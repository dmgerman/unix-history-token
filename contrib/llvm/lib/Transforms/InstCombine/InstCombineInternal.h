begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This file provides internal interfaces used to implement the InstCombine.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/AliasAnalysis.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/AssumptionCache.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/LoopInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ValueTracking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/InstVisitor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/PatternMatch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/InstCombine/InstCombineWorklist.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_TYPE
value|"instcombine"
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CallSite
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|MemIntrinsic
decl_stmt|;
name|class
name|MemSetInst
decl_stmt|;
comment|/// \brief Assign a complexity or rank value to LLVM Values.
comment|///
comment|/// This routine maps IR values to various complexity ranks:
comment|///   0 -> undef
comment|///   1 -> Constants
comment|///   2 -> Other non-instructions
comment|///   3 -> Arguments
comment|///   3 -> Unary operations
comment|///   4 -> Other instructions
specifier|static
specifier|inline
name|unsigned
name|getComplexity
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
block|{
if|if
condition|(
name|BinaryOperator
operator|::
name|isNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isFNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|isa
operator|<
name|Argument
operator|>
operator|(
name|V
operator|)
condition|)
return|return
literal|3
return|;
return|return
name|isa
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|?
operator|(
name|isa
operator|<
name|UndefValue
operator|>
operator|(
name|V
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
literal|2
return|;
block|}
comment|/// \brief Add one to a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|AddOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getAdd
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Subtract one from a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|SubOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getSub
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Return true if the specified value is free to invert (apply ~ to).
comment|/// This happens in cases where the ~ can be eliminated.  If WillInvertAllUses
comment|/// is true, work under the assumption that the caller intends to remove all
comment|/// uses of V and only keep uses of ~V.
comment|///
specifier|static
specifier|inline
name|bool
name|IsFreeToInvert
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|bool
name|WillInvertAllUses
parameter_list|)
block|{
comment|// ~(~(X)) -> X.
if|if
condition|(
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Constants can be considered to be not'ed values.
if|if
condition|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|true
return|;
comment|// Compares can be inverted if all of their uses are being modified to use the
comment|// ~V.
if|if
condition|(
name|isa
operator|<
name|CmpInst
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|WillInvertAllUses
return|;
comment|// If `V` is of the form `A + Constant` then `-1 - V` can be folded into `(-1
comment|// - Constant) - A` if we are willing to invert all of the uses.
if|if
condition|(
name|BinaryOperator
modifier|*
name|BO
init|=
name|dyn_cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BO
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Add
operator|||
name|BO
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
if|if
condition|(
name|isa
operator|<
name|Constant
operator|>
operator|(
name|BO
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
operator|||
name|isa
operator|<
name|Constant
operator|>
operator|(
name|BO
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
return|return
name|WillInvertAllUses
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Specific patterns of overflow check idioms that we match.
enum|enum
name|OverflowCheckFlavor
block|{
name|OCF_UNSIGNED_ADD
block|,
name|OCF_SIGNED_ADD
block|,
name|OCF_UNSIGNED_SUB
block|,
name|OCF_SIGNED_SUB
block|,
name|OCF_UNSIGNED_MUL
block|,
name|OCF_SIGNED_MUL
block|,
name|OCF_INVALID
block|}
enum|;
comment|/// \brief Returns the OverflowCheckFlavor corresponding to a overflow_with_op
comment|/// intrinsic.
specifier|static
specifier|inline
name|OverflowCheckFlavor
name|IntrinsicIDToOverflowCheckFlavor
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
switch|switch
condition|(
name|ID
condition|)
block|{
default|default:
return|return
name|OCF_INVALID
return|;
case|case
name|Intrinsic
operator|::
name|uadd_with_overflow
case|:
return|return
name|OCF_UNSIGNED_ADD
return|;
case|case
name|Intrinsic
operator|::
name|sadd_with_overflow
case|:
return|return
name|OCF_SIGNED_ADD
return|;
case|case
name|Intrinsic
operator|::
name|usub_with_overflow
case|:
return|return
name|OCF_UNSIGNED_SUB
return|;
case|case
name|Intrinsic
operator|::
name|ssub_with_overflow
case|:
return|return
name|OCF_SIGNED_SUB
return|;
case|case
name|Intrinsic
operator|::
name|umul_with_overflow
case|:
return|return
name|OCF_UNSIGNED_MUL
return|;
case|case
name|Intrinsic
operator|::
name|smul_with_overflow
case|:
return|return
name|OCF_SIGNED_MUL
return|;
block|}
block|}
comment|/// \brief An IRBuilder inserter that adds new instructions to the instcombine
comment|/// worklist.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombineIRInserter
range|:
name|public
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
block|{
name|InstCombineWorklist
operator|&
name|Worklist
block|;
name|AssumptionCache
operator|*
name|AC
block|;
name|public
operator|:
name|InstCombineIRInserter
argument_list|(
name|InstCombineWorklist
operator|&
name|WL
argument_list|,
name|AssumptionCache
operator|*
name|AC
argument_list|)
operator|:
name|Worklist
argument_list|(
name|WL
argument_list|)
block|,
name|AC
argument_list|(
argument|AC
argument_list|)
block|{}
name|void
name|InsertHelper
argument_list|(
argument|Instruction *I
argument_list|,
argument|const Twine&Name
argument_list|,
argument|BasicBlock *BB
argument_list|,
argument|BasicBlock::iterator InsertPt
argument_list|)
specifier|const
block|{
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
operator|::
name|InsertHelper
argument_list|(
name|I
argument_list|,
name|Name
argument_list|,
name|BB
argument_list|,
name|InsertPt
argument_list|)
block|;
name|Worklist
operator|.
name|Add
argument_list|(
name|I
argument_list|)
block|;
name|using
name|namespace
name|llvm
operator|::
name|PatternMatch
block|;
if|if
condition|(
name|match
argument_list|(
name|I
argument_list|,
name|m_Intrinsic
operator|<
name|Intrinsic
operator|::
name|assume
operator|>
operator|(
operator|)
argument_list|)
condition|)
name|AC
operator|->
name|registerAssumption
argument_list|(
name|cast
operator|<
name|CallInst
operator|>
operator|(
name|I
operator|)
argument_list|)
expr_stmt|;
block|}
expr|}
block|;
comment|/// \brief The core instruction combiner logic.
comment|///
comment|/// This class provides both the logic to recursively visit instructions and
comment|/// combine them, as well as the pass infrastructure for running this as part
comment|/// of the LLVM pass pipeline.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombiner
operator|:
name|public
name|InstVisitor
operator|<
name|InstCombiner
block|,
name|Instruction
operator|*
operator|>
block|{
comment|// FIXME: These members shouldn't be public.
name|public
operator|:
comment|/// \brief A worklist of the instructions that need to be simplified.
name|InstCombineWorklist
operator|&
name|Worklist
block|;
comment|/// \brief An IRBuilder that automatically inserts new instructions into the
comment|/// worklist.
typedef|typedef
name|IRBuilder
operator|<
name|true
operator|,
name|TargetFolder
operator|,
name|InstCombineIRInserter
operator|>
name|BuilderTy
expr_stmt|;
name|BuilderTy
operator|*
name|Builder
block|;
name|private
operator|:
comment|// Mode in which we are running the combiner.
specifier|const
name|bool
name|MinimizeSize
block|;
name|AliasAnalysis
operator|*
name|AA
block|;
comment|// Required analyses.
comment|// FIXME: These can never be null and should be references.
name|AssumptionCache
operator|*
name|AC
block|;
name|TargetLibraryInfo
operator|*
name|TLI
block|;
name|DominatorTree
operator|*
name|DT
block|;
specifier|const
name|DataLayout
operator|&
name|DL
block|;
comment|// Optional analyses. When non-null, these can both be used to do better
comment|// combining and will be updated to reflect any changes.
name|LoopInfo
operator|*
name|LI
block|;
name|bool
name|MadeIRChange
block|;
name|public
operator|:
name|InstCombiner
argument_list|(
argument|InstCombineWorklist&Worklist
argument_list|,
argument|BuilderTy *Builder
argument_list|,
argument|bool MinimizeSize
argument_list|,
argument|AliasAnalysis *AA
argument_list|,
argument|AssumptionCache *AC
argument_list|,
argument|TargetLibraryInfo *TLI
argument_list|,
argument|DominatorTree *DT
argument_list|,
argument|const DataLayout&DL
argument_list|,
argument|LoopInfo *LI
argument_list|)
operator|:
name|Worklist
argument_list|(
name|Worklist
argument_list|)
block|,
name|Builder
argument_list|(
name|Builder
argument_list|)
block|,
name|MinimizeSize
argument_list|(
name|MinimizeSize
argument_list|)
block|,
name|AA
argument_list|(
name|AA
argument_list|)
block|,
name|AC
argument_list|(
name|AC
argument_list|)
block|,
name|TLI
argument_list|(
name|TLI
argument_list|)
block|,
name|DT
argument_list|(
name|DT
argument_list|)
block|,
name|DL
argument_list|(
name|DL
argument_list|)
block|,
name|LI
argument_list|(
name|LI
argument_list|)
block|,
name|MadeIRChange
argument_list|(
argument|false
argument_list|)
block|{}
comment|/// \brief Run the combiner over the entire worklist until it is empty.
comment|///
comment|/// \returns true if the IR is changed.
name|bool
name|run
argument_list|()
block|;
name|AssumptionCache
operator|*
name|getAssumptionCache
argument_list|()
specifier|const
block|{
return|return
name|AC
return|;
block|}
specifier|const
name|DataLayout
operator|&
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|DL
return|;
block|}
name|DominatorTree
operator|*
name|getDominatorTree
argument_list|()
specifier|const
block|{
return|return
name|DT
return|;
block|}
name|LoopInfo
operator|*
name|getLoopInfo
argument_list|()
specifier|const
block|{
return|return
name|LI
return|;
block|}
name|TargetLibraryInfo
operator|*
name|getTargetLibraryInfo
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
comment|// Visitation implementation - Implement instruction combining for different
comment|// instruction types.  The semantics are as follows:
comment|// Return Value:
comment|//    null        - No change was made
comment|//     I          - Change was made, I is still valid, I may be dead though
comment|//   otherwise    - Change was made, replace I with returned instruction
comment|//
name|Instruction
operator|*
name|visitAdd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFAdd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|OptimizePointerDifference
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
block|;
name|Instruction
operator|*
name|visitSub
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFSub
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitMul
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|foldFMulConst
argument_list|(
name|Instruction
operator|*
name|FMulOrDiv
argument_list|,
name|Constant
operator|*
name|C
argument_list|,
name|Instruction
operator|*
name|InsertBefore
argument_list|)
block|;
name|Instruction
operator|*
name|visitFMul
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitURem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitSRem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFRem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|bool
name|SimplifyDivRemOfSelect
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonRemTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonIRemTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonDivTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonIDivTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitUDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitSDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|simplifyRangeCheck
argument_list|(
argument|ICmpInst *Cmp0
argument_list|,
argument|ICmpInst *Cmp1
argument_list|,
argument|bool Inverted
argument_list|)
block|;
name|Value
operator|*
name|FoldAndOfICmps
argument_list|(
name|ICmpInst
operator|*
name|LHS
argument_list|,
name|ICmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Value
operator|*
name|FoldAndOfFCmps
argument_list|(
name|FCmpInst
operator|*
name|LHS
argument_list|,
name|FCmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|visitAnd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|FoldOrOfICmps
argument_list|(
name|ICmpInst
operator|*
name|LHS
argument_list|,
name|ICmpInst
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|Value
operator|*
name|FoldOrOfFCmps
argument_list|(
name|FCmpInst
operator|*
name|LHS
argument_list|,
name|FCmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldOrWithConstants
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|Value
operator|*
name|B
argument_list|,
name|Value
operator|*
name|C
argument_list|)
block|;
name|Instruction
operator|*
name|FoldXorWithConstants
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|Value
operator|*
name|B
argument_list|,
name|Value
operator|*
name|C
argument_list|)
block|;
name|Instruction
operator|*
name|visitOr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitXor
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitShl
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitAShr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitLShr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonShiftTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|FoldFCmp_IntToFP_Cst
argument_list|(
name|FCmpInst
operator|&
name|I
argument_list|,
name|Instruction
operator|*
name|LHSI
argument_list|,
name|Constant
operator|*
name|RHSC
argument_list|)
block|;
name|Instruction
operator|*
name|FoldCmpLoadFromIndexedGlobal
argument_list|(
name|GetElementPtrInst
operator|*
name|GEP
argument_list|,
name|GlobalVariable
operator|*
name|GV
argument_list|,
name|CmpInst
operator|&
name|ICI
argument_list|,
name|ConstantInt
operator|*
name|AndCst
operator|=
name|nullptr
argument_list|)
block|;
name|Instruction
operator|*
name|visitFCmpInst
argument_list|(
name|FCmpInst
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInstWithCastAndCast
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInstWithInstAndIntCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|Instruction
operator|*
name|LHS
argument_list|,
name|ConstantInt
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpDivCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|BinaryOperator
operator|*
name|DivI
argument_list|,
name|ConstantInt
operator|*
name|DivRHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpShrCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|BinaryOperator
operator|*
name|DivI
argument_list|,
name|ConstantInt
operator|*
name|DivRHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpCstShrCst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|ConstantInt
operator|*
name|CI1
argument_list|,
name|ConstantInt
operator|*
name|CI2
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpCstShlCst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|ConstantInt
operator|*
name|CI1
argument_list|,
name|ConstantInt
operator|*
name|CI2
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpAddOpCst
argument_list|(
argument|Instruction&ICI
argument_list|,
argument|Value *X
argument_list|,
argument|ConstantInt *CI
argument_list|,
argument|ICmpInst::Predicate Pred
argument_list|)
block|;
name|Instruction
operator|*
name|FoldGEPICmp
argument_list|(
argument|GEPOperator *GEPLHS
argument_list|,
argument|Value *RHS
argument_list|,
argument|ICmpInst::Predicate Cond
argument_list|,
argument|Instruction&I
argument_list|)
block|;
name|Instruction
operator|*
name|FoldAllocaCmp
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|AllocaInst
operator|*
name|Alloca
argument_list|,
name|Value
operator|*
name|Other
argument_list|)
block|;
name|Instruction
operator|*
name|FoldShiftByConstant
argument_list|(
name|Value
operator|*
name|Op0
argument_list|,
name|Constant
operator|*
name|Op1
argument_list|,
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonCastTransforms
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|commonPointerCastTransforms
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitTrunc
argument_list|(
name|TruncInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitZExt
argument_list|(
name|ZExtInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSExt
argument_list|(
name|SExtInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPTrunc
argument_list|(
name|FPTruncInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPExt
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPToUI
argument_list|(
name|FPToUIInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPToSI
argument_list|(
name|FPToSIInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitUIToFP
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSIToFP
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitPtrToInt
argument_list|(
name|PtrToIntInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitIntToPtr
argument_list|(
name|IntToPtrInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitBitCast
argument_list|(
name|BitCastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitAddrSpaceCast
argument_list|(
name|AddrSpaceCastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSelectOpOp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|Instruction
operator|*
name|TI
argument_list|,
name|Instruction
operator|*
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSelectIntoOp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|Value
operator|*
argument_list|,
name|Value
operator|*
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSPFofSPF
argument_list|(
argument|Instruction *Inner
argument_list|,
argument|SelectPatternFlavor SPF1
argument_list|,
argument|Value *A
argument_list|,
argument|Value *B
argument_list|,
argument|Instruction&Outer
argument_list|,
argument|SelectPatternFlavor SPF2
argument_list|,
argument|Value *C
argument_list|)
block|;
name|Instruction
operator|*
name|FoldItoFPtoI
argument_list|(
name|Instruction
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSelectInst
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSelectInstWithICmp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|ICmpInst
operator|*
name|ICI
argument_list|)
block|;
name|Instruction
operator|*
name|visitCallInst
argument_list|(
name|CallInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitInvokeInst
argument_list|(
name|InvokeInst
operator|&
name|II
argument_list|)
block|;
name|Instruction
operator|*
name|SliceUpIllegalIntegerPHI
argument_list|(
name|PHINode
operator|&
name|PN
argument_list|)
block|;
name|Instruction
operator|*
name|visitPHINode
argument_list|(
name|PHINode
operator|&
name|PN
argument_list|)
block|;
name|Instruction
operator|*
name|visitGetElementPtrInst
argument_list|(
name|GetElementPtrInst
operator|&
name|GEP
argument_list|)
block|;
name|Instruction
operator|*
name|visitAllocaInst
argument_list|(
name|AllocaInst
operator|&
name|AI
argument_list|)
block|;
name|Instruction
operator|*
name|visitAllocSite
argument_list|(
name|Instruction
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFree
argument_list|(
name|CallInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitLoadInst
argument_list|(
name|LoadInst
operator|&
name|LI
argument_list|)
block|;
name|Instruction
operator|*
name|visitStoreInst
argument_list|(
name|StoreInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitBranchInst
argument_list|(
name|BranchInst
operator|&
name|BI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSwitchInst
argument_list|(
name|SwitchInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitReturnInst
argument_list|(
name|ReturnInst
operator|&
name|RI
argument_list|)
block|;
name|Instruction
operator|*
name|visitInsertValueInst
argument_list|(
name|InsertValueInst
operator|&
name|IV
argument_list|)
block|;
name|Instruction
operator|*
name|visitInsertElementInst
argument_list|(
name|InsertElementInst
operator|&
name|IE
argument_list|)
block|;
name|Instruction
operator|*
name|visitExtractElementInst
argument_list|(
name|ExtractElementInst
operator|&
name|EI
argument_list|)
block|;
name|Instruction
operator|*
name|visitShuffleVectorInst
argument_list|(
name|ShuffleVectorInst
operator|&
name|SVI
argument_list|)
block|;
name|Instruction
operator|*
name|visitExtractValueInst
argument_list|(
name|ExtractValueInst
operator|&
name|EV
argument_list|)
block|;
name|Instruction
operator|*
name|visitLandingPadInst
argument_list|(
name|LandingPadInst
operator|&
name|LI
argument_list|)
block|;
comment|// visitInstruction - Specify what to return for unhandled instructions...
name|Instruction
operator|*
name|visitInstruction
argument_list|(
argument|Instruction&I
argument_list|)
block|{
return|return
name|nullptr
return|;
block|}
comment|// True when DB dominates all uses of DI execpt UI.
comment|// UI must be in the same block as DI.
comment|// The routine checks that the DI parent and DB are different.
name|bool
name|dominatesAllUses
argument_list|(
argument|const Instruction *DI
argument_list|,
argument|const Instruction *UI
argument_list|,
argument|const BasicBlock *DB
argument_list|)
specifier|const
block|;
comment|// Replace select with select operand SIOpd in SI-ICmp sequence when possible
name|bool
name|replacedSelectWithOperand
argument_list|(
argument|SelectInst *SI
argument_list|,
argument|const ICmpInst *Icmp
argument_list|,
argument|const unsigned SIOpd
argument_list|)
block|;
name|private
operator|:
name|bool
name|ShouldChangeType
argument_list|(
argument|unsigned FromBitWidth
argument_list|,
argument|unsigned ToBitWidth
argument_list|)
specifier|const
block|;
name|bool
name|ShouldChangeType
argument_list|(
argument|Type *From
argument_list|,
argument|Type *To
argument_list|)
specifier|const
block|;
name|Value
operator|*
name|dyn_castNegVal
argument_list|(
argument|Value *V
argument_list|)
specifier|const
block|;
name|Value
operator|*
name|dyn_castFNegVal
argument_list|(
argument|Value *V
argument_list|,
argument|bool NoSignedZero = false
argument_list|)
specifier|const
block|;
name|Type
operator|*
name|FindElementAtOffset
argument_list|(
argument|PointerType *PtrTy
argument_list|,
argument|int64_t Offset
argument_list|,
argument|SmallVectorImpl<Value *>&NewIndices
argument_list|)
block|;
name|Instruction
operator|*
name|FoldOpIntoSelect
argument_list|(
name|Instruction
operator|&
name|Op
argument_list|,
name|SelectInst
operator|*
name|SI
argument_list|)
block|;
comment|/// \brief Classify whether a cast is worth optimizing.
comment|///
comment|/// Returns true if the cast from "V to Ty" actually results in any code
comment|/// being generated and is interesting to optimize out. If the cast can be
comment|/// eliminated by some other simple transformation, we prefer to do the
comment|/// simplification first.
name|bool
name|ShouldOptimizeCast
argument_list|(
argument|Instruction::CastOps opcode
argument_list|,
argument|const Value *V
argument_list|,
argument|Type *Ty
argument_list|)
block|;
comment|/// \brief Try to optimize a sequence of instructions checking if an operation
comment|/// on LHS and RHS overflows.
comment|///
comment|/// If this overflow check is done via one of the overflow check intrinsics,
comment|/// then CtxI has to be the call instruction calling that intrinsic.  If this
comment|/// overflow check is done by arithmetic followed by a compare, then CtxI has
comment|/// to be the arithmetic instruction.
comment|///
comment|/// If a simplification is possible, stores the simplified result of the
comment|/// operation in OperationResult and result of the overflow check in
comment|/// OverflowResult, and return true.  If no simplification is possible,
comment|/// returns false.
name|bool
name|OptimizeOverflowCheck
argument_list|(
argument|OverflowCheckFlavor OCF
argument_list|,
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|,
argument|Instruction&CtxI
argument_list|,
argument|Value *&OperationResult
argument_list|,
argument|Constant *&OverflowResult
argument_list|)
block|;
name|Instruction
operator|*
name|visitCallSite
argument_list|(
argument|CallSite CS
argument_list|)
block|;
name|Instruction
operator|*
name|tryOptimizeCall
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|)
block|;
name|bool
name|transformConstExprCastCall
argument_list|(
argument|CallSite CS
argument_list|)
block|;
name|Instruction
operator|*
name|transformCallThroughTrampoline
argument_list|(
argument|CallSite CS
argument_list|,
argument|IntrinsicInst *Tramp
argument_list|)
block|;
name|Instruction
operator|*
name|transformZExtICmp
argument_list|(
argument|ICmpInst *ICI
argument_list|,
argument|Instruction&CI
argument_list|,
argument|bool DoXform = true
argument_list|)
block|;
name|Instruction
operator|*
name|transformSExtICmp
argument_list|(
name|ICmpInst
operator|*
name|ICI
argument_list|,
name|Instruction
operator|&
name|CI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedAdd
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|&
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedSub
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|&
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowUnsignedSub
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|&
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedMul
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|&
name|CxtI
argument_list|)
block|;
name|Value
operator|*
name|EmitGEPOffset
argument_list|(
name|User
operator|*
name|GEP
argument_list|)
block|;
name|Instruction
operator|*
name|scalarizePHI
argument_list|(
name|ExtractElementInst
operator|&
name|EI
argument_list|,
name|PHINode
operator|*
name|PN
argument_list|)
block|;
name|Value
operator|*
name|EvaluateInDifferentElementOrder
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|ArrayRef
operator|<
name|int
operator|>
name|Mask
argument_list|)
block|;
name|public
operator|:
comment|/// \brief Inserts an instruction \p New before instruction \p Old
comment|///
comment|/// Also adds the new instruction to the worklist and returns \p New so that
comment|/// it is suitable for use as the return from the visitation patterns.
name|Instruction
operator|*
name|InsertNewInstBefore
argument_list|(
argument|Instruction *New
argument_list|,
argument|Instruction&Old
argument_list|)
block|{
name|assert
argument_list|(
name|New
operator|&&
operator|!
name|New
operator|->
name|getParent
argument_list|()
operator|&&
literal|"New instruction already inserted into a basic block!"
argument_list|)
block|;
name|BasicBlock
operator|*
name|BB
operator|=
name|Old
operator|.
name|getParent
argument_list|()
block|;
name|BB
operator|->
name|getInstList
argument_list|()
operator|.
name|insert
argument_list|(
name|Old
operator|.
name|getIterator
argument_list|()
argument_list|,
name|New
argument_list|)
block|;
comment|// Insert inst
name|Worklist
operator|.
name|Add
argument_list|(
name|New
argument_list|)
block|;
return|return
name|New
return|;
block|}
comment|/// \brief Same as InsertNewInstBefore, but also sets the debug loc.
name|Instruction
operator|*
name|InsertNewInstWith
argument_list|(
argument|Instruction *New
argument_list|,
argument|Instruction&Old
argument_list|)
block|{
name|New
operator|->
name|setDebugLoc
argument_list|(
name|Old
operator|.
name|getDebugLoc
argument_list|()
argument_list|)
block|;
return|return
name|InsertNewInstBefore
argument_list|(
name|New
argument_list|,
name|Old
argument_list|)
return|;
block|}
comment|/// \brief A combiner-aware RAUW-like routine.
comment|///
comment|/// This method is to be used when an instruction is found to be dead,
comment|/// replaceable with another preexisting expression. Here we add all uses of
comment|/// I to the worklist, replace all uses of I with the new value, then return
comment|/// I, so that the inst combiner will know that I was modified.
name|Instruction
operator|*
name|ReplaceInstUsesWith
argument_list|(
argument|Instruction&I
argument_list|,
argument|Value *V
argument_list|)
block|{
comment|// If there are no uses to replace, then we return nullptr to indicate that
comment|// no changes were made to the program.
if|if
condition|(
name|I
operator|.
name|use_empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|Worklist
operator|.
name|AddUsersToWorkList
argument_list|(
name|I
argument_list|)
block|;
comment|// Add all modified instrs to worklist.
comment|// If we are replacing the instruction with itself, this must be in a
comment|// segment of unreachable code, so just clobber the instruction.
if|if
condition|(
operator|&
name|I
operator|==
name|V
condition|)
name|V
operator|=
name|UndefValue
operator|::
name|get
argument_list|(
name|I
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: Replacing "
operator|<<
name|I
operator|<<
literal|"\n"
operator|<<
literal|"    with "
operator|<<
operator|*
name|V
operator|<<
literal|'\n'
argument_list|)
decl_stmt|;
name|I
operator|.
name|replaceAllUsesWith
argument_list|(
name|V
argument_list|)
expr_stmt|;
return|return
operator|&
name|I
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Creates a result tuple for an overflow intrinsic \p II with a given
end_comment

begin_comment
comment|/// \p Result and a constant \p Overflow value.
end_comment

begin_function
name|Instruction
modifier|*
name|CreateOverflowTuple
parameter_list|(
name|IntrinsicInst
modifier|*
name|II
parameter_list|,
name|Value
modifier|*
name|Result
parameter_list|,
name|Constant
modifier|*
name|Overflow
parameter_list|)
block|{
name|Constant
modifier|*
name|V
index|[]
init|=
block|{
name|UndefValue
operator|::
name|get
argument_list|(
name|Result
operator|->
name|getType
argument_list|()
argument_list|)
block|,
name|Overflow
block|}
decl_stmt|;
name|StructType
modifier|*
name|ST
init|=
name|cast
operator|<
name|StructType
operator|>
operator|(
name|II
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Constant
modifier|*
name|Struct
init|=
name|ConstantStruct
operator|::
name|get
argument_list|(
name|ST
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|InsertValueInst
operator|::
name|Create
argument_list|(
name|Struct
argument_list|,
name|Result
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Combiner aware instruction erasure.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// When dealing with an instruction that has side effects or produces a void
end_comment

begin_comment
comment|/// value, we can't rely on DCE to delete the instruction. Instead, visit
end_comment

begin_comment
comment|/// methods should return the value returned by this function.
end_comment

begin_function
name|Instruction
modifier|*
name|EraseInstFromFunction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: ERASE "
operator|<<
name|I
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|.
name|use_empty
argument_list|()
operator|&&
literal|"Cannot erase instruction that is used!"
argument_list|)
expr_stmt|;
comment|// Make sure that we reprocess all operands now that we reduced their
comment|// use counts.
if|if
condition|(
name|I
operator|.
name|getNumOperands
argument_list|()
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|User
operator|::
name|op_iterator
name|i
operator|=
name|I
operator|.
name|op_begin
argument_list|()
operator|,
name|e
operator|=
name|I
operator|.
name|op_end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Instruction
modifier|*
name|Op
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
operator|*
name|i
operator|)
condition|)
name|Worklist
operator|.
name|Add
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
name|Worklist
operator|.
name|Remove
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|I
operator|.
name|eraseFromParent
argument_list|()
expr_stmt|;
name|MadeIRChange
operator|=
name|true
expr_stmt|;
return|return
name|nullptr
return|;
comment|// Don't do anything with FI
block|}
end_function

begin_decl_stmt
name|void
name|computeKnownBits
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|computeKnownBits
argument_list|(
name|V
argument_list|,
name|KnownZero
argument_list|,
name|KnownOne
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|MaskedValueIsZero
argument_list|(
name|Value
operator|*
name|V
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|MaskedValueIsZero
argument_list|(
name|V
argument_list|,
name|Mask
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|Value
operator|*
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeNumSignBits
argument_list|(
name|Op
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|ComputeSignBit
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|bool
operator|&
name|KnownZero
argument_list|,
name|bool
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeSignBit
argument_list|(
name|V
argument_list|,
name|KnownZero
argument_list|,
name|KnownOne
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|OverflowResult
name|computeOverflowForUnsignedMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_function

begin_function
name|OverflowResult
name|computeOverflowForUnsignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|/// \brief Performs a few simplifications for operators which are associative
end_comment

begin_comment
comment|/// or commutative.
end_comment

begin_function_decl
name|bool
name|SimplifyAssociativeOrCommutative
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Tries to simplify binary operations which some other binary
end_comment

begin_comment
comment|/// operation distributes over.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// It does this by either by factorizing out common terms (eg "(A*B)+(A*C)"
end_comment

begin_comment
comment|/// -> "A*(B+C)") or expanding out if this results in simplifications (eg: "A
end_comment

begin_comment
comment|///& (B | C) -> (A&B) | (A&C)" if this is a win).  Returns the simplified
end_comment

begin_comment
comment|/// value, or null if it didn't simplify.
end_comment

begin_function_decl
name|Value
modifier|*
name|SimplifyUsingDistributiveLaws
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Attempts to replace V with a simpler value based on the demanded
end_comment

begin_comment
comment|/// bits.
end_comment

begin_function_decl
name|Value
modifier|*
name|SimplifyDemandedUseBits
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
parameter_list|,
name|Instruction
modifier|*
name|CxtI
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|SimplifyDemandedBits
parameter_list|(
name|Use
modifier|&
name|U
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded
end_comment

begin_comment
comment|/// bit for "r1 = shr x, c1; r2 = shl r1, c2" instruction sequence.
end_comment

begin_function_decl
name|Value
modifier|*
name|SimplifyShrShlDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|Lsr
parameter_list|,
name|Instruction
modifier|*
name|Sftl
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Tries to simplify operands to an integer instruction based on its
end_comment

begin_comment
comment|/// demanded bits.
end_comment

begin_function_decl
name|bool
name|SimplifyDemandedInstructionBits
parameter_list|(
name|Instruction
modifier|&
name|Inst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|SimplifyDemandedVectorElts
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedElts
parameter_list|,
name|APInt
modifier|&
name|UndefElts
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|SimplifyVectorOp
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|SimplifyBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// FoldOpIntoPhi - Given a binary operator, cast instruction, or select
end_comment

begin_comment
comment|// which has a PHI node as operand #0, see if we can fold the instruction
end_comment

begin_comment
comment|// into the PHI (which is only possible if all operands to the PHI are
end_comment

begin_comment
comment|// constants).
end_comment

begin_comment
comment|//
end_comment

begin_function_decl
name|Instruction
modifier|*
name|FoldOpIntoPhi
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Try to rotate an operation below a PHI node, using PHI nodes for
end_comment

begin_comment
comment|/// its operands.
end_comment

begin_function_decl
name|Instruction
modifier|*
name|FoldPHIArgOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|FoldPHIArgBinOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|FoldPHIArgGEPIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|FoldPHIArgLoadIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|FoldPHIArgZextsIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|OptAndOp
parameter_list|(
name|Instruction
modifier|*
name|Op
parameter_list|,
name|ConstantInt
modifier|*
name|OpRHS
parameter_list|,
name|ConstantInt
modifier|*
name|AndRHS
parameter_list|,
name|BinaryOperator
modifier|&
name|TheAnd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|FoldLogicalPlusAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|ConstantInt
modifier|*
name|Mask
parameter_list|,
name|bool
name|isSub
parameter_list|,
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|InsertRangeTest
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Constant
modifier|*
name|Lo
parameter_list|,
name|Constant
modifier|*
name|Hi
parameter_list|,
name|bool
name|isSigned
parameter_list|,
name|bool
name|Inside
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|PromoteCastOfAllocation
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|,
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|MatchBSwapOrBitReverse
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|SimplifyStoreAtEndOfBlock
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|SimplifyMemTransfer
parameter_list|(
name|MemIntrinsic
modifier|*
name|MI
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Instruction
modifier|*
name|SimplifyMemSet
parameter_list|(
name|MemSetInst
modifier|*
name|MI
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Value
modifier|*
name|EvaluateInDifferentType
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|isSigned
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Returns a value X such that Val = X * Scale, or null if none.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If the multiplication is known not to overflow then NoSignedWrap is set.
end_comment

begin_function_decl
name|Value
modifier|*
name|Descale
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|APInt
name|Scale
parameter_list|,
name|bool
modifier|&
name|NoSignedWrap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};  }
comment|// end namespace llvm.
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

