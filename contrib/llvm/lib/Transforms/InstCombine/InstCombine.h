begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstCombine.h - Main InstCombine pass definition ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSTCOMBINE_INSTCOMBINE_H
end_ifndef

begin_define
define|#
directive|define
name|INSTCOMBINE_INSTCOMBINE_H
end_define

begin_include
include|#
directive|include
file|"InstCombineWorklist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ValueTracking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/InstVisitor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/TargetFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/Utils/SimplifyLibCalls.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CallSite
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|MemIntrinsic
decl_stmt|;
name|class
name|MemSetInst
decl_stmt|;
comment|/// SelectPatternFlavor - We can match a variety of different patterns for
comment|/// select operations.
enum|enum
name|SelectPatternFlavor
block|{
name|SPF_UNKNOWN
init|=
literal|0
block|,
name|SPF_SMIN
block|,
name|SPF_UMIN
block|,
name|SPF_SMAX
block|,
name|SPF_UMAX
comment|//SPF_ABS - TODO.
block|}
enum|;
comment|/// getComplexity:  Assign a complexity or rank value to LLVM Values...
comment|///   0 -> undef, 1 -> Const, 2 -> Other, 3 -> Arg, 3 -> Unary, 4 -> OtherInst
specifier|static
specifier|inline
name|unsigned
name|getComplexity
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
block|{
if|if
condition|(
name|BinaryOperator
operator|::
name|isNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isFNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|isa
operator|<
name|Argument
operator|>
operator|(
name|V
operator|)
condition|)
return|return
literal|3
return|;
return|return
name|isa
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|?
operator|(
name|isa
operator|<
name|UndefValue
operator|>
operator|(
name|V
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
literal|2
return|;
block|}
comment|/// InstCombineIRInserter - This is an IRBuilder insertion helper that works
comment|/// just like the normal insertion helper, but also adds any new instructions
comment|/// to the instcombine worklist.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombineIRInserter
range|:
name|public
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
block|{
name|InstCombineWorklist
operator|&
name|Worklist
block|;
name|public
operator|:
name|InstCombineIRInserter
argument_list|(
name|InstCombineWorklist
operator|&
name|WL
argument_list|)
operator|:
name|Worklist
argument_list|(
argument|WL
argument_list|)
block|{}
name|void
name|InsertHelper
argument_list|(
argument|Instruction *I
argument_list|,
argument|const Twine&Name
argument_list|,
argument|BasicBlock *BB
argument_list|,
argument|BasicBlock::iterator InsertPt
argument_list|)
specifier|const
block|{
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
operator|::
name|InsertHelper
argument_list|(
name|I
argument_list|,
name|Name
argument_list|,
name|BB
argument_list|,
name|InsertPt
argument_list|)
block|;
name|Worklist
operator|.
name|Add
argument_list|(
name|I
argument_list|)
block|;   }
block|}
decl_stmt|;
comment|/// InstCombiner - The -instcombine pass.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombiner
range|:
name|public
name|FunctionPass
decl_stmt|,
name|public
name|InstVisitor
decl|<
name|InstCombiner
decl_stmt|,
name|Instruction
modifier|*
decl|>
block|{
name|DataLayout
modifier|*
name|TD
decl_stmt|;
name|TargetLibraryInfo
modifier|*
name|TLI
decl_stmt|;
name|bool
name|MadeIRChange
decl_stmt|;
name|LibCallSimplifier
modifier|*
name|Simplifier
decl_stmt|;
name|bool
name|MinimizeSize
decl_stmt|;
name|public
label|:
comment|/// Worklist - All of the instructions that need to be simplified.
name|InstCombineWorklist
name|Worklist
decl_stmt|;
comment|/// Builder - This is an IRBuilder that automatically inserts new
comment|/// instructions into the worklist when they are created.
typedef|typedef
name|IRBuilder
operator|<
name|true
operator|,
name|TargetFolder
operator|,
name|InstCombineIRInserter
operator|>
name|BuilderTy
expr_stmt|;
name|BuilderTy
modifier|*
name|Builder
decl_stmt|;
specifier|static
name|char
name|ID
decl_stmt|;
comment|// Pass identification, replacement for typeid
name|InstCombiner
argument_list|()
operator|:
name|FunctionPass
argument_list|(
name|ID
argument_list|)
operator|,
name|TD
argument_list|(
literal|0
argument_list|)
operator|,
name|Builder
argument_list|(
literal|0
argument_list|)
block|{
name|MinimizeSize
operator|=
name|false
block|;
name|initializeInstCombinerPass
argument_list|(
operator|*
name|PassRegistry
operator|::
name|getPassRegistry
argument_list|()
argument_list|)
block|;   }
name|public
operator|:
name|virtual
name|bool
name|runOnFunction
argument_list|(
name|Function
operator|&
name|F
argument_list|)
expr_stmt|;
name|bool
name|DoOneIteration
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|,
name|unsigned
name|ItNum
parameter_list|)
function_decl|;
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
decl_stmt|;
name|DataLayout
operator|*
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|TD
return|;
block|}
name|TargetLibraryInfo
operator|*
name|getTargetLibraryInfo
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
comment|// Visitation implementation - Implement instruction combining for different
comment|// instruction types.  The semantics are as follows:
comment|// Return Value:
comment|//    null        - No change was made
comment|//     I          - Change was made, I is still valid, I may be dead though
comment|//   otherwise    - Change was made, replace I with returned instruction
comment|//
name|Instruction
modifier|*
name|visitAdd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFAdd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|OptimizePointerDifference
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSub
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFSub
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitMul
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|foldFMulConst
parameter_list|(
name|Instruction
modifier|*
name|FMulOrDiv
parameter_list|,
name|ConstantFP
modifier|*
name|C
parameter_list|,
name|Instruction
modifier|*
name|InsertBefore
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFMul
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitURem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSRem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFRem
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|SimplifyDivRemOfSelect
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonRemTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonIRemTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonDivTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonIDivTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitUDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFDiv
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldAndOfICmps
parameter_list|(
name|ICmpInst
modifier|*
name|LHS
parameter_list|,
name|ICmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldAndOfFCmps
parameter_list|(
name|FCmpInst
modifier|*
name|LHS
parameter_list|,
name|FCmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAnd
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldOrOfICmps
parameter_list|(
name|ICmpInst
modifier|*
name|LHS
parameter_list|,
name|ICmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldOrOfFCmps
parameter_list|(
name|FCmpInst
modifier|*
name|LHS
parameter_list|,
name|FCmpInst
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldOrWithConstants
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|Op
parameter_list|,
name|Value
modifier|*
name|A
parameter_list|,
name|Value
modifier|*
name|B
parameter_list|,
name|Value
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitOr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitXor
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitShl
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAShr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLShr
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonShiftTransforms
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldFCmp_IntToFP_Cst
parameter_list|(
name|FCmpInst
modifier|&
name|I
parameter_list|,
name|Instruction
modifier|*
name|LHSI
parameter_list|,
name|Constant
modifier|*
name|RHSC
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldCmpLoadFromIndexedGlobal
parameter_list|(
name|GetElementPtrInst
modifier|*
name|GEP
parameter_list|,
name|GlobalVariable
modifier|*
name|GV
parameter_list|,
name|CmpInst
modifier|&
name|ICI
parameter_list|,
name|ConstantInt
modifier|*
name|AndCst
init|=
literal|0
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFCmpInst
parameter_list|(
name|FCmpInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitICmpInst
parameter_list|(
name|ICmpInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitICmpInstWithCastAndCast
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitICmpInstWithInstAndIntCst
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|,
name|Instruction
modifier|*
name|LHS
parameter_list|,
name|ConstantInt
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldICmpDivCst
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|,
name|BinaryOperator
modifier|*
name|DivI
parameter_list|,
name|ConstantInt
modifier|*
name|DivRHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldICmpShrCst
parameter_list|(
name|ICmpInst
modifier|&
name|ICI
parameter_list|,
name|BinaryOperator
modifier|*
name|DivI
parameter_list|,
name|ConstantInt
modifier|*
name|DivRHS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldICmpAddOpCst
argument_list|(
name|Instruction
operator|&
name|ICI
argument_list|,
name|Value
operator|*
name|X
argument_list|,
name|ConstantInt
operator|*
name|CI
argument_list|,
name|ICmpInst
operator|::
name|Predicate
name|Pred
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|FoldGEPICmp
argument_list|(
name|GEPOperator
operator|*
name|GEPLHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|ICmpInst
operator|::
name|Predicate
name|Cond
argument_list|,
name|Instruction
operator|&
name|I
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|FoldShiftByConstant
parameter_list|(
name|Value
modifier|*
name|Op0
parameter_list|,
name|ConstantInt
modifier|*
name|Op1
parameter_list|,
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonCastTransforms
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|commonPointerCastTransforms
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitTrunc
parameter_list|(
name|TruncInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitZExt
parameter_list|(
name|ZExtInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSExt
parameter_list|(
name|SExtInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPTrunc
parameter_list|(
name|FPTruncInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPExt
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPToUI
parameter_list|(
name|FPToUIInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFPToSI
parameter_list|(
name|FPToSIInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitUIToFP
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSIToFP
parameter_list|(
name|CastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitPtrToInt
parameter_list|(
name|PtrToIntInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitIntToPtr
parameter_list|(
name|IntToPtrInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitBitCast
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAddrSpaceCast
parameter_list|(
name|AddrSpaceCastInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldSelectOpOp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|Instruction
modifier|*
name|TI
parameter_list|,
name|Instruction
modifier|*
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldSelectIntoOp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|Value
modifier|*
parameter_list|,
name|Value
modifier|*
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldSPFofSPF
parameter_list|(
name|Instruction
modifier|*
name|Inner
parameter_list|,
name|SelectPatternFlavor
name|SPF1
parameter_list|,
name|Value
modifier|*
name|A
parameter_list|,
name|Value
modifier|*
name|B
parameter_list|,
name|Instruction
modifier|&
name|Outer
parameter_list|,
name|SelectPatternFlavor
name|SPF2
parameter_list|,
name|Value
modifier|*
name|C
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSelectInst
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSelectInstWithICmp
parameter_list|(
name|SelectInst
modifier|&
name|SI
parameter_list|,
name|ICmpInst
modifier|*
name|ICI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitCallInst
parameter_list|(
name|CallInst
modifier|&
name|CI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitInvokeInst
parameter_list|(
name|InvokeInst
modifier|&
name|II
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SliceUpIllegalIntegerPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitPHINode
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitGetElementPtrInst
parameter_list|(
name|GetElementPtrInst
modifier|&
name|GEP
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAllocaInst
parameter_list|(
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitAllocSite
parameter_list|(
name|Instruction
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitFree
parameter_list|(
name|CallInst
modifier|&
name|FI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLoadInst
parameter_list|(
name|LoadInst
modifier|&
name|LI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitStoreInst
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitBranchInst
parameter_list|(
name|BranchInst
modifier|&
name|BI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitSwitchInst
parameter_list|(
name|SwitchInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitInsertElementInst
parameter_list|(
name|InsertElementInst
modifier|&
name|IE
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitExtractElementInst
parameter_list|(
name|ExtractElementInst
modifier|&
name|EI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitShuffleVectorInst
parameter_list|(
name|ShuffleVectorInst
modifier|&
name|SVI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitExtractValueInst
parameter_list|(
name|ExtractValueInst
modifier|&
name|EV
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|visitLandingPadInst
parameter_list|(
name|LandingPadInst
modifier|&
name|LI
parameter_list|)
function_decl|;
comment|// visitInstruction - Specify what to return for unhandled instructions...
name|Instruction
modifier|*
name|visitInstruction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|private
label|:
name|bool
name|ShouldChangeType
argument_list|(
name|Type
operator|*
name|From
argument_list|,
name|Type
operator|*
name|To
argument_list|)
decl|const
decl_stmt|;
name|Value
modifier|*
name|dyn_castNegVal
argument_list|(
name|Value
operator|*
name|V
argument_list|)
decl|const
decl_stmt|;
name|Value
modifier|*
name|dyn_castFNegVal
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|bool
name|NoSignedZero
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|Type
modifier|*
name|FindElementAtOffset
argument_list|(
name|Type
operator|*
name|PtrTy
argument_list|,
name|int64_t
name|Offset
argument_list|,
name|SmallVectorImpl
operator|<
name|Value
operator|*
operator|>
operator|&
name|NewIndices
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|FoldOpIntoSelect
parameter_list|(
name|Instruction
modifier|&
name|Op
parameter_list|,
name|SelectInst
modifier|*
name|SI
parameter_list|)
function_decl|;
comment|/// ShouldOptimizeCast - Return true if the cast from "V to Ty" actually
comment|/// results in any code being generated and is interesting to optimize out. If
comment|/// the cast can be eliminated by some other simple transformation, we prefer
comment|/// to do the simplification first.
name|bool
name|ShouldOptimizeCast
argument_list|(
name|Instruction
operator|::
name|CastOps
name|opcode
argument_list|,
specifier|const
name|Value
operator|*
name|V
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
decl_stmt|;
name|Instruction
modifier|*
name|visitCallSite
parameter_list|(
name|CallSite
name|CS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|tryOptimizeCall
parameter_list|(
name|CallInst
modifier|*
name|CI
parameter_list|,
specifier|const
name|DataLayout
modifier|*
name|TD
parameter_list|)
function_decl|;
name|bool
name|transformConstExprCastCall
parameter_list|(
name|CallSite
name|CS
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|transformCallThroughTrampoline
parameter_list|(
name|CallSite
name|CS
parameter_list|,
name|IntrinsicInst
modifier|*
name|Tramp
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|transformZExtICmp
parameter_list|(
name|ICmpInst
modifier|*
name|ICI
parameter_list|,
name|Instruction
modifier|&
name|CI
parameter_list|,
name|bool
name|DoXform
init|=
name|true
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|transformSExtICmp
parameter_list|(
name|ICmpInst
modifier|*
name|ICI
parameter_list|,
name|Instruction
modifier|&
name|CI
parameter_list|)
function_decl|;
name|bool
name|WillNotOverflowSignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EmitGEPOffset
parameter_list|(
name|User
modifier|*
name|GEP
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|scalarizePHI
parameter_list|(
name|ExtractElementInst
modifier|&
name|EI
parameter_list|,
name|PHINode
modifier|*
name|PN
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EvaluateInDifferentElementOrder
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|ArrayRef
operator|<
name|int
operator|>
name|Mask
argument_list|)
decl_stmt|;
name|public
label|:
comment|// InsertNewInstBefore - insert an instruction New before instruction Old
comment|// in the program.  Add the new instruction to the worklist.
comment|//
name|Instruction
modifier|*
name|InsertNewInstBefore
parameter_list|(
name|Instruction
modifier|*
name|New
parameter_list|,
name|Instruction
modifier|&
name|Old
parameter_list|)
block|{
name|assert
argument_list|(
name|New
operator|&&
name|New
operator|->
name|getParent
argument_list|()
operator|==
literal|0
operator|&&
literal|"New instruction already inserted into a basic block!"
argument_list|)
expr_stmt|;
name|BasicBlock
modifier|*
name|BB
init|=
name|Old
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|BB
operator|->
name|getInstList
argument_list|()
operator|.
name|insert
argument_list|(
operator|&
name|Old
argument_list|,
name|New
argument_list|)
expr_stmt|;
comment|// Insert inst
name|Worklist
operator|.
name|Add
argument_list|(
name|New
argument_list|)
expr_stmt|;
return|return
name|New
return|;
block|}
comment|// InsertNewInstWith - same as InsertNewInstBefore, but also sets the
comment|// debug loc.
comment|//
name|Instruction
modifier|*
name|InsertNewInstWith
parameter_list|(
name|Instruction
modifier|*
name|New
parameter_list|,
name|Instruction
modifier|&
name|Old
parameter_list|)
block|{
name|New
operator|->
name|setDebugLoc
argument_list|(
name|Old
operator|.
name|getDebugLoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|InsertNewInstBefore
argument_list|(
name|New
argument_list|,
name|Old
argument_list|)
return|;
block|}
comment|// ReplaceInstUsesWith - This method is to be used when an instruction is
comment|// found to be dead, replacable with another preexisting expression.  Here
comment|// we add all uses of I to the worklist, replace all uses of I with the new
comment|// value, then return I, so that the inst combiner will know that I was
comment|// modified.
comment|//
name|Instruction
modifier|*
name|ReplaceInstUsesWith
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|,
name|Value
modifier|*
name|V
parameter_list|)
block|{
name|Worklist
operator|.
name|AddUsersToWorkList
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Add all modified instrs to worklist.
comment|// If we are replacing the instruction with itself, this must be in a
comment|// segment of unreachable code, so just clobber the instruction.
if|if
condition|(
operator|&
name|I
operator|==
name|V
condition|)
name|V
operator|=
name|UndefValue
operator|::
name|get
argument_list|(
name|I
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: Replacing "
operator|<<
name|I
operator|<<
literal|"\n"
literal|"    with "
operator|<<
operator|*
name|V
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|I
operator|.
name|replaceAllUsesWith
argument_list|(
name|V
argument_list|)
expr_stmt|;
return|return
operator|&
name|I
return|;
block|}
comment|// EraseInstFromFunction - When dealing with an instruction that has side
comment|// effects or produces a void value, we can't rely on DCE to delete the
comment|// instruction.  Instead, visit methods should return the value returned by
comment|// this function.
name|Instruction
modifier|*
name|EraseInstFromFunction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: ERASE "
operator|<<
name|I
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|.
name|use_empty
argument_list|()
operator|&&
literal|"Cannot erase instruction that is used!"
argument_list|)
expr_stmt|;
comment|// Make sure that we reprocess all operands now that we reduced their
comment|// use counts.
if|if
condition|(
name|I
operator|.
name|getNumOperands
argument_list|()
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|User
operator|::
name|op_iterator
name|i
operator|=
name|I
operator|.
name|op_begin
argument_list|()
operator|,
name|e
operator|=
name|I
operator|.
name|op_end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Instruction
modifier|*
name|Op
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
operator|*
name|i
operator|)
condition|)
name|Worklist
operator|.
name|Add
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
name|Worklist
operator|.
name|Remove
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|I
operator|.
name|eraseFromParent
argument_list|()
expr_stmt|;
name|MadeIRChange
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
comment|// Don't do anything with FI
block|}
name|void
name|ComputeMaskedBits
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeMaskedBits
argument_list|(
name|V
argument_list|,
name|KnownZero
argument_list|,
name|KnownOne
argument_list|,
name|TD
argument_list|,
name|Depth
argument_list|)
return|;
block|}
name|bool
name|MaskedValueIsZero
argument_list|(
name|Value
operator|*
name|V
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|MaskedValueIsZero
argument_list|(
name|V
argument_list|,
name|Mask
argument_list|,
name|TD
argument_list|,
name|Depth
argument_list|)
return|;
block|}
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|Value
operator|*
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeNumSignBits
argument_list|(
name|Op
argument_list|,
name|TD
argument_list|,
name|Depth
argument_list|)
return|;
block|}
name|private
label|:
comment|/// SimplifyAssociativeOrCommutative - This performs a few simplifications for
comment|/// operators which are associative or commutative.
name|bool
name|SimplifyAssociativeOrCommutative
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// SimplifyUsingDistributiveLaws - This tries to simplify binary operations
comment|/// which some other binary operation distributes over either by factorizing
comment|/// out common terms (eg "(A*B)+(A*C)" -> "A*(B+C)") or expanding out if this
comment|/// results in simplifications (eg: "A& (B | C) -> (A&B) | (A&C)" if this is
comment|/// a win).  Returns the simplified value, or null if it didn't simplify.
name|Value
modifier|*
name|SimplifyUsingDistributiveLaws
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// SimplifyDemandedUseBits - Attempts to replace V with a simpler value
comment|/// based on the demanded bits.
name|Value
modifier|*
name|SimplifyDemandedUseBits
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
parameter_list|)
function_decl|;
name|bool
name|SimplifyDemandedBits
parameter_list|(
name|Use
modifier|&
name|U
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded
comment|/// bit for "r1 = shr x, c1; r2 = shl r1, c2" instruction sequence.
name|Value
modifier|*
name|SimplifyShrShlDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|Lsr
parameter_list|,
name|Instruction
modifier|*
name|Sftl
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|)
function_decl|;
comment|/// SimplifyDemandedInstructionBits - Inst is an integer instruction that
comment|/// SimplifyDemandedBits knows about.  See if the instruction has any
comment|/// properties that allow us to simplify its operands.
name|bool
name|SimplifyDemandedInstructionBits
parameter_list|(
name|Instruction
modifier|&
name|Inst
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyDemandedVectorElts
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedElts
parameter_list|,
name|APInt
modifier|&
name|UndefElts
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
comment|// FoldOpIntoPhi - Given a binary operator, cast instruction, or select
comment|// which has a PHI node as operand #0, see if we can fold the instruction
comment|// into the PHI (which is only possible if all operands to the PHI are
comment|// constants).
comment|//
name|Instruction
modifier|*
name|FoldOpIntoPhi
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
comment|// FoldPHIArgOpIntoPHI - If all operands to a PHI node are the same "unary"
comment|// operator and they all are only used by the PHI, PHI together their
comment|// inputs, and do the operation once, to the result of the PHI.
name|Instruction
modifier|*
name|FoldPHIArgOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgBinOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgGEPIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgLoadIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|OptAndOp
parameter_list|(
name|Instruction
modifier|*
name|Op
parameter_list|,
name|ConstantInt
modifier|*
name|OpRHS
parameter_list|,
name|ConstantInt
modifier|*
name|AndRHS
parameter_list|,
name|BinaryOperator
modifier|&
name|TheAnd
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldLogicalPlusAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|ConstantInt
modifier|*
name|Mask
parameter_list|,
name|bool
name|isSub
parameter_list|,
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|InsertRangeTest
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Constant
modifier|*
name|Lo
parameter_list|,
name|Constant
modifier|*
name|Hi
parameter_list|,
name|bool
name|isSigned
parameter_list|,
name|bool
name|Inside
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|PromoteCastOfAllocation
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|,
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|MatchBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|SimplifyStoreAtEndOfBlock
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemTransfer
parameter_list|(
name|MemIntrinsic
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemSet
parameter_list|(
name|MemSetInst
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EvaluateInDifferentType
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|isSigned
parameter_list|)
function_decl|;
comment|/// Descale - Return a value X such that Val = X * Scale, or null if none.  If
comment|/// the multiplication is known not to overflow then NoSignedWrap is set.
name|Value
modifier|*
name|Descale
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|APInt
name|Scale
parameter_list|,
name|bool
modifier|&
name|NoSignedWrap
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm.
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

