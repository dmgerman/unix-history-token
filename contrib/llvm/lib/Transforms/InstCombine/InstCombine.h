begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstCombine.h - Main InstCombine pass definition ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINE_H
end_define

begin_include
include|#
directive|include
file|"InstCombineWorklist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/AssumptionCache.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ValueTracking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Dominators.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/InstVisitor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/PatternMatch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/Utils/SimplifyLibCalls.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_TYPE
value|"instcombine"
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CallSite
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|MemIntrinsic
decl_stmt|;
name|class
name|MemSetInst
decl_stmt|;
comment|/// SelectPatternFlavor - We can match a variety of different patterns for
comment|/// select operations.
enum|enum
name|SelectPatternFlavor
block|{
name|SPF_UNKNOWN
init|=
literal|0
block|,
name|SPF_SMIN
block|,
name|SPF_UMIN
block|,
name|SPF_SMAX
block|,
name|SPF_UMAX
block|,
name|SPF_ABS
block|,
name|SPF_NABS
block|}
enum|;
comment|/// getComplexity:  Assign a complexity or rank value to LLVM Values...
comment|///   0 -> undef, 1 -> Const, 2 -> Other, 3 -> Arg, 3 -> Unary, 4 -> OtherInst
specifier|static
specifier|inline
name|unsigned
name|getComplexity
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|Instruction
operator|>
operator|(
name|V
operator|)
condition|)
block|{
if|if
condition|(
name|BinaryOperator
operator|::
name|isNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isFNeg
argument_list|(
name|V
argument_list|)
operator|||
name|BinaryOperator
operator|::
name|isNot
argument_list|(
name|V
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|isa
operator|<
name|Argument
operator|>
operator|(
name|V
operator|)
condition|)
return|return
literal|3
return|;
return|return
name|isa
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|?
operator|(
name|isa
operator|<
name|UndefValue
operator|>
operator|(
name|V
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
literal|2
return|;
block|}
comment|/// AddOne - Add one to a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|AddOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getAdd
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// SubOne - Subtract one from a Constant
specifier|static
specifier|inline
name|Constant
modifier|*
name|SubOne
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|ConstantExpr
operator|::
name|getSub
argument_list|(
name|C
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|C
operator|->
name|getType
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/// InstCombineIRInserter - This is an IRBuilder insertion helper that works
comment|/// just like the normal insertion helper, but also adds any new instructions
comment|/// to the instcombine worklist.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombineIRInserter
range|:
name|public
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
block|{
name|InstCombineWorklist
operator|&
name|Worklist
block|;
name|AssumptionCache
operator|*
name|AC
block|;
name|public
operator|:
name|InstCombineIRInserter
argument_list|(
name|InstCombineWorklist
operator|&
name|WL
argument_list|,
name|AssumptionCache
operator|*
name|AC
argument_list|)
operator|:
name|Worklist
argument_list|(
name|WL
argument_list|)
block|,
name|AC
argument_list|(
argument|AC
argument_list|)
block|{}
name|void
name|InsertHelper
argument_list|(
argument|Instruction *I
argument_list|,
argument|const Twine&Name
argument_list|,
argument|BasicBlock *BB
argument_list|,
argument|BasicBlock::iterator InsertPt
argument_list|)
specifier|const
block|{
name|IRBuilderDefaultInserter
operator|<
name|true
operator|>
operator|::
name|InsertHelper
argument_list|(
name|I
argument_list|,
name|Name
argument_list|,
name|BB
argument_list|,
name|InsertPt
argument_list|)
block|;
name|Worklist
operator|.
name|Add
argument_list|(
name|I
argument_list|)
block|;
name|using
name|namespace
name|llvm
operator|::
name|PatternMatch
block|;
if|if
condition|(
name|match
argument_list|(
name|I
argument_list|,
name|m_Intrinsic
operator|<
name|Intrinsic
operator|::
name|assume
operator|>
operator|(
operator|)
argument_list|)
condition|)
name|AC
operator|->
name|registerAssumption
argument_list|(
name|cast
operator|<
name|CallInst
operator|>
operator|(
name|I
operator|)
argument_list|)
expr_stmt|;
block|}
expr|}
block|;
comment|/// InstCombiner - The -instcombine pass.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|InstCombiner
operator|:
name|public
name|FunctionPass
block|,
name|public
name|InstVisitor
operator|<
name|InstCombiner
block|,
name|Instruction
operator|*
operator|>
block|{
name|AssumptionCache
operator|*
name|AC
block|;
specifier|const
name|DataLayout
operator|*
name|DL
block|;
name|TargetLibraryInfo
operator|*
name|TLI
block|;
name|DominatorTree
operator|*
name|DT
block|;
name|bool
name|MadeIRChange
block|;
name|LibCallSimplifier
operator|*
name|Simplifier
block|;
name|bool
name|MinimizeSize
block|;
name|public
operator|:
comment|/// Worklist - All of the instructions that need to be simplified.
name|InstCombineWorklist
name|Worklist
block|;
comment|/// Builder - This is an IRBuilder that automatically inserts new
comment|/// instructions into the worklist when they are created.
typedef|typedef
name|IRBuilder
operator|<
name|true
operator|,
name|TargetFolder
operator|,
name|InstCombineIRInserter
operator|>
name|BuilderTy
expr_stmt|;
name|BuilderTy
operator|*
name|Builder
block|;
specifier|static
name|char
name|ID
block|;
comment|// Pass identification, replacement for typeid
name|InstCombiner
argument_list|()
operator|:
name|FunctionPass
argument_list|(
name|ID
argument_list|)
block|,
name|DL
argument_list|(
name|nullptr
argument_list|)
block|,
name|DT
argument_list|(
name|nullptr
argument_list|)
block|,
name|Builder
argument_list|(
argument|nullptr
argument_list|)
block|{
name|MinimizeSize
operator|=
name|false
block|;
name|initializeInstCombinerPass
argument_list|(
operator|*
name|PassRegistry
operator|::
name|getPassRegistry
argument_list|()
argument_list|)
block|;   }
name|public
operator|:
name|bool
name|runOnFunction
argument_list|(
argument|Function&F
argument_list|)
name|override
block|;
name|bool
name|DoOneIteration
argument_list|(
argument|Function&F
argument_list|,
argument|unsigned ItNum
argument_list|)
block|;
name|void
name|getAnalysisUsage
argument_list|(
argument|AnalysisUsage&AU
argument_list|)
specifier|const
name|override
block|;
name|AssumptionCache
operator|*
name|getAssumptionCache
argument_list|()
specifier|const
block|{
return|return
name|AC
return|;
block|}
specifier|const
name|DataLayout
operator|*
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|DL
return|;
block|}
name|DominatorTree
operator|*
name|getDominatorTree
argument_list|()
specifier|const
block|{
return|return
name|DT
return|;
block|}
name|TargetLibraryInfo
operator|*
name|getTargetLibraryInfo
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
comment|// Visitation implementation - Implement instruction combining for different
comment|// instruction types.  The semantics are as follows:
comment|// Return Value:
comment|//    null        - No change was made
comment|//     I          - Change was made, I is still valid, I may be dead though
comment|//   otherwise    - Change was made, replace I with returned instruction
comment|//
name|Instruction
operator|*
name|visitAdd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFAdd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|OptimizePointerDifference
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
block|;
name|Instruction
operator|*
name|visitSub
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFSub
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitMul
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|foldFMulConst
argument_list|(
name|Instruction
operator|*
name|FMulOrDiv
argument_list|,
name|Constant
operator|*
name|C
argument_list|,
name|Instruction
operator|*
name|InsertBefore
argument_list|)
block|;
name|Instruction
operator|*
name|visitFMul
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitURem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitSRem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFRem
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|bool
name|SimplifyDivRemOfSelect
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonRemTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonIRemTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonDivTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonIDivTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitUDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitSDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitFDiv
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|simplifyRangeCheck
argument_list|(
argument|ICmpInst *Cmp0
argument_list|,
argument|ICmpInst *Cmp1
argument_list|,
argument|bool Inverted
argument_list|)
block|;
name|Value
operator|*
name|FoldAndOfICmps
argument_list|(
name|ICmpInst
operator|*
name|LHS
argument_list|,
name|ICmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Value
operator|*
name|FoldAndOfFCmps
argument_list|(
name|FCmpInst
operator|*
name|LHS
argument_list|,
name|FCmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|visitAnd
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Value
operator|*
name|FoldOrOfICmps
argument_list|(
name|ICmpInst
operator|*
name|LHS
argument_list|,
name|ICmpInst
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|Value
operator|*
name|FoldOrOfFCmps
argument_list|(
name|FCmpInst
operator|*
name|LHS
argument_list|,
name|FCmpInst
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldOrWithConstants
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|Value
operator|*
name|B
argument_list|,
name|Value
operator|*
name|C
argument_list|)
block|;
name|Instruction
operator|*
name|FoldXorWithConstants
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|Value
operator|*
name|B
argument_list|,
name|Value
operator|*
name|C
argument_list|)
block|;
name|Instruction
operator|*
name|visitOr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitXor
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitShl
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitAShr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitLShr
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonShiftTransforms
argument_list|(
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|FoldFCmp_IntToFP_Cst
argument_list|(
name|FCmpInst
operator|&
name|I
argument_list|,
name|Instruction
operator|*
name|LHSI
argument_list|,
name|Constant
operator|*
name|RHSC
argument_list|)
block|;
name|Instruction
operator|*
name|FoldCmpLoadFromIndexedGlobal
argument_list|(
name|GetElementPtrInst
operator|*
name|GEP
argument_list|,
name|GlobalVariable
operator|*
name|GV
argument_list|,
name|CmpInst
operator|&
name|ICI
argument_list|,
name|ConstantInt
operator|*
name|AndCst
operator|=
name|nullptr
argument_list|)
block|;
name|Instruction
operator|*
name|visitFCmpInst
argument_list|(
name|FCmpInst
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInstWithCastAndCast
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|)
block|;
name|Instruction
operator|*
name|visitICmpInstWithInstAndIntCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|Instruction
operator|*
name|LHS
argument_list|,
name|ConstantInt
operator|*
name|RHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpDivCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|BinaryOperator
operator|*
name|DivI
argument_list|,
name|ConstantInt
operator|*
name|DivRHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpShrCst
argument_list|(
name|ICmpInst
operator|&
name|ICI
argument_list|,
name|BinaryOperator
operator|*
name|DivI
argument_list|,
name|ConstantInt
operator|*
name|DivRHS
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpCstShrCst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|ConstantInt
operator|*
name|CI1
argument_list|,
name|ConstantInt
operator|*
name|CI2
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpCstShlCst
argument_list|(
name|ICmpInst
operator|&
name|I
argument_list|,
name|Value
operator|*
name|Op
argument_list|,
name|Value
operator|*
name|A
argument_list|,
name|ConstantInt
operator|*
name|CI1
argument_list|,
name|ConstantInt
operator|*
name|CI2
argument_list|)
block|;
name|Instruction
operator|*
name|FoldICmpAddOpCst
argument_list|(
argument|Instruction&ICI
argument_list|,
argument|Value *X
argument_list|,
argument|ConstantInt *CI
argument_list|,
argument|ICmpInst::Predicate Pred
argument_list|)
block|;
name|Instruction
operator|*
name|FoldGEPICmp
argument_list|(
argument|GEPOperator *GEPLHS
argument_list|,
argument|Value *RHS
argument_list|,
argument|ICmpInst::Predicate Cond
argument_list|,
argument|Instruction&I
argument_list|)
block|;
name|Instruction
operator|*
name|FoldShiftByConstant
argument_list|(
name|Value
operator|*
name|Op0
argument_list|,
name|Constant
operator|*
name|Op1
argument_list|,
name|BinaryOperator
operator|&
name|I
argument_list|)
block|;
name|Instruction
operator|*
name|commonCastTransforms
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|commonPointerCastTransforms
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitTrunc
argument_list|(
name|TruncInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitZExt
argument_list|(
name|ZExtInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSExt
argument_list|(
name|SExtInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPTrunc
argument_list|(
name|FPTruncInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPExt
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPToUI
argument_list|(
name|FPToUIInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFPToSI
argument_list|(
name|FPToSIInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitUIToFP
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSIToFP
argument_list|(
name|CastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitPtrToInt
argument_list|(
name|PtrToIntInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitIntToPtr
argument_list|(
name|IntToPtrInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitBitCast
argument_list|(
name|BitCastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitAddrSpaceCast
argument_list|(
name|AddrSpaceCastInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSelectOpOp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|Instruction
operator|*
name|TI
argument_list|,
name|Instruction
operator|*
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSelectIntoOp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|Value
operator|*
argument_list|,
name|Value
operator|*
argument_list|)
block|;
name|Instruction
operator|*
name|FoldSPFofSPF
argument_list|(
argument|Instruction *Inner
argument_list|,
argument|SelectPatternFlavor SPF1
argument_list|,
argument|Value *A
argument_list|,
argument|Value *B
argument_list|,
argument|Instruction&Outer
argument_list|,
argument|SelectPatternFlavor SPF2
argument_list|,
argument|Value *C
argument_list|)
block|;
name|Instruction
operator|*
name|visitSelectInst
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSelectInstWithICmp
argument_list|(
name|SelectInst
operator|&
name|SI
argument_list|,
name|ICmpInst
operator|*
name|ICI
argument_list|)
block|;
name|Instruction
operator|*
name|visitCallInst
argument_list|(
name|CallInst
operator|&
name|CI
argument_list|)
block|;
name|Instruction
operator|*
name|visitInvokeInst
argument_list|(
name|InvokeInst
operator|&
name|II
argument_list|)
block|;
name|Instruction
operator|*
name|SliceUpIllegalIntegerPHI
argument_list|(
name|PHINode
operator|&
name|PN
argument_list|)
block|;
name|Instruction
operator|*
name|visitPHINode
argument_list|(
name|PHINode
operator|&
name|PN
argument_list|)
block|;
name|Instruction
operator|*
name|visitGetElementPtrInst
argument_list|(
name|GetElementPtrInst
operator|&
name|GEP
argument_list|)
block|;
name|Instruction
operator|*
name|visitAllocaInst
argument_list|(
name|AllocaInst
operator|&
name|AI
argument_list|)
block|;
name|Instruction
operator|*
name|visitAllocSite
argument_list|(
name|Instruction
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitFree
argument_list|(
name|CallInst
operator|&
name|FI
argument_list|)
block|;
name|Instruction
operator|*
name|visitLoadInst
argument_list|(
name|LoadInst
operator|&
name|LI
argument_list|)
block|;
name|Instruction
operator|*
name|visitStoreInst
argument_list|(
name|StoreInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitBranchInst
argument_list|(
name|BranchInst
operator|&
name|BI
argument_list|)
block|;
name|Instruction
operator|*
name|visitSwitchInst
argument_list|(
name|SwitchInst
operator|&
name|SI
argument_list|)
block|;
name|Instruction
operator|*
name|visitReturnInst
argument_list|(
name|ReturnInst
operator|&
name|RI
argument_list|)
block|;
name|Instruction
operator|*
name|visitInsertValueInst
argument_list|(
name|InsertValueInst
operator|&
name|IV
argument_list|)
block|;
name|Instruction
operator|*
name|visitInsertElementInst
argument_list|(
name|InsertElementInst
operator|&
name|IE
argument_list|)
block|;
name|Instruction
operator|*
name|visitExtractElementInst
argument_list|(
name|ExtractElementInst
operator|&
name|EI
argument_list|)
block|;
name|Instruction
operator|*
name|visitShuffleVectorInst
argument_list|(
name|ShuffleVectorInst
operator|&
name|SVI
argument_list|)
block|;
name|Instruction
operator|*
name|visitExtractValueInst
argument_list|(
name|ExtractValueInst
operator|&
name|EV
argument_list|)
block|;
name|Instruction
operator|*
name|visitLandingPadInst
argument_list|(
name|LandingPadInst
operator|&
name|LI
argument_list|)
block|;
comment|// visitInstruction - Specify what to return for unhandled instructions...
name|Instruction
operator|*
name|visitInstruction
argument_list|(
argument|Instruction&I
argument_list|)
block|{
return|return
name|nullptr
return|;
block|}
comment|// True when DB dominates all uses of DI execpt UI.
comment|// UI must be in the same block as DI.
comment|// The routine checks that the DI parent and DB are different.
name|bool
name|dominatesAllUses
argument_list|(
argument|const Instruction *DI
argument_list|,
argument|const Instruction *UI
argument_list|,
argument|const BasicBlock *DB
argument_list|)
specifier|const
block|;
comment|// Replace select with select operand SIOpd in SI-ICmp sequence when possible
name|bool
name|replacedSelectWithOperand
argument_list|(
argument|SelectInst *SI
argument_list|,
argument|const ICmpInst *Icmp
argument_list|,
argument|const unsigned SIOpd
argument_list|)
block|;
name|private
operator|:
name|bool
name|ShouldChangeType
argument_list|(
argument|Type *From
argument_list|,
argument|Type *To
argument_list|)
specifier|const
block|;
name|Value
operator|*
name|dyn_castNegVal
argument_list|(
argument|Value *V
argument_list|)
specifier|const
block|;
name|Value
operator|*
name|dyn_castFNegVal
argument_list|(
argument|Value *V
argument_list|,
argument|bool NoSignedZero = false
argument_list|)
specifier|const
block|;
name|Type
operator|*
name|FindElementAtOffset
argument_list|(
argument|Type *PtrTy
argument_list|,
argument|int64_t Offset
argument_list|,
argument|SmallVectorImpl<Value *>&NewIndices
argument_list|)
block|;
name|Instruction
operator|*
name|FoldOpIntoSelect
argument_list|(
name|Instruction
operator|&
name|Op
argument_list|,
name|SelectInst
operator|*
name|SI
argument_list|)
block|;
comment|/// ShouldOptimizeCast - Return true if the cast from "V to Ty" actually
comment|/// results in any code being generated and is interesting to optimize out. If
comment|/// the cast can be eliminated by some other simple transformation, we prefer
comment|/// to do the simplification first.
name|bool
name|ShouldOptimizeCast
argument_list|(
argument|Instruction::CastOps opcode
argument_list|,
argument|const Value *V
argument_list|,
argument|Type *Ty
argument_list|)
block|;
name|Instruction
operator|*
name|visitCallSite
argument_list|(
argument|CallSite CS
argument_list|)
block|;
name|Instruction
operator|*
name|tryOptimizeCall
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
specifier|const
name|DataLayout
operator|*
name|DL
argument_list|)
block|;
name|bool
name|transformConstExprCastCall
argument_list|(
argument|CallSite CS
argument_list|)
block|;
name|Instruction
operator|*
name|transformCallThroughTrampoline
argument_list|(
argument|CallSite CS
argument_list|,
argument|IntrinsicInst *Tramp
argument_list|)
block|;
name|Instruction
operator|*
name|transformZExtICmp
argument_list|(
argument|ICmpInst *ICI
argument_list|,
argument|Instruction&CI
argument_list|,
argument|bool DoXform = true
argument_list|)
block|;
name|Instruction
operator|*
name|transformSExtICmp
argument_list|(
name|ICmpInst
operator|*
name|ICI
argument_list|,
name|Instruction
operator|&
name|CI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedAdd
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedSub
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowUnsignedSub
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|bool
name|WillNotOverflowSignedMul
argument_list|(
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
name|Instruction
operator|*
name|CxtI
argument_list|)
block|;
name|Value
operator|*
name|EmitGEPOffset
argument_list|(
name|User
operator|*
name|GEP
argument_list|)
block|;
name|Instruction
operator|*
name|scalarizePHI
argument_list|(
name|ExtractElementInst
operator|&
name|EI
argument_list|,
name|PHINode
operator|*
name|PN
argument_list|)
block|;
name|Value
operator|*
name|EvaluateInDifferentElementOrder
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|ArrayRef
operator|<
name|int
operator|>
name|Mask
argument_list|)
block|;
name|public
operator|:
comment|// InsertNewInstBefore - insert an instruction New before instruction Old
comment|// in the program.  Add the new instruction to the worklist.
comment|//
name|Instruction
operator|*
name|InsertNewInstBefore
argument_list|(
argument|Instruction *New
argument_list|,
argument|Instruction&Old
argument_list|)
block|{
name|assert
argument_list|(
name|New
operator|&&
operator|!
name|New
operator|->
name|getParent
argument_list|()
operator|&&
literal|"New instruction already inserted into a basic block!"
argument_list|)
block|;
name|BasicBlock
operator|*
name|BB
operator|=
name|Old
operator|.
name|getParent
argument_list|()
block|;
name|BB
operator|->
name|getInstList
argument_list|()
operator|.
name|insert
argument_list|(
operator|&
name|Old
argument_list|,
name|New
argument_list|)
block|;
comment|// Insert inst
name|Worklist
operator|.
name|Add
argument_list|(
name|New
argument_list|)
block|;
return|return
name|New
return|;
block|}
comment|// InsertNewInstWith - same as InsertNewInstBefore, but also sets the
comment|// debug loc.
comment|//
name|Instruction
operator|*
name|InsertNewInstWith
argument_list|(
argument|Instruction *New
argument_list|,
argument|Instruction&Old
argument_list|)
block|{
name|New
operator|->
name|setDebugLoc
argument_list|(
name|Old
operator|.
name|getDebugLoc
argument_list|()
argument_list|)
block|;
return|return
name|InsertNewInstBefore
argument_list|(
name|New
argument_list|,
name|Old
argument_list|)
return|;
block|}
comment|// ReplaceInstUsesWith - This method is to be used when an instruction is
comment|// found to be dead, replacable with another preexisting expression.  Here
comment|// we add all uses of I to the worklist, replace all uses of I with the new
comment|// value, then return I, so that the inst combiner will know that I was
comment|// modified.
comment|//
name|Instruction
operator|*
name|ReplaceInstUsesWith
argument_list|(
argument|Instruction&I
argument_list|,
argument|Value *V
argument_list|)
block|{
name|Worklist
operator|.
name|AddUsersToWorkList
argument_list|(
name|I
argument_list|)
block|;
comment|// Add all modified instrs to worklist.
comment|// If we are replacing the instruction with itself, this must be in a
comment|// segment of unreachable code, so just clobber the instruction.
if|if
condition|(
operator|&
name|I
operator|==
name|V
condition|)
name|V
operator|=
name|UndefValue
operator|::
name|get
argument_list|(
name|I
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: Replacing "
operator|<<
name|I
operator|<<
literal|"\n"
literal|"    with "
operator|<<
operator|*
name|V
operator|<<
literal|'\n'
argument_list|)
block|;
name|I
operator|.
name|replaceAllUsesWith
argument_list|(
name|V
argument_list|)
block|;
return|return
operator|&
name|I
return|;
block|}
comment|/// Creates a result tuple for an overflow intrinsic \p II with a given
comment|/// \p Result and a constant \p Overflow value. If \p ReUseName is true the
comment|/// \p Result's name is taken from \p II.
name|Instruction
modifier|*
name|CreateOverflowTuple
parameter_list|(
name|IntrinsicInst
modifier|*
name|II
parameter_list|,
name|Value
modifier|*
name|Result
parameter_list|,
name|bool
name|Overflow
parameter_list|,
name|bool
name|ReUseName
init|=
name|true
parameter_list|)
block|{
if|if
condition|(
name|ReUseName
condition|)
name|Result
operator|->
name|takeName
argument_list|(
name|II
argument_list|)
expr_stmt|;
name|Constant
modifier|*
name|V
index|[]
init|=
block|{
name|UndefValue
operator|::
name|get
argument_list|(
name|Result
operator|->
name|getType
argument_list|()
argument_list|)
block|,
name|Overflow
operator|?
name|Builder
operator|->
name|getTrue
argument_list|()
operator|:
name|Builder
operator|->
name|getFalse
argument_list|()
block|}
decl_stmt|;
name|StructType
modifier|*
name|ST
init|=
name|cast
operator|<
name|StructType
operator|>
operator|(
name|II
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Constant
modifier|*
name|Struct
init|=
name|ConstantStruct
operator|::
name|get
argument_list|(
name|ST
argument_list|,
name|V
argument_list|)
decl_stmt|;
return|return
name|InsertValueInst
operator|::
name|Create
argument_list|(
name|Struct
argument_list|,
name|Result
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// EraseInstFromFunction - When dealing with an instruction that has side
comment|// effects or produces a void value, we can't rely on DCE to delete the
comment|// instruction.  Instead, visit methods should return the value returned by
comment|// this function.
name|Instruction
modifier|*
name|EraseInstFromFunction
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IC: ERASE "
operator|<<
name|I
operator|<<
literal|'\n'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|.
name|use_empty
argument_list|()
operator|&&
literal|"Cannot erase instruction that is used!"
argument_list|)
expr_stmt|;
comment|// Make sure that we reprocess all operands now that we reduced their
comment|// use counts.
if|if
condition|(
name|I
operator|.
name|getNumOperands
argument_list|()
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|User
operator|::
name|op_iterator
name|i
operator|=
name|I
operator|.
name|op_begin
argument_list|()
operator|,
name|e
operator|=
name|I
operator|.
name|op_end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Instruction
modifier|*
name|Op
init|=
name|dyn_cast
operator|<
name|Instruction
operator|>
operator|(
operator|*
name|i
operator|)
condition|)
name|Worklist
operator|.
name|Add
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
name|Worklist
operator|.
name|Remove
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|I
operator|.
name|eraseFromParent
argument_list|()
expr_stmt|;
name|MadeIRChange
operator|=
name|true
expr_stmt|;
return|return
name|nullptr
return|;
comment|// Don't do anything with FI
block|}
name|void
name|computeKnownBits
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|computeKnownBits
argument_list|(
name|V
argument_list|,
name|KnownZero
argument_list|,
name|KnownOne
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|bool
name|MaskedValueIsZero
argument_list|(
name|Value
operator|*
name|V
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|MaskedValueIsZero
argument_list|(
name|V
argument_list|,
name|Mask
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|Value
operator|*
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeNumSignBits
argument_list|(
name|Op
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|void
name|ComputeSignBit
argument_list|(
name|Value
operator|*
name|V
argument_list|,
name|bool
operator|&
name|KnownZero
argument_list|,
name|bool
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|,
name|Instruction
operator|*
name|CxtI
operator|=
name|nullptr
argument_list|)
decl|const
block|{
return|return
name|llvm
operator|::
name|ComputeSignBit
argument_list|(
name|V
argument_list|,
name|KnownZero
argument_list|,
name|KnownOne
argument_list|,
name|DL
argument_list|,
name|Depth
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|OverflowResult
name|computeOverflowForUnsignedMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|OverflowResult
name|computeOverflowForUnsignedAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|CxtI
parameter_list|)
block|{
return|return
name|llvm
operator|::
name|computeOverflowForUnsignedAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|DL
argument_list|,
name|AC
argument_list|,
name|CxtI
argument_list|,
name|DT
argument_list|)
return|;
block|}
name|private
label|:
comment|/// SimplifyAssociativeOrCommutative - This performs a few simplifications for
comment|/// operators which are associative or commutative.
name|bool
name|SimplifyAssociativeOrCommutative
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// SimplifyUsingDistributiveLaws - This tries to simplify binary operations
comment|/// which some other binary operation distributes over either by factorizing
comment|/// out common terms (eg "(A*B)+(A*C)" -> "A*(B+C)") or expanding out if this
comment|/// results in simplifications (eg: "A& (B | C) -> (A&B) | (A&C)" if this is
comment|/// a win).  Returns the simplified value, or null if it didn't simplify.
name|Value
modifier|*
name|SimplifyUsingDistributiveLaws
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// SimplifyDemandedUseBits - Attempts to replace V with a simpler value
comment|/// based on the demanded bits.
name|Value
modifier|*
name|SimplifyDemandedUseBits
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
parameter_list|,
name|Instruction
modifier|*
name|CxtI
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|SimplifyDemandedBits
parameter_list|(
name|Use
modifier|&
name|U
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded
comment|/// bit for "r1 = shr x, c1; r2 = shl r1, c2" instruction sequence.
name|Value
modifier|*
name|SimplifyShrShlDemandedBits
parameter_list|(
name|Instruction
modifier|*
name|Lsr
parameter_list|,
name|Instruction
modifier|*
name|Sftl
parameter_list|,
name|APInt
name|DemandedMask
parameter_list|,
name|APInt
modifier|&
name|KnownZero
parameter_list|,
name|APInt
modifier|&
name|KnownOne
parameter_list|)
function_decl|;
comment|/// SimplifyDemandedInstructionBits - Inst is an integer instruction that
comment|/// SimplifyDemandedBits knows about.  See if the instruction has any
comment|/// properties that allow us to simplify its operands.
name|bool
name|SimplifyDemandedInstructionBits
parameter_list|(
name|Instruction
modifier|&
name|Inst
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyDemandedVectorElts
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|APInt
name|DemandedElts
parameter_list|,
name|APInt
modifier|&
name|UndefElts
parameter_list|,
name|unsigned
name|Depth
init|=
literal|0
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyVectorOp
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
name|Value
modifier|*
name|SimplifyBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
function_decl|;
comment|// FoldOpIntoPhi - Given a binary operator, cast instruction, or select
comment|// which has a PHI node as operand #0, see if we can fold the instruction
comment|// into the PHI (which is only possible if all operands to the PHI are
comment|// constants).
comment|//
name|Instruction
modifier|*
name|FoldOpIntoPhi
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
comment|// FoldPHIArgOpIntoPHI - If all operands to a PHI node are the same "unary"
comment|// operator and they all are only used by the PHI, PHI together their
comment|// inputs, and do the operation once, to the result of the PHI.
name|Instruction
modifier|*
name|FoldPHIArgOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgBinOpIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgGEPIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|FoldPHIArgLoadIntoPHI
parameter_list|(
name|PHINode
modifier|&
name|PN
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|OptAndOp
parameter_list|(
name|Instruction
modifier|*
name|Op
parameter_list|,
name|ConstantInt
modifier|*
name|OpRHS
parameter_list|,
name|ConstantInt
modifier|*
name|AndRHS
parameter_list|,
name|BinaryOperator
modifier|&
name|TheAnd
parameter_list|)
function_decl|;
name|Value
modifier|*
name|FoldLogicalPlusAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
name|ConstantInt
modifier|*
name|Mask
parameter_list|,
name|bool
name|isSub
parameter_list|,
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
name|Value
modifier|*
name|InsertRangeTest
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Constant
modifier|*
name|Lo
parameter_list|,
name|Constant
modifier|*
name|Hi
parameter_list|,
name|bool
name|isSigned
parameter_list|,
name|bool
name|Inside
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|PromoteCastOfAllocation
parameter_list|(
name|BitCastInst
modifier|&
name|CI
parameter_list|,
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|MatchBSwap
parameter_list|(
name|BinaryOperator
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|SimplifyStoreAtEndOfBlock
parameter_list|(
name|StoreInst
modifier|&
name|SI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemTransfer
parameter_list|(
name|MemIntrinsic
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Instruction
modifier|*
name|SimplifyMemSet
parameter_list|(
name|MemSetInst
modifier|*
name|MI
parameter_list|)
function_decl|;
name|Value
modifier|*
name|EvaluateInDifferentType
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|isSigned
parameter_list|)
function_decl|;
comment|/// Descale - Return a value X such that Val = X * Scale, or null if none.  If
comment|/// the multiplication is known not to overflow then NoSignedWrap is set.
name|Value
modifier|*
name|Descale
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|APInt
name|Scale
parameter_list|,
name|bool
modifier|&
name|NoSignedWrap
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm.
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

