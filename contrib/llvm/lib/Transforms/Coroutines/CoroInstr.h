begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CoroInstr.h - Coroutine Intrinsics Instruction Wrappers -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// This file defines classes that make it really easy to deal with intrinsic
end_comment

begin_comment
comment|// functions with the isa/dyncast family of functions.  In particular, this
end_comment

begin_comment
comment|// allows you to do things like:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     if (auto *SF = dyn_cast<CoroSubFnInst>(Inst))
end_comment

begin_comment
comment|//        ... SF->getFrame() ...
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// All intrinsic function calls are instances of the call instruction, so these
end_comment

begin_comment
comment|// are all subclasses of the CallInst class.  Note that none of these classes
end_comment

begin_comment
comment|// has state or virtual methods, which is an important part of this gross/neat
end_comment

begin_comment
comment|// hack working.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The helpful comment above is borrowed from llvm/IntrinsicInst.h, we keep
end_comment

begin_comment
comment|// coroutine intrinsic wrappers here since they are only used by the passes in
end_comment

begin_comment
comment|// the Coroutine library.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TRANSFORMS_COROUTINES_COROINSTR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TRANSFORMS_COROUTINES_COROINSTR_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/GlobalVariable.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This class represents the llvm.coro.subfn.addr instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroSubFnInst
range|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|FrameArg
block|,
name|IndexArg
block|}
block|;
name|public
operator|:
expr|enum
name|ResumeKind
block|{
name|RestartTrigger
operator|=
operator|-
literal|1
block|,
name|ResumeIndex
block|,
name|DestroyIndex
block|,
name|CleanupIndex
block|,
name|IndexLast
block|,
name|IndexFirst
operator|=
name|RestartTrigger
block|}
block|;
name|Value
operator|*
name|getFrame
argument_list|()
specifier|const
block|{
return|return
name|getArgOperand
argument_list|(
name|FrameArg
argument_list|)
return|;
block|}
name|ResumeKind
name|getIndex
argument_list|()
specifier|const
block|{
name|int64_t
name|Index
operator|=
name|getRawIndex
argument_list|()
operator|->
name|getValue
argument_list|()
operator|.
name|getSExtValue
argument_list|()
block|;
name|assert
argument_list|(
name|Index
operator|>=
name|IndexFirst
operator|&&
name|Index
operator|<
name|IndexLast
operator|&&
literal|"unexpected CoroSubFnInst index argument"
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|ResumeKind
operator|>
operator|(
name|Index
operator|)
return|;
block|}
name|ConstantInt
operator|*
name|getRawIndex
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|getArgOperand
argument_list|(
name|IndexArg
argument_list|)
operator|)
return|;
block|}
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_subfn_addr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.alloc instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroAllocInst
operator|:
name|public
name|IntrinsicInst
block|{
name|public
operator|:
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_alloc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.alloc instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroIdInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|AlignArg
block|,
name|PromiseArg
block|,
name|CoroutineArg
block|,
name|InfoArg
block|}
block|;
name|public
operator|:
name|CoroAllocInst
operator|*
name|getCoroAlloc
argument_list|()
block|{
for|for
control|(
name|User
modifier|*
name|U
range|:
name|users
argument_list|()
control|)
if|if
condition|(
name|auto
operator|*
name|CA
operator|=
name|dyn_cast
operator|<
name|CoroAllocInst
operator|>
operator|(
name|U
operator|)
condition|)
return|return
name|CA
return|;
return|return
name|nullptr
return|;
block|}
name|IntrinsicInst
operator|*
name|getCoroBegin
argument_list|()
block|{
for|for
control|(
name|User
modifier|*
name|U
range|:
name|users
argument_list|()
control|)
if|if
condition|(
name|auto
operator|*
name|II
operator|=
name|dyn_cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|U
operator|)
condition|)
if|if
condition|(
name|II
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_begin
condition|)
return|return
name|II
return|;
name|llvm_unreachable
argument_list|(
literal|"no coro.begin associated with coro.id"
argument_list|)
block|;   }
name|AllocaInst
operator|*
name|getPromise
argument_list|()
specifier|const
block|{
name|Value
operator|*
name|Arg
operator|=
name|getArgOperand
argument_list|(
name|PromiseArg
argument_list|)
block|;
return|return
name|isa
operator|<
name|ConstantPointerNull
operator|>
operator|(
name|Arg
operator|)
condition|?
name|nullptr
else|:
name|cast
operator|<
name|AllocaInst
operator|>
operator|(
name|Arg
operator|->
name|stripPointerCasts
argument_list|()
operator|)
return|;
block|}
name|void
name|clearPromise
argument_list|()
block|{
name|Value
operator|*
name|Arg
operator|=
name|getArgOperand
argument_list|(
name|PromiseArg
argument_list|)
block|;
name|setArgOperand
argument_list|(
name|PromiseArg
argument_list|,
name|ConstantPointerNull
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt8PtrTy
argument_list|(
name|getContext
argument_list|()
argument_list|)
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|isa
operator|<
name|AllocaInst
operator|>
operator|(
name|Arg
operator|)
condition|)
return|return;
name|assert
argument_list|(
operator|(
name|isa
operator|<
name|BitCastInst
operator|>
operator|(
name|Arg
operator|)
operator|||
name|isa
operator|<
name|GetElementPtrInst
operator|>
operator|(
name|Arg
operator|)
operator|)
operator|&&
literal|"unexpected instruction designating the promise"
argument_list|)
block|;
comment|// TODO: Add a check that any remaining users of Inst are after coro.begin
comment|// or add code to move the users after coro.begin.
name|auto
operator|*
name|Inst
operator|=
name|cast
operator|<
name|Instruction
operator|>
operator|(
name|Arg
operator|)
block|;
if|if
condition|(
name|Inst
operator|->
name|use_empty
argument_list|()
condition|)
block|{
name|Inst
operator|->
name|eraseFromParent
argument_list|()
expr_stmt|;
return|return;
block|}
name|Inst
operator|->
name|moveBefore
argument_list|(
name|getCoroBegin
argument_list|()
operator|->
name|getNextNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Info argument of coro.id is
comment|//   fresh out of the frontend: null ;
comment|//   outlined                 : {Init, Return, Susp1, Susp2, ...} ;
comment|//   postsplit                : [resume, destroy, cleanup] ;
comment|//
comment|// If parts of the coroutine were outlined to protect against undesirable
comment|// code motion, these functions will be stored in a struct literal referred to
comment|// by the Info parameter. Note: this is only needed before coroutine is split.
comment|//
comment|// After coroutine is split, resume functions are stored in an array
comment|// referred to by this parameter.
struct|struct
name|Info
block|{
name|ConstantStruct
modifier|*
name|OutlinedParts
init|=
name|nullptr
decl_stmt|;
name|ConstantArray
modifier|*
name|Resumers
init|=
name|nullptr
decl_stmt|;
name|bool
name|hasOutlinedParts
argument_list|()
specifier|const
block|{
return|return
name|OutlinedParts
operator|!=
name|nullptr
return|;
block|}
name|bool
name|isPostSplit
argument_list|()
specifier|const
block|{
return|return
name|Resumers
operator|!=
name|nullptr
return|;
block|}
name|bool
name|isPreSplit
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isPostSplit
argument_list|()
return|;
block|}
block|}
struct|;
name|Info
name|getInfo
argument_list|()
specifier|const
block|{
name|Info
name|Result
block|;
name|auto
operator|*
name|GV
operator|=
name|dyn_cast
operator|<
name|GlobalVariable
operator|>
operator|(
name|getRawInfo
argument_list|()
operator|)
block|;
if|if
condition|(
operator|!
name|GV
condition|)
return|return
name|Result
return|;
name|assert
argument_list|(
name|GV
operator|->
name|isConstant
argument_list|()
operator|&&
name|GV
operator|->
name|hasDefinitiveInitializer
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
modifier|*
name|Initializer
init|=
name|GV
operator|->
name|getInitializer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|Result
operator|.
name|OutlinedParts
operator|=
name|dyn_cast
operator|<
name|ConstantStruct
operator|>
operator|(
name|Initializer
operator|)
operator|)
condition|)
return|return
name|Result
return|;
name|Result
operator|.
name|Resumers
operator|=
name|cast
operator|<
name|ConstantArray
operator|>
operator|(
name|Initializer
operator|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Constant
operator|*
name|getRawInfo
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|getArgOperand
argument_list|(
name|InfoArg
argument_list|)
operator|->
name|stripPointerCasts
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setInfo
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
name|setArgOperand
argument_list|(
name|InfoArg
argument_list|,
name|C
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|Function
operator|*
name|getCoroutine
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Function
operator|>
operator|(
name|getArgOperand
argument_list|(
name|CoroutineArg
argument_list|)
operator|->
name|stripPointerCasts
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setCoroutineSelf
parameter_list|()
block|{
name|assert
argument_list|(
name|isa
operator|<
name|ConstantPointerNull
operator|>
operator|(
name|getArgOperand
argument_list|(
name|CoroutineArg
argument_list|)
operator|)
operator|&&
literal|"Coroutine argument is already assigned"
argument_list|)
expr_stmt|;
name|auto
operator|*
specifier|const
name|Int8PtrTy
operator|=
name|Type
operator|::
name|getInt8PtrTy
argument_list|(
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
name|setArgOperand
argument_list|(
name|CoroutineArg
argument_list|,
name|ConstantExpr
operator|::
name|getBitCast
argument_list|(
name|getFunction
argument_list|()
argument_list|,
name|Int8PtrTy
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
end_comment

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|IntrinsicInst
modifier|*
name|I
parameter_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_id
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|/// This represents the llvm.coro.frame instruction.
end_comment

begin_decl_stmt
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroFrameInst
range|:
name|public
name|IntrinsicInst
block|{
name|public
operator|:
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_frame
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.free instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroFreeInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|IdArg
block|,
name|FrameArg
block|}
block|;
name|public
operator|:
name|Value
operator|*
name|getFrame
argument_list|()
specifier|const
block|{
return|return
name|getArgOperand
argument_list|(
name|FrameArg
argument_list|)
return|;
block|}
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_free
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This class represents the llvm.coro.begin instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroBeginInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|IdArg
block|,
name|MemArg
block|}
block|;
name|public
operator|:
name|CoroIdInst
operator|*
name|getId
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|CoroIdInst
operator|>
operator|(
name|getArgOperand
argument_list|(
name|IdArg
argument_list|)
operator|)
return|;
block|}
name|Value
operator|*
name|getMem
argument_list|()
specifier|const
block|{
return|return
name|getArgOperand
argument_list|(
name|MemArg
argument_list|)
return|;
block|}
comment|// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_begin
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.save instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroSaveInst
operator|:
name|public
name|IntrinsicInst
block|{
name|public
operator|:
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_save
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.promise instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroPromiseInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|FrameArg
block|,
name|AlignArg
block|,
name|FromArg
block|}
block|;
name|public
operator|:
name|bool
name|isFromPromise
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|getArgOperand
argument_list|(
name|FromArg
argument_list|)
operator|)
operator|->
name|isOneValue
argument_list|()
return|;
block|}
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|getArgOperand
argument_list|(
name|AlignArg
argument_list|)
operator|)
operator|->
name|getZExtValue
argument_list|()
return|;
block|}
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_promise
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.suspend instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroSuspendInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|SaveArg
block|,
name|FinalArg
block|}
block|;
name|public
operator|:
name|CoroSaveInst
operator|*
name|getCoroSave
argument_list|()
specifier|const
block|{
name|Value
operator|*
name|Arg
operator|=
name|getArgOperand
argument_list|(
name|SaveArg
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|SI
operator|=
name|dyn_cast
operator|<
name|CoroSaveInst
operator|>
operator|(
name|Arg
operator|)
condition|)
return|return
name|SI
return|;
name|assert
argument_list|(
name|isa
operator|<
name|ConstantTokenNone
operator|>
operator|(
name|Arg
operator|)
argument_list|)
block|;
return|return
name|nullptr
return|;
block|}
name|bool
name|isFinal
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|getArgOperand
argument_list|(
name|FinalArg
argument_list|)
operator|)
operator|->
name|isOneValue
argument_list|()
return|;
block|}
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_suspend
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.size instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroSizeInst
operator|:
name|public
name|IntrinsicInst
block|{
name|public
operator|:
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_size
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents the llvm.coro.end instruction.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CoroEndInst
operator|:
name|public
name|IntrinsicInst
block|{   enum
block|{
name|FrameArg
block|,
name|UnwindArg
block|}
block|;
name|public
operator|:
name|bool
name|isFallthrough
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isUnwind
argument_list|()
return|;
block|}
name|bool
name|isUnwind
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|Constant
operator|>
operator|(
name|getArgOperand
argument_list|(
name|UnwindArg
argument_list|)
operator|)
operator|->
name|isOneValue
argument_list|()
return|;
block|}
comment|// Methods to support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const IntrinsicInst *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|Intrinsic
operator|::
name|coro_end
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
operator|&&
name|classof
argument_list|(
name|cast
operator|<
name|IntrinsicInst
operator|>
operator|(
name|V
operator|)
argument_list|)
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// End namespace llvm.
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

