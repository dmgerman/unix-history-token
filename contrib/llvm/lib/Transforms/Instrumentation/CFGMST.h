begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CFGMST.h - Minimum Spanning Tree for CFG ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements a Union-find algorithm to compute Minimum Spanning Tree
end_comment

begin_comment
comment|// for a given CFG.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/BlockFrequencyInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/BranchProbabilityInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/CFG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BranchProbability.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Transforms/Utils/BasicBlockUtils.h"
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
define|#
directive|define
name|DEBUG_TYPE
value|"cfgmst"
comment|/// \brief An union-find based Minimum Spanning Tree for CFG
comment|///
comment|/// Implements a Union-find algorithm to compute Minimum Spanning Tree
comment|/// for a given CFG.
name|template
operator|<
name|class
name|Edge
operator|,
name|class
name|BBInfo
operator|>
name|class
name|CFGMST
block|{
name|public
operator|:
name|Function
operator|&
name|F
block|;
comment|// Store all the edges in CFG. It may contain some stale edges
comment|// when Removed is set.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|Edge
operator|>>
name|AllEdges
block|;
comment|// This map records the auxiliary information for each BB.
name|DenseMap
operator|<
specifier|const
name|BasicBlock
operator|*
block|,
name|std
operator|::
name|unique_ptr
operator|<
name|BBInfo
operator|>>
name|BBInfos
block|;
comment|// Find the root group of the G and compress the path from G to the root.
name|BBInfo
operator|*
name|findAndCompressGroup
argument_list|(
argument|BBInfo *G
argument_list|)
block|{
if|if
condition|(
name|G
operator|->
name|Group
operator|!=
name|G
condition|)
name|G
operator|->
name|Group
operator|=
name|findAndCompressGroup
argument_list|(
name|static_cast
operator|<
name|BBInfo
operator|*
operator|>
operator|(
name|G
operator|->
name|Group
operator|)
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|BBInfo
operator|*
operator|>
operator|(
name|G
operator|->
name|Group
operator|)
return|;
block|}
comment|// Union BB1 and BB2 into the same group and return true.
comment|// Returns false if BB1 and BB2 are already in the same group.
name|bool
name|unionGroups
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|BB1
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|BB2
parameter_list|)
block|{
name|BBInfo
modifier|*
name|BB1G
init|=
name|findAndCompressGroup
argument_list|(
operator|&
name|getBBInfo
argument_list|(
name|BB1
argument_list|)
argument_list|)
decl_stmt|;
name|BBInfo
modifier|*
name|BB2G
init|=
name|findAndCompressGroup
argument_list|(
operator|&
name|getBBInfo
argument_list|(
name|BB2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|BB1G
operator|==
name|BB2G
condition|)
return|return
name|false
return|;
comment|// Make the smaller rank tree a direct child or the root of high rank tree.
if|if
condition|(
name|BB1G
operator|->
name|Rank
operator|<
name|BB2G
operator|->
name|Rank
condition|)
name|BB1G
operator|->
name|Group
operator|=
name|BB2G
expr_stmt|;
else|else
block|{
name|BB2G
operator|->
name|Group
operator|=
name|BB1G
expr_stmt|;
comment|// If the ranks are the same, increment root of one tree by one.
if|if
condition|(
name|BB1G
operator|->
name|Rank
operator|==
name|BB2G
operator|->
name|Rank
condition|)
name|BB1G
operator|->
name|Rank
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|// Give BB, return the auxiliary information.
name|BBInfo
modifier|&
name|getBBInfo
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
block|{
name|auto
name|It
init|=
name|BBInfos
operator|.
name|find
argument_list|(
name|BB
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|It
operator|->
name|second
operator|.
name|get
argument_list|()
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
return|return
operator|*
name|It
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Traverse the CFG using a stack. Find all the edges and assign the weight.
comment|// Edges with large weight will be put into MST first so they are less likely
comment|// to be instrumented.
name|void
name|buildEdges
parameter_list|()
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Build Edge on "
operator|<<
name|F
operator|.
name|getName
argument_list|()
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
specifier|const
name|BasicBlock
modifier|*
name|BB
init|=
operator|&
operator|(
name|F
operator|.
name|getEntryBlock
argument_list|()
operator|)
decl_stmt|;
name|uint64_t
name|EntryWeight
init|=
operator|(
name|BFI
operator|!=
name|nullptr
condition|?
name|BFI
operator|->
name|getEntryFreq
argument_list|()
else|:
literal|2
operator|)
decl_stmt|;
comment|// Add a fake edge to the entry.
name|addEdge
argument_list|(
name|nullptr
argument_list|,
name|BB
argument_list|,
name|EntryWeight
argument_list|)
expr_stmt|;
comment|// Special handling for single BB functions.
if|if
condition|(
name|succ_empty
argument_list|(
name|BB
argument_list|)
condition|)
block|{
name|addEdge
argument_list|(
name|BB
argument_list|,
name|nullptr
argument_list|,
name|EntryWeight
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
specifier|const
name|uint32_t
name|CriticalEdgeMultiplier
init|=
literal|1000
decl_stmt|;
for|for
control|(
name|Function
operator|::
name|iterator
name|BB
operator|=
name|F
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|F
operator|.
name|end
argument_list|()
init|;
name|BB
operator|!=
name|E
condition|;
operator|++
name|BB
control|)
block|{
name|TerminatorInst
modifier|*
name|TI
init|=
name|BB
operator|->
name|getTerminator
argument_list|()
decl_stmt|;
name|uint64_t
name|BBWeight
init|=
operator|(
name|BFI
operator|!=
name|nullptr
condition|?
name|BFI
operator|->
name|getBlockFreq
argument_list|(
operator|&
operator|*
name|BB
argument_list|)
operator|.
name|getFrequency
argument_list|()
else|:
literal|2
operator|)
decl_stmt|;
name|uint64_t
name|Weight
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|int
name|successors
init|=
name|TI
operator|->
name|getNumSuccessors
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|successors
condition|;
operator|++
name|i
control|)
block|{
name|BasicBlock
modifier|*
name|TargetBB
init|=
name|TI
operator|->
name|getSuccessor
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bool
name|Critical
init|=
name|isCriticalEdge
argument_list|(
name|TI
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|uint64_t
name|scaleFactor
init|=
name|BBWeight
decl_stmt|;
if|if
condition|(
name|Critical
condition|)
block|{
if|if
condition|(
name|scaleFactor
operator|<
name|UINT64_MAX
operator|/
name|CriticalEdgeMultiplier
condition|)
name|scaleFactor
operator|*=
name|CriticalEdgeMultiplier
expr_stmt|;
else|else
name|scaleFactor
operator|=
name|UINT64_MAX
expr_stmt|;
block|}
if|if
condition|(
name|BPI
operator|!=
name|nullptr
condition|)
name|Weight
operator|=
name|BPI
operator|->
name|getEdgeProbability
argument_list|(
operator|&
operator|*
name|BB
argument_list|,
name|TargetBB
argument_list|)
operator|.
name|scale
argument_list|(
name|scaleFactor
argument_list|)
expr_stmt|;
name|addEdge
argument_list|(
operator|&
operator|*
name|BB
argument_list|,
name|TargetBB
argument_list|,
name|Weight
argument_list|)
operator|.
name|IsCritical
operator|=
name|Critical
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"  Edge: from "
operator|<<
name|BB
operator|->
name|getName
argument_list|()
operator|<<
literal|" to "
operator|<<
name|TargetBB
operator|->
name|getName
argument_list|()
operator|<<
literal|"  w="
operator|<<
name|Weight
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addEdge
argument_list|(
operator|&
operator|*
name|BB
argument_list|,
name|nullptr
argument_list|,
name|BBWeight
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"  Edge: from "
operator|<<
name|BB
operator|->
name|getName
argument_list|()
operator|<<
literal|" to exit"
operator|<<
literal|" w = "
operator|<<
name|BBWeight
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Sort CFG edges based on its weight.
name|void
name|sortEdgesByWeight
parameter_list|()
block|{
name|std
operator|::
name|stable_sort
argument_list|(
name|AllEdges
operator|.
name|begin
argument_list|()
argument_list|,
name|AllEdges
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|Edge
operator|>
operator|&
name|Edge1
operator|,
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|Edge
operator|>
operator|&
name|Edge2
operator|)
block|{
return|return
name|Edge1
operator|->
name|Weight
operator|>
name|Edge2
operator|->
name|Weight
return|;
block|}
block|)
function|;
block|}
end_decl_stmt

begin_comment
comment|// Traverse all the edges and compute the Minimum Weight Spanning Tree
end_comment

begin_comment
comment|// using union-find algorithm.
end_comment

begin_function
name|void
name|computeMinimumSpanningTree
parameter_list|()
block|{
comment|// First, put all the critical edge with landing-pad as the Dest to MST.
comment|// This works around the insufficient support of critical edges split
comment|// when destination BB is a landing pad.
for|for
control|(
name|auto
operator|&
name|Ei
operator|:
name|AllEdges
control|)
block|{
if|if
condition|(
name|Ei
operator|->
name|Removed
condition|)
continue|continue;
if|if
condition|(
name|Ei
operator|->
name|IsCritical
condition|)
block|{
if|if
condition|(
name|Ei
operator|->
name|DestBB
operator|&&
name|Ei
operator|->
name|DestBB
operator|->
name|isLandingPad
argument_list|()
condition|)
block|{
if|if
condition|(
name|unionGroups
argument_list|(
name|Ei
operator|->
name|SrcBB
argument_list|,
name|Ei
operator|->
name|DestBB
argument_list|)
condition|)
name|Ei
operator|->
name|InMST
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|auto
operator|&
name|Ei
operator|:
name|AllEdges
control|)
block|{
if|if
condition|(
name|Ei
operator|->
name|Removed
condition|)
continue|continue;
if|if
condition|(
name|unionGroups
argument_list|(
name|Ei
operator|->
name|SrcBB
argument_list|,
name|Ei
operator|->
name|DestBB
argument_list|)
condition|)
name|Ei
operator|->
name|InMST
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Dump the Debug information about the instrumentation.
end_comment

begin_decl_stmt
name|void
name|dumpEdges
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Twine
operator|&
name|Message
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|Message
operator|.
name|str
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
name|OS
operator|<<
name|Message
operator|<<
literal|"\n"
expr_stmt|;
name|OS
operator|<<
literal|"  Number of Basic Blocks: "
operator|<<
name|BBInfos
operator|.
name|size
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|BI
operator|:
name|BBInfos
control|)
block|{
specifier|const
name|BasicBlock
modifier|*
name|BB
init|=
name|BI
operator|.
name|first
decl_stmt|;
name|OS
operator|<<
literal|"  BB: "
operator|<<
operator|(
name|BB
operator|==
name|nullptr
condition|?
literal|"FakeNode"
else|:
name|BB
operator|->
name|getName
argument_list|()
operator|)
operator|<<
literal|"  "
operator|<<
name|BI
operator|.
name|second
operator|->
name|infoString
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|OS
operator|<<
literal|"  Number of Edges: "
operator|<<
name|AllEdges
operator|.
name|size
argument_list|()
operator|<<
literal|" (*: Instrument, C: CriticalEdge, -: Removed)\n"
expr_stmt|;
name|uint32_t
name|Count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|EI
operator|:
name|AllEdges
control|)
name|OS
operator|<<
literal|"  Edge "
operator|<<
name|Count
operator|++
operator|<<
literal|": "
operator|<<
name|getBBInfo
argument_list|(
name|EI
operator|->
name|SrcBB
argument_list|)
operator|.
name|Index
operator|<<
literal|"-->"
operator|<<
name|getBBInfo
argument_list|(
name|EI
operator|->
name|DestBB
argument_list|)
operator|.
name|Index
operator|<<
name|EI
operator|->
name|infoString
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Add an edge to AllEdges with weight W.
end_comment

begin_function
name|Edge
modifier|&
name|addEdge
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|Src
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|Dest
parameter_list|,
name|uint64_t
name|W
parameter_list|)
block|{
name|uint32_t
name|Index
init|=
name|BBInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|auto
name|Iter
init|=
name|BBInfos
operator|.
name|end
argument_list|()
decl_stmt|;
name|bool
name|Inserted
decl_stmt|;
name|std
operator|::
name|tie
argument_list|(
name|Iter
argument_list|,
name|Inserted
argument_list|)
operator|=
name|BBInfos
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Src
argument_list|,
name|nullptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Inserted
condition|)
block|{
comment|// Newly inserted, update the real info.
name|Iter
operator|->
name|second
operator|=
name|std
operator|::
name|move
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|BBInfo
operator|>
operator|(
name|Index
operator|)
argument_list|)
expr_stmt|;
name|Index
operator|++
expr_stmt|;
block|}
name|std
operator|::
name|tie
argument_list|(
name|Iter
argument_list|,
name|Inserted
argument_list|)
operator|=
name|BBInfos
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Dest
argument_list|,
name|nullptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Inserted
condition|)
comment|// Newly inserted, update the real info.
name|Iter
operator|->
name|second
operator|=
name|std
operator|::
name|move
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|BBInfo
operator|>
operator|(
name|Index
operator|)
argument_list|)
expr_stmt|;
name|AllEdges
operator|.
name|emplace_back
argument_list|(
argument|new Edge(Src, Dest, W)
argument_list|)
expr_stmt|;
return|return
operator|*
name|AllEdges
operator|.
name|back
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|BranchProbabilityInfo
modifier|*
name|BPI
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BlockFrequencyInfo
modifier|*
name|BFI
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|CFGMST
argument_list|(
name|Function
operator|&
name|Func
argument_list|,
name|BranchProbabilityInfo
operator|*
name|BPI_
operator|=
name|nullptr
argument_list|,
name|BlockFrequencyInfo
operator|*
name|BFI_
operator|=
name|nullptr
argument_list|)
operator|:
name|F
argument_list|(
name|Func
argument_list|)
operator|,
name|BPI
argument_list|(
name|BPI_
argument_list|)
operator|,
name|BFI
argument_list|(
argument|BFI_
argument_list|)
block|{
name|buildEdges
argument_list|()
block|;
name|sortEdgesByWeight
argument_list|()
block|;
name|computeMinimumSpanningTree
argument_list|()
block|;   }
end_expr_stmt

begin_undef
unit|};
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_comment
comment|// "cfgmst"
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

end_unit

