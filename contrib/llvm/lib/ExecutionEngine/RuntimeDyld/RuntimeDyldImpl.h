begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RuntimeDyldImpl.h - Run-time dynamic linker for MC-JIT --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Interface for the implementations of runtime dynamic linker facilities.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_EXECUTIONENGINE_RUNTIMEDYLD_RUNTIMEDYLDIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_EXECUTIONENGINE_RUNTIMEDYLD_RUNTIMEDYLDIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/RTDyldMemoryManager.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/RuntimeDyld.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/RuntimeDyldChecker.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Format.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Host.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Mutex.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SwapByteOrder.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_decl_stmt
name|using
name|namespace
name|llvm
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|using
name|namespace
name|llvm
operator|::
name|object
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Twine
decl_stmt|;
define|#
directive|define
name|UNIMPLEMENTED_RELOC
parameter_list|(
name|RelType
parameter_list|)
define|\
value|case RelType: \     return make_error<RuntimeDyldError>("Unimplemented relocation: " #RelType)
comment|/// SectionEntry - represents a section emitted into memory by the dynamic
comment|/// linker.
name|class
name|SectionEntry
block|{
comment|/// Name - section name.
name|std
operator|::
name|string
name|Name
expr_stmt|;
comment|/// Address - address in the linker's memory where the section resides.
name|uint8_t
modifier|*
name|Address
decl_stmt|;
comment|/// Size - section size. Doesn't include the stubs.
name|size_t
name|Size
decl_stmt|;
comment|/// LoadAddress - the address of the section in the target process's memory.
comment|/// Used for situations in which JIT-ed code is being executed in the address
comment|/// space of a separate process.  If the code executes in the same address
comment|/// space where it was JIT-ed, this just equals Address.
name|uint64_t
name|LoadAddress
decl_stmt|;
comment|/// StubOffset - used for architectures with stub functions for far
comment|/// relocations (like ARM).
name|uintptr_t
name|StubOffset
decl_stmt|;
comment|/// The total amount of space allocated for this section.  This includes the
comment|/// section size and the maximum amount of space that the stubs can occupy.
name|size_t
name|AllocationSize
decl_stmt|;
comment|/// ObjAddress - address of the section in the in-memory object file.  Used
comment|/// for calculating relocations in some object formats (like MachO).
name|uintptr_t
name|ObjAddress
decl_stmt|;
name|public
label|:
name|SectionEntry
argument_list|(
argument|StringRef name
argument_list|,
argument|uint8_t *address
argument_list|,
argument|size_t size
argument_list|,
argument|size_t allocationSize
argument_list|,
argument|uintptr_t objAddress
argument_list|)
block|:
name|Name
argument_list|(
name|name
argument_list|)
operator|,
name|Address
argument_list|(
name|address
argument_list|)
operator|,
name|Size
argument_list|(
name|size
argument_list|)
operator|,
name|LoadAddress
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|address
operator|)
argument_list|)
operator|,
name|StubOffset
argument_list|(
name|size
argument_list|)
operator|,
name|AllocationSize
argument_list|(
name|allocationSize
argument_list|)
operator|,
name|ObjAddress
argument_list|(
argument|objAddress
argument_list|)
block|{
comment|// AllocationSize is used only in asserts, prevent an "unused private field"
comment|// warning:
operator|(
name|void
operator|)
name|AllocationSize
block|;   }
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|uint8_t
operator|*
name|getAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
return|;
block|}
comment|/// \brief Return the address of this section with an offset.
name|uint8_t
modifier|*
name|getAddressWithOffset
argument_list|(
name|unsigned
name|OffsetBytes
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|OffsetBytes
operator|<=
name|AllocationSize
operator|&&
literal|"Offset out of bounds!"
argument_list|)
expr_stmt|;
return|return
name|Address
operator|+
name|OffsetBytes
return|;
block|}
name|size_t
name|getSize
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|uint64_t
name|getLoadAddress
argument_list|()
specifier|const
block|{
return|return
name|LoadAddress
return|;
block|}
name|void
name|setLoadAddress
parameter_list|(
name|uint64_t
name|LA
parameter_list|)
block|{
name|LoadAddress
operator|=
name|LA
expr_stmt|;
block|}
comment|/// \brief Return the load address of this section with an offset.
name|uint64_t
name|getLoadAddressWithOffset
argument_list|(
name|unsigned
name|OffsetBytes
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|OffsetBytes
operator|<=
name|AllocationSize
operator|&&
literal|"Offset out of bounds!"
argument_list|)
expr_stmt|;
return|return
name|LoadAddress
operator|+
name|OffsetBytes
return|;
block|}
name|uintptr_t
name|getStubOffset
argument_list|()
specifier|const
block|{
return|return
name|StubOffset
return|;
block|}
name|void
name|advanceStubOffset
parameter_list|(
name|unsigned
name|StubSize
parameter_list|)
block|{
name|StubOffset
operator|+=
name|StubSize
expr_stmt|;
name|assert
argument_list|(
name|StubOffset
operator|<=
name|AllocationSize
operator|&&
literal|"Not enough space allocated!"
argument_list|)
expr_stmt|;
block|}
name|uintptr_t
name|getObjAddress
argument_list|()
specifier|const
block|{
return|return
name|ObjAddress
return|;
block|}
block|}
empty_stmt|;
comment|/// RelocationEntry - used to represent relocations internally in the dynamic
comment|/// linker.
name|class
name|RelocationEntry
block|{
name|public
label|:
comment|/// SectionID - the section this relocation points to.
name|unsigned
name|SectionID
decl_stmt|;
comment|/// Offset - offset into the section.
name|uint64_t
name|Offset
decl_stmt|;
comment|/// RelType - relocation type.
name|uint32_t
name|RelType
decl_stmt|;
comment|/// Addend - the relocation addend encoded in the instruction itself.  Also
comment|/// used to make a relocation section relative instead of symbol relative.
name|int64_t
name|Addend
decl_stmt|;
struct|struct
name|SectionPair
block|{
name|uint32_t
name|SectionA
decl_stmt|;
name|uint32_t
name|SectionB
decl_stmt|;
block|}
struct|;
comment|/// SymOffset - Section offset of the relocation entry's symbol (used for GOT
comment|/// lookup).
union|union
block|{
name|uint64_t
name|SymOffset
decl_stmt|;
name|SectionPair
name|Sections
decl_stmt|;
block|}
union|;
comment|/// True if this is a PCRel relocation (MachO specific).
name|bool
name|IsPCRel
decl_stmt|;
comment|/// The size of this relocation (MachO specific).
name|unsigned
name|Size
decl_stmt|;
comment|// COFF specific.
name|bool
name|IsTargetThumbFunc
decl_stmt|;
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|)
block|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
name|addend
argument_list|)
operator|,
name|SymOffset
argument_list|(
literal|0
argument_list|)
operator|,
name|IsPCRel
argument_list|(
name|false
argument_list|)
operator|,
name|Size
argument_list|(
literal|0
argument_list|)
operator|,
name|IsTargetThumbFunc
argument_list|(
argument|false
argument_list|)
block|{}
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|,
argument|uint64_t symoffset
argument_list|)
operator|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
name|addend
argument_list|)
operator|,
name|SymOffset
argument_list|(
name|symoffset
argument_list|)
operator|,
name|IsPCRel
argument_list|(
name|false
argument_list|)
operator|,
name|Size
argument_list|(
literal|0
argument_list|)
operator|,
name|IsTargetThumbFunc
argument_list|(
argument|false
argument_list|)
block|{}
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|,
argument|bool IsPCRel
argument_list|,
argument|unsigned Size
argument_list|)
operator|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
name|addend
argument_list|)
operator|,
name|SymOffset
argument_list|(
literal|0
argument_list|)
operator|,
name|IsPCRel
argument_list|(
name|IsPCRel
argument_list|)
operator|,
name|Size
argument_list|(
name|Size
argument_list|)
operator|,
name|IsTargetThumbFunc
argument_list|(
argument|false
argument_list|)
block|{}
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|,
argument|unsigned SectionA
argument_list|,
argument|uint64_t SectionAOffset
argument_list|,
argument|unsigned SectionB
argument_list|,
argument|uint64_t SectionBOffset
argument_list|,
argument|bool IsPCRel
argument_list|,
argument|unsigned Size
argument_list|)
operator|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
name|SectionAOffset
operator|-
name|SectionBOffset
operator|+
name|addend
argument_list|)
operator|,
name|IsPCRel
argument_list|(
name|IsPCRel
argument_list|)
operator|,
name|Size
argument_list|(
name|Size
argument_list|)
operator|,
name|IsTargetThumbFunc
argument_list|(
argument|false
argument_list|)
block|{
name|Sections
operator|.
name|SectionA
operator|=
name|SectionA
block|;
name|Sections
operator|.
name|SectionB
operator|=
name|SectionB
block|;   }
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|,
argument|unsigned SectionA
argument_list|,
argument|uint64_t SectionAOffset
argument_list|,
argument|unsigned SectionB
argument_list|,
argument|uint64_t SectionBOffset
argument_list|,
argument|bool IsPCRel
argument_list|,
argument|unsigned Size
argument_list|,
argument|bool IsTargetThumbFunc
argument_list|)
operator|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
name|SectionAOffset
operator|-
name|SectionBOffset
operator|+
name|addend
argument_list|)
operator|,
name|IsPCRel
argument_list|(
name|IsPCRel
argument_list|)
operator|,
name|Size
argument_list|(
name|Size
argument_list|)
operator|,
name|IsTargetThumbFunc
argument_list|(
argument|IsTargetThumbFunc
argument_list|)
block|{
name|Sections
operator|.
name|SectionA
operator|=
name|SectionA
block|;
name|Sections
operator|.
name|SectionB
operator|=
name|SectionB
block|;   }
block|}
empty_stmt|;
name|class
name|RelocationValueRef
block|{
name|public
label|:
name|unsigned
name|SectionID
decl_stmt|;
name|uint64_t
name|Offset
decl_stmt|;
name|int64_t
name|Addend
decl_stmt|;
specifier|const
name|char
modifier|*
name|SymbolName
decl_stmt|;
name|RelocationValueRef
argument_list|()
operator|:
name|SectionID
argument_list|(
literal|0
argument_list|)
operator|,
name|Offset
argument_list|(
literal|0
argument_list|)
operator|,
name|Addend
argument_list|(
literal|0
argument_list|)
operator|,
name|SymbolName
argument_list|(
argument|nullptr
argument_list|)
block|{}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RelocationValueRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|SectionID
operator|==
name|Other
operator|.
name|SectionID
operator|&&
name|Offset
operator|==
name|Other
operator|.
name|Offset
operator|&&
name|Addend
operator|==
name|Other
operator|.
name|Addend
operator|&&
name|SymbolName
operator|==
name|Other
operator|.
name|SymbolName
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|RelocationValueRef
operator|&
name|Other
operator|)
specifier|const
block|{
if|if
condition|(
name|SectionID
operator|!=
name|Other
operator|.
name|SectionID
condition|)
return|return
name|SectionID
operator|<
name|Other
operator|.
name|SectionID
return|;
if|if
condition|(
name|Offset
operator|!=
name|Other
operator|.
name|Offset
condition|)
return|return
name|Offset
operator|<
name|Other
operator|.
name|Offset
return|;
if|if
condition|(
name|Addend
operator|!=
name|Other
operator|.
name|Addend
condition|)
return|return
name|Addend
operator|<
name|Other
operator|.
name|Addend
return|;
return|return
name|SymbolName
operator|<
name|Other
operator|.
name|SymbolName
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// @brief Symbol info for RuntimeDyld.
end_comment

begin_decl_stmt
name|class
name|SymbolTableEntry
block|{
name|public
label|:
name|SymbolTableEntry
argument_list|()
operator|:
name|Offset
argument_list|(
literal|0
argument_list|)
operator|,
name|SectionID
argument_list|(
literal|0
argument_list|)
block|{}
name|SymbolTableEntry
argument_list|(
argument|unsigned SectionID
argument_list|,
argument|uint64_t Offset
argument_list|,
argument|JITSymbolFlags Flags
argument_list|)
operator|:
name|Offset
argument_list|(
name|Offset
argument_list|)
operator|,
name|SectionID
argument_list|(
name|SectionID
argument_list|)
operator|,
name|Flags
argument_list|(
argument|Flags
argument_list|)
block|{}
name|unsigned
name|getSectionID
argument_list|()
specifier|const
block|{
return|return
name|SectionID
return|;
block|}
name|uint64_t
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
name|JITSymbolFlags
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|private
label|:
name|uint64_t
name|Offset
decl_stmt|;
name|unsigned
name|SectionID
decl_stmt|;
name|JITSymbolFlags
name|Flags
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|StringMap
operator|<
name|SymbolTableEntry
operator|>
name|RTDyldSymbolTable
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|RuntimeDyldImpl
block|{
name|friend
name|class
name|RuntimeDyld
operator|::
name|LoadedObjectInfo
expr_stmt|;
name|friend
name|class
name|RuntimeDyldCheckerImpl
decl_stmt|;
name|protected
label|:
specifier|static
specifier|const
name|unsigned
name|AbsoluteSymbolSection
init|=
operator|~
literal|0U
decl_stmt|;
comment|// The MemoryManager to load objects into.
name|RuntimeDyld
operator|::
name|MemoryManager
operator|&
name|MemMgr
expr_stmt|;
comment|// The symbol resolver to use for external symbols.
name|JITSymbolResolver
modifier|&
name|Resolver
decl_stmt|;
comment|// Attached RuntimeDyldChecker instance. Null if no instance attached.
name|RuntimeDyldCheckerImpl
modifier|*
name|Checker
decl_stmt|;
comment|// A list of all sections emitted by the dynamic linker.  These sections are
comment|// referenced in the code by means of their index in this list - SectionID.
typedef|typedef
name|SmallVector
operator|<
name|SectionEntry
operator|,
literal|64
operator|>
name|SectionList
expr_stmt|;
name|SectionList
name|Sections
decl_stmt|;
typedef|typedef
name|unsigned
name|SID
typedef|;
comment|// Type for SectionIDs
define|#
directive|define
name|RTDYLD_INVALID_SECTION_ID
value|((RuntimeDyldImpl::SID)(-1))
comment|// Keep a map of sections from object file to the SectionID which
comment|// references it.
typedef|typedef
name|std
operator|::
name|map
operator|<
name|SectionRef
operator|,
name|unsigned
operator|>
name|ObjSectionToIDMap
expr_stmt|;
comment|// A global symbol table for symbols from all loaded modules.
name|RTDyldSymbolTable
name|GlobalSymbolTable
decl_stmt|;
comment|// Keep a map of common symbols to their info pairs
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|SymbolRef
operator|>
name|CommonSymbolList
expr_stmt|;
comment|// For each symbol, keep a list of relocations based on it. Anytime
comment|// its address is reassigned (the JIT re-compiled the function, e.g.),
comment|// the relocations get re-resolved.
comment|// The symbol (or section) the relocation is sourced from is the Key
comment|// in the relocation list where it's stored.
typedef|typedef
name|SmallVector
operator|<
name|RelocationEntry
operator|,
literal|64
operator|>
name|RelocationList
expr_stmt|;
comment|// Relocations to sections already loaded. Indexed by SectionID which is the
comment|// source of the address. The target where the address will be written is
comment|// SectionID/Offset in the relocation itself.
name|std
operator|::
name|unordered_map
operator|<
name|unsigned
operator|,
name|RelocationList
operator|>
name|Relocations
expr_stmt|;
comment|// Relocations to external symbols that are not yet resolved.  Symbols are
comment|// external when they aren't found in the global symbol table of all loaded
comment|// modules.  This map is indexed by symbol name.
name|StringMap
operator|<
name|RelocationList
operator|>
name|ExternalSymbolRelocations
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|RelocationValueRef
operator|,
name|uintptr_t
operator|>
name|StubMap
expr_stmt|;
name|Triple
operator|::
name|ArchType
name|Arch
expr_stmt|;
name|bool
name|IsTargetLittleEndian
decl_stmt|;
name|bool
name|IsMipsO32ABI
decl_stmt|;
name|bool
name|IsMipsN32ABI
decl_stmt|;
name|bool
name|IsMipsN64ABI
decl_stmt|;
comment|// True if all sections should be passed to the memory manager, false if only
comment|// sections containing relocations should be. Defaults to 'false'.
name|bool
name|ProcessAllSections
decl_stmt|;
comment|// This mutex prevents simultaneously loading objects from two different
comment|// threads.  This keeps us from having to protect individual data structures
comment|// and guarantees that section allocation requests to the memory manager
comment|// won't be interleaved between modules.  It is also used in mapSectionAddress
comment|// and resolveRelocations to protect write access to internal data structures.
comment|//
comment|// loadObject may be called on the same thread during the handling of of
comment|// processRelocations, and that's OK.  The handling of the relocation lists
comment|// is written in such a way as to work correctly if new elements are added to
comment|// the end of the list while the list is being processed.
name|sys
operator|::
name|Mutex
name|lock
expr_stmt|;
name|virtual
name|unsigned
name|getMaxStubSize
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|unsigned
name|getStubAlignment
parameter_list|()
init|=
literal|0
function_decl|;
name|bool
name|HasError
decl_stmt|;
name|std
operator|::
name|string
name|ErrorStr
expr_stmt|;
name|uint64_t
name|getSectionLoadAddress
argument_list|(
name|unsigned
name|SectionID
argument_list|)
decl|const
block|{
return|return
name|Sections
index|[
name|SectionID
index|]
operator|.
name|getLoadAddress
argument_list|()
return|;
block|}
name|uint8_t
modifier|*
name|getSectionAddress
argument_list|(
name|unsigned
name|SectionID
argument_list|)
decl|const
block|{
return|return
name|Sections
index|[
name|SectionID
index|]
operator|.
name|getAddress
argument_list|()
return|;
block|}
name|void
name|writeInt16BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint16_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|IsTargetLittleEndian
condition|)
name|sys
operator|::
name|swapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
name|void
name|writeInt32BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint32_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|IsTargetLittleEndian
condition|)
name|sys
operator|::
name|swapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|2
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|3
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
name|void
name|writeInt64BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|IsTargetLittleEndian
condition|)
name|sys
operator|::
name|swapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|56
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|48
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|2
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|40
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|3
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|32
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|4
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|5
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|6
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|7
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
name|virtual
name|void
name|setMipsABI
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|Obj
parameter_list|)
block|{
name|IsMipsO32ABI
operator|=
name|false
expr_stmt|;
name|IsMipsN32ABI
operator|=
name|false
expr_stmt|;
name|IsMipsN64ABI
operator|=
name|false
expr_stmt|;
block|}
comment|/// Endian-aware read Read the least significant Size bytes from Src.
name|uint64_t
name|readBytesUnaligned
argument_list|(
name|uint8_t
operator|*
name|Src
argument_list|,
name|unsigned
name|Size
argument_list|)
decl|const
decl_stmt|;
comment|/// Endian-aware write. Write the least significant Size bytes from Value to
comment|/// Dst.
name|void
name|writeBytesUnaligned
argument_list|(
name|uint64_t
name|Value
argument_list|,
name|uint8_t
operator|*
name|Dst
argument_list|,
name|unsigned
name|Size
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Given the common symbols discovered in the object file, emit a
comment|/// new section for them and update the symbol mappings in the object and
comment|/// symbol table.
name|Error
name|emitCommonSymbols
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|Obj
parameter_list|,
name|CommonSymbolList
modifier|&
name|CommonSymbols
parameter_list|)
function_decl|;
comment|/// \brief Emits section data from the object file to the MemoryManager.
comment|/// \param IsCode if it's true then allocateCodeSection() will be
comment|///        used for emits, else allocateDataSection() will be used.
comment|/// \return SectionID.
name|Expected
operator|<
name|unsigned
operator|>
name|emitSection
argument_list|(
argument|const ObjectFile&Obj
argument_list|,
argument|const SectionRef&Section
argument_list|,
argument|bool IsCode
argument_list|)
expr_stmt|;
comment|/// \brief Find Section in LocalSections. If the secton is not found - emit
comment|///        it and store in LocalSections.
comment|/// \param IsCode if it's true then allocateCodeSection() will be
comment|///        used for emmits, else allocateDataSection() will be used.
comment|/// \return SectionID.
name|Expected
operator|<
name|unsigned
operator|>
name|findOrEmitSection
argument_list|(
argument|const ObjectFile&Obj
argument_list|,
argument|const SectionRef&Section
argument_list|,
argument|bool IsCode
argument_list|,
argument|ObjSectionToIDMap&LocalSections
argument_list|)
expr_stmt|;
comment|// \brief Add a relocation entry that uses the given section.
name|void
name|addRelocationForSection
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|unsigned
name|SectionID
parameter_list|)
function_decl|;
comment|// \brief Add a relocation entry that uses the given symbol.  This symbol may
comment|// be found in the global symbol table, or it may be external.
name|void
name|addRelocationForSymbol
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|StringRef
name|SymbolName
parameter_list|)
function_decl|;
comment|/// \brief Emits long jump instruction to Addr.
comment|/// \return Pointer to the memory area for emitting target address.
name|uint8_t
modifier|*
name|createStubFunction
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|unsigned
name|AbiVariant
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// \brief Resolves relocations from Relocs list with address from Value.
name|void
name|resolveRelocationList
parameter_list|(
specifier|const
name|RelocationList
modifier|&
name|Relocs
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
function_decl|;
comment|/// \brief A object file specific relocation resolver
comment|/// \param RE The relocation to be resolved
comment|/// \param Value Target symbol address to apply the relocation action
name|virtual
name|void
name|resolveRelocation
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// \brief Parses one or more object file relocations (some object files use
comment|///        relocation pairs) and stores it to Relocations or SymbolRelocations
comment|///        (this depends on the object file type).
comment|/// \return Iterator to the next relocation that needs to be parsed.
name|virtual
name|Expected
operator|<
name|relocation_iterator
operator|>
name|processRelocationRef
argument_list|(
argument|unsigned SectionID
argument_list|,
argument|relocation_iterator RelI
argument_list|,
argument|const ObjectFile&Obj
argument_list|,
argument|ObjSectionToIDMap&ObjSectionToID
argument_list|,
argument|StubMap&Stubs
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/// \brief Resolve relocations to external symbols.
name|Error
name|resolveExternalSymbols
parameter_list|()
function_decl|;
comment|// \brief Compute an upper bound of the memory that is required to load all
comment|// sections
name|Error
name|computeTotalAllocSize
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|Obj
parameter_list|,
name|uint64_t
modifier|&
name|CodeSize
parameter_list|,
name|uint32_t
modifier|&
name|CodeAlign
parameter_list|,
name|uint64_t
modifier|&
name|RODataSize
parameter_list|,
name|uint32_t
modifier|&
name|RODataAlign
parameter_list|,
name|uint64_t
modifier|&
name|RWDataSize
parameter_list|,
name|uint32_t
modifier|&
name|RWDataAlign
parameter_list|)
function_decl|;
comment|// \brief Compute GOT size
name|unsigned
name|computeGOTSize
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|Obj
parameter_list|)
function_decl|;
comment|// \brief Compute the stub buffer size required for a section
name|unsigned
name|computeSectionStubBufSize
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|Obj
parameter_list|,
specifier|const
name|SectionRef
modifier|&
name|Section
parameter_list|)
function_decl|;
comment|// \brief Implementation of the generic part of the loadObject algorithm.
name|Expected
operator|<
name|ObjSectionToIDMap
operator|>
name|loadObjectImpl
argument_list|(
specifier|const
name|object
operator|::
name|ObjectFile
operator|&
name|Obj
argument_list|)
expr_stmt|;
comment|// \brief Return size of Global Offset Table (GOT) entry
name|virtual
name|size_t
name|getGOTEntrySize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|// \brief Return true if the relocation R may require allocating a GOT entry.
name|virtual
name|bool
name|relocationNeedsGot
argument_list|(
specifier|const
name|RelocationRef
operator|&
name|R
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
comment|// \brief Return true if the relocation R may require allocating a stub.
name|virtual
name|bool
name|relocationNeedsStub
argument_list|(
specifier|const
name|RelocationRef
operator|&
name|R
argument_list|)
decl|const
block|{
return|return
name|true
return|;
comment|// Conservative answer
block|}
name|public
label|:
name|RuntimeDyldImpl
argument_list|(
name|RuntimeDyld
operator|::
name|MemoryManager
operator|&
name|MemMgr
argument_list|,
name|JITSymbolResolver
operator|&
name|Resolver
argument_list|)
operator|:
name|MemMgr
argument_list|(
name|MemMgr
argument_list|)
operator|,
name|Resolver
argument_list|(
name|Resolver
argument_list|)
operator|,
name|Checker
argument_list|(
name|nullptr
argument_list|)
operator|,
name|ProcessAllSections
argument_list|(
name|false
argument_list|)
operator|,
name|HasError
argument_list|(
argument|false
argument_list|)
block|{   }
name|virtual
operator|~
name|RuntimeDyldImpl
argument_list|()
expr_stmt|;
name|void
name|setProcessAllSections
parameter_list|(
name|bool
name|ProcessAllSections
parameter_list|)
block|{
name|this
operator|->
name|ProcessAllSections
operator|=
name|ProcessAllSections
expr_stmt|;
block|}
name|void
name|setRuntimeDyldChecker
parameter_list|(
name|RuntimeDyldCheckerImpl
modifier|*
name|Checker
parameter_list|)
block|{
name|this
operator|->
name|Checker
operator|=
name|Checker
expr_stmt|;
block|}
name|virtual
name|std
operator|::
name|unique_ptr
operator|<
name|RuntimeDyld
operator|::
name|LoadedObjectInfo
operator|>
name|loadObject
argument_list|(
specifier|const
name|object
operator|::
name|ObjectFile
operator|&
name|Obj
argument_list|)
operator|=
literal|0
expr_stmt|;
name|uint8_t
modifier|*
name|getSymbolLocalAddress
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
block|{
comment|// FIXME: Just look up as a function for now. Overly simple of course.
comment|// Work in progress.
name|RTDyldSymbolTable
operator|::
name|const_iterator
name|pos
operator|=
name|GlobalSymbolTable
operator|.
name|find
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|GlobalSymbolTable
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
specifier|const
specifier|auto
modifier|&
name|SymInfo
init|=
name|pos
operator|->
name|second
decl_stmt|;
comment|// Absolute symbols do not have a local address.
if|if
condition|(
name|SymInfo
operator|.
name|getSectionID
argument_list|()
operator|==
name|AbsoluteSymbolSection
condition|)
return|return
name|nullptr
return|;
return|return
name|getSectionAddress
argument_list|(
name|SymInfo
operator|.
name|getSectionID
argument_list|()
argument_list|)
operator|+
name|SymInfo
operator|.
name|getOffset
argument_list|()
return|;
block|}
name|JITEvaluatedSymbol
name|getSymbol
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
block|{
comment|// FIXME: Just look up as a function for now. Overly simple of course.
comment|// Work in progress.
name|RTDyldSymbolTable
operator|::
name|const_iterator
name|pos
operator|=
name|GlobalSymbolTable
operator|.
name|find
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|GlobalSymbolTable
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
specifier|const
specifier|auto
modifier|&
name|SymEntry
init|=
name|pos
operator|->
name|second
decl_stmt|;
name|uint64_t
name|SectionAddr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SymEntry
operator|.
name|getSectionID
argument_list|()
operator|!=
name|AbsoluteSymbolSection
condition|)
name|SectionAddr
operator|=
name|getSectionLoadAddress
argument_list|(
name|SymEntry
operator|.
name|getSectionID
argument_list|()
argument_list|)
expr_stmt|;
name|uint64_t
name|TargetAddr
init|=
name|SectionAddr
operator|+
name|SymEntry
operator|.
name|getOffset
argument_list|()
decl_stmt|;
return|return
name|JITEvaluatedSymbol
argument_list|(
name|TargetAddr
argument_list|,
name|SymEntry
operator|.
name|getFlags
argument_list|()
argument_list|)
return|;
block|}
name|void
name|resolveRelocations
parameter_list|()
function_decl|;
name|void
name|reassignSectionAddress
parameter_list|(
name|unsigned
name|SectionID
parameter_list|,
name|uint64_t
name|Addr
parameter_list|)
function_decl|;
name|void
name|mapSectionAddress
parameter_list|(
specifier|const
name|void
modifier|*
name|LocalAddress
parameter_list|,
name|uint64_t
name|TargetAddress
parameter_list|)
function_decl|;
comment|// Is the linker in an error state?
name|bool
name|hasError
parameter_list|()
block|{
return|return
name|HasError
return|;
block|}
comment|// Mark the error condition as handled and continue.
name|void
name|clearError
parameter_list|()
block|{
name|HasError
operator|=
name|false
expr_stmt|;
block|}
comment|// Get the error message.
name|StringRef
name|getErrorString
parameter_list|()
block|{
return|return
name|ErrorStr
return|;
block|}
name|virtual
name|bool
name|isCompatibleFile
argument_list|(
specifier|const
name|ObjectFile
operator|&
name|Obj
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|registerEHFrames
parameter_list|()
function_decl|;
name|void
name|deregisterEHFrames
parameter_list|()
function_decl|;
name|virtual
name|Error
name|finalizeLoad
parameter_list|(
specifier|const
name|ObjectFile
modifier|&
name|ObjImg
parameter_list|,
name|ObjSectionToIDMap
modifier|&
name|SectionMap
parameter_list|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

