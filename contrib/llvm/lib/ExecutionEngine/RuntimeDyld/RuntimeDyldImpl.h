begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RuntimeDyldImpl.h - Run-time dynamic linker for MC-JIT --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Interface for the implementations of runtime dynamic linker facilities.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_RUNTIME_DYLD_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_RUNTIME_DYLD_IMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/ObjectImage.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/RuntimeDyld.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Format.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Host.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SwapByteOrder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/system_error.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|using
name|namespace
name|llvm
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|using
name|namespace
name|llvm
operator|::
name|object
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ObjectBuffer
decl_stmt|;
name|class
name|Twine
decl_stmt|;
comment|/// SectionEntry - represents a section emitted into memory by the dynamic
comment|/// linker.
name|class
name|SectionEntry
block|{
name|public
label|:
comment|/// Name - section name.
name|StringRef
name|Name
decl_stmt|;
comment|/// Address - address in the linker's memory where the section resides.
name|uint8_t
modifier|*
name|Address
decl_stmt|;
comment|/// Size - section size.
name|size_t
name|Size
decl_stmt|;
comment|/// LoadAddress - the address of the section in the target process's memory.
comment|/// Used for situations in which JIT-ed code is being executed in the address
comment|/// space of a separate process.  If the code executes in the same address
comment|/// space where it was JIT-ed, this just equals Address.
name|uint64_t
name|LoadAddress
decl_stmt|;
comment|/// StubOffset - used for architectures with stub functions for far
comment|/// relocations (like ARM).
name|uintptr_t
name|StubOffset
decl_stmt|;
comment|/// ObjAddress - address of the section in the in-memory object file.  Used
comment|/// for calculating relocations in some object formats (like MachO).
name|uintptr_t
name|ObjAddress
decl_stmt|;
name|SectionEntry
argument_list|(
argument|StringRef name
argument_list|,
argument|uint8_t *address
argument_list|,
argument|size_t size
argument_list|,
argument|uintptr_t stubOffset
argument_list|,
argument|uintptr_t objAddress
argument_list|)
block|:
name|Name
argument_list|(
name|name
argument_list|)
operator|,
name|Address
argument_list|(
name|address
argument_list|)
operator|,
name|Size
argument_list|(
name|size
argument_list|)
operator|,
name|LoadAddress
argument_list|(
operator|(
name|uintptr_t
operator|)
name|address
argument_list|)
operator|,
name|StubOffset
argument_list|(
name|stubOffset
argument_list|)
operator|,
name|ObjAddress
argument_list|(
argument|objAddress
argument_list|)
block|{}
block|}
empty_stmt|;
comment|/// RelocationEntry - used to represent relocations internally in the dynamic
comment|/// linker.
name|class
name|RelocationEntry
block|{
name|public
label|:
comment|/// SectionID - the section this relocation points to.
name|unsigned
name|SectionID
decl_stmt|;
comment|/// Offset - offset into the section.
name|uintptr_t
name|Offset
decl_stmt|;
comment|/// RelType - relocation type.
name|uint32_t
name|RelType
decl_stmt|;
comment|/// Addend - the relocation addend encoded in the instruction itself.  Also
comment|/// used to make a relocation section relative instead of symbol relative.
name|intptr_t
name|Addend
decl_stmt|;
name|RelocationEntry
argument_list|(
argument|unsigned id
argument_list|,
argument|uint64_t offset
argument_list|,
argument|uint32_t type
argument_list|,
argument|int64_t addend
argument_list|)
block|:
name|SectionID
argument_list|(
name|id
argument_list|)
operator|,
name|Offset
argument_list|(
name|offset
argument_list|)
operator|,
name|RelType
argument_list|(
name|type
argument_list|)
operator|,
name|Addend
argument_list|(
argument|addend
argument_list|)
block|{}
block|}
empty_stmt|;
comment|/// ObjRelocationInfo - relocation information as read from the object file.
comment|/// Used to pass around data taken from object::RelocationRef, together with
comment|/// the section to which the relocation points (represented by a SectionID).
name|class
name|ObjRelocationInfo
block|{
name|public
label|:
name|unsigned
name|SectionID
decl_stmt|;
name|uint64_t
name|Offset
decl_stmt|;
name|SymbolRef
name|Symbol
decl_stmt|;
name|uint64_t
name|Type
decl_stmt|;
name|int64_t
name|AdditionalInfo
decl_stmt|;
block|}
empty_stmt|;
name|class
name|RelocationValueRef
block|{
name|public
label|:
name|unsigned
name|SectionID
decl_stmt|;
name|intptr_t
name|Addend
decl_stmt|;
specifier|const
name|char
modifier|*
name|SymbolName
decl_stmt|;
name|RelocationValueRef
argument_list|()
operator|:
name|SectionID
argument_list|(
literal|0
argument_list|)
operator|,
name|Addend
argument_list|(
literal|0
argument_list|)
operator|,
name|SymbolName
argument_list|(
literal|0
argument_list|)
block|{}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RelocationValueRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|memcmp
argument_list|(
name|this
argument_list|,
operator|&
name|Other
argument_list|,
sizeof|sizeof
argument_list|(
name|RelocationValueRef
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|RelocationValueRef
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|memcmp
argument_list|(
name|this
argument_list|,
operator|&
name|Other
argument_list|,
sizeof|sizeof
argument_list|(
name|RelocationValueRef
argument_list|)
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
empty_stmt|;
name|class
name|RuntimeDyldImpl
block|{
name|protected
label|:
comment|// The MemoryManager to load objects into.
name|RTDyldMemoryManager
modifier|*
name|MemMgr
decl_stmt|;
comment|// A list of all sections emitted by the dynamic linker.  These sections are
comment|// referenced in the code by means of their index in this list - SectionID.
typedef|typedef
name|SmallVector
operator|<
name|SectionEntry
operator|,
literal|64
operator|>
name|SectionList
expr_stmt|;
name|SectionList
name|Sections
decl_stmt|;
comment|// Keep a map of sections from object file to the SectionID which
comment|// references it.
typedef|typedef
name|std
operator|::
name|map
operator|<
name|SectionRef
operator|,
name|unsigned
operator|>
name|ObjSectionToIDMap
expr_stmt|;
comment|// A global symbol table for symbols from all loaded modules.  Maps the
comment|// symbol name to a (SectionID, offset in section) pair.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|uintptr_t
operator|>
name|SymbolLoc
expr_stmt|;
typedef|typedef
name|StringMap
operator|<
name|SymbolLoc
operator|>
name|SymbolTableMap
expr_stmt|;
name|SymbolTableMap
name|GlobalSymbolTable
decl_stmt|;
comment|// Pair representing the size and alignment requirement for a common symbol.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|CommonSymbolInfo
expr_stmt|;
comment|// Keep a map of common symbols to their info pairs
typedef|typedef
name|std
operator|::
name|map
operator|<
name|SymbolRef
operator|,
name|CommonSymbolInfo
operator|>
name|CommonSymbolMap
expr_stmt|;
comment|// For each symbol, keep a list of relocations based on it. Anytime
comment|// its address is reassigned (the JIT re-compiled the function, e.g.),
comment|// the relocations get re-resolved.
comment|// The symbol (or section) the relocation is sourced from is the Key
comment|// in the relocation list where it's stored.
typedef|typedef
name|SmallVector
operator|<
name|RelocationEntry
operator|,
literal|64
operator|>
name|RelocationList
expr_stmt|;
comment|// Relocations to sections already loaded. Indexed by SectionID which is the
comment|// source of the address. The target where the address will be written is
comment|// SectionID/Offset in the relocation itself.
name|DenseMap
operator|<
name|unsigned
operator|,
name|RelocationList
operator|>
name|Relocations
expr_stmt|;
comment|// Relocations to external symbols that are not yet resolved.  Symbols are
comment|// external when they aren't found in the global symbol table of all loaded
comment|// modules.  This map is indexed by symbol name.
name|StringMap
operator|<
name|RelocationList
operator|>
name|ExternalSymbolRelocations
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|RelocationValueRef
operator|,
name|uintptr_t
operator|>
name|StubMap
expr_stmt|;
name|Triple
operator|::
name|ArchType
name|Arch
expr_stmt|;
specifier|inline
name|unsigned
name|getMaxStubSize
parameter_list|()
block|{
if|if
condition|(
name|Arch
operator|==
name|Triple
operator|::
name|arm
operator|||
name|Arch
operator|==
name|Triple
operator|::
name|thumb
condition|)
return|return
literal|8
return|;
comment|// 32-bit instruction and 32-bit address
elseif|else
if|if
condition|(
name|Arch
operator|==
name|Triple
operator|::
name|mipsel
operator|||
name|Arch
operator|==
name|Triple
operator|::
name|mips
condition|)
return|return
literal|16
return|;
elseif|else
if|if
condition|(
name|Arch
operator|==
name|Triple
operator|::
name|ppc64
condition|)
return|return
literal|44
return|;
else|else
return|return
literal|0
return|;
block|}
name|bool
name|HasError
decl_stmt|;
name|std
operator|::
name|string
name|ErrorStr
expr_stmt|;
comment|// Set the error state and record an error string.
name|bool
name|Error
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Msg
parameter_list|)
block|{
name|ErrorStr
operator|=
name|Msg
operator|.
name|str
argument_list|()
expr_stmt|;
name|HasError
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
name|uint64_t
name|getSectionLoadAddress
parameter_list|(
name|unsigned
name|SectionID
parameter_list|)
block|{
return|return
name|Sections
index|[
name|SectionID
index|]
operator|.
name|LoadAddress
return|;
block|}
name|uint8_t
modifier|*
name|getSectionAddress
parameter_list|(
name|unsigned
name|SectionID
parameter_list|)
block|{
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|Sections
index|[
name|SectionID
index|]
operator|.
name|Address
return|;
block|}
comment|// Subclasses can override this method to get the alignment requirement of
comment|// a common symbol. Returns no alignment requirement if not implemented.
name|virtual
name|unsigned
name|getCommonSymbolAlignment
parameter_list|(
specifier|const
name|SymbolRef
modifier|&
name|Sym
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|void
name|writeInt16BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint16_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|sys
operator|::
name|isLittleEndianHost
argument_list|()
condition|)
name|Value
operator|=
name|sys
operator|::
name|SwapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
name|void
name|writeInt32BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint32_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|sys
operator|::
name|isLittleEndianHost
argument_list|()
condition|)
name|Value
operator|=
name|sys
operator|::
name|SwapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|2
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|3
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
name|void
name|writeInt64BE
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
block|{
if|if
condition|(
name|sys
operator|::
name|isLittleEndianHost
argument_list|()
condition|)
name|Value
operator|=
name|sys
operator|::
name|SwapByteOrder
argument_list|(
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Addr
operator|=
operator|(
name|Value
operator|>>
literal|56
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|1
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|48
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|2
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|40
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|3
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|32
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|4
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|5
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|6
operator|)
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
operator|*
operator|(
name|Addr
operator|+
literal|7
operator|)
operator|=
name|Value
operator|&
literal|0xFF
expr_stmt|;
block|}
comment|/// \brief Given the common symbols discovered in the object file, emit a
comment|/// new section for them and update the symbol mappings in the object and
comment|/// symbol table.
name|void
name|emitCommonSymbols
parameter_list|(
name|ObjectImage
modifier|&
name|Obj
parameter_list|,
specifier|const
name|CommonSymbolMap
modifier|&
name|CommonSymbols
parameter_list|,
name|uint64_t
name|TotalSize
parameter_list|,
name|SymbolTableMap
modifier|&
name|SymbolTable
parameter_list|)
function_decl|;
comment|/// \brief Emits section data from the object file to the MemoryManager.
comment|/// \param IsCode if it's true then allocateCodeSection() will be
comment|///        used for emits, else allocateDataSection() will be used.
comment|/// \return SectionID.
name|unsigned
name|emitSection
parameter_list|(
name|ObjectImage
modifier|&
name|Obj
parameter_list|,
specifier|const
name|SectionRef
modifier|&
name|Section
parameter_list|,
name|bool
name|IsCode
parameter_list|)
function_decl|;
comment|/// \brief Find Section in LocalSections. If the secton is not found - emit
comment|///        it and store in LocalSections.
comment|/// \param IsCode if it's true then allocateCodeSection() will be
comment|///        used for emmits, else allocateDataSection() will be used.
comment|/// \return SectionID.
name|unsigned
name|findOrEmitSection
parameter_list|(
name|ObjectImage
modifier|&
name|Obj
parameter_list|,
specifier|const
name|SectionRef
modifier|&
name|Section
parameter_list|,
name|bool
name|IsCode
parameter_list|,
name|ObjSectionToIDMap
modifier|&
name|LocalSections
parameter_list|)
function_decl|;
comment|// \brief Add a relocation entry that uses the given section.
name|void
name|addRelocationForSection
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|unsigned
name|SectionID
parameter_list|)
function_decl|;
comment|// \brief Add a relocation entry that uses the given symbol.  This symbol may
comment|// be found in the global symbol table, or it may be external.
name|void
name|addRelocationForSymbol
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|StringRef
name|SymbolName
parameter_list|)
function_decl|;
comment|/// \brief Emits long jump instruction to Addr.
comment|/// \return Pointer to the memory area for emitting target address.
name|uint8_t
modifier|*
name|createStubFunction
parameter_list|(
name|uint8_t
modifier|*
name|Addr
parameter_list|)
function_decl|;
comment|/// \brief Resolves relocations from Relocs list with address from Value.
name|void
name|resolveRelocationList
parameter_list|(
specifier|const
name|RelocationList
modifier|&
name|Relocs
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
function_decl|;
name|void
name|resolveRelocationEntry
parameter_list|(
specifier|const
name|RelocationEntry
modifier|&
name|RE
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
function_decl|;
comment|/// \brief A object file specific relocation resolver
comment|/// \param Section The section where the relocation is being applied
comment|/// \param Offset The offset into the section for this relocation
comment|/// \param Value Target symbol address to apply the relocation action
comment|/// \param Type object file specific relocation type
comment|/// \param Addend A constant addend used to compute the value to be stored
comment|///        into the relocatable field
name|virtual
name|void
name|resolveRelocation
parameter_list|(
specifier|const
name|SectionEntry
modifier|&
name|Section
parameter_list|,
name|uint64_t
name|Offset
parameter_list|,
name|uint64_t
name|Value
parameter_list|,
name|uint32_t
name|Type
parameter_list|,
name|int64_t
name|Addend
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// \brief Parses the object file relocation and stores it to Relocations
comment|///        or SymbolRelocations (this depends on the object file type).
name|virtual
name|void
name|processRelocationRef
parameter_list|(
specifier|const
name|ObjRelocationInfo
modifier|&
name|Rel
parameter_list|,
name|ObjectImage
modifier|&
name|Obj
parameter_list|,
name|ObjSectionToIDMap
modifier|&
name|ObjSectionToID
parameter_list|,
specifier|const
name|SymbolTableMap
modifier|&
name|Symbols
parameter_list|,
name|StubMap
modifier|&
name|Stubs
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// \brief Resolve relocations to external symbols.
name|void
name|resolveExternalSymbols
parameter_list|()
function_decl|;
name|virtual
name|ObjectImage
modifier|*
name|createObjectImage
parameter_list|(
name|ObjectBuffer
modifier|*
name|InputBuffer
parameter_list|)
function_decl|;
name|public
label|:
name|RuntimeDyldImpl
argument_list|(
name|RTDyldMemoryManager
operator|*
name|mm
argument_list|)
operator|:
name|MemMgr
argument_list|(
name|mm
argument_list|)
operator|,
name|HasError
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
operator|~
name|RuntimeDyldImpl
argument_list|()
expr_stmt|;
name|ObjectImage
modifier|*
name|loadObject
parameter_list|(
name|ObjectBuffer
modifier|*
name|InputBuffer
parameter_list|)
function_decl|;
name|void
modifier|*
name|getSymbolAddress
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
comment|// FIXME: Just look up as a function for now. Overly simple of course.
comment|// Work in progress.
if|if
condition|(
name|GlobalSymbolTable
operator|.
name|find
argument_list|(
name|Name
argument_list|)
operator|==
name|GlobalSymbolTable
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
name|SymbolLoc
name|Loc
init|=
name|GlobalSymbolTable
operator|.
name|lookup
argument_list|(
name|Name
argument_list|)
decl_stmt|;
return|return
name|getSectionAddress
argument_list|(
name|Loc
operator|.
name|first
argument_list|)
operator|+
name|Loc
operator|.
name|second
return|;
block|}
name|uint64_t
name|getSymbolLoadAddress
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
comment|// FIXME: Just look up as a function for now. Overly simple of course.
comment|// Work in progress.
if|if
condition|(
name|GlobalSymbolTable
operator|.
name|find
argument_list|(
name|Name
argument_list|)
operator|==
name|GlobalSymbolTable
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
name|SymbolLoc
name|Loc
init|=
name|GlobalSymbolTable
operator|.
name|lookup
argument_list|(
name|Name
argument_list|)
decl_stmt|;
return|return
name|getSectionLoadAddress
argument_list|(
name|Loc
operator|.
name|first
argument_list|)
operator|+
name|Loc
operator|.
name|second
return|;
block|}
name|void
name|resolveRelocations
parameter_list|()
function_decl|;
name|void
name|reassignSectionAddress
parameter_list|(
name|unsigned
name|SectionID
parameter_list|,
name|uint64_t
name|Addr
parameter_list|)
function_decl|;
name|void
name|mapSectionAddress
parameter_list|(
specifier|const
name|void
modifier|*
name|LocalAddress
parameter_list|,
name|uint64_t
name|TargetAddress
parameter_list|)
function_decl|;
comment|// Is the linker in an error state?
name|bool
name|hasError
parameter_list|()
block|{
return|return
name|HasError
return|;
block|}
comment|// Mark the error condition as handled and continue.
name|void
name|clearError
parameter_list|()
block|{
name|HasError
operator|=
name|false
expr_stmt|;
block|}
comment|// Get the error message.
name|StringRef
name|getErrorString
parameter_list|()
block|{
return|return
name|ErrorStr
return|;
block|}
name|virtual
name|bool
name|isCompatibleFormat
argument_list|(
specifier|const
name|ObjectBuffer
operator|*
name|Buffer
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

