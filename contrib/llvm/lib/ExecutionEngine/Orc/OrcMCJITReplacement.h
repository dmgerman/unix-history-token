begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---- OrcMCJITReplacement.h - Orc based MCJIT replacement ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Orc based MCJIT replacement.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_EXECUTIONENGINE_ORC_ORCMCJITREPLACEMENT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_EXECUTIONENGINE_ORC_ORCMCJITREPLACEMENT_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/ExecutionEngine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/GenericValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/JITSymbol.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/RuntimeDyld.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/CompileUtils.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/IRCompileLayer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/LazyEmittingLayer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Mangler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/Archive.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/Binary.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|orc
block|{
name|class
name|OrcMCJITReplacement
range|:
name|public
name|ExecutionEngine
block|{
comment|// OrcMCJITReplacement needs to do a little extra book-keeping to ensure that
comment|// Orc's automatic finalization doesn't kick in earlier than MCJIT clients are
comment|// expecting - see finalizeMemory.
name|class
name|MCJITReplacementMemMgr
operator|:
name|public
name|MCJITMemoryManager
block|{
name|public
operator|:
name|MCJITReplacementMemMgr
argument_list|(
name|OrcMCJITReplacement
operator|&
name|M
argument_list|,
name|std
operator|::
name|shared_ptr
operator|<
name|MCJITMemoryManager
operator|>
name|ClientMM
argument_list|)
operator|:
name|M
argument_list|(
name|M
argument_list|)
block|,
name|ClientMM
argument_list|(
argument|std::move(ClientMM)
argument_list|)
block|{}
name|uint8_t
operator|*
name|allocateCodeSection
argument_list|(
argument|uintptr_t Size
argument_list|,
argument|unsigned Alignment
argument_list|,
argument|unsigned SectionID
argument_list|,
argument|StringRef SectionName
argument_list|)
name|override
block|{
name|uint8_t
operator|*
name|Addr
operator|=
name|ClientMM
operator|->
name|allocateCodeSection
argument_list|(
name|Size
argument_list|,
name|Alignment
argument_list|,
name|SectionID
argument_list|,
name|SectionName
argument_list|)
block|;
name|M
operator|.
name|SectionsAllocatedSinceLastLoad
operator|.
name|insert
argument_list|(
name|Addr
argument_list|)
block|;
return|return
name|Addr
return|;
block|}
name|uint8_t
operator|*
name|allocateDataSection
argument_list|(
argument|uintptr_t Size
argument_list|,
argument|unsigned Alignment
argument_list|,
argument|unsigned SectionID
argument_list|,
argument|StringRef SectionName
argument_list|,
argument|bool IsReadOnly
argument_list|)
name|override
block|{
name|uint8_t
operator|*
name|Addr
operator|=
name|ClientMM
operator|->
name|allocateDataSection
argument_list|(
name|Size
argument_list|,
name|Alignment
argument_list|,
name|SectionID
argument_list|,
name|SectionName
argument_list|,
name|IsReadOnly
argument_list|)
block|;
name|M
operator|.
name|SectionsAllocatedSinceLastLoad
operator|.
name|insert
argument_list|(
name|Addr
argument_list|)
block|;
return|return
name|Addr
return|;
block|}
name|void
name|reserveAllocationSpace
argument_list|(
argument|uintptr_t CodeSize
argument_list|,
argument|uint32_t CodeAlign
argument_list|,
argument|uintptr_t RODataSize
argument_list|,
argument|uint32_t RODataAlign
argument_list|,
argument|uintptr_t RWDataSize
argument_list|,
argument|uint32_t RWDataAlign
argument_list|)
name|override
block|{
return|return
name|ClientMM
operator|->
name|reserveAllocationSpace
argument_list|(
name|CodeSize
argument_list|,
name|CodeAlign
argument_list|,
name|RODataSize
argument_list|,
name|RODataAlign
argument_list|,
name|RWDataSize
argument_list|,
name|RWDataAlign
argument_list|)
return|;
block|}
name|bool
name|needsToReserveAllocationSpace
argument_list|()
name|override
block|{
return|return
name|ClientMM
operator|->
name|needsToReserveAllocationSpace
argument_list|()
return|;
block|}
name|void
name|registerEHFrames
argument_list|(
argument|uint8_t *Addr
argument_list|,
argument|uint64_t LoadAddr
argument_list|,
argument|size_t Size
argument_list|)
name|override
block|{
return|return
name|ClientMM
operator|->
name|registerEHFrames
argument_list|(
name|Addr
argument_list|,
name|LoadAddr
argument_list|,
name|Size
argument_list|)
return|;
block|}
name|void
name|deregisterEHFrames
argument_list|(
argument|uint8_t *Addr
argument_list|,
argument|uint64_t LoadAddr
argument_list|,
argument|size_t Size
argument_list|)
name|override
block|{
return|return
name|ClientMM
operator|->
name|deregisterEHFrames
argument_list|(
name|Addr
argument_list|,
name|LoadAddr
argument_list|,
name|Size
argument_list|)
return|;
block|}
name|void
name|notifyObjectLoaded
argument_list|(
argument|RuntimeDyld&RTDyld
argument_list|,
argument|const object::ObjectFile&O
argument_list|)
name|override
block|{
return|return
name|ClientMM
operator|->
name|notifyObjectLoaded
argument_list|(
name|RTDyld
argument_list|,
name|O
argument_list|)
return|;
block|}
name|void
name|notifyObjectLoaded
argument_list|(
argument|ExecutionEngine *EE
argument_list|,
argument|const object::ObjectFile&O
argument_list|)
name|override
block|{
return|return
name|ClientMM
operator|->
name|notifyObjectLoaded
argument_list|(
name|EE
argument_list|,
name|O
argument_list|)
return|;
block|}
name|bool
name|finalizeMemory
argument_list|(
argument|std::string *ErrMsg = nullptr
argument_list|)
name|override
block|{
comment|// Each set of objects loaded will be finalized exactly once, but since
comment|// symbol lookup during relocation may recursively trigger the
comment|// loading/relocation of other modules, and since we're forwarding all
comment|// finalizeMemory calls to a single underlying memory manager, we need to
comment|// defer forwarding the call on until all necessary objects have been
comment|// loaded. Otherwise, during the relocation of a leaf object, we will end
comment|// up finalizing memory, causing a crash further up the stack when we
comment|// attempt to apply relocations to finalized memory.
comment|// To avoid finalizing too early, look at how many objects have been
comment|// loaded but not yet finalized. This is a bit of a hack that relies on
comment|// the fact that we're lazily emitting object files: The only way you can
comment|// get more than one set of objects loaded but not yet finalized is if
comment|// they were loaded during relocation of another set.
if|if
condition|(
name|M
operator|.
name|UnfinalizedSections
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|ClientMM
operator|->
name|finalizeMemory
argument_list|(
name|ErrMsg
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|OrcMCJITReplacement
operator|&
name|M
block|;
name|std
operator|::
name|shared_ptr
operator|<
name|MCJITMemoryManager
operator|>
name|ClientMM
block|;   }
decl_stmt|;
name|class
name|LinkingResolver
range|:
name|public
name|JITSymbolResolver
block|{
name|public
operator|:
name|LinkingResolver
argument_list|(
name|OrcMCJITReplacement
operator|&
name|M
argument_list|)
operator|:
name|M
argument_list|(
argument|M
argument_list|)
block|{}
name|JITSymbol
name|findSymbol
argument_list|(
argument|const std::string&Name
argument_list|)
name|override
block|{
return|return
name|M
operator|.
name|ClientResolver
operator|->
name|findSymbol
argument_list|(
name|Name
argument_list|)
return|;
block|}
name|JITSymbol
name|findSymbolInLogicalDylib
argument_list|(
argument|const std::string&Name
argument_list|)
name|override
block|{
if|if
condition|(
name|auto
name|Sym
init|=
name|M
operator|.
name|findMangledSymbol
argument_list|(
name|Name
argument_list|)
condition|)
return|return
name|Sym
return|;
return|return
name|M
operator|.
name|ClientResolver
operator|->
name|findSymbolInLogicalDylib
argument_list|(
name|Name
argument_list|)
return|;
block|}
name|private
label|:
name|OrcMCJITReplacement
modifier|&
name|M
decl_stmt|;
block|}
empty_stmt|;
name|private
label|:
specifier|static
name|ExecutionEngine
modifier|*
name|createOrcMCJITReplacement
argument_list|(
name|std
operator|::
name|string
operator|*
name|ErrorMsg
argument_list|,
name|std
operator|::
name|shared_ptr
operator|<
name|MCJITMemoryManager
operator|>
name|MemMgr
argument_list|,
name|std
operator|::
name|shared_ptr
operator|<
name|JITSymbolResolver
operator|>
name|Resolver
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|TargetMachine
operator|>
name|TM
argument_list|)
block|{
return|return
name|new
name|OrcMCJITReplacement
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|MemMgr
argument_list|)
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Resolver
argument_list|)
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|TM
argument_list|)
argument_list|)
return|;
block|}
name|public
label|:
specifier|static
name|void
name|Register
parameter_list|()
block|{
name|OrcMCJITReplacementCtor
operator|=
name|createOrcMCJITReplacement
expr_stmt|;
block|}
name|OrcMCJITReplacement
argument_list|(
name|std
operator|::
name|shared_ptr
operator|<
name|MCJITMemoryManager
operator|>
name|MemMgr
argument_list|,
name|std
operator|::
name|shared_ptr
operator|<
name|JITSymbolResolver
operator|>
name|ClientResolver
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|TargetMachine
operator|>
name|TM
argument_list|)
operator|:
name|ExecutionEngine
argument_list|(
name|TM
operator|->
name|createDataLayout
argument_list|()
argument_list|)
operator|,
name|TM
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|TM
argument_list|)
argument_list|)
operator|,
name|MemMgr
argument_list|(
operator|*
name|this
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|MemMgr
argument_list|)
argument_list|)
operator|,
name|Resolver
argument_list|(
operator|*
name|this
argument_list|)
operator|,
name|ClientResolver
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ClientResolver
argument_list|)
argument_list|)
operator|,
name|NotifyObjectLoaded
argument_list|(
operator|*
name|this
argument_list|)
operator|,
name|NotifyFinalized
argument_list|(
operator|*
name|this
argument_list|)
operator|,
name|ObjectLayer
argument_list|(
name|NotifyObjectLoaded
argument_list|,
name|NotifyFinalized
argument_list|)
operator|,
name|CompileLayer
argument_list|(
name|ObjectLayer
argument_list|,
name|SimpleCompiler
argument_list|(
operator|*
name|this
operator|->
name|TM
argument_list|)
argument_list|)
operator|,
name|LazyEmitLayer
argument_list|(
argument|CompileLayer
argument_list|)
block|{}
name|void
name|addModule
argument_list|(
argument|std::unique_ptr<Module> M
argument_list|)
name|override
block|{
comment|// If this module doesn't have a DataLayout attached then attach the
comment|// default.
if|if
condition|(
name|M
operator|->
name|getDataLayout
argument_list|()
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|M
operator|->
name|setDataLayout
argument_list|(
name|getDataLayout
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|M
operator|->
name|getDataLayout
argument_list|()
operator|==
name|getDataLayout
argument_list|()
operator|&&
literal|"DataLayout Mismatch"
argument_list|)
expr_stmt|;
block|}
name|Modules
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|M
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Module
operator|*
operator|>
name|Ms
expr_stmt|;
name|Ms
operator|.
name|push_back
argument_list|(
operator|&
operator|*
name|Modules
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|LazyEmitLayer
operator|.
name|addModuleSet
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Ms
argument_list|)
argument_list|,
operator|&
name|MemMgr
argument_list|,
operator|&
name|Resolver
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|addObjectFile
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|ObjectFile
operator|>
name|O
argument_list|)
name|override
block|{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|ObjectFile
operator|>>
name|Objs
expr_stmt|;
name|Objs
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|O
argument_list|)
argument_list|)
expr_stmt|;
name|ObjectLayer
operator|.
name|addObjectSet
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Objs
argument_list|)
argument_list|,
operator|&
name|MemMgr
argument_list|,
operator|&
name|Resolver
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|addObjectFile
argument_list|(
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|ObjectFile
operator|>
name|O
argument_list|)
name|override
block|{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|ObjectFile
operator|>>>
name|Objs
expr_stmt|;
name|Objs
operator|.
name|push_back
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|ObjectFile
operator|>>
operator|(
name|std
operator|::
name|move
argument_list|(
name|O
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ObjectLayer
operator|.
name|addObjectSet
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Objs
argument_list|)
argument_list|,
operator|&
name|MemMgr
argument_list|,
operator|&
name|Resolver
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|addArchive
argument_list|(
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|Archive
operator|>
name|A
argument_list|)
name|override
block|{
name|Archives
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|A
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|uint64_t
name|getSymbolAddress
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
return|return
name|findSymbol
argument_list|(
name|Name
argument_list|)
operator|.
name|getAddress
argument_list|()
return|;
block|}
end_function

begin_function
name|JITSymbol
name|findSymbol
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
return|return
name|findMangledSymbol
argument_list|(
name|Mangle
argument_list|(
name|Name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|finalizeObject
parameter_list|()
function|override
block|{
comment|// This is deprecated - Aim to remove in ExecutionEngine.
comment|// REMOVE IF POSSIBLE - Doesn't make sense for New JIT.
block|}
end_function

begin_function
name|void
name|mapSectionAddress
parameter_list|(
specifier|const
name|void
modifier|*
name|LocalAddress
parameter_list|,
name|uint64_t
name|TargetAddress
parameter_list|)
function|override
block|{
for|for
control|(
name|auto
operator|&
name|P
operator|:
name|UnfinalizedSections
control|)
if|if
condition|(
name|P
operator|.
name|second
operator|.
name|count
argument_list|(
name|LocalAddress
argument_list|)
condition|)
name|ObjectLayer
operator|.
name|mapSectionAddress
argument_list|(
name|P
operator|.
name|first
argument_list|,
name|LocalAddress
argument_list|,
name|TargetAddress
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|uint64_t
name|getGlobalValueAddress
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
name|override
block|{
return|return
name|getSymbolAddress
argument_list|(
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|getFunctionAddress
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
name|override
block|{
return|return
name|getSymbolAddress
argument_list|(
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
modifier|*
name|getPointerToFunction
parameter_list|(
name|Function
modifier|*
name|F
parameter_list|)
function|override
block|{
name|uint64_t
name|FAddr
init|=
name|getSymbolAddress
argument_list|(
name|F
operator|->
name|getName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|FAddr
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|getPointerToNamedFunction
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|bool
name|AbortOnFailure
init|=
name|true
parameter_list|)
function|override
block|{
name|uint64_t
name|Addr
init|=
name|getSymbolAddress
argument_list|(
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Addr
operator|&&
name|AbortOnFailure
condition|)
name|llvm_unreachable
argument_list|(
literal|"Missing symbol!"
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Addr
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|GenericValue
name|runFunction
argument_list|(
name|Function
operator|*
name|F
argument_list|,
name|ArrayRef
operator|<
name|GenericValue
operator|>
name|ArgValues
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setObjectCache
parameter_list|(
name|ObjectCache
modifier|*
name|NewCache
parameter_list|)
function|override
block|{
name|CompileLayer
operator|.
name|setObjectCache
argument_list|(
name|NewCache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setProcessAllSections
parameter_list|(
name|bool
name|ProcessAllSections
parameter_list|)
function|override
block|{
name|ObjectLayer
operator|.
name|setProcessAllSections
argument_list|(
name|ProcessAllSections
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function
name|JITSymbol
name|findMangledSymbol
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
if|if
condition|(
name|auto
name|Sym
init|=
name|LazyEmitLayer
operator|.
name|findSymbol
argument_list|(
name|Name
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|Sym
return|;
if|if
condition|(
name|auto
name|Sym
init|=
name|ClientResolver
operator|->
name|findSymbol
argument_list|(
name|Name
argument_list|)
condition|)
return|return
name|Sym
return|;
if|if
condition|(
name|auto
name|Sym
init|=
name|scanArchives
argument_list|(
name|Name
argument_list|)
condition|)
return|return
name|Sym
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_function
name|JITSymbol
name|scanArchives
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
for|for
control|(
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|Archive
operator|>
operator|&
name|OB
operator|:
name|Archives
control|)
block|{
name|object
operator|::
name|Archive
operator|*
name|A
operator|=
name|OB
operator|.
name|getBinary
argument_list|()
expr_stmt|;
comment|// Look for our symbols in each Archive
name|auto
name|OptionalChildOrErr
init|=
name|A
operator|->
name|findSym
argument_list|(
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|OptionalChildOrErr
condition|)
name|report_fatal_error
argument_list|(
name|OptionalChildOrErr
operator|.
name|takeError
argument_list|()
argument_list|)
expr_stmt|;
name|auto
operator|&
name|OptionalChild
operator|=
operator|*
name|OptionalChildOrErr
expr_stmt|;
if|if
condition|(
name|OptionalChild
condition|)
block|{
comment|// FIXME: Support nested archives?
name|Expected
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|Binary
operator|>>
name|ChildBinOrErr
operator|=
name|OptionalChild
operator|->
name|getAsBinary
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ChildBinOrErr
condition|)
block|{
comment|// TODO: Actually report errors helpfully.
name|consumeError
argument_list|(
name|ChildBinOrErr
operator|.
name|takeError
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|Binary
operator|>
operator|&
name|ChildBin
operator|=
name|ChildBinOrErr
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|ChildBin
operator|->
name|isObject
argument_list|()
condition|)
block|{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|ObjectFile
operator|>>
name|ObjSet
expr_stmt|;
name|ObjSet
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|object
operator|::
name|ObjectFile
operator|>
operator|(
name|static_cast
operator|<
name|object
operator|::
name|ObjectFile
operator|*
operator|>
operator|(
name|ChildBin
operator|.
name|release
argument_list|()
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ObjectLayer
operator|.
name|addObjectSet
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ObjSet
argument_list|)
argument_list|,
operator|&
name|MemMgr
argument_list|,
operator|&
name|Resolver
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto
name|Sym
init|=
name|ObjectLayer
operator|.
name|findSymbol
argument_list|(
name|Name
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|Sym
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_function

begin_decl_stmt
name|class
name|NotifyObjectLoadedT
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|RuntimeDyld
operator|::
name|LoadedObjectInfo
operator|>>
name|LoadedObjInfoListT
expr_stmt|;
name|NotifyObjectLoadedT
argument_list|(
name|OrcMCJITReplacement
operator|&
name|M
argument_list|)
operator|:
name|M
argument_list|(
argument|M
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ObjListT
operator|>
name|void
name|operator
argument_list|()
operator|(
name|RTDyldObjectLinkingLayerBase
operator|::
name|ObjSetHandleT
name|H
operator|,
specifier|const
name|ObjListT
operator|&
name|Objects
operator|,
specifier|const
name|LoadedObjInfoListT
operator|&
name|Infos
operator|)
specifier|const
block|{
name|M
operator|.
name|UnfinalizedSections
index|[
name|H
index|]
operator|=
name|std
operator|::
name|move
argument_list|(
name|M
operator|.
name|SectionsAllocatedSinceLastLoad
argument_list|)
block|;
name|M
operator|.
name|SectionsAllocatedSinceLastLoad
operator|=
name|SectionAddrSet
argument_list|()
block|;
name|assert
argument_list|(
name|Objects
operator|.
name|size
argument_list|()
operator|==
name|Infos
operator|.
name|size
argument_list|()
operator|&&
literal|"Incorrect number of Infos for Objects."
argument_list|)
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Objects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|I
control|)
name|M
operator|.
name|MemMgr
operator|.
name|notifyObjectLoaded
argument_list|(
operator|&
name|M
argument_list|,
name|getObject
argument_list|(
operator|*
name|Objects
index|[
name|I
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|private
label|:
specifier|static
specifier|const
name|object
operator|::
name|ObjectFile
operator|&
name|getObject
argument_list|(
argument|const object::ObjectFile&Obj
argument_list|)
block|{
return|return
name|Obj
return|;
block|}
name|template
operator|<
name|typename
name|ObjT
operator|>
specifier|static
specifier|const
name|object
operator|::
name|ObjectFile
operator|&
name|getObject
argument_list|(
argument|const object::OwningBinary<ObjT>&Obj
argument_list|)
block|{
return|return
operator|*
name|Obj
operator|.
name|getBinary
argument_list|()
return|;
block|}
name|OrcMCJITReplacement
modifier|&
name|M
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|NotifyFinalizedT
block|{
name|public
label|:
name|NotifyFinalizedT
argument_list|(
name|OrcMCJITReplacement
operator|&
name|M
argument_list|)
operator|:
name|M
argument_list|(
argument|M
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|RTDyldObjectLinkingLayerBase
operator|::
name|ObjSetHandleT
name|H
operator|)
block|{
name|M
operator|.
name|UnfinalizedSections
operator|.
name|erase
argument_list|(
name|H
argument_list|)
block|;     }
name|private
operator|:
name|OrcMCJITReplacement
operator|&
name|M
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|Mangle
argument_list|(
argument|StringRef Name
argument_list|)
block|{
name|std
operator|::
name|string
name|MangledName
block|;
block|{
name|raw_string_ostream
name|MangledNameStream
argument_list|(
name|MangledName
argument_list|)
block|;
name|Mang
operator|.
name|getNameWithPrefix
argument_list|(
name|MangledNameStream
argument_list|,
name|Name
argument_list|,
name|getDataLayout
argument_list|()
argument_list|)
block|;     }
return|return
name|MangledName
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|RTDyldObjectLinkingLayer
operator|<
name|NotifyObjectLoadedT
operator|>
name|ObjectLayerT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|IRCompileLayer
operator|<
name|ObjectLayerT
operator|>
name|CompileLayerT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|LazyEmittingLayer
operator|<
name|CompileLayerT
operator|>
name|LazyEmitLayerT
expr_stmt|;
end_typedef

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|TargetMachine
operator|>
name|TM
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MCJITReplacementMemMgr
name|MemMgr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LinkingResolver
name|Resolver
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|shared_ptr
operator|<
name|JITSymbolResolver
operator|>
name|ClientResolver
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Mangler
name|Mang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NotifyObjectLoadedT
name|NotifyObjectLoaded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NotifyFinalizedT
name|NotifyFinalized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ObjectLayerT
name|ObjectLayer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CompileLayerT
name|CompileLayer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LazyEmitLayerT
name|LazyEmitLayer
decl_stmt|;
end_decl_stmt

begin_comment
comment|// We need to store ObjLayerT::ObjSetHandles for each of the object sets
end_comment

begin_comment
comment|// that have been emitted but not yet finalized so that we can forward the
end_comment

begin_comment
comment|// mapSectionAddress calls appropriately.
end_comment

begin_typedef
typedef|typedef
name|std
operator|::
name|set
operator|<
specifier|const
name|void
operator|*
operator|>
name|SectionAddrSet
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|ObjSetHandleCompare
block|{
name|bool
name|operator
argument_list|()
operator|(
name|ObjectLayerT
operator|::
name|ObjSetHandleT
name|H1
operator|,
name|ObjectLayerT
operator|::
name|ObjSetHandleT
name|H2
operator|)
specifier|const
block|{
return|return
operator|&
operator|*
name|H1
operator|<
operator|&
operator|*
name|H2
return|;
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|SectionAddrSet
name|SectionsAllocatedSinceLastLoad
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|ObjectLayerT
operator|::
name|ObjSetHandleT
operator|,
name|SectionAddrSet
operator|,
name|ObjSetHandleCompare
operator|>
name|UnfinalizedSections
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|object
operator|::
name|OwningBinary
operator|<
name|object
operator|::
name|Archive
operator|>>
name|Archives
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace orc
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_EXECUTIONENGINE_ORC_MCJITREPLACEMENT_H
end_comment

end_unit

