begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*  *  *                     The LLVM Compiler Infrastructure  *  * This file is distributed under the University of Illinois Open Source  * License. See LICENSE.TXT for details.  *  *===----------------------------------------------------------------------===*  *  * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time)   * Profiling API implementation.   *  * NOTE: This file comes in a style different from the rest of LLVM  * source base since  this is a piece of code shared from Intel(R)  * products.  Please do not reformat / re-style this code to make  * subsequent merges and contributions from the original source base eaiser.  *  *===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|"ittnotify_config.h"
end_include

begin_if
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|""
name|,
name|off
name|)
end_pragma

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"jitprofiling.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"\n@(#) $Revision: 243501 $\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DLL_ENVIRONMENT_VAR
value|"VS_PROFILER"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NEW_DLL_ENVIRONMENT_VAR
end_ifndef

begin_if
if|#
directive|if
name|ITT_ARCH
operator|==
name|ITT_ARCH_IA32
end_if

begin_define
define|#
directive|define
name|NEW_DLL_ENVIRONMENT_VAR
value|"INTEL_JIT_PROFILER32"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NEW_DLL_ENVIRONMENT_VAR
value|"INTEL_JIT_PROFILER64"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_DLL_ENVIRONMENT_VAR */
end_comment

begin_if
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
end_if

begin_define
define|#
directive|define
name|DEFAULT_DLLNAME
value|"JitPI.dll"
end_define

begin_decl_stmt
name|HINSTANCE
name|m_libHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DLLNAME
value|"libJitPI.so"
end_define

begin_decl_stmt
name|void
modifier|*
name|m_libHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_comment
comment|/* default location of JIT profiling agent on Android */
end_comment

begin_define
define|#
directive|define
name|ANDROID_JIT_AGENT_PATH
value|"/data/intel/libittnotify.so"
end_define

begin_comment
comment|/* the function pointers */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
function_decl|(
modifier|*
name|TPInitialize
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|TPInitialize
name|FUNC_Initialize
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
function_decl|(
modifier|*
name|TPNotify
function_decl|)
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|TPNotify
name|FUNC_NotifyEvent
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|iJIT_IsProfilingActiveFlags
name|executionMode
init|=
name|iJIT_NOTHING_RUNNING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end collector dll part. */
end_comment

begin_comment
comment|/* loadiJIT_Funcs() : this function is called just in the beginning   *  and is responsible to load the functions from BistroJavaCollector.dll  * result:  *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1  *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0  */
end_comment

begin_function_decl
specifier|static
name|int
name|loadiJIT_Funcs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* global representing whether the BistroJavaCollector can't be loaded */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iJIT_DLL_is_missing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual stack - the struct is used as a virtual stack for each thread.  * Every thread initializes with a stack of size INIT_TOP_STACK.  * Every method entry decreases from the current stack point,  * and when a thread stack reaches its top of stack (return from the global   * function), the top of stack and the current stack increase. Notice that   * when returning from a function the stack pointer is the address of   * the function return. */
end_comment

begin_if
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
end_if

begin_decl_stmt
specifier|static
name|DWORD
name|threadLocalStorageHandle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_decl_stmt
specifier|static
name|pthread_key_t
name|threadLocalStorageHandle
init|=
operator|(
name|pthread_key_t
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
end_comment

begin_define
define|#
directive|define
name|INIT_TOP_Stack
value|10000
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|TopStack
decl_stmt|;
name|unsigned
name|int
name|CurrentStack
decl_stmt|;
block|}
name|ThreadStack
operator|,
typedef|*
name|pThreadStack
typedef|;
end_typedef

begin_comment
comment|/* end of virtual stack. */
end_comment

begin_comment
comment|/*  * The function for reporting virtual-machine related events to VTune.  * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill   * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.  * The return value in iJVM_EVENT_TYPE_ENTER_NIDS&&   * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.  * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event   * it will be -1 if EventSpecificData == 0 otherwise it will be 0. */
end_comment

begin_function
name|ITT_EXTERN_C
name|int
name|JITAPI
name|iJIT_NotifyEvent
parameter_list|(
name|iJIT_JVM_EVENT
name|event_type
parameter_list|,
name|void
modifier|*
name|EventSpecificData
parameter_list|)
block|{
name|int
name|ReturnValue
decl_stmt|;
comment|/*      * This section is for debugging outside of VTune.       * It creates the environment variables that indicates call graph mode.      * If running outside of VTune remove the remark.      *      *      * static int firstTime = 1;      * char DoCallGraph[12] = "DoCallGraph";      * if (firstTime)      * {      * firstTime = 0;      * SetEnvironmentVariable( "BISTRO_COLLECTORS_DO_CALLGRAPH", DoCallGraph);      * }      *      * end of section.     */
comment|/* initialization part - the functions have not been loaded yet. This part      *        will load the functions, and check if we are in Call Graph mode.       *        (for special treatment).      */
if|if
condition|(
operator|!
name|FUNC_NotifyEvent
condition|)
block|{
if|if
condition|(
name|iJIT_DLL_is_missing
condition|)
return|return
literal|0
return|;
comment|/* load the Function from the DLL */
if|if
condition|(
operator|!
name|loadiJIT_Funcs
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* Call Graph initialization. */
block|}
comment|/* If the event is method entry/exit, check that in the current mode       * VTune is allowed to receive it      */
if|if
condition|(
operator|(
name|event_type
operator|==
name|iJVM_EVENT_TYPE_ENTER_NIDS
operator|||
name|event_type
operator|==
name|iJVM_EVENT_TYPE_LEAVE_NIDS
operator|)
operator|&&
operator|(
name|executionMode
operator|!=
name|iJIT_CALLGRAPH_ON
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* This section is performed when method enter event occurs.      * It updates the virtual stack, or creates it if this is the first       * method entry in the thread. The stack pointer is decreased.      */
if|if
condition|(
name|event_type
operator|==
name|iJVM_EVENT_TYPE_ENTER_NIDS
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|TlsGetValue
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|pthread_getspecific
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
comment|/* check for use of reserved method IDs */
if|if
condition|(
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|method_id
operator|<=
literal|999
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|threadStack
condition|)
block|{
comment|/* initialize the stack. */
name|threadStack
operator|=
operator|(
name|pThreadStack
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ThreadStack
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|threadStack
operator|->
name|TopStack
operator|=
name|INIT_TOP_Stack
expr_stmt|;
name|threadStack
operator|->
name|CurrentStack
operator|=
name|INIT_TOP_Stack
expr_stmt|;
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|TlsSetValue
argument_list|(
name|threadLocalStorageHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|threadStack
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pthread_setspecific
argument_list|(
name|threadLocalStorageHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|threadStack
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
block|}
comment|/* decrease the stack. */
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|stack_id
operator|=
operator|(
name|threadStack
operator|->
name|CurrentStack
operator|)
operator|--
expr_stmt|;
block|}
comment|/* This section is performed when method leave event occurs      * It updates the virtual stack.      *    Increases the stack pointer.      *    If the stack pointer reached the top (left the global function)      *        increase the pointer and the top pointer.      */
if|if
condition|(
name|event_type
operator|==
name|iJVM_EVENT_TYPE_LEAVE_NIDS
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|TlsGetValue
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|pthread_getspecific
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
comment|/* check for use of reserved method IDs */
if|if
condition|(
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|method_id
operator|<=
literal|999
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|threadStack
condition|)
block|{
comment|/* Error: first report in this thread is method exit */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|stack_id
operator|=
operator|++
operator|(
name|threadStack
operator|->
name|CurrentStack
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|stack_id
operator|>
name|threadStack
operator|->
name|TopStack
condition|)
operator|(
operator|(
name|piJIT_Method_NIDS
operator|)
name|EventSpecificData
operator|)
operator|->
name|stack_id
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|event_type
operator|==
name|iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED
condition|)
block|{
comment|/* check for use of reserved method IDs */
if|if
condition|(
operator|(
operator|(
name|piJIT_Method_Load
operator|)
name|EventSpecificData
operator|)
operator|->
name|method_id
operator|<=
literal|999
condition|)
return|return
literal|0
return|;
block|}
name|ReturnValue
operator|=
operator|(
name|int
operator|)
name|FUNC_NotifyEvent
argument_list|(
name|event_type
argument_list|,
name|EventSpecificData
argument_list|)
expr_stmt|;
return|return
name|ReturnValue
return|;
block|}
end_function

begin_comment
comment|/* The new mode call back routine */
end_comment

begin_function
name|ITT_EXTERN_C
name|void
name|JITAPI
name|iJIT_RegisterCallbackEx
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
name|iJIT_ModeChangedEx
name|NewModeCallBackFuncEx
parameter_list|)
block|{
comment|/* is it already missing... or the load of functions from the DLL failed */
if|if
condition|(
name|iJIT_DLL_is_missing
operator|||
operator|!
name|loadiJIT_Funcs
argument_list|()
condition|)
block|{
comment|/* then do not bother with notifications */
name|NewModeCallBackFuncEx
argument_list|(
name|userdata
argument_list|,
name|iJIT_NO_NOTIFICATIONS
argument_list|)
expr_stmt|;
comment|/* Error: could not load JIT functions. */
return|return;
block|}
comment|/* nothing to do with the callback */
block|}
end_function

begin_comment
comment|/*  * This function allows the user to query in which mode, if at all,   *VTune is running  */
end_comment

begin_function
name|ITT_EXTERN_C
name|iJIT_IsProfilingActiveFlags
name|JITAPI
name|iJIT_IsProfilingActive
parameter_list|()
block|{
if|if
condition|(
operator|!
name|iJIT_DLL_is_missing
condition|)
block|{
name|loadiJIT_Funcs
argument_list|()
expr_stmt|;
block|}
return|return
name|executionMode
return|;
block|}
end_function

begin_comment
comment|/* this function loads the collector dll (BistroJavaCollector)   * and the relevant functions.  * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1  * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0  */
end_comment

begin_function
specifier|static
name|int
name|loadiJIT_Funcs
parameter_list|()
block|{
specifier|static
name|int
name|bDllWasLoaded
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dllName
init|=
operator|(
name|char
operator|*
operator|)
name|rcsid
decl_stmt|;
comment|/* !! Just to avoid unused code elimination */
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|DWORD
name|dNameLength
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
if|if
condition|(
name|bDllWasLoaded
condition|)
block|{
comment|/* dll was already loaded, no need to do it for the second time */
return|return
literal|1
return|;
block|}
comment|/* Assumes that the DLL will not be found */
name|iJIT_DLL_is_missing
operator|=
literal|1
expr_stmt|;
name|FUNC_NotifyEvent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m_libHandle
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|FreeLibrary
argument_list|(
name|m_libHandle
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|dlclose
argument_list|(
name|m_libHandle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|m_libHandle
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Try to get the dll name from the environment */
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|dNameLength
operator|=
name|GetEnvironmentVariableA
argument_list|(
name|NEW_DLL_ENVIRONMENT_VAR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dNameLength
condition|)
block|{
name|DWORD
name|envret
init|=
literal|0
decl_stmt|;
name|dllName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|dNameLength
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|envret
operator|=
name|GetEnvironmentVariableA
argument_list|(
name|NEW_DLL_ENVIRONMENT_VAR
argument_list|,
name|dllName
argument_list|,
name|dNameLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|envret
condition|)
block|{
comment|/* Try to load the dll from the PATH... */
name|m_libHandle
operator|=
name|LoadLibraryExA
argument_list|(
name|dllName
argument_list|,
name|NULL
argument_list|,
name|LOAD_WITH_ALTERED_SEARCH_PATH
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dllName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to use old VS_PROFILER variable */
name|dNameLength
operator|=
name|GetEnvironmentVariableA
argument_list|(
name|DLL_ENVIRONMENT_VAR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dNameLength
condition|)
block|{
name|DWORD
name|envret
init|=
literal|0
decl_stmt|;
name|dllName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|dNameLength
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|envret
operator|=
name|GetEnvironmentVariableA
argument_list|(
name|DLL_ENVIRONMENT_VAR
argument_list|,
name|dllName
argument_list|,
name|dNameLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|envret
condition|)
block|{
comment|/* Try to load the dll from the PATH... */
name|m_libHandle
operator|=
name|LoadLibraryA
argument_list|(
name|dllName
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dllName
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|dllName
operator|=
name|getenv
argument_list|(
name|NEW_DLL_ENVIRONMENT_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dllName
condition|)
name|dllName
operator|=
name|getenv
argument_list|(
name|DLL_ENVIRONMENT_VAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ANDROID
if|if
condition|(
operator|!
name|dllName
condition|)
name|dllName
operator|=
name|ANDROID_JIT_AGENT_PATH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dllName
condition|)
block|{
comment|/* Try to load the dll from the PATH... */
name|m_libHandle
operator|=
name|dlopen
argument_list|(
name|dllName
argument_list|,
name|RTLD_LAZY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
if|if
condition|(
operator|!
name|m_libHandle
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|m_libHandle
operator|=
name|LoadLibraryA
argument_list|(
name|DEFAULT_DLLNAME
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|m_libHandle
operator|=
name|dlopen
argument_list|(
name|DEFAULT_DLLNAME
argument_list|,
name|RTLD_LAZY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
block|}
comment|/* if the dll wasn't loaded - exit. */
if|if
condition|(
operator|!
name|m_libHandle
condition|)
block|{
name|iJIT_DLL_is_missing
operator|=
literal|1
expr_stmt|;
comment|/* don't try to initialize                                    * JIT agent the second time                                    */
return|return
literal|0
return|;
block|}
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|FUNC_NotifyEvent
operator|=
operator|(
name|TPNotify
operator|)
name|GetProcAddress
argument_list|(
name|m_libHandle
argument_list|,
literal|"NotifyEvent"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|FUNC_NotifyEvent
operator|=
operator|(
name|TPNotify
operator|)
operator|(
name|intptr_t
operator|)
name|dlsym
argument_list|(
name|m_libHandle
argument_list|,
literal|"NotifyEvent"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
if|if
condition|(
operator|!
name|FUNC_NotifyEvent
condition|)
block|{
name|FUNC_Initialize
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|FUNC_Initialize
operator|=
operator|(
name|TPInitialize
operator|)
name|GetProcAddress
argument_list|(
name|m_libHandle
argument_list|,
literal|"Initialize"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|FUNC_Initialize
operator|=
operator|(
name|TPInitialize
operator|)
operator|(
name|intptr_t
operator|)
name|dlsym
argument_list|(
name|m_libHandle
argument_list|,
literal|"Initialize"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
if|if
condition|(
operator|!
name|FUNC_Initialize
condition|)
block|{
name|FUNC_NotifyEvent
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|executionMode
operator|=
operator|(
name|iJIT_IsProfilingActiveFlags
operator|)
name|FUNC_Initialize
argument_list|()
expr_stmt|;
name|bDllWasLoaded
operator|=
literal|1
expr_stmt|;
name|iJIT_DLL_is_missing
operator|=
literal|0
expr_stmt|;
comment|/* DLL is ok. */
comment|/*      * Call Graph mode: init the thread local storage      * (need to store the virtual stack there).      */
if|if
condition|(
name|executionMode
operator|==
name|iJIT_CALLGRAPH_ON
condition|)
block|{
comment|/* Allocate a thread local storage slot for the thread "stack" */
if|if
condition|(
operator|!
name|threadLocalStorageHandle
condition|)
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|threadLocalStorageHandle
operator|=
name|TlsAlloc
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pthread_key_create
argument_list|(
operator|&
name|threadLocalStorageHandle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This function should be called by the user whenever a thread ends,   * to free the thread "virtual stack" storage  */
end_comment

begin_function
name|ITT_EXTERN_C
name|void
name|JITAPI
name|FinalizeThread
parameter_list|()
block|{
if|if
condition|(
name|threadLocalStorageHandle
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|TlsGetValue
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pThreadStack
name|threadStack
init|=
operator|(
name|pThreadStack
operator|)
name|pthread_getspecific
argument_list|(
name|threadLocalStorageHandle
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
if|if
condition|(
name|threadStack
condition|)
block|{
name|free
argument_list|(
name|threadStack
argument_list|)
expr_stmt|;
name|threadStack
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|TlsSetValue
argument_list|(
name|threadLocalStorageHandle
argument_list|,
name|threadStack
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pthread_setspecific
argument_list|(
name|threadLocalStorageHandle
argument_list|,
name|threadStack
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This function should be called by the user when the process ends,   * to free the local storage index */
end_comment

begin_function
name|ITT_EXTERN_C
name|void
name|JITAPI
name|FinalizeProcess
parameter_list|()
block|{
if|if
condition|(
name|m_libHandle
condition|)
block|{
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|FreeLibrary
argument_list|(
name|m_libHandle
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|dlclose
argument_list|(
name|m_libHandle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|m_libHandle
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|threadLocalStorageHandle
condition|)
if|#
directive|if
name|ITT_PLATFORM
operator|==
name|ITT_PLATFORM_WIN
name|TlsFree
argument_list|(
name|threadLocalStorageHandle
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
name|pthread_key_delete
argument_list|(
name|threadLocalStorageHandle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ITT_PLATFORM==ITT_PLATFORM_WIN */
block|}
end_function

begin_comment
comment|/*  * This function should be called by the user for any method once.  * The function will return a unique method ID, the user should maintain   * the ID for each method  */
end_comment

begin_function
name|ITT_EXTERN_C
name|unsigned
name|int
name|JITAPI
name|iJIT_GetNewMethodID
parameter_list|()
block|{
specifier|static
name|unsigned
name|int
name|methodID
init|=
literal|0x100000
decl_stmt|;
if|if
condition|(
name|methodID
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* ERROR : this is not a valid value */
return|return
name|methodID
operator|++
return|;
block|}
end_function

end_unit

