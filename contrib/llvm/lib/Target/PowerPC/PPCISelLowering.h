begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the interfaces that PPC uses to lower LLVM code into a
end_comment

begin_comment
comment|// selection DAG.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_define

begin_include
include|#
directive|include
file|"PPC.h"
end_include

begin_include
include|#
directive|include
file|"PPCInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"PPCRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|"PPCSubtarget.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/CallingConvLower.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PPCISD
block|{
enum|enum
name|NodeType
block|{
comment|// Start the numbering where the builtin ops and target ops leave off.
name|FIRST_NUMBER
init|=
name|ISD
operator|::
name|BUILTIN_OP_END
block|,
comment|/// FSEL - Traditional three-operand fsel node.
comment|///
name|FSEL
block|,
comment|/// FCFID - The FCFID instruction, taking an f64 operand and producing
comment|/// and f64 value containing the FP representation of the integer that
comment|/// was temporarily in the f64 operand.
name|FCFID
block|,
comment|/// Newer FCFID[US] integer-to-floating-point conversion instructions for
comment|/// unsigned integers and single-precision outputs.
name|FCFIDU
block|,
name|FCFIDS
block|,
name|FCFIDUS
block|,
comment|/// FCTI[D,W]Z - The FCTIDZ and FCTIWZ instructions, taking an f32 or f64
comment|/// operand, producing an f64 value containing the integer representation
comment|/// of that FP value.
name|FCTIDZ
block|,
name|FCTIWZ
block|,
comment|/// Newer FCTI[D,W]UZ floating-point-to-integer conversion instructions for
comment|/// unsigned integers.
name|FCTIDUZ
block|,
name|FCTIWUZ
block|,
comment|/// Reciprocal estimate instructions (unary FP ops).
name|FRE
block|,
name|FRSQRTE
block|,
comment|// VMADDFP, VNMSUBFP - The VMADDFP and VNMSUBFP instructions, taking
comment|// three v4f32 operands and producing a v4f32 result.
name|VMADDFP
block|,
name|VNMSUBFP
block|,
comment|/// VPERM - The PPC VPERM Instruction.
comment|///
name|VPERM
block|,
comment|/// Hi/Lo - These represent the high and low 16-bit parts of a global
comment|/// address respectively.  These nodes have two operands, the first of
comment|/// which must be a TargetGlobalAddress, and the second of which must be a
comment|/// Constant.  Selected naively, these turn into 'lis G+C' and 'li G+C',
comment|/// though these are usually folded into other nodes.
name|Hi
block|,
name|Lo
block|,
name|TOC_ENTRY
block|,
comment|/// The following three target-specific nodes are used for calls through
comment|/// function pointers in the 64-bit SVR4 ABI.
comment|/// Restore the TOC from the TOC save area of the current stack frame.
comment|/// This is basically a hard coded load instruction which additionally
comment|/// takes/produces a flag.
name|TOC_RESTORE
block|,
comment|/// Like a regular LOAD but additionally taking/producing a flag.
name|LOAD
block|,
comment|/// LOAD into r2 (also taking/producing a flag). Like TOC_RESTORE, this is
comment|/// a hard coded load instruction.
name|LOAD_TOC
block|,
comment|/// OPRC, CHAIN = DYNALLOC(CHAIN, NEGSIZE, FRAME_INDEX)
comment|/// This instruction is lowered in PPCRegisterInfo::eliminateFrameIndex to
comment|/// compute an allocation on the stack.
name|DYNALLOC
block|,
comment|/// GlobalBaseReg - On Darwin, this node represents the result of the mflr
comment|/// at function entry, used for PIC code.
name|GlobalBaseReg
block|,
comment|/// These nodes represent the 32-bit PPC shifts that operate on 6-bit
comment|/// shift amounts.  These nodes are generated by the multi-precision shift
comment|/// code.
name|SRL
block|,
name|SRA
block|,
name|SHL
block|,
comment|/// CALL - A direct function call.
comment|/// CALL_NOP is a call with the special NOP which follows 64-bit
comment|/// SVR4 calls.
name|CALL
block|,
name|CALL_NOP
block|,
comment|/// CHAIN,FLAG = MTCTR(VAL, CHAIN[, INFLAG]) - Directly corresponds to a
comment|/// MTCTR instruction.
name|MTCTR
block|,
comment|/// CHAIN,FLAG = BCTRL(CHAIN, INFLAG) - Directly corresponds to a
comment|/// BCTRL instruction.
name|BCTRL
block|,
comment|/// Return with a flag operand, matched by 'blr'
name|RET_FLAG
block|,
comment|/// R32 = MFOCRF(CRREG, INFLAG) - Represents the MFOCRF instruction.
comment|/// This copies the bits corresponding to the specified CRREG into the
comment|/// resultant GPR.  Bits corresponding to other CR regs are undefined.
name|MFOCRF
block|,
comment|// EH_SJLJ_SETJMP - SjLj exception handling setjmp.
name|EH_SJLJ_SETJMP
block|,
comment|// EH_SJLJ_LONGJMP - SjLj exception handling longjmp.
name|EH_SJLJ_LONGJMP
block|,
comment|/// RESVEC = VCMP(LHS, RHS, OPC) - Represents one of the altivec VCMP*
comment|/// instructions.  For lack of better number, we use the opcode number
comment|/// encoding for the OPC field to identify the compare.  For example, 838
comment|/// is VCMPGTSH.
name|VCMP
block|,
comment|/// RESVEC, OUTFLAG = VCMPo(LHS, RHS, OPC) - Represents one of the
comment|/// altivec VCMP*o instructions.  For lack of better number, we use the
comment|/// opcode number encoding for the OPC field to identify the compare.  For
comment|/// example, 838 is VCMPGTSH.
name|VCMPo
block|,
comment|/// CHAIN = COND_BRANCH CHAIN, CRRC, OPC, DESTBB [, INFLAG] - This
comment|/// corresponds to the COND_BRANCH pseudo instruction.  CRRC is the
comment|/// condition register to branch on, OPC is the branch opcode to use (e.g.
comment|/// PPC::BLE), DESTBB is the destination block to branch to, and INFLAG is
comment|/// an optional input flag argument.
name|COND_BRANCH
block|,
comment|/// CHAIN = BDNZ CHAIN, DESTBB - These are used to create counter-based
comment|/// loops.
name|BDNZ
block|,
name|BDZ
block|,
comment|/// F8RC = FADDRTZ F8RC, F8RC - This is an FADD done with rounding
comment|/// towards zero.  Used only as part of the long double-to-int
comment|/// conversion sequence.
name|FADDRTZ
block|,
comment|/// F8RC = MFFS - This moves the FPSCR (not modeled) into the register.
name|MFFS
block|,
comment|/// LARX = This corresponds to PPC l{w|d}arx instrcution: load and
comment|/// reserve indexed. This is used to implement atomic operations.
name|LARX
block|,
comment|/// STCX = This corresponds to PPC stcx. instrcution: store conditional
comment|/// indexed. This is used to implement atomic operations.
name|STCX
block|,
comment|/// TC_RETURN - A tail call return.
comment|///   operand #0 chain
comment|///   operand #1 callee (register or absolute)
comment|///   operand #2 stack adjustment
comment|///   operand #3 optional in flag
name|TC_RETURN
block|,
comment|/// ch, gl = CR6[UN]SET ch, inglue - Toggle CR bit 6 for SVR4 vararg calls
name|CR6SET
block|,
name|CR6UNSET
block|,
name|PPC32_GOT
block|,
comment|/// GPRC = address of _GLOBAL_OFFSET_TABLE_. Used by general dynamic and
comment|/// local dynamic TLS  on PPC32.
name|PPC32_PICGOT
block|,
comment|/// G8RC = ADDIS_GOT_TPREL_HA %X2, Symbol - Used by the initial-exec
comment|/// TLS model, produces an ADDIS8 instruction that adds the GOT
comment|/// base to sym\@got\@tprel\@ha.
name|ADDIS_GOT_TPREL_HA
block|,
comment|/// G8RC = LD_GOT_TPREL_L Symbol, G8RReg - Used by the initial-exec
comment|/// TLS model, produces a LD instruction with base register G8RReg
comment|/// and offset sym\@got\@tprel\@l.  This completes the addition that
comment|/// finds the offset of "sym" relative to the thread pointer.
name|LD_GOT_TPREL_L
block|,
comment|/// G8RC = ADD_TLS G8RReg, Symbol - Used by the initial-exec TLS
comment|/// model, produces an ADD instruction that adds the contents of
comment|/// G8RReg to the thread pointer.  Symbol contains a relocation
comment|/// sym\@tls which is to be replaced by the thread pointer and
comment|/// identifies to the linker that the instruction is part of a
comment|/// TLS sequence.
name|ADD_TLS
block|,
comment|/// G8RC = ADDIS_TLSGD_HA %X2, Symbol - For the general-dynamic TLS
comment|/// model, produces an ADDIS8 instruction that adds the GOT base
comment|/// register to sym\@got\@tlsgd\@ha.
name|ADDIS_TLSGD_HA
block|,
comment|/// G8RC = ADDI_TLSGD_L G8RReg, Symbol - For the general-dynamic TLS
comment|/// model, produces an ADDI8 instruction that adds G8RReg to
comment|/// sym\@got\@tlsgd\@l.
name|ADDI_TLSGD_L
block|,
comment|/// G8RC = GET_TLS_ADDR %X3, Symbol - For the general-dynamic TLS
comment|/// model, produces a call to __tls_get_addr(sym\@tlsgd).
name|GET_TLS_ADDR
block|,
comment|/// G8RC = ADDIS_TLSLD_HA %X2, Symbol - For the local-dynamic TLS
comment|/// model, produces an ADDIS8 instruction that adds the GOT base
comment|/// register to sym\@got\@tlsld\@ha.
name|ADDIS_TLSLD_HA
block|,
comment|/// G8RC = ADDI_TLSLD_L G8RReg, Symbol - For the local-dynamic TLS
comment|/// model, produces an ADDI8 instruction that adds G8RReg to
comment|/// sym\@got\@tlsld\@l.
name|ADDI_TLSLD_L
block|,
comment|/// G8RC = GET_TLSLD_ADDR %X3, Symbol - For the local-dynamic TLS
comment|/// model, produces a call to __tls_get_addr(sym\@tlsld).
name|GET_TLSLD_ADDR
block|,
comment|/// G8RC = ADDIS_DTPREL_HA %X3, Symbol, Chain - For the
comment|/// local-dynamic TLS model, produces an ADDIS8 instruction
comment|/// that adds X3 to sym\@dtprel\@ha. The Chain operand is needed
comment|/// to tie this in place following a copy to %X3 from the result
comment|/// of a GET_TLSLD_ADDR.
name|ADDIS_DTPREL_HA
block|,
comment|/// G8RC = ADDI_DTPREL_L G8RReg, Symbol - For the local-dynamic TLS
comment|/// model, produces an ADDI8 instruction that adds G8RReg to
comment|/// sym\@got\@dtprel\@l.
name|ADDI_DTPREL_L
block|,
comment|/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded
comment|/// during instruction selection to optimize a BUILD_VECTOR into
comment|/// operations on splats.  This is necessary to avoid losing these
comment|/// optimizations due to constant folding.
name|VADD_SPLAT
block|,
comment|/// CHAIN = SC CHAIN, Imm128 - System call.  The 7-bit unsigned
comment|/// operand identifies the operating system entry point.
name|SC
block|,
comment|/// CHAIN = STBRX CHAIN, GPRC, Ptr, Type - This is a
comment|/// byte-swapping store instruction.  It byte-swaps the low "Type" bits of
comment|/// the GPRC input, then stores it through Ptr.  Type can be either i16 or
comment|/// i32.
name|STBRX
init|=
name|ISD
operator|::
name|FIRST_TARGET_MEMORY_OPCODE
block|,
comment|/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a
comment|/// byte-swapping load instruction.  It loads "Type" bits, byte swaps it,
comment|/// then puts it in the bottom bits of the GPRC.  TYPE can be either i16
comment|/// or i32.
name|LBRX
block|,
comment|/// STFIWX - The STFIWX instruction.  The first operand is an input token
comment|/// chain, then an f64 value to store, then an address to store it to.
name|STFIWX
block|,
comment|/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point
comment|/// load which sign-extends from a 32-bit integer value into the
comment|/// destination 64-bit register.
name|LFIWAX
block|,
comment|/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point
comment|/// load which zero-extends from a 32-bit integer value into the
comment|/// destination 64-bit register.
name|LFIWZX
block|,
comment|/// G8RC = ADDIS_TOC_HA %X2, Symbol - For medium and large code model,
comment|/// produces an ADDIS8 instruction that adds the TOC base register to
comment|/// sym\@toc\@ha.
name|ADDIS_TOC_HA
block|,
comment|/// G8RC = LD_TOC_L Symbol, G8RReg - For medium and large code model,
comment|/// produces a LD instruction with base register G8RReg and offset
comment|/// sym\@toc\@l. Preceded by an ADDIS_TOC_HA to form a full 32-bit offset.
name|LD_TOC_L
block|,
comment|/// G8RC = ADDI_TOC_L G8RReg, Symbol - For medium code model, produces
comment|/// an ADDI8 instruction that adds G8RReg to sym\@toc\@l.
comment|/// Preceded by an ADDIS_TOC_HA to form a full 32-bit offset.
name|ADDI_TOC_L
block|}
enum|;
block|}
comment|/// Define some predicates that are used for node matching.
name|namespace
name|PPC
block|{
comment|/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a
comment|/// VPKUHUM instruction.
name|bool
name|isVPKUHUMShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a
comment|/// VPKUWUM instruction.
name|bool
name|isVPKUWUMShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for
comment|/// a VRGL* instruction with the specified unit size (1,2 or 4 bytes).
name|bool
name|isVMRGLShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|UnitSize
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for
comment|/// a VRGH* instruction with the specified unit size (1,2 or 4 bytes).
name|bool
name|isVMRGHShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|UnitSize
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the shift
comment|/// amount, otherwise return -1.
name|int
name|isVSLDOIShuffleMask
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isSplatShuffleMask - Return true if the specified VECTOR_SHUFFLE operand
comment|/// specifies a splat of a single element that is suitable for input to
comment|/// VSPLTB/VSPLTH/VSPLTW.
name|bool
name|isSplatShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|EltSize
parameter_list|)
function_decl|;
comment|/// isAllNegativeZeroVector - Returns true if all elements of build_vector
comment|/// are -0.0.
name|bool
name|isAllNegativeZeroVector
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// getVSPLTImmediate - Return the appropriate VSPLT* immediate to splat the
comment|/// specified isSplatShuffleMask VECTOR_SHUFFLE mask.
name|unsigned
name|getVSPLTImmediate
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|EltSize
parameter_list|)
function_decl|;
comment|/// get_VSPLTI_elt - If this is a build_vector of constants which can be
comment|/// formed by using a vspltis[bhw] instruction of the specified element
comment|/// size, return the constant being splatted.  The ByteSize field indicates
comment|/// the number of bytes of each element [124] -> [bhw].
name|SDValue
name|get_VSPLTI_elt
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|ByteSize
parameter_list|,
name|SelectionDAG
modifier|&
name|DAG
parameter_list|)
function_decl|;
block|}
name|class
name|PPCTargetLowering
range|:
name|public
name|TargetLowering
block|{
specifier|const
name|PPCSubtarget
operator|&
name|PPCSubTarget
block|;
name|public
operator|:
name|explicit
name|PPCTargetLowering
argument_list|(
name|PPCTargetMachine
operator|&
name|TM
argument_list|)
block|;
comment|/// getTargetNodeName() - This method returns the name of a target specific
comment|/// DAG node.
name|virtual
specifier|const
name|char
operator|*
name|getTargetNodeName
argument_list|(
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
name|virtual
name|MVT
name|getScalarShiftAmountTy
argument_list|(
argument|EVT LHSTy
argument_list|)
specifier|const
block|{
return|return
name|MVT
operator|::
name|i32
return|;
block|}
comment|/// getSetCCResultType - Return the ISD::SETCC ValueType
name|virtual
name|EVT
name|getSetCCResultType
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|EVT VT
argument_list|)
specifier|const
block|;
comment|/// getPreIndexedAddressParts - returns true by value, base pointer and
comment|/// offset pointer and addressing mode by reference if the node's address
comment|/// can be legally represented as pre-indexed load / store address.
name|virtual
name|bool
name|getPreIndexedAddressParts
argument_list|(
argument|SDNode *N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Offset
argument_list|,
argument|ISD::MemIndexedMode&AM
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegReg - Given the specified addressed, check to see if it
comment|/// can be represented as an indexed [r+r] operation.  Returns false if it
comment|/// can be more efficiently represented with [r+imm].
name|bool
name|SelectAddressRegReg
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Index
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegImm - Returns true if the address N can be represented
comment|/// by a base register plus a signed 16-bit displacement [r+imm], and if it
comment|/// is not better represented as reg+reg.  If Aligned is true, only accept
comment|/// displacements suitable for STD and friends, i.e. multiples of 4.
name|bool
name|SelectAddressRegImm
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Disp
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|bool Aligned
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegRegOnly - Given the specified addressed, force it to be
comment|/// represented as an indexed [r+r] operation.
name|bool
name|SelectAddressRegRegOnly
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Index
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|Sched
operator|::
name|Preference
name|getSchedulingPreference
argument_list|(
argument|SDNode *N
argument_list|)
specifier|const
block|;
comment|/// LowerOperation - Provide custom lowering hooks for some operations.
comment|///
name|virtual
name|SDValue
name|LowerOperation
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// ReplaceNodeResults - Replace the results of node with an illegal result
comment|/// type with new values built out of custom code.
comment|///
name|virtual
name|void
name|ReplaceNodeResults
argument_list|(
argument|SDNode *N
argument_list|,
argument|SmallVectorImpl<SDValue>&Results
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|virtual
name|SDValue
name|PerformDAGCombine
argument_list|(
argument|SDNode *N
argument_list|,
argument|DAGCombinerInfo&DCI
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|computeMaskedBitsForTargetNode
argument_list|(
argument|const SDValue Op
argument_list|,
argument|APInt&KnownZero
argument_list|,
argument|APInt&KnownOne
argument_list|,
argument|const SelectionDAG&DAG
argument_list|,
argument|unsigned Depth =
literal|0
argument_list|)
specifier|const
block|;
name|virtual
name|MachineBasicBlock
operator|*
name|EmitInstrWithCustomInserter
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|EmitAtomicBinary
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|,
argument|bool is64Bit
argument_list|,
argument|unsigned BinOpcode
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|EmitPartwordAtomicBinary
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|,
argument|bool is8bit
argument_list|,
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|emitEHSjLjSetJmp
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|emitEHSjLjLongJmp
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|)
specifier|const
block|;
name|ConstraintType
name|getConstraintType
argument_list|(
argument|const std::string&Constraint
argument_list|)
specifier|const
block|;
comment|/// Examine constraint string and operand type and determine a weight value.
comment|/// The operand object must already have been set up with the operand type.
name|ConstraintWeight
name|getSingleConstraintMatchWeight
argument_list|(
argument|AsmOperandInfo&info
argument_list|,
argument|const char *constraint
argument_list|)
specifier|const
block|;
name|std
operator|::
name|pair
operator|<
name|unsigned
block|,
specifier|const
name|TargetRegisterClass
operator|*
operator|>
name|getRegForInlineAsmConstraint
argument_list|(
argument|const std::string&Constraint
argument_list|,
argument|MVT VT
argument_list|)
specifier|const
block|;
comment|/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate
comment|/// function arguments in the caller parameter area.  This is the actual
comment|/// alignment, not its logarithm.
name|unsigned
name|getByValTypeAlignment
argument_list|(
argument|Type *Ty
argument_list|)
specifier|const
block|;
comment|/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
comment|/// vector.  If it is invalid, don't add anything to Ops.
name|virtual
name|void
name|LowerAsmOperandForConstraint
argument_list|(
argument|SDValue Op
argument_list|,
argument|std::string&Constraint
argument_list|,
argument|std::vector<SDValue>&Ops
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// isLegalAddressingMode - Return true if the addressing mode represented
comment|/// by AM is legal for this target, for a load/store of the specified type.
name|virtual
name|bool
name|isLegalAddressingMode
argument_list|(
argument|const AddrMode&AM
argument_list|,
argument|Type *Ty
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isOffsetFoldingLegal
argument_list|(
argument|const GlobalAddressSDNode *GA
argument_list|)
specifier|const
block|;
comment|/// getOptimalMemOpType - Returns the target specific optimal type for load
comment|/// and store operations as a result of memset, memcpy, and memmove
comment|/// lowering. If DstAlign is zero that means it's safe to destination
comment|/// alignment can satisfy any constraint. Similarly if SrcAlign is zero it
comment|/// means there isn't a need to check it against alignment requirement,
comment|/// probably because the source does not need to be loaded. If 'IsMemset' is
comment|/// true, that means it's expanding a memset. If 'ZeroMemset' is true, that
comment|/// means it's a memset of zero. 'MemcpyStrSrc' indicates whether the memcpy
comment|/// source is constant so it does not need to be loaded.
comment|/// It returns EVT::Other if the type should be determined using generic
comment|/// target-independent logic.
name|virtual
name|EVT
name|getOptimalMemOpType
argument_list|(
argument|uint64_t Size
argument_list|,
argument|unsigned DstAlign
argument_list|,
argument|unsigned SrcAlign
argument_list|,
argument|bool IsMemset
argument_list|,
argument|bool ZeroMemset
argument_list|,
argument|bool MemcpyStrSrc
argument_list|,
argument|MachineFunction&MF
argument_list|)
specifier|const
block|;
comment|/// Is unaligned memory access allowed for the given type, and is it fast
comment|/// relative to software emulation.
name|virtual
name|bool
name|allowsUnalignedMemoryAccesses
argument_list|(
argument|EVT VT
argument_list|,
argument|bool *Fast =
literal|0
argument_list|)
specifier|const
block|;
comment|/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster
comment|/// than a pair of fmul and fadd instructions. fmuladd intrinsics will be
comment|/// expanded to FMAs when this method returns true, otherwise fmuladd is
comment|/// expanded to fmul + fadd.
name|virtual
name|bool
name|isFMAFasterThanFMulAndFAdd
argument_list|(
argument|EVT VT
argument_list|)
specifier|const
block|;
comment|/// createFastISel - This method returns a target-specific FastISel object,
comment|/// or null if the target does not support "fast" instruction selection.
name|virtual
name|FastISel
operator|*
name|createFastISel
argument_list|(
argument|FunctionLoweringInfo&FuncInfo
argument_list|,
argument|const TargetLibraryInfo *LibInfo
argument_list|)
specifier|const
block|;
name|private
operator|:
name|SDValue
name|getFramePointerFrameIndex
argument_list|(
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|getReturnAddrFrameIndex
argument_list|(
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|bool
name|IsEligibleForTailCallOptimization
argument_list|(
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CalleeCC
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|EmitTailCallLoadFPAndRetAddr
argument_list|(
argument|SelectionDAG& DAG
argument_list|,
argument|int SPDiff
argument_list|,
argument|SDValue Chain
argument_list|,
argument|SDValue&LROpOut
argument_list|,
argument|SDValue&FPOpOut
argument_list|,
argument|bool isDarwinABI
argument_list|,
argument|SDLoc dl
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerRETURNADDR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFRAMEADDR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerConstantPool
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerBlockAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerGlobalTLSAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerGlobalAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerJumpTable
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSETCC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerINIT_TRAMPOLINE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerADJUST_TRAMPOLINE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerVASTART
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerVAARG
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerVACOPY
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSTACKRESTORE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerDYNAMIC_STACKALLOC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSELECT_CC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFP_TO_INT
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SDLoc dl
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerINT_TO_FP
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFLT_ROUNDS_
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSHL_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSRL_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSRA_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerBUILD_VECTOR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerVECTOR_SHUFFLE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerINTRINSIC_WO_CHAIN
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerSCALAR_TO_VECTOR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerMUL
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerCallResult
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue InFlag
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|FinishCall
argument_list|(
argument|CallingConv::ID CallConv
argument_list|,
argument|SDLoc dl
argument_list|,
argument|bool isTailCall
argument_list|,
argument|bool isVarArg
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVector<std::pair<unsigned
argument_list|,
argument|SDValue>
argument_list|,
literal|8
argument|>&RegsToPass
argument_list|,
argument|SDValue InFlag
argument_list|,
argument|SDValue Chain
argument_list|,
argument|SDValue&Callee
argument_list|,
argument|int SPDiff
argument_list|,
argument|unsigned NumBytes
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|virtual
name|SDValue
name|LowerFormalArguments
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|virtual
name|SDValue
name|LowerCall
argument_list|(
argument|TargetLowering::CallLoweringInfo&CLI
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|CanLowerReturn
argument_list|(
argument|CallingConv::ID CallConv
argument_list|,
argument|MachineFunction&MF
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|LLVMContext&Context
argument_list|)
specifier|const
block|;
name|virtual
name|SDValue
name|LowerReturn
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<SDValue>&OutVals
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|extendArgForPPC64
argument_list|(
argument|ISD::ArgFlagsTy Flags
argument_list|,
argument|EVT ObjectVT
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SDValue ArgVal
argument_list|,
argument|SDLoc dl
argument_list|)
specifier|const
block|;
name|void
name|setMinReservedArea
argument_list|(
argument|MachineFunction&MF
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|unsigned nAltivecParamsAtEnd
argument_list|,
argument|unsigned MinReservedArea
argument_list|,
argument|bool isPPC64
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFormalArguments_Darwin
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFormalArguments_64SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerFormalArguments_32SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|createMemcpyOutsideCallSeq
argument_list|(
argument|SDValue Arg
argument_list|,
argument|SDValue PtrOff
argument_list|,
argument|SDValue CallSeqStart
argument_list|,
argument|ISD::ArgFlagsTy Flags
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SDLoc dl
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerCall_Darwin
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<SDValue>&OutVals
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerCall_64SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<SDValue>&OutVals
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|LowerCall_32SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<SDValue>&OutVals
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SDLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
specifier|const
block|;
name|SDValue
name|lowerEH_SJLJ_SETJMP
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|lowerEH_SJLJ_LONGJMP
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|DAGCombineFastRecip
argument_list|(
argument|SDValue Op
argument_list|,
argument|DAGCombinerInfo&DCI
argument_list|)
specifier|const
block|;
name|SDValue
name|DAGCombineFastRecipFSQRT
argument_list|(
argument|SDValue Op
argument_list|,
argument|DAGCombinerInfo&DCI
argument_list|)
specifier|const
block|;
name|CCAssignFn
operator|*
name|useFastISelCCs
argument_list|(
argument|unsigned Flag
argument_list|)
specifier|const
block|;   }
decl_stmt|;
name|namespace
name|PPC
block|{
name|FastISel
modifier|*
name|createFastISel
parameter_list|(
name|FunctionLoweringInfo
modifier|&
name|FuncInfo
parameter_list|,
specifier|const
name|TargetLibraryInfo
modifier|*
name|LibInfo
parameter_list|)
function_decl|;
block|}
name|bool
name|CC_PPC32_SVR4_Custom_Dummy
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
decl_stmt|;
name|bool
name|CC_PPC32_SVR4_Custom_AlignArgRegs
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
decl_stmt|;
name|bool
name|CC_PPC32_SVR4_Custom_AlignFPArgRegs
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_comment

end_unit

