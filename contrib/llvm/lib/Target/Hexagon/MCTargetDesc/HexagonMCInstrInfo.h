begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- HexagonMCInstrInfo.cpp - Utility functions on Hexagon MCInsts ------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Utility functions for Hexagon specific MCInst queries
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_HEXAGON_MCTARGETDESC_HEXAGONMCINSTRINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_HEXAGON_MCTARGETDESC_HEXAGONMCINSTRINFO_H
end_define

begin_include
include|#
directive|include
file|"HexagonMCExpr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCInst.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|HexagonMCChecker
decl_stmt|;
name|class
name|MCInstrDesc
decl_stmt|;
name|class
name|MCInstrInfo
decl_stmt|;
name|class
name|MCSubtargetInfo
decl_stmt|;
name|namespace
name|HexagonII
block|{
name|enum
name|class
name|MemAccessSize
decl_stmt|;
block|}
name|class
name|DuplexCandidate
block|{
name|public
label|:
name|unsigned
name|packetIndexI
decl_stmt|,
name|packetIndexJ
decl_stmt|,
name|iClass
decl_stmt|;
name|DuplexCandidate
argument_list|(
argument|unsigned i
argument_list|,
argument|unsigned j
argument_list|,
argument|unsigned iClass
argument_list|)
block|:
name|packetIndexI
argument_list|(
name|i
argument_list|)
operator|,
name|packetIndexJ
argument_list|(
name|j
argument_list|)
operator|,
name|iClass
argument_list|(
argument|iClass
argument_list|)
block|{}
block|}
empty_stmt|;
name|namespace
name|Hexagon
block|{
name|class
name|PacketIterator
block|{
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
decl_stmt|;
name|MCInst
operator|::
name|const_iterator
name|BundleCurrent
expr_stmt|;
name|MCInst
operator|::
name|const_iterator
name|BundleEnd
expr_stmt|;
name|MCInst
operator|::
name|const_iterator
name|DuplexCurrent
expr_stmt|;
name|MCInst
operator|::
name|const_iterator
name|DuplexEnd
expr_stmt|;
name|public
label|:
name|PacketIterator
argument_list|(
name|MCInstrInfo
specifier|const
operator|&
name|MCII
argument_list|,
name|MCInst
specifier|const
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|PacketIterator
argument_list|(
name|MCInstrInfo
specifier|const
operator|&
name|MCII
argument_list|,
name|MCInst
specifier|const
operator|&
name|Inst
argument_list|,
name|std
operator|::
name|nullptr_t
argument_list|)
expr_stmt|;
name|PacketIterator
operator|&
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
name|MCInst
specifier|const
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|==
operator|(
name|PacketIterator
specifier|const
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
name|PacketIterator
specifier|const
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|Other
operator|)
return|;
block|}
block|}
empty_stmt|;
block|}
comment|// namespace Hexagon
name|namespace
name|HexagonMCInstrInfo
block|{
name|size_t
specifier|const
name|innerLoopOffset
init|=
literal|0
decl_stmt|;
name|int64_t
specifier|const
name|innerLoopMask
init|=
literal|1
operator|<<
name|innerLoopOffset
decl_stmt|;
name|size_t
specifier|const
name|outerLoopOffset
init|=
literal|1
decl_stmt|;
name|int64_t
specifier|const
name|outerLoopMask
init|=
literal|1
operator|<<
name|outerLoopOffset
decl_stmt|;
comment|// do not reorder memory load/stores by default load/stores are re-ordered
comment|// and by default loads can be re-ordered
name|size_t
specifier|const
name|memReorderDisabledOffset
init|=
literal|2
decl_stmt|;
name|int64_t
specifier|const
name|memReorderDisabledMask
init|=
literal|1
operator|<<
name|memReorderDisabledOffset
decl_stmt|;
comment|// allow re-ordering of memory stores by default stores cannot be re-ordered
name|size_t
specifier|const
name|memStoreReorderEnabledOffset
init|=
literal|3
decl_stmt|;
name|int64_t
specifier|const
name|memStoreReorderEnabledMask
init|=
literal|1
operator|<<
name|memStoreReorderEnabledOffset
decl_stmt|;
name|size_t
specifier|const
name|bundleInstructionsOffset
init|=
literal|1
decl_stmt|;
name|void
name|addConstant
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|uint64_t
name|Value
parameter_list|,
name|MCContext
modifier|&
name|Context
parameter_list|)
function_decl|;
name|void
name|addConstExtender
parameter_list|(
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
modifier|&
name|MCB
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Returns a iterator range of instructions in this bundle
name|iterator_range
operator|<
name|Hexagon
operator|::
name|PacketIterator
operator|>
name|bundleInstructions
argument_list|(
name|MCInstrInfo
specifier|const
operator|&
name|MCII
argument_list|,
name|MCInst
specifier|const
operator|&
name|MCI
argument_list|)
expr_stmt|;
name|iterator_range
operator|<
name|MCInst
operator|::
name|const_iterator
operator|>
name|bundleInstructions
argument_list|(
name|MCInst
specifier|const
operator|&
name|MCI
argument_list|)
expr_stmt|;
comment|// Returns the number of instructions in the bundle
name|size_t
name|bundleSize
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Put the packet in to canonical form, compound, duplex, pad, and shuffle
name|bool
name|canonicalizePacket
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|,
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInst
modifier|&
name|MCB
parameter_list|,
name|HexagonMCChecker
modifier|*
name|Checker
parameter_list|)
function_decl|;
comment|// Create a duplex instruction given the two subinsts
name|MCInst
modifier|*
name|deriveDuplex
parameter_list|(
name|MCContext
modifier|&
name|Context
parameter_list|,
name|unsigned
name|iClass
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|inst0
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|inst1
parameter_list|)
function_decl|;
name|MCInst
name|deriveExtender
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|Inst
parameter_list|,
name|MCOperand
specifier|const
modifier|&
name|MO
parameter_list|)
function_decl|;
comment|// Convert this instruction in to a duplex subinst
name|MCInst
name|deriveSubInst
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|Inst
parameter_list|)
function_decl|;
comment|// Clamp off upper 26 bits of extendable operand for emission
name|void
name|clampExtended
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|MCInst
name|createBundle
parameter_list|()
function_decl|;
comment|// Return the extender for instruction at Index or nullptr if none
name|MCInst
specifier|const
modifier|*
name|extenderForIndex
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCB
parameter_list|,
name|size_t
name|Index
parameter_list|)
function_decl|;
name|void
name|extendIfNeeded
parameter_list|(
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
modifier|&
name|MCB
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return memory access size
name|HexagonII
operator|::
name|MemAccessSize
name|getAccessSize
argument_list|(
name|MCInstrInfo
specifier|const
operator|&
name|MCII
argument_list|,
name|MCInst
specifier|const
operator|&
name|MCI
argument_list|)
expr_stmt|;
name|MCInstrDesc
specifier|const
modifier|&
name|getDesc
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return which duplex group this instruction belongs to
name|unsigned
name|getDuplexCandidateGroup
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MI
parameter_list|)
function_decl|;
comment|// Return a list of all possible instruction duplex combinations
name|SmallVector
operator|<
name|DuplexCandidate
operator|,
literal|8
operator|>
name|getDuplexPossibilties
argument_list|(
name|MCInstrInfo
specifier|const
operator|&
name|MCII
argument_list|,
name|MCSubtargetInfo
specifier|const
operator|&
name|STI
argument_list|,
name|MCInst
specifier|const
operator|&
name|MCB
argument_list|)
expr_stmt|;
name|unsigned
name|getDuplexRegisterNumbering
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|MCExpr
specifier|const
modifier|&
name|getExpr
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|)
function_decl|;
comment|// Return the index of the extendable operand
name|unsigned
name|short
name|getExtendableOp
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return a reference to the extendable operand
name|MCOperand
specifier|const
modifier|&
name|getExtendableOperand
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the implicit alignment of the extendable operand
name|unsigned
name|getExtentAlignment
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the number of logical bits of the extendable operand
name|unsigned
name|getExtentBits
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the max value that a constant extendable operand can have
comment|// without being extended.
name|int
name|getMaxValue
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the min value that a constant extendable operand can have
comment|// without being extended.
name|int
name|getMinValue
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return instruction name
name|StringRef
name|getName
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the operand index for the new value.
name|unsigned
name|short
name|getNewValueOp
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the operand that consumes or produces a new value.
name|MCOperand
specifier|const
modifier|&
name|getNewValueOperand
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|unsigned
name|short
name|getNewValueOp2
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|MCOperand
specifier|const
modifier|&
name|getNewValueOperand2
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return the Hexagon ISA class for the insn.
name|unsigned
name|getType
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|/// Return the slots used by the insn.
name|unsigned
name|getUnits
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|unsigned
name|getOtherReservedSlots
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|hasDuplex
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Does the packet have an extender for the instruction at Index
name|bool
name|hasExtenderForIndex
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCB
parameter_list|,
name|size_t
name|Index
parameter_list|)
function_decl|;
name|bool
name|hasImmExt
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the instruction is a legal new-value producer.
name|bool
name|hasNewValue
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|hasNewValue2
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|unsigned
name|iClassOfDuplexPair
parameter_list|(
name|unsigned
name|Ga
parameter_list|,
name|unsigned
name|Gb
parameter_list|)
function_decl|;
name|int64_t
name|minConstant
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|,
name|size_t
name|Index
parameter_list|)
function_decl|;
name|template
operator|<
name|unsigned
name|N
operator|,
name|unsigned
name|S
operator|>
name|bool
name|inRange
argument_list|(
argument|MCInst const&MCI
argument_list|,
argument|size_t Index
argument_list|)
block|{
return|return
name|isShiftedUInt
operator|<
name|N
operator|,
name|S
operator|>
operator|(
name|minConstant
argument_list|(
name|MCI
argument_list|,
name|Index
argument_list|)
operator|)
return|;
block|}
name|template
operator|<
name|unsigned
name|N
operator|,
name|unsigned
name|S
operator|>
name|bool
name|inSRange
argument_list|(
argument|MCInst const&MCI
argument_list|,
argument|size_t Index
argument_list|)
block|{
return|return
name|isShiftedInt
operator|<
name|N
operator|,
name|S
operator|>
operator|(
name|minConstant
argument_list|(
name|MCI
argument_list|,
name|Index
argument_list|)
operator|)
return|;
block|}
name|template
operator|<
name|unsigned
name|N
operator|>
name|bool
name|inRange
argument_list|(
argument|MCInst const&MCI
argument_list|,
argument|size_t Index
argument_list|)
block|{
return|return
name|isUInt
operator|<
name|N
operator|>
operator|(
name|minConstant
argument_list|(
name|MCI
argument_list|,
name|Index
argument_list|)
operator|)
return|;
block|}
comment|// Return the instruction at Index
name|MCInst
specifier|const
modifier|&
name|instruction
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCB
parameter_list|,
name|size_t
name|Index
parameter_list|)
function_decl|;
name|bool
name|isAccumulator
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Returns whether this MCInst is a wellformed bundle
name|bool
name|isBundle
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the insn is an actual insn.
name|bool
name|isCanon
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isCofMax1
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isCompound
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the instruction needs to be constant extended.
name|bool
name|isConstExtended
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isCVINew
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Is this double register suitable for use in a duplex subinst
name|bool
name|isDblRegForSubInst
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
comment|// Is this a duplex instruction
name|bool
name|isDuplex
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Can these instructions be duplexed
name|bool
name|isDuplexPair
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MIa
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MIb
parameter_list|)
function_decl|;
comment|// Can these duplex classes be combine in to a duplex instruction
name|bool
name|isDuplexPairMatch
parameter_list|(
name|unsigned
name|Ga
parameter_list|,
name|unsigned
name|Gb
parameter_list|)
function_decl|;
comment|// Return true if the insn may be extended based on the operand value.
name|bool
name|isExtendable
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the instruction must be always extended.
name|bool
name|isExtended
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|/// Return whether it is a floating-point insn.
name|bool
name|isFloat
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Returns whether this instruction is an immediate extender
name|bool
name|isImmext
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Returns whether this bundle is an endloop0
name|bool
name|isInnerLoop
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Is this an integer register
name|bool
name|isIntReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
comment|// Is this register suitable for use in a duplex subinst
name|bool
name|isIntRegForSubInst
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|bool
name|isMemReorderDisabled
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isMemStoreReorderEnabled
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the insn is a new-value consumer.
name|bool
name|isNewValue
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isOpExtendable
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|,
name|unsigned
name|short
parameter_list|)
function_decl|;
comment|// Can these two instructions be duplexed
name|bool
name|isOrderedDuplexPair
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MIa
parameter_list|,
name|bool
name|ExtendedA
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MIb
parameter_list|,
name|bool
name|ExtendedB
parameter_list|,
name|bool
name|bisReversable
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|)
function_decl|;
comment|// Returns whether this bundle is an endloop1
name|bool
name|isOuterLoop
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether this instruction is predicated
name|bool
name|isPredicated
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isPredicateLate
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isPredicatedNew
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the predicate sense is true
name|bool
name|isPredicatedTrue
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Is this a predicate register
name|bool
name|isPredReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
comment|// Return whether the insn is a prefix.
name|bool
name|isPrefix
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Return whether the insn is solo, i.e., cannot be in a packet.
name|bool
name|isSolo
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|/// Return whether the insn can be packaged only with A and X-type insns.
name|bool
name|isSoloAX
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|/// Return whether the insn can be packaged only with an A-type insn in slot #1.
name|bool
name|isSoloAin1
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isSubInstruction
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|isVector
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|bool
name|mustExtend
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|)
function_decl|;
name|bool
name|mustNotExtend
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|)
function_decl|;
comment|// Pad the bundle with nops to satisfy endloop requirements
name|void
name|padEndloop
parameter_list|(
name|MCInst
modifier|&
name|MCI
parameter_list|,
name|MCContext
modifier|&
name|Context
parameter_list|)
function_decl|;
name|bool
name|prefersSlot3
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCInst
specifier|const
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Replace the instructions inside MCB, represented by Candidate
name|void
name|replaceDuplex
parameter_list|(
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInst
modifier|&
name|MCI
parameter_list|,
name|DuplexCandidate
name|Candidate
parameter_list|)
function_decl|;
name|bool
name|s27_2_reloc
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|)
function_decl|;
comment|// Marks a bundle as endloop0
name|void
name|setInnerLoop
parameter_list|(
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|void
name|setMemReorderDisabled
parameter_list|(
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|void
name|setMemStoreReorderEnabled
parameter_list|(
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
name|void
name|setMustExtend
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|,
name|bool
name|Val
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|setMustNotExtend
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|,
name|bool
name|Val
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|setS27_2_reloc
parameter_list|(
name|MCExpr
specifier|const
modifier|&
name|Expr
parameter_list|,
name|bool
name|Val
init|=
name|true
parameter_list|)
function_decl|;
comment|// Marks a bundle as endloop1
name|void
name|setOuterLoop
parameter_list|(
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
comment|// Would duplexing this instruction create a requirement to extend
name|bool
name|subInstWouldBeExtended
parameter_list|(
name|MCInst
specifier|const
modifier|&
name|potentialDuplex
parameter_list|)
function_decl|;
name|unsigned
name|SubregisterBit
parameter_list|(
name|unsigned
name|Consumer
parameter_list|,
name|unsigned
name|Producer
parameter_list|,
name|unsigned
name|Producer2
parameter_list|)
function_decl|;
comment|// Attempt to find and replace compound pairs
name|void
name|tryCompound
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|,
name|MCContext
modifier|&
name|Context
parameter_list|,
name|MCInst
modifier|&
name|MCI
parameter_list|)
function_decl|;
block|}
comment|// namespace HexagonMCInstrInfo
block|}
end_decl_stmt

begin_comment
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_TARGET_HEXAGON_MCTARGETDESC_HEXAGONMCINSTRINFO_H
end_comment

end_unit

