begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- AArch64AddressingModes.h - AArch64 Addressing Modes ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the AArch64 addressing mode implementation stuff.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_AARCH64_MCTARGETDESC_AARCH64ADDRESSINGMODES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_AARCH64_MCTARGETDESC_AARCH64ADDRESSINGMODES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// AArch64_AM - AArch64 Addressing Mode Stuff
name|namespace
name|AArch64_AM
block|{
comment|//===----------------------------------------------------------------------===//
comment|// Shifts
comment|//
enum|enum
name|ShiftExtendType
block|{
name|InvalidShiftExtend
init|=
operator|-
literal|1
block|,
name|LSL
init|=
literal|0
block|,
name|LSR
block|,
name|ASR
block|,
name|ROR
block|,
name|MSL
block|,
name|UXTB
block|,
name|UXTH
block|,
name|UXTW
block|,
name|UXTX
block|,
name|SXTB
block|,
name|SXTH
block|,
name|SXTW
block|,
name|SXTX
block|, }
enum|;
comment|/// getShiftName - Get the string encoding for the shift type.
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getShiftExtendName
argument_list|(
name|AArch64_AM
operator|::
name|ShiftExtendType
name|ST
argument_list|)
block|{
switch|switch
condition|(
name|ST
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"unhandled shift type!"
argument_list|)
expr_stmt|;
case|case
name|AArch64_AM
operator|::
name|LSL
case|:
return|return
literal|"lsl"
return|;
case|case
name|AArch64_AM
operator|::
name|LSR
case|:
return|return
literal|"lsr"
return|;
case|case
name|AArch64_AM
operator|::
name|ASR
case|:
return|return
literal|"asr"
return|;
case|case
name|AArch64_AM
operator|::
name|ROR
case|:
return|return
literal|"ror"
return|;
case|case
name|AArch64_AM
operator|::
name|MSL
case|:
return|return
literal|"msl"
return|;
case|case
name|AArch64_AM
operator|::
name|UXTB
case|:
return|return
literal|"uxtb"
return|;
case|case
name|AArch64_AM
operator|::
name|UXTH
case|:
return|return
literal|"uxth"
return|;
case|case
name|AArch64_AM
operator|::
name|UXTW
case|:
return|return
literal|"uxtw"
return|;
case|case
name|AArch64_AM
operator|::
name|UXTX
case|:
return|return
literal|"uxtx"
return|;
case|case
name|AArch64_AM
operator|::
name|SXTB
case|:
return|return
literal|"sxtb"
return|;
case|case
name|AArch64_AM
operator|::
name|SXTH
case|:
return|return
literal|"sxth"
return|;
case|case
name|AArch64_AM
operator|::
name|SXTW
case|:
return|return
literal|"sxtw"
return|;
case|case
name|AArch64_AM
operator|::
name|SXTX
case|:
return|return
literal|"sxtx"
return|;
block|}
return|return
name|nullptr
return|;
block|}
comment|/// getShiftType - Extract the shift type.
specifier|static
specifier|inline
name|AArch64_AM
operator|::
name|ShiftExtendType
name|getShiftType
argument_list|(
argument|unsigned Imm
argument_list|)
block|{
switch|switch
condition|(
operator|(
name|Imm
operator|>>
literal|6
operator|)
operator|&
literal|0x7
condition|)
block|{
default|default:
return|return
name|AArch64_AM
operator|::
name|InvalidShiftExtend
return|;
case|case
literal|0
case|:
return|return
name|AArch64_AM
operator|::
name|LSL
return|;
case|case
literal|1
case|:
return|return
name|AArch64_AM
operator|::
name|LSR
return|;
case|case
literal|2
case|:
return|return
name|AArch64_AM
operator|::
name|ASR
return|;
case|case
literal|3
case|:
return|return
name|AArch64_AM
operator|::
name|ROR
return|;
case|case
literal|4
case|:
return|return
name|AArch64_AM
operator|::
name|MSL
return|;
block|}
block|}
comment|/// getShiftValue - Extract the shift value.
specifier|static
specifier|inline
name|unsigned
name|getShiftValue
argument_list|(
argument|unsigned Imm
argument_list|)
block|{
return|return
name|Imm
operator|&
literal|0x3f
return|;
block|}
comment|/// getShifterImm - Encode the shift type and amount:
comment|///   imm:     6-bit shift amount
comment|///   shifter: 000 ==> lsl
comment|///            001 ==> lsr
comment|///            010 ==> asr
comment|///            011 ==> ror
comment|///            100 ==> msl
comment|///   {8-6}  = shifter
comment|///   {5-0}  = imm
specifier|static
specifier|inline
name|unsigned
name|getShifterImm
argument_list|(
name|AArch64_AM
operator|::
name|ShiftExtendType
name|ST
argument_list|,
name|unsigned
name|Imm
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|Imm
operator|&
literal|0x3f
operator|)
operator|==
name|Imm
operator|&&
literal|"Illegal shifted immedate value!"
argument_list|)
expr_stmt|;
name|unsigned
name|STEnc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ST
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid shift requested"
argument_list|)
expr_stmt|;
case|case
name|AArch64_AM
operator|::
name|LSL
case|:
name|STEnc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AArch64_AM
operator|::
name|LSR
case|:
name|STEnc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AArch64_AM
operator|::
name|ASR
case|:
name|STEnc
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AArch64_AM
operator|::
name|ROR
case|:
name|STEnc
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|AArch64_AM
operator|::
name|MSL
case|:
name|STEnc
operator|=
literal|4
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|STEnc
operator|<<
literal|6
operator|)
operator||
operator|(
name|Imm
operator|&
literal|0x3f
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Extends
comment|//
comment|/// getArithShiftValue - get the arithmetic shift value.
specifier|static
specifier|inline
name|unsigned
name|getArithShiftValue
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
name|Imm
operator|&
literal|0x7
return|;
block|}
comment|/// getExtendType - Extract the extend type for operands of arithmetic ops.
specifier|static
specifier|inline
name|AArch64_AM
operator|::
name|ShiftExtendType
name|getExtendType
argument_list|(
argument|unsigned Imm
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|Imm
operator|&
literal|0x7
operator|)
operator|==
name|Imm
operator|&&
literal|"invalid immediate!"
argument_list|)
block|;
switch|switch
condition|(
name|Imm
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Compiler bug!"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
return|return
name|AArch64_AM
operator|::
name|UXTB
return|;
case|case
literal|1
case|:
return|return
name|AArch64_AM
operator|::
name|UXTH
return|;
case|case
literal|2
case|:
return|return
name|AArch64_AM
operator|::
name|UXTW
return|;
case|case
literal|3
case|:
return|return
name|AArch64_AM
operator|::
name|UXTX
return|;
case|case
literal|4
case|:
return|return
name|AArch64_AM
operator|::
name|SXTB
return|;
case|case
literal|5
case|:
return|return
name|AArch64_AM
operator|::
name|SXTH
return|;
case|case
literal|6
case|:
return|return
name|AArch64_AM
operator|::
name|SXTW
return|;
case|case
literal|7
case|:
return|return
name|AArch64_AM
operator|::
name|SXTX
return|;
block|}
block|}
specifier|static
specifier|inline
name|AArch64_AM
operator|::
name|ShiftExtendType
name|getArithExtendType
argument_list|(
argument|unsigned Imm
argument_list|)
block|{
return|return
name|getExtendType
argument_list|(
operator|(
name|Imm
operator|>>
literal|3
operator|)
operator|&
literal|0x7
argument_list|)
return|;
block|}
comment|/// Mapping from extend bits to required operation:
comment|///   shifter: 000 ==> uxtb
comment|///            001 ==> uxth
comment|///            010 ==> uxtw
comment|///            011 ==> uxtx
comment|///            100 ==> sxtb
comment|///            101 ==> sxth
comment|///            110 ==> sxtw
comment|///            111 ==> sxtx
specifier|inline
name|unsigned
name|getExtendEncoding
argument_list|(
name|AArch64_AM
operator|::
name|ShiftExtendType
name|ET
argument_list|)
block|{
switch|switch
condition|(
name|ET
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid extend type requested"
argument_list|)
expr_stmt|;
case|case
name|AArch64_AM
operator|::
name|UXTB
case|:
return|return
literal|0
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|UXTH
case|:
return|return
literal|1
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|UXTW
case|:
return|return
literal|2
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|UXTX
case|:
return|return
literal|3
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|SXTB
case|:
return|return
literal|4
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|SXTH
case|:
return|return
literal|5
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|SXTW
case|:
return|return
literal|6
return|;
break|break;
case|case
name|AArch64_AM
operator|::
name|SXTX
case|:
return|return
literal|7
return|;
break|break;
block|}
block|}
comment|/// getArithExtendImm - Encode the extend type and shift amount for an
comment|///                     arithmetic instruction:
comment|///   imm:     3-bit extend amount
comment|///   {5-3}  = shifter
comment|///   {2-0}  = imm3
specifier|static
specifier|inline
name|unsigned
name|getArithExtendImm
argument_list|(
name|AArch64_AM
operator|::
name|ShiftExtendType
name|ET
argument_list|,
name|unsigned
name|Imm
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|Imm
operator|&
literal|0x7
operator|)
operator|==
name|Imm
operator|&&
literal|"Illegal shifted immedate value!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|getExtendEncoding
argument_list|(
name|ET
argument_list|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|Imm
operator|&
literal|0x7
operator|)
return|;
block|}
comment|/// getMemDoShift - Extract the "do shift" flag value for load/store
comment|/// instructions.
specifier|static
specifier|inline
name|bool
name|getMemDoShift
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0x1
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// getExtendType - Extract the extend type for the offset operand of
comment|/// loads/stores.
specifier|static
specifier|inline
name|AArch64_AM
operator|::
name|ShiftExtendType
name|getMemExtendType
argument_list|(
argument|unsigned Imm
argument_list|)
block|{
return|return
name|getExtendType
argument_list|(
operator|(
name|Imm
operator|>>
literal|1
operator|)
operator|&
literal|0x7
argument_list|)
return|;
block|}
comment|/// getExtendImm - Encode the extend type and amount for a load/store inst:
comment|///   doshift:     should the offset be scaled by the access size
comment|///   shifter: 000 ==> uxtb
comment|///            001 ==> uxth
comment|///            010 ==> uxtw
comment|///            011 ==> uxtx
comment|///            100 ==> sxtb
comment|///            101 ==> sxth
comment|///            110 ==> sxtw
comment|///            111 ==> sxtx
comment|///   {3-1}  = shifter
comment|///   {0}  = doshift
specifier|static
specifier|inline
name|unsigned
name|getMemExtendImm
argument_list|(
name|AArch64_AM
operator|::
name|ShiftExtendType
name|ET
argument_list|,
name|bool
name|DoShift
argument_list|)
block|{
return|return
operator|(
name|getExtendEncoding
argument_list|(
name|ET
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|unsigned
argument_list|(
name|DoShift
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|ror
parameter_list|(
name|uint64_t
name|elt
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
return|return
operator|(
operator|(
name|elt
operator|&
literal|1
operator|)
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
name|elt
operator|>>
literal|1
operator|)
return|;
block|}
comment|/// processLogicalImmediate - Determine if an immediate value can be encoded
comment|/// as the immediate operand of a logical instruction for the given register
comment|/// size.  If so, return true with "encoding" set to the encoded value in
comment|/// the form N:immr:imms.
specifier|static
specifier|inline
name|bool
name|processLogicalImmediate
parameter_list|(
name|uint64_t
name|Imm
parameter_list|,
name|unsigned
name|RegSize
parameter_list|,
name|uint64_t
modifier|&
name|Encoding
parameter_list|)
block|{
if|if
condition|(
name|Imm
operator|==
literal|0ULL
operator|||
name|Imm
operator|==
operator|~
literal|0ULL
operator|||
operator|(
name|RegSize
operator|!=
literal|64
operator|&&
operator|(
name|Imm
operator|>>
name|RegSize
operator|!=
literal|0
operator|||
name|Imm
operator|==
operator|~
literal|0U
operator|)
operator|)
condition|)
return|return
name|false
return|;
comment|// First, determine the element size.
name|unsigned
name|Size
init|=
name|RegSize
decl_stmt|;
do|do
block|{
name|Size
operator|/=
literal|2
expr_stmt|;
name|uint64_t
name|Mask
init|=
operator|(
literal|1ULL
operator|<<
name|Size
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|Imm
operator|&
name|Mask
operator|)
operator|!=
operator|(
operator|(
name|Imm
operator|>>
name|Size
operator|)
operator|&
name|Mask
operator|)
condition|)
block|{
name|Size
operator|*=
literal|2
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|Size
operator|>
literal|2
condition|)
do|;
comment|// Second, determine the rotation to make the element be: 0^m 1^n.
name|uint32_t
name|CTO
decl_stmt|,
name|I
decl_stmt|;
name|uint64_t
name|Mask
init|=
operator|(
operator|(
name|uint64_t
operator|)
operator|-
literal|1LL
operator|)
operator|>>
operator|(
literal|64
operator|-
name|Size
operator|)
decl_stmt|;
name|Imm
operator|&=
name|Mask
expr_stmt|;
if|if
condition|(
name|isShiftedMask_64
argument_list|(
name|Imm
argument_list|)
condition|)
block|{
name|I
operator|=
name|countTrailingZeros
argument_list|(
name|Imm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<
literal|64
operator|&&
literal|"undefined behavior"
argument_list|)
expr_stmt|;
name|CTO
operator|=
name|CountTrailingOnes_64
argument_list|(
name|Imm
operator|>>
name|I
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Imm
operator||=
operator|~
name|Mask
expr_stmt|;
if|if
condition|(
operator|!
name|isShiftedMask_64
argument_list|(
operator|~
name|Imm
argument_list|)
condition|)
return|return
name|false
return|;
name|unsigned
name|CLO
init|=
name|CountLeadingOnes_64
argument_list|(
name|Imm
argument_list|)
decl_stmt|;
name|I
operator|=
literal|64
operator|-
name|CLO
expr_stmt|;
name|CTO
operator|=
name|CLO
operator|+
name|CountTrailingOnes_64
argument_list|(
name|Imm
argument_list|)
operator|-
operator|(
literal|64
operator|-
name|Size
operator|)
expr_stmt|;
block|}
comment|// Encode in Immr the number of RORs it would take to get *from* 0^m 1^n
comment|// to our target value, where I is the number of RORs to go the opposite
comment|// direction.
name|assert
argument_list|(
name|Size
operator|>
name|I
operator|&&
literal|"I should be smaller than element size"
argument_list|)
expr_stmt|;
name|unsigned
name|Immr
init|=
operator|(
name|Size
operator|-
name|I
operator|)
operator|&
operator|(
name|Size
operator|-
literal|1
operator|)
decl_stmt|;
comment|// If size has a 1 in the n'th bit, create a value that has zeroes in
comment|// bits [0, n] and ones above that.
name|uint64_t
name|NImms
init|=
operator|~
operator|(
name|Size
operator|-
literal|1
operator|)
operator|<<
literal|1
decl_stmt|;
comment|// Or the CTO value into the low bits, which must be below the Nth bit
comment|// bit mentioned above.
name|NImms
operator||=
operator|(
name|CTO
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Extract the seventh bit and toggle it to create the N field.
name|unsigned
name|N
init|=
operator|(
operator|(
name|NImms
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
operator|^
literal|1
decl_stmt|;
name|Encoding
operator|=
operator|(
name|N
operator|<<
literal|12
operator|)
operator||
operator|(
name|Immr
operator|<<
literal|6
operator|)
operator||
operator|(
name|NImms
operator|&
literal|0x3f
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// isLogicalImmediate - Return true if the immediate is valid for a logical
comment|/// immediate instruction of the given register size. Return false otherwise.
specifier|static
specifier|inline
name|bool
name|isLogicalImmediate
parameter_list|(
name|uint64_t
name|imm
parameter_list|,
name|unsigned
name|regSize
parameter_list|)
block|{
name|uint64_t
name|encoding
decl_stmt|;
return|return
name|processLogicalImmediate
argument_list|(
name|imm
argument_list|,
name|regSize
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/// encodeLogicalImmediate - Return the encoded immediate value for a logical
comment|/// immediate instruction of the given register size.
specifier|static
specifier|inline
name|uint64_t
name|encodeLogicalImmediate
parameter_list|(
name|uint64_t
name|imm
parameter_list|,
name|unsigned
name|regSize
parameter_list|)
block|{
name|uint64_t
name|encoding
init|=
literal|0
decl_stmt|;
name|bool
name|res
init|=
name|processLogicalImmediate
argument_list|(
name|imm
argument_list|,
name|regSize
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|res
operator|&&
literal|"invalid logical immediate"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|res
expr_stmt|;
return|return
name|encoding
return|;
block|}
comment|/// decodeLogicalImmediate - Decode a logical immediate value in the form
comment|/// "N:immr:imms" (where the immr and imms fields are each 6 bits) into the
comment|/// integer value it represents with regSize bits.
specifier|static
specifier|inline
name|uint64_t
name|decodeLogicalImmediate
parameter_list|(
name|uint64_t
name|val
parameter_list|,
name|unsigned
name|regSize
parameter_list|)
block|{
comment|// Extract the N, imms, and immr fields.
name|unsigned
name|N
init|=
operator|(
name|val
operator|>>
literal|12
operator|)
operator|&
literal|1
decl_stmt|;
name|unsigned
name|immr
init|=
operator|(
name|val
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|unsigned
name|imms
init|=
name|val
operator|&
literal|0x3f
decl_stmt|;
name|assert
argument_list|(
operator|(
name|regSize
operator|==
literal|64
operator|||
name|N
operator|==
literal|0
operator|)
operator|&&
literal|"undefined logical immediate encoding"
argument_list|)
expr_stmt|;
name|int
name|len
init|=
literal|31
operator|-
name|countLeadingZeros
argument_list|(
operator|(
name|N
operator|<<
literal|6
operator|)
operator||
operator|(
operator|~
name|imms
operator|&
literal|0x3f
operator|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|len
operator|>=
literal|0
operator|&&
literal|"undefined logical immediate encoding"
argument_list|)
expr_stmt|;
name|unsigned
name|size
init|=
operator|(
literal|1
operator|<<
name|len
operator|)
decl_stmt|;
name|unsigned
name|R
init|=
name|immr
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|S
init|=
name|imms
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
decl_stmt|;
name|assert
argument_list|(
name|S
operator|!=
name|size
operator|-
literal|1
operator|&&
literal|"undefined logical immediate encoding"
argument_list|)
expr_stmt|;
name|uint64_t
name|pattern
init|=
operator|(
literal|1ULL
operator|<<
operator|(
name|S
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|R
condition|;
operator|++
name|i
control|)
name|pattern
operator|=
name|ror
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// Replicate the pattern to fill the regSize.
while|while
condition|(
name|size
operator|!=
name|regSize
condition|)
block|{
name|pattern
operator||=
operator|(
name|pattern
operator|<<
name|size
operator|)
expr_stmt|;
name|size
operator|*=
literal|2
expr_stmt|;
block|}
return|return
name|pattern
return|;
block|}
comment|/// isValidDecodeLogicalImmediate - Check to see if the logical immediate value
comment|/// in the form "N:immr:imms" (where the immr and imms fields are each 6 bits)
comment|/// is a valid encoding for an integer value with regSize bits.
specifier|static
specifier|inline
name|bool
name|isValidDecodeLogicalImmediate
parameter_list|(
name|uint64_t
name|val
parameter_list|,
name|unsigned
name|regSize
parameter_list|)
block|{
comment|// Extract the N and imms fields needed for checking.
name|unsigned
name|N
init|=
operator|(
name|val
operator|>>
literal|12
operator|)
operator|&
literal|1
decl_stmt|;
name|unsigned
name|imms
init|=
name|val
operator|&
literal|0x3f
decl_stmt|;
if|if
condition|(
name|regSize
operator|==
literal|32
operator|&&
name|N
operator|!=
literal|0
condition|)
comment|// undefined logical immediate encoding
return|return
name|false
return|;
name|int
name|len
init|=
literal|31
operator|-
name|countLeadingZeros
argument_list|(
operator|(
name|N
operator|<<
literal|6
operator|)
operator||
operator|(
operator|~
name|imms
operator|&
literal|0x3f
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
comment|// undefined logical immediate encoding
return|return
name|false
return|;
name|unsigned
name|size
init|=
operator|(
literal|1
operator|<<
name|len
operator|)
decl_stmt|;
name|unsigned
name|S
init|=
name|imms
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|S
operator|==
name|size
operator|-
literal|1
condition|)
comment|// undefined logical immediate encoding
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Floating-point Immediates
comment|//
specifier|static
specifier|inline
name|float
name|getFPImmFloat
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// We expect an 8-bit binary encoding of a floating-point number here.
union|union
block|{
name|uint32_t
name|I
decl_stmt|;
name|float
name|F
decl_stmt|;
block|}
name|FPUnion
union|;
name|uint8_t
name|Sign
init|=
operator|(
name|Imm
operator|>>
literal|7
operator|)
operator|&
literal|0x1
decl_stmt|;
name|uint8_t
name|Exp
init|=
operator|(
name|Imm
operator|>>
literal|4
operator|)
operator|&
literal|0x7
decl_stmt|;
name|uint8_t
name|Mantissa
init|=
name|Imm
operator|&
literal|0xf
decl_stmt|;
comment|//   8-bit FP    iEEEE Float Encoding
comment|//   abcd efgh   aBbbbbbc defgh000 00000000 00000000
comment|//
comment|// where B = NOT(b);
name|FPUnion
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
name|Sign
operator|<<
literal|31
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
operator|(
name|Exp
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
operator|<<
literal|30
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
operator|(
name|Exp
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|?
literal|0x1f
else|:
literal|0
operator|)
operator|<<
literal|25
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
name|Exp
operator|&
literal|0x3
operator|)
operator|<<
literal|23
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
name|Mantissa
operator|<<
literal|19
expr_stmt|;
return|return
name|FPUnion
operator|.
name|F
return|;
block|}
comment|/// getFP32Imm - Return an 8-bit floating-point version of the 32-bit
comment|/// floating-point value. If the value cannot be represented as an 8-bit
comment|/// floating-point value, then return -1.
specifier|static
specifier|inline
name|int
name|getFP32Imm
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|)
block|{
name|uint32_t
name|Sign
init|=
name|Imm
operator|.
name|lshr
argument_list|(
literal|31
argument_list|)
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|1
decl_stmt|;
name|int32_t
name|Exp
init|=
operator|(
name|Imm
operator|.
name|lshr
argument_list|(
literal|23
argument_list|)
operator|.
name|getSExtValue
argument_list|()
operator|&
literal|0xff
operator|)
operator|-
literal|127
decl_stmt|;
comment|// -126 to 127
name|int64_t
name|Mantissa
init|=
name|Imm
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|0x7fffff
decl_stmt|;
comment|// 23 bits
comment|// We can handle 4 bits of mantissa.
comment|// mantissa = (16+UInt(e:f:g:h))/16.
if|if
condition|(
name|Mantissa
operator|&
literal|0x7ffff
condition|)
return|return
operator|-
literal|1
return|;
name|Mantissa
operator|>>=
literal|19
expr_stmt|;
if|if
condition|(
operator|(
name|Mantissa
operator|&
literal|0xf
operator|)
operator|!=
name|Mantissa
condition|)
return|return
operator|-
literal|1
return|;
comment|// We can handle 3 bits of exponent: exp == UInt(NOT(b):c:d)-3
if|if
condition|(
name|Exp
operator|<
operator|-
literal|3
operator|||
name|Exp
operator|>
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|Exp
operator|=
operator|(
operator|(
name|Exp
operator|+
literal|3
operator|)
operator|&
literal|0x7
operator|)
operator|^
literal|4
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|Sign
operator|<<
literal|7
operator|)
operator||
operator|(
name|Exp
operator|<<
literal|4
operator|)
operator||
name|Mantissa
return|;
block|}
specifier|static
specifier|inline
name|int
name|getFP32Imm
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|FPImm
parameter_list|)
block|{
return|return
name|getFP32Imm
argument_list|(
name|FPImm
operator|.
name|bitcastToAPInt
argument_list|()
argument_list|)
return|;
block|}
comment|/// getFP64Imm - Return an 8-bit floating-point version of the 64-bit
comment|/// floating-point value. If the value cannot be represented as an 8-bit
comment|/// floating-point value, then return -1.
specifier|static
specifier|inline
name|int
name|getFP64Imm
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|)
block|{
name|uint64_t
name|Sign
init|=
name|Imm
operator|.
name|lshr
argument_list|(
literal|63
argument_list|)
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|1
decl_stmt|;
name|int64_t
name|Exp
init|=
operator|(
name|Imm
operator|.
name|lshr
argument_list|(
literal|52
argument_list|)
operator|.
name|getSExtValue
argument_list|()
operator|&
literal|0x7ff
operator|)
operator|-
literal|1023
decl_stmt|;
comment|// -1022 to 1023
name|uint64_t
name|Mantissa
init|=
name|Imm
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|0xfffffffffffffULL
decl_stmt|;
comment|// We can handle 4 bits of mantissa.
comment|// mantissa = (16+UInt(e:f:g:h))/16.
if|if
condition|(
name|Mantissa
operator|&
literal|0xffffffffffffULL
condition|)
return|return
operator|-
literal|1
return|;
name|Mantissa
operator|>>=
literal|48
expr_stmt|;
if|if
condition|(
operator|(
name|Mantissa
operator|&
literal|0xf
operator|)
operator|!=
name|Mantissa
condition|)
return|return
operator|-
literal|1
return|;
comment|// We can handle 3 bits of exponent: exp == UInt(NOT(b):c:d)-3
if|if
condition|(
name|Exp
operator|<
operator|-
literal|3
operator|||
name|Exp
operator|>
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|Exp
operator|=
operator|(
operator|(
name|Exp
operator|+
literal|3
operator|)
operator|&
literal|0x7
operator|)
operator|^
literal|4
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|Sign
operator|<<
literal|7
operator|)
operator||
operator|(
name|Exp
operator|<<
literal|4
operator|)
operator||
name|Mantissa
return|;
block|}
specifier|static
specifier|inline
name|int
name|getFP64Imm
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|FPImm
parameter_list|)
block|{
return|return
name|getFP64Imm
argument_list|(
name|FPImm
operator|.
name|bitcastToAPInt
argument_list|()
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// AdvSIMD Modified Immediates
comment|//===--------------------------------------------------------------------===//
comment|// 0x00 0x00 0x00 abcdefgh 0x00 0x00 0x00 abcdefgh
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType1
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xffffff00ffffff00ULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType1
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType1
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|32
operator|)
operator||
name|EncVal
return|;
block|}
comment|// 0x00 0x00 abcdefgh 0x00 0x00 0x00 abcdefgh 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType2
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xffff00ffffff00ffULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType2
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xff00ULL
operator|)
operator|>>
literal|8
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType2
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|40
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|8
operator|)
return|;
block|}
comment|// 0x00 abcdefgh 0x00 0x00 0x00 abcdefgh 0x00 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType3
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xff00ffffff00ffffULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType3
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xff0000ULL
operator|)
operator|>>
literal|16
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType3
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|48
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|16
operator|)
return|;
block|}
comment|// abcdefgh 0x00 0x00 0x00 abcdefgh 0x00 0x00 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType4
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0x00ffffff00ffffffULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType4
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xff000000ULL
operator|)
operator|>>
literal|24
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType4
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|56
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|24
operator|)
return|;
block|}
comment|// 0x00 abcdefgh 0x00 abcdefgh 0x00 abcdefgh 0x00 abcdefgh
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType5
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|Imm
operator|&
literal|0x00ff0000ULL
operator|)
operator|>>
literal|16
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0x000000ffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xff00ff00ff00ff00ULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType5
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType5
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|48
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|32
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|16
operator|)
operator||
name|EncVal
return|;
block|}
comment|// abcdefgh 0x00 abcdefgh 0x00 abcdefgh 0x00 abcdefgh 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType6
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|Imm
operator|&
literal|0xff000000ULL
operator|)
operator|>>
literal|16
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0x0000ff00ULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0x00ff00ff00ff00ffULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType6
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xff00ULL
operator|)
operator|>>
literal|8
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType6
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|56
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|40
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|24
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|8
operator|)
return|;
block|}
comment|// 0x00 0x00 abcdefgh 0xFF 0x00 0x00 abcdefgh 0xFF
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType7
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xffff00ffffff00ffULL
operator|)
operator|==
literal|0x000000ff000000ffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType7
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xff00ULL
operator|)
operator|>>
literal|8
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType7
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|40
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|8
operator|)
operator||
literal|0x000000ff000000ffULL
return|;
block|}
comment|// 0x00 abcdefgh 0xFF 0xFF 0x00 abcdefgh 0xFF 0xFF
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType8
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0xff00ffffff00ffffULL
operator|)
operator|==
literal|0x0000ffff0000ffffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType8
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|48
operator|)
operator||
operator|(
name|EncVal
operator|<<
literal|16
operator|)
operator||
literal|0x0000ffff0000ffffULL
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType8
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0x00ff0000ULL
operator|)
operator|>>
literal|16
return|;
block|}
comment|// abcdefgh abcdefgh abcdefgh abcdefgh abcdefgh abcdefgh abcdefgh abcdefgh
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType9
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|>>
literal|48
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0x0000ffffULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|>>
literal|56
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0x000000ffULL
operator|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType9
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|&
literal|0xffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType9
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
name|Imm
decl_stmt|;
name|EncVal
operator||=
operator|(
name|EncVal
operator|<<
literal|8
operator|)
expr_stmt|;
name|EncVal
operator||=
operator|(
name|EncVal
operator|<<
literal|16
operator|)
expr_stmt|;
name|EncVal
operator||=
operator|(
name|EncVal
operator|<<
literal|32
operator|)
expr_stmt|;
return|return
name|EncVal
return|;
block|}
comment|// aaaaaaaa bbbbbbbb cccccccc dddddddd eeeeeeee ffffffff gggggggg hhhhhhhh
comment|// cmode: 1110, op: 1
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType10
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|ByteA
init|=
name|Imm
operator|&
literal|0xff00000000000000ULL
decl_stmt|;
name|uint64_t
name|ByteB
init|=
name|Imm
operator|&
literal|0x00ff000000000000ULL
decl_stmt|;
name|uint64_t
name|ByteC
init|=
name|Imm
operator|&
literal|0x0000ff0000000000ULL
decl_stmt|;
name|uint64_t
name|ByteD
init|=
name|Imm
operator|&
literal|0x000000ff00000000ULL
decl_stmt|;
name|uint64_t
name|ByteE
init|=
name|Imm
operator|&
literal|0x00000000ff000000ULL
decl_stmt|;
name|uint64_t
name|ByteF
init|=
name|Imm
operator|&
literal|0x0000000000ff0000ULL
decl_stmt|;
name|uint64_t
name|ByteG
init|=
name|Imm
operator|&
literal|0x000000000000ff00ULL
decl_stmt|;
name|uint64_t
name|ByteH
init|=
name|Imm
operator|&
literal|0x00000000000000ffULL
decl_stmt|;
return|return
operator|(
name|ByteA
operator|==
literal|0ULL
operator|||
name|ByteA
operator|==
literal|0xff00000000000000ULL
operator|)
operator|&&
operator|(
name|ByteB
operator|==
literal|0ULL
operator|||
name|ByteB
operator|==
literal|0x00ff000000000000ULL
operator|)
operator|&&
operator|(
name|ByteC
operator|==
literal|0ULL
operator|||
name|ByteC
operator|==
literal|0x0000ff0000000000ULL
operator|)
operator|&&
operator|(
name|ByteD
operator|==
literal|0ULL
operator|||
name|ByteD
operator|==
literal|0x000000ff00000000ULL
operator|)
operator|&&
operator|(
name|ByteE
operator|==
literal|0ULL
operator|||
name|ByteE
operator|==
literal|0x00000000ff000000ULL
operator|)
operator|&&
operator|(
name|ByteF
operator|==
literal|0ULL
operator|||
name|ByteF
operator|==
literal|0x0000000000ff0000ULL
operator|)
operator|&&
operator|(
name|ByteG
operator|==
literal|0ULL
operator|||
name|ByteG
operator|==
literal|0x000000000000ff00ULL
operator|)
operator|&&
operator|(
name|ByteH
operator|==
literal|0ULL
operator|||
name|ByteH
operator|==
literal|0x00000000000000ffULL
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType10
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint8_t
name|BitA
init|=
operator|(
name|Imm
operator|&
literal|0xff00000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitB
init|=
operator|(
name|Imm
operator|&
literal|0x00ff000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitC
init|=
operator|(
name|Imm
operator|&
literal|0x0000ff0000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitD
init|=
operator|(
name|Imm
operator|&
literal|0x000000ff00000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitE
init|=
operator|(
name|Imm
operator|&
literal|0x00000000ff000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitF
init|=
operator|(
name|Imm
operator|&
literal|0x0000000000ff0000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitG
init|=
operator|(
name|Imm
operator|&
literal|0x000000000000ff00ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitH
init|=
operator|(
name|Imm
operator|&
literal|0x00000000000000ffULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|EncVal
init|=
name|BitA
decl_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitB
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitC
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitD
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitE
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitF
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitG
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitH
expr_stmt|;
return|return
name|EncVal
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType10
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x80
condition|)
name|EncVal
operator||=
literal|0xff00000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x40
condition|)
name|EncVal
operator||=
literal|0x00ff000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x20
condition|)
name|EncVal
operator||=
literal|0x0000ff0000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x10
condition|)
name|EncVal
operator||=
literal|0x000000ff00000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x08
condition|)
name|EncVal
operator||=
literal|0x00000000ff000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x04
condition|)
name|EncVal
operator||=
literal|0x0000000000ff0000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x02
condition|)
name|EncVal
operator||=
literal|0x000000000000ff00ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x01
condition|)
name|EncVal
operator||=
literal|0x00000000000000ffULL
expr_stmt|;
return|return
name|EncVal
return|;
block|}
comment|// aBbbbbbc defgh000 0x00 0x00 aBbbbbbc defgh000 0x00 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType11
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|BString
init|=
operator|(
name|Imm
operator|&
literal|0x7E000000ULL
operator|)
operator|>>
literal|25
decl_stmt|;
return|return
operator|(
operator|(
name|Imm
operator|>>
literal|32
operator|)
operator|==
operator|(
name|Imm
operator|&
literal|0xffffffffULL
operator|)
operator|)
operator|&&
operator|(
name|BString
operator|==
literal|0x1f
operator|||
name|BString
operator|==
literal|0x20
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0x0007ffff0007ffffULL
operator|)
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType11
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint8_t
name|BitA
init|=
operator|(
name|Imm
operator|&
literal|0x80000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitB
init|=
operator|(
name|Imm
operator|&
literal|0x20000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitC
init|=
operator|(
name|Imm
operator|&
literal|0x01000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitD
init|=
operator|(
name|Imm
operator|&
literal|0x00800000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitE
init|=
operator|(
name|Imm
operator|&
literal|0x00400000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitF
init|=
operator|(
name|Imm
operator|&
literal|0x00200000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitG
init|=
operator|(
name|Imm
operator|&
literal|0x00100000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitH
init|=
operator|(
name|Imm
operator|&
literal|0x00080000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|EncVal
init|=
name|BitA
decl_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitB
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitC
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitD
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitE
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitF
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitG
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitH
expr_stmt|;
return|return
name|EncVal
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType11
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x80
condition|)
name|EncVal
operator||=
literal|0x80000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x40
condition|)
name|EncVal
operator||=
literal|0x3e000000ULL
expr_stmt|;
else|else
name|EncVal
operator||=
literal|0x40000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x20
condition|)
name|EncVal
operator||=
literal|0x01000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x10
condition|)
name|EncVal
operator||=
literal|0x00800000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x08
condition|)
name|EncVal
operator||=
literal|0x00400000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x04
condition|)
name|EncVal
operator||=
literal|0x00200000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x02
condition|)
name|EncVal
operator||=
literal|0x00100000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x01
condition|)
name|EncVal
operator||=
literal|0x00080000ULL
expr_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|32
operator|)
operator||
name|EncVal
return|;
block|}
comment|// aBbbbbbb bbcdefgh 0x00 0x00 0x00 0x00 0x00 0x00
specifier|static
specifier|inline
name|bool
name|isAdvSIMDModImmType12
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|BString
init|=
operator|(
name|Imm
operator|&
literal|0x7fc0000000000000ULL
operator|)
operator|>>
literal|54
decl_stmt|;
return|return
operator|(
operator|(
name|BString
operator|==
literal|0xff
operator|||
name|BString
operator|==
literal|0x100
operator|)
operator|&&
operator|(
operator|(
name|Imm
operator|&
literal|0x0000ffffffffffffULL
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|uint8_t
name|encodeAdvSIMDModImmType12
parameter_list|(
name|uint64_t
name|Imm
parameter_list|)
block|{
name|uint8_t
name|BitA
init|=
operator|(
name|Imm
operator|&
literal|0x8000000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitB
init|=
operator|(
name|Imm
operator|&
literal|0x0040000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitC
init|=
operator|(
name|Imm
operator|&
literal|0x0020000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitD
init|=
operator|(
name|Imm
operator|&
literal|0x0010000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitE
init|=
operator|(
name|Imm
operator|&
literal|0x0008000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitF
init|=
operator|(
name|Imm
operator|&
literal|0x0004000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitG
init|=
operator|(
name|Imm
operator|&
literal|0x0002000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|BitH
init|=
operator|(
name|Imm
operator|&
literal|0x0001000000000000ULL
operator|)
operator|!=
literal|0
decl_stmt|;
name|uint8_t
name|EncVal
init|=
name|BitA
decl_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitB
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitC
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitD
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitE
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitF
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitG
expr_stmt|;
name|EncVal
operator|<<=
literal|1
expr_stmt|;
name|EncVal
operator||=
name|BitH
expr_stmt|;
return|return
name|EncVal
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|decodeAdvSIMDModImmType12
parameter_list|(
name|uint8_t
name|Imm
parameter_list|)
block|{
name|uint64_t
name|EncVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x80
condition|)
name|EncVal
operator||=
literal|0x8000000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x40
condition|)
name|EncVal
operator||=
literal|0x3fc0000000000000ULL
expr_stmt|;
else|else
name|EncVal
operator||=
literal|0x4000000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x20
condition|)
name|EncVal
operator||=
literal|0x0020000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x10
condition|)
name|EncVal
operator||=
literal|0x0010000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x08
condition|)
name|EncVal
operator||=
literal|0x0008000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x04
condition|)
name|EncVal
operator||=
literal|0x0004000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x02
condition|)
name|EncVal
operator||=
literal|0x0002000000000000ULL
expr_stmt|;
if|if
condition|(
name|Imm
operator|&
literal|0x01
condition|)
name|EncVal
operator||=
literal|0x0001000000000000ULL
expr_stmt|;
return|return
operator|(
name|EncVal
operator|<<
literal|32
operator|)
operator||
name|EncVal
return|;
block|}
block|}
comment|// end namespace AArch64_AM
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

