begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=== AArch64CallingConv.h - Custom Calling Convention Routines -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the custom routines for the AArch64 Calling Convention
end_comment

begin_comment
comment|// that aren't done by tablegen.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_AARCH64_AARCH64CALLINGCONVENTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_AARCH64_AARCH64CALLINGCONVENTION_H
end_define

begin_include
include|#
directive|include
file|"AArch64.h"
end_include

begin_include
include|#
directive|include
file|"AArch64InstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"AArch64Subtarget.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/CallingConvLower.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallingConv.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetInstrInfo.h"
end_include

begin_macro
name|namespace
end_macro

begin_block
block|{
name|using
name|namespace
name|llvm
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|XRegList
index|[]
init|=
block|{
name|AArch64
operator|::
name|X0
block|,
name|AArch64
operator|::
name|X1
block|,
name|AArch64
operator|::
name|X2
block|,
name|AArch64
operator|::
name|X3
block|,
name|AArch64
operator|::
name|X4
block|,
name|AArch64
operator|::
name|X5
block|,
name|AArch64
operator|::
name|X6
block|,
name|AArch64
operator|::
name|X7
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|HRegList
index|[]
init|=
block|{
name|AArch64
operator|::
name|H0
block|,
name|AArch64
operator|::
name|H1
block|,
name|AArch64
operator|::
name|H2
block|,
name|AArch64
operator|::
name|H3
block|,
name|AArch64
operator|::
name|H4
block|,
name|AArch64
operator|::
name|H5
block|,
name|AArch64
operator|::
name|H6
block|,
name|AArch64
operator|::
name|H7
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|SRegList
index|[]
init|=
block|{
name|AArch64
operator|::
name|S0
block|,
name|AArch64
operator|::
name|S1
block|,
name|AArch64
operator|::
name|S2
block|,
name|AArch64
operator|::
name|S3
block|,
name|AArch64
operator|::
name|S4
block|,
name|AArch64
operator|::
name|S5
block|,
name|AArch64
operator|::
name|S6
block|,
name|AArch64
operator|::
name|S7
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|DRegList
index|[]
init|=
block|{
name|AArch64
operator|::
name|D0
block|,
name|AArch64
operator|::
name|D1
block|,
name|AArch64
operator|::
name|D2
block|,
name|AArch64
operator|::
name|D3
block|,
name|AArch64
operator|::
name|D4
block|,
name|AArch64
operator|::
name|D5
block|,
name|AArch64
operator|::
name|D6
block|,
name|AArch64
operator|::
name|D7
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|QRegList
index|[]
init|=
block|{
name|AArch64
operator|::
name|Q0
block|,
name|AArch64
operator|::
name|Q1
block|,
name|AArch64
operator|::
name|Q2
block|,
name|AArch64
operator|::
name|Q3
block|,
name|AArch64
operator|::
name|Q4
block|,
name|AArch64
operator|::
name|Q5
block|,
name|AArch64
operator|::
name|Q6
block|,
name|AArch64
operator|::
name|Q7
block|}
decl_stmt|;
specifier|static
name|bool
name|finishStackBlock
argument_list|(
name|SmallVectorImpl
operator|<
name|CCValAssign
operator|>
operator|&
name|PendingMembers
argument_list|,
name|MVT
name|LocVT
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|,
name|unsigned
name|SlotAlign
argument_list|)
block|{
name|unsigned
name|Size
init|=
name|LocVT
operator|.
name|getSizeInBits
argument_list|()
operator|/
literal|8
decl_stmt|;
name|unsigned
name|StackAlign
init|=
name|State
operator|.
name|getMachineFunction
argument_list|()
operator|.
name|getSubtarget
argument_list|()
operator|.
name|getDataLayout
argument_list|()
operator|->
name|getStackAlignment
argument_list|()
decl_stmt|;
name|unsigned
name|Align
init|=
name|std
operator|::
name|min
argument_list|(
name|ArgFlags
operator|.
name|getOrigAlign
argument_list|()
argument_list|,
name|StackAlign
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|It
operator|:
name|PendingMembers
control|)
block|{
name|It
operator|.
name|convertToMem
argument_list|(
name|State
operator|.
name|AllocateStack
argument_list|(
name|Size
argument_list|,
name|std
operator|::
name|max
argument_list|(
name|Align
argument_list|,
name|SlotAlign
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|State
operator|.
name|addLoc
argument_list|(
name|It
argument_list|)
expr_stmt|;
name|SlotAlign
operator|=
literal|1
expr_stmt|;
block|}
comment|// All pending members have now been allocated
name|PendingMembers
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// The Darwin variadic PCS places anonymous arguments in 8-byte stack slots. An
comment|/// [N x Ty] type must still be contiguous in memory though.
specifier|static
name|bool
name|CC_AArch64_Custom_Stack_Block
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
block|{
name|SmallVectorImpl
operator|<
name|CCValAssign
operator|>
operator|&
name|PendingMembers
operator|=
name|State
operator|.
name|getPendingLocs
argument_list|()
expr_stmt|;
comment|// Add the argument to the list to be allocated once we know the size of the
comment|// block.
name|PendingMembers
operator|.
name|push_back
argument_list|(
name|CCValAssign
operator|::
name|getPending
argument_list|(
name|ValNo
argument_list|,
name|ValVT
argument_list|,
name|LocVT
argument_list|,
name|LocInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ArgFlags
operator|.
name|isInConsecutiveRegsLast
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|finishStackBlock
argument_list|(
name|PendingMembers
argument_list|,
name|LocVT
argument_list|,
name|ArgFlags
argument_list|,
name|State
argument_list|,
literal|8
argument_list|)
return|;
block|}
comment|/// Given an [N x Ty] block, it should be passed in a consecutive sequence of
comment|/// registers. If no such sequence is available, mark the rest of the registers
comment|/// of that type as used and place the argument on the stack.
specifier|static
name|bool
name|CC_AArch64_Custom_Block
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
block|{
comment|// Try to allocate a contiguous block of registers, each of the correct
comment|// size to hold one member.
name|ArrayRef
operator|<
name|uint16_t
operator|>
name|RegList
expr_stmt|;
if|if
condition|(
name|LocVT
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|i64
condition|)
name|RegList
operator|=
name|XRegList
expr_stmt|;
elseif|else
if|if
condition|(
name|LocVT
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|f16
condition|)
name|RegList
operator|=
name|HRegList
expr_stmt|;
elseif|else
if|if
condition|(
name|LocVT
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|f32
operator|||
name|LocVT
operator|.
name|is32BitVector
argument_list|()
condition|)
name|RegList
operator|=
name|SRegList
expr_stmt|;
elseif|else
if|if
condition|(
name|LocVT
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|f64
operator|||
name|LocVT
operator|.
name|is64BitVector
argument_list|()
condition|)
name|RegList
operator|=
name|DRegList
expr_stmt|;
elseif|else
if|if
condition|(
name|LocVT
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|f128
operator|||
name|LocVT
operator|.
name|is128BitVector
argument_list|()
condition|)
name|RegList
operator|=
name|QRegList
expr_stmt|;
else|else
block|{
comment|// Not an array we want to split up after all.
return|return
name|false
return|;
block|}
name|SmallVectorImpl
operator|<
name|CCValAssign
operator|>
operator|&
name|PendingMembers
operator|=
name|State
operator|.
name|getPendingLocs
argument_list|()
expr_stmt|;
comment|// Add the argument to the list to be allocated once we know the size of the
comment|// block.
name|PendingMembers
operator|.
name|push_back
argument_list|(
name|CCValAssign
operator|::
name|getPending
argument_list|(
name|ValNo
argument_list|,
name|ValVT
argument_list|,
name|LocVT
argument_list|,
name|LocInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ArgFlags
operator|.
name|isInConsecutiveRegsLast
argument_list|()
condition|)
return|return
name|true
return|;
name|unsigned
name|RegResult
init|=
name|State
operator|.
name|AllocateRegBlock
argument_list|(
name|RegList
argument_list|,
name|PendingMembers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|RegResult
condition|)
block|{
for|for
control|(
name|auto
operator|&
name|It
operator|:
name|PendingMembers
control|)
block|{
name|It
operator|.
name|convertToReg
argument_list|(
name|RegResult
argument_list|)
expr_stmt|;
name|State
operator|.
name|addLoc
argument_list|(
name|It
argument_list|)
expr_stmt|;
operator|++
name|RegResult
expr_stmt|;
block|}
name|PendingMembers
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Mark all regs in the class as unavailable
for|for
control|(
name|auto
name|Reg
range|:
name|RegList
control|)
name|State
operator|.
name|AllocateReg
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
specifier|const
name|AArch64Subtarget
modifier|&
name|Subtarget
init|=
name|static_cast
operator|<
specifier|const
name|AArch64Subtarget
operator|&
operator|>
operator|(
name|State
operator|.
name|getMachineFunction
argument_list|()
operator|.
name|getSubtarget
argument_list|()
operator|)
decl_stmt|;
name|unsigned
name|SlotAlign
init|=
name|Subtarget
operator|.
name|isTargetDarwin
argument_list|()
condition|?
literal|1
else|:
literal|8
decl_stmt|;
return|return
name|finishStackBlock
argument_list|(
name|PendingMembers
argument_list|,
name|LocVT
argument_list|,
name|ArgFlags
argument_list|,
name|State
argument_list|,
name|SlotAlign
argument_list|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

