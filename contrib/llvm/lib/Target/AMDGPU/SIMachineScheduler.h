begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- SIMachineScheduler.h - SI Scheduler Interface -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief SI Machine Scheduler interface
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_AMDGPU_SIMACHINESCHEDULER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_AMDGPU_SIMACHINESCHEDULER_H
end_define

begin_include
include|#
directive|include
file|"SIInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineScheduler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/RegisterPressure.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/ScheduleDAG.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
enum|enum
name|SIScheduleCandReason
block|{
name|NoCand
block|,
name|RegUsage
block|,
name|Latency
block|,
name|Successor
block|,
name|Depth
block|,
name|NodeOrder
block|}
enum|;
struct|struct
name|SISchedulerCandidate
block|{
comment|// The reason for this candidate.
name|SIScheduleCandReason
name|Reason
init|=
name|NoCand
decl_stmt|;
comment|// Set of reasons that apply to multiple candidates.
name|uint32_t
name|RepeatReasonSet
init|=
literal|0
decl_stmt|;
name|SISchedulerCandidate
argument_list|()
operator|=
expr|default
expr_stmt|;
name|bool
name|isRepeat
parameter_list|(
name|SIScheduleCandReason
name|R
parameter_list|)
block|{
return|return
name|RepeatReasonSet
operator|&
operator|(
literal|1
operator|<<
name|R
operator|)
return|;
block|}
name|void
name|setRepeat
parameter_list|(
name|SIScheduleCandReason
name|R
parameter_list|)
block|{
name|RepeatReasonSet
operator||=
operator|(
literal|1
operator|<<
name|R
operator|)
expr_stmt|;
block|}
block|}
struct|;
name|class
name|SIScheduleDAGMI
decl_stmt|;
name|class
name|SIScheduleBlockCreator
decl_stmt|;
enum|enum
name|SIScheduleBlockLinkKind
block|{
name|NoData
block|,
name|Data
block|}
enum|;
name|class
name|SIScheduleBlock
block|{
name|SIScheduleDAGMI
modifier|*
name|DAG
decl_stmt|;
name|SIScheduleBlockCreator
modifier|*
name|BC
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SUnit
operator|*
operator|>
name|SUnits
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|NodeNum2Index
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SUnit
operator|*
operator|>
name|TopReadySUs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SUnit
operator|*
operator|>
name|ScheduledSUnits
expr_stmt|;
comment|/// The top of the unscheduled zone.
name|IntervalPressure
name|TopPressure
decl_stmt|;
name|RegPressureTracker
name|TopRPTracker
decl_stmt|;
comment|// Pressure: number of said class of registers needed to
comment|// store the live virtual and real registers.
comment|// We do care only of SGPR32 and VGPR32 and do track only virtual registers.
comment|// Pressure of additional registers required inside the block.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|InternalAdditionnalPressure
expr_stmt|;
comment|// Pressure of input and output registers
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LiveInPressure
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LiveOutPressure
expr_stmt|;
comment|// Registers required by the block, and outputs.
comment|// We do track only virtual registers.
comment|// Note that some registers are not 32 bits,
comment|// and thus the pressure is not equal
comment|// to the number of live registers.
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|LiveInRegs
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|LiveOutRegs
expr_stmt|;
name|bool
name|Scheduled
init|=
name|false
decl_stmt|;
name|bool
name|HighLatencyBlock
init|=
name|false
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|HasLowLatencyNonWaitedParent
expr_stmt|;
comment|// Unique ID, the index of the Block in the SIScheduleDAGMI Blocks table.
name|unsigned
name|ID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|Preds
expr_stmt|;
comment|// All blocks predecessors.
comment|// All blocks successors, and the kind of link
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|SIScheduleBlock
operator|*
operator|,
name|SIScheduleBlockLinkKind
operator|>>
name|Succs
expr_stmt|;
name|unsigned
name|NumHighLatencySuccessors
init|=
literal|0
decl_stmt|;
name|public
label|:
name|SIScheduleBlock
argument_list|(
argument|SIScheduleDAGMI *DAG
argument_list|,
argument|SIScheduleBlockCreator *BC
argument_list|,
argument|unsigned ID
argument_list|)
block|:
name|DAG
argument_list|(
name|DAG
argument_list|)
operator|,
name|BC
argument_list|(
name|BC
argument_list|)
operator|,
name|TopRPTracker
argument_list|(
name|TopPressure
argument_list|)
operator|,
name|ID
argument_list|(
argument|ID
argument_list|)
block|{}
operator|~
name|SIScheduleBlock
argument_list|()
operator|=
expr|default
expr_stmt|;
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|ID
return|;
block|}
comment|/// Functions for Block construction.
name|void
name|addUnit
parameter_list|(
name|SUnit
modifier|*
name|SU
parameter_list|)
function_decl|;
comment|// When all SUs have been added.
name|void
name|finalizeUnits
parameter_list|()
function_decl|;
comment|// Add block pred, which has instruction predecessor of SU.
name|void
name|addPred
parameter_list|(
name|SIScheduleBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|addSucc
parameter_list|(
name|SIScheduleBlock
modifier|*
name|Succ
parameter_list|,
name|SIScheduleBlockLinkKind
name|Kind
parameter_list|)
function_decl|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
operator|&
name|getPreds
argument_list|()
specifier|const
block|{
return|return
name|Preds
return|;
block|}
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|SIScheduleBlock
operator|*
operator|,
name|SIScheduleBlockLinkKind
operator|>>
name|getSuccs
argument_list|()
specifier|const
block|{
return|return
name|Succs
return|;
block|}
name|unsigned
name|Height
decl_stmt|;
comment|// Maximum topdown path length to block without outputs
name|unsigned
name|Depth
decl_stmt|;
comment|// Maximum bottomup path length to block without inputs
name|unsigned
name|getNumHighLatencySuccessors
argument_list|()
specifier|const
block|{
return|return
name|NumHighLatencySuccessors
return|;
block|}
name|bool
name|isHighLatencyBlock
parameter_list|()
block|{
return|return
name|HighLatencyBlock
return|;
block|}
comment|// This is approximative.
comment|// Ideally should take into accounts some instructions (rcp, etc)
comment|// are 4 times slower.
name|int
name|getCost
parameter_list|()
block|{
return|return
name|SUnits
operator|.
name|size
argument_list|()
return|;
block|}
comment|// The block Predecessors and Successors must be all registered
comment|// before fastSchedule().
comment|// Fast schedule with no particular requirement.
name|void
name|fastSchedule
parameter_list|()
function_decl|;
name|std
operator|::
name|vector
operator|<
name|SUnit
operator|*
operator|>
name|getScheduledUnits
argument_list|()
block|{
return|return
name|ScheduledSUnits
return|;
block|}
comment|// Complete schedule that will try to minimize reg pressure and
comment|// low latencies, and will fill liveins and liveouts.
comment|// Needs all MIs to be grouped between BeginBlock and EndBlock.
comment|// The MIs can be moved after the scheduling,
comment|// it is just used to allow correct track of live registers.
name|void
name|schedule
argument_list|(
name|MachineBasicBlock
operator|::
name|iterator
name|BeginBlock
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|EndBlock
argument_list|)
decl_stmt|;
name|bool
name|isScheduled
parameter_list|()
block|{
return|return
name|Scheduled
return|;
block|}
comment|// Needs the block to be scheduled inside
comment|// TODO: find a way to compute it.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getInternalAdditionnalRegUsage
argument_list|()
block|{
return|return
name|InternalAdditionnalPressure
return|;
block|}
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|getInRegs
argument_list|()
block|{
return|return
name|LiveInRegs
return|;
block|}
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|getOutRegs
argument_list|()
block|{
return|return
name|LiveOutRegs
return|;
block|}
name|void
name|printDebug
parameter_list|(
name|bool
name|Full
parameter_list|)
function_decl|;
name|private
label|:
name|struct
name|SISchedCandidate
range|:
name|SISchedulerCandidate
block|{
comment|// The best SUnit candidate.
name|SUnit
operator|*
name|SU
operator|=
name|nullptr
block|;
name|unsigned
name|SGPRUsage
block|;
name|unsigned
name|VGPRUsage
block|;
name|bool
name|IsLowLatency
block|;
name|unsigned
name|LowLatencyOffset
block|;
name|bool
name|HasLowLatencyNonWaitedParent
block|;
name|SISchedCandidate
argument_list|()
operator|=
expr|default
block|;
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|SU
return|;
block|}
comment|// Copy the status of another candidate without changing policy.
name|void
name|setBest
argument_list|(
argument|SISchedCandidate&Best
argument_list|)
block|{
name|assert
argument_list|(
name|Best
operator|.
name|Reason
operator|!=
name|NoCand
operator|&&
literal|"uninitialized Sched candidate"
argument_list|)
block|;
name|SU
operator|=
name|Best
operator|.
name|SU
block|;
name|Reason
operator|=
name|Best
operator|.
name|Reason
block|;
name|SGPRUsage
operator|=
name|Best
operator|.
name|SGPRUsage
block|;
name|VGPRUsage
operator|=
name|Best
operator|.
name|VGPRUsage
block|;
name|IsLowLatency
operator|=
name|Best
operator|.
name|IsLowLatency
block|;
name|LowLatencyOffset
operator|=
name|Best
operator|.
name|LowLatencyOffset
block|;
name|HasLowLatencyNonWaitedParent
operator|=
name|Best
operator|.
name|HasLowLatencyNonWaitedParent
block|;     }
expr|}
block|;
name|void
name|undoSchedule
argument_list|()
block|;
name|void
name|undoReleaseSucc
argument_list|(
name|SUnit
operator|*
name|SU
argument_list|,
name|SDep
operator|*
name|SuccEdge
argument_list|)
block|;
name|void
name|releaseSucc
argument_list|(
name|SUnit
operator|*
name|SU
argument_list|,
name|SDep
operator|*
name|SuccEdge
argument_list|)
block|;
comment|// InOrOutBlock: restrict to links pointing inside the block (true),
comment|// or restrict to links pointing outside the block (false).
name|void
name|releaseSuccessors
argument_list|(
argument|SUnit *SU
argument_list|,
argument|bool InOrOutBlock
argument_list|)
block|;
name|void
name|nodeScheduled
argument_list|(
name|SUnit
operator|*
name|SU
argument_list|)
block|;
name|void
name|tryCandidateTopDown
argument_list|(
name|SISchedCandidate
operator|&
name|Cand
argument_list|,
name|SISchedCandidate
operator|&
name|TryCand
argument_list|)
block|;
name|void
name|tryCandidateBottomUp
argument_list|(
name|SISchedCandidate
operator|&
name|Cand
argument_list|,
name|SISchedCandidate
operator|&
name|TryCand
argument_list|)
block|;
name|SUnit
operator|*
name|pickNode
argument_list|()
block|;
name|void
name|traceCandidate
argument_list|(
specifier|const
name|SISchedCandidate
operator|&
name|Cand
argument_list|)
block|;
name|void
name|initRegPressure
argument_list|(
argument|MachineBasicBlock::iterator BeginBlock
argument_list|,
argument|MachineBasicBlock::iterator EndBlock
argument_list|)
block|; }
decl_stmt|;
struct|struct
name|SIScheduleBlocks
block|{
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|Blocks
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|TopDownIndex2Block
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|TopDownBlock2Index
expr_stmt|;
block|}
struct|;
enum|enum
name|SISchedulerBlockCreatorVariant
block|{
name|LatenciesAlone
block|,
name|LatenciesGrouped
block|,
name|LatenciesAlonePlusConsecutive
block|}
enum|;
name|class
name|SIScheduleBlockCreator
block|{
name|SIScheduleDAGMI
modifier|*
name|DAG
decl_stmt|;
comment|// unique_ptr handles freeing memory for us.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|SIScheduleBlock
operator|>>
name|BlockPtrs
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|SISchedulerBlockCreatorVariant
operator|,
name|SIScheduleBlocks
operator|>
name|Blocks
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|CurrentBlocks
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|Node2CurrentBlock
expr_stmt|;
comment|// Topological sort
comment|// Maps topological index to the node number.
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|TopDownIndex2Block
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|TopDownBlock2Index
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|BottomUpIndex2Block
expr_stmt|;
comment|// 0 -> Color not given.
comment|// 1 to SUnits.size() -> Reserved group (you should only add elements to them).
comment|// Above -> Other groups.
name|int
name|NextReservedID
decl_stmt|;
name|int
name|NextNonReservedID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|CurrentColoring
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|CurrentTopDownReservedDependencyColoring
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|CurrentBottomUpReservedDependencyColoring
expr_stmt|;
name|public
label|:
name|SIScheduleBlockCreator
argument_list|(
name|SIScheduleDAGMI
operator|*
name|DAG
argument_list|)
expr_stmt|;
operator|~
name|SIScheduleBlockCreator
argument_list|()
expr_stmt|;
name|SIScheduleBlocks
name|getBlocks
parameter_list|(
name|SISchedulerBlockCreatorVariant
name|BlockVariant
parameter_list|)
function_decl|;
name|bool
name|isSUInBlock
parameter_list|(
name|SUnit
modifier|*
name|SU
parameter_list|,
name|unsigned
name|ID
parameter_list|)
function_decl|;
name|private
label|:
comment|// Give a Reserved color to every high latency.
name|void
name|colorHighLatenciesAlone
parameter_list|()
function_decl|;
comment|// Create groups of high latencies with a Reserved color.
name|void
name|colorHighLatenciesGroups
parameter_list|()
function_decl|;
comment|// Compute coloring for topdown and bottom traversals with
comment|// different colors depending on dependencies on Reserved colors.
name|void
name|colorComputeReservedDependencies
parameter_list|()
function_decl|;
comment|// Give color to all non-colored SUs according to Reserved groups dependencies.
name|void
name|colorAccordingToReservedDependencies
parameter_list|()
function_decl|;
comment|// Divides Blocks having no bottom up or top down dependencies on Reserved groups.
comment|// The new colors are computed according to the dependencies on the other blocks
comment|// formed with colorAccordingToReservedDependencies.
name|void
name|colorEndsAccordingToDependencies
parameter_list|()
function_decl|;
comment|// Cut groups into groups with SUs in consecutive order (except for Reserved groups).
name|void
name|colorForceConsecutiveOrderInGroup
parameter_list|()
function_decl|;
comment|// Merge Constant loads that have all their users into another group to the group.
comment|// (TODO: else if all their users depend on the same group, put them there)
name|void
name|colorMergeConstantLoadsNextGroup
parameter_list|()
function_decl|;
comment|// Merge SUs that have all their users into another group to the group
name|void
name|colorMergeIfPossibleNextGroup
parameter_list|()
function_decl|;
comment|// Merge SUs that have all their users into another group to the group,
comment|// but only for Reserved groups.
name|void
name|colorMergeIfPossibleNextGroupOnlyForReserved
parameter_list|()
function_decl|;
comment|// Merge SUs that have all their users into another group to the group,
comment|// but only if the group is no more than a few SUs.
name|void
name|colorMergeIfPossibleSmallGroupsToNextGroup
parameter_list|()
function_decl|;
comment|// Divides Blocks with important size.
comment|// Idea of implementation: attribute new colors depending on topdown and
comment|// bottom up links to other blocks.
name|void
name|cutHugeBlocks
parameter_list|()
function_decl|;
comment|// Put in one group all instructions with no users in this scheduling region
comment|// (we'd want these groups be at the end).
name|void
name|regroupNoUserInstructions
parameter_list|()
function_decl|;
name|void
name|createBlocksForVariant
parameter_list|(
name|SISchedulerBlockCreatorVariant
name|BlockVariant
parameter_list|)
function_decl|;
name|void
name|topologicalSort
parameter_list|()
function_decl|;
name|void
name|scheduleInsideBlocks
parameter_list|()
function_decl|;
name|void
name|fillStats
parameter_list|()
function_decl|;
block|}
empty_stmt|;
enum|enum
name|SISchedulerBlockSchedulerVariant
block|{
name|BlockLatencyRegUsage
block|,
name|BlockRegUsageLatency
block|,
name|BlockRegUsage
block|}
enum|;
name|class
name|SIScheduleBlockScheduler
block|{
name|SIScheduleDAGMI
modifier|*
name|DAG
decl_stmt|;
name|SISchedulerBlockSchedulerVariant
name|Variant
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|Blocks
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|unsigned
operator|>>
name|LiveOutRegsNumUsages
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|LiveRegs
expr_stmt|;
comment|// Num of schedulable unscheduled blocks reading the register.
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|LiveRegsConsumers
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LastPosHighLatencyParentScheduled
expr_stmt|;
name|int
name|LastPosWaitedHighLatency
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|BlocksScheduled
expr_stmt|;
name|unsigned
name|NumBlockScheduled
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|ReadyBlocks
expr_stmt|;
name|unsigned
name|VregCurrentUsage
decl_stmt|;
name|unsigned
name|SregCurrentUsage
decl_stmt|;
comment|// Currently is only approximation.
name|unsigned
name|maxVregUsage
decl_stmt|;
name|unsigned
name|maxSregUsage
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|BlockNumPredsLeft
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|BlockNumSuccsLeft
expr_stmt|;
name|public
label|:
name|SIScheduleBlockScheduler
argument_list|(
argument|SIScheduleDAGMI *DAG
argument_list|,
argument|SISchedulerBlockSchedulerVariant Variant
argument_list|,
argument|SIScheduleBlocks BlocksStruct
argument_list|)
empty_stmt|;
operator|~
name|SIScheduleBlockScheduler
argument_list|()
operator|=
expr|default
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SIScheduleBlock
operator|*
operator|>
name|getBlocks
argument_list|()
block|{
return|return
name|BlocksScheduled
return|;
block|}
name|unsigned
name|getVGPRUsage
parameter_list|()
block|{
return|return
name|maxVregUsage
return|;
block|}
name|unsigned
name|getSGPRUsage
parameter_list|()
block|{
return|return
name|maxSregUsage
return|;
block|}
name|private
label|:
name|struct
name|SIBlockSchedCandidate
range|:
name|SISchedulerCandidate
block|{
comment|// The best Block candidate.
name|SIScheduleBlock
operator|*
name|Block
operator|=
name|nullptr
block|;
name|bool
name|IsHighLatency
block|;
name|int
name|VGPRUsageDiff
block|;
name|unsigned
name|NumSuccessors
block|;
name|unsigned
name|NumHighLatencySuccessors
block|;
name|unsigned
name|LastPosHighLatParentScheduled
block|;
name|unsigned
name|Height
block|;
name|SIBlockSchedCandidate
argument_list|()
operator|=
expr|default
block|;
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
comment|// Copy the status of another candidate without changing policy.
name|void
name|setBest
argument_list|(
argument|SIBlockSchedCandidate&Best
argument_list|)
block|{
name|assert
argument_list|(
name|Best
operator|.
name|Reason
operator|!=
name|NoCand
operator|&&
literal|"uninitialized Sched candidate"
argument_list|)
block|;
name|Block
operator|=
name|Best
operator|.
name|Block
block|;
name|Reason
operator|=
name|Best
operator|.
name|Reason
block|;
name|IsHighLatency
operator|=
name|Best
operator|.
name|IsHighLatency
block|;
name|VGPRUsageDiff
operator|=
name|Best
operator|.
name|VGPRUsageDiff
block|;
name|NumSuccessors
operator|=
name|Best
operator|.
name|NumSuccessors
block|;
name|NumHighLatencySuccessors
operator|=
name|Best
operator|.
name|NumHighLatencySuccessors
block|;
name|LastPosHighLatParentScheduled
operator|=
name|Best
operator|.
name|LastPosHighLatParentScheduled
block|;
name|Height
operator|=
name|Best
operator|.
name|Height
block|;     }
expr|}
block|;
name|bool
name|tryCandidateLatency
argument_list|(
name|SIBlockSchedCandidate
operator|&
name|Cand
argument_list|,
name|SIBlockSchedCandidate
operator|&
name|TryCand
argument_list|)
block|;
name|bool
name|tryCandidateRegUsage
argument_list|(
name|SIBlockSchedCandidate
operator|&
name|Cand
argument_list|,
name|SIBlockSchedCandidate
operator|&
name|TryCand
argument_list|)
block|;
name|SIScheduleBlock
operator|*
name|pickBlock
argument_list|()
block|;
name|void
name|addLiveRegs
argument_list|(
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|Regs
argument_list|)
block|;
name|void
name|decreaseLiveRegs
argument_list|(
name|SIScheduleBlock
operator|*
name|Block
argument_list|,
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|Regs
argument_list|)
block|;
name|void
name|releaseBlockSuccs
argument_list|(
name|SIScheduleBlock
operator|*
name|Parent
argument_list|)
block|;
name|void
name|blockScheduled
argument_list|(
name|SIScheduleBlock
operator|*
name|Block
argument_list|)
block|;
comment|// Check register pressure change
comment|// by scheduling a block with these LiveIn and LiveOut.
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|checkRegUsageImpact
argument_list|(
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|InRegs
argument_list|,
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|OutRegs
argument_list|)
block|;
name|void
name|schedule
argument_list|()
block|; }
decl_stmt|;
struct|struct
name|SIScheduleBlockResult
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|SUs
expr_stmt|;
name|unsigned
name|MaxSGPRUsage
decl_stmt|;
name|unsigned
name|MaxVGPRUsage
decl_stmt|;
block|}
struct|;
name|class
name|SIScheduler
block|{
name|SIScheduleDAGMI
modifier|*
name|DAG
decl_stmt|;
name|SIScheduleBlockCreator
name|BlockCreator
decl_stmt|;
name|public
label|:
name|SIScheduler
argument_list|(
name|SIScheduleDAGMI
operator|*
name|DAG
argument_list|)
operator|:
name|DAG
argument_list|(
name|DAG
argument_list|)
operator|,
name|BlockCreator
argument_list|(
argument|DAG
argument_list|)
block|{}
operator|~
name|SIScheduler
argument_list|()
operator|=
expr|default
expr_stmt|;
name|struct
name|SIScheduleBlockResult
name|scheduleVariant
parameter_list|(
name|SISchedulerBlockCreatorVariant
name|BlockVariant
parameter_list|,
name|SISchedulerBlockSchedulerVariant
name|ScheduleVariant
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|class
name|SIScheduleDAGMI
name|final
range|:
name|public
name|ScheduleDAGMILive
block|{
specifier|const
name|SIInstrInfo
operator|*
name|SITII
block|;
specifier|const
name|SIRegisterInfo
operator|*
name|SITRI
block|;
name|std
operator|::
name|vector
operator|<
name|SUnit
operator|>
name|SUnitsLinksBackup
block|;
comment|// For moveLowLatencies. After all Scheduling variants are tested.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|ScheduledSUnits
block|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|ScheduledSUnitsInv
block|;
name|unsigned
name|VGPRSetID
block|;
name|unsigned
name|SGPRSetID
block|;
name|public
operator|:
name|SIScheduleDAGMI
argument_list|(
name|MachineSchedContext
operator|*
name|C
argument_list|)
block|;
operator|~
name|SIScheduleDAGMI
argument_list|()
name|override
block|;
comment|// Entry point for the schedule.
name|void
name|schedule
argument_list|()
name|override
block|;
comment|// To init Block's RPTracker.
name|void
name|initRPTracker
argument_list|(
argument|RegPressureTracker&RPTracker
argument_list|)
block|{
name|RPTracker
operator|.
name|init
argument_list|(
operator|&
name|MF
argument_list|,
name|RegClassInfo
argument_list|,
name|LIS
argument_list|,
name|BB
argument_list|,
name|RegionBegin
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|;   }
name|MachineBasicBlock
operator|*
name|getBB
argument_list|()
block|{
return|return
name|BB
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|getCurrentTop
argument_list|()
block|{
return|return
name|CurrentTop
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|getCurrentBottom
argument_list|()
block|{
return|return
name|CurrentBottom
return|;
block|}
name|LiveIntervals
operator|*
name|getLIS
argument_list|()
block|{
return|return
name|LIS
return|;
block|}
name|MachineRegisterInfo
operator|*
name|getMRI
argument_list|()
block|{
return|return
operator|&
name|MRI
return|;
block|}
specifier|const
name|TargetRegisterInfo
operator|*
name|getTRI
argument_list|()
block|{
return|return
name|TRI
return|;
block|}
name|ScheduleDAGTopologicalSort
operator|*
name|GetTopo
argument_list|()
block|{
return|return
operator|&
name|Topo
return|;
block|}
name|SUnit
operator|&
name|getEntrySU
argument_list|()
block|{
return|return
name|EntrySU
return|;
block|}
name|SUnit
operator|&
name|getExitSU
argument_list|()
block|{
return|return
name|ExitSU
return|;
block|}
name|void
name|restoreSULinksLeft
argument_list|()
block|;
name|template
operator|<
name|typename
name|_Iterator
operator|>
name|void
name|fillVgprSgprCost
argument_list|(
argument|_Iterator First
argument_list|,
argument|_Iterator End
argument_list|,
argument|unsigned&VgprUsage
argument_list|,
argument|unsigned&SgprUsage
argument_list|)
block|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|getInRegs
argument_list|()
block|{
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|InRegs
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|RegMaskPair
range|:
name|RPTracker
operator|.
name|getPressure
argument_list|()
operator|.
name|LiveInRegs
control|)
block|{
name|InRegs
operator|.
name|insert
argument_list|(
name|RegMaskPair
operator|.
name|RegUnit
argument_list|)
expr_stmt|;
block|}
return|return
name|InRegs
return|;
block|}
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|getOutRegs
argument_list|()
block|{
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|OutRegs
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|RegMaskPair
range|:
name|RPTracker
operator|.
name|getPressure
argument_list|()
operator|.
name|LiveOutRegs
control|)
block|{
name|OutRegs
operator|.
name|insert
argument_list|(
name|RegMaskPair
operator|.
name|RegUnit
argument_list|)
expr_stmt|;
block|}
return|return
name|OutRegs
return|;
block|}
block|;
name|unsigned
name|getVGPRSetID
argument_list|()
specifier|const
block|{
return|return
name|VGPRSetID
return|;
block|}
name|unsigned
name|getSGPRSetID
argument_list|()
specifier|const
block|{
return|return
name|SGPRSetID
return|;
block|}
name|private
operator|:
name|void
name|topologicalSort
argument_list|()
block|;
comment|// After scheduling is done, improve low latency placements.
name|void
name|moveLowLatencies
argument_list|()
block|;
name|public
operator|:
comment|// Some stats for scheduling inside blocks.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|IsLowLatencySU
block|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LowLatencyOffset
block|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|IsHighLatencySU
block|;
comment|// Topological sort
comment|// Maps topological index to the node number.
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|TopDownIndex2SU
block|;
name|std
operator|::
name|vector
operator|<
name|int
operator|>
name|BottomUpIndex2SU
block|; }
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_TARGET_AMDGPU_SIMACHINESCHEDULER_H
end_comment

end_unit

