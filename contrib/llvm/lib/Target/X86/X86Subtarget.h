begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- X86Subtarget.h - Define Subtarget for the X86 ----------*- C++ -*--===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the X86 specific subclass of TargetSubtargetInfo.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_X86_X86SUBTARGET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_X86_X86SUBTARGET_H
end_define

begin_include
include|#
directive|include
file|"X86FrameLowering.h"
end_include

begin_include
include|#
directive|include
file|"X86ISelLowering.h"
end_include

begin_include
include|#
directive|include
file|"X86InstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"X86SelectionDAGInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/GlobalISel/GISelAccessor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallingConv.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCInstrItineraries.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetSubtargetInfo.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_define
define|#
directive|define
name|GET_SUBTARGETINFO_HEADER
end_define

begin_include
include|#
directive|include
file|"X86GenSubtargetInfo.inc"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|GlobalValue
decl_stmt|;
comment|/// The X86 backend supports a number of different styles of PIC.
comment|///
name|namespace
name|PICStyles
block|{
enum|enum
name|Style
block|{
name|StubPIC
block|,
comment|// Used on i386-darwin in pic mode.
name|GOT
block|,
comment|// Used on 32 bit elf on when in pic mode.
name|RIPRel
block|,
comment|// Used on X86-64 when in pic mode.
name|None
comment|// Set when not in pic mode.
block|}
enum|;
block|}
comment|// end namespace PICStyles
name|class
name|X86Subtarget
name|final
range|:
name|public
name|X86GenSubtargetInfo
block|{
name|protected
operator|:
expr|enum
name|X86SSEEnum
block|{
name|NoSSE
block|,
name|SSE1
block|,
name|SSE2
block|,
name|SSE3
block|,
name|SSSE3
block|,
name|SSE41
block|,
name|SSE42
block|,
name|AVX
block|,
name|AVX2
block|,
name|AVX512F
block|}
block|;    enum
name|X863DNowEnum
block|{
name|NoThreeDNow
block|,
name|MMX
block|,
name|ThreeDNow
block|,
name|ThreeDNowA
block|}
block|;    enum
name|X86ProcFamilyEnum
block|{
name|Others
block|,
name|IntelAtom
block|,
name|IntelSLM
block|,
name|IntelGLM
block|}
block|;
comment|/// X86 processor family: Intel Atom, and others
name|X86ProcFamilyEnum
name|X86ProcFamily
block|;
comment|/// Which PIC style to use
name|PICStyles
operator|::
name|Style
name|PICStyle
block|;
specifier|const
name|TargetMachine
operator|&
name|TM
block|;
comment|/// SSE1, SSE2, SSE3, SSSE3, SSE41, SSE42, or none supported.
name|X86SSEEnum
name|X86SSELevel
block|;
comment|/// MMX, 3DNow, 3DNow Athlon, or none supported.
name|X863DNowEnum
name|X863DNowLevel
block|;
comment|/// True if the processor supports X87 instructions.
name|bool
name|HasX87
block|;
comment|/// True if this processor has conditional move instructions
comment|/// (generally pentium pro+).
name|bool
name|HasCMov
block|;
comment|/// True if the processor supports X86-64 instructions.
name|bool
name|HasX86_64
block|;
comment|/// True if the processor supports POPCNT.
name|bool
name|HasPOPCNT
block|;
comment|/// True if the processor supports SSE4A instructions.
name|bool
name|HasSSE4A
block|;
comment|/// Target has AES instructions
name|bool
name|HasAES
block|;
comment|/// Target has FXSAVE/FXRESTOR instructions
name|bool
name|HasFXSR
block|;
comment|/// Target has XSAVE instructions
name|bool
name|HasXSAVE
block|;
comment|/// Target has XSAVEOPT instructions
name|bool
name|HasXSAVEOPT
block|;
comment|/// Target has XSAVEC instructions
name|bool
name|HasXSAVEC
block|;
comment|/// Target has XSAVES instructions
name|bool
name|HasXSAVES
block|;
comment|/// Target has carry-less multiplication
name|bool
name|HasPCLMUL
block|;
comment|/// Target has 3-operand fused multiply-add
name|bool
name|HasFMA
block|;
comment|/// Target has 4-operand fused multiply-add
name|bool
name|HasFMA4
block|;
comment|/// Target has XOP instructions
name|bool
name|HasXOP
block|;
comment|/// Target has TBM instructions.
name|bool
name|HasTBM
block|;
comment|/// Target has LWP instructions
name|bool
name|HasLWP
block|;
comment|/// True if the processor has the MOVBE instruction.
name|bool
name|HasMOVBE
block|;
comment|/// True if the processor has the RDRAND instruction.
name|bool
name|HasRDRAND
block|;
comment|/// Processor has 16-bit floating point conversion instructions.
name|bool
name|HasF16C
block|;
comment|/// Processor has FS/GS base insturctions.
name|bool
name|HasFSGSBase
block|;
comment|/// Processor has LZCNT instruction.
name|bool
name|HasLZCNT
block|;
comment|/// Processor has BMI1 instructions.
name|bool
name|HasBMI
block|;
comment|/// Processor has BMI2 instructions.
name|bool
name|HasBMI2
block|;
comment|/// Processor has VBMI instructions.
name|bool
name|HasVBMI
block|;
comment|/// Processor has Integer Fused Multiply Add
name|bool
name|HasIFMA
block|;
comment|/// Processor has RTM instructions.
name|bool
name|HasRTM
block|;
comment|/// Processor has ADX instructions.
name|bool
name|HasADX
block|;
comment|/// Processor has SHA instructions.
name|bool
name|HasSHA
block|;
comment|/// Processor has PRFCHW instructions.
name|bool
name|HasPRFCHW
block|;
comment|/// Processor has RDSEED instructions.
name|bool
name|HasRDSEED
block|;
comment|/// Processor has LAHF/SAHF instructions.
name|bool
name|HasLAHFSAHF
block|;
comment|/// Processor has MONITORX/MWAITX instructions.
name|bool
name|HasMWAITX
block|;
comment|/// Processor has Cache Line Zero instruction
name|bool
name|HasCLZERO
block|;
comment|/// Processor has Prefetch with intent to Write instruction
name|bool
name|HasPFPREFETCHWT1
block|;
comment|/// True if BT (bit test) of memory instructions are slow.
name|bool
name|IsBTMemSlow
block|;
comment|/// True if SHLD instructions are slow.
name|bool
name|IsSHLDSlow
block|;
comment|/// True if the PMULLD instruction is slow compared to PMULLW/PMULHW and
comment|//  PMULUDQ.
name|bool
name|IsPMULLDSlow
block|;
comment|/// True if unaligned memory accesses of 16-bytes are slow.
name|bool
name|IsUAMem16Slow
block|;
comment|/// True if unaligned memory accesses of 32-bytes are slow.
name|bool
name|IsUAMem32Slow
block|;
comment|/// True if SSE operations can have unaligned memory operands.
comment|/// This may require setting a configuration bit in the processor.
name|bool
name|HasSSEUnalignedMem
block|;
comment|/// True if this processor has the CMPXCHG16B instruction;
comment|/// this is true for most x86-64 chips, but not the first AMD chips.
name|bool
name|HasCmpxchg16b
block|;
comment|/// True if the LEA instruction should be used for adjusting
comment|/// the stack pointer. This is an optimization for Intel Atom processors.
name|bool
name|UseLeaForSP
block|;
comment|/// True if there is no performance penalty to writing only the lower parts
comment|/// of a YMM or ZMM register without clearing the upper part.
name|bool
name|HasFastPartialYMMorZMMWrite
block|;
comment|/// True if hardware SQRTSS instruction is at least as fast (latency) as
comment|/// RSQRTSS followed by a Newton-Raphson iteration.
name|bool
name|HasFastScalarFSQRT
block|;
comment|/// True if hardware SQRTPS/VSQRTPS instructions are at least as fast
comment|/// (throughput) as RSQRTPS/VRSQRTPS followed by a Newton-Raphson iteration.
name|bool
name|HasFastVectorFSQRT
block|;
comment|/// True if 8-bit divisions are significantly faster than
comment|/// 32-bit divisions and should be used when possible.
name|bool
name|HasSlowDivide32
block|;
comment|/// True if 32-bit divides are significantly faster than
comment|/// 64-bit divisions and should be used when possible.
name|bool
name|HasSlowDivide64
block|;
comment|/// True if LZCNT instruction is fast.
name|bool
name|HasFastLZCNT
block|;
comment|/// True if SHLD based rotate is fast.
name|bool
name|HasFastSHLDRotate
block|;
comment|/// True if the processor has enhanced REP MOVSB/STOSB.
name|bool
name|HasERMSB
block|;
comment|/// True if the short functions should be padded to prevent
comment|/// a stall when returning too early.
name|bool
name|PadShortFunctions
block|;
comment|/// True if the Calls with memory reference should be converted
comment|/// to a register-based indirect call.
name|bool
name|CallRegIndirect
block|;
comment|/// True if the LEA instruction inputs have to be ready at address generation
comment|/// (AG) time.
name|bool
name|LEAUsesAG
block|;
comment|/// True if the LEA instruction with certain arguments is slow
name|bool
name|SlowLEA
block|;
comment|/// True if the LEA instruction has all three source operands: base, index,
comment|/// and offset or if the LEA instruction uses base and index registers where
comment|/// the base is EBP, RBP,or R13
name|bool
name|Slow3OpsLEA
block|;
comment|/// True if INC and DEC instructions are slow when writing to flags
name|bool
name|SlowIncDec
block|;
comment|/// Processor has AVX-512 PreFetch Instructions
name|bool
name|HasPFI
block|;
comment|/// Processor has AVX-512 Exponential and Reciprocal Instructions
name|bool
name|HasERI
block|;
comment|/// Processor has AVX-512 Conflict Detection Instructions
name|bool
name|HasCDI
block|;
comment|/// Processor has AVX-512 population count Instructions
name|bool
name|HasVPOPCNTDQ
block|;
comment|/// Processor has AVX-512 Doubleword and Quadword instructions
name|bool
name|HasDQI
block|;
comment|/// Processor has AVX-512 Byte and Word instructions
name|bool
name|HasBWI
block|;
comment|/// Processor has AVX-512 Vector Length eXtenstions
name|bool
name|HasVLX
block|;
comment|/// Processor has PKU extenstions
name|bool
name|HasPKU
block|;
comment|/// Processor supports MPX - Memory Protection Extensions
name|bool
name|HasMPX
block|;
comment|/// Processor has Software Guard Extensions
name|bool
name|HasSGX
block|;
comment|/// Processor supports Flush Cache Line instruction
name|bool
name|HasCLFLUSHOPT
block|;
comment|/// Processor supports Cache Line Write Back instruction
name|bool
name|HasCLWB
block|;
comment|/// Use software floating point for code generation.
name|bool
name|UseSoftFloat
block|;
comment|/// The minimum alignment known to hold of the stack frame on
comment|/// entry to the function and which must be maintained by every function.
name|unsigned
name|stackAlignment
block|;
comment|/// Max. memset / memcpy size that is turned into rep/movs, rep/stos ops.
comment|///
name|unsigned
name|MaxInlineSizeThreshold
block|;
comment|/// What processor and OS we're targeting.
name|Triple
name|TargetTriple
block|;
comment|/// Instruction itineraries for scheduling
name|InstrItineraryData
name|InstrItins
block|;
comment|/// Gather the accessor points to GlobalISel-related APIs.
comment|/// This is used to avoid ifndefs spreading around while GISel is
comment|/// an optional library.
name|std
operator|::
name|unique_ptr
operator|<
name|GISelAccessor
operator|>
name|GISel
block|;
name|private
operator|:
comment|/// Override the stack alignment.
name|unsigned
name|StackAlignOverride
block|;
comment|/// True if compiling for 64-bit, false for 16-bit or 32-bit.
name|bool
name|In64BitMode
block|;
comment|/// True if compiling for 32-bit, false for 16-bit or 64-bit.
name|bool
name|In32BitMode
block|;
comment|/// True if compiling for 16-bit, false for 32-bit or 64-bit.
name|bool
name|In16BitMode
block|;
name|X86SelectionDAGInfo
name|TSInfo
block|;
comment|// Ordering here is important. X86InstrInfo initializes X86RegisterInfo which
comment|// X86TargetLowering needs.
name|X86InstrInfo
name|InstrInfo
block|;
name|X86TargetLowering
name|TLInfo
block|;
name|X86FrameLowering
name|FrameLowering
block|;
name|public
operator|:
comment|/// This constructor initializes the data members to match that
comment|/// of the specified triple.
comment|///
name|X86Subtarget
argument_list|(
argument|const Triple&TT
argument_list|,
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|,
argument|const X86TargetMachine&TM
argument_list|,
argument|unsigned StackAlignOverride
argument_list|)
block|;
comment|/// This object will take onwership of \p GISelAccessor.
name|void
name|setGISelAccessor
argument_list|(
argument|GISelAccessor&GISel
argument_list|)
block|{
name|this
operator|->
name|GISel
operator|.
name|reset
argument_list|(
operator|&
name|GISel
argument_list|)
block|; }
specifier|const
name|X86TargetLowering
operator|*
name|getTargetLowering
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|TLInfo
return|;
block|}
specifier|const
name|X86InstrInfo
operator|*
name|getInstrInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrInfo
return|;
block|}
specifier|const
name|X86FrameLowering
operator|*
name|getFrameLowering
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|FrameLowering
return|;
block|}
specifier|const
name|X86SelectionDAGInfo
operator|*
name|getSelectionDAGInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|TSInfo
return|;
block|}
specifier|const
name|X86RegisterInfo
operator|*
name|getRegisterInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|getInstrInfo
argument_list|()
operator|->
name|getRegisterInfo
argument_list|()
return|;
block|}
comment|/// Returns the minimum alignment known to hold of the
comment|/// stack frame on entry to the function and which must be maintained by every
comment|/// function for this subtarget.
name|unsigned
name|getStackAlignment
argument_list|()
specifier|const
block|{
return|return
name|stackAlignment
return|;
block|}
comment|/// Returns the maximum memset / memcpy size
comment|/// that still makes it profitable to inline the call.
name|unsigned
name|getMaxInlineSizeThreshold
argument_list|()
specifier|const
block|{
return|return
name|MaxInlineSizeThreshold
return|;
block|}
comment|/// ParseSubtargetFeatures - Parses features string setting specified
comment|/// subtarget options.  Definition of function is auto generated by tblgen.
name|void
name|ParseSubtargetFeatures
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
comment|/// Methods used by Global ISel
specifier|const
name|CallLowering
operator|*
name|getCallLowering
argument_list|()
specifier|const
name|override
block|;
specifier|const
name|InstructionSelector
operator|*
name|getInstructionSelector
argument_list|()
specifier|const
name|override
block|;
specifier|const
name|LegalizerInfo
operator|*
name|getLegalizerInfo
argument_list|()
specifier|const
name|override
block|;
specifier|const
name|RegisterBankInfo
operator|*
name|getRegBankInfo
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
comment|/// Initialize the full set of dependencies so we can use an initializer
comment|/// list for X86Subtarget.
name|X86Subtarget
operator|&
name|initializeSubtargetDependencies
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
name|void
name|initializeEnvironment
argument_list|()
block|;
name|void
name|initSubtargetFeatures
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
name|public
operator|:
comment|/// Is this x86_64? (disregarding specific ABI / programming model)
name|bool
name|is64Bit
argument_list|()
specifier|const
block|{
return|return
name|In64BitMode
return|;
block|}
name|bool
name|is32Bit
argument_list|()
specifier|const
block|{
return|return
name|In32BitMode
return|;
block|}
name|bool
name|is16Bit
argument_list|()
specifier|const
block|{
return|return
name|In16BitMode
return|;
block|}
comment|/// Is this x86_64 with the ILP32 programming model (x32 ABI)?
name|bool
name|isTarget64BitILP32
argument_list|()
specifier|const
block|{
return|return
name|In64BitMode
operator|&&
operator|(
name|TargetTriple
operator|.
name|getEnvironment
argument_list|()
operator|==
name|Triple
operator|::
name|GNUX32
operator|||
name|TargetTriple
operator|.
name|isOSNaCl
argument_list|()
operator|)
return|;
block|}
comment|/// Is this x86_64 with the LP64 programming model (standard AMD64, no x32)?
name|bool
name|isTarget64BitLP64
argument_list|()
specifier|const
block|{
return|return
name|In64BitMode
operator|&&
operator|(
name|TargetTriple
operator|.
name|getEnvironment
argument_list|()
operator|!=
name|Triple
operator|::
name|GNUX32
operator|&&
operator|!
name|TargetTriple
operator|.
name|isOSNaCl
argument_list|()
operator|)
return|;
block|}
name|PICStyles
operator|::
name|Style
name|getPICStyle
argument_list|()
specifier|const
block|{
return|return
name|PICStyle
return|;
block|}
name|void
name|setPICStyle
argument_list|(
argument|PICStyles::Style Style
argument_list|)
block|{
name|PICStyle
operator|=
name|Style
block|; }
name|bool
name|hasX87
argument_list|()
specifier|const
block|{
return|return
name|HasX87
return|;
block|}
name|bool
name|hasCMov
argument_list|()
specifier|const
block|{
return|return
name|HasCMov
return|;
block|}
name|bool
name|hasSSE1
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSE1
return|;
block|}
name|bool
name|hasSSE2
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSE2
return|;
block|}
name|bool
name|hasSSE3
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSE3
return|;
block|}
name|bool
name|hasSSSE3
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSSE3
return|;
block|}
name|bool
name|hasSSE41
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSE41
return|;
block|}
name|bool
name|hasSSE42
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|SSE42
return|;
block|}
name|bool
name|hasAVX
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|AVX
return|;
block|}
name|bool
name|hasAVX2
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|AVX2
return|;
block|}
name|bool
name|hasAVX512
argument_list|()
specifier|const
block|{
return|return
name|X86SSELevel
operator|>=
name|AVX512F
return|;
block|}
name|bool
name|hasFp256
argument_list|()
specifier|const
block|{
return|return
name|hasAVX
argument_list|()
return|;
block|}
name|bool
name|hasInt256
argument_list|()
specifier|const
block|{
return|return
name|hasAVX2
argument_list|()
return|;
block|}
name|bool
name|hasSSE4A
argument_list|()
specifier|const
block|{
return|return
name|HasSSE4A
return|;
block|}
name|bool
name|hasMMX
argument_list|()
specifier|const
block|{
return|return
name|X863DNowLevel
operator|>=
name|MMX
return|;
block|}
name|bool
name|has3DNow
argument_list|()
specifier|const
block|{
return|return
name|X863DNowLevel
operator|>=
name|ThreeDNow
return|;
block|}
name|bool
name|has3DNowA
argument_list|()
specifier|const
block|{
return|return
name|X863DNowLevel
operator|>=
name|ThreeDNowA
return|;
block|}
name|bool
name|hasPOPCNT
argument_list|()
specifier|const
block|{
return|return
name|HasPOPCNT
return|;
block|}
name|bool
name|hasAES
argument_list|()
specifier|const
block|{
return|return
name|HasAES
return|;
block|}
name|bool
name|hasFXSR
argument_list|()
specifier|const
block|{
return|return
name|HasFXSR
return|;
block|}
name|bool
name|hasXSAVE
argument_list|()
specifier|const
block|{
return|return
name|HasXSAVE
return|;
block|}
name|bool
name|hasXSAVEOPT
argument_list|()
specifier|const
block|{
return|return
name|HasXSAVEOPT
return|;
block|}
name|bool
name|hasXSAVEC
argument_list|()
specifier|const
block|{
return|return
name|HasXSAVEC
return|;
block|}
name|bool
name|hasXSAVES
argument_list|()
specifier|const
block|{
return|return
name|HasXSAVES
return|;
block|}
name|bool
name|hasPCLMUL
argument_list|()
specifier|const
block|{
return|return
name|HasPCLMUL
return|;
block|}
comment|// Prefer FMA4 to FMA - its better for commutation/memory folding and
comment|// has equal or better performance on all supported targets.
name|bool
name|hasFMA
argument_list|()
specifier|const
block|{
return|return
operator|(
name|HasFMA
operator|||
name|hasAVX512
argument_list|()
operator|)
operator|&&
operator|!
name|HasFMA4
return|;
block|}
name|bool
name|hasFMA4
argument_list|()
specifier|const
block|{
return|return
name|HasFMA4
return|;
block|}
name|bool
name|hasAnyFMA
argument_list|()
specifier|const
block|{
return|return
name|hasFMA
argument_list|()
operator|||
name|hasFMA4
argument_list|()
return|;
block|}
name|bool
name|hasXOP
argument_list|()
specifier|const
block|{
return|return
name|HasXOP
return|;
block|}
name|bool
name|hasTBM
argument_list|()
specifier|const
block|{
return|return
name|HasTBM
return|;
block|}
name|bool
name|hasLWP
argument_list|()
specifier|const
block|{
return|return
name|HasLWP
return|;
block|}
name|bool
name|hasMOVBE
argument_list|()
specifier|const
block|{
return|return
name|HasMOVBE
return|;
block|}
name|bool
name|hasRDRAND
argument_list|()
specifier|const
block|{
return|return
name|HasRDRAND
return|;
block|}
name|bool
name|hasF16C
argument_list|()
specifier|const
block|{
return|return
name|HasF16C
return|;
block|}
name|bool
name|hasFSGSBase
argument_list|()
specifier|const
block|{
return|return
name|HasFSGSBase
return|;
block|}
name|bool
name|hasLZCNT
argument_list|()
specifier|const
block|{
return|return
name|HasLZCNT
return|;
block|}
name|bool
name|hasBMI
argument_list|()
specifier|const
block|{
return|return
name|HasBMI
return|;
block|}
name|bool
name|hasBMI2
argument_list|()
specifier|const
block|{
return|return
name|HasBMI2
return|;
block|}
name|bool
name|hasVBMI
argument_list|()
specifier|const
block|{
return|return
name|HasVBMI
return|;
block|}
name|bool
name|hasIFMA
argument_list|()
specifier|const
block|{
return|return
name|HasIFMA
return|;
block|}
name|bool
name|hasRTM
argument_list|()
specifier|const
block|{
return|return
name|HasRTM
return|;
block|}
name|bool
name|hasADX
argument_list|()
specifier|const
block|{
return|return
name|HasADX
return|;
block|}
name|bool
name|hasSHA
argument_list|()
specifier|const
block|{
return|return
name|HasSHA
return|;
block|}
name|bool
name|hasPRFCHW
argument_list|()
specifier|const
block|{
return|return
name|HasPRFCHW
return|;
block|}
name|bool
name|hasRDSEED
argument_list|()
specifier|const
block|{
return|return
name|HasRDSEED
return|;
block|}
name|bool
name|hasLAHFSAHF
argument_list|()
specifier|const
block|{
return|return
name|HasLAHFSAHF
return|;
block|}
name|bool
name|hasMWAITX
argument_list|()
specifier|const
block|{
return|return
name|HasMWAITX
return|;
block|}
name|bool
name|hasCLZERO
argument_list|()
specifier|const
block|{
return|return
name|HasCLZERO
return|;
block|}
name|bool
name|isBTMemSlow
argument_list|()
specifier|const
block|{
return|return
name|IsBTMemSlow
return|;
block|}
name|bool
name|isSHLDSlow
argument_list|()
specifier|const
block|{
return|return
name|IsSHLDSlow
return|;
block|}
name|bool
name|isPMULLDSlow
argument_list|()
specifier|const
block|{
return|return
name|IsPMULLDSlow
return|;
block|}
name|bool
name|isUnalignedMem16Slow
argument_list|()
specifier|const
block|{
return|return
name|IsUAMem16Slow
return|;
block|}
name|bool
name|isUnalignedMem32Slow
argument_list|()
specifier|const
block|{
return|return
name|IsUAMem32Slow
return|;
block|}
name|bool
name|hasSSEUnalignedMem
argument_list|()
specifier|const
block|{
return|return
name|HasSSEUnalignedMem
return|;
block|}
name|bool
name|hasCmpxchg16b
argument_list|()
specifier|const
block|{
return|return
name|HasCmpxchg16b
return|;
block|}
name|bool
name|useLeaForSP
argument_list|()
specifier|const
block|{
return|return
name|UseLeaForSP
return|;
block|}
name|bool
name|hasFastPartialYMMorZMMWrite
argument_list|()
specifier|const
block|{
return|return
name|HasFastPartialYMMorZMMWrite
return|;
block|}
name|bool
name|hasFastScalarFSQRT
argument_list|()
specifier|const
block|{
return|return
name|HasFastScalarFSQRT
return|;
block|}
name|bool
name|hasFastVectorFSQRT
argument_list|()
specifier|const
block|{
return|return
name|HasFastVectorFSQRT
return|;
block|}
name|bool
name|hasFastLZCNT
argument_list|()
specifier|const
block|{
return|return
name|HasFastLZCNT
return|;
block|}
name|bool
name|hasFastSHLDRotate
argument_list|()
specifier|const
block|{
return|return
name|HasFastSHLDRotate
return|;
block|}
name|bool
name|hasERMSB
argument_list|()
specifier|const
block|{
return|return
name|HasERMSB
return|;
block|}
name|bool
name|hasSlowDivide32
argument_list|()
specifier|const
block|{
return|return
name|HasSlowDivide32
return|;
block|}
name|bool
name|hasSlowDivide64
argument_list|()
specifier|const
block|{
return|return
name|HasSlowDivide64
return|;
block|}
name|bool
name|padShortFunctions
argument_list|()
specifier|const
block|{
return|return
name|PadShortFunctions
return|;
block|}
name|bool
name|callRegIndirect
argument_list|()
specifier|const
block|{
return|return
name|CallRegIndirect
return|;
block|}
name|bool
name|LEAusesAG
argument_list|()
specifier|const
block|{
return|return
name|LEAUsesAG
return|;
block|}
name|bool
name|slowLEA
argument_list|()
specifier|const
block|{
return|return
name|SlowLEA
return|;
block|}
name|bool
name|slow3OpsLEA
argument_list|()
specifier|const
block|{
return|return
name|Slow3OpsLEA
return|;
block|}
name|bool
name|slowIncDec
argument_list|()
specifier|const
block|{
return|return
name|SlowIncDec
return|;
block|}
name|bool
name|hasCDI
argument_list|()
specifier|const
block|{
return|return
name|HasCDI
return|;
block|}
name|bool
name|hasVPOPCNTDQ
argument_list|()
specifier|const
block|{
return|return
name|HasVPOPCNTDQ
return|;
block|}
name|bool
name|hasPFI
argument_list|()
specifier|const
block|{
return|return
name|HasPFI
return|;
block|}
name|bool
name|hasERI
argument_list|()
specifier|const
block|{
return|return
name|HasERI
return|;
block|}
name|bool
name|hasDQI
argument_list|()
specifier|const
block|{
return|return
name|HasDQI
return|;
block|}
name|bool
name|hasBWI
argument_list|()
specifier|const
block|{
return|return
name|HasBWI
return|;
block|}
name|bool
name|hasVLX
argument_list|()
specifier|const
block|{
return|return
name|HasVLX
return|;
block|}
name|bool
name|hasPKU
argument_list|()
specifier|const
block|{
return|return
name|HasPKU
return|;
block|}
name|bool
name|hasMPX
argument_list|()
specifier|const
block|{
return|return
name|HasMPX
return|;
block|}
name|bool
name|hasCLFLUSHOPT
argument_list|()
specifier|const
block|{
return|return
name|HasCLFLUSHOPT
return|;
block|}
name|bool
name|isXRaySupported
argument_list|()
specifier|const
name|override
block|{
return|return
name|is64Bit
argument_list|()
return|;
block|}
name|bool
name|isAtom
argument_list|()
specifier|const
block|{
return|return
name|X86ProcFamily
operator|==
name|IntelAtom
return|;
block|}
name|bool
name|isSLM
argument_list|()
specifier|const
block|{
return|return
name|X86ProcFamily
operator|==
name|IntelSLM
return|;
block|}
name|bool
name|useSoftFloat
argument_list|()
specifier|const
block|{
return|return
name|UseSoftFloat
return|;
block|}
comment|/// Use mfence if we have SSE2 or we're on x86-64 (even if we asked for
comment|/// no-sse2). There isn't any reason to disable it if the target processor
comment|/// supports it.
name|bool
name|hasMFence
argument_list|()
specifier|const
block|{
return|return
name|hasSSE2
argument_list|()
operator|||
name|is64Bit
argument_list|()
return|;
block|}
specifier|const
name|Triple
operator|&
name|getTargetTriple
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
return|;
block|}
name|bool
name|isTargetDarwin
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSDarwin
argument_list|()
return|;
block|}
name|bool
name|isTargetFreeBSD
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSFreeBSD
argument_list|()
return|;
block|}
name|bool
name|isTargetDragonFly
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSDragonFly
argument_list|()
return|;
block|}
name|bool
name|isTargetSolaris
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSSolaris
argument_list|()
return|;
block|}
name|bool
name|isTargetPS4
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isPS4CPU
argument_list|()
return|;
block|}
name|bool
name|isTargetELF
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSBinFormatELF
argument_list|()
return|;
block|}
name|bool
name|isTargetCOFF
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSBinFormatCOFF
argument_list|()
return|;
block|}
name|bool
name|isTargetMachO
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSBinFormatMachO
argument_list|()
return|;
block|}
name|bool
name|isTargetLinux
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSLinux
argument_list|()
return|;
block|}
name|bool
name|isTargetKFreeBSD
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSKFreeBSD
argument_list|()
return|;
block|}
name|bool
name|isTargetGlibc
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSGlibc
argument_list|()
return|;
block|}
name|bool
name|isTargetAndroid
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isAndroid
argument_list|()
return|;
block|}
name|bool
name|isTargetNaCl
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSNaCl
argument_list|()
return|;
block|}
name|bool
name|isTargetNaCl32
argument_list|()
specifier|const
block|{
return|return
name|isTargetNaCl
argument_list|()
operator|&&
operator|!
name|is64Bit
argument_list|()
return|;
block|}
name|bool
name|isTargetNaCl64
argument_list|()
specifier|const
block|{
return|return
name|isTargetNaCl
argument_list|()
operator|&&
name|is64Bit
argument_list|()
return|;
block|}
name|bool
name|isTargetMCU
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSIAMCU
argument_list|()
return|;
block|}
name|bool
name|isTargetFuchsia
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSFuchsia
argument_list|()
return|;
block|}
name|bool
name|isTargetWindowsMSVC
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isWindowsMSVCEnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetKnownWindowsMSVC
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isKnownWindowsMSVCEnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetWindowsCoreCLR
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isWindowsCoreCLREnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetWindowsCygwin
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isWindowsCygwinEnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetWindowsGNU
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isWindowsGNUEnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetWindowsItanium
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isWindowsItaniumEnvironment
argument_list|()
return|;
block|}
name|bool
name|isTargetCygMing
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSCygMing
argument_list|()
return|;
block|}
name|bool
name|isOSWindows
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSWindows
argument_list|()
return|;
block|}
name|bool
name|isTargetWin64
argument_list|()
specifier|const
block|{
return|return
name|In64BitMode
operator|&&
name|TargetTriple
operator|.
name|isOSWindows
argument_list|()
return|;
block|}
name|bool
name|isTargetWin32
argument_list|()
specifier|const
block|{
return|return
operator|!
name|In64BitMode
operator|&&
operator|(
name|isTargetCygMing
argument_list|()
operator|||
name|isTargetKnownWindowsMSVC
argument_list|()
operator|)
return|;
block|}
name|bool
name|isPICStyleGOT
argument_list|()
specifier|const
block|{
return|return
name|PICStyle
operator|==
name|PICStyles
operator|::
name|GOT
return|;
block|}
name|bool
name|isPICStyleRIPRel
argument_list|()
specifier|const
block|{
return|return
name|PICStyle
operator|==
name|PICStyles
operator|::
name|RIPRel
return|;
block|}
name|bool
name|isPICStyleStubPIC
argument_list|()
specifier|const
block|{
return|return
name|PICStyle
operator|==
name|PICStyles
operator|::
name|StubPIC
return|;
block|}
name|bool
name|isPositionIndependent
argument_list|()
specifier|const
block|{
return|return
name|TM
operator|.
name|isPositionIndependent
argument_list|()
return|;
block|}
name|bool
name|isCallingConvWin64
argument_list|(
argument|CallingConv::ID CC
argument_list|)
specifier|const
block|{
switch|switch
condition|(
name|CC
condition|)
block|{
comment|// On Win64, all these conventions just use the default convention.
case|case
name|CallingConv
operator|::
name|C
case|:
case|case
name|CallingConv
operator|::
name|Fast
case|:
case|case
name|CallingConv
operator|::
name|X86_FastCall
case|:
case|case
name|CallingConv
operator|::
name|X86_StdCall
case|:
case|case
name|CallingConv
operator|::
name|X86_ThisCall
case|:
case|case
name|CallingConv
operator|::
name|X86_VectorCall
case|:
case|case
name|CallingConv
operator|::
name|Intel_OCL_BI
case|:
return|return
name|isTargetWin64
argument_list|()
return|;
comment|// This convention allows using the Win64 convention on other targets.
case|case
name|CallingConv
operator|::
name|X86_64_Win64
case|:
return|return
name|true
return|;
comment|// This convention allows using the SysV convention on Windows targets.
case|case
name|CallingConv
operator|::
name|X86_64_SysV
case|:
return|return
name|false
return|;
comment|// Otherwise, who knows what this is.
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Classify a global variable reference for the current subtarget according
comment|/// to how we should reference it in a non-pcrel context.
name|unsigned
name|char
name|classifyLocalReference
argument_list|(
argument|const GlobalValue *GV
argument_list|)
specifier|const
block|;
name|unsigned
name|char
name|classifyGlobalReference
argument_list|(
argument|const GlobalValue *GV
argument_list|,
argument|const Module&M
argument_list|)
specifier|const
block|;
name|unsigned
name|char
name|classifyGlobalReference
argument_list|(
argument|const GlobalValue *GV
argument_list|)
specifier|const
block|;
comment|/// Classify a global function reference for the current subtarget.
name|unsigned
name|char
name|classifyGlobalFunctionReference
argument_list|(
argument|const GlobalValue *GV
argument_list|,
argument|const Module&M
argument_list|)
specifier|const
block|;
name|unsigned
name|char
name|classifyGlobalFunctionReference
argument_list|(
argument|const GlobalValue *GV
argument_list|)
specifier|const
block|;
comment|/// Classify a blockaddress reference for the current subtarget according to
comment|/// how we should reference it in a non-pcrel context.
name|unsigned
name|char
name|classifyBlockAddressReference
argument_list|()
specifier|const
block|;
comment|/// Return true if the subtarget allows calls to immediate address.
name|bool
name|isLegalToCallImmediateAddr
argument_list|()
specifier|const
block|;
comment|/// This function returns the name of a function which has an interface
comment|/// like the non-standard bzero function, if such a function exists on
comment|/// the current subtarget and it is considered prefereable over
comment|/// memset with zero passed as the second argument. Otherwise it
comment|/// returns null.
specifier|const
name|char
operator|*
name|getBZeroEntry
argument_list|()
specifier|const
block|;
comment|/// This function returns true if the target has sincos() routine in its
comment|/// compiler runtime or math libraries.
name|bool
name|hasSinCos
argument_list|()
specifier|const
block|;
comment|/// Enable the MachineScheduler pass for all X86 subtargets.
name|bool
name|enableMachineScheduler
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
comment|// TODO: Update the regression tests and return true.
name|bool
name|supportPrintSchedInfo
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|enableEarlyIfConversion
argument_list|()
specifier|const
name|override
block|;
comment|/// Return the instruction itineraries based on the subtarget selection.
specifier|const
name|InstrItineraryData
operator|*
name|getInstrItineraryData
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrItins
return|;
block|}
name|AntiDepBreakMode
name|getAntiDepBreakMode
argument_list|()
specifier|const
name|override
block|{
return|return
name|TargetSubtargetInfo
operator|::
name|ANTIDEP_CRITICAL
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_TARGET_X86_X86SUBTARGET_H
end_comment

end_unit

