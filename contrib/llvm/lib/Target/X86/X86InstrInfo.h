begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- X86InstrInfo.h - X86 Instruction Information ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the X86 implementation of the TargetInstrInfo class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_X86_X86INSTRINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_X86_X86INSTRINFO_H
end_define

begin_include
include|#
directive|include
file|"MCTargetDesc/X86BaseInfo.h"
end_include

begin_include
include|#
directive|include
file|"X86InstrFMA3Info.h"
end_include

begin_include
include|#
directive|include
file|"X86RegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetInstrInfo.h"
end_include

begin_define
define|#
directive|define
name|GET_INSTRINFO_HEADER
end_define

begin_include
include|#
directive|include
file|"X86GenInstrInfo.inc"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MachineInstrBuilder
decl_stmt|;
name|class
name|X86RegisterInfo
decl_stmt|;
name|class
name|X86Subtarget
decl_stmt|;
name|namespace
name|X86
block|{
comment|// X86 specific condition code. These correspond to X86_*_COND in
comment|// X86InstrInfo.td. They must be kept in synch.
enum|enum
name|CondCode
block|{
name|COND_A
init|=
literal|0
block|,
name|COND_AE
init|=
literal|1
block|,
name|COND_B
init|=
literal|2
block|,
name|COND_BE
init|=
literal|3
block|,
name|COND_E
init|=
literal|4
block|,
name|COND_G
init|=
literal|5
block|,
name|COND_GE
init|=
literal|6
block|,
name|COND_L
init|=
literal|7
block|,
name|COND_LE
init|=
literal|8
block|,
name|COND_NE
init|=
literal|9
block|,
name|COND_NO
init|=
literal|10
block|,
name|COND_NP
init|=
literal|11
block|,
name|COND_NS
init|=
literal|12
block|,
name|COND_O
init|=
literal|13
block|,
name|COND_P
init|=
literal|14
block|,
name|COND_S
init|=
literal|15
block|,
name|LAST_VALID_COND
init|=
name|COND_S
block|,
comment|// Artificial condition codes. These are used by AnalyzeBranch
comment|// to indicate a block terminated with two conditional branches that together
comment|// form a compound condition. They occur in code using FCMP_OEQ or FCMP_UNE,
comment|// which can't be represented on x86 with a single condition. These
comment|// are never used in MachineInstrs and are inverses of one another.
name|COND_NE_OR_P
block|,
name|COND_E_AND_NP
block|,
name|COND_INVALID
block|}
enum|;
comment|// Turn condition code into conditional branch opcode.
name|unsigned
name|GetCondBranchFromCond
parameter_list|(
name|CondCode
name|CC
parameter_list|)
function_decl|;
comment|/// \brief Return a pair of condition code for the given predicate and whether
comment|/// the instruction operands should be swaped to match the condition code.
name|std
operator|::
name|pair
operator|<
name|CondCode
operator|,
name|bool
operator|>
name|getX86ConditionCode
argument_list|(
argument|CmpInst::Predicate Predicate
argument_list|)
expr_stmt|;
comment|/// \brief Return a set opcode for the given condition and whether it has
comment|/// a memory operand.
name|unsigned
name|getSETFromCond
parameter_list|(
name|CondCode
name|CC
parameter_list|,
name|bool
name|HasMemoryOperand
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Return a cmov opcode for the given condition, register size in
comment|/// bytes, and operand type.
name|unsigned
name|getCMovFromCond
parameter_list|(
name|CondCode
name|CC
parameter_list|,
name|unsigned
name|RegBytes
parameter_list|,
name|bool
name|HasMemoryOperand
init|=
name|false
parameter_list|)
function_decl|;
comment|// Turn CMov opcode into condition code.
name|CondCode
name|getCondFromCMovOpc
parameter_list|(
name|unsigned
name|Opc
parameter_list|)
function_decl|;
comment|/// GetOppositeBranchCondition - Return the inverse of the specified cond,
comment|/// e.g. turning COND_E to COND_NE.
name|CondCode
name|GetOppositeBranchCondition
parameter_list|(
name|CondCode
name|CC
parameter_list|)
function_decl|;
block|}
comment|// end namespace X86;
comment|/// isGlobalStubReference - Return true if the specified TargetFlag operand is
comment|/// a reference to a stub for a global, not the global itself.
specifier|inline
specifier|static
name|bool
name|isGlobalStubReference
parameter_list|(
name|unsigned
name|char
name|TargetFlag
parameter_list|)
block|{
switch|switch
condition|(
name|TargetFlag
condition|)
block|{
case|case
name|X86II
operator|::
name|MO_DLLIMPORT
case|:
comment|// dllimport stub.
case|case
name|X86II
operator|::
name|MO_GOTPCREL
case|:
comment|// rip-relative GOT reference.
case|case
name|X86II
operator|::
name|MO_GOT
case|:
comment|// normal GOT reference.
case|case
name|X86II
operator|::
name|MO_DARWIN_NONLAZY_PIC_BASE
case|:
comment|// Normal $non_lazy_ptr ref.
case|case
name|X86II
operator|::
name|MO_DARWIN_NONLAZY
case|:
comment|// Normal $non_lazy_ptr ref.
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// isGlobalRelativeToPICBase - Return true if the specified global value
comment|/// reference is relative to a 32-bit PIC base (X86ISD::GlobalBaseReg).  If this
comment|/// is true, the addressing mode has the PIC base register added in (e.g. EBX).
specifier|inline
specifier|static
name|bool
name|isGlobalRelativeToPICBase
parameter_list|(
name|unsigned
name|char
name|TargetFlag
parameter_list|)
block|{
switch|switch
condition|(
name|TargetFlag
condition|)
block|{
case|case
name|X86II
operator|::
name|MO_GOTOFF
case|:
comment|// isPICStyleGOT: local global.
case|case
name|X86II
operator|::
name|MO_GOT
case|:
comment|// isPICStyleGOT: other global.
case|case
name|X86II
operator|::
name|MO_PIC_BASE_OFFSET
case|:
comment|// Darwin local global.
case|case
name|X86II
operator|::
name|MO_DARWIN_NONLAZY_PIC_BASE
case|:
comment|// Darwin/32 external global.
case|case
name|X86II
operator|::
name|MO_TLVP
case|:
comment|// ??? Pretty sure..
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
specifier|inline
specifier|static
name|bool
name|isScale
parameter_list|(
specifier|const
name|MachineOperand
modifier|&
name|MO
parameter_list|)
block|{
return|return
name|MO
operator|.
name|isImm
argument_list|()
operator|&&
operator|(
name|MO
operator|.
name|getImm
argument_list|()
operator|==
literal|1
operator|||
name|MO
operator|.
name|getImm
argument_list|()
operator|==
literal|2
operator|||
name|MO
operator|.
name|getImm
argument_list|()
operator|==
literal|4
operator|||
name|MO
operator|.
name|getImm
argument_list|()
operator|==
literal|8
operator|)
return|;
block|}
specifier|inline
specifier|static
name|bool
name|isLeaMem
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Op
parameter_list|)
block|{
if|if
condition|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
argument_list|)
operator|.
name|isFI
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|Op
operator|+
name|X86
operator|::
name|AddrSegmentReg
operator|<=
name|MI
operator|.
name|getNumOperands
argument_list|()
operator|&&
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrBaseReg
argument_list|)
operator|.
name|isReg
argument_list|()
operator|&&
name|isScale
argument_list|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrScaleAmt
argument_list|)
argument_list|)
operator|&&
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrIndexReg
argument_list|)
operator|.
name|isReg
argument_list|()
operator|&&
operator|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrDisp
argument_list|)
operator|.
name|isImm
argument_list|()
operator|||
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrDisp
argument_list|)
operator|.
name|isGlobal
argument_list|()
operator|||
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrDisp
argument_list|)
operator|.
name|isCPI
argument_list|()
operator|||
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrDisp
argument_list|)
operator|.
name|isJTI
argument_list|()
operator|)
return|;
block|}
specifier|inline
specifier|static
name|bool
name|isMem
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Op
parameter_list|)
block|{
if|if
condition|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
argument_list|)
operator|.
name|isFI
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|Op
operator|+
name|X86
operator|::
name|AddrNumOperands
operator|<=
name|MI
operator|.
name|getNumOperands
argument_list|()
operator|&&
name|MI
operator|.
name|getOperand
argument_list|(
name|Op
operator|+
name|X86
operator|::
name|AddrSegmentReg
argument_list|)
operator|.
name|isReg
argument_list|()
operator|&&
name|isLeaMem
argument_list|(
name|MI
argument_list|,
name|Op
argument_list|)
return|;
block|}
name|class
name|X86InstrInfo
name|final
range|:
name|public
name|X86GenInstrInfo
block|{
name|X86Subtarget
operator|&
name|Subtarget
block|;
specifier|const
name|X86RegisterInfo
name|RI
block|;
comment|/// RegOp2MemOpTable3Addr, RegOp2MemOpTable0, RegOp2MemOpTable1,
comment|/// RegOp2MemOpTable2, RegOp2MemOpTable3 - Load / store folding opcode maps.
comment|///
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|uint16_t
operator|,
name|uint16_t
operator|>
expr|>
name|RegOp2MemOpTableType
expr_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable2Addr
decl_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable0
decl_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable1
decl_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable2
decl_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable3
decl_stmt|;
name|RegOp2MemOpTableType
name|RegOp2MemOpTable4
decl_stmt|;
comment|/// MemOp2RegOpTable - Load / store unfolding opcode map.
comment|///
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|uint16_t
operator|,
name|uint16_t
operator|>
expr|>
name|MemOp2RegOpTableType
expr_stmt|;
name|MemOp2RegOpTableType
name|MemOp2RegOpTable
decl_stmt|;
specifier|static
name|void
name|AddTableEntry
parameter_list|(
name|RegOp2MemOpTableType
modifier|&
name|R2MTable
parameter_list|,
name|MemOp2RegOpTableType
modifier|&
name|M2RTable
parameter_list|,
name|uint16_t
name|RegOp
parameter_list|,
name|uint16_t
name|MemOp
parameter_list|,
name|uint16_t
name|Flags
parameter_list|)
function_decl|;
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
name|bool
name|AnalyzeBranchImpl
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|*
operator|&
name|TBB
argument_list|,
name|MachineBasicBlock
operator|*
operator|&
name|FBB
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Cond
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|&
name|CondBranches
argument_list|,
name|bool
name|AllowModify
argument_list|)
decl|const
decl_stmt|;
name|public
label|:
name|explicit
name|X86InstrInfo
parameter_list|(
name|X86Subtarget
modifier|&
name|STI
parameter_list|)
function_decl|;
comment|/// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As
comment|/// such, whenever a client has an instance of instruction info, it should
comment|/// always be able to get register info as well (through this method).
comment|///
specifier|const
name|X86RegisterInfo
operator|&
name|getRegisterInfo
argument_list|()
specifier|const
block|{
return|return
name|RI
return|;
block|}
comment|/// Returns the stack pointer adjustment that happens inside the frame
comment|/// setup..destroy sequence (e.g. by pushes, or inside the callee).
name|int64_t
name|getFrameAdjustment
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|I
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isFrameInstr
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFrameSetup
argument_list|(
name|I
argument_list|)
condition|)
return|return
name|I
operator|.
name|getOperand
argument_list|(
literal|2
argument_list|)
operator|.
name|getImm
argument_list|()
return|;
return|return
name|I
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|.
name|getImm
argument_list|()
return|;
block|}
comment|/// Sets the stack pointer adjustment made inside the frame made up by this
comment|/// instruction.
name|void
name|setFrameAdjustment
argument_list|(
name|MachineInstr
operator|&
name|I
argument_list|,
name|int64_t
name|V
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isFrameInstr
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFrameSetup
argument_list|(
name|I
argument_list|)
condition|)
name|I
operator|.
name|getOperand
argument_list|(
literal|2
argument_list|)
operator|.
name|setImm
argument_list|(
name|V
argument_list|)
expr_stmt|;
else|else
name|I
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
operator|.
name|setImm
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
comment|/// getSPAdjust - This returns the stack pointer adjustment made by
comment|/// this instruction. For x86, we need to handle more complex call
comment|/// sequences involving PUSHes.
name|int
name|getSPAdjust
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// isCoalescableExtInstr - Return true if the instruction is a "coalescable"
comment|/// extension instruction. That is, it's like a copy where it's legal for the
comment|/// source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns
comment|/// true, then it's expected the pre-extension value is available as a subreg
comment|/// of the result register. This also returns the sub-register index in
comment|/// SubIdx.
name|bool
name|isCoalescableExtInstr
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|SrcReg
argument_list|,
name|unsigned
operator|&
name|DstReg
argument_list|,
name|unsigned
operator|&
name|SubIdx
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|isLoadFromStackSlot
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// isLoadFromStackSlotPostFE - Check for post-frame ptr elimination
comment|/// stack locations as well.  This uses a heuristic so it isn't
comment|/// reliable for correctness.
name|unsigned
name|isLoadFromStackSlotPostFE
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|isStoreToStackSlot
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// isStoreToStackSlotPostFE - Check for post-frame ptr elimination
comment|/// stack locations as well.  This uses a heuristic so it isn't
comment|/// reliable for correctness.
name|unsigned
name|isStoreToStackSlotPostFE
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|isReallyTriviallyReMaterializable
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|AliasAnalysis
operator|*
name|AA
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|reMaterialize
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|unsigned
name|DestReg
argument_list|,
name|unsigned
name|SubIdx
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|Orig
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|&
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// Given an operand within a MachineInstr, insert preceding code to put it
comment|/// into the right format for a particular kind of LEA instruction. This may
comment|/// involve using an appropriate super-register instead (with an implicit use
comment|/// of the original) or creating a new virtual register and inserting COPY
comment|/// instructions to get the data into the right class.
comment|///
comment|/// Reference parameters are set to indicate how caller should add this
comment|/// operand to the LEA instruction.
name|bool
name|classifyLEAReg
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
specifier|const
name|MachineOperand
operator|&
name|Src
argument_list|,
name|unsigned
name|LEAOpcode
argument_list|,
name|bool
name|AllowSP
argument_list|,
name|unsigned
operator|&
name|NewSrc
argument_list|,
name|bool
operator|&
name|isKill
argument_list|,
name|bool
operator|&
name|isUndef
argument_list|,
name|MachineOperand
operator|&
name|ImplicitOp
argument_list|,
name|LiveVariables
operator|*
name|LV
argument_list|)
decl|const
decl_stmt|;
comment|/// convertToThreeAddress - This method must be implemented by targets that
comment|/// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target
comment|/// may be able to convert a two-address instruction into a true
comment|/// three-address instruction on demand.  This allows the X86 target (for
comment|/// example) to convert ADD and SHL instructions into LEA instructions if they
comment|/// would require register copies due to two-addressness.
comment|///
comment|/// This method returns a null pointer if the transformation cannot be
comment|/// performed, otherwise it returns the new instruction.
comment|///
name|MachineInstr
modifier|*
name|convertToThreeAddress
argument_list|(
name|MachineFunction
operator|::
name|iterator
operator|&
name|MFI
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|LiveVariables
operator|*
name|LV
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// Returns true iff the routine could find two commutable operands in the
comment|/// given machine instruction.
comment|/// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their
comment|/// input values can be re-defined in this method only if the input values
comment|/// are not pre-defined, which is designated by the special value
comment|/// 'CommuteAnyOperandIndex' assigned to it.
comment|/// If both of indices are pre-defined and refer to some operands, then the
comment|/// method simply returns true if the corresponding operands are commutable
comment|/// and returns false otherwise.
comment|///
comment|/// For example, calling this method this way:
comment|///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;
comment|///     findCommutedOpIndices(MI, Op1, Op2);
comment|/// can be interpreted as a query asking to find an operand that would be
comment|/// commutable with the operand#1.
name|bool
name|findCommutedOpIndices
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx1
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx2
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// Returns true if the routine could find two commutable operands
comment|/// in the given FMA instruction \p MI. Otherwise, returns false.
comment|///
comment|/// \p SrcOpIdx1 and \p SrcOpIdx2 are INPUT and OUTPUT arguments.
comment|/// The output indices of the commuted operands are returned in these
comment|/// arguments. Also, the input values of these arguments may be preset either
comment|/// to indices of operands that must be commuted or be equal to a special
comment|/// value 'CommuteAnyOperandIndex' which means that the corresponding
comment|/// operand index is not set and this method is free to pick any of
comment|/// available commutable operands.
comment|/// The parameter \p FMA3Group keeps the reference to the group of relative
comment|/// FMA3 opcodes including register/memory forms of 132/213/231 opcodes.
comment|///
comment|/// For example, calling this method this way:
comment|///     unsigned Idx1 = 1, Idx2 = CommuteAnyOperandIndex;
comment|///     findFMA3CommutedOpIndices(MI, Idx1, Idx2, FMA3Group);
comment|/// can be interpreted as a query asking if the operand #1 can be swapped
comment|/// with any other available operand (e.g. operand #2, operand #3, etc.).
comment|///
comment|/// The returned FMA opcode may differ from the opcode in the given MI.
comment|/// For example, commuting the operands #1 and #3 in the following FMA
comment|///     FMA213 #1, #2, #3
comment|/// results into instruction with adjusted opcode:
comment|///     FMA231 #3, #2, #1
name|bool
name|findFMA3CommutedOpIndices
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx1
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx2
argument_list|,
specifier|const
name|X86InstrFMA3Group
operator|&
name|FMA3Group
argument_list|)
decl|const
decl_stmt|;
comment|/// Returns an adjusted FMA opcode that must be used in FMA instruction that
comment|/// performs the same computations as the given \p MI but which has the
comment|/// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.
comment|/// It may return 0 if it is unsafe to commute the operands.
comment|/// Note that a machine instruction (instead of its opcode) is passed as the
comment|/// first parameter to make it possible to analyze the instruction's uses and
comment|/// commute the first operand of FMA even when it seems unsafe when you look
comment|/// at the opcode. For example, it is Ok to commute the first operand of
comment|/// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.
comment|///
comment|/// The returned FMA opcode may differ from the opcode in the given \p MI.
comment|/// For example, commuting the operands #1 and #3 in the following FMA
comment|///     FMA213 #1, #2, #3
comment|/// results into instruction with adjusted opcode:
comment|///     FMA231 #3, #2, #1
name|unsigned
name|getFMA3OpcodeToCommuteOperands
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|SrcOpIdx1
argument_list|,
name|unsigned
name|SrcOpIdx2
argument_list|,
specifier|const
name|X86InstrFMA3Group
operator|&
name|FMA3Group
argument_list|)
decl|const
decl_stmt|;
comment|// Branch analysis.
name|bool
name|isUnpredicatedTerminator
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|isUnconditionalTailCall
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|canMakeTailCallConditional
argument_list|(
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Cond
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|TailCall
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|replaceBranchWithTailCall
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Cond
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|TailCall
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|analyzeBranch
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|*
operator|&
name|TBB
argument_list|,
name|MachineBasicBlock
operator|*
operator|&
name|FBB
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Cond
argument_list|,
name|bool
name|AllowModify
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|getMemOpBaseRegImmOfs
argument_list|(
name|MachineInstr
operator|&
name|LdSt
argument_list|,
name|unsigned
operator|&
name|BaseReg
argument_list|,
name|int64_t
operator|&
name|Offset
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|analyzeBranchPredicate
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|TargetInstrInfo
operator|::
name|MachineBranchPredicate
operator|&
name|MBP
argument_list|,
name|bool
name|AllowModify
operator|=
name|false
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|removeBranch
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|int
operator|*
name|BytesRemoved
operator|=
name|nullptr
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|insertBranch
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|*
name|TBB
argument_list|,
name|MachineBasicBlock
operator|*
name|FBB
argument_list|,
name|ArrayRef
operator|<
name|MachineOperand
operator|>
name|Cond
argument_list|,
specifier|const
name|DebugLoc
operator|&
name|DL
argument_list|,
name|int
operator|*
name|BytesAdded
operator|=
name|nullptr
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|canInsertSelect
argument_list|(
specifier|const
name|MachineBasicBlock
operator|&
argument_list|,
name|ArrayRef
operator|<
name|MachineOperand
operator|>
name|Cond
argument_list|,
name|unsigned
argument_list|,
name|unsigned
argument_list|,
name|int
operator|&
argument_list|,
name|int
operator|&
argument_list|,
name|int
operator|&
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|insertSelect
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
specifier|const
name|DebugLoc
operator|&
name|DL
argument_list|,
name|unsigned
name|DstReg
argument_list|,
name|ArrayRef
operator|<
name|MachineOperand
operator|>
name|Cond
argument_list|,
name|unsigned
name|TrueReg
argument_list|,
name|unsigned
name|FalseReg
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|copyPhysReg
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
specifier|const
name|DebugLoc
operator|&
name|DL
argument_list|,
name|unsigned
name|DestReg
argument_list|,
name|unsigned
name|SrcReg
argument_list|,
name|bool
name|KillSrc
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|storeRegToStackSlot
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|unsigned
name|SrcReg
argument_list|,
name|bool
name|isKill
argument_list|,
name|int
name|FrameIndex
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|RC
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|storeRegToAddr
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|unsigned
name|SrcReg
argument_list|,
name|bool
name|isKill
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Addr
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|RC
argument_list|,
name|MachineInstr
operator|::
name|mmo_iterator
name|MMOBegin
argument_list|,
name|MachineInstr
operator|::
name|mmo_iterator
name|MMOEnd
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|&
name|NewMIs
argument_list|)
decl|const
decl_stmt|;
name|void
name|loadRegFromStackSlot
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|unsigned
name|DestReg
argument_list|,
name|int
name|FrameIndex
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|RC
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|loadRegFromAddr
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|unsigned
name|DestReg
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Addr
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|RC
argument_list|,
name|MachineInstr
operator|::
name|mmo_iterator
name|MMOBegin
argument_list|,
name|MachineInstr
operator|::
name|mmo_iterator
name|MMOEnd
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|&
name|NewMIs
argument_list|)
decl|const
decl_stmt|;
name|bool
name|expandPostRAPseudo
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// Check whether the target can fold a load that feeds a subreg operand
comment|/// (or a subreg operand that feeds a store).
name|bool
name|isSubregFoldable
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
comment|/// foldMemoryOperand - If this target supports it, fold a load or store of
comment|/// the specified stack slot into the specified machine instruction for the
comment|/// specified operand(s).  If this is possible, the target should perform the
comment|/// folding and return true, otherwise it should return false.  If it folds
comment|/// the instruction, it is likely that the MachineInstruction the iterator
comment|/// references has been changed.
name|MachineInstr
modifier|*
name|foldMemoryOperandImpl
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Ops
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|InsertPt
argument_list|,
name|int
name|FrameIndex
argument_list|,
name|LiveIntervals
operator|*
name|LIS
operator|=
name|nullptr
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// foldMemoryOperand - Same as the previous version except it allows folding
comment|/// of any load and store from / to any address, not just from a specific
comment|/// stack slot.
name|MachineInstr
modifier|*
name|foldMemoryOperandImpl
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Ops
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|InsertPt
argument_list|,
name|MachineInstr
operator|&
name|LoadMI
argument_list|,
name|LiveIntervals
operator|*
name|LIS
operator|=
name|nullptr
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// unfoldMemoryOperand - Separate a single instruction which folded a load or
comment|/// a store or a load and a store into two or more instruction. If this is
comment|/// possible, returns true as well as the new instructions by reference.
name|bool
name|unfoldMemoryOperand
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|Reg
argument_list|,
name|bool
name|UnfoldLoad
argument_list|,
name|bool
name|UnfoldStore
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineInstr
operator|*
operator|>
operator|&
name|NewMIs
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|unfoldMemoryOperand
argument_list|(
name|SelectionDAG
operator|&
name|DAG
argument_list|,
name|SDNode
operator|*
name|N
argument_list|,
name|SmallVectorImpl
operator|<
name|SDNode
operator|*
operator|>
operator|&
name|NewNodes
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// getOpcodeAfterMemoryUnfold - Returns the opcode of the would be new
comment|/// instruction after load / store are unfolded from an instruction of the
comment|/// specified opcode. It returns zero if the specified unfolding is not
comment|/// possible. If LoadRegIndex is non-null, it is filled in with the operand
comment|/// index of the operand which will hold the register holding the loaded
comment|/// value.
name|unsigned
name|getOpcodeAfterMemoryUnfold
argument_list|(
name|unsigned
name|Opc
argument_list|,
name|bool
name|UnfoldLoad
argument_list|,
name|bool
name|UnfoldStore
argument_list|,
name|unsigned
operator|*
name|LoadRegIndex
operator|=
name|nullptr
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler
comment|/// to determine if two loads are loading from the same base address. It
comment|/// should only return true if the base pointers are the same and the
comment|/// only differences between the two addresses are the offset. It also returns
comment|/// the offsets by reference.
name|bool
name|areLoadsFromSameBasePtr
argument_list|(
name|SDNode
operator|*
name|Load1
argument_list|,
name|SDNode
operator|*
name|Load2
argument_list|,
name|int64_t
operator|&
name|Offset1
argument_list|,
name|int64_t
operator|&
name|Offset2
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to
comment|/// determine (in conjunction with areLoadsFromSameBasePtr) if two loads should
comment|/// be scheduled togther. On some targets if two loads are loading from
comment|/// addresses in the same cache line, it's better if they are scheduled
comment|/// together. This function takes two integers that represent the load offsets
comment|/// from the common base address. It returns true if it decides it's desirable
comment|/// to schedule the two loads together. "NumLoads" is the number of loads that
comment|/// have already been scheduled after Load1.
name|bool
name|shouldScheduleLoadsNear
argument_list|(
name|SDNode
operator|*
name|Load1
argument_list|,
name|SDNode
operator|*
name|Load2
argument_list|,
name|int64_t
name|Offset1
argument_list|,
name|int64_t
name|Offset2
argument_list|,
name|unsigned
name|NumLoads
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|getNoop
argument_list|(
name|MCInst
operator|&
name|NopInst
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|reverseBranchCondition
argument_list|(
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Cond
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// isSafeToMoveRegClassDefs - Return true if it's safe to move a machine
comment|/// instruction that defines the specified register class.
name|bool
name|isSafeToMoveRegClassDefs
argument_list|(
specifier|const
name|TargetRegisterClass
operator|*
name|RC
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// isSafeToClobberEFLAGS - Return true if it's safe insert an instruction tha
comment|/// would clobber the EFLAGS condition register. Note the result may be
comment|/// conservative. If it cannot definitely determine the safety after visiting
comment|/// a few instructions in each direction it assumes it's not safe.
name|bool
name|isSafeToClobberEFLAGS
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|)
decl|const
decl_stmt|;
comment|/// True if MI has a condition code def, e.g. EFLAGS, that is
comment|/// not marked dead.
name|bool
name|hasLiveCondCodeDef
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// getGlobalBaseReg - Return a virtual register initialized with the
comment|/// the global base register value. Output instructions required to
comment|/// initialize the register in the function entry block, if necessary.
comment|///
name|unsigned
name|getGlobalBaseReg
argument_list|(
name|MachineFunction
operator|*
name|MF
argument_list|)
decl|const
decl_stmt|;
name|std
operator|::
name|pair
operator|<
name|uint16_t
operator|,
name|uint16_t
operator|>
name|getExecutionDomain
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
name|override
expr_stmt|;
name|void
name|setExecutionDomain
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|Domain
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|getPartialRegUpdateClearance
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNum
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|getUndefRegClearance
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|OpNum
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|breakPartialRegDependency
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNum
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
name|override
decl_stmt|;
name|MachineInstr
modifier|*
name|foldMemoryOperandImpl
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNum
argument_list|,
name|ArrayRef
operator|<
name|MachineOperand
operator|>
name|MOs
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|InsertPt
argument_list|,
name|unsigned
name|Size
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|bool
name|AllowCommute
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isHighLatencyDef
argument_list|(
name|int
name|opc
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|hasHighOperandLatency
argument_list|(
specifier|const
name|TargetSchedModel
operator|&
name|SchedModel
argument_list|,
specifier|const
name|MachineRegisterInfo
operator|*
name|MRI
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|DefMI
argument_list|,
name|unsigned
name|DefIdx
argument_list|,
specifier|const
name|MachineInstr
operator|&
name|UseMI
argument_list|,
name|unsigned
name|UseIdx
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|useMachineCombiner
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|isAssociativeAndCommutative
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|Inst
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|hasReassociableOperands
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|Inst
argument_list|,
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|setSpecialOperandAttr
argument_list|(
name|MachineInstr
operator|&
name|OldMI1
argument_list|,
name|MachineInstr
operator|&
name|OldMI2
argument_list|,
name|MachineInstr
operator|&
name|NewMI1
argument_list|,
name|MachineInstr
operator|&
name|NewMI2
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// analyzeCompare - For a comparison instruction, return the source registers
comment|/// in SrcReg and SrcReg2 if having two register operands, and the value it
comment|/// compares against in CmpValue. Return true if the comparison instruction
comment|/// can be analyzed.
name|bool
name|analyzeCompare
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|SrcReg
argument_list|,
name|unsigned
operator|&
name|SrcReg2
argument_list|,
name|int
operator|&
name|CmpMask
argument_list|,
name|int
operator|&
name|CmpValue
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// optimizeCompareInstr - Check if there exists an earlier instruction that
comment|/// operates on the same source operands and sets flags in the same way as
comment|/// Compare; remove Compare if possible.
name|bool
name|optimizeCompareInstr
argument_list|(
name|MachineInstr
operator|&
name|CmpInstr
argument_list|,
name|unsigned
name|SrcReg
argument_list|,
name|unsigned
name|SrcReg2
argument_list|,
name|int
name|CmpMask
argument_list|,
name|int
name|CmpValue
argument_list|,
specifier|const
name|MachineRegisterInfo
operator|*
name|MRI
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// optimizeLoadInstr - Try to remove the load by folding it to a register
comment|/// operand at the use. We fold the load instructions if and only if the
comment|/// def and use are in the same BB. We only look at one load and see
comment|/// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register
comment|/// defined by the load we are trying to fold. DefMI returns the machine
comment|/// instruction that defines FoldAsLoadDefReg, and the function returns
comment|/// the machine instruction generated due to folding.
name|MachineInstr
modifier|*
name|optimizeLoadInstr
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
specifier|const
name|MachineRegisterInfo
operator|*
name|MRI
argument_list|,
name|unsigned
operator|&
name|FoldAsLoadDefReg
argument_list|,
name|MachineInstr
operator|*
operator|&
name|DefMI
argument_list|)
decl|const
name|override
decl_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|decomposeMachineOperandsTargetFlags
argument_list|(
argument|unsigned TF
argument_list|)
specifier|const
name|override
expr_stmt|;
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|>>
name|getSerializableDirectMachineOperandTargetFlags
argument_list|()
specifier|const
name|override
expr_stmt|;
name|unsigned
name|getOutliningBenefit
argument_list|(
name|size_t
name|SequenceSize
argument_list|,
name|size_t
name|Occurrences
argument_list|,
name|bool
name|CanBeTailCall
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|isFunctionSafeToOutlineFrom
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|)
decl|const
name|override
decl_stmt|;
name|llvm
operator|::
name|X86GenInstrInfo
operator|::
name|MachineOutlinerInstrType
name|getOutliningType
argument_list|(
argument|MachineInstr&MI
argument_list|)
specifier|const
name|override
expr_stmt|;
name|void
name|insertOutlinerEpilogue
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineFunction
operator|&
name|MF
argument_list|,
name|bool
name|IsTailCall
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|insertOutlinerPrologue
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineFunction
operator|&
name|MF
argument_list|,
name|bool
name|isTailCall
argument_list|)
decl|const
name|override
decl_stmt|;
name|MachineBasicBlock
operator|::
name|iterator
name|insertOutlinedCall
argument_list|(
argument|Module&M
argument_list|,
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator&It
argument_list|,
argument|MachineFunction&MF
argument_list|,
argument|bool IsTailCall
argument_list|)
specifier|const
name|override
expr_stmt|;
name|protected
label|:
comment|/// Commutes the operands in the given instruction by changing the operands
comment|/// order and/or changing the instruction's opcode and/or the immediate value
comment|/// operand.
comment|///
comment|/// The arguments 'CommuteOpIdx1' and 'CommuteOpIdx2' specify the operands
comment|/// to be commuted.
comment|///
comment|/// Do not call this method for a non-commutable instruction or
comment|/// non-commutable operands.
comment|/// Even though the instruction is commutable, the method may still
comment|/// fail to commute the operands, null pointer is returned in such cases.
name|MachineInstr
modifier|*
name|commuteInstructionImpl
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|bool
name|NewMI
argument_list|,
name|unsigned
name|CommuteOpIdx1
argument_list|,
name|unsigned
name|CommuteOpIdx2
argument_list|)
decl|const
name|override
decl_stmt|;
name|private
label|:
name|MachineInstr
modifier|*
name|convertToThreeAddressWithLEA
argument_list|(
name|unsigned
name|MIOpc
argument_list|,
name|MachineFunction
operator|::
name|iterator
operator|&
name|MFI
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|LiveVariables
operator|*
name|LV
argument_list|)
decl|const
decl_stmt|;
comment|/// Handles memory folding for special case instructions, for instance those
comment|/// requiring custom manipulation of the address.
name|MachineInstr
modifier|*
name|foldMemoryOperandCustom
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNum
argument_list|,
name|ArrayRef
operator|<
name|MachineOperand
operator|>
name|MOs
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|InsertPt
argument_list|,
name|unsigned
name|Size
argument_list|,
name|unsigned
name|Align
argument_list|)
decl|const
decl_stmt|;
comment|/// isFrameOperand - Return true and the FrameIndex if the specified
comment|/// operand and follow operands form a reference to the stack frame.
name|bool
name|isFrameOperand
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|int
name|Op
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
decl_stmt|;
comment|/// Returns true iff the routine could find two commutable operands in the
comment|/// given machine instruction with 3 vector inputs.
comment|/// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their
comment|/// input values can be re-defined in this method only if the input values
comment|/// are not pre-defined, which is designated by the special value
comment|/// 'CommuteAnyOperandIndex' assigned to it.
comment|/// If both of indices are pre-defined and refer to some operands, then the
comment|/// method simply returns true if the corresponding operands are commutable
comment|/// and returns false otherwise.
comment|///
comment|/// For example, calling this method this way:
comment|///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;
comment|///     findThreeSrcCommutedOpIndices(MI, Op1, Op2);
comment|/// can be interpreted as a query asking to find an operand that would be
comment|/// commutable with the operand#1.
name|bool
name|findThreeSrcCommutedOpIndices
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx1
argument_list|,
name|unsigned
operator|&
name|SrcOpIdx2
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

