begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- X86InstrBuilder.h - Functions to aid building x86 insts -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file exposes functions that may be used with BuildMI from the
end_comment

begin_comment
comment|// MachineInstrBuilder.h file to handle X86'isms in a clean way.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The BuildMem function may be used with the BuildMI function to add entire
end_comment

begin_comment
comment|// memory references in a single, typed, function call.  X86 memory references
end_comment

begin_comment
comment|// can be very complex expressions (described in the README), so wrapping them
end_comment

begin_comment
comment|// up behind an easier to use interface makes sense.  Descriptions of the
end_comment

begin_comment
comment|// functions are included below.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For reference, the order of operands for memory references is:
end_comment

begin_comment
comment|// (Operand), Base, Scale, Index, Displacement.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_X86_X86INSTRBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_X86_X86INSTRBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFrameInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstrBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineMemOperand.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineOperand.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCInstrDesc.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// X86AddressMode - This struct holds a generalized full x86 address mode.
comment|/// The base register can be a frame index, which will eventually be replaced
comment|/// with BP or SP and Disp being offsetted accordingly.  The displacement may
comment|/// also include the offset of a global value.
struct|struct
name|X86AddressMode
block|{
enum|enum
block|{
name|RegBase
block|,
name|FrameIndexBase
block|}
name|BaseType
enum|;
union|union
block|{
name|unsigned
name|Reg
decl_stmt|;
name|int
name|FrameIndex
decl_stmt|;
block|}
name|Base
union|;
name|unsigned
name|Scale
decl_stmt|;
name|unsigned
name|IndexReg
decl_stmt|;
name|int
name|Disp
decl_stmt|;
specifier|const
name|GlobalValue
modifier|*
name|GV
decl_stmt|;
name|unsigned
name|GVOpFlags
decl_stmt|;
name|X86AddressMode
argument_list|()
operator|:
name|BaseType
argument_list|(
name|RegBase
argument_list|)
operator|,
name|Scale
argument_list|(
literal|1
argument_list|)
operator|,
name|IndexReg
argument_list|(
literal|0
argument_list|)
operator|,
name|Disp
argument_list|(
literal|0
argument_list|)
operator|,
name|GV
argument_list|(
name|nullptr
argument_list|)
operator|,
name|GVOpFlags
argument_list|(
literal|0
argument_list|)
block|{
name|Base
operator|.
name|Reg
operator|=
literal|0
block|;   }
name|void
name|getFullAddress
argument_list|(
argument|SmallVectorImpl<MachineOperand>&MO
argument_list|)
block|{
name|assert
argument_list|(
name|Scale
operator|==
literal|1
operator|||
name|Scale
operator|==
literal|2
operator|||
name|Scale
operator|==
literal|4
operator|||
name|Scale
operator|==
literal|8
argument_list|)
block|;
if|if
condition|(
name|BaseType
operator|==
name|X86AddressMode
operator|::
name|RegBase
condition|)
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateReg
argument_list|(
name|Base
operator|.
name|Reg
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|BaseType
operator|==
name|X86AddressMode
operator|::
name|FrameIndexBase
argument_list|)
expr_stmt|;
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateFI
argument_list|(
name|Base
operator|.
name|FrameIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateImm
argument_list|(
name|Scale
argument_list|)
argument_list|)
expr_stmt|;
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateReg
argument_list|(
name|IndexReg
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GV
condition|)
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateGA
argument_list|(
name|GV
argument_list|,
name|Disp
argument_list|,
name|GVOpFlags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateImm
argument_list|(
name|Disp
argument_list|)
argument_list|)
expr_stmt|;
name|MO
operator|.
name|push_back
argument_list|(
name|MachineOperand
operator|::
name|CreateReg
argument_list|(
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Compute the addressing mode from an machine instruction starting with the
end_comment

begin_comment
comment|/// given operand.
end_comment

begin_function
specifier|static
specifier|inline
name|X86AddressMode
name|getAddressFromInstr
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|Operand
parameter_list|)
block|{
name|X86AddressMode
name|AM
decl_stmt|;
specifier|const
name|MachineOperand
modifier|&
name|Op0
init|=
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|Op0
operator|.
name|isReg
argument_list|()
condition|)
block|{
name|AM
operator|.
name|BaseType
operator|=
name|X86AddressMode
operator|::
name|RegBase
expr_stmt|;
name|AM
operator|.
name|Base
operator|.
name|Reg
operator|=
name|Op0
operator|.
name|getReg
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|AM
operator|.
name|BaseType
operator|=
name|X86AddressMode
operator|::
name|FrameIndexBase
expr_stmt|;
name|AM
operator|.
name|Base
operator|.
name|FrameIndex
operator|=
name|Op0
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
specifier|const
name|MachineOperand
modifier|&
name|Op1
init|=
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|1
argument_list|)
decl_stmt|;
name|AM
operator|.
name|Scale
operator|=
name|Op1
operator|.
name|getImm
argument_list|()
expr_stmt|;
specifier|const
name|MachineOperand
modifier|&
name|Op2
init|=
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|2
argument_list|)
decl_stmt|;
name|AM
operator|.
name|IndexReg
operator|=
name|Op2
operator|.
name|getReg
argument_list|()
expr_stmt|;
specifier|const
name|MachineOperand
modifier|&
name|Op3
init|=
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|Op3
operator|.
name|isGlobal
argument_list|()
condition|)
name|AM
operator|.
name|GV
operator|=
name|Op3
operator|.
name|getGlobal
argument_list|()
expr_stmt|;
else|else
name|AM
operator|.
name|Disp
operator|=
name|Op3
operator|.
name|getImm
argument_list|()
expr_stmt|;
return|return
name|AM
return|;
block|}
end_function

begin_comment
comment|/// addDirectMem - This function is used to add a direct memory reference to the
end_comment

begin_comment
comment|/// current instruction -- that is, a dereference of an address in a register,
end_comment

begin_comment
comment|/// with no scale, index or displacement. An example is: DWORD PTR [EAX].
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addDirectMem
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|unsigned
name|Reg
parameter_list|)
block|{
comment|// Because memory references are always represented with five
comment|// values, this adds: Reg, 1, NoReg, 0, NoReg to the instruction.
return|return
name|MIB
operator|.
name|addReg
argument_list|(
name|Reg
argument_list|)
operator|.
name|addImm
argument_list|(
literal|1
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
operator|.
name|addImm
argument_list|(
literal|0
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Replace the address used in the instruction with the direct memory
end_comment

begin_comment
comment|/// reference.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|setDirectAddressInInstr
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|Operand
parameter_list|,
name|unsigned
name|Reg
parameter_list|)
block|{
comment|// Direct memory address is in a form of: Reg, 1 (Scale), NoReg, 0, NoReg.
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
argument_list|)
operator|.
name|setReg
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|1
argument_list|)
operator|.
name|setImm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|2
argument_list|)
operator|.
name|setReg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|3
argument_list|)
operator|.
name|setImm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MI
operator|->
name|getOperand
argument_list|(
name|Operand
operator|+
literal|4
argument_list|)
operator|.
name|setReg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addOffset
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|int
name|Offset
parameter_list|)
block|{
return|return
name|MIB
operator|.
name|addImm
argument_list|(
literal|1
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
operator|.
name|addImm
argument_list|(
name|Offset
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addOffset
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
specifier|const
name|MachineOperand
modifier|&
name|Offset
parameter_list|)
block|{
return|return
name|MIB
operator|.
name|addImm
argument_list|(
literal|1
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|Offset
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// addRegOffset - This function is used to add a memory reference of the form
end_comment

begin_comment
comment|/// [Reg + Offset], i.e., one with no scale or index, but with a
end_comment

begin_comment
comment|/// displacement. An example is: DWORD PTR [EAX + 4].
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addRegOffset
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|bool
name|isKill
parameter_list|,
name|int
name|Offset
parameter_list|)
block|{
return|return
name|addOffset
argument_list|(
name|MIB
operator|.
name|addReg
argument_list|(
name|Reg
argument_list|,
name|getKillRegState
argument_list|(
name|isKill
argument_list|)
argument_list|)
argument_list|,
name|Offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// addRegReg - This function is used to add a memory reference of the form:
end_comment

begin_comment
comment|/// [Reg + Reg].
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addRegReg
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|unsigned
name|Reg1
parameter_list|,
name|bool
name|isKill1
parameter_list|,
name|unsigned
name|Reg2
parameter_list|,
name|bool
name|isKill2
parameter_list|)
block|{
return|return
name|MIB
operator|.
name|addReg
argument_list|(
name|Reg1
argument_list|,
name|getKillRegState
argument_list|(
name|isKill1
argument_list|)
argument_list|)
operator|.
name|addImm
argument_list|(
literal|1
argument_list|)
operator|.
name|addReg
argument_list|(
name|Reg2
argument_list|,
name|getKillRegState
argument_list|(
name|isKill2
argument_list|)
argument_list|)
operator|.
name|addImm
argument_list|(
literal|0
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addFullAddress
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
specifier|const
name|X86AddressMode
modifier|&
name|AM
parameter_list|)
block|{
name|assert
argument_list|(
name|AM
operator|.
name|Scale
operator|==
literal|1
operator|||
name|AM
operator|.
name|Scale
operator|==
literal|2
operator|||
name|AM
operator|.
name|Scale
operator|==
literal|4
operator|||
name|AM
operator|.
name|Scale
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|AM
operator|.
name|BaseType
operator|==
name|X86AddressMode
operator|::
name|RegBase
condition|)
name|MIB
operator|.
name|addReg
argument_list|(
name|AM
operator|.
name|Base
operator|.
name|Reg
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|AM
operator|.
name|BaseType
operator|==
name|X86AddressMode
operator|::
name|FrameIndexBase
argument_list|)
expr_stmt|;
name|MIB
operator|.
name|addFrameIndex
argument_list|(
name|AM
operator|.
name|Base
operator|.
name|FrameIndex
argument_list|)
expr_stmt|;
block|}
name|MIB
operator|.
name|addImm
argument_list|(
name|AM
operator|.
name|Scale
argument_list|)
operator|.
name|addReg
argument_list|(
name|AM
operator|.
name|IndexReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|AM
operator|.
name|GV
condition|)
name|MIB
operator|.
name|addGlobalAddress
argument_list|(
name|AM
operator|.
name|GV
argument_list|,
name|AM
operator|.
name|Disp
argument_list|,
name|AM
operator|.
name|GVOpFlags
argument_list|)
expr_stmt|;
else|else
name|MIB
operator|.
name|addImm
argument_list|(
name|AM
operator|.
name|Disp
argument_list|)
expr_stmt|;
return|return
name|MIB
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// addFrameReference - This function is used to add a reference to the base of
end_comment

begin_comment
comment|/// an abstract object on the stack frame of the current function.  This
end_comment

begin_comment
comment|/// reference has base register as the FrameIndex offset until it is resolved.
end_comment

begin_comment
comment|/// This allows a constant offset to be specified as well...
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addFrameReference
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|int
name|FI
parameter_list|,
name|int
name|Offset
init|=
literal|0
parameter_list|)
block|{
name|MachineInstr
modifier|*
name|MI
init|=
name|MIB
decl_stmt|;
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|MI
operator|->
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|MachineFrameInfo
modifier|&
name|MFI
init|=
name|MF
operator|.
name|getFrameInfo
argument_list|()
decl_stmt|;
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
init|=
name|MI
operator|->
name|getDesc
argument_list|()
decl_stmt|;
name|auto
name|Flags
init|=
name|MachineMemOperand
operator|::
name|MONone
decl_stmt|;
if|if
condition|(
name|MCID
operator|.
name|mayLoad
argument_list|()
condition|)
name|Flags
operator||=
name|MachineMemOperand
operator|::
name|MOLoad
expr_stmt|;
if|if
condition|(
name|MCID
operator|.
name|mayStore
argument_list|()
condition|)
name|Flags
operator||=
name|MachineMemOperand
operator|::
name|MOStore
expr_stmt|;
name|MachineMemOperand
modifier|*
name|MMO
init|=
name|MF
operator|.
name|getMachineMemOperand
argument_list|(
name|MachinePointerInfo
operator|::
name|getFixedStack
argument_list|(
name|MF
argument_list|,
name|FI
argument_list|,
name|Offset
argument_list|)
argument_list|,
name|Flags
argument_list|,
name|MFI
operator|.
name|getObjectSize
argument_list|(
name|FI
argument_list|)
argument_list|,
name|MFI
operator|.
name|getObjectAlignment
argument_list|(
name|FI
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|addOffset
argument_list|(
name|MIB
operator|.
name|addFrameIndex
argument_list|(
name|FI
argument_list|)
argument_list|,
name|Offset
argument_list|)
operator|.
name|addMemOperand
argument_list|(
name|MMO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// addConstantPoolReference - This function is used to add a reference to the
end_comment

begin_comment
comment|/// base of a constant value spilled to the per-function constant pool.  The
end_comment

begin_comment
comment|/// reference uses the abstract ConstantPoolIndex which is retained until
end_comment

begin_comment
comment|/// either machine code emission or assembly output. In PIC mode on x86-32,
end_comment

begin_comment
comment|/// the GlobalBaseReg parameter can be used to make this a
end_comment

begin_comment
comment|/// GlobalBaseReg-relative reference.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|MachineInstrBuilder
modifier|&
name|addConstantPoolReference
parameter_list|(
specifier|const
name|MachineInstrBuilder
modifier|&
name|MIB
parameter_list|,
name|unsigned
name|CPI
parameter_list|,
name|unsigned
name|GlobalBaseReg
parameter_list|,
name|unsigned
name|char
name|OpFlags
parameter_list|)
block|{
comment|//FIXME: factor this
return|return
name|MIB
operator|.
name|addReg
argument_list|(
name|GlobalBaseReg
argument_list|)
operator|.
name|addImm
argument_list|(
literal|1
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
operator|.
name|addConstantPoolIndex
argument_list|(
name|CPI
argument_list|,
literal|0
argument_list|,
name|OpFlags
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_TARGET_X86_X86INSTRBUILDER_H
end_comment

end_unit

