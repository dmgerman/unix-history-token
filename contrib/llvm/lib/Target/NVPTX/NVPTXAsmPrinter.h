begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- NVPTXAsmPrinter.h - NVPTX LLVM assembly writer --------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains a printer that converts from our internal representation
end_comment

begin_comment
comment|// of machine-dependent LLVM code to NVPTX assembly language.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_NVPTX_NVPTXASMPRINTER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_NVPTX_NVPTXASMPRINTER_H
end_define

begin_include
include|#
directive|include
file|"NVPTX.h"
end_include

begin_include
include|#
directive|include
file|"NVPTXSubtarget.h"
end_include

begin_include
include|#
directive|include
file|"NVPTXTargetMachine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallString.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/AsmPrinter.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCAsmInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCExpr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCSymbol.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CommandLine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/FormattedStream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_include
include|#
directive|include
file|<fstream>
end_include

begin_comment
comment|// The ptx syntax and format is very different from that usually seem in a .s
end_comment

begin_comment
comment|// file,
end_comment

begin_comment
comment|// therefore we are not able to use the MCAsmStreamer interface here.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// We are handcrafting the output method here.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A better approach is to clone the MCAsmStreamer to a MCPTXAsmStreamer
end_comment

begin_comment
comment|// (subclass of MCStreamer).
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCOperand
decl_stmt|;
name|class
name|LineReader
block|{
name|private
label|:
name|unsigned
name|theCurLine
decl_stmt|;
name|std
operator|::
name|ifstream
name|fstr
expr_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
name|std
operator|::
name|string
name|theFileName
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|32
operator|>
name|lineOffset
expr_stmt|;
name|public
label|:
name|LineReader
argument_list|(
argument|std::string filename
argument_list|)
block|{
name|theCurLine
operator|=
literal|0
expr_stmt|;
name|fstr
operator|.
name|open
argument_list|(
name|filename
operator|.
name|c_str
argument_list|()
argument_list|)
expr_stmt|;
name|theFileName
operator|=
name|filename
expr_stmt|;
block|}
name|std
operator|::
name|string
name|fileName
argument_list|()
block|{
return|return
name|theFileName
return|;
block|}
operator|~
name|LineReader
argument_list|()
block|{
name|fstr
operator|.
name|close
argument_list|()
block|; }
name|std
operator|::
name|string
name|readLine
argument_list|(
argument|unsigned line
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|NVPTXAsmPrinter
range|:
name|public
name|AsmPrinter
block|{
name|class
name|AggBuffer
block|{
comment|// Used to buffer the emitted string for initializing global
comment|// aggregates.
comment|//
comment|// Normally an aggregate (array, vector or structure) is emitted
comment|// as a u8[]. However, if one element/field of the aggregate
comment|// is a non-NULL address, then the aggregate is emitted as u32[]
comment|// or u64[].
comment|//
comment|// We first layout the aggregate in 'buffer' in bytes, except for
comment|// those symbol addresses. For the i-th symbol address in the
comment|//aggregate, its corresponding 4-byte or 8-byte elements in 'buffer'
comment|// are filled with 0s. symbolPosInBuffer[i-1] records its position
comment|// in 'buffer', and Symbols[i-1] records the Value*.
comment|//
comment|// Once we have this AggBuffer setup, we can choose how to print
comment|// it out.
name|public
operator|:
name|unsigned
name|numSymbols
block|;
comment|// number of symbol addresses
name|private
operator|:
specifier|const
name|unsigned
name|size
block|;
comment|// size of the buffer in bytes
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
name|buffer
block|;
comment|// the buffer
name|SmallVector
operator|<
name|unsigned
block|,
literal|4
operator|>
name|symbolPosInBuffer
block|;
name|SmallVector
operator|<
specifier|const
name|Value
operator|*
block|,
literal|4
operator|>
name|Symbols
block|;
comment|// SymbolsBeforeStripping[i] is the original form of Symbols[i] before
comment|// stripping pointer casts, i.e.,
comment|// Symbols[i] == SymbolsBeforeStripping[i]->stripPointerCasts().
comment|//
comment|// We need to keep these values because AggBuffer::print decides whether to
comment|// emit a "generic()" cast for Symbols[i] depending on the address space of
comment|// SymbolsBeforeStripping[i].
name|SmallVector
operator|<
specifier|const
name|Value
operator|*
block|,
literal|4
operator|>
name|SymbolsBeforeStripping
block|;
name|unsigned
name|curpos
block|;
name|raw_ostream
operator|&
name|O
block|;
name|NVPTXAsmPrinter
operator|&
name|AP
block|;
name|bool
name|EmitGeneric
block|;
name|public
operator|:
name|AggBuffer
argument_list|(
argument|unsigned size
argument_list|,
argument|raw_ostream&O
argument_list|,
argument|NVPTXAsmPrinter&AP
argument_list|)
operator|:
name|size
argument_list|(
name|size
argument_list|)
block|,
name|buffer
argument_list|(
name|size
argument_list|)
block|,
name|O
argument_list|(
name|O
argument_list|)
block|,
name|AP
argument_list|(
argument|AP
argument_list|)
block|{
name|curpos
operator|=
literal|0
block|;
name|numSymbols
operator|=
literal|0
block|;
name|EmitGeneric
operator|=
name|AP
operator|.
name|EmitGeneric
block|;     }
name|unsigned
name|addBytes
argument_list|(
argument|unsigned char *Ptr
argument_list|,
argument|int Num
argument_list|,
argument|int Bytes
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|curpos
operator|+
name|Num
operator|)
operator|<=
name|size
argument_list|)
block|;
name|assert
argument_list|(
operator|(
name|curpos
operator|+
name|Bytes
operator|)
operator|<=
name|size
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Num
condition|;
operator|++
name|i
control|)
block|{
name|buffer
index|[
name|curpos
index|]
operator|=
name|Ptr
index|[
name|i
index|]
expr_stmt|;
name|curpos
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|Num
init|;
name|i
operator|<
name|Bytes
condition|;
operator|++
name|i
control|)
block|{
name|buffer
index|[
name|curpos
index|]
operator|=
literal|0
expr_stmt|;
name|curpos
operator|++
expr_stmt|;
block|}
return|return
name|curpos
return|;
block|}
name|unsigned
name|addZeros
argument_list|(
argument|int Num
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|curpos
operator|+
name|Num
operator|)
operator|<=
name|size
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Num
condition|;
operator|++
name|i
control|)
block|{
name|buffer
index|[
name|curpos
index|]
operator|=
literal|0
expr_stmt|;
name|curpos
operator|++
expr_stmt|;
block|}
return|return
name|curpos
return|;
block|}
name|void
name|addSymbol
argument_list|(
argument|const Value *GVar
argument_list|,
argument|const Value *GVarBeforeStripping
argument_list|)
block|{
name|symbolPosInBuffer
operator|.
name|push_back
argument_list|(
name|curpos
argument_list|)
block|;
name|Symbols
operator|.
name|push_back
argument_list|(
name|GVar
argument_list|)
block|;
name|SymbolsBeforeStripping
operator|.
name|push_back
argument_list|(
name|GVarBeforeStripping
argument_list|)
block|;
name|numSymbols
operator|++
block|;     }
name|void
name|print
argument_list|()
block|{
if|if
condition|(
name|numSymbols
operator|==
literal|0
condition|)
block|{
comment|// print out in bytes
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|O
operator|<<
literal|", "
expr_stmt|;
name|O
operator|<<
operator|(
name|unsigned
name|int
operator|)
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// print out in 4-bytes or 8-bytes
name|unsigned
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nSym
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nextSymbolPos
init|=
name|symbolPosInBuffer
index|[
name|nSym
index|]
decl_stmt|;
name|unsigned
name|int
name|nBytes
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|static_cast
operator|<
specifier|const
name|NVPTXTargetMachine
operator|&
operator|>
operator|(
name|AP
operator|.
name|TM
operator|)
operator|.
name|is64Bit
argument_list|()
condition|)
name|nBytes
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|size
condition|;
name|pos
operator|+=
name|nBytes
control|)
block|{
if|if
condition|(
name|pos
condition|)
name|O
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|nextSymbolPos
condition|)
block|{
specifier|const
name|Value
modifier|*
name|v
init|=
name|Symbols
index|[
name|nSym
index|]
decl_stmt|;
specifier|const
name|Value
modifier|*
name|v0
init|=
name|SymbolsBeforeStripping
index|[
name|nSym
index|]
decl_stmt|;
if|if
condition|(
specifier|const
name|GlobalValue
modifier|*
name|GVar
init|=
name|dyn_cast
operator|<
name|GlobalValue
operator|>
operator|(
name|v
operator|)
condition|)
block|{
name|MCSymbol
modifier|*
name|Name
init|=
name|AP
operator|.
name|getSymbol
argument_list|(
name|GVar
argument_list|)
decl_stmt|;
name|PointerType
modifier|*
name|PTy
init|=
name|dyn_cast
operator|<
name|PointerType
operator|>
operator|(
name|v0
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|bool
name|IsNonGenericPointer
init|=
name|false
decl_stmt|;
comment|// Is v0 a non-generic pointer?
if|if
condition|(
name|PTy
operator|&&
name|PTy
operator|->
name|getAddressSpace
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|IsNonGenericPointer
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|EmitGeneric
operator|&&
operator|!
name|isa
operator|<
name|Function
operator|>
operator|(
name|v
operator|)
operator|&&
operator|!
name|IsNonGenericPointer
condition|)
block|{
name|O
operator|<<
literal|"generic("
expr_stmt|;
name|O
operator|<<
operator|*
name|Name
expr_stmt|;
name|O
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|O
operator|<<
operator|*
name|Name
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
specifier|const
name|ConstantExpr
modifier|*
name|CExpr
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|v0
operator|)
condition|)
block|{
specifier|const
name|MCExpr
modifier|*
name|Expr
init|=
name|AP
operator|.
name|lowerConstantForGV
argument_list|(
name|cast
operator|<
name|Constant
operator|>
operator|(
name|CExpr
operator|)
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|AP
operator|.
name|printMCExpr
argument_list|(
operator|*
name|Expr
argument_list|,
name|O
argument_list|)
expr_stmt|;
block|}
else|else
name|llvm_unreachable
argument_list|(
literal|"symbol type unknown"
argument_list|)
expr_stmt|;
name|nSym
operator|++
expr_stmt|;
if|if
condition|(
name|nSym
operator|>=
name|numSymbols
condition|)
name|nextSymbolPos
operator|=
name|size
operator|+
literal|1
expr_stmt|;
else|else
name|nextSymbolPos
operator|=
name|symbolPosInBuffer
index|[
name|nSym
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nBytes
operator|==
literal|4
condition|)
name|O
operator|<<
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|&
name|buffer
index|[
name|pos
index|]
operator|)
expr_stmt|;
else|else
name|O
operator|<<
operator|*
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
operator|(
operator|&
name|buffer
index|[
name|pos
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
expr|}
block|;
name|friend
name|class
name|AggBuffer
block|;
name|void
name|emitSrcInText
argument_list|(
argument|StringRef filename
argument_list|,
argument|unsigned line
argument_list|)
block|;
name|private
operator|:
specifier|const
name|char
operator|*
name|getPassName
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"NVPTX Assembly Printer"
return|;
block|}
specifier|const
name|Function
operator|*
name|F
block|;
name|std
operator|::
name|string
name|CurrentFnName
block|;
name|void
name|EmitBasicBlockStart
argument_list|(
argument|const MachineBasicBlock&MBB
argument_list|)
specifier|const
name|override
block|;
name|void
name|EmitFunctionEntryLabel
argument_list|()
name|override
block|;
name|void
name|EmitFunctionBodyStart
argument_list|()
name|override
block|;
name|void
name|EmitFunctionBodyEnd
argument_list|()
name|override
block|;
name|void
name|emitImplicitDef
argument_list|(
argument|const MachineInstr *MI
argument_list|)
specifier|const
name|override
block|;
name|void
name|EmitInstruction
argument_list|(
argument|const MachineInstr *
argument_list|)
name|override
block|;
name|void
name|lowerToMCInst
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|MCInst
operator|&
name|OutMI
argument_list|)
block|;
name|bool
name|lowerOperand
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|,
name|MCOperand
operator|&
name|MCOp
argument_list|)
block|;
name|MCOperand
name|GetSymbolRef
argument_list|(
specifier|const
name|MCSymbol
operator|*
name|Symbol
argument_list|)
block|;
name|unsigned
name|encodeVirtualRegister
argument_list|(
argument|unsigned Reg
argument_list|)
block|;
name|void
name|EmitAlignment
argument_list|(
argument|unsigned NumBits
argument_list|,
argument|const GlobalValue *GV = nullptr
argument_list|)
specifier|const
block|{}
name|void
name|printVecModifiedImmediate
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|,
specifier|const
name|char
operator|*
name|Modifier
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|void
name|printMemOperand
argument_list|(
argument|const MachineInstr *MI
argument_list|,
argument|int opNum
argument_list|,
argument|raw_ostream&O
argument_list|,
argument|const char *Modifier = nullptr
argument_list|)
block|;
name|void
name|printImplicitDef
argument_list|(
argument|const MachineInstr *MI
argument_list|,
argument|raw_ostream&O
argument_list|)
specifier|const
block|;
name|void
name|printModuleLevelGV
argument_list|(
specifier|const
name|GlobalVariable
operator|*
name|GVar
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|,
name|bool
operator|=
name|false
argument_list|)
block|;
name|void
name|printParamName
argument_list|(
argument|int paramIndex
argument_list|,
argument|raw_ostream&O
argument_list|)
block|;
name|void
name|printParamName
argument_list|(
argument|Function::const_arg_iterator I
argument_list|,
argument|int paramIndex
argument_list|,
argument|raw_ostream&O
argument_list|)
block|;
name|void
name|emitGlobals
argument_list|(
specifier|const
name|Module
operator|&
name|M
argument_list|)
block|;
name|void
name|emitHeader
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|,
specifier|const
name|NVPTXSubtarget
operator|&
name|STI
argument_list|)
block|;
name|void
name|emitKernelFunctionDirectives
argument_list|(
argument|const Function&F
argument_list|,
argument|raw_ostream&O
argument_list|)
specifier|const
block|;
name|void
name|emitVirtualRegister
argument_list|(
argument|unsigned int vr
argument_list|,
argument|raw_ostream&
argument_list|)
block|;
name|void
name|emitFunctionExternParamList
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|)
block|;
name|void
name|emitFunctionParamList
argument_list|(
specifier|const
name|Function
operator|*
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|void
name|emitFunctionParamList
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|void
name|setAndEmitFunctionVirtualRegisters
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|)
block|;
name|void
name|emitFunctionTempData
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|,
name|unsigned
operator|&
name|FrameSize
argument_list|)
block|;
name|bool
name|isImageType
argument_list|(
specifier|const
name|Type
operator|*
name|Ty
argument_list|)
block|;
name|void
name|printReturnValStr
argument_list|(
specifier|const
name|Function
operator|*
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|void
name|printReturnValStr
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
block|;
name|bool
name|PrintAsmOperand
argument_list|(
argument|const MachineInstr *MI
argument_list|,
argument|unsigned OpNo
argument_list|,
argument|unsigned AsmVariant
argument_list|,
argument|const char *ExtraCode
argument_list|,
argument|raw_ostream&
argument_list|)
name|override
block|;
name|void
name|printOperand
argument_list|(
argument|const MachineInstr *MI
argument_list|,
argument|int opNum
argument_list|,
argument|raw_ostream&O
argument_list|,
argument|const char *Modifier = nullptr
argument_list|)
block|;
name|bool
name|PrintAsmMemoryOperand
argument_list|(
argument|const MachineInstr *MI
argument_list|,
argument|unsigned OpNo
argument_list|,
argument|unsigned AsmVariant
argument_list|,
argument|const char *ExtraCode
argument_list|,
argument|raw_ostream&
argument_list|)
name|override
block|;
specifier|const
name|MCExpr
operator|*
name|lowerConstantForGV
argument_list|(
argument|const Constant *CV
argument_list|,
argument|bool ProcessingGeneric
argument_list|)
block|;
name|void
name|printMCExpr
argument_list|(
specifier|const
name|MCExpr
operator|&
name|Expr
argument_list|,
name|raw_ostream
operator|&
name|OS
argument_list|)
block|;
name|protected
operator|:
name|bool
name|doInitialization
argument_list|(
argument|Module&M
argument_list|)
name|override
block|;
name|bool
name|doFinalization
argument_list|(
argument|Module&M
argument_list|)
name|override
block|;
name|private
operator|:
name|std
operator|::
name|string
name|CurrentBankselLabelInBasicBlock
block|;
name|bool
name|GlobalsEmitted
block|;
comment|// This is specific per MachineFunction.
specifier|const
name|MachineRegisterInfo
operator|*
name|MRI
block|;
comment|// The contents are specific for each
comment|// MachineFunction. But the size of the
comment|// array is not.
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|VRegMap
expr_stmt|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|TargetRegisterClass
operator|*
operator|,
name|VRegMap
operator|>
name|VRegRCMap
expr_stmt|;
name|VRegRCMap
name|VRegMapping
decl_stmt|;
comment|// Cache the subtarget here.
specifier|const
name|NVPTXSubtarget
modifier|*
name|nvptxSubtarget
decl_stmt|;
comment|// Build the map between type name and ID based on module's type
comment|// symbol table.
name|std
operator|::
name|map
operator|<
specifier|const
name|Type
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|TypeNameMap
expr_stmt|;
comment|// List of variables demoted to a function scope.
name|std
operator|::
name|map
operator|<
specifier|const
name|Function
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
specifier|const
name|GlobalVariable
operator|*
operator|>
expr|>
name|localDecls
expr_stmt|;
comment|// To record filename to ID mapping
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|unsigned
operator|>
name|filenameMap
expr_stmt|;
name|void
name|recordAndEmitFilenames
parameter_list|(
name|Module
modifier|&
parameter_list|)
function_decl|;
name|void
name|emitPTXGlobalVariable
parameter_list|(
specifier|const
name|GlobalVariable
modifier|*
name|GVar
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
name|void
name|emitPTXAddressSpace
argument_list|(
name|unsigned
name|int
name|AddressSpace
argument_list|,
name|raw_ostream
operator|&
name|O
argument_list|)
decl|const
decl_stmt|;
name|std
operator|::
name|string
name|getPTXFundamentalTypeStr
argument_list|(
argument|const Type *Ty
argument_list|,
argument|bool = true
argument_list|)
specifier|const
expr_stmt|;
name|void
name|printScalarConstant
parameter_list|(
specifier|const
name|Constant
modifier|*
name|CPV
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
name|void
name|printFPConstant
parameter_list|(
specifier|const
name|ConstantFP
modifier|*
name|Fp
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
name|void
name|bufferLEByte
parameter_list|(
specifier|const
name|Constant
modifier|*
name|CPV
parameter_list|,
name|int
name|Bytes
parameter_list|,
name|AggBuffer
modifier|*
name|aggBuffer
parameter_list|)
function_decl|;
name|void
name|bufferAggregateConstant
parameter_list|(
specifier|const
name|Constant
modifier|*
name|CV
parameter_list|,
name|AggBuffer
modifier|*
name|aggBuffer
parameter_list|)
function_decl|;
name|void
name|printOperandProper
parameter_list|(
specifier|const
name|MachineOperand
modifier|&
name|MO
parameter_list|)
function_decl|;
name|void
name|emitLinkageDirective
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|V
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
name|void
name|emitDeclarations
parameter_list|(
specifier|const
name|Module
modifier|&
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
name|void
name|emitDeclaration
parameter_list|(
specifier|const
name|Function
modifier|*
parameter_list|,
name|raw_ostream
modifier|&
name|O
parameter_list|)
function_decl|;
specifier|static
specifier|const
name|char
modifier|*
name|getRegisterName
parameter_list|(
name|unsigned
name|RegNo
parameter_list|)
function_decl|;
name|void
name|emitDemotedVars
parameter_list|(
specifier|const
name|Function
modifier|*
parameter_list|,
name|raw_ostream
modifier|&
parameter_list|)
function_decl|;
name|bool
name|lowerImageHandleOperand
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|,
name|unsigned
name|OpNo
parameter_list|,
name|MCOperand
modifier|&
name|MCOp
parameter_list|)
function_decl|;
name|void
name|lowerImageHandleSymbol
parameter_list|(
name|unsigned
name|Index
parameter_list|,
name|MCOperand
modifier|&
name|MCOp
parameter_list|)
function_decl|;
name|bool
name|isLoopHeaderOfNoUnroll
argument_list|(
specifier|const
name|MachineBasicBlock
operator|&
name|MBB
argument_list|)
decl|const
decl_stmt|;
name|LineReader
modifier|*
name|reader
decl_stmt|;
name|LineReader
modifier|*
name|getReader
argument_list|(
name|std
operator|::
name|string
argument_list|)
decl_stmt|;
comment|// Used to control the need to emit .generic() in the initializer of
comment|// module scope variables.
comment|// Although ptx supports the hybrid mode like the following,
comment|//    .global .u32 a;
comment|//    .global .u32 b;
comment|//    .global .u32 addr[] = {a, generic(b)}
comment|// we have difficulty representing the difference in the NVVM IR.
comment|//
comment|// Since the address value should always be generic in CUDA C and always
comment|// be specific in OpenCL, we use this simple control here.
comment|//
name|bool
name|EmitGeneric
decl_stmt|;
name|public
label|:
name|NVPTXAsmPrinter
argument_list|(
name|TargetMachine
operator|&
name|TM
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|MCStreamer
operator|>
name|Streamer
argument_list|)
operator|:
name|AsmPrinter
argument_list|(
name|TM
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Streamer
argument_list|)
argument_list|)
operator|,
name|EmitGeneric
argument_list|(
argument|static_cast<NVPTXTargetMachine&>(TM).getDrvInterface() ==                     NVPTX::CUDA
argument_list|)
block|{
name|CurrentBankselLabelInBasicBlock
operator|=
literal|""
block|;
name|reader
operator|=
name|nullptr
block|;   }
operator|~
name|NVPTXAsmPrinter
argument_list|()
block|{
if|if
condition|(
operator|!
name|reader
condition|)
name|delete
name|reader
decl_stmt|;
block|}
name|bool
name|runOnMachineFunction
parameter_list|(
name|MachineFunction
modifier|&
name|F
parameter_list|)
function|override
block|{
name|nvptxSubtarget
operator|=
operator|&
name|F
operator|.
name|getSubtarget
operator|<
name|NVPTXSubtarget
operator|>
operator|(
operator|)
expr_stmt|;
return|return
name|AsmPrinter
operator|::
name|runOnMachineFunction
argument_list|(
name|F
argument_list|)
return|;
block|}
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
name|override
block|{
name|AU
operator|.
name|addRequired
operator|<
name|MachineLoopInfo
operator|>
operator|(
operator|)
expr_stmt|;
name|AsmPrinter
operator|::
name|getAnalysisUsage
argument_list|(
name|AU
argument_list|)
expr_stmt|;
block|}
name|bool
name|ignoreLoc
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
parameter_list|)
function_decl|;
name|std
operator|::
name|string
name|getVirtualRegisterName
argument_list|(
argument|unsigned
argument_list|)
specifier|const
expr_stmt|;
name|DebugLoc
name|prevDebugLoc
decl_stmt|;
name|void
name|emitLineNumberAsDotLoc
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end of namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

