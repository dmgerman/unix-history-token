begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ARMBaseInfo.h - Top level definitions for ARM -------- --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains small standalone helper functions and enum definitions for
end_comment

begin_comment
comment|// the ARM target useful for the compiler back-end and the MC libraries.
end_comment

begin_comment
comment|// As such, it deliberately does not include references to LLVM core
end_comment

begin_comment
comment|// code gen types, passes, etc..
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMBASEINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMBASEINFO_H
end_define

begin_include
include|#
directive|include
file|"ARMMCTargetDesc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// Enums corresponding to ARM condition codes
name|namespace
name|ARMCC
block|{
comment|// The CondCodes constants map directly to the 4-bit encoding of the
comment|// condition field for predicated instructions.
enum|enum
name|CondCodes
block|{
comment|// Meaning (integer)          Meaning (floating-point)
name|EQ
block|,
comment|// Equal                      Equal
name|NE
block|,
comment|// Not equal                  Not equal, or unordered
name|HS
block|,
comment|// Carry set>, ==, or unordered
name|LO
block|,
comment|// Carry clear                Less than
name|MI
block|,
comment|// Minus, negative            Less than
name|PL
block|,
comment|// Plus, positive or zero>, ==, or unordered
name|VS
block|,
comment|// Overflow                   Unordered
name|VC
block|,
comment|// No overflow                Not unordered
name|HI
block|,
comment|// Unsigned higher            Greater than, or unordered
name|LS
block|,
comment|// Unsigned lower or same     Less than or equal
name|GE
block|,
comment|// Greater than or equal      Greater than or equal
name|LT
block|,
comment|// Less than                  Less than, or unordered
name|GT
block|,
comment|// Greater than               Greater than
name|LE
block|,
comment|// Less than or equal<, ==, or unordered
name|AL
comment|// Always (unconditional)     Always (unconditional)
block|}
enum|;
specifier|inline
specifier|static
name|CondCodes
name|getOppositeCondition
parameter_list|(
name|CondCodes
name|CC
parameter_list|)
block|{
switch|switch
condition|(
name|CC
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown condition code"
argument_list|)
expr_stmt|;
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|HS
case|:
return|return
name|LO
return|;
case|case
name|LO
case|:
return|return
name|HS
return|;
case|case
name|MI
case|:
return|return
name|PL
return|;
case|case
name|PL
case|:
return|return
name|MI
return|;
case|case
name|VS
case|:
return|return
name|VC
return|;
case|case
name|VC
case|:
return|return
name|VS
return|;
case|case
name|HI
case|:
return|return
name|LS
return|;
case|case
name|LS
case|:
return|return
name|HI
return|;
case|case
name|GE
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GE
return|;
case|case
name|GT
case|:
return|return
name|LE
return|;
case|case
name|LE
case|:
return|return
name|GT
return|;
block|}
block|}
block|}
comment|// namespace ARMCC
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|ARMCondCodeToString
argument_list|(
name|ARMCC
operator|::
name|CondCodes
name|CC
argument_list|)
block|{
switch|switch
condition|(
name|CC
condition|)
block|{
case|case
name|ARMCC
operator|::
name|EQ
case|:
return|return
literal|"eq"
return|;
case|case
name|ARMCC
operator|::
name|NE
case|:
return|return
literal|"ne"
return|;
case|case
name|ARMCC
operator|::
name|HS
case|:
return|return
literal|"hs"
return|;
case|case
name|ARMCC
operator|::
name|LO
case|:
return|return
literal|"lo"
return|;
case|case
name|ARMCC
operator|::
name|MI
case|:
return|return
literal|"mi"
return|;
case|case
name|ARMCC
operator|::
name|PL
case|:
return|return
literal|"pl"
return|;
case|case
name|ARMCC
operator|::
name|VS
case|:
return|return
literal|"vs"
return|;
case|case
name|ARMCC
operator|::
name|VC
case|:
return|return
literal|"vc"
return|;
case|case
name|ARMCC
operator|::
name|HI
case|:
return|return
literal|"hi"
return|;
case|case
name|ARMCC
operator|::
name|LS
case|:
return|return
literal|"ls"
return|;
case|case
name|ARMCC
operator|::
name|GE
case|:
return|return
literal|"ge"
return|;
case|case
name|ARMCC
operator|::
name|LT
case|:
return|return
literal|"lt"
return|;
case|case
name|ARMCC
operator|::
name|GT
case|:
return|return
literal|"gt"
return|;
case|case
name|ARMCC
operator|::
name|LE
case|:
return|return
literal|"le"
return|;
case|case
name|ARMCC
operator|::
name|AL
case|:
return|return
literal|"al"
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unknown condition code"
argument_list|)
expr_stmt|;
block|}
name|namespace
name|ARM_PROC
block|{
enum|enum
name|IMod
block|{
name|IE
init|=
literal|2
block|,
name|ID
init|=
literal|3
block|}
enum|;
enum|enum
name|IFlags
block|{
name|F
init|=
literal|1
block|,
name|I
init|=
literal|2
block|,
name|A
init|=
literal|4
block|}
enum|;
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|IFlagsToString
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown iflags operand"
argument_list|)
expr_stmt|;
case|case
name|F
case|:
return|return
literal|"f"
return|;
case|case
name|I
case|:
return|return
literal|"i"
return|;
case|case
name|A
case|:
return|return
literal|"a"
return|;
block|}
block|}
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|IModToString
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown imod operand"
argument_list|)
expr_stmt|;
case|case
name|IE
case|:
return|return
literal|"ie"
return|;
case|case
name|ID
case|:
return|return
literal|"id"
return|;
block|}
block|}
block|}
name|namespace
name|ARM_MB
block|{
comment|// The Memory Barrier Option constants map directly to the 4-bit encoding of
comment|// the option field for memory barrier operations.
enum|enum
name|MemBOpt
block|{
name|RESERVED_0
init|=
literal|0
block|,
name|OSHLD
init|=
literal|1
block|,
name|OSHST
init|=
literal|2
block|,
name|OSH
init|=
literal|3
block|,
name|RESERVED_4
init|=
literal|4
block|,
name|NSHLD
init|=
literal|5
block|,
name|NSHST
init|=
literal|6
block|,
name|NSH
init|=
literal|7
block|,
name|RESERVED_8
init|=
literal|8
block|,
name|ISHLD
init|=
literal|9
block|,
name|ISHST
init|=
literal|10
block|,
name|ISH
init|=
literal|11
block|,
name|RESERVED_12
init|=
literal|12
block|,
name|LD
init|=
literal|13
block|,
name|ST
init|=
literal|14
block|,
name|SY
init|=
literal|15
block|}
enum|;
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|MemBOptToString
parameter_list|(
name|unsigned
name|val
parameter_list|,
name|bool
name|HasV8
parameter_list|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown memory operation"
argument_list|)
expr_stmt|;
case|case
name|SY
case|:
return|return
literal|"sy"
return|;
case|case
name|ST
case|:
return|return
literal|"st"
return|;
case|case
name|LD
case|:
return|return
name|HasV8
condition|?
literal|"ld"
else|:
literal|"#0xd"
return|;
case|case
name|RESERVED_12
case|:
return|return
literal|"#0xc"
return|;
case|case
name|ISH
case|:
return|return
literal|"ish"
return|;
case|case
name|ISHST
case|:
return|return
literal|"ishst"
return|;
case|case
name|ISHLD
case|:
return|return
name|HasV8
condition|?
literal|"ishld"
else|:
literal|"#0x9"
return|;
case|case
name|RESERVED_8
case|:
return|return
literal|"#0x8"
return|;
case|case
name|NSH
case|:
return|return
literal|"nsh"
return|;
case|case
name|NSHST
case|:
return|return
literal|"nshst"
return|;
case|case
name|NSHLD
case|:
return|return
name|HasV8
condition|?
literal|"nshld"
else|:
literal|"#0x5"
return|;
case|case
name|RESERVED_4
case|:
return|return
literal|"#0x4"
return|;
case|case
name|OSH
case|:
return|return
literal|"osh"
return|;
case|case
name|OSHST
case|:
return|return
literal|"oshst"
return|;
case|case
name|OSHLD
case|:
return|return
name|HasV8
condition|?
literal|"oshld"
else|:
literal|"#0x1"
return|;
case|case
name|RESERVED_0
case|:
return|return
literal|"#0x0"
return|;
block|}
block|}
block|}
comment|// namespace ARM_MB
name|namespace
name|ARM_ISB
block|{
enum|enum
name|InstSyncBOpt
block|{
name|RESERVED_0
init|=
literal|0
block|,
name|RESERVED_1
init|=
literal|1
block|,
name|RESERVED_2
init|=
literal|2
block|,
name|RESERVED_3
init|=
literal|3
block|,
name|RESERVED_4
init|=
literal|4
block|,
name|RESERVED_5
init|=
literal|5
block|,
name|RESERVED_6
init|=
literal|6
block|,
name|RESERVED_7
init|=
literal|7
block|,
name|RESERVED_8
init|=
literal|8
block|,
name|RESERVED_9
init|=
literal|9
block|,
name|RESERVED_10
init|=
literal|10
block|,
name|RESERVED_11
init|=
literal|11
block|,
name|RESERVED_12
init|=
literal|12
block|,
name|RESERVED_13
init|=
literal|13
block|,
name|RESERVED_14
init|=
literal|14
block|,
name|SY
init|=
literal|15
block|}
enum|;
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|InstSyncBOptToString
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown memory operation"
argument_list|)
expr_stmt|;
case|case
name|RESERVED_0
case|:
return|return
literal|"#0x0"
return|;
case|case
name|RESERVED_1
case|:
return|return
literal|"#0x1"
return|;
case|case
name|RESERVED_2
case|:
return|return
literal|"#0x2"
return|;
case|case
name|RESERVED_3
case|:
return|return
literal|"#0x3"
return|;
case|case
name|RESERVED_4
case|:
return|return
literal|"#0x4"
return|;
case|case
name|RESERVED_5
case|:
return|return
literal|"#0x5"
return|;
case|case
name|RESERVED_6
case|:
return|return
literal|"#0x6"
return|;
case|case
name|RESERVED_7
case|:
return|return
literal|"#0x7"
return|;
case|case
name|RESERVED_8
case|:
return|return
literal|"#0x8"
return|;
case|case
name|RESERVED_9
case|:
return|return
literal|"#0x9"
return|;
case|case
name|RESERVED_10
case|:
return|return
literal|"#0xa"
return|;
case|case
name|RESERVED_11
case|:
return|return
literal|"#0xb"
return|;
case|case
name|RESERVED_12
case|:
return|return
literal|"#0xc"
return|;
case|case
name|RESERVED_13
case|:
return|return
literal|"#0xd"
return|;
case|case
name|RESERVED_14
case|:
return|return
literal|"#0xe"
return|;
case|case
name|SY
case|:
return|return
literal|"sy"
return|;
block|}
block|}
block|}
comment|// namespace ARM_ISB
comment|/// isARMLowRegister - Returns true if the register is a low register (r0-r7).
comment|///
specifier|static
specifier|inline
name|bool
name|isARMLowRegister
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|using
name|namespace
name|ARM
decl_stmt|;
switch|switch
condition|(
name|Reg
condition|)
block|{
case|case
name|R0
case|:
case|case
name|R1
case|:
case|case
name|R2
case|:
case|case
name|R3
case|:
case|case
name|R4
case|:
case|case
name|R5
case|:
case|case
name|R6
case|:
case|case
name|R7
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// ARMII - This namespace holds all of the target specific flags that
comment|/// instruction info tracks.
comment|///
name|namespace
name|ARMII
block|{
comment|/// ARM Index Modes
enum|enum
name|IndexMode
block|{
name|IndexModeNone
init|=
literal|0
block|,
name|IndexModePre
init|=
literal|1
block|,
name|IndexModePost
init|=
literal|2
block|,
name|IndexModeUpd
init|=
literal|3
block|}
enum|;
comment|/// ARM Addressing Modes
enum|enum
name|AddrMode
block|{
name|AddrModeNone
init|=
literal|0
block|,
name|AddrMode1
init|=
literal|1
block|,
name|AddrMode2
init|=
literal|2
block|,
name|AddrMode3
init|=
literal|3
block|,
name|AddrMode4
init|=
literal|4
block|,
name|AddrMode5
init|=
literal|5
block|,
name|AddrMode6
init|=
literal|6
block|,
name|AddrModeT1_1
init|=
literal|7
block|,
name|AddrModeT1_2
init|=
literal|8
block|,
name|AddrModeT1_4
init|=
literal|9
block|,
name|AddrModeT1_s
init|=
literal|10
block|,
comment|// i8 * 4 for pc and sp relative data
name|AddrModeT2_i12
init|=
literal|11
block|,
name|AddrModeT2_i8
init|=
literal|12
block|,
name|AddrModeT2_so
init|=
literal|13
block|,
name|AddrModeT2_pc
init|=
literal|14
block|,
comment|// +/- i12 for pc relative data
name|AddrModeT2_i8s4
init|=
literal|15
block|,
comment|// i8 * 4
name|AddrMode_i12
init|=
literal|16
block|}
enum|;
specifier|inline
specifier|static
specifier|const
name|char
modifier|*
name|AddrModeToString
parameter_list|(
name|AddrMode
name|addrmode
parameter_list|)
block|{
switch|switch
condition|(
name|addrmode
condition|)
block|{
case|case
name|AddrModeNone
case|:
return|return
literal|"AddrModeNone"
return|;
case|case
name|AddrMode1
case|:
return|return
literal|"AddrMode1"
return|;
case|case
name|AddrMode2
case|:
return|return
literal|"AddrMode2"
return|;
case|case
name|AddrMode3
case|:
return|return
literal|"AddrMode3"
return|;
case|case
name|AddrMode4
case|:
return|return
literal|"AddrMode4"
return|;
case|case
name|AddrMode5
case|:
return|return
literal|"AddrMode5"
return|;
case|case
name|AddrMode6
case|:
return|return
literal|"AddrMode6"
return|;
case|case
name|AddrModeT1_1
case|:
return|return
literal|"AddrModeT1_1"
return|;
case|case
name|AddrModeT1_2
case|:
return|return
literal|"AddrModeT1_2"
return|;
case|case
name|AddrModeT1_4
case|:
return|return
literal|"AddrModeT1_4"
return|;
case|case
name|AddrModeT1_s
case|:
return|return
literal|"AddrModeT1_s"
return|;
case|case
name|AddrModeT2_i12
case|:
return|return
literal|"AddrModeT2_i12"
return|;
case|case
name|AddrModeT2_i8
case|:
return|return
literal|"AddrModeT2_i8"
return|;
case|case
name|AddrModeT2_so
case|:
return|return
literal|"AddrModeT2_so"
return|;
case|case
name|AddrModeT2_pc
case|:
return|return
literal|"AddrModeT2_pc"
return|;
case|case
name|AddrModeT2_i8s4
case|:
return|return
literal|"AddrModeT2_i8s4"
return|;
case|case
name|AddrMode_i12
case|:
return|return
literal|"AddrMode_i12"
return|;
block|}
block|}
comment|/// Target Operand Flag enum.
enum|enum
name|TOF
block|{
comment|//===------------------------------------------------------------------===//
comment|// ARM Specific MachineOperand flags.
name|MO_NO_FLAG
init|=
literal|0
block|,
comment|/// MO_LO16 - On a symbol operand, this represents a relocation containing
comment|/// lower 16 bit of the address. Used only via movw instruction.
name|MO_LO16
init|=
literal|0x1
block|,
comment|/// MO_HI16 - On a symbol operand, this represents a relocation containing
comment|/// higher 16 bit of the address. Used only via movt instruction.
name|MO_HI16
init|=
literal|0x2
block|,
comment|/// MO_OPTION_MASK - Most flags are mutually exclusive; this mask selects
comment|/// just that part of the flag set.
name|MO_OPTION_MASK
init|=
literal|0x0f
block|,
comment|/// MO_SBREL - On a symbol operand, this represents a static base relative
comment|/// relocation. Used in movw and movt instructions.
name|MO_SBREL
init|=
literal|0x10
block|,
comment|/// MO_DLLIMPORT - On a symbol operand, this represents that the reference
comment|/// to the symbol is for an import stub.  This is used for DLL import
comment|/// storage class indication on Windows.
name|MO_DLLIMPORT
init|=
literal|0x20
block|,
comment|/// MO_SECREL - On a symbol operand this indicates that the immediate is
comment|/// the offset from beginning of section.
comment|///
comment|/// This is the TLS offset for the COFF/Windows TLS mechanism.
name|MO_SECREL
init|=
literal|0x40
block|,
comment|/// MO_NONLAZY - This is an independent flag, on a symbol operand "FOO" it
comment|/// represents a symbol which, if indirect, will get special Darwin mangling
comment|/// as a non-lazy-ptr indirect symbol (i.e. "L_FOO$non_lazy_ptr"). Can be
comment|/// combined with MO_LO16, MO_HI16 or MO_NO_FLAG (in a constant-pool, for
comment|/// example).
name|MO_NONLAZY
init|=
literal|0x80
block|,
comment|// It's undefined behaviour if an enum overflows the range between its
comment|// smallest and largest values, but since these are |ed together, it can
comment|// happen. Put a sentinel in (values of this enum are stored as "unsigned
comment|// char").
name|MO_UNUSED_MAXIMUM
init|=
literal|0xff
block|}
enum|;
enum|enum
block|{
comment|//===------------------------------------------------------------------===//
comment|// Instruction Flags.
comment|//===------------------------------------------------------------------===//
comment|// This four-bit field describes the addressing mode used.
name|AddrModeMask
init|=
literal|0x1f
block|,
comment|// The AddrMode enums are declared in ARMBaseInfo.h
comment|// IndexMode - Unindex, pre-indexed, or post-indexed are valid for load
comment|// and store ops only.  Generic "updating" flag is used for ld/st multiple.
comment|// The index mode enums are declared in ARMBaseInfo.h
name|IndexModeShift
init|=
literal|5
block|,
name|IndexModeMask
init|=
literal|3
operator|<<
name|IndexModeShift
block|,
comment|//===------------------------------------------------------------------===//
comment|// Instruction encoding formats.
comment|//
name|FormShift
init|=
literal|7
block|,
name|FormMask
init|=
literal|0x3f
operator|<<
name|FormShift
block|,
comment|// Pseudo instructions
name|Pseudo
init|=
literal|0
operator|<<
name|FormShift
block|,
comment|// Multiply instructions
name|MulFrm
init|=
literal|1
operator|<<
name|FormShift
block|,
comment|// Branch instructions
name|BrFrm
init|=
literal|2
operator|<<
name|FormShift
block|,
name|BrMiscFrm
init|=
literal|3
operator|<<
name|FormShift
block|,
comment|// Data Processing instructions
name|DPFrm
init|=
literal|4
operator|<<
name|FormShift
block|,
name|DPSoRegFrm
init|=
literal|5
operator|<<
name|FormShift
block|,
comment|// Load and Store
name|LdFrm
init|=
literal|6
operator|<<
name|FormShift
block|,
name|StFrm
init|=
literal|7
operator|<<
name|FormShift
block|,
name|LdMiscFrm
init|=
literal|8
operator|<<
name|FormShift
block|,
name|StMiscFrm
init|=
literal|9
operator|<<
name|FormShift
block|,
name|LdStMulFrm
init|=
literal|10
operator|<<
name|FormShift
block|,
name|LdStExFrm
init|=
literal|11
operator|<<
name|FormShift
block|,
comment|// Miscellaneous arithmetic instructions
name|ArithMiscFrm
init|=
literal|12
operator|<<
name|FormShift
block|,
name|SatFrm
init|=
literal|13
operator|<<
name|FormShift
block|,
comment|// Extend instructions
name|ExtFrm
init|=
literal|14
operator|<<
name|FormShift
block|,
comment|// VFP formats
name|VFPUnaryFrm
init|=
literal|15
operator|<<
name|FormShift
block|,
name|VFPBinaryFrm
init|=
literal|16
operator|<<
name|FormShift
block|,
name|VFPConv1Frm
init|=
literal|17
operator|<<
name|FormShift
block|,
name|VFPConv2Frm
init|=
literal|18
operator|<<
name|FormShift
block|,
name|VFPConv3Frm
init|=
literal|19
operator|<<
name|FormShift
block|,
name|VFPConv4Frm
init|=
literal|20
operator|<<
name|FormShift
block|,
name|VFPConv5Frm
init|=
literal|21
operator|<<
name|FormShift
block|,
name|VFPLdStFrm
init|=
literal|22
operator|<<
name|FormShift
block|,
name|VFPLdStMulFrm
init|=
literal|23
operator|<<
name|FormShift
block|,
name|VFPMiscFrm
init|=
literal|24
operator|<<
name|FormShift
block|,
comment|// Thumb format
name|ThumbFrm
init|=
literal|25
operator|<<
name|FormShift
block|,
comment|// Miscelleaneous format
name|MiscFrm
init|=
literal|26
operator|<<
name|FormShift
block|,
comment|// NEON formats
name|NGetLnFrm
init|=
literal|27
operator|<<
name|FormShift
block|,
name|NSetLnFrm
init|=
literal|28
operator|<<
name|FormShift
block|,
name|NDupFrm
init|=
literal|29
operator|<<
name|FormShift
block|,
name|NLdStFrm
init|=
literal|30
operator|<<
name|FormShift
block|,
name|N1RegModImmFrm
init|=
literal|31
operator|<<
name|FormShift
block|,
name|N2RegFrm
init|=
literal|32
operator|<<
name|FormShift
block|,
name|NVCVTFrm
init|=
literal|33
operator|<<
name|FormShift
block|,
name|NVDupLnFrm
init|=
literal|34
operator|<<
name|FormShift
block|,
name|N2RegVShLFrm
init|=
literal|35
operator|<<
name|FormShift
block|,
name|N2RegVShRFrm
init|=
literal|36
operator|<<
name|FormShift
block|,
name|N3RegFrm
init|=
literal|37
operator|<<
name|FormShift
block|,
name|N3RegVShFrm
init|=
literal|38
operator|<<
name|FormShift
block|,
name|NVExtFrm
init|=
literal|39
operator|<<
name|FormShift
block|,
name|NVMulSLFrm
init|=
literal|40
operator|<<
name|FormShift
block|,
name|NVTBLFrm
init|=
literal|41
operator|<<
name|FormShift
block|,
comment|//===------------------------------------------------------------------===//
comment|// Misc flags.
comment|// UnaryDP - Indicates this is a unary data processing instruction, i.e.
comment|// it doesn't have a Rn operand.
name|UnaryDP
init|=
literal|1
operator|<<
literal|13
block|,
comment|// Xform16Bit - Indicates this Thumb2 instruction may be transformed into
comment|// a 16-bit Thumb instruction if certain conditions are met.
name|Xform16Bit
init|=
literal|1
operator|<<
literal|14
block|,
comment|// ThumbArithFlagSetting - The instruction is a 16-bit flag setting Thumb
comment|// instruction. Used by the parser to determine whether to require the 'S'
comment|// suffix on the mnemonic (when not in an IT block) or preclude it (when
comment|// in an IT block).
name|ThumbArithFlagSetting
init|=
literal|1
operator|<<
literal|18
block|,
comment|//===------------------------------------------------------------------===//
comment|// Code domain.
name|DomainShift
init|=
literal|15
block|,
name|DomainMask
init|=
literal|7
operator|<<
name|DomainShift
block|,
name|DomainGeneral
init|=
literal|0
operator|<<
name|DomainShift
block|,
name|DomainVFP
init|=
literal|1
operator|<<
name|DomainShift
block|,
name|DomainNEON
init|=
literal|2
operator|<<
name|DomainShift
block|,
name|DomainNEONA8
init|=
literal|4
operator|<<
name|DomainShift
block|,
comment|//===------------------------------------------------------------------===//
comment|// Field shifts - such shifts are used to set field while generating
comment|// machine instructions.
comment|//
comment|// FIXME: This list will need adjusting/fixing as the MC code emitter
comment|// takes shape and the ARMCodeEmitter.cpp bits go away.
name|ShiftTypeShift
init|=
literal|4
block|,
name|M_BitShift
init|=
literal|5
block|,
name|ShiftImmShift
init|=
literal|5
block|,
name|ShiftShift
init|=
literal|7
block|,
name|N_BitShift
init|=
literal|7
block|,
name|ImmHiShift
init|=
literal|8
block|,
name|SoRotImmShift
init|=
literal|8
block|,
name|RegRsShift
init|=
literal|8
block|,
name|ExtRotImmShift
init|=
literal|10
block|,
name|RegRdLoShift
init|=
literal|12
block|,
name|RegRdShift
init|=
literal|12
block|,
name|RegRdHiShift
init|=
literal|16
block|,
name|RegRnShift
init|=
literal|16
block|,
name|S_BitShift
init|=
literal|20
block|,
name|W_BitShift
init|=
literal|21
block|,
name|AM3_I_BitShift
init|=
literal|22
block|,
name|D_BitShift
init|=
literal|22
block|,
name|U_BitShift
init|=
literal|23
block|,
name|P_BitShift
init|=
literal|24
block|,
name|I_BitShift
init|=
literal|25
block|,
name|CondShift
init|=
literal|28
block|}
enum|;
block|}
comment|// end namespace ARMII
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm;
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

