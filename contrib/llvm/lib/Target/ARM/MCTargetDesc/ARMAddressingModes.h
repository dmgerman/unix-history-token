begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ARMAddressingModes.h - ARM Addressing Modes -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the ARM addressing mode implementation stuff.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMADDRESSINGMODES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_ARM_MCTARGETDESC_ARMADDRESSINGMODES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// ARM_AM - ARM Addressing Mode Stuff
name|namespace
name|ARM_AM
block|{
enum|enum
name|ShiftOpc
block|{
name|no_shift
init|=
literal|0
block|,
name|asr
block|,
name|lsl
block|,
name|lsr
block|,
name|ror
block|,
name|rrx
block|}
enum|;
enum|enum
name|AddrOpc
block|{
name|sub
init|=
literal|0
block|,
name|add
block|}
enum|;
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getAddrOpcStr
parameter_list|(
name|AddrOpc
name|Op
parameter_list|)
block|{
return|return
name|Op
operator|==
name|sub
condition|?
literal|"-"
else|:
literal|""
return|;
block|}
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getShiftOpcStr
parameter_list|(
name|ShiftOpc
name|Op
parameter_list|)
block|{
switch|switch
condition|(
name|Op
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown shift opc!"
argument_list|)
expr_stmt|;
case|case
name|ARM_AM
operator|::
name|asr
case|:
return|return
literal|"asr"
return|;
case|case
name|ARM_AM
operator|::
name|lsl
case|:
return|return
literal|"lsl"
return|;
case|case
name|ARM_AM
operator|::
name|lsr
case|:
return|return
literal|"lsr"
return|;
case|case
name|ARM_AM
operator|::
name|ror
case|:
return|return
literal|"ror"
return|;
case|case
name|ARM_AM
operator|::
name|rrx
case|:
return|return
literal|"rrx"
return|;
block|}
block|}
specifier|static
specifier|inline
name|unsigned
name|getShiftOpcEncoding
parameter_list|(
name|ShiftOpc
name|Op
parameter_list|)
block|{
switch|switch
condition|(
name|Op
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown shift opc!"
argument_list|)
expr_stmt|;
case|case
name|ARM_AM
operator|::
name|asr
case|:
return|return
literal|2
return|;
case|case
name|ARM_AM
operator|::
name|lsl
case|:
return|return
literal|0
return|;
case|case
name|ARM_AM
operator|::
name|lsr
case|:
return|return
literal|1
return|;
case|case
name|ARM_AM
operator|::
name|ror
case|:
return|return
literal|3
return|;
block|}
block|}
enum|enum
name|AMSubMode
block|{
name|bad_am_submode
init|=
literal|0
block|,
name|ia
block|,
name|ib
block|,
name|da
block|,
name|db
block|}
enum|;
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getAMSubModeStr
parameter_list|(
name|AMSubMode
name|Mode
parameter_list|)
block|{
switch|switch
condition|(
name|Mode
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown addressing sub-mode!"
argument_list|)
expr_stmt|;
case|case
name|ARM_AM
operator|::
name|ia
case|:
return|return
literal|"ia"
return|;
case|case
name|ARM_AM
operator|::
name|ib
case|:
return|return
literal|"ib"
return|;
case|case
name|ARM_AM
operator|::
name|da
case|:
return|return
literal|"da"
return|;
case|case
name|ARM_AM
operator|::
name|db
case|:
return|return
literal|"db"
return|;
block|}
block|}
comment|/// rotr32 - Rotate a 32-bit unsigned value right by a specified # bits.
comment|///
specifier|static
specifier|inline
name|unsigned
name|rotr32
parameter_list|(
name|unsigned
name|Val
parameter_list|,
name|unsigned
name|Amt
parameter_list|)
block|{
name|assert
argument_list|(
name|Amt
operator|<
literal|32
operator|&&
literal|"Invalid rotate amount"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Val
operator|>>
name|Amt
operator|)
operator||
operator|(
name|Val
operator|<<
operator|(
operator|(
literal|32
operator|-
name|Amt
operator|)
operator|&
literal|31
operator|)
operator|)
return|;
block|}
comment|/// rotl32 - Rotate a 32-bit unsigned value left by a specified # bits.
comment|///
specifier|static
specifier|inline
name|unsigned
name|rotl32
parameter_list|(
name|unsigned
name|Val
parameter_list|,
name|unsigned
name|Amt
parameter_list|)
block|{
name|assert
argument_list|(
name|Amt
operator|<
literal|32
operator|&&
literal|"Invalid rotate amount"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Val
operator|<<
name|Amt
operator|)
operator||
operator|(
name|Val
operator|>>
operator|(
operator|(
literal|32
operator|-
name|Amt
operator|)
operator|&
literal|31
operator|)
operator|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #1: shift_operand with registers
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This 'addressing mode' is used for arithmetic instructions.  It can
comment|// represent things like:
comment|//   reg
comment|//   reg [asr|lsl|lsr|ror|rrx] reg
comment|//   reg [asr|lsl|lsr|ror|rrx] imm
comment|//
comment|// This is stored three operands [rega, regb, opc].  The first is the base
comment|// reg, the second is the shift amount (or reg0 if not present or imm).  The
comment|// third operand encodes the shift opcode and the imm if a reg isn't present.
comment|//
specifier|static
specifier|inline
name|unsigned
name|getSORegOpc
parameter_list|(
name|ShiftOpc
name|ShOp
parameter_list|,
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
name|ShOp
operator||
operator|(
name|Imm
operator|<<
literal|3
operator|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getSORegOffset
parameter_list|(
name|unsigned
name|Op
parameter_list|)
block|{
return|return
name|Op
operator|>>
literal|3
return|;
block|}
specifier|static
specifier|inline
name|ShiftOpc
name|getSORegShOp
parameter_list|(
name|unsigned
name|Op
parameter_list|)
block|{
return|return
call|(
name|ShiftOpc
call|)
argument_list|(
name|Op
operator|&
literal|7
argument_list|)
return|;
block|}
comment|/// getSOImmValImm - Given an encoded imm field for the reg/imm form, return
comment|/// the 8-bit imm value.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValImm
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
name|Imm
operator|&
literal|0xFF
return|;
block|}
comment|/// getSOImmValRot - Given an encoded imm field for the reg/imm form, return
comment|/// the rotate amount.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValRot
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|>>
literal|8
operator|)
operator|*
literal|2
return|;
block|}
comment|/// getSOImmValRotate - Try to handle Imm with an immediate shifter operand,
comment|/// computing the rotate amount to use.  If this immediate value cannot be
comment|/// handled with a single shifter-op, determine a good rotate amount that will
comment|/// take a maximal chunk of bits out of the immediate.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValRotate
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially shifter_operands with a rotate
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the rotate amount.
name|unsigned
name|TZ
init|=
name|countTrailingZeros
argument_list|(
name|Imm
argument_list|)
decl_stmt|;
comment|// Rotate amount must be even.  Something like 0x200 must be rotated 8 bits,
comment|// not 9.
name|unsigned
name|RotAmt
init|=
name|TZ
operator|&
operator|~
literal|1
decl_stmt|;
comment|// If we can handle this spread, return it.
if|if
condition|(
operator|(
name|rotr32
argument_list|(
name|Imm
argument_list|,
name|RotAmt
argument_list|)
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
comment|// For values like 0xF000000F, we should ignore the low 6 bits, then
comment|// retry the hunt.
if|if
condition|(
name|Imm
operator|&
literal|63U
condition|)
block|{
name|unsigned
name|TZ2
init|=
name|countTrailingZeros
argument_list|(
name|Imm
operator|&
operator|~
literal|63U
argument_list|)
decl_stmt|;
name|unsigned
name|RotAmt2
init|=
name|TZ2
operator|&
operator|~
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|rotr32
argument_list|(
name|Imm
argument_list|,
name|RotAmt2
argument_list|)
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|32
operator|-
name|RotAmt2
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
block|}
comment|// Otherwise, we have no way to cover this span of bits with a single
comment|// shifter_op immediate.  Return a chunk of bits that will be useful to
comment|// handle.
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
block|}
comment|/// getSOImmVal - Given a 32-bit immediate, if it is something that can fit
comment|/// into an shifter_operand immediate operand, return the 12-bit encoding for
comment|/// it.  If not, return -1.
specifier|static
specifier|inline
name|int
name|getSOImmVal
parameter_list|(
name|unsigned
name|Arg
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially shifter_operands with a rotate
comment|// of zero.
if|if
condition|(
operator|(
name|Arg
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
name|Arg
return|;
name|unsigned
name|RotAmt
init|=
name|getSOImmValRotate
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
comment|// If this cannot be handled with a single shifter_op, bail out.
if|if
condition|(
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|RotAmt
argument_list|)
operator|&
name|Arg
condition|)
return|return
operator|-
literal|1
return|;
comment|// Encode this correctly.
return|return
name|rotl32
argument_list|(
name|Arg
argument_list|,
name|RotAmt
argument_list|)
operator||
operator|(
operator|(
name|RotAmt
operator|>>
literal|1
operator|)
operator|<<
literal|8
operator|)
return|;
block|}
comment|/// isSOImmTwoPartVal - Return true if the specified value can be obtained by
comment|/// or'ing together two SOImmVal's.
specifier|static
specifier|inline
name|bool
name|isSOImmTwoPartVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with a single shifter_op, bail out.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
if|if
condition|(
name|V
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|// If this can be handled with two shifter_op's, accept.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getSOImmTwoPartFirst - If V is a value that satisfies isSOImmTwoPartVal,
comment|/// return the first chunk of it.
specifier|static
specifier|inline
name|unsigned
name|getSOImmTwoPartFirst
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
return|return
name|rotr32
argument_list|(
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
return|;
block|}
comment|/// getSOImmTwoPartSecond - If V is a value that satisfies isSOImmTwoPartVal,
comment|/// return the second chunk of it.
specifier|static
specifier|inline
name|unsigned
name|getSOImmTwoPartSecond
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// Mask out the first hunk.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
comment|// Take what's left.
name|assert
argument_list|(
name|V
operator|==
operator|(
name|rotr32
argument_list|(
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
operator|)
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
comment|/// getThumbImmValShift - Try to handle Imm with a 8-bit immediate followed
comment|/// by a left shift. Returns the shift amount to use.
specifier|static
specifier|inline
name|unsigned
name|getThumbImmValShift
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially immediate operand with a shift
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the shift amount.
return|return
name|countTrailingZeros
argument_list|(
name|Imm
argument_list|)
return|;
block|}
comment|/// isThumbImmShiftedVal - Return true if the specified value can be obtained
comment|/// by left shifting a 8-bit immediate.
specifier|static
specifier|inline
name|bool
name|isThumbImmShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with
name|V
operator|=
operator|(
operator|~
literal|255U
operator|<<
name|getThumbImmValShift
argument_list|(
name|V
argument_list|)
operator|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getThumbImm16ValShift - Try to handle Imm with a 16-bit immediate followed
comment|/// by a left shift. Returns the shift amount to use.
specifier|static
specifier|inline
name|unsigned
name|getThumbImm16ValShift
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 16-bit (or less) immediates are trivially immediate operand with a shift
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|65535U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the shift amount.
return|return
name|countTrailingZeros
argument_list|(
name|Imm
argument_list|)
return|;
block|}
comment|/// isThumbImm16ShiftedVal - Return true if the specified value can be
comment|/// obtained by left shifting a 16-bit immediate.
specifier|static
specifier|inline
name|bool
name|isThumbImm16ShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with
name|V
operator|=
operator|(
operator|~
literal|65535U
operator|<<
name|getThumbImm16ValShift
argument_list|(
name|V
argument_list|)
operator|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getThumbImmNonShiftedVal - If V is a value that satisfies
comment|/// isThumbImmShiftedVal, return the non-shiftd value.
specifier|static
specifier|inline
name|unsigned
name|getThumbImmNonShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
return|return
name|V
operator|>>
name|getThumbImmValShift
argument_list|(
name|V
argument_list|)
return|;
block|}
comment|/// getT2SOImmValSplat - Return the 12-bit encoded representation
comment|/// if the specified value can be obtained by splatting the low 8 bits
comment|/// into every other byte or every byte of a 32-bit value. i.e.,
comment|///     00000000 00000000 00000000 abcdefgh    control = 0
comment|///     00000000 abcdefgh 00000000 abcdefgh    control = 1
comment|///     abcdefgh 00000000 abcdefgh 00000000    control = 2
comment|///     abcdefgh abcdefgh abcdefgh abcdefgh    control = 3
comment|/// Return -1 if none of the above apply.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmValSplatVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|,
name|Vs
decl_stmt|,
name|Imm
decl_stmt|;
comment|// control = 0
if|if
condition|(
operator|(
name|V
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0
condition|)
return|return
name|V
return|;
comment|// If the value is zeroes in the first byte, just shift those off
name|Vs
operator|=
operator|(
operator|(
name|V
operator|&
literal|0xff
operator|)
operator|==
literal|0
operator|)
condition|?
name|V
operator|>>
literal|8
else|:
name|V
expr_stmt|;
comment|// Any passing value only has 8 bits of payload, splatted across the word
name|Imm
operator|=
name|Vs
operator|&
literal|0xff
expr_stmt|;
comment|// Likewise, any passing values have the payload splatted into the 3rd byte
name|u
operator|=
name|Imm
operator||
operator|(
name|Imm
operator|<<
literal|16
operator|)
expr_stmt|;
comment|// control = 1 or 2
if|if
condition|(
name|Vs
operator|==
name|u
condition|)
return|return
operator|(
operator|(
operator|(
name|Vs
operator|==
name|V
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
name|Imm
return|;
comment|// control = 3
if|if
condition|(
name|Vs
operator|==
operator|(
name|u
operator||
operator|(
name|u
operator|<<
literal|8
operator|)
operator|)
condition|)
return|return
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
name|Imm
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/// getT2SOImmValRotateVal - Return the 12-bit encoded representation if the
comment|/// specified value is a rotated 8-bit value. Return -1 if no rotation
comment|/// encoding is possible.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmValRotateVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
name|unsigned
name|RotAmt
init|=
name|countLeadingZeros
argument_list|(
name|V
argument_list|)
decl_stmt|;
if|if
condition|(
name|RotAmt
operator|>=
literal|24
condition|)
return|return
operator|-
literal|1
return|;
comment|// If 'Arg' can be handled with a single shifter_op return the value.
if|if
condition|(
operator|(
name|rotr32
argument_list|(
literal|0xff000000U
argument_list|,
name|RotAmt
argument_list|)
operator|&
name|V
operator|)
operator|==
name|V
condition|)
return|return
operator|(
name|rotr32
argument_list|(
name|V
argument_list|,
literal|24
operator|-
name|RotAmt
argument_list|)
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|RotAmt
operator|+
literal|8
operator|)
operator|<<
literal|7
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/// getT2SOImmVal - Given a 32-bit immediate, if it is something that can fit
comment|/// into a Thumb-2 shifter_operand immediate operand, return the 12-bit
comment|/// encoding for it.  If not, return -1.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmVal
parameter_list|(
name|unsigned
name|Arg
parameter_list|)
block|{
comment|// If 'Arg' is an 8-bit splat, then get the encoded value.
name|int
name|Splat
init|=
name|getT2SOImmValSplatVal
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|Splat
operator|!=
operator|-
literal|1
condition|)
return|return
name|Splat
return|;
comment|// If 'Arg' can be handled with a single shifter_op return the value.
name|int
name|Rot
init|=
name|getT2SOImmValRotateVal
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|Rot
operator|!=
operator|-
literal|1
condition|)
return|return
name|Rot
return|;
return|return
operator|-
literal|1
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmValRotate
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
if|if
condition|(
operator|(
name|V
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the rotate amount.
name|unsigned
name|RotAmt
init|=
name|countTrailingZeros
argument_list|(
name|V
argument_list|)
decl_stmt|;
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isT2SOImmTwoPartVal
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
name|unsigned
name|V
init|=
name|Imm
decl_stmt|;
comment|// Passing values can be any combination of splat values and shifter
comment|// values. If this can be handled with a single shifter or splat, bail
comment|// out. Those should be handled directly, not with a two-part val.
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getT2SOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
if|if
condition|(
name|V
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|// If this can be handled as an immediate, accept.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|// Likewise, try masking out a splat value first.
name|V
operator|=
name|Imm
expr_stmt|;
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
operator|&
literal|0xff00ff00U
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|V
operator|&=
operator|~
literal|0xff00ff00U
expr_stmt|;
elseif|else
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
operator|&
literal|0x00ff00ffU
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|V
operator|&=
operator|~
literal|0x00ff00ffU
expr_stmt|;
comment|// If what's left can be handled as an immediate, accept.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|// Otherwise, do not accept.
return|return
name|false
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmTwoPartFirst
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
name|assert
argument_list|(
name|isT2SOImmTwoPartVal
argument_list|(
name|Imm
argument_list|)
operator|&&
literal|"Immedate cannot be encoded as two part immediate!"
argument_list|)
expr_stmt|;
comment|// Try a shifter operand as one part
name|unsigned
name|V
init|=
name|rotr32
argument_list|(
operator|~
literal|255
argument_list|,
name|getT2SOImmValRotate
argument_list|(
name|Imm
argument_list|)
argument_list|)
operator|&
name|Imm
decl_stmt|;
comment|// If the rest is encodable as an immediate, then return it.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|V
return|;
comment|// Try masking out a splat value first.
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|Imm
operator|&
literal|0xff00ff00U
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|Imm
operator|&
literal|0xff00ff00U
return|;
comment|// The other splat is all that's left as an option.
name|assert
argument_list|(
name|getT2SOImmValSplatVal
argument_list|(
name|Imm
operator|&
literal|0x00ff00ffU
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|Imm
operator|&
literal|0x00ff00ffU
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmTwoPartSecond
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// Mask out the first hunk
name|Imm
operator|^=
name|getT2SOImmTwoPartFirst
argument_list|(
name|Imm
argument_list|)
expr_stmt|;
comment|// Return what's left
name|assert
argument_list|(
name|getT2SOImmVal
argument_list|(
name|Imm
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
literal|"Unable to encode second part of T2 two part SO immediate"
argument_list|)
expr_stmt|;
return|return
name|Imm
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #2
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for most simple load/store instructions.
comment|//
comment|// addrmode2 := reg +/- reg shop imm
comment|// addrmode2 := reg +/- imm12
comment|//
comment|// The first operand is always a Reg.  The second operand is a reg if in
comment|// reg/reg form, otherwise it's reg#0.  The third field encodes the operation
comment|// in bit 12, the immediate in bits 0-11, and the shift op in 13-15. The
comment|// fourth operand 16-17 encodes the index mode.
comment|//
comment|// If this addressing mode is a frame index (before prolog/epilog insertion
comment|// and code rewriting), this operand will have the form:  FI#, reg0,<offs>
comment|// with no shift amount for the frame offset.
comment|//
specifier|static
specifier|inline
name|unsigned
name|getAM2Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|Imm12
parameter_list|,
name|ShiftOpc
name|SO
parameter_list|,
name|unsigned
name|IdxMode
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|Imm12
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|&&
literal|"Imm too large!"
argument_list|)
expr_stmt|;
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
name|Imm12
operator||
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|12
operator|)
operator||
operator|(
name|SO
operator|<<
literal|13
operator|)
operator||
operator|(
name|IdxMode
operator|<<
literal|16
operator|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM2Offset
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
name|AM2Opc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM2Op
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM2Opc
operator|>>
literal|12
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
specifier|static
specifier|inline
name|ShiftOpc
name|getAM2ShiftOpc
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
call|(
name|ShiftOpc
call|)
argument_list|(
operator|(
name|AM2Opc
operator|>>
literal|13
operator|)
operator|&
literal|7
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM2IdxMode
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
operator|(
name|AM2Opc
operator|>>
literal|16
operator|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #3
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for sign-extending loads, and load/store-pair instructions.
comment|//
comment|// addrmode3 := reg +/- reg
comment|// addrmode3 := reg +/- imm8
comment|//
comment|// The first operand is always a Reg.  The second operand is a reg if in
comment|// reg/reg form, otherwise it's reg#0.  The third field encodes the operation
comment|// in bit 8, the immediate in bits 0-7. The fourth operand 9-10 encodes the
comment|// index mode.
comment|/// getAM3Opc - This function encodes the addrmode3 opc field.
specifier|static
specifier|inline
name|unsigned
name|getAM3Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|char
name|Offset
parameter_list|,
name|unsigned
name|IdxMode
init|=
literal|0
parameter_list|)
block|{
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|8
operator|)
operator||
name|Offset
operator||
operator|(
name|IdxMode
operator|<<
literal|9
operator|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|char
name|getAM3Offset
parameter_list|(
name|unsigned
name|AM3Opc
parameter_list|)
block|{
return|return
name|AM3Opc
operator|&
literal|0xFF
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM3Op
parameter_list|(
name|unsigned
name|AM3Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM3Opc
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM3IdxMode
parameter_list|(
name|unsigned
name|AM3Opc
parameter_list|)
block|{
return|return
operator|(
name|AM3Opc
operator|>>
literal|9
operator|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #4
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for load / store multiple instructions.
comment|//
comment|// addrmode4 := reg,<mode>
comment|//
comment|// The four modes are:
comment|//    IA - Increment after
comment|//    IB - Increment before
comment|//    DA - Decrement after
comment|//    DB - Decrement before
comment|// For VFP instructions, only the IA and DB modes are valid.
specifier|static
specifier|inline
name|AMSubMode
name|getAM4SubMode
parameter_list|(
name|unsigned
name|Mode
parameter_list|)
block|{
return|return
call|(
name|AMSubMode
call|)
argument_list|(
name|Mode
operator|&
literal|0x7
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM4ModeImm
parameter_list|(
name|AMSubMode
name|SubMode
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|SubMode
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #5
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for coprocessor instructions, such as FP load/stores.
comment|//
comment|// addrmode5 := reg +/- imm8*4
comment|//
comment|// The first operand is always a Reg.  The second operand encodes the
comment|// operation in bit 8 and the immediate in bits 0-7.
comment|/// getAM5Opc - This function encodes the addrmode5 opc field.
specifier|static
specifier|inline
name|unsigned
name|getAM5Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|char
name|Offset
parameter_list|)
block|{
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|8
operator|)
operator||
name|Offset
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|char
name|getAM5Offset
parameter_list|(
name|unsigned
name|AM5Opc
parameter_list|)
block|{
return|return
name|AM5Opc
operator|&
literal|0xFF
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM5Op
parameter_list|(
name|unsigned
name|AM5Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM5Opc
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #6
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for NEON load / store instructions.
comment|//
comment|// addrmode6 := reg with optional alignment
comment|//
comment|// This is stored in two operands [regaddr, align].  The first is the
comment|// address register.  The second operand is the value of the alignment
comment|// specifier in bytes or zero if no explicit alignment.
comment|// Valid alignments depend on the specific instruction.
comment|//===--------------------------------------------------------------------===//
comment|// NEON Modified Immediates
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// Several NEON instructions (e.g., VMOV) take a "modified immediate"
comment|// vector operand, where a small immediate encoded in the instruction
comment|// specifies a full NEON vector value.  These modified immediates are
comment|// represented here as encoded integers.  The low 8 bits hold the immediate
comment|// value; bit 12 holds the "Op" field of the instruction, and bits 11-8 hold
comment|// the "Cmode" field of the instruction.  The interfaces below treat the
comment|// Op and Cmode values as a single 5-bit value.
specifier|static
specifier|inline
name|unsigned
name|createNEONModImm
parameter_list|(
name|unsigned
name|OpCmode
parameter_list|,
name|unsigned
name|Val
parameter_list|)
block|{
return|return
operator|(
name|OpCmode
operator|<<
literal|8
operator|)
operator||
name|Val
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getNEONModImmOpCmode
parameter_list|(
name|unsigned
name|ModImm
parameter_list|)
block|{
return|return
operator|(
name|ModImm
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getNEONModImmVal
parameter_list|(
name|unsigned
name|ModImm
parameter_list|)
block|{
return|return
name|ModImm
operator|&
literal|0xff
return|;
block|}
comment|/// decodeNEONModImm - Decode a NEON modified immediate value into the
comment|/// element value and the element size in bits.  (If the element size is
comment|/// smaller than the vector, it is splatted into all the elements.)
specifier|static
specifier|inline
name|uint64_t
name|decodeNEONModImm
parameter_list|(
name|unsigned
name|ModImm
parameter_list|,
name|unsigned
modifier|&
name|EltBits
parameter_list|)
block|{
name|unsigned
name|OpCmode
init|=
name|getNEONModImmOpCmode
argument_list|(
name|ModImm
argument_list|)
decl_stmt|;
name|unsigned
name|Imm8
init|=
name|getNEONModImmVal
argument_list|(
name|ModImm
argument_list|)
decl_stmt|;
name|uint64_t
name|Val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OpCmode
operator|==
literal|0xe
condition|)
block|{
comment|// 8-bit vector elements
name|Val
operator|=
name|Imm8
expr_stmt|;
name|EltBits
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OpCmode
operator|&
literal|0xc
operator|)
operator|==
literal|0x8
condition|)
block|{
comment|// 16-bit vector elements
name|unsigned
name|ByteNum
init|=
operator|(
name|OpCmode
operator|&
literal|0x6
operator|)
operator|>>
literal|1
decl_stmt|;
name|Val
operator|=
name|Imm8
operator|<<
operator|(
literal|8
operator|*
name|ByteNum
operator|)
expr_stmt|;
name|EltBits
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OpCmode
operator|&
literal|0x8
operator|)
operator|==
literal|0
condition|)
block|{
comment|// 32-bit vector elements, zero with one byte set
name|unsigned
name|ByteNum
init|=
operator|(
name|OpCmode
operator|&
literal|0x6
operator|)
operator|>>
literal|1
decl_stmt|;
name|Val
operator|=
name|Imm8
operator|<<
operator|(
literal|8
operator|*
name|ByteNum
operator|)
expr_stmt|;
name|EltBits
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OpCmode
operator|&
literal|0xe
operator|)
operator|==
literal|0xc
condition|)
block|{
comment|// 32-bit vector elements, one byte with low bits set
name|unsigned
name|ByteNum
init|=
literal|1
operator|+
operator|(
name|OpCmode
operator|&
literal|0x1
operator|)
decl_stmt|;
name|Val
operator|=
operator|(
name|Imm8
operator|<<
operator|(
literal|8
operator|*
name|ByteNum
operator|)
operator|)
operator||
operator|(
literal|0xffff
operator|>>
operator|(
literal|8
operator|*
operator|(
literal|2
operator|-
name|ByteNum
operator|)
operator|)
operator|)
expr_stmt|;
name|EltBits
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpCmode
operator|==
literal|0x1e
condition|)
block|{
comment|// 64-bit vector elements
for|for
control|(
name|unsigned
name|ByteNum
init|=
literal|0
init|;
name|ByteNum
operator|<
literal|8
condition|;
operator|++
name|ByteNum
control|)
block|{
if|if
condition|(
operator|(
name|ModImm
operator|>>
name|ByteNum
operator|)
operator|&
literal|1
condition|)
name|Val
operator||=
operator|(
name|uint64_t
operator|)
literal|0xff
operator|<<
operator|(
literal|8
operator|*
name|ByteNum
operator|)
expr_stmt|;
block|}
name|EltBits
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|llvm_unreachable
argument_list|(
literal|"Unsupported NEON immediate"
argument_list|)
expr_stmt|;
block|}
return|return
name|Val
return|;
block|}
comment|// Generic validation for single-byte immediate (0X00, 00X0, etc).
specifier|static
specifier|inline
name|bool
name|isNEONBytesplat
parameter_list|(
name|unsigned
name|Value
parameter_list|,
name|unsigned
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
name|Size
operator|>=
literal|1
operator|&&
name|Size
operator|<=
literal|4
operator|&&
literal|"Invalid size"
argument_list|)
expr_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Value
operator|&
literal|0xff
condition|)
name|count
operator|++
expr_stmt|;
name|Value
operator|>>=
literal|8
expr_stmt|;
block|}
return|return
name|count
operator|==
literal|1
return|;
block|}
comment|/// Checks if Value is a correct immediate for instructions like VBIC/VORR.
specifier|static
specifier|inline
name|bool
name|isNEONi16splat
parameter_list|(
name|unsigned
name|Value
parameter_list|)
block|{
if|if
condition|(
name|Value
operator|>
literal|0xffff
condition|)
return|return
name|false
return|;
comment|// i16 value with set bits only in one byte X0 or 0X.
return|return
name|Value
operator|==
literal|0
operator|||
name|isNEONBytesplat
argument_list|(
name|Value
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|// Encode NEON 16 bits Splat immediate for instructions like VBIC/VORR
specifier|static
specifier|inline
name|unsigned
name|encodeNEONi16splat
parameter_list|(
name|unsigned
name|Value
parameter_list|)
block|{
name|assert
argument_list|(
name|isNEONi16splat
argument_list|(
name|Value
argument_list|)
operator|&&
literal|"Invalid NEON splat value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Value
operator|>=
literal|0x100
condition|)
name|Value
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator||
literal|0xa00
expr_stmt|;
else|else
name|Value
operator||=
literal|0x800
expr_stmt|;
return|return
name|Value
return|;
block|}
comment|/// Checks if Value is a correct immediate for instructions like VBIC/VORR.
specifier|static
specifier|inline
name|bool
name|isNEONi32splat
parameter_list|(
name|unsigned
name|Value
parameter_list|)
block|{
comment|// i32 value with set bits only in one byte X000, 0X00, 00X0, or 000X.
return|return
name|Value
operator|==
literal|0
operator|||
name|isNEONBytesplat
argument_list|(
name|Value
argument_list|,
literal|4
argument_list|)
return|;
block|}
comment|/// Encode NEON 32 bits Splat immediate for instructions like VBIC/VORR.
specifier|static
specifier|inline
name|unsigned
name|encodeNEONi32splat
parameter_list|(
name|unsigned
name|Value
parameter_list|)
block|{
name|assert
argument_list|(
name|isNEONi32splat
argument_list|(
name|Value
argument_list|)
operator|&&
literal|"Invalid NEON splat value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Value
operator|>=
literal|0x100
operator|&&
name|Value
operator|<=
literal|0xff00
condition|)
name|Value
operator|=
operator|(
name|Value
operator|>>
literal|8
operator|)
operator||
literal|0x200
expr_stmt|;
elseif|else
if|if
condition|(
name|Value
operator|>
literal|0xffff
operator|&&
name|Value
operator|<=
literal|0xff0000
condition|)
name|Value
operator|=
operator|(
name|Value
operator|>>
literal|16
operator|)
operator||
literal|0x400
expr_stmt|;
elseif|else
if|if
condition|(
name|Value
operator|>
literal|0xffffff
condition|)
name|Value
operator|=
operator|(
name|Value
operator|>>
literal|24
operator|)
operator||
literal|0x600
expr_stmt|;
return|return
name|Value
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Floating-point Immediates
comment|//
specifier|static
specifier|inline
name|float
name|getFPImmFloat
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// We expect an 8-bit binary encoding of a floating-point number here.
union|union
block|{
name|uint32_t
name|I
decl_stmt|;
name|float
name|F
decl_stmt|;
block|}
name|FPUnion
union|;
name|uint8_t
name|Sign
init|=
operator|(
name|Imm
operator|>>
literal|7
operator|)
operator|&
literal|0x1
decl_stmt|;
name|uint8_t
name|Exp
init|=
operator|(
name|Imm
operator|>>
literal|4
operator|)
operator|&
literal|0x7
decl_stmt|;
name|uint8_t
name|Mantissa
init|=
name|Imm
operator|&
literal|0xf
decl_stmt|;
comment|//   8-bit FP    iEEEE Float Encoding
comment|//   abcd efgh   aBbbbbbc defgh000 00000000 00000000
comment|//
comment|// where B = NOT(b);
name|FPUnion
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
name|Sign
operator|<<
literal|31
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
operator|(
name|Exp
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
operator|<<
literal|30
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
operator|(
name|Exp
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|?
literal|0x1f
else|:
literal|0
operator|)
operator|<<
literal|25
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
operator|(
name|Exp
operator|&
literal|0x3
operator|)
operator|<<
literal|23
expr_stmt|;
name|FPUnion
operator|.
name|I
operator||=
name|Mantissa
operator|<<
literal|19
expr_stmt|;
return|return
name|FPUnion
operator|.
name|F
return|;
block|}
comment|/// getFP32Imm - Return an 8-bit floating-point version of the 32-bit
comment|/// floating-point value. If the value cannot be represented as an 8-bit
comment|/// floating-point value, then return -1.
specifier|static
specifier|inline
name|int
name|getFP32Imm
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|)
block|{
name|uint32_t
name|Sign
init|=
name|Imm
operator|.
name|lshr
argument_list|(
literal|31
argument_list|)
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|1
decl_stmt|;
name|int32_t
name|Exp
init|=
operator|(
name|Imm
operator|.
name|lshr
argument_list|(
literal|23
argument_list|)
operator|.
name|getSExtValue
argument_list|()
operator|&
literal|0xff
operator|)
operator|-
literal|127
decl_stmt|;
comment|// -126 to 127
name|int64_t
name|Mantissa
init|=
name|Imm
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|0x7fffff
decl_stmt|;
comment|// 23 bits
comment|// We can handle 4 bits of mantissa.
comment|// mantissa = (16+UInt(e:f:g:h))/16.
if|if
condition|(
name|Mantissa
operator|&
literal|0x7ffff
condition|)
return|return
operator|-
literal|1
return|;
name|Mantissa
operator|>>=
literal|19
expr_stmt|;
if|if
condition|(
operator|(
name|Mantissa
operator|&
literal|0xf
operator|)
operator|!=
name|Mantissa
condition|)
return|return
operator|-
literal|1
return|;
comment|// We can handle 3 bits of exponent: exp == UInt(NOT(b):c:d)-3
if|if
condition|(
name|Exp
operator|<
operator|-
literal|3
operator|||
name|Exp
operator|>
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|Exp
operator|=
operator|(
operator|(
name|Exp
operator|+
literal|3
operator|)
operator|&
literal|0x7
operator|)
operator|^
literal|4
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|Sign
operator|<<
literal|7
operator|)
operator||
operator|(
name|Exp
operator|<<
literal|4
operator|)
operator||
name|Mantissa
return|;
block|}
specifier|static
specifier|inline
name|int
name|getFP32Imm
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|FPImm
parameter_list|)
block|{
return|return
name|getFP32Imm
argument_list|(
name|FPImm
operator|.
name|bitcastToAPInt
argument_list|()
argument_list|)
return|;
block|}
comment|/// getFP64Imm - Return an 8-bit floating-point version of the 64-bit
comment|/// floating-point value. If the value cannot be represented as an 8-bit
comment|/// floating-point value, then return -1.
specifier|static
specifier|inline
name|int
name|getFP64Imm
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|)
block|{
name|uint64_t
name|Sign
init|=
name|Imm
operator|.
name|lshr
argument_list|(
literal|63
argument_list|)
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|1
decl_stmt|;
name|int64_t
name|Exp
init|=
operator|(
name|Imm
operator|.
name|lshr
argument_list|(
literal|52
argument_list|)
operator|.
name|getSExtValue
argument_list|()
operator|&
literal|0x7ff
operator|)
operator|-
literal|1023
decl_stmt|;
comment|// -1022 to 1023
name|uint64_t
name|Mantissa
init|=
name|Imm
operator|.
name|getZExtValue
argument_list|()
operator|&
literal|0xfffffffffffffULL
decl_stmt|;
comment|// We can handle 4 bits of mantissa.
comment|// mantissa = (16+UInt(e:f:g:h))/16.
if|if
condition|(
name|Mantissa
operator|&
literal|0xffffffffffffULL
condition|)
return|return
operator|-
literal|1
return|;
name|Mantissa
operator|>>=
literal|48
expr_stmt|;
if|if
condition|(
operator|(
name|Mantissa
operator|&
literal|0xf
operator|)
operator|!=
name|Mantissa
condition|)
return|return
operator|-
literal|1
return|;
comment|// We can handle 3 bits of exponent: exp == UInt(NOT(b):c:d)-3
if|if
condition|(
name|Exp
operator|<
operator|-
literal|3
operator|||
name|Exp
operator|>
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|Exp
operator|=
operator|(
operator|(
name|Exp
operator|+
literal|3
operator|)
operator|&
literal|0x7
operator|)
operator|^
literal|4
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|Sign
operator|<<
literal|7
operator|)
operator||
operator|(
name|Exp
operator|<<
literal|4
operator|)
operator||
name|Mantissa
return|;
block|}
specifier|static
specifier|inline
name|int
name|getFP64Imm
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|FPImm
parameter_list|)
block|{
return|return
name|getFP64Imm
argument_list|(
name|FPImm
operator|.
name|bitcastToAPInt
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// end namespace ARM_AM
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

