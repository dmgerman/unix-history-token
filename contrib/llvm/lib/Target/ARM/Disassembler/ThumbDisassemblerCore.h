begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ThumbDisassemblerCore.h - Thumb disassembler helpers -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the ARM Disassembler.
end_comment

begin_comment
comment|// It contains code for disassembling a Thumb instr.  It is to be included by
end_comment

begin_comment
comment|// ARMDisassemblerCore.cpp because it contains the static DisassembleThumbFrm()
end_comment

begin_comment
comment|// function which acts as the dispatcher to disassemble a Thumb instruction.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///////////////////////////////
end_comment

begin_comment
comment|//                           //
end_comment

begin_comment
comment|//     Utility Functions     //
end_comment

begin_comment
comment|//                           //
end_comment

begin_comment
comment|///////////////////////////////
end_comment

begin_comment
comment|// Utilities for 16-bit Thumb instructions.
end_comment

begin_comment
comment|/* 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0                [  tRt ]                       [ tRm ]  [ tRn ]  [ tRd ]                          D  [   Rm   ]  [  Rd ]                        [ imm3]                [    imm5    ]                    i     [    imm5   ]                             [       imm7      ]                          [       imm8         ]                [             imm11            ]              [   cond  ] */
end_comment

begin_comment
comment|// Extract tRt: Inst{10-8}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1tRt
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract tRm: Inst{8-6}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1tRm
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract tRn: Inst{5-3}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1tRn
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract tRd: Inst{2-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1tRd
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract [D:Rd]: Inst{7:2-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Rd
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|7
argument_list|)
operator|<<
literal|3
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract Rm: Inst{6-3}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Rm
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm3: Inst{8-6}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm3
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm5: Inst{10-6}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm5
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract i:imm5: Inst{9:7-3}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm6
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|9
argument_list|,
literal|9
argument_list|)
operator|<<
literal|5
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm7: Inst{6-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm7
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm8: Inst{7-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm8
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm11: Inst{10-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Imm11
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract cond: Inst{11-8}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getT1Cond
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|IsGPR
parameter_list|(
name|unsigned
name|RegClass
parameter_list|)
block|{
return|return
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
return|;
block|}
end_function

begin_comment
comment|// Utilities for 32-bit Thumb instructions.
end_comment

begin_comment
comment|// Extract imm4: Inst{19-16}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm4
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|19
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm3: Inst{14-12}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm3
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|14
argument_list|,
literal|12
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Extract imm8: Inst{7-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm8
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// A8.6.61 LDRB (immediate, Thumb) and friends
end_comment

begin_comment
comment|// +/-: Inst{9}
end_comment

begin_comment
comment|// imm8: Inst{7-0}
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm8
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|int
name|Offset
init|=
name|getImm8
argument_list|(
name|insn
argument_list|)
decl_stmt|;
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|9
argument_list|,
literal|9
argument_list|)
condition|?
name|Offset
else|:
operator|-
name|Offset
return|;
block|}
end_function

begin_comment
comment|// Extract imm12: Inst{11-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm12
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// A8.6.63 LDRB (literal) and friends
end_comment

begin_comment
comment|// +/-: Inst{23}
end_comment

begin_comment
comment|// imm12: Inst{11-0}
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm12
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|int
name|Offset
init|=
name|getImm12
argument_list|(
name|insn
argument_list|)
decl_stmt|;
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
condition|?
name|Offset
else|:
operator|-
name|Offset
return|;
block|}
end_function

begin_comment
comment|// Extract imm2: Inst{7-6}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm2
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// For BFI, BFC, t2SBFX, and t2UBFX.
end_comment

begin_comment
comment|// Extract lsb: Inst{14-12:7-6}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getLsb
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|getImm3
argument_list|(
name|insn
argument_list|)
operator|<<
literal|2
operator||
name|getImm2
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// For BFI and BFC.
end_comment

begin_comment
comment|// Extract msb: Inst{4-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getMsb
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// For t2SBFX and t2UBFX.
end_comment

begin_comment
comment|// Extract widthminus1: Inst{4-0}.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getWidthMinus1
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// For t2ADDri12 and t2SUBri12.
end_comment

begin_comment
comment|// imm12 = i:imm3:imm8;
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getIImm3Imm8
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
operator|<<
literal|11
operator||
name|getImm3
argument_list|(
name|insn
argument_list|)
operator|<<
literal|8
operator||
name|getImm8
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// For t2MOVi16 and t2MOVTi16.
end_comment

begin_comment
comment|// imm16 = imm4:i:imm3:imm8;
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getImm16
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|getImm4
argument_list|(
name|insn
argument_list|)
operator|<<
literal|12
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
operator|<<
literal|11
operator||
name|getImm3
argument_list|(
name|insn
argument_list|)
operator|<<
literal|8
operator||
name|getImm8
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Inst{5-4} encodes the shift type.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getShiftTypeBits
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Inst{14-12}:Inst{7-6} encodes the imm5 shift amount.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|getShiftAmtBits
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
return|return
name|getImm3
argument_list|(
name|insn
argument_list|)
operator|<<
literal|2
operator||
name|getImm2
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// A8.6.17 BFC
end_comment

begin_comment
comment|// Encoding T1 ARMv6T2, ARMv7
end_comment

begin_comment
comment|// LLVM-specific encoding for #<lsb> and #<width>
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|getBitfieldInvMask
parameter_list|(
name|uint32_t
name|insn
parameter_list|,
name|uint32_t
modifier|&
name|mask
parameter_list|)
block|{
name|uint32_t
name|lsb
init|=
name|getImm3
argument_list|(
name|insn
argument_list|)
operator|<<
literal|2
operator||
name|getImm2
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|uint32_t
name|msb
init|=
name|getMsb
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|uint32_t
name|Val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|msb
operator|<
name|lsb
condition|)
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Encoding error: msb< lsb\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|uint32_t
name|i
init|=
name|lsb
init|;
name|i
operator|<=
name|msb
condition|;
operator|++
name|i
control|)
name|Val
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|mask
operator|=
operator|~
name|Val
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A8.4 Shifts applied to a register
end_comment

begin_comment
comment|// A8.4.1 Constant shifts
end_comment

begin_comment
comment|// A8.4.3 Pseudocode details of instruction-specified shifts and rotates
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// decodeImmShift() returns the shift amount and the the shift opcode.
end_comment

begin_comment
comment|// Note that, as of Jan-06-2010, LLVM does not support rrx shifted operands yet.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|decodeImmShift
argument_list|(
name|unsigned
name|bits2
argument_list|,
name|unsigned
name|imm5
argument_list|,
name|ARM_AM
operator|::
name|ShiftOpc
operator|&
name|ShOp
argument_list|)
block|{
name|assert
argument_list|(
name|imm5
operator|<
literal|32
operator|&&
literal|"Invalid imm5 argument"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits2
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"No such value"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|ShOp
operator|=
name|ARM_AM
operator|::
name|lsl
expr_stmt|;
return|return
name|imm5
return|;
case|case
literal|1
case|:
name|ShOp
operator|=
name|ARM_AM
operator|::
name|lsr
expr_stmt|;
return|return
operator|(
name|imm5
operator|==
literal|0
condition|?
literal|32
else|:
name|imm5
operator|)
return|;
case|case
literal|2
case|:
name|ShOp
operator|=
name|ARM_AM
operator|::
name|asr
expr_stmt|;
return|return
operator|(
name|imm5
operator|==
literal|0
condition|?
literal|32
else|:
name|imm5
operator|)
return|;
case|case
literal|3
case|:
name|ShOp
operator|=
operator|(
name|imm5
operator|==
literal|0
condition|?
name|ARM_AM
operator|::
name|rrx
else|:
name|ARM_AM
operator|::
name|ror
operator|)
expr_stmt|;
return|return
operator|(
name|imm5
operator|==
literal|0
condition|?
literal|1
else|:
name|imm5
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// A6.3.2 Modified immediate constants in Thumb instructions
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ThumbExpandImm() returns the modified immediate constant given an imm12 for
end_comment

begin_comment
comment|// Thumb data-processing instructions with modified immediate.
end_comment

begin_comment
comment|// See also A6.3.1 Data-processing (modified immediate).
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|ThumbExpandImm
parameter_list|(
name|unsigned
name|imm12
parameter_list|)
block|{
name|assert
argument_list|(
name|imm12
operator|<=
literal|0xFFF
operator|&&
literal|"Invalid imm12 argument"
argument_list|)
expr_stmt|;
comment|// If the leading two bits is 0b00, the modified immediate constant is
comment|// obtained by splatting the low 8 bits into the first byte, every other byte,
comment|// or every byte of a 32-bit value.
comment|//
comment|// Otherwise, a rotate right of '1':imm12<6:0> by the amount imm12<11:7> is
comment|// performed.
if|if
condition|(
name|slice
argument_list|(
name|imm12
argument_list|,
literal|11
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|short
name|control
init|=
name|slice
argument_list|(
name|imm12
argument_list|,
literal|9
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|unsigned
name|imm8
init|=
name|slice
argument_list|(
name|imm12
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|control
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"No such value"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0
case|:
return|return
name|imm8
return|;
case|case
literal|1
case|:
return|return
name|imm8
operator|<<
literal|16
operator||
name|imm8
return|;
case|case
literal|2
case|:
return|return
name|imm8
operator|<<
literal|24
operator||
name|imm8
operator|<<
literal|8
return|;
case|case
literal|3
case|:
return|return
name|imm8
operator|<<
literal|24
operator||
name|imm8
operator|<<
literal|16
operator||
name|imm8
operator|<<
literal|8
operator||
name|imm8
return|;
block|}
block|}
else|else
block|{
comment|// A rotate is required.
name|unsigned
name|Val
init|=
literal|1
operator|<<
literal|7
operator||
name|slice
argument_list|(
name|imm12
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|Amt
init|=
name|slice
argument_list|(
name|imm12
argument_list|,
literal|11
argument_list|,
literal|7
argument_list|)
decl_stmt|;
return|return
name|ARM_AM
operator|::
name|rotr32
argument_list|(
name|Val
argument_list|,
name|Amt
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm32_B_EncodingT3
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|bool
name|S
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
decl_stmt|;
name|bool
name|J1
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|,
literal|13
argument_list|)
decl_stmt|;
name|bool
name|J2
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|unsigned
name|Imm21
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|21
argument_list|,
literal|16
argument_list|)
operator|<<
literal|12
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|S
condition|)
name|Imm21
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|J2
condition|)
name|Imm21
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
if|if
condition|(
name|J1
condition|)
name|Imm21
operator||=
literal|1
operator|<<
literal|18
expr_stmt|;
return|return
name|SignExtend32
operator|<
literal|21
operator|>
operator|(
name|Imm21
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm32_B_EncodingT4
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|unsigned
name|S
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
decl_stmt|;
name|bool
name|I1
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|,
literal|13
argument_list|)
operator|==
name|S
decl_stmt|;
name|bool
name|I2
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|11
argument_list|)
operator|==
name|S
decl_stmt|;
name|unsigned
name|Imm25
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|25
argument_list|,
literal|16
argument_list|)
operator|<<
literal|12
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|S
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|I1
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
if|if
condition|(
name|I2
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
return|return
name|SignExtend32
operator|<
literal|25
operator|>
operator|(
name|Imm25
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm32_BL
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|unsigned
name|S
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
decl_stmt|;
name|bool
name|I1
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|,
literal|13
argument_list|)
operator|==
name|S
decl_stmt|;
name|bool
name|I2
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|11
argument_list|)
operator|==
name|S
decl_stmt|;
name|unsigned
name|Imm25
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|25
argument_list|,
literal|16
argument_list|)
operator|<<
literal|12
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|S
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|I1
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
if|if
condition|(
name|I2
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
return|return
name|SignExtend32
operator|<
literal|25
operator|>
operator|(
name|Imm25
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|decodeImm32_BLX
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|unsigned
name|S
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|26
argument_list|,
literal|26
argument_list|)
decl_stmt|;
name|bool
name|I1
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|,
literal|13
argument_list|)
operator|==
name|S
decl_stmt|;
name|bool
name|I2
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|11
argument_list|)
operator|==
name|S
decl_stmt|;
name|unsigned
name|Imm25
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|25
argument_list|,
literal|16
argument_list|)
operator|<<
literal|12
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
operator|<<
literal|2
decl_stmt|;
if|if
condition|(
name|S
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|I1
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
if|if
condition|(
name|I2
condition|)
name|Imm25
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
return|return
name|SignExtend32
operator|<
literal|25
operator|>
operator|(
name|Imm25
operator|)
return|;
block|}
end_function

begin_comment
comment|// See, for example, A8.6.221 SXTAB16.
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|decodeRotate
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
name|unsigned
name|rotate
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
decl_stmt|;
return|return
name|rotate
operator|<<
literal|3
return|;
block|}
end_function

begin_comment
comment|///////////////////////////////////////////////
end_comment

begin_comment
comment|//                                           //
end_comment

begin_comment
comment|// Thumb1 instruction disassembly functions. //
end_comment

begin_comment
comment|//                                           //
end_comment

begin_comment
comment|///////////////////////////////////////////////
end_comment

begin_comment
comment|// See "Utilities for 16-bit Thumb instructions" for register naming convention.
end_comment

begin_comment
comment|// A6.2.1 Shift (immediate), add, subtract, move, and compare
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// shift immediate:         tRd CPSR tRn imm5
end_comment

begin_comment
comment|// add/sub register:        tRd CPSR tRn tRm
end_comment

begin_comment
comment|// add/sub 3-bit immediate: tRd CPSR tRn imm3
end_comment

begin_comment
comment|// add/sub 8-bit immediate: tRt CPSR tRt(TIED_TO) imm8
end_comment

begin_comment
comment|// mov/cmp immediate:       tRt [CPSR] imm8 (CPSR present for mov)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Special case:
end_comment

begin_comment
comment|// tMOVSr:                  tRd tRn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1General
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
name|bool
name|Imm3
init|=
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tADDi3
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSUBi3
operator|)
decl_stmt|;
comment|// Use Rt implies use imm8.
name|bool
name|UseRt
init|=
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tADDi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSUBi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tMOVi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tCMPi8
operator|)
decl_stmt|;
comment|// Add the destination operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|UseRt
condition|?
name|getT1tRt
argument_list|(
name|insn
argument_list|)
else|:
name|getT1tRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// Check whether the next operand to be added is a CCR Register.
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|CCRRegClassID
condition|)
block|{
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Optional def operand expected"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|B
operator|->
name|InITBlock
argument_list|()
condition|?
literal|0
else|:
name|ARM
operator|::
name|CPSR
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// Check whether the next operand to be added is a Thumb1 Register.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
literal|"More operands expected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
condition|)
block|{
comment|// For UseRt, the reg operand is tied to the first reg operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|UseRt
condition|?
name|getT1tRt
argument_list|(
name|insn
argument_list|)
else|:
name|getT1tRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// Special case for tMOVSr.
if|if
condition|(
name|OpIdx
operator|==
name|NumOps
condition|)
return|return
name|true
return|;
comment|// The next available operand is either a reg operand or an imm operand.
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
condition|)
block|{
comment|// Three register operand instructions.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Pure imm operand expected"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|UseRt
condition|?
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
else|:
operator|(
name|Imm3
condition|?
name|getT1Imm3
argument_list|(
name|insn
argument_list|)
else|:
name|getT1Imm5
argument_list|(
name|insn
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.2.2 Data-processing
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tCMPr, tTST, tCMN: tRd tRn
end_comment

begin_comment
comment|// tMVN, tRSB:        tRd CPSR tRn
end_comment

begin_comment
comment|// Others:            tRd CPSR tRd(TIED_TO) tRn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1DP
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|CCRRegClassID
operator|||
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|)
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
comment|// Add the destination operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// Check whether the next operand to be added is a CCR Register.
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|CCRRegClassID
condition|)
block|{
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Optional def operand expected"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|B
operator|->
name|InITBlock
argument_list|()
condition|?
literal|0
else|:
name|ARM
operator|::
name|CPSR
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// We have either { tRd(TIED_TO), tRn } or { tRn } remaining.
comment|// Process the TIED_TO operand first.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
literal|"Thumb reg operand expected"
argument_list|)
expr_stmt|;
name|int
name|Idx
decl_stmt|;
if|if
condition|(
operator|(
name|Idx
operator|=
name|TID
operator|.
name|getOperandConstraint
argument_list|(
name|OpIdx
argument_list|,
name|TOI
operator|::
name|TIED_TO
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// The reg operand is tied to the first reg operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Idx
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// Process possible next reg operand.
if|if
condition|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
condition|)
block|{
comment|// Add tRn operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.2.3 Special data instructions and branch and exchange
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tADDhirr: Rd Rd(TIED_TO) Rm
end_comment

begin_comment
comment|// tCMPhir:  Rd Rm
end_comment

begin_comment
comment|// tMOVr, tMOVgpr2gpr, tMOVgpr2tgpr, tMOVtgpr2gpr: Rd|tRd Rm|tRn
end_comment

begin_comment
comment|// tBX_RET: 0 operand
end_comment

begin_comment
comment|// tBX_RET_vararg: Rm
end_comment

begin_comment
comment|// tBLXr_r9: Rm
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1Special
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
comment|// tBX_RET has 0 operand.
if|if
condition|(
name|NumOps
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|// BX/BLX has 1 reg operand: Rm.
if|if
condition|(
name|NumOps
operator|==
literal|1
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|getT1Rm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
comment|// Add the destination operand.
name|unsigned
name|RegClass
init|=
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|RegClass
argument_list|,
name|IsGPR
argument_list|(
name|RegClass
argument_list|)
condition|?
name|getT1Rd
argument_list|(
name|insn
argument_list|)
else|:
name|getT1tRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// We have either { Rd(TIED_TO), Rm } or { Rm|tRn } remaining.
comment|// Process the TIED_TO operand first.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
literal|"More operands expected"
argument_list|)
expr_stmt|;
name|int
name|Idx
decl_stmt|;
if|if
condition|(
operator|(
name|Idx
operator|=
name|TID
operator|.
name|getOperandConstraint
argument_list|(
name|OpIdx
argument_list|,
name|TOI
operator|::
name|TIED_TO
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// The reg operand is tied to the first reg operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Idx
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// The next reg operand is either Rm or tRn.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
literal|"More operands expected"
argument_list|)
expr_stmt|;
name|RegClass
operator|=
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|RegClass
argument_list|,
name|IsGPR
argument_list|(
name|RegClass
argument_list|)
condition|?
name|getT1Rm
argument_list|(
name|insn
argument_list|)
else|:
name|getT1tRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A8.6.59 LDR (literal)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tLDRpci: tRt imm8*4
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1LdPC
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|)
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
comment|// Add the destination operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRt
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// And the (imm8<< 2) operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
operator|<<
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Thumb specific addressing modes (see ARMInstrThumb.td):
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t_addrmode_rr := reg + reg
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t_addrmode_s4 := reg + reg
end_comment

begin_comment
comment|//                  reg + imm5 * 4
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t_addrmode_s2 := reg + reg
end_comment

begin_comment
comment|//                  reg + imm5 * 2
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t_addrmode_s1 := reg + reg
end_comment

begin_comment
comment|//                  reg + imm5
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t_addrmode_sp := sp + imm8 * 4
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A6.2.4 Load/store single data item
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Load/Store Register (reg|imm):      tRd tRn imm5 tRm
end_comment

begin_comment
comment|// Load Register Signed Byte|Halfword: tRd tRn tRm
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1LdSt
parameter_list|(
name|unsigned
name|opA
parameter_list|,
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
comment|// Table A6-5 16-bit Thumb Load/store instructions
comment|// opA = 0b0101 for STR/LDR (register) and friends.
comment|// Otherwise, we have STR/LDR (immediate) and friends.
name|bool
name|Imm5
init|=
operator|(
name|opA
operator|!=
literal|5
operator|)
decl_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first two as thumb reg operands"
argument_list|)
expr_stmt|;
comment|// Add the destination reg and the base reg.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OpIdx
operator|=
literal|2
expr_stmt|;
comment|// We have either { imm5, tRm } or { tRm } remaining.
comment|// Process the imm5 first.  Note that STR/LDR (register) should skip the imm5
comment|// offset operand for t_addrmode_s[1|2|4].
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
literal|"More operands expected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Imm5
condition|?
name|getT1Imm5
argument_list|(
name|insn
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// The next reg operand is tRm, the offset.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
literal|"Thumb reg operand expected"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|Imm5
condition|?
literal|0
else|:
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.2.4 Load/store single data item
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Load/Store Register SP relative: tRt ARM::SP imm8
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1LdStSP
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tLDRspi
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSTRspi
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
literal|2
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
literal|2
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|)
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRt
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|ARM
operator|::
name|SP
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Table A6-1 16-bit Thumb instruction encoding
end_comment

begin_comment
comment|// A8.6.10 ADR
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tADDrPCi: tRt imm8
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1AddPCi
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
name|Opcode
operator|==
name|ARM
operator|::
name|tADDrPCi
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|)
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRt
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Table A6-1 16-bit Thumb instruction encoding
end_comment

begin_comment
comment|// A8.6.8 ADD (SP plus immediate)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tADDrSPi: tRt ARM::SP imm8
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1AddSPi
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
name|Opcode
operator|==
name|ARM
operator|::
name|tADDrSPi
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
literal|2
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
literal|2
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|)
operator|&&
literal|"Invalid arguments"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRt
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|ARM
operator|::
name|SP
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// tPUSH, tPOP: Pred-Imm Pred-CCR register_list
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// where register_list = low registers + [lr] for PUSH or
end_comment

begin_comment
comment|//                       low registers + [pc] for POP
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// "low registers" is specified by Inst{7-0}
end_comment

begin_comment
comment|// lr|pc is specified by Inst{8}
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1PushPop
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tPUSH
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tPOP
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
comment|// Handling the two predicate operands before the reglist.
if|if
condition|(
name|B
operator|->
name|DoPredicateOperands
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|)
condition|)
name|OpIdx
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Expected predicate operands not found.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|unsigned
name|RegListBits
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
operator|<<
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tPUSH
condition|?
literal|14
else|:
literal|15
operator|)
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Fill the variadic part of reglist.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|RegListBits
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.2.5 Miscellaneous 16-bit instructions
end_comment

begin_comment
comment|// Delegate to DisassembleThumb1PushPop() for tPUSH& tPOP.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tADDspi, tSUBspi: ARM::SP ARM::SP(TIED_TO) imm7
end_comment

begin_comment
comment|// t2IT:             firstcond=Inst{7-4} mask=Inst{3-0}
end_comment

begin_comment
comment|// tCBNZ, tCBZ:      tRd imm6*2
end_comment

begin_comment
comment|// tBKPT:            imm8
end_comment

begin_comment
comment|// tNOP, tSEV, tYIELD, tWFE, tWFI:
end_comment

begin_comment
comment|//   no operand (except predicate pair)
end_comment

begin_comment
comment|// tSETENDBE, tSETENDLE, :
end_comment

begin_comment
comment|//   no operand
end_comment

begin_comment
comment|// Others:           tRd tRn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1Misc
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
if|if
condition|(
name|NumOps
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tPUSH
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tPOP
condition|)
return|return
name|DisassembleThumb1PushPop
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
comment|// Predicate operands are handled elsewhere.
if|if
condition|(
name|NumOps
operator|==
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|CCRRegClassID
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tADDspi
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSUBspi
condition|)
block|{
comment|// Special case handling for tADDspi and tSUBspi.
comment|// A8.6.8 ADD (SP plus immediate)& A8.6.215 SUB (SP minus immediate)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|ARM
operator|::
name|SP
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|ARM
operator|::
name|SP
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm7
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2IT
condition|)
block|{
comment|// Special case handling for If-Then.
comment|// A8.6.50 IT
comment|// Tag the (firstcond[0] bit<< 4) along with mask.
comment|// firstcond
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// firstcond[0] and mask
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tBKPT
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// breakpoint value
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// CPS has a singleton $opt operand that contains the following information:
comment|// opt{4-0} = don't care
comment|// opt{5} = 0 (false)
comment|// opt{8-6} = AIF from Inst{2-0}
comment|// opt{10-9} = 1:imod from Inst{4} with 0b10 as enable and 0b11 as disable
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tCPS
condition|)
block|{
name|unsigned
name|Option
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
operator|<<
literal|6
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|10
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Option
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|&&
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|||
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
operator|)
operator|&&
literal|"Expect>=2 operands"
argument_list|)
expr_stmt|;
comment|// Add the destination operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|tGPRRegClassID
condition|)
block|{
comment|// Two register instructions.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|getT1tRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// CBNZ, CBZ
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tCBNZ
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tCBZ
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getT1Imm6
argument_list|(
name|insn
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A8.6.53  LDM / LDMIA
end_comment

begin_comment
comment|// A8.6.189 STM / STMIA
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tLDM_UPD/tSTM_UPD: tRt tRt AM4ModeImm Pred-Imm Pred-CCR register_list
end_comment

begin_comment
comment|// tLDM:              tRt AM4ModeImm Pred-Imm Pred-CCR register_list
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1LdStMul
parameter_list|(
name|bool
name|Ld
parameter_list|,
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|tLDM
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tLDM_UPD
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSTM_UPD
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|unsigned
name|tRt
init|=
name|getT1tRt
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
comment|// WB register, if necessary.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tLDM_UPD
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|tSTM_UPD
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|tRt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|tRt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// A8.6.53 LDM / LDMIA / LDMFD - Encoding T1
comment|// A8.6.53 STM / STMIA / STMEA - Encoding T1
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ARM_AM
operator|::
name|getAM4ModeImm
argument_list|(
name|ARM_AM
operator|::
name|ia
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// Handling the two predicate operands before the reglist.
if|if
condition|(
name|B
operator|->
name|DoPredicateOperands
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|)
condition|)
name|OpIdx
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Expected predicate operands not found.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|unsigned
name|RegListBits
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Fill the variadic part of reglist.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|RegListBits
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|tGPRRegClassID
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|DisassembleThumb1LdMul
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
return|return
name|DisassembleThumb1LdStMul
argument_list|(
name|true
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|DisassembleThumb1StMul
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
return|return
name|DisassembleThumb1LdStMul
argument_list|(
name|false
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// A8.6.16 B Encoding T1
end_comment

begin_comment
comment|// cond = Inst{11-8}& imm8 = Inst{7-0}
end_comment

begin_comment
comment|// imm32 = SignExtend(imm8:'0', 32)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tBcc: offset Pred-Imm Pred-CCR
end_comment

begin_comment
comment|// tSVC: imm8 Pred-Imm Pred-CCR
end_comment

begin_comment
comment|// tTRAP: 0 operand (early return)
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1CondBr
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
parameter_list|)
block|{
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|tTRAP
condition|)
return|return
name|true
return|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|==
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|CCRRegClassID
operator|&&
literal|"Exactly 3 operands expected"
argument_list|)
expr_stmt|;
name|unsigned
name|Imm8
init|=
name|getT1Imm8
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Opcode
operator|==
name|ARM
operator|::
name|tBcc
condition|?
name|SignExtend32
operator|<
literal|9
operator|>
operator|(
name|Imm8
operator|<<
literal|1
operator|)
operator|+
literal|4
else|:
operator|(
name|int
operator|)
name|Imm8
argument_list|)
argument_list|)
expr_stmt|;
comment|// Predicate operands by ARMBasicMCBuilder::TryPredicateAndSBitModifier().
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A8.6.16 B Encoding T2
end_comment

begin_comment
comment|// imm11 = Inst{10-0}
end_comment

begin_comment
comment|// imm32 = SignExtend(imm11:'0', 32)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// tB: offset
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1Br
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|==
literal|1
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
literal|"1 imm operand expected"
argument_list|)
expr_stmt|;
name|unsigned
name|Imm11
init|=
name|getT1Imm11
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|// When executing a Thumb instruction, PC reads as the address of the current
comment|// instruction plus 4.  The assembler subtracts 4 from the difference between
comment|// the branch instruction and the target address, disassembler has to add 4 to
comment|// to compensate.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|SignExtend32
operator|<
literal|12
operator|>
operator|(
name|Imm11
operator|<<
literal|1
operator|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// See A6.2 16-bit Thumb instruction encoding for instruction classes
end_comment

begin_comment
comment|// corresponding to op.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Table A6-1 16-bit Thumb instruction encoding (abridged)
end_comment

begin_comment
comment|// op		Instruction or instruction class
end_comment

begin_comment
comment|// ------	--------------------------------------------------------------------
end_comment

begin_comment
comment|// 00xxxx	Shift (immediate), add, subtract, move, and compare on page A6-7
end_comment

begin_comment
comment|// 010000	Data-processing on page A6-8
end_comment

begin_comment
comment|// 010001	Special data instructions and branch and exchange on page A6-9
end_comment

begin_comment
comment|// 01001x	Load from Literal Pool, see LDR (literal) on page A8-122
end_comment

begin_comment
comment|// 0101xx	Load/store single data item on page A6-10
end_comment

begin_comment
comment|// 011xxx
end_comment

begin_comment
comment|// 100xxx
end_comment

begin_comment
comment|// 10100x	Generate PC-relative address, see ADR on page A8-32
end_comment

begin_comment
comment|// 10101x	Generate SP-relative address, see ADD (SP plus immediate) on page A8-28
end_comment

begin_comment
comment|// 1011xx	Miscellaneous 16-bit instructions on page A6-11
end_comment

begin_comment
comment|// 11000x	Store multiple registers, see STM / STMIA / STMEA on page A8-374
end_comment

begin_comment
comment|// 11001x	Load multiple registers, see LDM / LDMIA / LDMFD on page A8-110 a
end_comment

begin_comment
comment|// 1101xx	Conditional branch, and Supervisor Call on page A6-13
end_comment

begin_comment
comment|// 11100x	Unconditional Branch, see B on page A8-44
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb1
parameter_list|(
name|uint16_t
name|op
parameter_list|,
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|unsigned
name|op1
init|=
name|slice
argument_list|(
name|op
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|unsigned
name|op2
init|=
name|slice
argument_list|(
name|op
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|op3
init|=
name|slice
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|opA
init|=
name|slice
argument_list|(
name|op
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op1
condition|)
block|{
case|case
literal|0
case|:
comment|// A6.2.1 Shift (immediate), add, subtract, move, and compare
return|return
name|DisassembleThumb1General
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
case|case
literal|1
case|:
switch|switch
condition|(
name|op2
condition|)
block|{
case|case
literal|0
case|:
switch|switch
condition|(
name|op3
condition|)
block|{
case|case
literal|0
case|:
comment|// A6.2.2 Data-processing
return|return
name|DisassembleThumb1DP
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
case|case
literal|1
case|:
comment|// A6.2.3 Special data instructions and branch and exchange
return|return
name|DisassembleThumb1Special
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
default|default:
comment|// A8.6.59 LDR (literal)
return|return
name|DisassembleThumb1LdPC
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
break|break;
default|default:
comment|// A6.2.4 Load/store single data item
return|return
name|DisassembleThumb1LdSt
argument_list|(
name|opA
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
break|break;
block|}
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|op2
condition|)
block|{
case|case
literal|0
case|:
comment|// A6.2.4 Load/store single data item
return|return
name|DisassembleThumb1LdSt
argument_list|(
name|opA
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
case|case
literal|1
case|:
comment|// A6.2.4 Load/store single data item
return|return
name|DisassembleThumb1LdStSP
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
case|case
literal|2
case|:
if|if
condition|(
name|op3
operator|<=
literal|1
condition|)
block|{
comment|// A8.6.10 ADR
return|return
name|DisassembleThumb1AddPCi
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
else|else
block|{
comment|// A8.6.8 ADD (SP plus immediate)
return|return
name|DisassembleThumb1AddSPi
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
default|default:
comment|// A6.2.5 Miscellaneous 16-bit instructions
return|return
name|DisassembleThumb1Misc
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|op2
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|op3
operator|<=
literal|1
condition|)
block|{
comment|// A8.6.189 STM / STMIA / STMEA
return|return
name|DisassembleThumb1StMul
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
else|else
block|{
comment|// A8.6.53 LDM / LDMIA / LDMFD
return|return
name|DisassembleThumb1LdMul
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
case|case
literal|1
case|:
comment|// A6.2.6 Conditional branch, and Supervisor Call
return|return
name|DisassembleThumb1CondBr
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
case|case
literal|2
case|:
comment|// Unconditional Branch, see B on page A8-44
return|return
name|DisassembleThumb1Br
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unreachable code"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unreachable code"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|///////////////////////////////////////////////
end_comment

begin_comment
comment|//                                           //
end_comment

begin_comment
comment|// Thumb2 instruction disassembly functions. //
end_comment

begin_comment
comment|//                                           //
end_comment

begin_comment
comment|///////////////////////////////////////////////
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//                                                       //
end_comment

begin_comment
comment|// Note: the register naming follows the ARM convention! //
end_comment

begin_comment
comment|//                                                       //
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|Thumb2SRSOpcode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|ARM
operator|::
name|t2SRSDBW
case|:
case|case
name|ARM
operator|::
name|t2SRSDB
case|:
case|case
name|ARM
operator|::
name|t2SRSIAW
case|:
case|case
name|ARM
operator|::
name|t2SRSIA
case|:
return|return
name|true
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|Thumb2RFEOpcode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|ARM
operator|::
name|t2RFEDBW
case|:
case|case
name|ARM
operator|::
name|t2RFEDB
case|:
case|case
name|ARM
operator|::
name|t2RFEIAW
case|:
case|case
name|ARM
operator|::
name|t2RFEIA
case|:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|// t2SRS[IA|DB]W/t2SRS[IA|DB]: mode_imm = Inst{4-0}
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2SRS
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// t2RFE[IA|DB]W/t2RFE[IA|DB]: Rn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2RFE
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|DisassembleThumb2LdStMul
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
if|if
condition|(
name|Thumb2SRSOpcode
argument_list|(
name|Opcode
argument_list|)
condition|)
return|return
name|DisassembleThumb2SRS
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|)
return|;
if|if
condition|(
name|Thumb2RFEOpcode
argument_list|(
name|Opcode
argument_list|)
condition|)
return|return
name|DisassembleThumb2RFE
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDM
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDM_UPD
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STM
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STM_UPD
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|5
operator|&&
literal|"Thumb2 LdStMul expects NumOps>= 5"
argument_list|)
expr_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|unsigned
name|Base
init|=
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|// Writeback to base.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDM_UPD
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STM_UPD
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|Base
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|Base
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
name|ARM_AM
operator|::
name|AMSubMode
name|SubMode
operator|=
name|getAMSubModeForBits
argument_list|(
name|getPUBits
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ARM_AM
operator|::
name|getAM4ModeImm
argument_list|(
name|SubMode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// Handling the two predicate operands before the reglist.
if|if
condition|(
name|B
operator|->
name|DoPredicateOperands
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|)
condition|)
name|OpIdx
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Expected predicate operands not found.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|unsigned
name|RegListBits
init|=
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Fill the variadic part of reglist.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|RegListBits
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// t2LDREX: Rd Rn
end_comment

begin_comment
comment|// t2LDREXD: Rd Rs Rn
end_comment

begin_comment
comment|// t2LDREXB, t2LDREXH: Rd Rn
end_comment

begin_comment
comment|// t2STREX: Rs Rd Rn
end_comment

begin_comment
comment|// t2STREXD: Rm Rd Rs Rn
end_comment

begin_comment
comment|// t2STREXB, t2STREXH: Rm Rd Rn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2LdStEx
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>=2 operands and first two as reg operands"
argument_list|)
expr_stmt|;
name|bool
name|isStore
init|=
operator|(
name|ARM
operator|::
name|t2STREX
operator|<=
name|Opcode
operator|&&
name|Opcode
operator|<=
name|ARM
operator|::
name|t2STREXH
operator|)
decl_stmt|;
name|bool
name|isSW
init|=
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDREX
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STREX
operator|)
decl_stmt|;
name|bool
name|isDW
init|=
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDREXD
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STREXD
operator|)
decl_stmt|;
comment|// Add the destination operand for store.
if|if
condition|(
name|isStore
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|isSW
condition|?
name|decodeRs
argument_list|(
name|insn
argument_list|)
else|:
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// Source operand for store and destination operand for load.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// Thumb2 doubleword complication: with an extra source/destination operand.
if|if
condition|(
name|isDW
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// Finally add the pointer operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// LLVM, as of Jan-05-2010, does not output<Rt2>, i.e., Rs, in the asm.
end_comment

begin_comment
comment|// Whereas the ARM Arch. Manual does not require that t2 = t+1 like in ARM ISA.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2LDRDi8: Rd Rs Rn imm8s4 (offset mode)
end_comment

begin_comment
comment|// t2LDRDpci: Rd Rs imm8s4 (Not decoded, prefer the generic t2LDRDi8 version)
end_comment

begin_comment
comment|// t2STRDi8: Rd Rs Rn imm8s4 (offset mode)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Ditto for t2LDRD_PRE, t2LDRD_POST, t2STRD_PRE, t2STRD_POST, which are for
end_comment

begin_comment
comment|// disassembly only and do not have a tied_to writeback base register operand.
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2LdStDual
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|4
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|3
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
literal|"Expect>= 4 operands and first 3 as reg operands"
argument_list|)
expr_stmt|;
comment|// Add the<Rt><Rt2> operands.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Finally add (+/-)imm8*4, depending on the U bit.
name|int
name|Offset
init|=
name|getImm8
argument_list|(
name|insn
argument_list|)
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|getUBit
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|Offset
operator|=
operator|-
name|Offset
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Offset
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// PC-based defined for Codegen, which do not get decoded by design:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2TBB, t2TBH: Rm immDontCare immDontCare
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Generic version defined for disassembly:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2TBBgen, t2TBHgen: Rn Rm Pred-Imm Pred-CCR
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2TB
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
literal|"Expect>= 2 operands"
argument_list|)
expr_stmt|;
comment|// The generic version of TBB/TBH needs a base register.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add the index register.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|Thumb2ShiftOpcode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|ARM
operator|::
name|t2MOVCClsl
case|:
case|case
name|ARM
operator|::
name|t2MOVCClsr
case|:
case|case
name|ARM
operator|::
name|t2MOVCCasr
case|:
case|case
name|ARM
operator|::
name|t2MOVCCror
case|:
case|case
name|ARM
operator|::
name|t2LSLri
case|:
case|case
name|ARM
operator|::
name|t2LSRri
case|:
case|case
name|ARM
operator|::
name|t2ASRri
case|:
case|case
name|ARM
operator|::
name|t2RORri
case|:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|// A6.3.11 Data-processing (shifted register)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Two register operands (Rn=0b1111 no 1st operand reg): Rs Rm
end_comment

begin_comment
comment|// Two register operands (Rs=0b1111 no dst operand reg): Rn Rm
end_comment

begin_comment
comment|// Three register operands: Rs Rn Rm
end_comment

begin_comment
comment|// Three register operands: (Rn=0b1111 Conditional Move) Rs Ro(TIED_TO) Rm
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Constant shifts t2_so_reg is a 2-operand unit corresponding to the Thumb2
end_comment

begin_comment
comment|// register with shift forms: (Rm, ConstantShiftSpecifier).
end_comment

begin_comment
comment|// Constant shift specifier: Imm = (ShOp | ShAmt<<3).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// There are special instructions, like t2MOVsra_flag and t2MOVsrl_flag, which
end_comment

begin_comment
comment|// only require two register operands: Rd, Rm in ARM Reference Manual terms, and
end_comment

begin_comment
comment|// nothing else, because the shift amount is already specified.
end_comment

begin_comment
comment|// Similar case holds for t2MOVrx, t2ADDrr, ..., etc.
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2DPSoReg
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
comment|// Special case handling.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2BR_JT
condition|)
block|{
name|assert
argument_list|(
name|NumOps
operator|==
literal|4
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
name|OpInfo
index|[
literal|3
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
literal|"Exactlt 4 operands expect and first two as reg operands"
argument_list|)
expr_stmt|;
comment|// Only need to populate the src reg operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first two as reg operands"
argument_list|)
expr_stmt|;
name|bool
name|ThreeReg
init|=
operator|(
name|NumOps
operator|>
literal|2
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|)
decl_stmt|;
name|bool
name|NoDstReg
init|=
operator|(
name|decodeRs
argument_list|(
name|insn
argument_list|)
operator|==
literal|0xF
operator|)
decl_stmt|;
comment|// Build the register operands, followed by the constant shift specifier.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|NoDstReg
condition|?
name|decodeRn
argument_list|(
name|insn
argument_list|)
else|:
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|ThreeReg
condition|)
block|{
name|int
name|Idx
decl_stmt|;
if|if
condition|(
operator|(
name|Idx
operator|=
name|TID
operator|.
name|getOperandConstraint
argument_list|(
name|OpIdx
argument_list|,
name|TOI
operator|::
name|TIED_TO
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Process tied_to operand constraint.
name|MI
operator|.
name|addOperand
argument_list|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Idx
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NoDstReg
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Thumb2 encoding error: d==15 for three-reg operands.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|NumOps
operator|==
name|OpIdx
condition|)
return|return
name|true
return|;
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
condition|)
block|{
if|if
condition|(
name|Thumb2ShiftOpcode
argument_list|(
name|Opcode
argument_list|)
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getShiftAmtBits
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|// Build the constant shift specifier operand.
name|unsigned
name|bits2
init|=
name|getShiftTypeBits
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|imm5
init|=
name|getShiftAmtBits
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|ARM_AM
operator|::
name|ShiftOpc
name|ShOp
operator|=
name|ARM_AM
operator|::
name|no_shift
expr_stmt|;
name|unsigned
name|ShAmt
init|=
name|decodeImmShift
argument_list|(
name|bits2
argument_list|,
name|imm5
argument_list|,
name|ShOp
argument_list|)
decl_stmt|;
comment|// PKHBT/PKHTB are special in that we need the decodeImmShift() call to
comment|// decode the shift amount from raw imm5 and bits2, but we DO NOT need
comment|// to encode the ShOp, as it's in the asm string already.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2PKHBT
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2PKHTB
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ShAmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ARM_AM
operator|::
name|getSORegOpc
argument_list|(
name|ShOp
argument_list|,
name|ShAmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|OpIdx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.1 Data-processing (modified immediate)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Two register operands: Rs Rn ModImm
end_comment

begin_comment
comment|// One register operands (Rs=0b1111 no explicit dest reg): Rn ModImm
end_comment

begin_comment
comment|// One register operands (Rn=0b1111 no explicit src reg): Rs ModImm - {t2MOVi, t2MVNi}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ModImm = ThumbExpandImm(i:imm3:imm8)
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2DPModImm
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first one as reg operand"
argument_list|)
expr_stmt|;
name|bool
name|TwoReg
init|=
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|)
decl_stmt|;
name|bool
name|NoDstReg
init|=
operator|(
name|decodeRs
argument_list|(
name|insn
argument_list|)
operator|==
literal|0xF
operator|)
decl_stmt|;
comment|// Build the register operands, followed by the modified immediate.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|NoDstReg
condition|?
name|decodeRn
argument_list|(
name|insn
argument_list|)
else|:
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|TwoReg
condition|)
block|{
if|if
condition|(
name|NoDstReg
condition|)
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Thumb2 encoding error: d==15 for DPModImm 2-reg instr.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
comment|// The modified immediate operand should come next.
name|assert
argument_list|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Pure imm operand expected"
argument_list|)
expr_stmt|;
comment|// i:imm3:imm8
comment|// A6.3.2 Modified immediate constants in Thumb instructions
name|unsigned
name|imm12
init|=
name|getIImm3Imm8
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ThumbExpandImm
argument_list|(
name|imm12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|Thumb2SaturateOpcode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
case|case
name|ARM
operator|::
name|t2SSATlsl
case|:
case|case
name|ARM
operator|::
name|t2SSATasr
case|:
case|case
name|ARM
operator|::
name|t2SSAT16
case|:
case|case
name|ARM
operator|::
name|t2USATlsl
case|:
case|case
name|ARM
operator|::
name|t2USATasr
case|:
case|case
name|ARM
operator|::
name|t2USAT16
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|decodeThumb2SaturatePos
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
case|case
name|ARM
operator|::
name|t2SSATlsl
case|:
case|case
name|ARM
operator|::
name|t2SSATasr
case|:
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
return|;
case|case
name|ARM
operator|::
name|t2SSAT16
case|:
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
return|;
case|case
name|ARM
operator|::
name|t2USATlsl
case|:
case|case
name|ARM
operator|::
name|t2USATasr
case|:
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|ARM
operator|::
name|t2USAT16
case|:
return|return
name|slice
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|// A6.3.3 Data-processing (plain binary immediate)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// o t2ADDri12, t2SUBri12: Rs Rn imm12
end_comment

begin_comment
comment|// o t2LEApcrel (ADR): Rs imm12
end_comment

begin_comment
comment|// o t2BFC (BFC): Rs Ro(TIED_TO) bf_inv_mask_imm
end_comment

begin_comment
comment|// o t2BFI (BFI) (Currently not defined in LLVM as of Jan-07-2010)
end_comment

begin_comment
comment|// o t2MOVi16: Rs imm16
end_comment

begin_comment
comment|// o t2MOVTi16: Rs imm16
end_comment

begin_comment
comment|// o t2SBFX (SBFX): Rs Rn lsb width
end_comment

begin_comment
comment|// o t2UBFX (UBFX): Rs Rn lsb width
end_comment

begin_comment
comment|// o t2BFI (BFI): Rs Rn lsb width
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// [Signed|Unsigned] Saturate [16]
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// o t2SSAT[lsl|asr], t2USAT[lsl|asr]: Rs sat_pos Rn shamt
end_comment

begin_comment
comment|// o t2SSAT16, t2USAT16: Rs sat_pos Rn
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2DPBinImm
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first one as reg operand"
argument_list|)
expr_stmt|;
name|bool
name|TwoReg
init|=
operator|(
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|)
decl_stmt|;
comment|// Build the register operand(s), followed by the immediate(s).
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
comment|// t2SSAT/t2SSAT16/t2USAT/t2USAT16 has imm operand after Rd.
if|if
condition|(
name|Thumb2SaturateOpcode
argument_list|(
name|Opcode
argument_list|)
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|decodeThumb2SaturatePos
argument_list|(
name|Opcode
argument_list|,
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2SSAT16
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2USAT16
condition|)
block|{
name|OpIdx
operator|+=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// For SSAT operand reg (Rn) has been disassembled above.
comment|// Now disassemble the shift amount.
comment|// Inst{14-12:7-6} encodes the imm5 shift amount.
name|unsigned
name|ShAmt
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|14
argument_list|,
literal|12
argument_list|)
operator|<<
literal|2
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|ShAmt
argument_list|)
argument_list|)
expr_stmt|;
name|OpIdx
operator|+=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TwoReg
condition|)
block|{
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
literal|"Expect>= 3 operands"
argument_list|)
expr_stmt|;
name|int
name|Idx
decl_stmt|;
if|if
condition|(
operator|(
name|Idx
operator|=
name|TID
operator|.
name|getOperandConstraint
argument_list|(
name|OpIdx
argument_list|,
name|TOI
operator|::
name|TIED_TO
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Process tied_to operand constraint.
name|MI
operator|.
name|addOperand
argument_list|(
name|MI
operator|.
name|getOperand
argument_list|(
name|Idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Add src reg operand.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|OpIdx
expr_stmt|;
block|}
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Pure imm operand expected"
argument_list|)
expr_stmt|;
comment|// Pre-increment OpIdx.
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2ADDri12
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2SUBri12
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2LEApcrel
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getIImm3Imm8
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2MOVi16
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2MOVTi16
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getImm16
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2BFC
condition|)
block|{
name|uint32_t
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getBitfieldInvMask
argument_list|(
name|insn
argument_list|,
name|mask
argument_list|)
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
else|else
block|{
comment|// Handle the case of: lsb width
name|assert
argument_list|(
operator|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2SBFX
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2UBFX
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2BFI
operator|)
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getLsb
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2BFI
condition|)
block|{
if|if
condition|(
name|getMsb
argument_list|(
name|insn
argument_list|)
operator|<
name|getLsb
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"Encoding error: msb< lsb\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getMsb
argument_list|(
name|insn
argument_list|)
operator|-
name|getLsb
argument_list|(
name|insn
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|getWidthMinus1
argument_list|(
name|insn
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.4 Table A6-15 Miscellaneous control instructions
end_comment

begin_comment
comment|// A8.6.41 DMB
end_comment

begin_comment
comment|// A8.6.42 DSB
end_comment

begin_comment
comment|// A8.6.49 ISB
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|t2MiscCtrlInstr
parameter_list|(
name|uint32_t
name|insn
parameter_list|)
block|{
if|if
condition|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|31
argument_list|,
literal|20
argument_list|)
operator|==
literal|0xf3b
operator|&&
name|slice
argument_list|(
name|insn
argument_list|,
literal|15
argument_list|,
literal|14
argument_list|)
operator|==
literal|2
operator|&&
name|slice
argument_list|(
name|insn
argument_list|,
literal|12
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|// A6.3.4 Branches and miscellaneous control
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A8.6.16 B
end_comment

begin_comment
comment|// Branches: t2B, t2Bcc -> imm operand
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Branches: t2TPsoft -> no operand
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A8.6.23 BL, BLX (immediate)
end_comment

begin_comment
comment|// Branches (defined in ARMInstrThumb.td): tBLr9, tBLXi_r9 -> imm operand
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A8.6.26
end_comment

begin_comment
comment|// t2BXJ -> Rn
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Miscellaneous control: t2Int_MemBarrierV7 (and its t2DMB variants),
end_comment

begin_comment
comment|// t2Int_SyncBarrierV7 (and its t2DSB varianst), t2ISBsy, t2CLREX
end_comment

begin_comment
comment|//   -> no operand (except pred-imm pred-ccr for CLREX, memory barrier variants)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Hint: t2NOP, t2YIELD, t2WFE, t2WFI, t2SEV
end_comment

begin_comment
comment|//   -> no operand (except pred-imm pred-ccr)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2DBG -> imm4 = Inst{3-0}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2MRS/t2MRSsys -> Rs
end_comment

begin_comment
comment|// t2MSR/t2MSRsys -> Rn mask=Inst{11-8}
end_comment

begin_comment
comment|// t2SMC -> imm4 = Inst{19-16}
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2BrMiscCtrl
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
if|if
condition|(
name|NumOps
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|t2MiscCtrlInstr
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|Opcode
condition|)
block|{
case|case
name|ARM
operator|::
name|t2CLREX
case|:
case|case
name|ARM
operator|::
name|t2NOP
case|:
case|case
name|ARM
operator|::
name|t2YIELD
case|:
case|case
name|ARM
operator|::
name|t2WFE
case|:
case|case
name|ARM
operator|::
name|t2WFI
case|:
case|case
name|ARM
operator|::
name|t2SEV
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
comment|// CPS has a singleton $opt operand that contains the following information:
comment|// opt{4-0} = mode from Inst{4-0}
comment|// opt{5} = changemode from Inst{8}
comment|// opt{8-6} = AIF from Inst{7-5}
comment|// opt{10-9} = imod from Inst{10-9} with 0b10 as enable and 0b11 as disable
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2CPS
condition|)
block|{
name|unsigned
name|Option
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
operator|<<
literal|5
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
operator|<<
literal|6
operator||
name|slice
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|,
literal|9
argument_list|)
operator|<<
literal|9
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Option
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// DBG has its option specified in Inst{3-0}.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2DBG
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// MRS and MRSsys take one GPR reg Rs.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2MRS
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2MRSsys
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// BXJ takes one GPR reg Rn.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2BXJ
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// MSR and MSRsys take one GPR reg Rn, followed by the mask.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2MSR
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2MSRsys
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2BXJ
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// SMC take imm4.
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2SMC
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|19
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Add the imm operand.
name|int
name|Offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unexpected opcode"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ARM
operator|::
name|t2B
case|:
name|Offset
operator|=
name|decodeImm32_B_EncodingT4
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM
operator|::
name|t2Bcc
case|:
name|Offset
operator|=
name|decodeImm32_B_EncodingT3
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM
operator|::
name|tBLr9
case|:
name|Offset
operator|=
name|decodeImm32_BL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM
operator|::
name|tBLXi_r9
case|:
name|Offset
operator|=
name|decodeImm32_BLX
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// When executing a Thumb instruction, PC reads as the address of the current
comment|// instruction plus 4.  The assembler subtracts 4 from the difference between
comment|// the branch instruction and the target address, disassembler has to add 4 to
comment|// to compensate.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Offset
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|Thumb2PreloadOpcode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|ARM
operator|::
name|t2PLDi12
case|:
case|case
name|ARM
operator|::
name|t2PLDi8
case|:
case|case
name|ARM
operator|::
name|t2PLDpci
case|:
case|case
name|ARM
operator|::
name|t2PLDr
case|:
case|case
name|ARM
operator|::
name|t2PLDs
case|:
case|case
name|ARM
operator|::
name|t2PLDWi12
case|:
case|case
name|ARM
operator|::
name|t2PLDWi8
case|:
case|case
name|ARM
operator|::
name|t2PLDWpci
case|:
case|case
name|ARM
operator|::
name|t2PLDWr
case|:
case|case
name|ARM
operator|::
name|t2PLDWs
case|:
case|case
name|ARM
operator|::
name|t2PLIi12
case|:
case|case
name|ARM
operator|::
name|t2PLIi8
case|:
case|case
name|ARM
operator|::
name|t2PLIpci
case|:
case|case
name|ARM
operator|::
name|t2PLIr
case|:
case|case
name|ARM
operator|::
name|t2PLIs
case|:
return|return
name|true
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|DisassembleThumb2PreLoad
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
comment|// Preload Data/Instruction requires either 2 or 3 operands.
comment|// t2PLDi12, t2PLDi8, t2PLDpci: Rn [+/-]imm12/imm8
comment|// t2PLDr:                      Rn Rm
comment|// t2PLDs:                      Rn Rm imm2=Inst{5-4}
comment|// Same pattern applies for t2PLDW* and t2PLI*.
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first one as reg operand"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Pure imm operand expected"
argument_list|)
expr_stmt|;
name|int
name|Offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLDpci
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLDWpci
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLIpci
condition|)
block|{
name|bool
name|Negative
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
operator|==
literal|0
decl_stmt|;
name|unsigned
name|Imm12
init|=
name|getImm12
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|Offset
operator|=
name|Negative
condition|?
operator|-
literal|1
operator|-
name|Imm12
else|:
literal|1
operator|*
name|Imm12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLDi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLDWi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2PLIi8
condition|)
block|{
comment|// A8.6.117 Encoding T2: add = FALSE
name|unsigned
name|Imm8
init|=
name|getImm8
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|Offset
operator|=
operator|-
literal|1
operator|-
name|Imm8
expr_stmt|;
block|}
else|else
comment|// The i12 forms.  See, for example, A8.6.117 Encoding T1.
name|Offset
operator|=
name|decodeImm12
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
condition|)
block|{
comment|// Fills in the shift amount for t2PLDs, t2PLDWs, t2PLIs.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|slice
argument_list|(
name|insn
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A8.6.63 LDRB (literal)
end_comment

begin_comment
comment|// A8.6.79 LDRSB (literal)
end_comment

begin_comment
comment|// A8.6.75 LDRH (literal)
end_comment

begin_comment
comment|// A8.6.83 LDRSH (literal)
end_comment

begin_comment
comment|// A8.6.59 LDR (literal)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// These instrs calculate an address from the PC value and an immediate offset.
end_comment

begin_comment
comment|// Rd Rn=PC (+/-)imm12 (+ if Inst{23} == 0b1)
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2Ldpci
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
literal|"Expect>= 2 operands, first as reg, and second as imm operand"
argument_list|)
expr_stmt|;
comment|// Build the register operand, followed by the (+/-)imm12 immediate.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|decodeImm12
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.10 Store single data item
end_comment

begin_comment
comment|// A6.3.9 Load byte, memory hints
end_comment

begin_comment
comment|// A6.3.8 Load halfword, memory hints
end_comment

begin_comment
comment|// A6.3.7 Load word
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For example,
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2LDRi12:   Rd Rn (+)imm12
end_comment

begin_comment
comment|// t2LDRi8:    Rd Rn (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|// t2LDRs:     Rd Rn Rm ConstantShiftSpecifier (see also DisassembleThumb2DPSoReg)
end_comment

begin_comment
comment|// t2LDR_POST: Rd Rn Rn(TIED_TO) (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|// t2LDR_PRE:  Rd Rn Rn(TIED_TO) (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2STRi12:   Rd Rn (+)imm12
end_comment

begin_comment
comment|// t2STRi8:    Rd Rn (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|// t2STRs:     Rd Rn Rm ConstantShiftSpecifier (see also DisassembleThumb2DPSoReg)
end_comment

begin_comment
comment|// t2STR_POST: Rn Rd Rn(TIED_TO) (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|// t2STR_PRE:  Rn Rd Rn(TIED_TO) (+/-)imm8 (+ if Inst{9} == 0b1)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that for indexed modes, the Rn(TIED_TO) operand needs to be populated
end_comment

begin_comment
comment|// correctly, as LLVM AsmPrinter depends on it.  For indexed stores, the first
end_comment

begin_comment
comment|// operand is Rn; for all the other instructions, Rd is the first operand.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Delegates to DisassembleThumb2PreLoad() for preload data/instruction.
end_comment

begin_comment
comment|// Delegates to DisassembleThumb2Ldpci() for load * literal operations.
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2LdSt
parameter_list|(
name|bool
name|Load
parameter_list|,
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
name|unsigned
name|Rn
init|=
name|decodeRn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|Thumb2PreloadOpcode
argument_list|(
name|Opcode
argument_list|)
condition|)
return|return
name|DisassembleThumb2PreLoad
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
comment|// See, for example, A6.3.7 Load word: Table A6-18 Load word.
if|if
condition|(
name|Load
operator|&&
name|Rn
operator|==
literal|15
condition|)
return|return
name|DisassembleThumb2Ldpci
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 3 operands and first two as reg operands"
argument_list|)
expr_stmt|;
name|bool
name|ThreeReg
init|=
operator|(
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|)
decl_stmt|;
name|bool
name|TIED_TO
init|=
name|ThreeReg
operator|&&
name|TID
operator|.
name|getOperandConstraint
argument_list|(
literal|2
argument_list|,
name|TOI
operator|::
name|TIED_TO
argument_list|)
operator|!=
operator|-
literal|1
decl_stmt|;
name|bool
name|Imm12
init|=
operator|!
name|ThreeReg
operator|&&
name|slice
argument_list|(
name|insn
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
operator|==
literal|1
decl_stmt|;
comment|// ARMInstrThumb2.td
comment|// Build the register operands, followed by the immediate.
name|unsigned
name|R0
decl_stmt|,
name|R1
decl_stmt|,
name|R2
init|=
literal|0
decl_stmt|;
name|unsigned
name|Rd
init|=
name|decodeRd
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|Imm
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Load
operator|&&
name|TIED_TO
condition|)
block|{
name|R0
operator|=
name|Rn
expr_stmt|;
name|R1
operator|=
name|Rd
expr_stmt|;
block|}
else|else
block|{
name|R0
operator|=
name|Rd
expr_stmt|;
name|R1
operator|=
name|Rn
expr_stmt|;
block|}
if|if
condition|(
name|ThreeReg
condition|)
block|{
if|if
condition|(
name|TIED_TO
condition|)
block|{
name|R2
operator|=
name|Rn
expr_stmt|;
name|Imm
operator|=
name|decodeImm8
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|R2
operator|=
name|decodeRm
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|// See, for example, A8.6.64 LDRB (register).
comment|// And ARMAsmPrinter::printT2AddrModeSoRegOperand().
comment|// LSL is the default shift opc, and LLVM does not expect it to be encoded
comment|// as part of the immediate operand.
comment|// Imm = ARM_AM::getSORegOpc(ARM_AM::lsl, slice(insn, 5, 4));
name|Imm
operator|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Imm12
condition|)
name|Imm
operator|=
name|getImm12
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|Imm
operator|=
name|decodeImm8
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|R0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|R1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|ThreeReg
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|R2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
name|assert
argument_list|(
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
operator|&&
literal|"Pure imm operand expected"
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|Imm
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.12 Data-processing (register)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Two register operands [rotate]:   Rs Rm [rotation(= (rotate:'000'))]
end_comment

begin_comment
comment|// Three register operands only:     Rs Rn Rm
end_comment

begin_comment
comment|// Three register operands [rotate]: Rs Rn Rm [rotation(= (rotate:'000'))]
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Parallel addition and subtraction 32-bit Thumb instructions: Rs Rn Rm
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Miscellaneous operations: Rs [Rn] Rm
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2DPReg
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetInstrDesc
modifier|&
name|TID
init|=
name|ARMInsts
index|[
name|Opcode
index|]
decl_stmt|;
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|TID
operator|.
name|OpInfo
decl_stmt|;
name|unsigned
modifier|&
name|OpIdx
init|=
name|NumOpsAdded
decl_stmt|;
name|OpIdx
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|2
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 2 operands and first two as reg operands"
argument_list|)
expr_stmt|;
comment|// Build the register operands, followed by the optional rotation amount.
name|bool
name|ThreeReg
init|=
name|NumOps
operator|>
literal|2
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|ThreeReg
condition|)
block|{
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
if|if
condition|(
name|OpIdx
operator|<
name|NumOps
operator|&&
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|RegClass
operator|==
literal|0
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isPredicate
argument_list|()
operator|&&
operator|!
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|isOptionalDef
argument_list|()
condition|)
block|{
comment|// Add the rotation amount immediate.
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateImm
argument_list|(
name|decodeRotate
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|OpIdx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.16 Multiply, multiply accumulate, and absolute difference
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2MLA, t2MLS, t2SMMLA, t2SMMLS: Rs Rn Rm Ra=Inst{15-12}
end_comment

begin_comment
comment|// t2MUL, t2SMMUL:                 Rs Rn Rm
end_comment

begin_comment
comment|// t2SMLA[BB|BT|TB|TT|WB|WT]:      Rs Rn Rm Ra=Inst{15-12}
end_comment

begin_comment
comment|// t2SMUL[BB|BT|TB|TT|WB|WT]:      Rs Rn Rm
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Dual halfword multiply: t2SMUAD[X], t2SMUSD[X], t2SMLAD[X], t2SMLSD[X]:
end_comment

begin_comment
comment|//   Rs Rn Rm Ra=Inst{15-12}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unsigned Sum of Absolute Differences [and Accumulate]
end_comment

begin_comment
comment|//    Rs Rn Rm [Ra=Inst{15-12}]
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2Mul
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 3 operands and first three as reg operands"
argument_list|)
expr_stmt|;
comment|// Build the register operands.
name|bool
name|FourReg
init|=
name|NumOps
operator|>
literal|3
operator|&&
name|OpInfo
index|[
literal|3
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
decl_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FourReg
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NumOpsAdded
operator|=
name|FourReg
condition|?
literal|4
else|:
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// A6.3.17 Long multiply, long multiply accumulate, and divide
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// t2SMULL, t2UMULL, t2SMLAL, t2UMLAL, t2UMAAL: RdLo RdHi Rn Rm
end_comment

begin_comment
comment|// where RdLo = Inst{15-12} and RdHi = Inst{11-8}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Halfword multiple accumulate long: t2SMLAL<x><y>: RdLo RdHi Rn Rm
end_comment

begin_comment
comment|// where RdLo = Inst{15-12} and RdHi = Inst{11-8}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Dual halfword multiple: t2SMLALD[X], t2SMLSLD[X]: RdLo RdHi Rn Rm
end_comment

begin_comment
comment|// where RdLo = Inst{15-12} and RdHi = Inst{11-8}
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Signed/Unsigned divide: t2SDIV, t2UDIV: Rs Rn Rm
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2LongMul
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
specifier|const
name|TargetOperandInfo
modifier|*
name|OpInfo
init|=
name|ARMInsts
index|[
name|Opcode
index|]
operator|.
name|OpInfo
decl_stmt|;
name|assert
argument_list|(
name|NumOps
operator|>=
literal|3
operator|&&
name|OpInfo
index|[
literal|0
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|1
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
name|OpInfo
index|[
literal|2
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
operator|&&
literal|"Expect>= 3 operands and first three as reg operands"
argument_list|)
expr_stmt|;
name|bool
name|FourReg
init|=
name|NumOps
operator|>
literal|3
operator|&&
name|OpInfo
index|[
literal|3
index|]
operator|.
name|RegClass
operator|==
name|ARM
operator|::
name|GPRRegClassID
decl_stmt|;
comment|// Build the register operands.
if|if
condition|(
name|FourReg
condition|)
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRd
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRs
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRn
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MI
operator|.
name|addOperand
argument_list|(
name|MCOperand
operator|::
name|CreateReg
argument_list|(
name|getRegisterEnum
argument_list|(
name|B
argument_list|,
name|ARM
operator|::
name|GPRRegClassID
argument_list|,
name|decodeRm
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FourReg
condition|)
name|NumOpsAdded
operator|=
literal|4
expr_stmt|;
else|else
name|NumOpsAdded
operator|=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// See A6.3 32-bit Thumb instruction encoding for instruction classes
end_comment

begin_comment
comment|// corresponding to (op1, op2, op).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Table A6-9 32-bit Thumb instruction encoding
end_comment

begin_comment
comment|// op1	op2		op	Instruction class, see
end_comment

begin_comment
comment|// ---	-------	--	------------------------------------------------------------
end_comment

begin_comment
comment|// 01	00xx0xx	-	Load/store multiple on page A6-23
end_comment

begin_comment
comment|// 		00xx1xx	-	Load/store dual, load/store exclusive, table branch on page A6-24
end_comment

begin_comment
comment|// 		01xxxxx	-	Data-processing (shifted register) on page A6-31
end_comment

begin_comment
comment|// 		1xxxxxx	-	Coprocessor instructions on page A6-40
end_comment

begin_comment
comment|// 10	x0xxxxx	0	Data-processing (modified immediate) on page A6-15
end_comment

begin_comment
comment|// 		x1xxxxx	0	Data-processing (plain binary immediate) on page A6-19
end_comment

begin_comment
comment|// 		-		1	Branches and miscellaneous control on page A6-20
end_comment

begin_comment
comment|// 11	000xxx0	-	Store single data item on page A6-30
end_comment

begin_comment
comment|// 		001xxx0	-	Advanced SIMD element or structure load/store instructions on page A7-27
end_comment

begin_comment
comment|// 		00xx001 -	Load byte, memory hints on page A6-28
end_comment

begin_comment
comment|// 		00xx011	-	Load halfword, memory hints on page A6-26
end_comment

begin_comment
comment|// 		00xx101	-	Load word on page A6-25
end_comment

begin_comment
comment|// 		00xx111	-	UNDEFINED
end_comment

begin_comment
comment|// 		010xxxx	-	Data-processing (register) on page A6-33
end_comment

begin_comment
comment|// 		0110xxx	-	Multiply, multiply accumulate, and absolute difference on page A6-38
end_comment

begin_comment
comment|// 		0111xxx	-	Long multiply, long multiply accumulate, and divide on page A6-39
end_comment

begin_comment
comment|// 		1xxxxxx	-	Coprocessor instructions on page A6-40
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|static
name|bool
name|DisassembleThumb2
parameter_list|(
name|uint16_t
name|op1
parameter_list|,
name|uint16_t
name|op2
parameter_list|,
name|uint16_t
name|op
parameter_list|,
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|B
parameter_list|)
block|{
switch|switch
condition|(
name|op1
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|6
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Load/store multiple.
return|return
name|DisassembleThumb2LdStMul
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
comment|// Load/store dual, load/store exclusive, table branch, otherwise.
name|assert
argument_list|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|1
operator|&&
literal|"Thumb2 encoding error!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ARM
operator|::
name|t2LDREX
operator|<=
name|Opcode
operator|&&
name|Opcode
operator|<=
name|ARM
operator|::
name|t2LDREXH
operator|)
operator|||
operator|(
name|ARM
operator|::
name|t2STREX
operator|<=
name|Opcode
operator|&&
name|Opcode
operator|<=
name|ARM
operator|::
name|t2STREXH
operator|)
condition|)
block|{
comment|// Load/store exclusive.
return|return
name|DisassembleThumb2LdStEx
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDRDi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDRD_PRE
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2LDRD_POST
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STRDi8
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STRD_PRE
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2STRD_POST
condition|)
block|{
comment|// Load/store dual.
return|return
name|DisassembleThumb2LdStDual
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|ARM
operator|::
name|t2TBBgen
operator|||
name|Opcode
operator|==
name|ARM
operator|::
name|t2TBHgen
condition|)
block|{
comment|// Table branch.
return|return
name|DisassembleThumb2TB
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|6
argument_list|,
literal|5
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|// Data-processing (shifted register).
return|return
name|DisassembleThumb2DPSoReg
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
comment|// FIXME: A6.3.18 Coprocessor instructions
comment|// But see ThumbDisassembler::getInstruction().
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Data-processing (modified immediate)
return|return
name|DisassembleThumb2DPModImm
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
else|else
block|{
comment|// Data-processing (plain binary immediate)
return|return
name|DisassembleThumb2DPBinImm
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// Branches and miscellaneous control on page A6-20.
return|return
name|DisassembleThumb2BrMiscCtrl
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|6
argument_list|,
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|// Load/store instructions...
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Store single data item on page A6-30
return|return
name|DisassembleThumb2LdSt
argument_list|(
name|false
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
else|else
block|{
comment|// FIXME: Advanced SIMD element or structure load/store instructions.
comment|// But see ThumbDisassembler::getInstruction().
empty_stmt|;
block|}
block|}
else|else
block|{
comment|// Table A6-9 32-bit Thumb instruction encoding: Load byte|halfword|word
return|return
name|DisassembleThumb2LdSt
argument_list|(
name|true
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A6.3.12 Data-processing (register)
return|return
name|DisassembleThumb2DPReg
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|slice
argument_list|(
name|op2
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A6.3.16 Multiply, multiply accumulate, and absolute difference
return|return
name|DisassembleThumb2Mul
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
else|else
block|{
comment|// A6.3.17 Long multiply, long multiply accumulate, and divide
return|return
name|DisassembleThumb2LongMul
argument_list|(
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|B
argument_list|)
return|;
block|}
break|break;
default|default:
comment|// FIXME: A6.3.18 Coprocessor instructions
comment|// But see ThumbDisassembler::getInstruction().
empty_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Thumb2 encoding error!"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|DisassembleThumbFrm
parameter_list|(
name|MCInst
modifier|&
name|MI
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint32_t
name|insn
parameter_list|,
name|unsigned
name|short
name|NumOps
parameter_list|,
name|unsigned
modifier|&
name|NumOpsAdded
parameter_list|,
name|BO
name|Builder
parameter_list|)
block|{
name|uint16_t
name|HalfWord
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|31
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|HalfWord
operator|==
literal|0
condition|)
block|{
comment|// A6.2 16-bit Thumb instruction encoding
comment|// op = bits[15:10]
name|uint16_t
name|op
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|15
argument_list|,
literal|10
argument_list|)
decl_stmt|;
return|return
name|DisassembleThumb1
argument_list|(
name|op
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|Builder
argument_list|)
return|;
block|}
name|unsigned
name|bits15_11
init|=
name|slice
argument_list|(
name|HalfWord
argument_list|,
literal|15
argument_list|,
literal|11
argument_list|)
decl_stmt|;
comment|// A6.1 Thumb instruction set encoding
if|if
condition|(
operator|!
operator|(
name|bits15_11
operator|==
literal|0x1D
operator|||
name|bits15_11
operator|==
literal|0x1E
operator|||
name|bits15_11
operator|==
literal|0x1F
operator|)
condition|)
block|{
name|assert
argument_list|(
literal|"Bits[15:11] first halfword of Thumb2 instruction is out of range"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// A6.3 32-bit Thumb instruction encoding
name|uint16_t
name|op1
init|=
name|slice
argument_list|(
name|HalfWord
argument_list|,
literal|12
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|uint16_t
name|op2
init|=
name|slice
argument_list|(
name|HalfWord
argument_list|,
literal|10
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|uint16_t
name|op
init|=
name|slice
argument_list|(
name|insn
argument_list|,
literal|15
argument_list|,
literal|15
argument_list|)
decl_stmt|;
return|return
name|DisassembleThumb2
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|op
argument_list|,
name|MI
argument_list|,
name|Opcode
argument_list|,
name|insn
argument_list|,
name|NumOps
argument_list|,
name|NumOpsAdded
argument_list|,
name|Builder
argument_list|)
return|;
block|}
end_function

end_unit

