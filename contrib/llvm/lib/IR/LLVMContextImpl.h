begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LLVMContextImpl.h - The LLVMContextImpl opaque class ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file declares LLVMContextImpl, the opaque implementation
end_comment

begin_comment
comment|//  of LLVMContext.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_IR_LLVMCONTEXTIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_IR_LLVMCONTEXTIMPL_H
end_define

begin_include
include|#
directive|include
file|"AttributeImpl.h"
end_include

begin_include
include|#
directive|include
file|"ConstantsContext.h"
end_include

begin_include
include|#
directive|include
file|"LeaksContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantInt
decl_stmt|;
name|class
name|ConstantFP
decl_stmt|;
name|class
name|DiagnosticInfoOptimizationRemark
decl_stmt|;
name|class
name|DiagnosticInfoOptimizationRemarkMissed
decl_stmt|;
name|class
name|DiagnosticInfoOptimizationRemarkAnalysis
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
struct|struct
name|DenseMapAPIntKeyInfo
block|{
specifier|static
specifier|inline
name|APInt
name|getEmptyKey
parameter_list|()
block|{
name|APInt
name|V
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|V
operator|.
name|VAL
operator|=
literal|0
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|static
specifier|inline
name|APInt
name|getTombstoneKey
parameter_list|()
block|{
name|APInt
name|V
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|V
operator|.
name|VAL
operator|=
literal|1
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|hash_value
argument_list|(
name|Key
argument_list|)
operator|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|APInt
modifier|&
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|getBitWidth
argument_list|()
operator|==
name|RHS
operator|.
name|getBitWidth
argument_list|()
operator|&&
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
struct|;
struct|struct
name|DenseMapAPFloatKeyInfo
block|{
specifier|static
specifier|inline
name|APFloat
name|getEmptyKey
parameter_list|()
block|{
return|return
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|APFloat
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|,
literal|2
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|hash_value
argument_list|(
name|Key
argument_list|)
operator|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|LHS
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|bitwiseIsEqual
argument_list|(
name|RHS
argument_list|)
return|;
block|}
block|}
struct|;
struct|struct
name|AnonStructTypeKeyInfo
block|{
struct|struct
name|KeyTy
block|{
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|ETypes
expr_stmt|;
name|bool
name|isPacked
decl_stmt|;
name|KeyTy
argument_list|(
argument|const ArrayRef<Type*>& E
argument_list|,
argument|bool P
argument_list|)
block|:
name|ETypes
argument_list|(
name|E
argument_list|)
operator|,
name|isPacked
argument_list|(
argument|P
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|StructType
operator|*
name|ST
argument_list|)
operator|:
name|ETypes
argument_list|(
name|ST
operator|->
name|elements
argument_list|()
argument_list|)
operator|,
name|isPacked
argument_list|(
argument|ST->isPacked()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
if|if
condition|(
name|isPacked
operator|!=
name|that
operator|.
name|isPacked
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ETypes
operator|!=
name|that
operator|.
name|ETypes
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|operator
decl|!=
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
decl|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
specifier|static
specifier|inline
name|StructType
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|StructType
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|StructType
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|StructType
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|hash_combine
argument_list|(
name|hash_combine_range
argument_list|(
name|Key
operator|.
name|ETypes
operator|.
name|begin
argument_list|()
argument_list|,
name|Key
operator|.
name|ETypes
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|Key
operator|.
name|isPacked
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|StructType
modifier|*
name|ST
parameter_list|)
block|{
return|return
name|getHashValue
argument_list|(
name|KeyTy
argument_list|(
name|ST
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|StructType
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|LHS
operator|==
name|KeyTy
argument_list|(
name|RHS
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|StructType
modifier|*
name|LHS
parameter_list|,
specifier|const
name|StructType
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|FunctionTypeKeyInfo
block|{
struct|struct
name|KeyTy
block|{
specifier|const
name|Type
modifier|*
name|ReturnType
decl_stmt|;
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Params
expr_stmt|;
name|bool
name|isVarArg
decl_stmt|;
name|KeyTy
argument_list|(
argument|const Type* R
argument_list|,
argument|const ArrayRef<Type*>& P
argument_list|,
argument|bool V
argument_list|)
block|:
name|ReturnType
argument_list|(
name|R
argument_list|)
operator|,
name|Params
argument_list|(
name|P
argument_list|)
operator|,
name|isVarArg
argument_list|(
argument|V
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|FunctionType
operator|*
name|FT
argument_list|)
operator|:
name|ReturnType
argument_list|(
name|FT
operator|->
name|getReturnType
argument_list|()
argument_list|)
operator|,
name|Params
argument_list|(
name|FT
operator|->
name|params
argument_list|()
argument_list|)
operator|,
name|isVarArg
argument_list|(
argument|FT->isVarArg()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
if|if
condition|(
name|ReturnType
operator|!=
name|that
operator|.
name|ReturnType
condition|)
return|return
name|false
return|;
if|if
condition|(
name|isVarArg
operator|!=
name|that
operator|.
name|isVarArg
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Params
operator|!=
name|that
operator|.
name|Params
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|operator
decl|!=
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
decl|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|FunctionType
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|FunctionType
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|FunctionType
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|FunctionType
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|hash_combine
argument_list|(
name|Key
operator|.
name|ReturnType
argument_list|,
name|hash_combine_range
argument_list|(
name|Key
operator|.
name|Params
operator|.
name|begin
argument_list|()
argument_list|,
name|Key
operator|.
name|Params
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|Key
operator|.
name|isVarArg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|FunctionType
modifier|*
name|FT
parameter_list|)
block|{
return|return
name|getHashValue
argument_list|(
name|KeyTy
argument_list|(
name|FT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|FunctionType
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|LHS
operator|==
name|KeyTy
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|FunctionType
modifier|*
name|LHS
parameter_list|,
specifier|const
name|FunctionType
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief DenseMapInfo for MDTuple.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that we don't need the is-function-local bit, since that's implicit in
end_comment

begin_comment
comment|/// the operands.
end_comment

begin_struct
struct|struct
name|MDTupleInfo
block|{
struct|struct
name|KeyTy
block|{
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|RawOps
expr_stmt|;
name|ArrayRef
operator|<
name|MDOperand
operator|>
name|Ops
expr_stmt|;
name|unsigned
name|Hash
decl_stmt|;
name|KeyTy
argument_list|(
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|Ops
argument_list|)
operator|:
name|RawOps
argument_list|(
name|Ops
argument_list|)
operator|,
name|Hash
argument_list|(
argument|hash_combine_range(Ops.begin(), Ops.end())
argument_list|)
block|{}
name|KeyTy
argument_list|(
name|MDTuple
operator|*
name|N
argument_list|)
operator|:
name|Ops
argument_list|(
name|N
operator|->
name|op_begin
argument_list|()
argument_list|,
name|N
operator|->
name|op_end
argument_list|()
argument_list|)
operator|,
name|Hash
argument_list|(
argument|N->getHash()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MDTuple
operator|*
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Hash
operator|!=
name|RHS
operator|->
name|getHash
argument_list|()
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
operator|(
name|RawOps
operator|.
name|empty
argument_list|()
operator|||
name|Ops
operator|.
name|empty
argument_list|()
operator|)
operator|&&
literal|"Two sets of operands?"
argument_list|)
expr_stmt|;
return|return
name|RawOps
operator|.
name|empty
argument_list|()
condition|?
name|compareOps
argument_list|(
name|Ops
argument_list|,
name|RHS
argument_list|)
else|:
name|compareOps
argument_list|(
name|RawOps
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|template
decl|<
name|class
name|T
decl|>     static
name|bool
name|compareOps
argument_list|(
name|ArrayRef
operator|<
name|T
operator|>
name|Ops
argument_list|,
specifier|const
name|MDTuple
operator|*
name|RHS
argument_list|)
block|{
if|if
condition|(
name|Ops
operator|.
name|size
argument_list|()
operator|!=
name|RHS
operator|->
name|getNumOperands
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Ops
operator|.
name|begin
argument_list|()
argument_list|,
name|Ops
operator|.
name|end
argument_list|()
argument_list|,
name|RHS
operator|->
name|op_begin
argument_list|()
argument_list|)
return|;
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|MDTuple
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|MDTuple
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|MDTuple
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|MDTuple
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|Key
operator|.
name|Hash
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|MDTuple
modifier|*
name|U
parameter_list|)
block|{
return|return
name|U
operator|->
name|getHash
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|MDTuple
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|MDTuple
modifier|*
name|LHS
parameter_list|,
specifier|const
name|MDTuple
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief DenseMapInfo for MDLocation.
end_comment

begin_struct
struct|struct
name|MDLocationInfo
block|{
struct|struct
name|KeyTy
block|{
name|unsigned
name|Line
decl_stmt|;
name|unsigned
name|Column
decl_stmt|;
name|Metadata
modifier|*
name|Scope
decl_stmt|;
name|Metadata
modifier|*
name|InlinedAt
decl_stmt|;
name|KeyTy
argument_list|(
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|)
block|:
name|Line
argument_list|(
name|Line
argument_list|)
operator|,
name|Column
argument_list|(
name|Column
argument_list|)
operator|,
name|Scope
argument_list|(
name|Scope
argument_list|)
operator|,
name|InlinedAt
argument_list|(
argument|InlinedAt
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|MDLocation
operator|*
name|L
argument_list|)
operator|:
name|Line
argument_list|(
name|L
operator|->
name|getLine
argument_list|()
argument_list|)
operator|,
name|Column
argument_list|(
name|L
operator|->
name|getColumn
argument_list|()
argument_list|)
operator|,
name|Scope
argument_list|(
name|L
operator|->
name|getScope
argument_list|()
argument_list|)
operator|,
name|InlinedAt
argument_list|(
argument|L->getInlinedAt()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MDLocation
operator|*
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Column
operator|==
name|RHS
operator|->
name|getColumn
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getScope
argument_list|()
operator|&&
name|InlinedAt
operator|==
name|RHS
operator|->
name|getInlinedAt
argument_list|()
return|;
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|MDLocation
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|MDLocation
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|MDLocation
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|MDLocation
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|hash_combine
argument_list|(
name|Key
operator|.
name|Line
argument_list|,
name|Key
operator|.
name|Column
argument_list|,
name|Key
operator|.
name|Scope
argument_list|,
name|Key
operator|.
name|InlinedAt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|MDLocation
modifier|*
name|U
parameter_list|)
block|{
return|return
name|getHashValue
argument_list|(
name|KeyTy
argument_list|(
name|U
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|MDLocation
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|MDLocation
modifier|*
name|LHS
parameter_list|,
specifier|const
name|MDLocation
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|LLVMContextImpl
block|{
name|public
label|:
comment|/// OwnedModules - The set of modules instantiated in this context, and which
comment|/// will be automatically deleted if this context is deleted.
name|SmallPtrSet
operator|<
name|Module
operator|*
operator|,
literal|4
operator|>
name|OwnedModules
expr_stmt|;
name|LLVMContext
operator|::
name|InlineAsmDiagHandlerTy
name|InlineAsmDiagHandler
expr_stmt|;
name|void
modifier|*
name|InlineAsmDiagContext
decl_stmt|;
name|LLVMContext
operator|::
name|DiagnosticHandlerTy
name|DiagnosticHandler
expr_stmt|;
name|void
modifier|*
name|DiagnosticContext
decl_stmt|;
name|bool
name|RespectDiagnosticFilters
decl_stmt|;
name|LLVMContext
operator|::
name|YieldCallbackTy
name|YieldCallback
expr_stmt|;
name|void
modifier|*
name|YieldOpaqueHandle
decl_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|APInt
operator|,
name|ConstantInt
operator|*
operator|,
name|DenseMapAPIntKeyInfo
operator|>
name|IntMapTy
expr_stmt|;
name|IntMapTy
name|IntConstants
decl_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|APFloat
operator|,
name|ConstantFP
operator|*
operator|,
name|DenseMapAPFloatKeyInfo
operator|>
name|FPMapTy
expr_stmt|;
name|FPMapTy
name|FPConstants
decl_stmt|;
name|FoldingSet
operator|<
name|AttributeImpl
operator|>
name|AttrsSet
expr_stmt|;
name|FoldingSet
operator|<
name|AttributeSetImpl
operator|>
name|AttrsLists
expr_stmt|;
name|FoldingSet
operator|<
name|AttributeSetNode
operator|>
name|AttrsSetNodes
expr_stmt|;
name|StringMap
operator|<
name|MDString
operator|>
name|MDStringCache
expr_stmt|;
name|DenseMap
operator|<
name|Value
operator|*
operator|,
name|ValueAsMetadata
operator|*
operator|>
name|ValuesAsMetadata
expr_stmt|;
name|DenseMap
operator|<
name|Metadata
operator|*
operator|,
name|MetadataAsValue
operator|*
operator|>
name|MetadataAsValues
expr_stmt|;
name|DenseSet
operator|<
name|MDTuple
operator|*
operator|,
name|MDTupleInfo
operator|>
name|MDTuples
expr_stmt|;
name|DenseSet
operator|<
name|MDLocation
operator|*
operator|,
name|MDLocationInfo
operator|>
name|MDLocations
expr_stmt|;
comment|// MDNodes may be uniqued or not uniqued.  When they're not uniqued, they
comment|// aren't in the MDNodeSet, but they're still shared between objects, so no
comment|// one object can destroy them.  This set allows us to at least destroy them
comment|// on Context destruction.
name|SmallPtrSet
operator|<
name|UniquableMDNode
operator|*
operator|,
literal|1
operator|>
name|DistinctMDNodes
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|ConstantAggregateZero
operator|*
operator|>
name|CAZConstants
expr_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|ConstantArray
operator|>
name|ArrayConstantsTy
expr_stmt|;
name|ArrayConstantsTy
name|ArrayConstants
decl_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|ConstantStruct
operator|>
name|StructConstantsTy
expr_stmt|;
name|StructConstantsTy
name|StructConstants
decl_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|ConstantVector
operator|>
name|VectorConstantsTy
expr_stmt|;
name|VectorConstantsTy
name|VectorConstants
decl_stmt|;
name|DenseMap
operator|<
name|PointerType
operator|*
operator|,
name|ConstantPointerNull
operator|*
operator|>
name|CPNConstants
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|UndefValue
operator|*
operator|>
name|UVConstants
expr_stmt|;
name|StringMap
operator|<
name|ConstantDataSequential
operator|*
operator|>
name|CDSConstants
expr_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|Function
operator|*
operator|,
specifier|const
name|BasicBlock
operator|*
operator|>
operator|,
name|BlockAddress
operator|*
operator|>
name|BlockAddresses
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|ConstantExpr
operator|>
name|ExprConstants
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|InlineAsm
operator|>
name|InlineAsms
expr_stmt|;
name|ConstantInt
modifier|*
name|TheTrueVal
decl_stmt|;
name|ConstantInt
modifier|*
name|TheFalseVal
decl_stmt|;
name|LeakDetectorImpl
operator|<
name|Value
operator|>
name|LLVMObjects
expr_stmt|;
name|LeakDetectorImpl
operator|<
name|Metadata
operator|>
name|LLVMMDObjects
expr_stmt|;
comment|// Basic type instances.
name|Type
name|VoidTy
decl_stmt|,
name|LabelTy
decl_stmt|,
name|HalfTy
decl_stmt|,
name|FloatTy
decl_stmt|,
name|DoubleTy
decl_stmt|,
name|MetadataTy
decl_stmt|;
name|Type
name|X86_FP80Ty
decl_stmt|,
name|FP128Ty
decl_stmt|,
name|PPC_FP128Ty
decl_stmt|,
name|X86_MMXTy
decl_stmt|;
name|IntegerType
name|Int1Ty
decl_stmt|,
name|Int8Ty
decl_stmt|,
name|Int16Ty
decl_stmt|,
name|Int32Ty
decl_stmt|,
name|Int64Ty
decl_stmt|;
comment|/// TypeAllocator - All dynamically allocated types are allocated from this.
comment|/// They live forever until the context is torn down.
name|BumpPtrAllocator
name|TypeAllocator
decl_stmt|;
name|DenseMap
operator|<
name|unsigned
operator|,
name|IntegerType
operator|*
operator|>
name|IntegerTypes
expr_stmt|;
typedef|typedef
name|DenseSet
operator|<
name|FunctionType
operator|*
operator|,
name|FunctionTypeKeyInfo
operator|>
name|FunctionTypeSet
expr_stmt|;
name|FunctionTypeSet
name|FunctionTypes
decl_stmt|;
typedef|typedef
name|DenseSet
operator|<
name|StructType
operator|*
operator|,
name|AnonStructTypeKeyInfo
operator|>
name|StructTypeSet
expr_stmt|;
name|StructTypeSet
name|AnonStructTypes
decl_stmt|;
name|StringMap
operator|<
name|StructType
operator|*
operator|>
name|NamedStructTypes
expr_stmt|;
name|unsigned
name|NamedStructTypesUniqueID
decl_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|uint64_t
operator|>
operator|,
name|ArrayType
operator|*
operator|>
name|ArrayTypes
expr_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|VectorType
operator|*
operator|>
name|VectorTypes
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|PointerType
operator|*
operator|>
name|PointerTypes
expr_stmt|;
comment|// Pointers in AddrSpace = 0
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|PointerType
operator|*
operator|>
name|ASPointerTypes
expr_stmt|;
comment|/// ValueHandles - This map keeps track of all of the value handles that are
comment|/// watching a Value*.  The Value::HasValueHandle bit is used to know
comment|/// whether or not a value has an entry in this map.
typedef|typedef
name|DenseMap
operator|<
name|Value
operator|*
operator|,
name|ValueHandleBase
operator|*
operator|>
name|ValueHandlesTy
expr_stmt|;
name|ValueHandlesTy
name|ValueHandles
decl_stmt|;
comment|/// CustomMDKindNames - Map to hold the metadata string to ID mapping.
name|StringMap
operator|<
name|unsigned
operator|>
name|CustomMDKindNames
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|TrackingMDNodeRef
operator|>
name|MDPairTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|MDPairTy
operator|,
literal|2
operator|>
name|MDMapTy
expr_stmt|;
comment|/// MetadataStore - Collection of per-instruction metadata used in this
comment|/// context.
name|DenseMap
operator|<
specifier|const
name|Instruction
operator|*
operator|,
name|MDMapTy
operator|>
name|MetadataStore
expr_stmt|;
comment|/// DiscriminatorTable - This table maps file:line locations to an
comment|/// integer representing the next DWARF path discriminator to assign to
comment|/// instructions in different blocks at the same location.
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|unsigned
operator|>
name|DiscriminatorTable
expr_stmt|;
comment|/// IntrinsicIDCache - Cache of intrinsic name (string) to numeric ID mappings
comment|/// requested in this context
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Function
operator|*
operator|,
name|unsigned
operator|>
name|IntrinsicIDCacheTy
expr_stmt|;
name|IntrinsicIDCacheTy
name|IntrinsicIDCache
decl_stmt|;
comment|/// \brief Mapping from a function to its prefix data, which is stored as the
comment|/// operand of an unparented ReturnInst so that the prefix data has a Use.
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Function
operator|*
operator|,
name|ReturnInst
operator|*
operator|>
name|PrefixDataMapTy
expr_stmt|;
name|PrefixDataMapTy
name|PrefixDataMap
decl_stmt|;
comment|/// \brief Mapping from a function to its prologue data, which is stored as
comment|/// the operand of an unparented ReturnInst so that the prologue data has a
comment|/// Use.
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Function
operator|*
operator|,
name|ReturnInst
operator|*
operator|>
name|PrologueDataMapTy
expr_stmt|;
name|PrologueDataMapTy
name|PrologueDataMap
decl_stmt|;
name|int
name|getOrAddScopeRecordIdxEntry
parameter_list|(
name|MDNode
modifier|*
name|N
parameter_list|,
name|int
name|ExistingIdx
parameter_list|)
function_decl|;
name|int
name|getOrAddScopeInlinedAtIdxEntry
parameter_list|(
name|MDNode
modifier|*
name|Scope
parameter_list|,
name|MDNode
modifier|*
name|IA
parameter_list|,
name|int
name|ExistingIdx
parameter_list|)
function_decl|;
name|LLVMContextImpl
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
expr_stmt|;
operator|~
name|LLVMContextImpl
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

