begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- LLVMContextImpl.h - The LLVMContextImpl opaque class -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file declares LLVMContextImpl, the opaque implementation
end_comment

begin_comment
comment|//  of LLVMContext.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_IR_LLVMCONTEXTIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_IR_LLVMCONTEXTIMPL_H
end_define

begin_include
include|#
directive|include
file|"AttributeImpl.h"
end_include

begin_include
include|#
directive|include
file|"ConstantsContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/BinaryFormat/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DebugInfoMetadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/TrackingMDRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/YAMLTraits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantFP
decl_stmt|;
name|class
name|ConstantInt
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|ValueHandleBase
decl_stmt|;
struct|struct
name|DenseMapAPIntKeyInfo
block|{
specifier|static
specifier|inline
name|APInt
name|getEmptyKey
parameter_list|()
block|{
name|APInt
name|V
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|V
operator|.
name|U
operator|.
name|VAL
operator|=
literal|0
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|static
specifier|inline
name|APInt
name|getTombstoneKey
parameter_list|()
block|{
name|APInt
name|V
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|V
operator|.
name|U
operator|.
name|VAL
operator|=
literal|1
expr_stmt|;
return|return
name|V
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|hash_value
argument_list|(
name|Key
argument_list|)
operator|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|APInt
modifier|&
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|getBitWidth
argument_list|()
operator|==
name|RHS
operator|.
name|getBitWidth
argument_list|()
operator|&&
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
struct|;
struct|struct
name|DenseMapAPFloatKeyInfo
block|{
specifier|static
specifier|inline
name|APFloat
name|getEmptyKey
parameter_list|()
block|{
return|return
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|()
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|APFloat
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|()
argument_list|,
literal|2
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|hash_value
argument_list|(
name|Key
argument_list|)
operator|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|LHS
parameter_list|,
specifier|const
name|APFloat
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|bitwiseIsEqual
argument_list|(
name|RHS
argument_list|)
return|;
block|}
block|}
struct|;
struct|struct
name|AnonStructTypeKeyInfo
block|{
struct|struct
name|KeyTy
block|{
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|ETypes
expr_stmt|;
name|bool
name|isPacked
decl_stmt|;
name|KeyTy
argument_list|(
argument|const ArrayRef<Type*>& E
argument_list|,
argument|bool P
argument_list|)
block|:
name|ETypes
argument_list|(
name|E
argument_list|)
operator|,
name|isPacked
argument_list|(
argument|P
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|StructType
operator|*
name|ST
argument_list|)
operator|:
name|ETypes
argument_list|(
name|ST
operator|->
name|elements
argument_list|()
argument_list|)
operator|,
name|isPacked
argument_list|(
argument|ST->isPacked()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
if|if
condition|(
name|isPacked
operator|!=
name|that
operator|.
name|isPacked
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ETypes
operator|!=
name|that
operator|.
name|ETypes
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|operator
decl|!=
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
decl|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
specifier|static
specifier|inline
name|StructType
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|StructType
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|StructType
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|StructType
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|hash_combine
argument_list|(
name|hash_combine_range
argument_list|(
name|Key
operator|.
name|ETypes
operator|.
name|begin
argument_list|()
argument_list|,
name|Key
operator|.
name|ETypes
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|Key
operator|.
name|isPacked
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|StructType
modifier|*
name|ST
parameter_list|)
block|{
return|return
name|getHashValue
argument_list|(
name|KeyTy
argument_list|(
name|ST
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|StructType
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|LHS
operator|==
name|KeyTy
argument_list|(
name|RHS
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|StructType
modifier|*
name|LHS
parameter_list|,
specifier|const
name|StructType
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|FunctionTypeKeyInfo
block|{
struct|struct
name|KeyTy
block|{
specifier|const
name|Type
modifier|*
name|ReturnType
decl_stmt|;
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Params
expr_stmt|;
name|bool
name|isVarArg
decl_stmt|;
name|KeyTy
argument_list|(
argument|const Type* R
argument_list|,
argument|const ArrayRef<Type*>& P
argument_list|,
argument|bool V
argument_list|)
block|:
name|ReturnType
argument_list|(
name|R
argument_list|)
operator|,
name|Params
argument_list|(
name|P
argument_list|)
operator|,
name|isVarArg
argument_list|(
argument|V
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|FunctionType
operator|*
name|FT
argument_list|)
operator|:
name|ReturnType
argument_list|(
name|FT
operator|->
name|getReturnType
argument_list|()
argument_list|)
operator|,
name|Params
argument_list|(
name|FT
operator|->
name|params
argument_list|()
argument_list|)
operator|,
name|isVarArg
argument_list|(
argument|FT->isVarArg()
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
if|if
condition|(
name|ReturnType
operator|!=
name|that
operator|.
name|ReturnType
condition|)
return|return
name|false
return|;
if|if
condition|(
name|isVarArg
operator|!=
name|that
operator|.
name|isVarArg
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Params
operator|!=
name|that
operator|.
name|Params
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|operator
decl|!=
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
decl|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|FunctionType
modifier|*
name|getEmptyKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|FunctionType
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|FunctionType
modifier|*
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|FunctionType
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|hash_combine
argument_list|(
name|Key
operator|.
name|ReturnType
argument_list|,
name|hash_combine_range
argument_list|(
name|Key
operator|.
name|Params
operator|.
name|begin
argument_list|()
argument_list|,
name|Key
operator|.
name|Params
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|Key
operator|.
name|isVarArg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|FunctionType
modifier|*
name|FT
parameter_list|)
block|{
return|return
name|getHashValue
argument_list|(
name|KeyTy
argument_list|(
name|FT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|FunctionType
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|LHS
operator|==
name|KeyTy
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|FunctionType
modifier|*
name|LHS
parameter_list|,
specifier|const
name|FunctionType
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief Structure for hashing arbitrary MDNode operands.
end_comment

begin_decl_stmt
name|class
name|MDNodeOpsKey
block|{
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|RawOps
expr_stmt|;
name|ArrayRef
operator|<
name|MDOperand
operator|>
name|Ops
expr_stmt|;
name|unsigned
name|Hash
decl_stmt|;
name|protected
label|:
name|MDNodeOpsKey
argument_list|(
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|Ops
argument_list|)
operator|:
name|RawOps
argument_list|(
name|Ops
argument_list|)
operator|,
name|Hash
argument_list|(
argument|calculateHash(Ops)
argument_list|)
block|{}
name|template
operator|<
name|class
name|NodeTy
operator|>
name|MDNodeOpsKey
argument_list|(
argument|const NodeTy *N
argument_list|,
argument|unsigned Offset =
literal|0
argument_list|)
operator|:
name|Ops
argument_list|(
name|N
operator|->
name|op_begin
argument_list|()
operator|+
name|Offset
argument_list|,
name|N
operator|->
name|op_end
argument_list|()
argument_list|)
operator|,
name|Hash
argument_list|(
argument|N->getHash()
argument_list|)
block|{}
name|template
operator|<
name|class
name|NodeTy
operator|>
name|bool
name|compareOps
argument_list|(
argument|const NodeTy *RHS
argument_list|,
argument|unsigned Offset =
literal|0
argument_list|)
specifier|const
block|{
if|if
condition|(
name|getHash
argument_list|()
operator|!=
name|RHS
operator|->
name|getHash
argument_list|()
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
operator|(
name|RawOps
operator|.
name|empty
argument_list|()
operator|||
name|Ops
operator|.
name|empty
argument_list|()
operator|)
operator|&&
literal|"Two sets of operands?"
argument_list|)
expr_stmt|;
return|return
name|RawOps
operator|.
name|empty
argument_list|()
condition|?
name|compareOps
argument_list|(
name|Ops
argument_list|,
name|RHS
argument_list|,
name|Offset
argument_list|)
else|:
name|compareOps
argument_list|(
name|RawOps
argument_list|,
name|RHS
argument_list|,
name|Offset
argument_list|)
return|;
block|}
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|calculateHash
parameter_list|(
name|MDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|Offset
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|bool
name|compareOps
argument_list|(
argument|ArrayRef<T> Ops
argument_list|,
argument|const MDNode *RHS
argument_list|,
argument|unsigned Offset
argument_list|)
block|{
if|if
condition|(
name|Ops
operator|.
name|size
argument_list|()
operator|!=
name|RHS
operator|->
name|getNumOperands
argument_list|()
operator|-
name|Offset
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|equal
argument_list|(
name|Ops
operator|.
name|begin
argument_list|()
argument_list|,
name|Ops
operator|.
name|end
argument_list|()
argument_list|,
name|RHS
operator|->
name|op_begin
argument_list|()
operator|+
name|Offset
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}    static
name|unsigned
name|calculateHash
argument_list|(
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|Ops
argument_list|)
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
return|return
name|Hash
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|NodeTy
operator|>
expr|struct
name|MDNodeKeyImpl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Configuration point for MDNodeInfo::isEqual().
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|NodeTy
operator|>
expr|struct
name|MDNodeSubsetEqualImpl
block|{
name|using
name|KeyTy
operator|=
name|MDNodeKeyImpl
operator|<
name|NodeTy
operator|>
block|;
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const KeyTy&LHS
argument_list|,
argument|const NodeTy *RHS
argument_list|)
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const NodeTy *LHS
argument_list|,
argument|const NodeTy *RHS
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief DenseMapInfo for MDTuple.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that we don't need the is-function-local bit, since that's implicit in
end_comment

begin_comment
comment|/// the operands.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|MDTuple
operator|>
operator|:
name|MDNodeOpsKey
block|{
name|MDNodeKeyImpl
argument_list|(
name|ArrayRef
operator|<
name|Metadata
operator|*
operator|>
name|Ops
argument_list|)
operator|:
name|MDNodeOpsKey
argument_list|(
argument|Ops
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|MDTuple
operator|*
name|N
argument_list|)
operator|:
name|MDNodeOpsKey
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const MDTuple *RHS
argument_list|)
specifier|const
block|{
return|return
name|compareOps
argument_list|(
name|RHS
argument_list|)
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|getHash
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|calculateHash
parameter_list|(
name|MDTuple
modifier|*
name|N
parameter_list|)
block|{
return|return
name|MDNodeOpsKey
operator|::
name|calculateHash
argument_list|(
name|N
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief DenseMapInfo for DILocation.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DILocation
operator|>
block|{
name|unsigned
name|Line
block|;
name|unsigned
name|Column
block|;
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|InlinedAt
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|)
operator|:
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Column
argument_list|(
name|Column
argument_list|)
block|,
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|InlinedAt
argument_list|(
argument|InlinedAt
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DILocation
operator|*
name|L
argument_list|)
operator|:
name|Line
argument_list|(
name|L
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Column
argument_list|(
name|L
operator|->
name|getColumn
argument_list|()
argument_list|)
block|,
name|Scope
argument_list|(
name|L
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|InlinedAt
argument_list|(
argument|L->getRawInlinedAt()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DILocation *RHS
argument_list|)
specifier|const
block|{
return|return
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Column
operator|==
name|RHS
operator|->
name|getColumn
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|InlinedAt
operator|==
name|RHS
operator|->
name|getRawInlinedAt
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Line
argument_list|,
name|Column
argument_list|,
name|Scope
argument_list|,
name|InlinedAt
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief DenseMapInfo for GenericDINode.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|GenericDINode
operator|>
operator|:
name|MDNodeOpsKey
block|{
name|unsigned
name|Tag
block|;
name|MDString
operator|*
name|Header
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|MDString *Header
argument_list|,
argument|ArrayRef<Metadata *> DwarfOps
argument_list|)
operator|:
name|MDNodeOpsKey
argument_list|(
name|DwarfOps
argument_list|)
block|,
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Header
argument_list|(
argument|Header
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|GenericDINode
operator|*
name|N
argument_list|)
operator|:
name|MDNodeOpsKey
argument_list|(
name|N
argument_list|,
literal|1
argument_list|)
block|,
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Header
argument_list|(
argument|N->getRawHeader()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const GenericDINode *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Header
operator|==
name|RHS
operator|->
name|getRawHeader
argument_list|()
operator|&&
name|compareOps
argument_list|(
name|RHS
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|getHash
argument_list|()
argument_list|,
name|Tag
argument_list|,
name|Header
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|calculateHash
parameter_list|(
name|GenericDINode
modifier|*
name|N
parameter_list|)
block|{
return|return
name|MDNodeOpsKey
operator|::
name|calculateHash
argument_list|(
name|N
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DISubrange
operator|>
block|{
name|int64_t
name|Count
block|;
name|int64_t
name|LowerBound
block|;
name|MDNodeKeyImpl
argument_list|(
argument|int64_t Count
argument_list|,
argument|int64_t LowerBound
argument_list|)
operator|:
name|Count
argument_list|(
name|Count
argument_list|)
block|,
name|LowerBound
argument_list|(
argument|LowerBound
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DISubrange
operator|*
name|N
argument_list|)
operator|:
name|Count
argument_list|(
name|N
operator|->
name|getCount
argument_list|()
argument_list|)
block|,
name|LowerBound
argument_list|(
argument|N->getLowerBound()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DISubrange *RHS
argument_list|)
specifier|const
block|{
return|return
name|Count
operator|==
name|RHS
operator|->
name|getCount
argument_list|()
operator|&&
name|LowerBound
operator|==
name|RHS
operator|->
name|getLowerBound
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Count
argument_list|,
name|LowerBound
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIEnumerator
operator|>
block|{
name|int64_t
name|Value
block|;
name|MDString
operator|*
name|Name
block|;
name|MDNodeKeyImpl
argument_list|(
argument|int64_t Value
argument_list|,
argument|MDString *Name
argument_list|)
operator|:
name|Value
argument_list|(
name|Value
argument_list|)
block|,
name|Name
argument_list|(
argument|Name
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIEnumerator
operator|*
name|N
argument_list|)
operator|:
name|Value
argument_list|(
name|N
operator|->
name|getValue
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
argument|N->getRawName()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIEnumerator *RHS
argument_list|)
specifier|const
block|{
return|return
name|Value
operator|==
name|RHS
operator|->
name|getValue
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Value
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIBasicType
operator|>
block|{
name|unsigned
name|Tag
block|;
name|MDString
operator|*
name|Name
block|;
name|uint64_t
name|SizeInBits
block|;
name|uint32_t
name|AlignInBits
block|;
name|unsigned
name|Encoding
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|)
operator|:
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|SizeInBits
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|AlignInBits
argument_list|)
block|,
name|Encoding
argument_list|(
argument|Encoding
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIBasicType
operator|*
name|N
argument_list|)
operator|:
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|N
operator|->
name|getSizeInBits
argument_list|()
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|N
operator|->
name|getAlignInBits
argument_list|()
argument_list|)
block|,
name|Encoding
argument_list|(
argument|N->getEncoding()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIBasicType *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|SizeInBits
operator|==
name|RHS
operator|->
name|getSizeInBits
argument_list|()
operator|&&
name|AlignInBits
operator|==
name|RHS
operator|->
name|getAlignInBits
argument_list|()
operator|&&
name|Encoding
operator|==
name|RHS
operator|->
name|getEncoding
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Tag
argument_list|,
name|Name
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|Encoding
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIDerivedType
operator|>
block|{
name|unsigned
name|Tag
block|;
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|BaseType
block|;
name|uint64_t
name|SizeInBits
block|;
name|uint64_t
name|OffsetInBits
block|;
name|uint32_t
name|AlignInBits
block|;
name|Optional
operator|<
name|unsigned
operator|>
name|DWARFAddressSpace
block|;
name|unsigned
name|Flags
block|;
name|Metadata
operator|*
name|ExtraData
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|Optional<unsigned> DWARFAddressSpace
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *ExtraData
argument_list|)
operator|:
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|BaseType
argument_list|(
name|BaseType
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|SizeInBits
argument_list|)
block|,
name|OffsetInBits
argument_list|(
name|OffsetInBits
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|AlignInBits
argument_list|)
block|,
name|DWARFAddressSpace
argument_list|(
name|DWARFAddressSpace
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|ExtraData
argument_list|(
argument|ExtraData
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIDerivedType
operator|*
name|N
argument_list|)
operator|:
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|BaseType
argument_list|(
name|N
operator|->
name|getRawBaseType
argument_list|()
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|N
operator|->
name|getSizeInBits
argument_list|()
argument_list|)
block|,
name|OffsetInBits
argument_list|(
name|N
operator|->
name|getOffsetInBits
argument_list|()
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|N
operator|->
name|getAlignInBits
argument_list|()
argument_list|)
block|,
name|DWARFAddressSpace
argument_list|(
name|N
operator|->
name|getDWARFAddressSpace
argument_list|()
argument_list|)
block|,
name|Flags
argument_list|(
name|N
operator|->
name|getFlags
argument_list|()
argument_list|)
block|,
name|ExtraData
argument_list|(
argument|N->getRawExtraData()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIDerivedType *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|BaseType
operator|==
name|RHS
operator|->
name|getRawBaseType
argument_list|()
operator|&&
name|SizeInBits
operator|==
name|RHS
operator|->
name|getSizeInBits
argument_list|()
operator|&&
name|AlignInBits
operator|==
name|RHS
operator|->
name|getAlignInBits
argument_list|()
operator|&&
name|OffsetInBits
operator|==
name|RHS
operator|->
name|getOffsetInBits
argument_list|()
operator|&&
name|DWARFAddressSpace
operator|==
name|RHS
operator|->
name|getDWARFAddressSpace
argument_list|()
operator|&&
name|Flags
operator|==
name|RHS
operator|->
name|getFlags
argument_list|()
operator|&&
name|ExtraData
operator|==
name|RHS
operator|->
name|getRawExtraData
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
comment|// If this is a member inside an ODR type, only hash the type and the name.
comment|// Otherwise the hash will be stronger than
comment|// MDNodeSubsetEqualImpl::isODRMember().
if|if
condition|(
name|Tag
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|&&
name|Name
condition|)
if|if
condition|(
name|auto
operator|*
name|CT
operator|=
name|dyn_cast_or_null
operator|<
name|DICompositeType
operator|>
operator|(
name|Scope
operator|)
condition|)
if|if
condition|(
name|CT
operator|->
name|getRawIdentifier
argument_list|()
condition|)
return|return
name|hash_combine
argument_list|(
name|Name
argument_list|,
name|Scope
argument_list|)
return|;
end_expr_stmt

begin_comment
comment|// Intentionally computes the hash on a subset of the operands for
end_comment

begin_comment
comment|// performance reason. The subset has to be significant enough to avoid
end_comment

begin_comment
comment|// collision "most of the time". There is no correctness issue in case of
end_comment

begin_comment
comment|// collision because of the full check above.
end_comment

begin_return
return|return
name|hash_combine
argument_list|(
name|Tag
argument_list|,
name|Name
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Scope
argument_list|,
name|BaseType
argument_list|,
name|Flags
argument_list|)
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MDNodeSubsetEqualImpl
operator|<
name|DIDerivedType
operator|>
block|{
name|using
name|KeyTy
operator|=
name|MDNodeKeyImpl
operator|<
name|DIDerivedType
operator|>
block|;
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const KeyTy&LHS
argument_list|,
argument|const DIDerivedType *RHS
argument_list|)
block|{
return|return
name|isODRMember
argument_list|(
name|LHS
operator|.
name|Tag
argument_list|,
name|LHS
operator|.
name|Scope
argument_list|,
name|LHS
operator|.
name|Name
argument_list|,
name|RHS
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const DIDerivedType *LHS
argument_list|,
argument|const DIDerivedType *RHS
argument_list|)
block|{
return|return
name|isODRMember
argument_list|(
name|LHS
operator|->
name|getTag
argument_list|()
argument_list|,
name|LHS
operator|->
name|getRawScope
argument_list|()
argument_list|,
name|LHS
operator|->
name|getRawName
argument_list|()
argument_list|,
name|RHS
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Subprograms compare equal if they declare the same function in an ODR
end_comment

begin_comment
comment|/// type.
end_comment

begin_function
specifier|static
name|bool
name|isODRMember
parameter_list|(
name|unsigned
name|Tag
parameter_list|,
specifier|const
name|Metadata
modifier|*
name|Scope
parameter_list|,
specifier|const
name|MDString
modifier|*
name|Name
parameter_list|,
specifier|const
name|DIDerivedType
modifier|*
name|RHS
parameter_list|)
block|{
comment|// Check whether the LHS is eligible.
if|if
condition|(
name|Tag
operator|!=
name|dwarf
operator|::
name|DW_TAG_member
operator|||
operator|!
name|Name
condition|)
return|return
name|false
return|;
name|auto
operator|*
name|CT
operator|=
name|dyn_cast_or_null
operator|<
name|DICompositeType
operator|>
operator|(
name|Scope
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CT
operator|||
operator|!
name|CT
operator|->
name|getRawIdentifier
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Compare to the RHS.
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DICompositeType
operator|>
block|{
name|unsigned
name|Tag
block|;
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|BaseType
block|;
name|uint64_t
name|SizeInBits
block|;
name|uint64_t
name|OffsetInBits
block|;
name|uint32_t
name|AlignInBits
block|;
name|unsigned
name|Flags
block|;
name|Metadata
operator|*
name|Elements
block|;
name|unsigned
name|RuntimeLang
block|;
name|Metadata
operator|*
name|VTableHolder
block|;
name|Metadata
operator|*
name|TemplateParams
block|;
name|MDString
operator|*
name|Identifier
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint32_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|Metadata *VTableHolder
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|MDString *Identifier
argument_list|)
operator|:
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|BaseType
argument_list|(
name|BaseType
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|SizeInBits
argument_list|)
block|,
name|OffsetInBits
argument_list|(
name|OffsetInBits
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|AlignInBits
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|Elements
argument_list|(
name|Elements
argument_list|)
block|,
name|RuntimeLang
argument_list|(
name|RuntimeLang
argument_list|)
block|,
name|VTableHolder
argument_list|(
name|VTableHolder
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|TemplateParams
argument_list|)
block|,
name|Identifier
argument_list|(
argument|Identifier
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DICompositeType
operator|*
name|N
argument_list|)
operator|:
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|BaseType
argument_list|(
name|N
operator|->
name|getRawBaseType
argument_list|()
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|N
operator|->
name|getSizeInBits
argument_list|()
argument_list|)
block|,
name|OffsetInBits
argument_list|(
name|N
operator|->
name|getOffsetInBits
argument_list|()
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|N
operator|->
name|getAlignInBits
argument_list|()
argument_list|)
block|,
name|Flags
argument_list|(
name|N
operator|->
name|getFlags
argument_list|()
argument_list|)
block|,
name|Elements
argument_list|(
name|N
operator|->
name|getRawElements
argument_list|()
argument_list|)
block|,
name|RuntimeLang
argument_list|(
name|N
operator|->
name|getRuntimeLang
argument_list|()
argument_list|)
block|,
name|VTableHolder
argument_list|(
name|N
operator|->
name|getRawVTableHolder
argument_list|()
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|N
operator|->
name|getRawTemplateParams
argument_list|()
argument_list|)
block|,
name|Identifier
argument_list|(
argument|N->getRawIdentifier()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DICompositeType *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|BaseType
operator|==
name|RHS
operator|->
name|getRawBaseType
argument_list|()
operator|&&
name|SizeInBits
operator|==
name|RHS
operator|->
name|getSizeInBits
argument_list|()
operator|&&
name|AlignInBits
operator|==
name|RHS
operator|->
name|getAlignInBits
argument_list|()
operator|&&
name|OffsetInBits
operator|==
name|RHS
operator|->
name|getOffsetInBits
argument_list|()
operator|&&
name|Flags
operator|==
name|RHS
operator|->
name|getFlags
argument_list|()
operator|&&
name|Elements
operator|==
name|RHS
operator|->
name|getRawElements
argument_list|()
operator|&&
name|RuntimeLang
operator|==
name|RHS
operator|->
name|getRuntimeLang
argument_list|()
operator|&&
name|VTableHolder
operator|==
name|RHS
operator|->
name|getRawVTableHolder
argument_list|()
operator|&&
name|TemplateParams
operator|==
name|RHS
operator|->
name|getRawTemplateParams
argument_list|()
operator|&&
name|Identifier
operator|==
name|RHS
operator|->
name|getRawIdentifier
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
comment|// Intentionally computes the hash on a subset of the operands for
comment|// performance reason. The subset has to be significant enough to avoid
comment|// collision "most of the time". There is no correctness issue in case of
comment|// collision because of the full check above.
return|return
name|hash_combine
argument_list|(
name|Name
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|BaseType
argument_list|,
name|Scope
argument_list|,
name|Elements
argument_list|,
name|TemplateParams
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DISubroutineType
operator|>
block|{
name|unsigned
name|Flags
block|;
name|uint8_t
name|CC
block|;
name|Metadata
operator|*
name|TypeArray
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Flags
argument_list|,
argument|uint8_t CC
argument_list|,
argument|Metadata *TypeArray
argument_list|)
operator|:
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|CC
argument_list|(
name|CC
argument_list|)
block|,
name|TypeArray
argument_list|(
argument|TypeArray
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DISubroutineType
operator|*
name|N
argument_list|)
operator|:
name|Flags
argument_list|(
name|N
operator|->
name|getFlags
argument_list|()
argument_list|)
block|,
name|CC
argument_list|(
name|N
operator|->
name|getCC
argument_list|()
argument_list|)
block|,
name|TypeArray
argument_list|(
argument|N->getRawTypeArray()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DISubroutineType *RHS
argument_list|)
specifier|const
block|{
return|return
name|Flags
operator|==
name|RHS
operator|->
name|getFlags
argument_list|()
operator|&&
name|CC
operator|==
name|RHS
operator|->
name|getCC
argument_list|()
operator|&&
name|TypeArray
operator|==
name|RHS
operator|->
name|getRawTypeArray
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Flags
argument_list|,
name|CC
argument_list|,
name|TypeArray
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIFile
operator|>
block|{
name|MDString
operator|*
name|Filename
block|;
name|MDString
operator|*
name|Directory
block|;
name|DIFile
operator|::
name|ChecksumKind
name|CSKind
block|;
name|MDString
operator|*
name|Checksum
block|;
name|MDNodeKeyImpl
argument_list|(
argument|MDString *Filename
argument_list|,
argument|MDString *Directory
argument_list|,
argument|DIFile::ChecksumKind CSKind
argument_list|,
argument|MDString *Checksum
argument_list|)
operator|:
name|Filename
argument_list|(
name|Filename
argument_list|)
block|,
name|Directory
argument_list|(
name|Directory
argument_list|)
block|,
name|CSKind
argument_list|(
name|CSKind
argument_list|)
block|,
name|Checksum
argument_list|(
argument|Checksum
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIFile
operator|*
name|N
argument_list|)
operator|:
name|Filename
argument_list|(
name|N
operator|->
name|getRawFilename
argument_list|()
argument_list|)
block|,
name|Directory
argument_list|(
name|N
operator|->
name|getRawDirectory
argument_list|()
argument_list|)
block|,
name|CSKind
argument_list|(
name|N
operator|->
name|getChecksumKind
argument_list|()
argument_list|)
block|,
name|Checksum
argument_list|(
argument|N->getRawChecksum()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIFile *RHS
argument_list|)
specifier|const
block|{
return|return
name|Filename
operator|==
name|RHS
operator|->
name|getRawFilename
argument_list|()
operator|&&
name|Directory
operator|==
name|RHS
operator|->
name|getRawDirectory
argument_list|()
operator|&&
name|CSKind
operator|==
name|RHS
operator|->
name|getChecksumKind
argument_list|()
operator|&&
name|Checksum
operator|==
name|RHS
operator|->
name|getRawChecksum
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Filename
argument_list|,
name|Directory
argument_list|,
name|CSKind
argument_list|,
name|Checksum
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DISubprogram
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|MDString
operator|*
name|Name
block|;
name|MDString
operator|*
name|LinkageName
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|Type
block|;
name|bool
name|IsLocalToUnit
block|;
name|bool
name|IsDefinition
block|;
name|unsigned
name|ScopeLine
block|;
name|Metadata
operator|*
name|ContainingType
block|;
name|unsigned
name|Virtuality
block|;
name|unsigned
name|VirtualIndex
block|;
name|int
name|ThisAdjustment
block|;
name|unsigned
name|Flags
block|;
name|bool
name|IsOptimized
block|;
name|Metadata
operator|*
name|Unit
block|;
name|Metadata
operator|*
name|TemplateParams
block|;
name|Metadata
operator|*
name|Declaration
block|;
name|Metadata
operator|*
name|Variables
block|;
name|Metadata
operator|*
name|ThrownTypes
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|Metadata *ContainingType
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|int ThisAdjustment
argument_list|,
argument|unsigned Flags
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|Metadata *Unit
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|Metadata *Declaration
argument_list|,
argument|Metadata *Variables
argument_list|,
argument|Metadata *ThrownTypes
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|LinkageName
argument_list|(
name|LinkageName
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Type
argument_list|(
name|Type
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|IsDefinition
argument_list|)
block|,
name|ScopeLine
argument_list|(
name|ScopeLine
argument_list|)
block|,
name|ContainingType
argument_list|(
name|ContainingType
argument_list|)
block|,
name|Virtuality
argument_list|(
name|Virtuality
argument_list|)
block|,
name|VirtualIndex
argument_list|(
name|VirtualIndex
argument_list|)
block|,
name|ThisAdjustment
argument_list|(
name|ThisAdjustment
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|IsOptimized
argument_list|(
name|IsOptimized
argument_list|)
block|,
name|Unit
argument_list|(
name|Unit
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|TemplateParams
argument_list|)
block|,
name|Declaration
argument_list|(
name|Declaration
argument_list|)
block|,
name|Variables
argument_list|(
name|Variables
argument_list|)
block|,
name|ThrownTypes
argument_list|(
argument|ThrownTypes
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DISubprogram
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|LinkageName
argument_list|(
name|N
operator|->
name|getRawLinkageName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
name|N
operator|->
name|getRawType
argument_list|()
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|N
operator|->
name|isLocalToUnit
argument_list|()
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|N
operator|->
name|isDefinition
argument_list|()
argument_list|)
block|,
name|ScopeLine
argument_list|(
name|N
operator|->
name|getScopeLine
argument_list|()
argument_list|)
block|,
name|ContainingType
argument_list|(
name|N
operator|->
name|getRawContainingType
argument_list|()
argument_list|)
block|,
name|Virtuality
argument_list|(
name|N
operator|->
name|getVirtuality
argument_list|()
argument_list|)
block|,
name|VirtualIndex
argument_list|(
name|N
operator|->
name|getVirtualIndex
argument_list|()
argument_list|)
block|,
name|ThisAdjustment
argument_list|(
name|N
operator|->
name|getThisAdjustment
argument_list|()
argument_list|)
block|,
name|Flags
argument_list|(
name|N
operator|->
name|getFlags
argument_list|()
argument_list|)
block|,
name|IsOptimized
argument_list|(
name|N
operator|->
name|isOptimized
argument_list|()
argument_list|)
block|,
name|Unit
argument_list|(
name|N
operator|->
name|getRawUnit
argument_list|()
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|N
operator|->
name|getRawTemplateParams
argument_list|()
argument_list|)
block|,
name|Declaration
argument_list|(
name|N
operator|->
name|getRawDeclaration
argument_list|()
argument_list|)
block|,
name|Variables
argument_list|(
name|N
operator|->
name|getRawVariables
argument_list|()
argument_list|)
block|,
name|ThrownTypes
argument_list|(
argument|N->getRawThrownTypes()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DISubprogram *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|LinkageName
operator|==
name|RHS
operator|->
name|getRawLinkageName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
operator|&&
name|IsLocalToUnit
operator|==
name|RHS
operator|->
name|isLocalToUnit
argument_list|()
operator|&&
name|IsDefinition
operator|==
name|RHS
operator|->
name|isDefinition
argument_list|()
operator|&&
name|ScopeLine
operator|==
name|RHS
operator|->
name|getScopeLine
argument_list|()
operator|&&
name|ContainingType
operator|==
name|RHS
operator|->
name|getRawContainingType
argument_list|()
operator|&&
name|Virtuality
operator|==
name|RHS
operator|->
name|getVirtuality
argument_list|()
operator|&&
name|VirtualIndex
operator|==
name|RHS
operator|->
name|getVirtualIndex
argument_list|()
operator|&&
name|ThisAdjustment
operator|==
name|RHS
operator|->
name|getThisAdjustment
argument_list|()
operator|&&
name|Flags
operator|==
name|RHS
operator|->
name|getFlags
argument_list|()
operator|&&
name|IsOptimized
operator|==
name|RHS
operator|->
name|isOptimized
argument_list|()
operator|&&
name|Unit
operator|==
name|RHS
operator|->
name|getUnit
argument_list|()
operator|&&
name|TemplateParams
operator|==
name|RHS
operator|->
name|getRawTemplateParams
argument_list|()
operator|&&
name|Declaration
operator|==
name|RHS
operator|->
name|getRawDeclaration
argument_list|()
operator|&&
name|Variables
operator|==
name|RHS
operator|->
name|getRawVariables
argument_list|()
operator|&&
name|ThrownTypes
operator|==
name|RHS
operator|->
name|getRawThrownTypes
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
comment|// If this is a declaration inside an ODR type, only hash the type and the
comment|// name.  Otherwise the hash will be stronger than
comment|// MDNodeSubsetEqualImpl::isDeclarationOfODRMember().
if|if
condition|(
operator|!
name|IsDefinition
operator|&&
name|LinkageName
condition|)
if|if
condition|(
name|auto
operator|*
name|CT
operator|=
name|dyn_cast_or_null
operator|<
name|DICompositeType
operator|>
operator|(
name|Scope
operator|)
condition|)
if|if
condition|(
name|CT
operator|->
name|getRawIdentifier
argument_list|()
condition|)
return|return
name|hash_combine
argument_list|(
name|LinkageName
argument_list|,
name|Scope
argument_list|)
return|;
end_expr_stmt

begin_comment
comment|// Intentionally computes the hash on a subset of the operands for
end_comment

begin_comment
comment|// performance reason. The subset has to be significant enough to avoid
end_comment

begin_comment
comment|// collision "most of the time". There is no correctness issue in case of
end_comment

begin_comment
comment|// collision because of the full check above.
end_comment

begin_return
return|return
name|hash_combine
argument_list|(
name|Name
argument_list|,
name|Scope
argument_list|,
name|File
argument_list|,
name|Type
argument_list|,
name|Line
argument_list|)
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MDNodeSubsetEqualImpl
operator|<
name|DISubprogram
operator|>
block|{
name|using
name|KeyTy
operator|=
name|MDNodeKeyImpl
operator|<
name|DISubprogram
operator|>
block|;
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const KeyTy&LHS
argument_list|,
argument|const DISubprogram *RHS
argument_list|)
block|{
return|return
name|isDeclarationOfODRMember
argument_list|(
name|LHS
operator|.
name|IsDefinition
argument_list|,
name|LHS
operator|.
name|Scope
argument_list|,
name|LHS
operator|.
name|LinkageName
argument_list|,
name|LHS
operator|.
name|TemplateParams
argument_list|,
name|RHS
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isSubsetEqual
argument_list|(
argument|const DISubprogram *LHS
argument_list|,
argument|const DISubprogram *RHS
argument_list|)
block|{
return|return
name|isDeclarationOfODRMember
argument_list|(
name|LHS
operator|->
name|isDefinition
argument_list|()
argument_list|,
name|LHS
operator|->
name|getRawScope
argument_list|()
argument_list|,
name|LHS
operator|->
name|getRawLinkageName
argument_list|()
argument_list|,
name|LHS
operator|->
name|getRawTemplateParams
argument_list|()
argument_list|,
name|RHS
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Subprograms compare equal if they declare the same function in an ODR
end_comment

begin_comment
comment|/// type.
end_comment

begin_function
specifier|static
name|bool
name|isDeclarationOfODRMember
parameter_list|(
name|bool
name|IsDefinition
parameter_list|,
specifier|const
name|Metadata
modifier|*
name|Scope
parameter_list|,
specifier|const
name|MDString
modifier|*
name|LinkageName
parameter_list|,
specifier|const
name|Metadata
modifier|*
name|TemplateParams
parameter_list|,
specifier|const
name|DISubprogram
modifier|*
name|RHS
parameter_list|)
block|{
comment|// Check whether the LHS is eligible.
if|if
condition|(
name|IsDefinition
operator|||
operator|!
name|Scope
operator|||
operator|!
name|LinkageName
condition|)
return|return
name|false
return|;
name|auto
operator|*
name|CT
operator|=
name|dyn_cast_or_null
operator|<
name|DICompositeType
operator|>
operator|(
name|Scope
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CT
operator|||
operator|!
name|CT
operator|->
name|getRawIdentifier
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Compare to the RHS.
comment|// FIXME: We need to compare template parameters here to avoid incorrect
comment|// collisions in mapMetadata when RF_MoveDistinctMDs and a ODR-DISubprogram
comment|// has a non-ODR template parameter (i.e., a DICompositeType that does not
comment|// have an identifier). Eventually we should decouple ODR logic from
comment|// uniquing logic.
return|return
name|IsDefinition
operator|==
name|RHS
operator|->
name|isDefinition
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|LinkageName
operator|==
name|RHS
operator|->
name|getRawLinkageName
argument_list|()
operator|&&
name|TemplateParams
operator|==
name|RHS
operator|->
name|getRawTemplateParams
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DILexicalBlock
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|unsigned
name|Column
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Column
argument_list|(
argument|Column
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DILexicalBlock
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Column
argument_list|(
argument|N->getColumn()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DILexicalBlock *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Column
operator|==
name|RHS
operator|->
name|getColumn
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DILexicalBlockFile
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Discriminator
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Discriminator
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Discriminator
argument_list|(
argument|Discriminator
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DILexicalBlockFile
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Discriminator
argument_list|(
argument|N->getDiscriminator()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DILexicalBlockFile *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Discriminator
operator|==
name|RHS
operator|->
name|getDiscriminator
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|File
argument_list|,
name|Discriminator
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DINamespace
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|MDString
operator|*
name|Name
block|;
name|bool
name|ExportSymbols
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|bool ExportSymbols
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|ExportSymbols
argument_list|(
argument|ExportSymbols
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DINamespace
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|ExportSymbols
argument_list|(
argument|N->getExportSymbols()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DINamespace *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|ExportSymbols
operator|==
name|RHS
operator|->
name|getExportSymbols
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIModule
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|MDString
operator|*
name|Name
block|;
name|MDString
operator|*
name|ConfigurationMacros
block|;
name|MDString
operator|*
name|IncludePath
block|;
name|MDString
operator|*
name|ISysRoot
block|;
name|MDNodeKeyImpl
argument_list|(
name|Metadata
operator|*
name|Scope
argument_list|,
name|MDString
operator|*
name|Name
argument_list|,
name|MDString
operator|*
name|ConfigurationMacros
argument_list|,
name|MDString
operator|*
name|IncludePath
argument_list|,
name|MDString
operator|*
name|ISysRoot
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|ConfigurationMacros
argument_list|(
name|ConfigurationMacros
argument_list|)
block|,
name|IncludePath
argument_list|(
name|IncludePath
argument_list|)
block|,
name|ISysRoot
argument_list|(
argument|ISysRoot
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIModule
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|ConfigurationMacros
argument_list|(
name|N
operator|->
name|getRawConfigurationMacros
argument_list|()
argument_list|)
block|,
name|IncludePath
argument_list|(
name|N
operator|->
name|getRawIncludePath
argument_list|()
argument_list|)
block|,
name|ISysRoot
argument_list|(
argument|N->getRawISysRoot()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIModule *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|ConfigurationMacros
operator|==
name|RHS
operator|->
name|getRawConfigurationMacros
argument_list|()
operator|&&
name|IncludePath
operator|==
name|RHS
operator|->
name|getRawIncludePath
argument_list|()
operator|&&
name|ISysRoot
operator|==
name|RHS
operator|->
name|getRawISysRoot
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|Name
argument_list|,
name|ConfigurationMacros
argument_list|,
name|IncludePath
argument_list|,
name|ISysRoot
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DITemplateTypeParameter
operator|>
block|{
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|Type
block|;
name|MDNodeKeyImpl
argument_list|(
name|MDString
operator|*
name|Name
argument_list|,
name|Metadata
operator|*
name|Type
argument_list|)
operator|:
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Type
argument_list|(
argument|Type
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DITemplateTypeParameter
operator|*
name|N
argument_list|)
operator|:
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
argument|N->getRawType()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DITemplateTypeParameter *RHS
argument_list|)
specifier|const
block|{
return|return
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Name
argument_list|,
name|Type
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DITemplateValueParameter
operator|>
block|{
name|unsigned
name|Tag
block|;
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|Type
block|;
name|Metadata
operator|*
name|Value
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *Type
argument_list|,
argument|Metadata *Value
argument_list|)
operator|:
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Type
argument_list|(
name|Type
argument_list|)
block|,
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DITemplateValueParameter
operator|*
name|N
argument_list|)
operator|:
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
name|N
operator|->
name|getRawType
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|N->getValue()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DITemplateValueParameter *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
operator|&&
name|Value
operator|==
name|RHS
operator|->
name|getValue
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Tag
argument_list|,
name|Name
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIGlobalVariable
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|MDString
operator|*
name|Name
block|;
name|MDString
operator|*
name|LinkageName
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|Type
block|;
name|bool
name|IsLocalToUnit
block|;
name|bool
name|IsDefinition
block|;
name|Metadata
operator|*
name|StaticDataMemberDeclaration
block|;
name|uint32_t
name|AlignInBits
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|Metadata *StaticDataMemberDeclaration
argument_list|,
argument|uint32_t AlignInBits
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|LinkageName
argument_list|(
name|LinkageName
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Type
argument_list|(
name|Type
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|IsDefinition
argument_list|)
block|,
name|StaticDataMemberDeclaration
argument_list|(
name|StaticDataMemberDeclaration
argument_list|)
block|,
name|AlignInBits
argument_list|(
argument|AlignInBits
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIGlobalVariable
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|LinkageName
argument_list|(
name|N
operator|->
name|getRawLinkageName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
name|N
operator|->
name|getRawType
argument_list|()
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|N
operator|->
name|isLocalToUnit
argument_list|()
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|N
operator|->
name|isDefinition
argument_list|()
argument_list|)
block|,
name|StaticDataMemberDeclaration
argument_list|(
name|N
operator|->
name|getRawStaticDataMemberDeclaration
argument_list|()
argument_list|)
block|,
name|AlignInBits
argument_list|(
argument|N->getAlignInBits()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIGlobalVariable *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|LinkageName
operator|==
name|RHS
operator|->
name|getRawLinkageName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
operator|&&
name|IsLocalToUnit
operator|==
name|RHS
operator|->
name|isLocalToUnit
argument_list|()
operator|&&
name|IsDefinition
operator|==
name|RHS
operator|->
name|isDefinition
argument_list|()
operator|&&
name|StaticDataMemberDeclaration
operator|==
name|RHS
operator|->
name|getRawStaticDataMemberDeclaration
argument_list|()
operator|&&
name|AlignInBits
operator|==
name|RHS
operator|->
name|getAlignInBits
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
comment|// We do not use AlignInBits in hashing function here on purpose:
comment|// in most cases this param for local variable is zero (for function param
comment|// it is always zero). This leads to lots of hash collisions and errors on
comment|// cases with lots of similar variables.
comment|// clang/test/CodeGen/debug-info-257-args.c is an example of this problem,
comment|// generated IR is random for each run and test fails with Align included.
comment|// TODO: make hashing work fine with such situations
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|Name
argument_list|,
name|LinkageName
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|IsLocalToUnit
argument_list|,
name|IsDefinition
argument_list|,
comment|/* AlignInBits, */
name|StaticDataMemberDeclaration
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DILocalVariable
operator|>
block|{
name|Metadata
operator|*
name|Scope
block|;
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|Type
block|;
name|unsigned
name|Arg
block|;
name|unsigned
name|Flags
block|;
name|uint32_t
name|AlignInBits
block|;
name|MDNodeKeyImpl
argument_list|(
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|unsigned Arg
argument_list|,
argument|unsigned Flags
argument_list|,
argument|uint32_t AlignInBits
argument_list|)
operator|:
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Type
argument_list|(
name|Type
argument_list|)
block|,
name|Arg
argument_list|(
name|Arg
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|AlignInBits
argument_list|(
argument|AlignInBits
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DILocalVariable
operator|*
name|N
argument_list|)
operator|:
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
name|N
operator|->
name|getRawType
argument_list|()
argument_list|)
block|,
name|Arg
argument_list|(
name|N
operator|->
name|getArg
argument_list|()
argument_list|)
block|,
name|Flags
argument_list|(
name|N
operator|->
name|getFlags
argument_list|()
argument_list|)
block|,
name|AlignInBits
argument_list|(
argument|N->getAlignInBits()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DILocalVariable *RHS
argument_list|)
specifier|const
block|{
return|return
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
operator|&&
name|Arg
operator|==
name|RHS
operator|->
name|getArg
argument_list|()
operator|&&
name|Flags
operator|==
name|RHS
operator|->
name|getFlags
argument_list|()
operator|&&
name|AlignInBits
operator|==
name|RHS
operator|->
name|getAlignInBits
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
comment|// We do not use AlignInBits in hashing function here on purpose:
comment|// in most cases this param for local variable is zero (for function param
comment|// it is always zero). This leads to lots of hash collisions and errors on
comment|// cases with lots of similar variables.
comment|// clang/test/CodeGen/debug-info-257-args.c is an example of this problem,
comment|// generated IR is random for each run and test fails with Align included.
comment|// TODO: make hashing work fine with such situations
return|return
name|hash_combine
argument_list|(
name|Scope
argument_list|,
name|Name
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|Arg
argument_list|,
name|Flags
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIExpression
operator|>
block|{
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|Elements
block|;
name|MDNodeKeyImpl
argument_list|(
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|Elements
argument_list|)
operator|:
name|Elements
argument_list|(
argument|Elements
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIExpression
operator|*
name|N
argument_list|)
operator|:
name|Elements
argument_list|(
argument|N->getElements()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIExpression *RHS
argument_list|)
specifier|const
block|{
return|return
name|Elements
operator|==
name|RHS
operator|->
name|getElements
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine_range
argument_list|(
name|Elements
operator|.
name|begin
argument_list|()
argument_list|,
name|Elements
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIGlobalVariableExpression
operator|>
block|{
name|Metadata
operator|*
name|Variable
block|;
name|Metadata
operator|*
name|Expression
block|;
name|MDNodeKeyImpl
argument_list|(
name|Metadata
operator|*
name|Variable
argument_list|,
name|Metadata
operator|*
name|Expression
argument_list|)
operator|:
name|Variable
argument_list|(
name|Variable
argument_list|)
block|,
name|Expression
argument_list|(
argument|Expression
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIGlobalVariableExpression
operator|*
name|N
argument_list|)
operator|:
name|Variable
argument_list|(
name|N
operator|->
name|getRawVariable
argument_list|()
argument_list|)
block|,
name|Expression
argument_list|(
argument|N->getRawExpression()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIGlobalVariableExpression *RHS
argument_list|)
specifier|const
block|{
return|return
name|Variable
operator|==
name|RHS
operator|->
name|getRawVariable
argument_list|()
operator|&&
name|Expression
operator|==
name|RHS
operator|->
name|getRawExpression
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Variable
argument_list|,
name|Expression
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIObjCProperty
operator|>
block|{
name|MDString
operator|*
name|Name
block|;
name|Metadata
operator|*
name|File
block|;
name|unsigned
name|Line
block|;
name|MDString
operator|*
name|GetterName
block|;
name|MDString
operator|*
name|SetterName
block|;
name|unsigned
name|Attributes
block|;
name|Metadata
operator|*
name|Type
block|;
name|MDNodeKeyImpl
argument_list|(
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *GetterName
argument_list|,
argument|MDString *SetterName
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|Metadata *Type
argument_list|)
operator|:
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|GetterName
argument_list|(
name|GetterName
argument_list|)
block|,
name|SetterName
argument_list|(
name|SetterName
argument_list|)
block|,
name|Attributes
argument_list|(
name|Attributes
argument_list|)
block|,
name|Type
argument_list|(
argument|Type
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIObjCProperty
operator|*
name|N
argument_list|)
operator|:
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|GetterName
argument_list|(
name|N
operator|->
name|getRawGetterName
argument_list|()
argument_list|)
block|,
name|SetterName
argument_list|(
name|N
operator|->
name|getRawSetterName
argument_list|()
argument_list|)
block|,
name|Attributes
argument_list|(
name|N
operator|->
name|getAttributes
argument_list|()
argument_list|)
block|,
name|Type
argument_list|(
argument|N->getRawType()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIObjCProperty *RHS
argument_list|)
specifier|const
block|{
return|return
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|GetterName
operator|==
name|RHS
operator|->
name|getRawGetterName
argument_list|()
operator|&&
name|SetterName
operator|==
name|RHS
operator|->
name|getRawSetterName
argument_list|()
operator|&&
name|Attributes
operator|==
name|RHS
operator|->
name|getAttributes
argument_list|()
operator|&&
name|Type
operator|==
name|RHS
operator|->
name|getRawType
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Name
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|GetterName
argument_list|,
name|SetterName
argument_list|,
name|Attributes
argument_list|,
name|Type
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIImportedEntity
operator|>
block|{
name|unsigned
name|Tag
block|;
name|Metadata
operator|*
name|Scope
block|;
name|Metadata
operator|*
name|Entity
block|;
name|unsigned
name|Line
block|;
name|MDString
operator|*
name|Name
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned Tag
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *Entity
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|)
operator|:
name|Tag
argument_list|(
name|Tag
argument_list|)
block|,
name|Scope
argument_list|(
name|Scope
argument_list|)
block|,
name|Entity
argument_list|(
name|Entity
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Name
argument_list|(
argument|Name
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIImportedEntity
operator|*
name|N
argument_list|)
operator|:
name|Tag
argument_list|(
name|N
operator|->
name|getTag
argument_list|()
argument_list|)
block|,
name|Scope
argument_list|(
name|N
operator|->
name|getRawScope
argument_list|()
argument_list|)
block|,
name|Entity
argument_list|(
name|N
operator|->
name|getRawEntity
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
argument|N->getRawName()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIImportedEntity *RHS
argument_list|)
specifier|const
block|{
return|return
name|Tag
operator|==
name|RHS
operator|->
name|getTag
argument_list|()
operator|&&
name|Scope
operator|==
name|RHS
operator|->
name|getRawScope
argument_list|()
operator|&&
name|Entity
operator|==
name|RHS
operator|->
name|getRawEntity
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|Tag
argument_list|,
name|Scope
argument_list|,
name|Entity
argument_list|,
name|Line
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIMacro
operator|>
block|{
name|unsigned
name|MIType
block|;
name|unsigned
name|Line
block|;
name|MDString
operator|*
name|Name
block|;
name|MDString
operator|*
name|Value
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *Value
argument_list|)
operator|:
name|MIType
argument_list|(
name|MIType
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIMacro
operator|*
name|N
argument_list|)
operator|:
name|MIType
argument_list|(
name|N
operator|->
name|getMacinfoType
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|Name
argument_list|(
name|N
operator|->
name|getRawName
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|N->getRawValue()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIMacro *RHS
argument_list|)
specifier|const
block|{
return|return
name|MIType
operator|==
name|RHS
operator|->
name|getMacinfoType
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|Name
operator|==
name|RHS
operator|->
name|getRawName
argument_list|()
operator|&&
name|Value
operator|==
name|RHS
operator|->
name|getRawValue
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|MIType
argument_list|,
name|Line
argument_list|,
name|Name
argument_list|,
name|Value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|MDNodeKeyImpl
operator|<
name|DIMacroFile
operator|>
block|{
name|unsigned
name|MIType
block|;
name|unsigned
name|Line
block|;
name|Metadata
operator|*
name|File
block|;
name|Metadata
operator|*
name|Elements
block|;
name|MDNodeKeyImpl
argument_list|(
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *File
argument_list|,
argument|Metadata *Elements
argument_list|)
operator|:
name|MIType
argument_list|(
name|MIType
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|File
argument_list|(
name|File
argument_list|)
block|,
name|Elements
argument_list|(
argument|Elements
argument_list|)
block|{}
name|MDNodeKeyImpl
argument_list|(
specifier|const
name|DIMacroFile
operator|*
name|N
argument_list|)
operator|:
name|MIType
argument_list|(
name|N
operator|->
name|getMacinfoType
argument_list|()
argument_list|)
block|,
name|Line
argument_list|(
name|N
operator|->
name|getLine
argument_list|()
argument_list|)
block|,
name|File
argument_list|(
name|N
operator|->
name|getRawFile
argument_list|()
argument_list|)
block|,
name|Elements
argument_list|(
argument|N->getRawElements()
argument_list|)
block|{}
name|bool
name|isKeyOf
argument_list|(
argument|const DIMacroFile *RHS
argument_list|)
specifier|const
block|{
return|return
name|MIType
operator|==
name|RHS
operator|->
name|getMacinfoType
argument_list|()
operator|&&
name|Line
operator|==
name|RHS
operator|->
name|getLine
argument_list|()
operator|&&
name|File
operator|==
name|RHS
operator|->
name|getRawFile
argument_list|()
operator|&&
name|Elements
operator|==
name|RHS
operator|->
name|getRawElements
argument_list|()
return|;
block|}
name|unsigned
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|hash_combine
argument_list|(
name|MIType
argument_list|,
name|Line
argument_list|,
name|File
argument_list|,
name|Elements
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief DenseMapInfo for MDNode subclasses.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|NodeTy
operator|>
expr|struct
name|MDNodeInfo
block|{
name|using
name|KeyTy
operator|=
name|MDNodeKeyImpl
operator|<
name|NodeTy
operator|>
block|;
name|using
name|SubsetEqualTy
operator|=
name|MDNodeSubsetEqualImpl
operator|<
name|NodeTy
operator|>
block|;
specifier|static
specifier|inline
name|NodeTy
operator|*
name|getEmptyKey
argument_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|NodeTy
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|NodeTy
operator|*
name|getTombstoneKey
argument_list|()
block|{
return|return
name|DenseMapInfo
operator|<
name|NodeTy
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|Key
operator|.
name|getHashValue
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|NodeTy
modifier|*
name|N
parameter_list|)
block|{
return|return
name|KeyTy
argument_list|(
name|N
argument_list|)
operator|.
name|getHashValue
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|NodeTy
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|SubsetEqualTy
operator|::
name|isSubsetEqual
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
operator|||
name|LHS
operator|.
name|isKeyOf
argument_list|(
name|RHS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|NodeTy
modifier|*
name|LHS
parameter_list|,
specifier|const
name|NodeTy
modifier|*
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|LHS
operator|==
name|RHS
condition|)
return|return
name|true
return|;
if|if
condition|(
name|RHS
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|RHS
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|SubsetEqualTy
operator|::
name|isSubsetEqual
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
end_function

begin_define
unit|};
define|#
directive|define
name|HANDLE_MDNODE_LEAF
parameter_list|(
name|CLASS
parameter_list|)
value|using CLASS##Info = MDNodeInfo<CLASS>;
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.def"
end_include

begin_comment
comment|/// \brief Map-like storage for metadata attachments.
end_comment

begin_decl_stmt
name|class
name|MDAttachmentMap
block|{
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|TrackingMDNodeRef
operator|>
operator|,
literal|2
operator|>
name|Attachments
expr_stmt|;
name|public
label|:
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Attachments
operator|.
name|empty
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Attachments
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// \brief Get a particular attachment (if any).
name|MDNode
modifier|*
name|lookup
argument_list|(
name|unsigned
name|ID
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Set an attachment to a particular node.
comment|///
comment|/// Set the \c ID attachment to \c MD, replacing the current attachment at \c
comment|/// ID (if anyway).
name|void
name|set
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|MDNode
modifier|&
name|MD
parameter_list|)
function_decl|;
comment|/// \brief Remove an attachment.
comment|///
comment|/// Remove the attachment at \c ID, if any.
name|void
name|erase
parameter_list|(
name|unsigned
name|ID
parameter_list|)
function_decl|;
comment|/// \brief Copy out all the attachments.
comment|///
comment|/// Copies all the current attachments into \c Result, sorting by attachment
comment|/// ID.  This function does \em not clear \c Result.
name|void
name|getAll
argument_list|(
name|SmallVectorImpl
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
argument_list|,
name|MDNode
operator|*
operator|>>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Erase matching attachments.
comment|///
comment|/// Erases all attachments matching the \c shouldRemove predicate.
name|template
operator|<
name|class
name|PredTy
operator|>
name|void
name|remove_if
argument_list|(
argument|PredTy shouldRemove
argument_list|)
block|{
name|Attachments
operator|.
name|erase
argument_list|(
name|llvm
operator|::
name|remove_if
argument_list|(
name|Attachments
argument_list|,
name|shouldRemove
argument_list|)
argument_list|,
name|Attachments
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Multimap-like storage for metadata attachments for globals. This differs
end_comment

begin_comment
comment|/// from MDAttachmentMap in that it allows multiple attachments per metadata
end_comment

begin_comment
comment|/// kind.
end_comment

begin_decl_stmt
name|class
name|MDGlobalAttachmentMap
block|{
struct|struct
name|Attachment
block|{
name|unsigned
name|MDKind
decl_stmt|;
name|TrackingMDNodeRef
name|Node
decl_stmt|;
block|}
struct|;
name|SmallVector
operator|<
name|Attachment
operator|,
literal|1
operator|>
name|Attachments
expr_stmt|;
name|public
label|:
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Attachments
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// Appends all attachments with the given ID to \c Result in insertion order.
comment|/// If the global has no attachments with the given ID, or if ID is invalid,
comment|/// leaves Result unchanged.
name|void
name|get
argument_list|(
name|unsigned
name|ID
argument_list|,
name|SmallVectorImpl
operator|<
name|MDNode
operator|*
operator|>
operator|&
name|Result
argument_list|)
decl_stmt|;
name|void
name|insert
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|MDNode
modifier|&
name|MD
parameter_list|)
function_decl|;
name|void
name|erase
parameter_list|(
name|unsigned
name|ID
parameter_list|)
function_decl|;
comment|/// Appends all attachments for the global to \c Result, sorting by attachment
comment|/// ID. Attachments with the same ID appear in insertion order. This function
comment|/// does \em not clear \c Result.
name|void
name|getAll
argument_list|(
name|SmallVectorImpl
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
argument_list|,
name|MDNode
operator|*
operator|>>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|LLVMContextImpl
block|{
name|public
label|:
comment|/// OwnedModules - The set of modules instantiated in this context, and which
comment|/// will be automatically deleted if this context is deleted.
name|SmallPtrSet
operator|<
name|Module
operator|*
operator|,
literal|4
operator|>
name|OwnedModules
expr_stmt|;
name|LLVMContext
operator|::
name|InlineAsmDiagHandlerTy
name|InlineAsmDiagHandler
operator|=
name|nullptr
expr_stmt|;
name|void
modifier|*
name|InlineAsmDiagContext
init|=
name|nullptr
decl_stmt|;
name|LLVMContext
operator|::
name|DiagnosticHandlerTy
name|DiagnosticHandler
operator|=
name|nullptr
expr_stmt|;
name|void
modifier|*
name|DiagnosticContext
init|=
name|nullptr
decl_stmt|;
name|bool
name|RespectDiagnosticFilters
init|=
name|false
decl_stmt|;
name|bool
name|DiagnosticHotnessRequested
init|=
name|false
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|yaml
operator|::
name|Output
operator|>
name|DiagnosticsOutputFile
expr_stmt|;
name|LLVMContext
operator|::
name|YieldCallbackTy
name|YieldCallback
operator|=
name|nullptr
expr_stmt|;
name|void
modifier|*
name|YieldOpaqueHandle
init|=
name|nullptr
decl_stmt|;
name|using
name|IntMapTy
init|=
name|DenseMap
operator|<
name|APInt
decl_stmt|,
name|std
decl|::
name|unique_ptr
decl|<
name|ConstantInt
decl|>
decl_stmt|,
name|DenseMapAPIntKeyInfo
decl|>
decl_stmt|;
name|IntMapTy
name|IntConstants
decl_stmt|;
name|using
name|FPMapTy
init|=
name|DenseMap
operator|<
name|APFloat
decl_stmt|,
name|std
decl|::
name|unique_ptr
decl|<
name|ConstantFP
decl|>
decl_stmt|,
name|DenseMapAPFloatKeyInfo
decl|>
decl_stmt|;
name|FPMapTy
name|FPConstants
decl_stmt|;
name|FoldingSet
operator|<
name|AttributeImpl
operator|>
name|AttrsSet
expr_stmt|;
name|FoldingSet
operator|<
name|AttributeListImpl
operator|>
name|AttrsLists
expr_stmt|;
name|FoldingSet
operator|<
name|AttributeSetNode
operator|>
name|AttrsSetNodes
expr_stmt|;
name|StringMap
operator|<
name|MDString
operator|,
name|BumpPtrAllocator
operator|>
name|MDStringCache
expr_stmt|;
name|DenseMap
operator|<
name|Value
operator|*
operator|,
name|ValueAsMetadata
operator|*
operator|>
name|ValuesAsMetadata
expr_stmt|;
name|DenseMap
operator|<
name|Metadata
operator|*
operator|,
name|MetadataAsValue
operator|*
operator|>
name|MetadataAsValues
expr_stmt|;
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|ValueName
operator|*
operator|>
name|ValueNames
expr_stmt|;
define|#
directive|define
name|HANDLE_MDNODE_LEAF_UNIQUABLE
parameter_list|(
name|CLASS
parameter_list|)
define|\
value|DenseSet<CLASS *, CLASS##Info> CLASS##s;
include|#
directive|include
file|"llvm/IR/Metadata.def"
comment|// Optional map for looking up composite types by identifier.
name|Optional
operator|<
name|DenseMap
operator|<
specifier|const
name|MDString
operator|*
operator|,
name|DICompositeType
operator|*
operator|>>
name|DITypeMap
expr_stmt|;
comment|// MDNodes may be uniqued or not uniqued.  When they're not uniqued, they
comment|// aren't in the MDNodeSet, but they're still shared between objects, so no
comment|// one object can destroy them.  Keep track of them here so we can delete
comment|// them on context teardown.
name|std
operator|::
name|vector
operator|<
name|MDNode
operator|*
operator|>
name|DistinctMDNodes
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|ConstantAggregateZero
operator|>>
name|CAZConstants
expr_stmt|;
name|using
name|ArrayConstantsTy
init|=
name|ConstantUniqueMap
operator|<
name|ConstantArray
operator|>
decl_stmt|;
name|ArrayConstantsTy
name|ArrayConstants
decl_stmt|;
name|using
name|StructConstantsTy
init|=
name|ConstantUniqueMap
operator|<
name|ConstantStruct
operator|>
decl_stmt|;
name|StructConstantsTy
name|StructConstants
decl_stmt|;
name|using
name|VectorConstantsTy
init|=
name|ConstantUniqueMap
operator|<
name|ConstantVector
operator|>
decl_stmt|;
name|VectorConstantsTy
name|VectorConstants
decl_stmt|;
name|DenseMap
operator|<
name|PointerType
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|ConstantPointerNull
operator|>>
name|CPNConstants
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|UndefValue
operator|>>
name|UVConstants
expr_stmt|;
name|StringMap
operator|<
name|ConstantDataSequential
operator|*
operator|>
name|CDSConstants
expr_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|Function
operator|*
operator|,
specifier|const
name|BasicBlock
operator|*
operator|>
operator|,
name|BlockAddress
operator|*
operator|>
name|BlockAddresses
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|ConstantExpr
operator|>
name|ExprConstants
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|InlineAsm
operator|>
name|InlineAsms
expr_stmt|;
name|ConstantInt
modifier|*
name|TheTrueVal
init|=
name|nullptr
decl_stmt|;
name|ConstantInt
modifier|*
name|TheFalseVal
init|=
name|nullptr
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ConstantTokenNone
operator|>
name|TheNoneToken
expr_stmt|;
comment|// Basic type instances.
name|Type
name|VoidTy
decl_stmt|,
name|LabelTy
decl_stmt|,
name|HalfTy
decl_stmt|,
name|FloatTy
decl_stmt|,
name|DoubleTy
decl_stmt|,
name|MetadataTy
decl_stmt|,
name|TokenTy
decl_stmt|;
name|Type
name|X86_FP80Ty
decl_stmt|,
name|FP128Ty
decl_stmt|,
name|PPC_FP128Ty
decl_stmt|,
name|X86_MMXTy
decl_stmt|;
name|IntegerType
name|Int1Ty
decl_stmt|,
name|Int8Ty
decl_stmt|,
name|Int16Ty
decl_stmt|,
name|Int32Ty
decl_stmt|,
name|Int64Ty
decl_stmt|,
name|Int128Ty
decl_stmt|;
comment|/// TypeAllocator - All dynamically allocated types are allocated from this.
comment|/// They live forever until the context is torn down.
name|BumpPtrAllocator
name|TypeAllocator
decl_stmt|;
name|DenseMap
operator|<
name|unsigned
operator|,
name|IntegerType
operator|*
operator|>
name|IntegerTypes
expr_stmt|;
name|using
name|FunctionTypeSet
init|=
name|DenseSet
operator|<
name|FunctionType
operator|*
decl_stmt|,
name|FunctionTypeKeyInfo
decl|>
decl_stmt|;
name|FunctionTypeSet
name|FunctionTypes
decl_stmt|;
name|using
name|StructTypeSet
init|=
name|DenseSet
operator|<
name|StructType
operator|*
decl_stmt|,
name|AnonStructTypeKeyInfo
decl|>
decl_stmt|;
name|StructTypeSet
name|AnonStructTypes
decl_stmt|;
name|StringMap
operator|<
name|StructType
operator|*
operator|>
name|NamedStructTypes
expr_stmt|;
name|unsigned
name|NamedStructTypesUniqueID
init|=
literal|0
decl_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|uint64_t
operator|>
operator|,
name|ArrayType
operator|*
operator|>
name|ArrayTypes
expr_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|VectorType
operator|*
operator|>
name|VectorTypes
expr_stmt|;
name|DenseMap
operator|<
name|Type
operator|*
operator|,
name|PointerType
operator|*
operator|>
name|PointerTypes
expr_stmt|;
comment|// Pointers in AddrSpace = 0
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|PointerType
operator|*
operator|>
name|ASPointerTypes
expr_stmt|;
comment|/// ValueHandles - This map keeps track of all of the value handles that are
comment|/// watching a Value*.  The Value::HasValueHandle bit is used to know
comment|/// whether or not a value has an entry in this map.
name|using
name|ValueHandlesTy
init|=
name|DenseMap
operator|<
name|Value
operator|*
decl_stmt|,
name|ValueHandleBase
modifier|*
decl|>
decl_stmt|;
name|ValueHandlesTy
name|ValueHandles
decl_stmt|;
comment|/// CustomMDKindNames - Map to hold the metadata string to ID mapping.
name|StringMap
operator|<
name|unsigned
operator|>
name|CustomMDKindNames
expr_stmt|;
comment|/// Collection of per-instruction metadata used in this context.
name|DenseMap
operator|<
specifier|const
name|Instruction
operator|*
operator|,
name|MDAttachmentMap
operator|>
name|InstructionMetadata
expr_stmt|;
comment|/// Collection of per-GlobalObject metadata used in this context.
name|DenseMap
operator|<
specifier|const
name|GlobalObject
operator|*
operator|,
name|MDGlobalAttachmentMap
operator|>
name|GlobalObjectMetadata
expr_stmt|;
comment|/// Collection of per-GlobalObject sections used in this context.
name|DenseMap
operator|<
specifier|const
name|GlobalObject
operator|*
operator|,
name|StringRef
operator|>
name|GlobalObjectSections
expr_stmt|;
comment|/// Stable collection of section strings.
name|StringSet
operator|<
operator|>
name|SectionStrings
expr_stmt|;
comment|/// DiscriminatorTable - This table maps file:line locations to an
comment|/// integer representing the next DWARF path discriminator to assign to
comment|/// instructions in different blocks at the same location.
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|>
operator|,
name|unsigned
operator|>
name|DiscriminatorTable
expr_stmt|;
name|int
name|getOrAddScopeRecordIdxEntry
parameter_list|(
name|MDNode
modifier|*
name|N
parameter_list|,
name|int
name|ExistingIdx
parameter_list|)
function_decl|;
name|int
name|getOrAddScopeInlinedAtIdxEntry
parameter_list|(
name|MDNode
modifier|*
name|Scope
parameter_list|,
name|MDNode
modifier|*
name|IA
parameter_list|,
name|int
name|ExistingIdx
parameter_list|)
function_decl|;
comment|/// \brief A set of interned tags for operand bundles.  The StringMap maps
comment|/// bundle tags to their IDs.
comment|///
comment|/// \see LLVMContext::getOperandBundleTagID
name|StringMap
operator|<
name|uint32_t
operator|>
name|BundleTagCache
expr_stmt|;
name|StringMapEntry
operator|<
name|uint32_t
operator|>
operator|*
name|getOrInsertBundleTag
argument_list|(
argument|StringRef Tag
argument_list|)
expr_stmt|;
name|void
name|getOperandBundleTags
argument_list|(
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|Tags
argument_list|)
decl|const
decl_stmt|;
name|uint32_t
name|getOperandBundleTagID
argument_list|(
name|StringRef
name|Tag
argument_list|)
decl|const
decl_stmt|;
comment|/// Maintain the GC name for each function.
comment|///
comment|/// This saves allocating an additional word in Function for programs which
comment|/// do not use GC (i.e., most programs) at the cost of increased overhead for
comment|/// clients which do use GC.
name|DenseMap
operator|<
specifier|const
name|Function
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|GCNames
expr_stmt|;
comment|/// Flag to indicate if Value (other than GlobalValue) retains their name or
comment|/// not.
name|bool
name|DiscardValueNames
init|=
name|false
decl_stmt|;
name|LLVMContextImpl
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
expr_stmt|;
operator|~
name|LLVMContextImpl
argument_list|()
expr_stmt|;
comment|/// Destroy the ConstantArrays if they are not used.
name|void
name|dropTriviallyDeadConstantArrays
parameter_list|()
function_decl|;
comment|/// \brief Access the object which manages optimization bisection for failure
comment|/// analysis.
name|OptBisect
modifier|&
name|getOptBisect
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_LIB_IR_LLVMCONTEXTIMPL_H
end_comment

end_unit

