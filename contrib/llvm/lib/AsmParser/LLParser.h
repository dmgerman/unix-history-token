begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LLParser.h - Parser Class -------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the parser class for .ll files.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ASMPARSER_LLPARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ASMPARSER_LLPARSER_H
end_define

begin_include
include|#
directive|include
file|"LLLexer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Attributes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Type.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Module
decl_stmt|;
name|class
name|OpaqueType
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|GlobalValue
decl_stmt|;
name|class
name|MDString
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|StructType
decl_stmt|;
comment|/// ValID - Represents a reference of a definition of some sort with no type.
comment|/// There are several cases where we have to parse the value but where the
comment|/// type can depend on later context.  This may either be a numeric reference
comment|/// or a symbolic (%var) reference.  This is just a discriminated union.
struct|struct
name|ValID
block|{
enum|enum
block|{
name|t_LocalID
block|,
name|t_GlobalID
block|,
comment|// ID in UIntVal.
name|t_LocalName
block|,
name|t_GlobalName
block|,
comment|// Name in StrVal.
name|t_APSInt
block|,
name|t_APFloat
block|,
comment|// Value in APSIntVal/APFloatVal.
name|t_Null
block|,
name|t_Undef
block|,
name|t_Zero
block|,
comment|// No value.
name|t_EmptyArray
block|,
comment|// No value:  []
name|t_Constant
block|,
comment|// Value in ConstantVal.
name|t_InlineAsm
block|,
comment|// Value in StrVal/StrVal2/UIntVal.
name|t_MDNode
block|,
comment|// Value in MDNodeVal.
name|t_MDString
block|,
comment|// Value in MDStringVal.
name|t_ConstantStruct
block|,
comment|// Value in ConstantStructElts.
name|t_PackedConstantStruct
comment|// Value in ConstantStructElts.
block|}
name|Kind
enum|;
name|LLLexer
operator|::
name|LocTy
name|Loc
expr_stmt|;
name|unsigned
name|UIntVal
decl_stmt|;
name|std
operator|::
name|string
name|StrVal
operator|,
name|StrVal2
expr_stmt|;
name|APSInt
name|APSIntVal
decl_stmt|;
name|APFloat
name|APFloatVal
decl_stmt|;
name|Constant
modifier|*
name|ConstantVal
decl_stmt|;
name|MDNode
modifier|*
name|MDNodeVal
decl_stmt|;
name|MDString
modifier|*
name|MDStringVal
decl_stmt|;
name|Constant
modifier|*
modifier|*
name|ConstantStructElts
decl_stmt|;
name|ValID
argument_list|()
operator|:
name|Kind
argument_list|(
name|t_LocalID
argument_list|)
operator|,
name|APFloatVal
argument_list|(
literal|0.0
argument_list|)
block|{}
operator|~
name|ValID
argument_list|()
block|{
if|if
condition|(
name|Kind
operator|==
name|t_ConstantStruct
operator|||
name|Kind
operator|==
name|t_PackedConstantStruct
condition|)
name|delete
index|[]
name|ConstantStructElts
decl_stmt|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|ValID
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|Kind
operator|==
name|t_LocalID
operator|||
name|Kind
operator|==
name|t_GlobalID
condition|)
return|return
name|UIntVal
operator|<
name|RHS
operator|.
name|UIntVal
return|;
name|assert
argument_list|(
operator|(
name|Kind
operator|==
name|t_LocalName
operator|||
name|Kind
operator|==
name|t_GlobalName
operator|||
name|Kind
operator|==
name|t_ConstantStruct
operator|||
name|Kind
operator|==
name|t_PackedConstantStruct
operator|)
operator|&&
literal|"Ordering not defined for this ValID kind yet"
argument_list|)
expr_stmt|;
return|return
name|StrVal
operator|<
name|RHS
operator|.
name|StrVal
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|LLParser
block|{
name|public
label|:
typedef|typedef
name|LLLexer
operator|::
name|LocTy
name|LocTy
expr_stmt|;
name|private
label|:
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|LLLexer
name|Lex
decl_stmt|;
name|Module
modifier|*
name|M
decl_stmt|;
comment|// Instruction metadata resolution.  Each instruction can have a list of
comment|// MDRef info associated with them.
comment|//
comment|// The simpler approach of just creating temporary MDNodes and then calling
comment|// RAUW on them when the definition is processed doesn't work because some
comment|// instruction metadata kinds, such as dbg, get stored in the IR in an
comment|// "optimized" format which doesn't participate in the normal value use
comment|// lists. This means that RAUW doesn't work, even on temporary MDNodes
comment|// which otherwise support RAUW. Instead, we defer resolving MDNode
comment|// references until the definitions have been processed.
struct|struct
name|MDRef
block|{
name|SMLoc
name|Loc
decl_stmt|;
name|unsigned
name|MDKind
decl_stmt|,
name|MDSlot
decl_stmt|;
block|}
struct|;
name|DenseMap
operator|<
name|Instruction
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|MDRef
operator|>
expr|>
name|ForwardRefInstMetadata
expr_stmt|;
name|SmallVector
operator|<
name|Instruction
operator|*
operator|,
literal|64
operator|>
name|InstsWithTBAATag
expr_stmt|;
comment|// Type resolution handling data structures.  The location is set when we
comment|// have processed a use of the type but not a definition yet.
name|StringMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|NamedTypes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|NumberedTypes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|TrackingVH
operator|<
name|MDNode
operator|>
expr|>
name|NumberedMetadata
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|TrackingVH
operator|<
name|MDNode
operator|>
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefMDNodes
expr_stmt|;
comment|// Global Value reference information.
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|pair
operator|<
name|GlobalValue
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefVals
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|GlobalValue
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefValIDs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|GlobalValue
operator|*
operator|>
name|NumberedVals
expr_stmt|;
comment|// References to blockaddress.  The key is the function ValID, the value is
comment|// a list of references to blocks in that function.
name|std
operator|::
name|map
operator|<
name|ValID
operator|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|ValID
operator|,
name|GlobalValue
operator|*
operator|>
expr|>
operator|>
name|ForwardRefBlockAddresses
expr_stmt|;
comment|// Attribute builder reference information.
name|std
operator|::
name|map
operator|<
name|Value
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
expr|>
name|ForwardRefAttrGroups
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|AttrBuilder
operator|>
name|NumberedAttrBuilders
expr_stmt|;
name|public
label|:
name|LLParser
argument_list|(
name|MemoryBuffer
operator|*
name|F
argument_list|,
name|SourceMgr
operator|&
name|SM
argument_list|,
name|SMDiagnostic
operator|&
name|Err
argument_list|,
name|Module
operator|*
name|m
argument_list|)
operator|:
name|Context
argument_list|(
name|m
operator|->
name|getContext
argument_list|()
argument_list|)
operator|,
name|Lex
argument_list|(
name|F
argument_list|,
name|SM
argument_list|,
name|Err
argument_list|,
name|m
operator|->
name|getContext
argument_list|()
argument_list|)
operator|,
name|M
argument_list|(
argument|m
argument_list|)
block|{}
name|bool
name|Run
argument_list|()
expr_stmt|;
name|LLVMContext
modifier|&
name|getContext
parameter_list|()
block|{
return|return
name|Context
return|;
block|}
name|private
label|:
name|bool
name|Error
argument_list|(
name|LocTy
name|L
argument_list|,
specifier|const
name|Twine
operator|&
name|Msg
argument_list|)
decl|const
block|{
return|return
name|Lex
operator|.
name|Error
argument_list|(
name|L
argument_list|,
name|Msg
argument_list|)
return|;
block|}
name|bool
name|TokError
argument_list|(
specifier|const
name|Twine
operator|&
name|Msg
argument_list|)
decl|const
block|{
return|return
name|Error
argument_list|(
name|Lex
operator|.
name|getLoc
argument_list|()
argument_list|,
name|Msg
argument_list|)
return|;
block|}
comment|/// GetGlobalVal - Get a value with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// exists but does not have the right type.
name|GlobalValue
modifier|*
name|GetGlobalVal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|N
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|GlobalValue
modifier|*
name|GetGlobalVal
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|// Helper Routines.
name|bool
name|ParseToken
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|,
specifier|const
name|char
operator|*
name|ErrMsg
argument_list|)
decl_stmt|;
name|bool
name|EatIfPresent
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|)
block|{
if|if
condition|(
name|Lex
operator|.
name|getKind
argument_list|()
operator|!=
name|T
condition|)
return|return
name|false
return|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
name|FastMathFlags
name|EatFastMathFlagsIfPresent
parameter_list|()
block|{
name|FastMathFlags
name|FMF
decl_stmt|;
while|while
condition|(
name|true
condition|)
switch|switch
condition|(
name|Lex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|lltok
operator|::
name|kw_fast
case|:
name|FMF
operator|.
name|setUnsafeAlgebra
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|lltok
operator|::
name|kw_nnan
case|:
name|FMF
operator|.
name|setNoNaNs
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|lltok
operator|::
name|kw_ninf
case|:
name|FMF
operator|.
name|setNoInfs
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|lltok
operator|::
name|kw_nsz
case|:
name|FMF
operator|.
name|setNoSignedZeros
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|lltok
operator|::
name|kw_arcp
case|:
name|FMF
operator|.
name|setAllowReciprocal
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
continue|continue;
default|default:
return|return
name|FMF
return|;
block|}
return|return
name|FMF
return|;
block|}
name|bool
name|ParseOptionalToken
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|,
name|bool
operator|&
name|Present
argument_list|,
name|LocTy
operator|*
name|Loc
operator|=
literal|0
argument_list|)
block|{
if|if
condition|(
name|Lex
operator|.
name|getKind
argument_list|()
operator|!=
name|T
condition|)
block|{
name|Present
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Loc
condition|)
operator|*
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
name|Present
operator|=
name|true
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|ParseStringConstant
argument_list|(
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
name|bool
name|ParseUInt32
parameter_list|(
name|unsigned
modifier|&
name|Val
parameter_list|)
function_decl|;
name|bool
name|ParseUInt32
parameter_list|(
name|unsigned
modifier|&
name|Val
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseUInt32
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|bool
name|ParseTLSModel
argument_list|(
name|GlobalVariable
operator|::
name|ThreadLocalMode
operator|&
name|TLM
argument_list|)
decl_stmt|;
name|bool
name|ParseOptionalThreadLocal
argument_list|(
name|GlobalVariable
operator|::
name|ThreadLocalMode
operator|&
name|TLM
argument_list|)
decl_stmt|;
name|bool
name|ParseOptionalAddrSpace
parameter_list|(
name|unsigned
modifier|&
name|AddrSpace
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalParamAttrs
parameter_list|(
name|AttrBuilder
modifier|&
name|B
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalReturnAttrs
parameter_list|(
name|AttrBuilder
modifier|&
name|B
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalLinkage
parameter_list|(
name|unsigned
modifier|&
name|Linkage
parameter_list|,
name|bool
modifier|&
name|HasLinkage
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalLinkage
parameter_list|(
name|unsigned
modifier|&
name|Linkage
parameter_list|)
block|{
name|bool
name|HasLinkage
decl_stmt|;
return|return
name|ParseOptionalLinkage
argument_list|(
name|Linkage
argument_list|,
name|HasLinkage
argument_list|)
return|;
block|}
name|bool
name|ParseOptionalVisibility
parameter_list|(
name|unsigned
modifier|&
name|Visibility
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCallingConv
argument_list|(
name|CallingConv
operator|::
name|ID
operator|&
name|CC
argument_list|)
decl_stmt|;
name|bool
name|ParseOptionalAlignment
parameter_list|(
name|unsigned
modifier|&
name|Alignment
parameter_list|)
function_decl|;
name|bool
name|ParseScopeAndOrdering
parameter_list|(
name|bool
name|isAtomic
parameter_list|,
name|SynchronizationScope
modifier|&
name|Scope
parameter_list|,
name|AtomicOrdering
modifier|&
name|Ordering
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalStackAlignment
parameter_list|(
name|unsigned
modifier|&
name|Alignment
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCommaAlign
parameter_list|(
name|unsigned
modifier|&
name|Alignment
parameter_list|,
name|bool
modifier|&
name|AteExtraComma
parameter_list|)
function_decl|;
name|bool
name|ParseIndexList
argument_list|(
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|Indices
argument_list|,
name|bool
operator|&
name|AteExtraComma
argument_list|)
decl_stmt|;
name|bool
name|ParseIndexList
argument_list|(
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|Indices
argument_list|)
block|{
name|bool
name|AteExtraComma
decl_stmt|;
if|if
condition|(
name|ParseIndexList
argument_list|(
name|Indices
argument_list|,
name|AteExtraComma
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|AteExtraComma
condition|)
return|return
name|TokError
argument_list|(
literal|"expected index"
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|// Top-Level Entities
name|bool
name|ParseTopLevelEntities
parameter_list|()
function_decl|;
name|bool
name|ValidateEndOfModule
parameter_list|()
function_decl|;
name|bool
name|ParseTargetDefinition
parameter_list|()
function_decl|;
name|bool
name|ParseModuleAsm
parameter_list|()
function_decl|;
name|bool
name|ParseDepLibs
parameter_list|()
function_decl|;
comment|// FIXME: Remove in 4.0.
name|bool
name|ParseUnnamedType
parameter_list|()
function_decl|;
name|bool
name|ParseNamedType
parameter_list|()
function_decl|;
name|bool
name|ParseDeclare
parameter_list|()
function_decl|;
name|bool
name|ParseDefine
parameter_list|()
function_decl|;
name|bool
name|ParseGlobalType
parameter_list|(
name|bool
modifier|&
name|IsConstant
parameter_list|)
function_decl|;
name|bool
name|ParseUnnamedGlobal
parameter_list|()
function_decl|;
name|bool
name|ParseNamedGlobal
parameter_list|()
function_decl|;
name|bool
name|ParseGlobal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|,
name|unsigned
name|Linkage
argument_list|,
name|bool
name|HasLinkage
argument_list|,
name|unsigned
name|Visibility
argument_list|)
decl_stmt|;
name|bool
name|ParseAlias
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|,
name|unsigned
name|Visibility
argument_list|)
decl_stmt|;
name|bool
name|ParseStandaloneMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseNamedMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseMDString
parameter_list|(
name|MDString
modifier|*
modifier|&
name|Result
parameter_list|)
function_decl|;
name|bool
name|ParseMDNodeID
parameter_list|(
name|MDNode
modifier|*
modifier|&
name|Result
parameter_list|)
function_decl|;
name|bool
name|ParseMDNodeID
parameter_list|(
name|MDNode
modifier|*
modifier|&
name|Result
parameter_list|,
name|unsigned
modifier|&
name|SlotNo
parameter_list|)
function_decl|;
name|bool
name|ParseUnnamedAttrGrp
parameter_list|()
function_decl|;
name|bool
name|ParseFnAttributeValuePairs
argument_list|(
name|AttrBuilder
operator|&
name|B
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|FwdRefAttrGrps
argument_list|,
name|bool
name|inAttrGrp
argument_list|,
name|LocTy
operator|&
name|BuiltinLoc
argument_list|)
decl_stmt|;
comment|// Type Parsing.
name|bool
name|ParseType
parameter_list|(
name|Type
modifier|*
modifier|&
name|Result
parameter_list|,
name|bool
name|AllowVoid
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseType
parameter_list|(
name|Type
modifier|*
modifier|&
name|Result
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|bool
name|AllowVoid
init|=
name|false
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseType
argument_list|(
name|Result
argument_list|,
name|AllowVoid
argument_list|)
return|;
block|}
name|bool
name|ParseAnonStructType
parameter_list|(
name|Type
modifier|*
modifier|&
name|Result
parameter_list|,
name|bool
name|Packed
parameter_list|)
function_decl|;
name|bool
name|ParseStructBody
argument_list|(
name|SmallVectorImpl
operator|<
name|Type
operator|*
operator|>
operator|&
name|Body
argument_list|)
decl_stmt|;
name|bool
name|ParseStructDefinition
argument_list|(
name|SMLoc
name|TypeLoc
argument_list|,
name|StringRef
name|Name
argument_list|,
name|std
operator|::
name|pair
operator|<
name|Type
operator|*
argument_list|,
name|LocTy
operator|>
operator|&
name|Entry
argument_list|,
name|Type
operator|*
operator|&
name|ResultTy
argument_list|)
decl_stmt|;
name|bool
name|ParseArrayVectorType
parameter_list|(
name|Type
modifier|*
modifier|&
name|Result
parameter_list|,
name|bool
name|isVector
parameter_list|)
function_decl|;
name|bool
name|ParseFunctionType
parameter_list|(
name|Type
modifier|*
modifier|&
name|Result
parameter_list|)
function_decl|;
comment|// Function Semantic Analysis.
name|class
name|PerFunctionState
block|{
name|LLParser
modifier|&
name|P
decl_stmt|;
name|Function
modifier|&
name|F
decl_stmt|;
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|pair
operator|<
name|Value
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefVals
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|Value
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefValIDs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Value
operator|*
operator|>
name|NumberedVals
expr_stmt|;
comment|/// FunctionNumber - If this is an unnamed function, this is the slot
comment|/// number of it, otherwise it is -1.
name|int
name|FunctionNumber
decl_stmt|;
name|public
label|:
name|PerFunctionState
argument_list|(
argument|LLParser&p
argument_list|,
argument|Function&f
argument_list|,
argument|int FunctionNumber
argument_list|)
empty_stmt|;
operator|~
name|PerFunctionState
argument_list|()
expr_stmt|;
name|Function
operator|&
name|getFunction
argument_list|()
specifier|const
block|{
return|return
name|F
return|;
block|}
name|bool
name|FinishFunction
parameter_list|()
function_decl|;
comment|/// GetVal - Get a value with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// exists but does not have the right type.
name|Value
modifier|*
name|GetVal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|GetVal
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|/// SetInstName - After an instruction is parsed and inserted into its
comment|/// basic block, this installs its name.
name|bool
name|SetInstName
argument_list|(
name|int
name|NameID
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|NameStr
argument_list|,
name|LocTy
name|NameLoc
argument_list|,
name|Instruction
operator|*
name|Inst
argument_list|)
decl_stmt|;
comment|/// GetBB - Get a basic block with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// is not a BasicBlock.
name|BasicBlock
modifier|*
name|GetBB
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|BasicBlock
modifier|*
name|GetBB
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|/// DefineBB - Define the specified basic block, which is either named or
comment|/// unnamed.  If there is an error, this returns null otherwise it returns
comment|/// the block being defined.
name|BasicBlock
modifier|*
name|DefineBB
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
name|bool
name|ConvertValIDToValue
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|ValID
modifier|&
name|ID
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseValue
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseValue
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
return|return
name|ParseValue
argument_list|(
name|Ty
argument_list|,
name|V
argument_list|,
operator|&
name|PFS
argument_list|)
return|;
block|}
name|bool
name|ParseValue
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseValue
argument_list|(
name|Ty
argument_list|,
name|V
argument_list|,
operator|&
name|PFS
argument_list|)
return|;
block|}
name|bool
name|ParseTypeAndValue
parameter_list|(
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseTypeAndValue
parameter_list|(
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
return|return
name|ParseTypeAndValue
argument_list|(
name|V
argument_list|,
operator|&
name|PFS
argument_list|)
return|;
block|}
name|bool
name|ParseTypeAndValue
parameter_list|(
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseTypeAndValue
argument_list|(
name|V
argument_list|,
name|PFS
argument_list|)
return|;
block|}
name|bool
name|ParseTypeAndBasicBlock
parameter_list|(
name|BasicBlock
modifier|*
modifier|&
name|BB
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseTypeAndBasicBlock
parameter_list|(
name|BasicBlock
modifier|*
modifier|&
name|BB
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
name|LocTy
name|Loc
decl_stmt|;
return|return
name|ParseTypeAndBasicBlock
argument_list|(
name|BB
argument_list|,
name|Loc
argument_list|,
name|PFS
argument_list|)
return|;
block|}
struct|struct
name|ParamInfo
block|{
name|LocTy
name|Loc
decl_stmt|;
name|Value
modifier|*
name|V
decl_stmt|;
name|AttributeSet
name|Attrs
decl_stmt|;
name|ParamInfo
argument_list|(
argument|LocTy loc
argument_list|,
argument|Value *v
argument_list|,
argument|AttributeSet attrs
argument_list|)
block|:
name|Loc
argument_list|(
name|loc
argument_list|)
operator|,
name|V
argument_list|(
name|v
argument_list|)
operator|,
name|Attrs
argument_list|(
argument|attrs
argument_list|)
block|{}
block|}
struct|;
name|bool
name|ParseParameterList
argument_list|(
name|SmallVectorImpl
operator|<
name|ParamInfo
operator|>
operator|&
name|ArgList
argument_list|,
name|PerFunctionState
operator|&
name|PFS
argument_list|)
decl_stmt|;
comment|// Constant Parsing.
name|bool
name|ParseValID
parameter_list|(
name|ValID
modifier|&
name|ID
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
init|=
name|NULL
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalValue
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Constant
modifier|*
modifier|&
name|V
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalTypeAndValue
parameter_list|(
name|Constant
modifier|*
modifier|&
name|V
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalValueVector
argument_list|(
name|SmallVectorImpl
operator|<
name|Constant
operator|*
operator|>
operator|&
name|Elts
argument_list|)
decl_stmt|;
name|bool
name|ParseMetadataListValue
parameter_list|(
name|ValID
modifier|&
name|ID
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseMetadataValue
parameter_list|(
name|ValID
modifier|&
name|ID
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseMDNodeVector
argument_list|(
name|SmallVectorImpl
operator|<
name|Value
operator|*
operator|>
operator|&
argument_list|,
name|PerFunctionState
operator|*
name|PFS
argument_list|)
decl_stmt|;
name|bool
name|ParseInstructionMetadata
parameter_list|(
name|Instruction
modifier|*
name|Inst
parameter_list|,
name|PerFunctionState
modifier|*
name|PFS
parameter_list|)
function_decl|;
comment|// Function Parsing.
struct|struct
name|ArgInfo
block|{
name|LocTy
name|Loc
decl_stmt|;
name|Type
modifier|*
name|Ty
decl_stmt|;
name|AttributeSet
name|Attrs
decl_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|ArgInfo
argument_list|(
argument|LocTy L
argument_list|,
argument|Type *ty
argument_list|,
argument|AttributeSet Attr
argument_list|,
argument|const std::string&N
argument_list|)
block|:
name|Loc
argument_list|(
name|L
argument_list|)
operator|,
name|Ty
argument_list|(
name|ty
argument_list|)
operator|,
name|Attrs
argument_list|(
name|Attr
argument_list|)
operator|,
name|Name
argument_list|(
argument|N
argument_list|)
block|{}
block|}
struct|;
name|bool
name|ParseArgumentList
argument_list|(
name|SmallVectorImpl
operator|<
name|ArgInfo
operator|>
operator|&
name|ArgList
argument_list|,
name|bool
operator|&
name|isVarArg
argument_list|)
decl_stmt|;
name|bool
name|ParseFunctionHeader
parameter_list|(
name|Function
modifier|*
modifier|&
name|Fn
parameter_list|,
name|bool
name|isDefine
parameter_list|)
function_decl|;
name|bool
name|ParseFunctionBody
parameter_list|(
name|Function
modifier|&
name|Fn
parameter_list|)
function_decl|;
name|bool
name|ParseBasicBlock
parameter_list|(
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
comment|// Instruction Parsing.  Each instruction parsing routine can return with a
comment|// normal result, an error result, or return having eaten an extra comma.
enum|enum
name|InstResult
block|{
name|InstNormal
init|=
literal|0
block|,
name|InstError
init|=
literal|1
block|,
name|InstExtraComma
init|=
literal|2
block|}
enum|;
name|int
name|ParseInstruction
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseCmpPredicate
parameter_list|(
name|unsigned
modifier|&
name|Pred
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseRet
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseBr
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseSwitch
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseIndirectBr
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseInvoke
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseResume
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseArithmetic
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|,
name|unsigned
name|OperandType
parameter_list|)
function_decl|;
name|bool
name|ParseLogical
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseCompare
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseCast
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseSelect
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseVA_Arg
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseExtractElement
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseInsertElement
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseShuffleVector
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParsePHI
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseLandingPad
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseCall
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|bool
name|isTail
parameter_list|)
function_decl|;
name|int
name|ParseAlloc
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseLoad
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseStore
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseCmpXchg
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseAtomicRMW
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseFence
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseGetElementPtr
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseExtractValue
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|int
name|ParseInsertValue
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ResolveForwardRefBlockAddresses
argument_list|(
name|Function
operator|*
name|TheFn
argument_list|,
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|ValID
argument_list|,
name|GlobalValue
operator|*
operator|>
expr|>
operator|&
name|Refs
argument_list|,
name|PerFunctionState
operator|*
name|PFS
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

