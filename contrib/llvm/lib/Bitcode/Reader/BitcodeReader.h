begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitcodeReader.h - Internal BitcodeReader impl ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitcodeReader class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_BITCODE_READER_BITCODEREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_BITCODE_READER_BITCODEREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitstreamReader.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/LLVMBitCodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Attributes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GVMaterializer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/OperandTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/TrackingMDRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Type.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|<deque>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Comdat
decl_stmt|;
name|class
name|MemoryBuffer
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|//                          BitcodeReaderValueList Class
comment|//===----------------------------------------------------------------------===//
name|class
name|BitcodeReaderValueList
block|{
name|std
operator|::
name|vector
operator|<
name|WeakVH
operator|>
name|ValuePtrs
expr_stmt|;
comment|/// ResolveConstants - As we resolve forward-referenced constants, we add
comment|/// information about them to this vector.  This allows us to resolve them in
comment|/// bulk instead of resolving each reference at a time.  See the code in
comment|/// ResolveConstantForwardRefs for more information about this.
comment|///
comment|/// The key of this vector is the placeholder constant, the value is the slot
comment|/// number that holds the resolved value.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Constant
operator|*
operator|,
name|unsigned
operator|>
expr|>
name|ResolveConstantsTy
expr_stmt|;
name|ResolveConstantsTy
name|ResolveConstants
decl_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|public
label|:
name|BitcodeReaderValueList
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|Context
argument_list|(
argument|C
argument_list|)
block|{}
operator|~
name|BitcodeReaderValueList
argument_list|()
block|{
name|assert
argument_list|(
name|ResolveConstants
operator|.
name|empty
argument_list|()
operator|&&
literal|"Constants not resolved?"
argument_list|)
block|;   }
comment|// vector compatibility methods
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|ValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|push_back
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
name|ValuePtrs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|assert
argument_list|(
name|ResolveConstants
operator|.
name|empty
argument_list|()
operator|&&
literal|"Constants not resolved?"
argument_list|)
expr_stmt|;
name|ValuePtrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|Value
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|ValuePtrs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ValuePtrs
index|[
name|i
index|]
return|;
block|}
name|Value
operator|*
name|back
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
name|ValuePtrs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|shrinkTo
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|size
argument_list|()
operator|&&
literal|"Invalid shrinkTo request!"
argument_list|)
expr_stmt|;
name|ValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|Constant
modifier|*
name|getConstantFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|Value
modifier|*
name|getValueFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|void
name|AssignValue
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
comment|/// ResolveConstantForwardRefs - Once all constants are read, this method bulk
comment|/// resolves any forward references.
name|void
name|ResolveConstantForwardRefs
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|//                          BitcodeReaderMDValueList Class
comment|//===----------------------------------------------------------------------===//
name|class
name|BitcodeReaderMDValueList
block|{
name|unsigned
name|NumFwdRefs
decl_stmt|;
name|bool
name|AnyFwdRefs
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|TrackingMDRef
operator|>
name|MDValuePtrs
expr_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|public
label|:
name|BitcodeReaderMDValueList
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|NumFwdRefs
argument_list|(
literal|0
argument_list|)
operator|,
name|AnyFwdRefs
argument_list|(
name|false
argument_list|)
operator|,
name|Context
argument_list|(
argument|C
argument_list|)
block|{}
comment|// vector compatibility methods
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|MDValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|push_back
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
name|MDValuePtrs
operator|.
name|emplace_back
argument_list|(
name|MD
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|MDValuePtrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|Metadata
operator|*
name|back
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
name|MDValuePtrs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|Metadata
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|MDValuePtrs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|MDValuePtrs
index|[
name|i
index|]
return|;
block|}
name|void
name|shrinkTo
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|size
argument_list|()
operator|&&
literal|"Invalid shrinkTo request!"
argument_list|)
expr_stmt|;
name|MDValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|Metadata
modifier|*
name|getValueFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
function_decl|;
name|void
name|AssignValue
parameter_list|(
name|Metadata
modifier|*
name|MD
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
name|void
name|tryToResolveCycles
parameter_list|()
function_decl|;
block|}
empty_stmt|;
name|class
name|BitcodeReader
range|:
name|public
name|GVMaterializer
block|{
name|LLVMContext
operator|&
name|Context
block|;
name|DiagnosticHandlerFunction
name|DiagnosticHandler
block|;
name|Module
operator|*
name|TheModule
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|Buffer
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|BitstreamReader
operator|>
name|StreamFile
block|;
name|BitstreamCursor
name|Stream
block|;
name|DataStreamer
operator|*
name|LazyStreamer
block|;
name|uint64_t
name|NextUnreadBit
block|;
name|bool
name|SeenValueSymbolTable
block|;
name|std
operator|::
name|vector
operator|<
name|Type
operator|*
operator|>
name|TypeList
block|;
name|BitcodeReaderValueList
name|ValueList
block|;
name|BitcodeReaderMDValueList
name|MDValueList
block|;
name|std
operator|::
name|vector
operator|<
name|Comdat
operator|*
operator|>
name|ComdatList
block|;
name|SmallVector
operator|<
name|Instruction
operator|*
block|,
literal|64
operator|>
name|InstructionList
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|GlobalVariable
operator|*
block|,
name|unsigned
operator|>
expr|>
name|GlobalInits
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|GlobalAlias
operator|*
block|,
name|unsigned
operator|>
expr|>
name|AliasInits
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Function
operator|*
block|,
name|unsigned
operator|>
expr|>
name|FunctionPrefixes
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Function
operator|*
block|,
name|unsigned
operator|>
expr|>
name|FunctionPrologues
block|;
name|SmallVector
operator|<
name|Instruction
operator|*
block|,
literal|64
operator|>
name|InstsWithTBAATag
block|;
comment|/// MAttributes - The set of attributes by index.  Index zero in the
comment|/// file is for null, and is thus not represented here.  As such all indices
comment|/// are off by one.
name|std
operator|::
name|vector
operator|<
name|AttributeSet
operator|>
name|MAttributes
block|;
comment|/// \brief The set of attribute groups.
name|std
operator|::
name|map
operator|<
name|unsigned
block|,
name|AttributeSet
operator|>
name|MAttributeGroups
block|;
comment|/// FunctionBBs - While parsing a function body, this is a list of the basic
comment|/// blocks for the function.
name|std
operator|::
name|vector
operator|<
name|BasicBlock
operator|*
operator|>
name|FunctionBBs
block|;
comment|// When reading the module header, this list is populated with functions that
comment|// have bodies later in the file.
name|std
operator|::
name|vector
operator|<
name|Function
operator|*
operator|>
name|FunctionsWithBodies
block|;
comment|// When intrinsic functions are encountered which require upgrading they are
comment|// stored here with their replacement function.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Function
operator|*
operator|,
name|Function
operator|*
operator|>
expr|>
name|UpgradedIntrinsicMap
expr_stmt|;
name|UpgradedIntrinsicMap
name|UpgradedIntrinsics
decl_stmt|;
comment|// Map the bitcode's custom MDKind ID to the Module's MDKind ID.
name|DenseMap
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|MDKindMap
expr_stmt|;
comment|// Several operations happen after the module header has been read, but
comment|// before function bodies are processed. This keeps track of whether
comment|// we've done this yet.
name|bool
name|SeenFirstFunctionBody
decl_stmt|;
comment|/// DeferredFunctionInfo - When function bodies are initially scanned, this
comment|/// map contains info about where to find deferred function body in the
comment|/// stream.
name|DenseMap
operator|<
name|Function
operator|*
operator|,
name|uint64_t
operator|>
name|DeferredFunctionInfo
expr_stmt|;
comment|/// These are basic blocks forward-referenced by block addresses.  They are
comment|/// inserted lazily into functions when they're loaded.  The basic block ID is
comment|/// its index into the vector.
name|DenseMap
operator|<
name|Function
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|BasicBlock
operator|*
operator|>>
name|BasicBlockFwdRefs
expr_stmt|;
name|std
operator|::
name|deque
operator|<
name|Function
operator|*
operator|>
name|BasicBlockFwdRefQueue
expr_stmt|;
comment|/// UseRelativeIDs - Indicates that we are using a new encoding for
comment|/// instruction operands where most operands in the current
comment|/// FUNCTION_BLOCK are encoded relative to the instruction number,
comment|/// for a more compact encoding.  Some instruction operands are not
comment|/// relative to the instruction ID: basic block numbers, and types.
comment|/// Once the old style function blocks have been phased out, we would
comment|/// not need this flag.
name|bool
name|UseRelativeIDs
decl_stmt|;
comment|/// True if all functions will be materialized, negating the need to process
comment|/// (e.g.) blockaddress forward references.
name|bool
name|WillMaterializeAllForwardRefs
decl_stmt|;
comment|/// Functions that have block addresses taken.  This is usually empty.
name|SmallPtrSet
operator|<
specifier|const
name|Function
operator|*
operator|,
literal|4
operator|>
name|BlockAddressesTaken
expr_stmt|;
name|public
label|:
name|std
operator|::
name|error_code
name|Error
argument_list|(
argument|BitcodeError E
argument_list|,
argument|const Twine&Message
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|Error
argument_list|(
argument|BitcodeError E
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|Error
argument_list|(
specifier|const
name|Twine
operator|&
name|Message
argument_list|)
expr_stmt|;
name|explicit
name|BitcodeReader
parameter_list|(
name|MemoryBuffer
modifier|*
name|buffer
parameter_list|,
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|DiagnosticHandlerFunction
name|DiagnosticHandler
parameter_list|)
function_decl|;
name|explicit
name|BitcodeReader
parameter_list|(
name|DataStreamer
modifier|*
name|streamer
parameter_list|,
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|DiagnosticHandlerFunction
name|DiagnosticHandler
parameter_list|)
function_decl|;
operator|~
name|BitcodeReader
argument_list|()
block|{
name|FreeState
argument_list|()
block|; }
name|std
operator|::
name|error_code
name|materializeForwardReferencedFunctions
argument_list|()
expr_stmt|;
name|void
name|FreeState
parameter_list|()
function_decl|;
name|void
name|releaseBuffer
parameter_list|()
function_decl|;
name|bool
name|isDematerializable
argument_list|(
specifier|const
name|GlobalValue
operator|*
name|GV
argument_list|)
decl|const
name|override
decl_stmt|;
name|std
operator|::
name|error_code
name|materialize
argument_list|(
argument|GlobalValue *GV
argument_list|)
name|override
expr_stmt|;
name|std
operator|::
name|error_code
name|MaterializeModule
argument_list|(
argument|Module *M
argument_list|)
name|override
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|StructType
operator|*
operator|>
name|getIdentifiedStructTypes
argument_list|()
specifier|const
name|override
expr_stmt|;
name|void
name|Dematerialize
argument_list|(
name|GlobalValue
operator|*
name|GV
argument_list|)
name|override
decl_stmt|;
comment|/// @brief Main interface to parsing a bitcode buffer.
comment|/// @returns true if an error occurred.
name|std
operator|::
name|error_code
name|ParseBitcodeInto
argument_list|(
name|Module
operator|*
name|M
argument_list|)
expr_stmt|;
comment|/// @brief Cheap mechanism to just extract module triple
comment|/// @returns true if an error occurred.
name|ErrorOr
operator|<
name|std
operator|::
name|string
operator|>
name|parseTriple
argument_list|()
expr_stmt|;
specifier|static
name|uint64_t
name|decodeSignRotatedValue
parameter_list|(
name|uint64_t
name|V
parameter_list|)
function_decl|;
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|StructType
operator|*
operator|>
name|IdentifiedStructTypes
expr_stmt|;
name|StructType
modifier|*
name|createIdentifiedStructType
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|,
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|StructType
modifier|*
name|createIdentifiedStructType
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|)
function_decl|;
name|Type
modifier|*
name|getTypeByID
parameter_list|(
name|unsigned
name|ID
parameter_list|)
function_decl|;
name|Value
modifier|*
name|getFnValueByID
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
if|if
condition|(
name|Ty
operator|&&
name|Ty
operator|->
name|isMetadataTy
argument_list|()
condition|)
return|return
name|MetadataAsValue
operator|::
name|get
argument_list|(
name|Ty
operator|->
name|getContext
argument_list|()
argument_list|,
name|getFnMetadataByID
argument_list|(
name|ID
argument_list|)
argument_list|)
return|;
return|return
name|ValueList
operator|.
name|getValueFwdRef
argument_list|(
name|ID
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|Metadata
modifier|*
name|getFnMetadataByID
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
return|return
name|MDValueList
operator|.
name|getValueFwdRef
argument_list|(
name|ID
argument_list|)
return|;
block|}
name|BasicBlock
modifier|*
name|getBasicBlock
argument_list|(
name|unsigned
name|ID
argument_list|)
decl|const
block|{
if|if
condition|(
name|ID
operator|>=
name|FunctionBBs
operator|.
name|size
argument_list|()
condition|)
return|return
name|nullptr
return|;
comment|// Invalid ID
return|return
name|FunctionBBs
index|[
name|ID
index|]
return|;
block|}
name|AttributeSet
name|getAttributes
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|<
name|MAttributes
operator|.
name|size
argument_list|()
condition|)
return|return
name|MAttributes
index|[
name|i
operator|-
literal|1
index|]
return|;
return|return
name|AttributeSet
argument_list|()
return|;
block|}
comment|/// getValueTypePair - Read a value/type pair out of the specified record from
comment|/// slot 'Slot'.  Increment Slot past the number of slots used in the record.
comment|/// Return true on failure.
name|bool
name|getValueTypePair
argument_list|(
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
operator|&
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Value
operator|*
operator|&
name|ResVal
argument_list|)
block|{
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
return|return
name|true
return|;
name|unsigned
name|ValNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
operator|++
index|]
decl_stmt|;
comment|// Adjust the ValNo, if it was encoded relative to the InstNum.
if|if
condition|(
name|UseRelativeIDs
condition|)
name|ValNo
operator|=
name|InstNum
operator|-
name|ValNo
expr_stmt|;
if|if
condition|(
name|ValNo
operator|<
name|InstNum
condition|)
block|{
comment|// If this is not a forward reference, just return the value we already
comment|// have.
name|ResVal
operator|=
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|nullptr
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
name|nullptr
return|;
block|}
elseif|else
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|TypeNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
operator|++
index|]
decl_stmt|;
name|ResVal
operator|=
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|getTypeByID
argument_list|(
name|TypeNo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
name|nullptr
return|;
block|}
comment|/// popValue - Read a value out of the specified record from slot 'Slot'.
comment|/// Increment Slot past the number of slots used by the value in the record.
comment|/// Return true if there is an error.
name|bool
name|popValue
argument_list|(
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
operator|&
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|Value
operator|*
operator|&
name|ResVal
argument_list|)
block|{
if|if
condition|(
name|getValue
argument_list|(
name|Record
argument_list|,
name|Slot
argument_list|,
name|InstNum
argument_list|,
name|Ty
argument_list|,
name|ResVal
argument_list|)
condition|)
return|return
name|true
return|;
comment|// All values currently take a single record slot.
operator|++
name|Slot
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// getValue -- Like popValue, but does not increment the Slot number.
name|bool
name|getValue
argument_list|(
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|Value
operator|*
operator|&
name|ResVal
argument_list|)
block|{
name|ResVal
operator|=
name|getValue
argument_list|(
name|Record
argument_list|,
name|Slot
argument_list|,
name|InstNum
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
name|nullptr
return|;
block|}
comment|/// getValue -- Version of getValue that returns ResVal directly,
comment|/// or 0 if there is an error.
name|Value
modifier|*
name|getValue
argument_list|(
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
block|{
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|unsigned
name|ValNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
index|]
decl_stmt|;
comment|// Adjust the ValNo, if it was encoded relative to the InstNum.
if|if
condition|(
name|UseRelativeIDs
condition|)
name|ValNo
operator|=
name|InstNum
operator|-
name|ValNo
expr_stmt|;
return|return
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|Ty
argument_list|)
return|;
block|}
comment|/// getValueSigned -- Like getValue, but decodes signed VBRs.
name|Value
modifier|*
name|getValueSigned
argument_list|(
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
block|{
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|unsigned
name|ValNo
init|=
operator|(
name|unsigned
operator|)
name|decodeSignRotatedValue
argument_list|(
name|Record
index|[
name|Slot
index|]
argument_list|)
decl_stmt|;
comment|// Adjust the ValNo, if it was encoded relative to the InstNum.
if|if
condition|(
name|UseRelativeIDs
condition|)
name|ValNo
operator|=
name|InstNum
operator|-
name|ValNo
expr_stmt|;
return|return
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|std
operator|::
name|error_code
name|ParseAttrKind
argument_list|(
argument|uint64_t Code
argument_list|,
argument|Attribute::AttrKind *Kind
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseModule
argument_list|(
argument|bool Resume
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseAttributeBlock
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseAttributeGroupBlock
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseTypeTable
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseTypeTableBody
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseValueSymbolTable
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseConstants
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|RememberAndSkipFunctionBody
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseFunctionBody
argument_list|(
name|Function
operator|*
name|F
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|GlobalCleanup
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ResolveGlobalAndAliasInits
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseMetadata
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseMetadataAttachment
argument_list|()
expr_stmt|;
name|ErrorOr
operator|<
name|std
operator|::
name|string
operator|>
name|parseModuleTriple
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|ParseUseLists
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|InitStream
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|InitStreamFromBuffer
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|InitLazyStream
argument_list|()
expr_stmt|;
name|std
operator|::
name|error_code
name|FindFunctionInStream
argument_list|(
argument|Function *F
argument_list|,
argument|DenseMap<Function *
argument_list|,
argument|uint64_t>::iterator DeferredFunctionInfoIterator
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

