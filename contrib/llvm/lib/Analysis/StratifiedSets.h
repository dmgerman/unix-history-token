begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- StratifiedSets.h - Abstract stratified sets implementation. --------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_STRATIFIEDSETS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_STRATIFIEDSETS_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|<bitset>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cmath>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// \brief An index into Stratified Sets.
typedef|typedef
name|unsigned
name|StratifiedIndex
typedef|;
comment|// NOTE: ^ This can't be a short -- bootstrapping clang has a case where
comment|// ~1M sets exist.
comment|// \brief Container of information related to a value in a StratifiedSet.
struct|struct
name|StratifiedInfo
block|{
name|StratifiedIndex
name|Index
decl_stmt|;
comment|// For field sensitivity, etc. we can tack attributes on to this struct.
block|}
struct|;
comment|// The number of attributes that StratifiedAttrs should contain. Attributes are
comment|// described below, and 32 was an arbitrary choice because it fits nicely in 32
comment|// bits (because we use a bitset for StratifiedAttrs).
specifier|static
specifier|const
name|unsigned
name|NumStratifiedAttrs
init|=
literal|32
decl_stmt|;
comment|// These are attributes that the users of StratifiedSets/StratifiedSetBuilders
comment|// may use for various purposes. These also have the special property of that
comment|// they are merged down. So, if set A is above set B, and one decides to set an
comment|// attribute in set A, then the attribute will automatically be set in set B.
typedef|typedef
name|std
operator|::
name|bitset
operator|<
name|NumStratifiedAttrs
operator|>
name|StratifiedAttrs
expr_stmt|;
comment|// \brief A "link" between two StratifiedSets.
struct|struct
name|StratifiedLink
block|{
comment|// \brief This is a value used to signify "does not exist" where
comment|// the StratifiedIndex type is used. This is used instead of
comment|// Optional<StratifiedIndex> because Optional<StratifiedIndex> would
comment|// eat up a considerable amount of extra memory, after struct
comment|// padding/alignment is taken into account.
specifier|static
specifier|const
name|StratifiedIndex
name|SetSentinel
decl_stmt|;
comment|// \brief The index for the set "above" current
name|StratifiedIndex
name|Above
decl_stmt|;
comment|// \brief The link for the set "below" current
name|StratifiedIndex
name|Below
decl_stmt|;
comment|// \brief Attributes for these StratifiedSets.
name|StratifiedAttrs
name|Attrs
decl_stmt|;
name|StratifiedLink
argument_list|()
operator|:
name|Above
argument_list|(
name|SetSentinel
argument_list|)
operator|,
name|Below
argument_list|(
argument|SetSentinel
argument_list|)
block|{}
name|bool
name|hasBelow
argument_list|()
specifier|const
block|{
return|return
name|Below
operator|!=
name|SetSentinel
return|;
block|}
name|bool
name|hasAbove
argument_list|()
specifier|const
block|{
return|return
name|Above
operator|!=
name|SetSentinel
return|;
block|}
name|void
name|clearBelow
parameter_list|()
block|{
name|Below
operator|=
name|SetSentinel
expr_stmt|;
block|}
name|void
name|clearAbove
parameter_list|()
block|{
name|Above
operator|=
name|SetSentinel
expr_stmt|;
block|}
block|}
struct|;
comment|// \brief These are stratified sets, as described in "Fast algorithms for
comment|// Dyck-CFL-reachability with applications to Alias Analysis" by Zhang Q, Lyu M
comment|// R, Yuan H, and Su Z. -- in short, this is meant to represent different sets
comment|// of Value*s. If two Value*s are in the same set, or if both sets have
comment|// overlapping attributes, then the Value*s are said to alias.
comment|//
comment|// Sets may be related by position, meaning that one set may be considered as
comment|// above or below another. In CFL Alias Analysis, this gives us an indication
comment|// of how two variables are related; if the set of variable A is below a set
comment|// containing variable B, then at some point, a variable that has interacted
comment|// with B (or B itself) was either used in order to extract the variable A, or
comment|// was used as storage of variable A.
comment|//
comment|// Sets may also have attributes (as noted above). These attributes are
comment|// generally used for noting whether a variable in the set has interacted with
comment|// a variable whose origins we don't quite know (i.e. globals/arguments), or if
comment|// the variable may have had operations performed on it (modified in a function
comment|// call). All attributes that exist in a set A must exist in all sets marked as
comment|// below set A.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|StratifiedSets
block|{
name|public
operator|:
name|StratifiedSets
argument_list|()
block|{}
name|StratifiedSets
argument_list|(
name|DenseMap
operator|<
name|T
argument_list|,
name|StratifiedInfo
operator|>
name|Map
argument_list|,
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|Links
argument_list|)
operator|:
name|Values
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Map
argument_list|)
argument_list|)
block|,
name|Links
argument_list|(
argument|std::move(Links)
argument_list|)
block|{}
name|StratifiedSets
argument_list|(
argument|StratifiedSets<T>&&Other
argument_list|)
block|{
operator|*
name|this
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
block|; }
name|StratifiedSets
operator|&
name|operator
operator|=
operator|(
name|StratifiedSets
operator|<
name|T
operator|>
operator|&&
name|Other
operator|)
block|{
name|Values
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
operator|.
name|Values
argument_list|)
block|;
name|Links
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
operator|.
name|Links
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|Optional
operator|<
name|StratifiedInfo
operator|>
name|find
argument_list|(
argument|const T&Elem
argument_list|)
specifier|const
block|{
name|auto
name|Iter
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Elem
argument_list|)
block|;
if|if
condition|(
name|Iter
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NoneType
argument_list|()
return|;
block|}
return|return
name|Iter
operator|->
name|second
return|;
block|}
specifier|const
name|StratifiedLink
operator|&
name|getLink
argument_list|(
argument|StratifiedIndex Index
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Index
argument_list|)
argument_list|)
block|;
return|return
name|Links
index|[
name|Index
index|]
return|;
block|}
name|private
operator|:
name|DenseMap
operator|<
name|T
block|,
name|StratifiedInfo
operator|>
name|Values
block|;
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|Links
block|;
name|bool
name|inbounds
argument_list|(
argument|StratifiedIndex Idx
argument_list|)
specifier|const
block|{
return|return
name|Idx
operator|<
name|Links
operator|.
name|size
argument_list|()
return|;
block|}
expr|}
block|;
comment|// \brief Generic Builder class that produces StratifiedSets instances.
comment|//
comment|// The goal of this builder is to efficiently produce correct StratifiedSets
comment|// instances. To this end, we use a few tricks:
comment|//> Set chains (A method for linking sets together)
comment|//> Set remaps (A method for marking a set as an alias [irony?] of another)
comment|//
comment|// ==== Set chains ====
comment|// This builder has a notion of some value A being above, below, or with some
comment|// other value B:
comment|//> The `A above B` relationship implies that there is a reference edge going
comment|//   from A to B. Namely, it notes that A can store anything in B's set.
comment|//> The `A below B` relationship is the opposite of `A above B`. It implies
comment|//   that there's a dereference edge going from A to B.
comment|//> The `A with B` relationship states that there's an assignment edge going
comment|//   from A to B, and that A and B should be treated as equals.
comment|//
comment|// As an example, take the following code snippet:
comment|//
comment|// %a = alloca i32, align 4
comment|// %ap = alloca i32*, align 8
comment|// %app = alloca i32**, align 8
comment|// store %a, %ap
comment|// store %ap, %app
comment|// %aw = getelementptr %ap, 0
comment|//
comment|// Given this, the follow relations exist:
comment|//   - %a below %ap& %ap above %a
comment|//   - %ap below %app& %app above %ap
comment|//   - %aw with %ap& %ap with %aw
comment|//
comment|// These relations produce the following sets:
comment|//   [{%a}, {%ap, %aw}, {%app}]
comment|//
comment|// ...Which states that the only MayAlias relationship in the above program is
comment|// between %ap and %aw.
comment|//
comment|// Life gets more complicated when we actually have logic in our programs. So,
comment|// we either must remove this logic from our programs, or make consessions for
comment|// it in our AA algorithms. In this case, we have decided to select the latter
comment|// option.
comment|//
comment|// First complication: Conditionals
comment|// Motivation:
comment|//  %ad = alloca int, align 4
comment|//  %a = alloca int*, align 8
comment|//  %b = alloca int*, align 8
comment|//  %bp = alloca int**, align 8
comment|//  %c = call i1 @SomeFunc()
comment|//  %k = select %c, %ad, %bp
comment|//  store %ad, %a
comment|//  store %b, %bp
comment|//
comment|// %k has 'with' edges to both %a and %b, which ordinarily would not be linked
comment|// together. So, we merge the set that contains %a with the set that contains
comment|// %b. We then recursively merge the set above %a with the set above %b, and
comment|// the set below  %a with the set below %b, etc. Ultimately, the sets for this
comment|// program would end up like: {%ad}, {%a, %b, %k}, {%bp}, where {%ad} is below
comment|// {%a, %b, %c} is below {%ad}.
comment|//
comment|// Second complication: Arbitrary casts
comment|// Motivation:
comment|//  %ip = alloca int*, align 8
comment|//  %ipp = alloca int**, align 8
comment|//  %i = bitcast ipp to int
comment|//  store %ip, %ipp
comment|//  store %i, %ip
comment|//
comment|// This is impossible to construct with any of the rules above, because a set
comment|// containing both {%i, %ipp} is supposed to exist, the set with %i is supposed
comment|// to be below the set with %ip, and the set with %ip is supposed to be below
comment|// the set with %ipp. Because we don't allow circular relationships like this,
comment|// we merge all concerned sets into one. So, the above code would generate a
comment|// single StratifiedSet: {%ip, %ipp, %i}.
comment|//
comment|// ==== Set remaps ====
comment|// More of an implementation detail than anything -- when merging sets, we need
comment|// to update the numbers of all of the elements mapped to those sets. Rather
comment|// than doing this at each merge, we note in the BuilderLink structure that a
comment|// remap has occurred, and use this information so we can defer renumbering set
comment|// elements until build time.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|StratifiedSetsBuilder
block|{
comment|// \brief Represents a Stratified Set, with information about the Stratified
comment|// Set above it, the set below it, and whether the current set has been
comment|// remapped to another.
block|struct
name|BuilderLink
block|{
specifier|const
name|StratifiedIndex
name|Number
block|;
name|BuilderLink
argument_list|(
argument|StratifiedIndex N
argument_list|)
operator|:
name|Number
argument_list|(
argument|N
argument_list|)
block|{
name|Remap
operator|=
name|StratifiedLink
operator|::
name|SetSentinel
block|;     }
name|bool
name|hasAbove
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|hasAbove
argument_list|()
return|;
block|}
name|bool
name|hasBelow
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|hasBelow
argument_list|()
return|;
block|}
name|void
name|setBelow
argument_list|(
argument|StratifiedIndex I
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Below
operator|=
name|I
block|;     }
name|void
name|setAbove
argument_list|(
argument|StratifiedIndex I
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Above
operator|=
name|I
block|;     }
name|void
name|clearBelow
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|clearBelow
argument_list|()
block|;     }
name|void
name|clearAbove
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|clearAbove
argument_list|()
block|;     }
name|StratifiedIndex
name|getBelow
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|hasBelow
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Below
return|;
block|}
name|StratifiedIndex
name|getAbove
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|hasAbove
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Above
return|;
block|}
name|StratifiedAttrs
operator|&
name|getAttrs
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Attrs
return|;
block|}
name|void
name|setAttr
argument_list|(
argument|unsigned index
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|index
operator|<
name|NumStratifiedAttrs
argument_list|)
block|;
name|Link
operator|.
name|Attrs
operator|.
name|set
argument_list|(
name|index
argument_list|)
block|;     }
name|void
name|setAttrs
argument_list|(
argument|const StratifiedAttrs&other
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Attrs
operator||=
name|other
block|;     }
name|bool
name|isRemapped
argument_list|()
specifier|const
block|{
return|return
name|Remap
operator|!=
name|StratifiedLink
operator|::
name|SetSentinel
return|;
block|}
comment|// \brief For initial remapping to another set
name|void
name|remapTo
argument_list|(
argument|StratifiedIndex Other
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Remap
operator|=
name|Other
block|;     }
name|StratifiedIndex
name|getRemapIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Remap
return|;
block|}
comment|// \brief Should only be called when we're already remapped.
name|void
name|updateRemap
argument_list|(
argument|StratifiedIndex Other
argument_list|)
block|{
name|assert
argument_list|(
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Remap
operator|=
name|Other
block|;     }
comment|// \brief Prefer the above functions to calling things directly on what's
comment|// returned from this -- they guard against unexpected calls when the
comment|// current BuilderLink is remapped.
specifier|const
name|StratifiedLink
operator|&
name|getLink
argument_list|()
specifier|const
block|{
return|return
name|Link
return|;
block|}
name|private
operator|:
name|StratifiedLink
name|Link
block|;
name|StratifiedIndex
name|Remap
block|;   }
block|;
comment|// \brief This function performs all of the set unioning/value renumbering
comment|// that we've been putting off, and generates a vector<StratifiedLink> that
comment|// may be placed in a StratifiedSets instance.
name|void
name|finalizeSets
argument_list|(
argument|std::vector<StratifiedLink>&StratLinks
argument_list|)
block|{
name|DenseMap
operator|<
name|StratifiedIndex
block|,
name|StratifiedIndex
operator|>
name|Remaps
block|;
for|for
control|(
name|auto
operator|&
name|Link
operator|:
name|Links
control|)
block|{
if|if
condition|(
name|Link
operator|.
name|isRemapped
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|StratifiedIndex
name|Number
init|=
name|StratLinks
operator|.
name|size
argument_list|()
decl_stmt|;
name|Remaps
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Link
operator|.
name|Number
argument_list|,
name|Number
argument_list|)
argument_list|)
expr_stmt|;
name|StratLinks
operator|.
name|push_back
argument_list|(
name|Link
operator|.
name|getLink
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
operator|&
name|Link
operator|:
name|StratLinks
control|)
block|{
if|if
condition|(
name|Link
operator|.
name|hasAbove
argument_list|()
condition|)
block|{
name|auto
operator|&
name|Above
operator|=
name|linksAt
argument_list|(
name|Link
operator|.
name|Above
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Above
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Link
operator|.
name|Above
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
if|if
condition|(
name|Link
operator|.
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
operator|&
name|Below
operator|=
name|linksAt
argument_list|(
name|Link
operator|.
name|Below
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Below
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Link
operator|.
name|Below
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
block|}
for|for
control|(
name|auto
operator|&
name|Pair
operator|:
name|Values
control|)
block|{
name|auto
operator|&
name|Info
operator|=
name|Pair
operator|.
name|second
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|.
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Link
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Info
operator|.
name|Index
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
block|}
comment|// \brief There's a guarantee in StratifiedLink where all bits set in a
comment|// Link.externals will be set in all Link.externals "below" it.
specifier|static
name|void
name|propagateAttrs
argument_list|(
argument|std::vector<StratifiedLink>&Links
argument_list|)
block|{
specifier|const
name|auto
name|getHighestParentAbove
operator|=
index|[
operator|&
name|Links
index|]
operator|(
name|StratifiedIndex
name|Idx
operator|)
block|{
specifier|const
name|auto
operator|*
name|Link
operator|=
operator|&
name|Links
index|[
name|Idx
index|]
block|;
while|while
condition|(
name|Link
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|Idx
operator|=
name|Link
operator|->
name|Above
expr_stmt|;
name|Link
operator|=
operator|&
name|Links
index|[
name|Idx
index|]
expr_stmt|;
block|}
return|return
name|Idx
return|;
block|}
block|;
name|SmallSet
operator|<
name|StratifiedIndex
block|,
literal|16
operator|>
name|Visited
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|Links
operator|.
name|size
argument_list|()
init|;
name|I
operator|<
name|E
condition|;
operator|++
name|I
control|)
block|{
name|auto
name|CurrentIndex
init|=
name|getHighestParentAbove
argument_list|(
name|I
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Visited
operator|.
name|insert
argument_list|(
name|CurrentIndex
argument_list|)
operator|.
name|second
condition|)
block|{
continue|continue;
block|}
while|while
condition|(
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
operator|&
name|CurrentBits
operator|=
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|Attrs
expr_stmt|;
name|auto
name|NextIndex
init|=
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|Below
decl_stmt|;
name|auto
operator|&
name|NextBits
operator|=
name|Links
index|[
name|NextIndex
index|]
operator|.
name|Attrs
expr_stmt|;
name|NextBits
operator||=
name|CurrentBits
expr_stmt|;
name|CurrentIndex
operator|=
name|NextIndex
expr_stmt|;
block|}
block|}
block|}
name|public
operator|:
comment|// \brief Builds a StratifiedSet from the information we've been given since
comment|// either construction or the prior build() call.
name|StratifiedSets
operator|<
name|T
operator|>
name|build
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|StratLinks
block|;
name|finalizeSets
argument_list|(
name|StratLinks
argument_list|)
block|;
name|propagateAttrs
argument_list|(
name|StratLinks
argument_list|)
block|;
name|Links
operator|.
name|clear
argument_list|()
block|;
return|return
name|StratifiedSets
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Values
argument_list|)
operator|,
name|std
operator|::
name|move
argument_list|(
name|StratLinks
argument_list|)
operator|)
return|;
block|}
name|std
operator|::
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Values
operator|.
name|size
argument_list|()
return|;
block|}
name|std
operator|::
name|size_t
name|numSets
argument_list|()
specifier|const
block|{
return|return
name|Links
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|has
argument_list|(
argument|const T&Elem
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Elem
argument_list|)
operator|.
name|hasValue
argument_list|()
return|;
block|}
name|bool
name|add
argument_list|(
argument|const T&Main
argument_list|)
block|{
if|if
condition|(
name|get
argument_list|(
name|Main
argument_list|)
operator|.
name|hasValue
argument_list|()
condition|)
return|return
name|false
return|;
name|auto
name|NewIndex
operator|=
name|getNewUnlinkedIndex
argument_list|()
block|;
return|return
name|addAtMerging
argument_list|(
name|Main
argument_list|,
name|NewIndex
argument_list|)
return|;
block|}
comment|// \brief Restructures the stratified sets as necessary to make "ToAdd" in a
comment|// set above "Main". There are some cases where this is not possible (see
comment|// above), so we merge them such that ToAdd and Main are in the same set.
name|bool
name|addAbove
argument_list|(
argument|const T&Main
argument_list|,
argument|const T&ToAdd
argument_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
block|;
name|auto
name|Index
operator|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
block|;
if|if
condition|(
operator|!
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|hasAbove
argument_list|()
condition|)
name|addLinkAbove
argument_list|(
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Above
operator|=
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|getAbove
argument_list|()
block|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|Above
argument_list|)
return|;
block|}
comment|// \brief Restructures the stratified sets as necessary to make "ToAdd" in a
comment|// set below "Main". There are some cases where this is not possible (see
comment|// above), so we merge them such that ToAdd and Main are in the same set.
name|bool
name|addBelow
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
name|Index
init|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|hasBelow
argument_list|()
condition|)
name|addLinkBelow
argument_list|(
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Below
init|=
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|getBelow
argument_list|()
decl_stmt|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|Below
argument_list|)
return|;
block|}
name|bool
name|addWith
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
name|MainIndex
init|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
decl_stmt|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|MainIndex
argument_list|)
return|;
block|}
name|void
name|noteAttribute
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
name|unsigned
name|AttrNum
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|AttrNum
operator|<
name|StratifiedLink
operator|::
name|SetSentinel
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|get
argument_list|(
name|Main
argument_list|)
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
name|Link
operator|.
name|setAttr
argument_list|(
name|AttrNum
argument_list|)
expr_stmt|;
block|}
name|void
name|noteAttributes
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|StratifiedAttrs
modifier|&
name|NewAttrs
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|get
argument_list|(
name|Main
argument_list|)
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
name|Link
operator|.
name|setAttrs
argument_list|(
name|NewAttrs
argument_list|)
expr_stmt|;
block|}
name|StratifiedAttrs
name|getAttributes
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|get
argument_list|(
name|Main
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Link
operator|=
operator|&
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Attrs
init|=
name|Link
operator|->
name|getAttrs
argument_list|()
decl_stmt|;
while|while
condition|(
name|Link
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|Link
operator|=
operator|&
name|linksAt
argument_list|(
name|Link
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|Attrs
operator||=
name|Link
operator|->
name|getAttrs
argument_list|()
expr_stmt|;
block|}
return|return
name|Attrs
return|;
block|}
name|bool
name|getAttribute
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
name|unsigned
name|AttrNum
parameter_list|)
block|{
name|assert
argument_list|(
name|AttrNum
operator|<
name|StratifiedLink
operator|::
name|SetSentinel
argument_list|)
expr_stmt|;
name|auto
name|Attrs
init|=
name|getAttributes
argument_list|(
name|Main
argument_list|)
decl_stmt|;
return|return
name|Attrs
index|[
name|AttrNum
index|]
return|;
block|}
comment|// \brief Gets the attributes that have been applied to the set that Main
comment|// belongs to. It ignores attributes in any sets above the one that Main
comment|// resides in.
name|StratifiedAttrs
name|getRawAttributes
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|get
argument_list|(
name|Main
argument_list|)
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
return|return
name|Link
operator|.
name|getAttrs
argument_list|()
return|;
block|}
comment|// \brief Gets an attribute from the attributes that have been applied to the
comment|// set that Main belongs to. It ignores attributes in any sets above the one
comment|// that Main resides in.
name|bool
name|getRawAttribute
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
name|unsigned
name|AttrNum
parameter_list|)
block|{
name|assert
argument_list|(
name|AttrNum
operator|<
name|StratifiedLink
operator|::
name|SetSentinel
argument_list|)
expr_stmt|;
name|auto
name|Attrs
init|=
name|getRawAttributes
argument_list|(
name|Main
argument_list|)
decl_stmt|;
return|return
name|Attrs
index|[
name|AttrNum
index|]
return|;
block|}
name|private
label|:
name|DenseMap
operator|<
name|T
operator|,
name|StratifiedInfo
operator|>
name|Values
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BuilderLink
operator|>
name|Links
expr_stmt|;
comment|// \brief Adds the given element at the given index, merging sets if
comment|// necessary.
name|bool
name|addAtMerging
parameter_list|(
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|,
name|StratifiedIndex
name|Index
parameter_list|)
block|{
name|StratifiedInfo
name|Info
init|=
block|{
name|Index
block|}
decl_stmt|;
name|auto
name|Pair
init|=
name|Values
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ToAdd
argument_list|,
name|Info
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Pair
operator|.
name|second
condition|)
return|return
name|true
return|;
name|auto
operator|&
name|Iter
operator|=
name|Pair
operator|.
name|first
expr_stmt|;
name|auto
operator|&
name|IterSet
operator|=
name|linksAt
argument_list|(
name|Iter
operator|->
name|second
operator|.
name|Index
argument_list|)
expr_stmt|;
name|auto
operator|&
name|ReqSet
operator|=
name|linksAt
argument_list|(
name|Index
argument_list|)
expr_stmt|;
comment|// Failed to add where we wanted to. Merge the sets.
if|if
condition|(
operator|&
name|IterSet
operator|!=
operator|&
name|ReqSet
condition|)
name|merge
argument_list|(
name|IterSet
operator|.
name|Number
argument_list|,
name|ReqSet
operator|.
name|Number
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// \brief Gets the BuilderLink at the given index, taking set remapping into
comment|// account.
name|BuilderLink
modifier|&
name|linksAt
parameter_list|(
name|StratifiedIndex
name|Index
parameter_list|)
block|{
name|auto
operator|*
name|Start
operator|=
operator|&
name|Links
index|[
name|Index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Start
operator|->
name|isRemapped
argument_list|()
condition|)
return|return
operator|*
name|Start
return|;
name|auto
operator|*
name|Current
operator|=
name|Start
expr_stmt|;
while|while
condition|(
name|Current
operator|->
name|isRemapped
argument_list|()
condition|)
name|Current
operator|=
operator|&
name|Links
index|[
name|Current
operator|->
name|getRemapIndex
argument_list|()
index|]
expr_stmt|;
name|auto
name|NewRemap
init|=
name|Current
operator|->
name|Number
decl_stmt|;
comment|// Run through everything that has yet to be updated, and update them to
comment|// remap to NewRemap
name|Current
operator|=
name|Start
expr_stmt|;
while|while
condition|(
name|Current
operator|->
name|isRemapped
argument_list|()
condition|)
block|{
name|auto
operator|*
name|Next
operator|=
operator|&
name|Links
index|[
name|Current
operator|->
name|getRemapIndex
argument_list|()
index|]
expr_stmt|;
name|Current
operator|->
name|updateRemap
argument_list|(
name|NewRemap
argument_list|)
expr_stmt|;
name|Current
operator|=
name|Next
expr_stmt|;
block|}
return|return
operator|*
name|Current
return|;
block|}
comment|// \brief Merges two sets into one another. Assumes that these sets are not
comment|// already one in the same
name|void
name|merge
parameter_list|(
name|StratifiedIndex
name|Idx1
parameter_list|,
name|StratifiedIndex
name|Idx2
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Idx1
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|Idx2
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|&
name|linksAt
argument_list|(
name|Idx1
argument_list|)
operator|!=
operator|&
name|linksAt
argument_list|(
name|Idx2
argument_list|)
operator|&&
literal|"Merging a set into itself is not allowed"
argument_list|)
expr_stmt|;
comment|// CASE 1: If the set at `Idx1` is above or below `Idx2`, we need to merge
comment|// both the
comment|// given sets, and all sets between them, into one.
if|if
condition|(
name|tryMergeUpwards
argument_list|(
name|Idx1
argument_list|,
name|Idx2
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tryMergeUpwards
argument_list|(
name|Idx2
argument_list|,
name|Idx1
argument_list|)
condition|)
return|return;
comment|// CASE 2: The set at `Idx1` is not in the same chain as the set at `Idx2`.
comment|// We therefore need to merge the two chains together.
name|mergeDirect
argument_list|(
name|Idx1
argument_list|,
name|Idx2
argument_list|)
expr_stmt|;
block|}
comment|// \brief Merges two sets assuming that the set at `Idx1` is unreachable from
comment|// traversing above or below the set at `Idx2`.
name|void
name|mergeDirect
parameter_list|(
name|StratifiedIndex
name|Idx1
parameter_list|,
name|StratifiedIndex
name|Idx2
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Idx1
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|Idx2
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|Idx1
argument_list|)
expr_stmt|;
name|auto
operator|*
name|LinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|Idx2
argument_list|)
expr_stmt|;
comment|// Merging everything above LinksInto then proceeding to merge everything
comment|// below LinksInto becomes problematic, so we go as far "up" as possible!
while|while
condition|(
name|LinksInto
operator|->
name|hasAbove
argument_list|()
operator|&&
name|LinksFrom
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|LinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksFrom
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LinksFrom
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|LinksInto
operator|->
name|setAbove
argument_list|(
name|LinksFrom
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewAbove
operator|=
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|NewAbove
operator|.
name|setBelow
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
comment|// Merging strategy:
comment|//> If neither has links below, stop.
comment|//> If only `LinksInto` has links below, stop.
comment|//> If only `LinksFrom` has links below, reset `LinksInto.Below` to
comment|//  match `LinksFrom.Below`
comment|//> If both have links above, deal with those next.
while|while
condition|(
name|LinksInto
operator|->
name|hasBelow
argument_list|()
operator|&&
name|LinksFrom
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
operator|&
name|FromAttrs
operator|=
name|LinksFrom
operator|->
name|getAttrs
argument_list|()
expr_stmt|;
name|LinksInto
operator|->
name|setAttrs
argument_list|(
name|FromAttrs
argument_list|)
expr_stmt|;
comment|// Remap needs to happen after getBelow(), but before
comment|// assignment of LinksFrom
name|auto
operator|*
name|NewLinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksFrom
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|LinksFrom
operator|->
name|remapTo
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
name|LinksFrom
operator|=
name|NewLinksFrom
expr_stmt|;
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LinksFrom
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|LinksInto
operator|->
name|setBelow
argument_list|(
name|LinksFrom
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewBelow
operator|=
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|NewBelow
operator|.
name|setAbove
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
name|LinksFrom
operator|->
name|remapTo
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
comment|// \brief Checks to see if lowerIndex is at a level lower than upperIndex.
comment|// If so, it will merge lowerIndex with upperIndex (and all of the sets
comment|// between) and return true. Otherwise, it will return false.
name|bool
name|tryMergeUpwards
parameter_list|(
name|StratifiedIndex
name|LowerIndex
parameter_list|,
name|StratifiedIndex
name|UpperIndex
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|LowerIndex
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|UpperIndex
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Lower
operator|=
operator|&
name|linksAt
argument_list|(
name|LowerIndex
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Upper
operator|=
operator|&
name|linksAt
argument_list|(
name|UpperIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lower
operator|==
name|Upper
condition|)
return|return
name|true
return|;
name|SmallVector
operator|<
name|BuilderLink
operator|*
operator|,
literal|8
operator|>
name|Found
expr_stmt|;
name|auto
operator|*
name|Current
operator|=
name|Lower
expr_stmt|;
name|auto
name|Attrs
init|=
name|Current
operator|->
name|getAttrs
argument_list|()
decl_stmt|;
while|while
condition|(
name|Current
operator|->
name|hasAbove
argument_list|()
operator|&&
name|Current
operator|!=
name|Upper
condition|)
block|{
name|Found
operator|.
name|push_back
argument_list|(
name|Current
argument_list|)
expr_stmt|;
name|Attrs
operator||=
name|Current
operator|->
name|getAttrs
argument_list|()
expr_stmt|;
name|Current
operator|=
operator|&
name|linksAt
argument_list|(
name|Current
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Current
operator|!=
name|Upper
condition|)
return|return
name|false
return|;
name|Upper
operator|->
name|setAttrs
argument_list|(
name|Attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lower
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
name|NewBelowIndex
init|=
name|Lower
operator|->
name|getBelow
argument_list|()
decl_stmt|;
name|Upper
operator|->
name|setBelow
argument_list|(
name|NewBelowIndex
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewBelow
operator|=
name|linksAt
argument_list|(
name|NewBelowIndex
argument_list|)
expr_stmt|;
name|NewBelow
operator|.
name|setAbove
argument_list|(
name|UpperIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Upper
operator|->
name|clearBelow
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Ptr
range|:
name|Found
control|)
name|Ptr
operator|->
name|remapTo
argument_list|(
name|Upper
operator|->
name|Number
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|Optional
operator|<
specifier|const
name|StratifiedInfo
operator|*
operator|>
name|get
argument_list|(
argument|const T&Val
argument_list|)
specifier|const
block|{
name|auto
name|Result
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
name|Result
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
return|return
name|NoneType
argument_list|()
return|;
return|return
operator|&
name|Result
operator|->
name|second
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|StratifiedInfo
operator|*
operator|>
name|get
argument_list|(
argument|const T&Val
argument_list|)
block|{
name|auto
name|Result
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
name|Result
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
return|return
name|NoneType
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
operator|&
name|Result
operator|->
name|second
return|;
end_return

begin_expr_stmt
unit|}    Optional
operator|<
name|StratifiedIndex
operator|>
name|indexOf
argument_list|(
argument|const T&Val
argument_list|)
block|{
name|auto
name|MaybeVal
operator|=
name|get
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
operator|!
name|MaybeVal
operator|.
name|hasValue
argument_list|()
condition|)
return|return
name|NoneType
argument_list|()
return|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|MaybeVal
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Link
operator|.
name|Number
return|;
end_return

begin_macro
unit|}    StratifiedIndex
name|addLinkBelow
argument_list|(
argument|StratifiedIndex Set
argument_list|)
end_macro

begin_block
block|{
name|auto
name|At
init|=
name|addLinks
argument_list|()
decl_stmt|;
name|Links
index|[
name|Set
index|]
operator|.
name|setBelow
argument_list|(
name|At
argument_list|)
expr_stmt|;
name|Links
index|[
name|At
index|]
operator|.
name|setAbove
argument_list|(
name|Set
argument_list|)
expr_stmt|;
return|return
name|At
return|;
block|}
end_block

begin_function
name|StratifiedIndex
name|addLinkAbove
parameter_list|(
name|StratifiedIndex
name|Set
parameter_list|)
block|{
name|auto
name|At
init|=
name|addLinks
argument_list|()
decl_stmt|;
name|Links
index|[
name|At
index|]
operator|.
name|setBelow
argument_list|(
name|Set
argument_list|)
expr_stmt|;
name|Links
index|[
name|Set
index|]
operator|.
name|setAbove
argument_list|(
name|At
argument_list|)
expr_stmt|;
return|return
name|At
return|;
block|}
end_function

begin_function
name|StratifiedIndex
name|getNewUnlinkedIndex
parameter_list|()
block|{
return|return
name|addLinks
argument_list|()
return|;
block|}
end_function

begin_function
name|StratifiedIndex
name|addLinks
parameter_list|()
block|{
name|auto
name|Link
init|=
name|Links
operator|.
name|size
argument_list|()
decl_stmt|;
name|Links
operator|.
name|push_back
argument_list|(
name|BuilderLink
argument_list|(
name|Link
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Link
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|inbounds
argument_list|(
name|StratifiedIndex
name|N
argument_list|)
decl|const
block|{
return|return
name|N
operator|<
name|Links
operator|.
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_endif
unit|}; }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_STRATIFIEDSETS_H
end_comment

end_unit

