begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- StratifiedSets.h - Abstract stratified sets implementation. --------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_STRATIFIEDSETS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_STRATIFIEDSETS_H
end_define

begin_include
include|#
directive|include
file|"AliasAnalysisSummary.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|<bitset>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cmath>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|cflaa
block|{
comment|/// An index into Stratified Sets.
typedef|typedef
name|unsigned
name|StratifiedIndex
typedef|;
comment|/// NOTE: ^ This can't be a short -- bootstrapping clang has a case where
comment|/// ~1M sets exist.
comment|// \brief Container of information related to a value in a StratifiedSet.
struct|struct
name|StratifiedInfo
block|{
name|StratifiedIndex
name|Index
decl_stmt|;
comment|/// For field sensitivity, etc. we can tack fields on here.
block|}
struct|;
comment|/// A "link" between two StratifiedSets.
struct|struct
name|StratifiedLink
block|{
comment|/// \brief This is a value used to signify "does not exist" where the
comment|/// StratifiedIndex type is used.
comment|///
comment|/// This is used instead of Optional<StratifiedIndex> because
comment|/// Optional<StratifiedIndex> would eat up a considerable amount of extra
comment|/// memory, after struct padding/alignment is taken into account.
specifier|static
specifier|const
name|StratifiedIndex
name|SetSentinel
decl_stmt|;
comment|/// The index for the set "above" current
name|StratifiedIndex
name|Above
decl_stmt|;
comment|/// The link for the set "below" current
name|StratifiedIndex
name|Below
decl_stmt|;
comment|/// Attributes for these StratifiedSets.
name|AliasAttrs
name|Attrs
decl_stmt|;
name|StratifiedLink
argument_list|()
operator|:
name|Above
argument_list|(
name|SetSentinel
argument_list|)
operator|,
name|Below
argument_list|(
argument|SetSentinel
argument_list|)
block|{}
name|bool
name|hasBelow
argument_list|()
specifier|const
block|{
return|return
name|Below
operator|!=
name|SetSentinel
return|;
block|}
name|bool
name|hasAbove
argument_list|()
specifier|const
block|{
return|return
name|Above
operator|!=
name|SetSentinel
return|;
block|}
name|void
name|clearBelow
parameter_list|()
block|{
name|Below
operator|=
name|SetSentinel
expr_stmt|;
block|}
name|void
name|clearAbove
parameter_list|()
block|{
name|Above
operator|=
name|SetSentinel
expr_stmt|;
block|}
block|}
struct|;
comment|/// \brief These are stratified sets, as described in "Fast algorithms for
comment|/// Dyck-CFL-reachability with applications to Alias Analysis" by Zhang Q, Lyu M
comment|/// R, Yuan H, and Su Z. -- in short, this is meant to represent different sets
comment|/// of Value*s. If two Value*s are in the same set, or if both sets have
comment|/// overlapping attributes, then the Value*s are said to alias.
comment|///
comment|/// Sets may be related by position, meaning that one set may be considered as
comment|/// above or below another. In CFL Alias Analysis, this gives us an indication
comment|/// of how two variables are related; if the set of variable A is below a set
comment|/// containing variable B, then at some point, a variable that has interacted
comment|/// with B (or B itself) was either used in order to extract the variable A, or
comment|/// was used as storage of variable A.
comment|///
comment|/// Sets may also have attributes (as noted above). These attributes are
comment|/// generally used for noting whether a variable in the set has interacted with
comment|/// a variable whose origins we don't quite know (i.e. globals/arguments), or if
comment|/// the variable may have had operations performed on it (modified in a function
comment|/// call). All attributes that exist in a set A must exist in all sets marked as
comment|/// below set A.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|StratifiedSets
block|{
name|public
operator|:
name|StratifiedSets
argument_list|()
operator|=
expr|default
block|;
name|StratifiedSets
argument_list|(
name|StratifiedSets
operator|&&
argument_list|)
operator|=
expr|default
block|;
name|StratifiedSets
operator|&
name|operator
operator|=
operator|(
name|StratifiedSets
operator|&&
operator|)
operator|=
expr|default
block|;
name|StratifiedSets
argument_list|(
name|DenseMap
operator|<
name|T
argument_list|,
name|StratifiedInfo
operator|>
name|Map
argument_list|,
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|Links
argument_list|)
operator|:
name|Values
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Map
argument_list|)
argument_list|)
block|,
name|Links
argument_list|(
argument|std::move(Links)
argument_list|)
block|{}
name|Optional
operator|<
name|StratifiedInfo
operator|>
name|find
argument_list|(
argument|const T&Elem
argument_list|)
specifier|const
block|{
name|auto
name|Iter
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Elem
argument_list|)
block|;
if|if
condition|(
name|Iter
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
return|return
name|None
return|;
return|return
name|Iter
operator|->
name|second
return|;
block|}
specifier|const
name|StratifiedLink
modifier|&
name|getLink
argument_list|(
name|StratifiedIndex
name|Index
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Links
index|[
name|Index
index|]
return|;
block|}
name|private
label|:
name|DenseMap
operator|<
name|T
operator|,
name|StratifiedInfo
operator|>
name|Values
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|Links
expr_stmt|;
name|bool
name|inbounds
argument_list|(
name|StratifiedIndex
name|Idx
argument_list|)
decl|const
block|{
return|return
name|Idx
operator|<
name|Links
operator|.
name|size
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/// Generic Builder class that produces StratifiedSets instances.
comment|///
comment|/// The goal of this builder is to efficiently produce correct StratifiedSets
comment|/// instances. To this end, we use a few tricks:
comment|///> Set chains (A method for linking sets together)
comment|///> Set remaps (A method for marking a set as an alias [irony?] of another)
comment|///
comment|/// ==== Set chains ====
comment|/// This builder has a notion of some value A being above, below, or with some
comment|/// other value B:
comment|///> The `A above B` relationship implies that there is a reference edge
comment|///   going from A to B. Namely, it notes that A can store anything in B's set.
comment|///> The `A below B` relationship is the opposite of `A above B`. It implies
comment|///   that there's a dereference edge going from A to B.
comment|///> The `A with B` relationship states that there's an assignment edge going
comment|///   from A to B, and that A and B should be treated as equals.
comment|///
comment|/// As an example, take the following code snippet:
comment|///
comment|/// %a = alloca i32, align 4
comment|/// %ap = alloca i32*, align 8
comment|/// %app = alloca i32**, align 8
comment|/// store %a, %ap
comment|/// store %ap, %app
comment|/// %aw = getelementptr %ap, i32 0
comment|///
comment|/// Given this, the following relations exist:
comment|///   - %a below %ap& %ap above %a
comment|///   - %ap below %app& %app above %ap
comment|///   - %aw with %ap& %ap with %aw
comment|///
comment|/// These relations produce the following sets:
comment|///   [{%a}, {%ap, %aw}, {%app}]
comment|///
comment|/// ...Which state that the only MayAlias relationship in the above program is
comment|/// between %ap and %aw.
comment|///
comment|/// Because LLVM allows arbitrary casts, code like the following needs to be
comment|/// supported:
comment|///   %ip = alloca i64, align 8
comment|///   %ipp = alloca i64*, align 8
comment|///   %i = bitcast i64** ipp to i64
comment|///   store i64* %ip, i64** %ipp
comment|///   store i64 %i, i64* %ip
comment|///
comment|/// Which, because %ipp ends up *both* above and below %ip, is fun.
comment|///
comment|/// This is solved by merging %i and %ipp into a single set (...which is the
comment|/// only way to solve this, since their bit patterns are equivalent). Any sets
comment|/// that ended up in between %i and %ipp at the time of merging (in this case,
comment|/// the set containing %ip) also get conservatively merged into the set of %i
comment|/// and %ipp. In short, the resulting StratifiedSet from the above code would be
comment|/// {%ip, %ipp, %i}.
comment|///
comment|/// ==== Set remaps ====
comment|/// More of an implementation detail than anything -- when merging sets, we need
comment|/// to update the numbers of all of the elements mapped to those sets. Rather
comment|/// than doing this at each merge, we note in the BuilderLink structure that a
comment|/// remap has occurred, and use this information so we can defer renumbering set
comment|/// elements until build time.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|StratifiedSetsBuilder
block|{
comment|/// \brief Represents a Stratified Set, with information about the Stratified
comment|/// Set above it, the set below it, and whether the current set has been
comment|/// remapped to another.
block|struct
name|BuilderLink
block|{
specifier|const
name|StratifiedIndex
name|Number
block|;
name|BuilderLink
argument_list|(
argument|StratifiedIndex N
argument_list|)
operator|:
name|Number
argument_list|(
argument|N
argument_list|)
block|{
name|Remap
operator|=
name|StratifiedLink
operator|::
name|SetSentinel
block|;     }
name|bool
name|hasAbove
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|hasAbove
argument_list|()
return|;
block|}
name|bool
name|hasBelow
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|hasBelow
argument_list|()
return|;
block|}
name|void
name|setBelow
argument_list|(
argument|StratifiedIndex I
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Below
operator|=
name|I
block|;     }
name|void
name|setAbove
argument_list|(
argument|StratifiedIndex I
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Above
operator|=
name|I
block|;     }
name|void
name|clearBelow
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|clearBelow
argument_list|()
block|;     }
name|void
name|clearAbove
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|clearAbove
argument_list|()
block|;     }
name|StratifiedIndex
name|getBelow
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|hasBelow
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Below
return|;
block|}
name|StratifiedIndex
name|getAbove
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|hasAbove
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Above
return|;
block|}
name|AliasAttrs
name|getAttrs
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Link
operator|.
name|Attrs
return|;
block|}
name|void
name|setAttrs
argument_list|(
argument|AliasAttrs Other
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Link
operator|.
name|Attrs
operator||=
name|Other
block|;     }
name|bool
name|isRemapped
argument_list|()
specifier|const
block|{
return|return
name|Remap
operator|!=
name|StratifiedLink
operator|::
name|SetSentinel
return|;
block|}
comment|/// For initial remapping to another set
name|void
name|remapTo
argument_list|(
argument|StratifiedIndex Other
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Remap
operator|=
name|Other
block|;     }
name|StratifiedIndex
name|getRemapIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isRemapped
argument_list|()
argument_list|)
block|;
return|return
name|Remap
return|;
block|}
comment|/// Should only be called when we're already remapped.
name|void
name|updateRemap
argument_list|(
argument|StratifiedIndex Other
argument_list|)
block|{
name|assert
argument_list|(
name|isRemapped
argument_list|()
argument_list|)
block|;
name|Remap
operator|=
name|Other
block|;     }
comment|/// Prefer the above functions to calling things directly on what's returned
comment|/// from this -- they guard against unexpected calls when the current
comment|/// BuilderLink is remapped.
specifier|const
name|StratifiedLink
operator|&
name|getLink
argument_list|()
specifier|const
block|{
return|return
name|Link
return|;
block|}
name|private
operator|:
name|StratifiedLink
name|Link
block|;
name|StratifiedIndex
name|Remap
block|;   }
block|;
comment|/// \brief This function performs all of the set unioning/value renumbering
comment|/// that we've been putting off, and generates a vector<StratifiedLink> that
comment|/// may be placed in a StratifiedSets instance.
name|void
name|finalizeSets
argument_list|(
argument|std::vector<StratifiedLink>&StratLinks
argument_list|)
block|{
name|DenseMap
operator|<
name|StratifiedIndex
block|,
name|StratifiedIndex
operator|>
name|Remaps
block|;
for|for
control|(
name|auto
operator|&
name|Link
operator|:
name|Links
control|)
block|{
if|if
condition|(
name|Link
operator|.
name|isRemapped
argument_list|()
condition|)
continue|continue;
name|StratifiedIndex
name|Number
init|=
name|StratLinks
operator|.
name|size
argument_list|()
decl_stmt|;
name|Remaps
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Link
operator|.
name|Number
argument_list|,
name|Number
argument_list|)
argument_list|)
expr_stmt|;
name|StratLinks
operator|.
name|push_back
argument_list|(
name|Link
operator|.
name|getLink
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
operator|&
name|Link
operator|:
name|StratLinks
control|)
block|{
if|if
condition|(
name|Link
operator|.
name|hasAbove
argument_list|()
condition|)
block|{
name|auto
operator|&
name|Above
operator|=
name|linksAt
argument_list|(
name|Link
operator|.
name|Above
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Above
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Link
operator|.
name|Above
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
if|if
condition|(
name|Link
operator|.
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
operator|&
name|Below
operator|=
name|linksAt
argument_list|(
name|Link
operator|.
name|Below
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Below
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Link
operator|.
name|Below
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
block|}
for|for
control|(
name|auto
operator|&
name|Pair
operator|:
name|Values
control|)
block|{
name|auto
operator|&
name|Info
operator|=
name|Pair
operator|.
name|second
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|.
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Iter
init|=
name|Remaps
operator|.
name|find
argument_list|(
name|Link
operator|.
name|Number
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Iter
operator|!=
name|Remaps
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Info
operator|.
name|Index
operator|=
name|Iter
operator|->
name|second
expr_stmt|;
block|}
block|}
comment|/// \brief There's a guarantee in StratifiedLink where all bits set in a
comment|/// Link.externals will be set in all Link.externals "below" it.
specifier|static
name|void
name|propagateAttrs
argument_list|(
argument|std::vector<StratifiedLink>&Links
argument_list|)
block|{
specifier|const
name|auto
name|getHighestParentAbove
operator|=
index|[
operator|&
name|Links
index|]
operator|(
name|StratifiedIndex
name|Idx
operator|)
block|{
specifier|const
name|auto
operator|*
name|Link
operator|=
operator|&
name|Links
index|[
name|Idx
index|]
block|;
while|while
condition|(
name|Link
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|Idx
operator|=
name|Link
operator|->
name|Above
expr_stmt|;
name|Link
operator|=
operator|&
name|Links
index|[
name|Idx
index|]
expr_stmt|;
block|}
return|return
name|Idx
return|;
block|}
block|;
name|SmallSet
operator|<
name|StratifiedIndex
block|,
literal|16
operator|>
name|Visited
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|Links
operator|.
name|size
argument_list|()
init|;
name|I
operator|<
name|E
condition|;
operator|++
name|I
control|)
block|{
name|auto
name|CurrentIndex
init|=
name|getHighestParentAbove
argument_list|(
name|I
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Visited
operator|.
name|insert
argument_list|(
name|CurrentIndex
argument_list|)
operator|.
name|second
condition|)
continue|continue;
while|while
condition|(
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
operator|&
name|CurrentBits
operator|=
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|Attrs
expr_stmt|;
name|auto
name|NextIndex
init|=
name|Links
index|[
name|CurrentIndex
index|]
operator|.
name|Below
decl_stmt|;
name|auto
operator|&
name|NextBits
operator|=
name|Links
index|[
name|NextIndex
index|]
operator|.
name|Attrs
expr_stmt|;
name|NextBits
operator||=
name|CurrentBits
expr_stmt|;
name|CurrentIndex
operator|=
name|NextIndex
expr_stmt|;
block|}
block|}
block|}
name|public
operator|:
comment|/// Builds a StratifiedSet from the information we've been given since either
comment|/// construction or the prior build() call.
name|StratifiedSets
operator|<
name|T
operator|>
name|build
argument_list|()
block|{
name|std
operator|::
name|vector
operator|<
name|StratifiedLink
operator|>
name|StratLinks
block|;
name|finalizeSets
argument_list|(
name|StratLinks
argument_list|)
block|;
name|propagateAttrs
argument_list|(
name|StratLinks
argument_list|)
block|;
name|Links
operator|.
name|clear
argument_list|()
block|;
return|return
name|StratifiedSets
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Values
argument_list|)
operator|,
name|std
operator|::
name|move
argument_list|(
name|StratLinks
argument_list|)
operator|)
return|;
block|}
name|bool
name|has
argument_list|(
argument|const T&Elem
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Elem
argument_list|)
operator|.
name|hasValue
argument_list|()
return|;
block|}
name|bool
name|add
argument_list|(
argument|const T&Main
argument_list|)
block|{
if|if
condition|(
name|get
argument_list|(
name|Main
argument_list|)
operator|.
name|hasValue
argument_list|()
condition|)
return|return
name|false
return|;
name|auto
name|NewIndex
operator|=
name|getNewUnlinkedIndex
argument_list|()
block|;
return|return
name|addAtMerging
argument_list|(
name|Main
argument_list|,
name|NewIndex
argument_list|)
return|;
block|}
comment|/// \brief Restructures the stratified sets as necessary to make "ToAdd" in a
comment|/// set above "Main". There are some cases where this is not possible (see
comment|/// above), so we merge them such that ToAdd and Main are in the same set.
name|bool
name|addAbove
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
name|Index
init|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|hasAbove
argument_list|()
condition|)
name|addLinkAbove
argument_list|(
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Above
init|=
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|getAbove
argument_list|()
decl_stmt|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|Above
argument_list|)
return|;
block|}
comment|/// \brief Restructures the stratified sets as necessary to make "ToAdd" in a
comment|/// set below "Main". There are some cases where this is not possible (see
comment|/// above), so we merge them such that ToAdd and Main are in the same set.
name|bool
name|addBelow
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
name|Index
init|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|hasBelow
argument_list|()
condition|)
name|addLinkBelow
argument_list|(
name|Index
argument_list|)
expr_stmt|;
name|auto
name|Below
init|=
name|linksAt
argument_list|(
name|Index
argument_list|)
operator|.
name|getBelow
argument_list|()
decl_stmt|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|Below
argument_list|)
return|;
block|}
name|bool
name|addWith
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
name|MainIndex
init|=
operator|*
name|indexOf
argument_list|(
name|Main
argument_list|)
decl_stmt|;
return|return
name|addAtMerging
argument_list|(
name|ToAdd
argument_list|,
name|MainIndex
argument_list|)
return|;
block|}
name|void
name|noteAttributes
parameter_list|(
specifier|const
name|T
modifier|&
name|Main
parameter_list|,
name|AliasAttrs
name|NewAttrs
parameter_list|)
block|{
name|assert
argument_list|(
name|has
argument_list|(
name|Main
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|get
argument_list|(
name|Main
argument_list|)
expr_stmt|;
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
name|Link
operator|.
name|setAttrs
argument_list|(
name|NewAttrs
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|DenseMap
operator|<
name|T
operator|,
name|StratifiedInfo
operator|>
name|Values
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BuilderLink
operator|>
name|Links
expr_stmt|;
comment|/// Adds the given element at the given index, merging sets if necessary.
name|bool
name|addAtMerging
parameter_list|(
specifier|const
name|T
modifier|&
name|ToAdd
parameter_list|,
name|StratifiedIndex
name|Index
parameter_list|)
block|{
name|StratifiedInfo
name|Info
init|=
block|{
name|Index
block|}
decl_stmt|;
name|auto
name|Pair
init|=
name|Values
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ToAdd
argument_list|,
name|Info
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Pair
operator|.
name|second
condition|)
return|return
name|true
return|;
name|auto
operator|&
name|Iter
operator|=
name|Pair
operator|.
name|first
expr_stmt|;
name|auto
operator|&
name|IterSet
operator|=
name|linksAt
argument_list|(
name|Iter
operator|->
name|second
operator|.
name|Index
argument_list|)
expr_stmt|;
name|auto
operator|&
name|ReqSet
operator|=
name|linksAt
argument_list|(
name|Index
argument_list|)
expr_stmt|;
comment|// Failed to add where we wanted to. Merge the sets.
if|if
condition|(
operator|&
name|IterSet
operator|!=
operator|&
name|ReqSet
condition|)
name|merge
argument_list|(
name|IterSet
operator|.
name|Number
argument_list|,
name|ReqSet
operator|.
name|Number
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// Gets the BuilderLink at the given index, taking set remapping into
comment|/// account.
name|BuilderLink
modifier|&
name|linksAt
parameter_list|(
name|StratifiedIndex
name|Index
parameter_list|)
block|{
name|auto
operator|*
name|Start
operator|=
operator|&
name|Links
index|[
name|Index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Start
operator|->
name|isRemapped
argument_list|()
condition|)
return|return
operator|*
name|Start
return|;
name|auto
operator|*
name|Current
operator|=
name|Start
expr_stmt|;
while|while
condition|(
name|Current
operator|->
name|isRemapped
argument_list|()
condition|)
name|Current
operator|=
operator|&
name|Links
index|[
name|Current
operator|->
name|getRemapIndex
argument_list|()
index|]
expr_stmt|;
name|auto
name|NewRemap
init|=
name|Current
operator|->
name|Number
decl_stmt|;
comment|// Run through everything that has yet to be updated, and update them to
comment|// remap to NewRemap
name|Current
operator|=
name|Start
expr_stmt|;
while|while
condition|(
name|Current
operator|->
name|isRemapped
argument_list|()
condition|)
block|{
name|auto
operator|*
name|Next
operator|=
operator|&
name|Links
index|[
name|Current
operator|->
name|getRemapIndex
argument_list|()
index|]
expr_stmt|;
name|Current
operator|->
name|updateRemap
argument_list|(
name|NewRemap
argument_list|)
expr_stmt|;
name|Current
operator|=
name|Next
expr_stmt|;
block|}
return|return
operator|*
name|Current
return|;
block|}
comment|/// \brief Merges two sets into one another. Assumes that these sets are not
comment|/// already one in the same.
name|void
name|merge
parameter_list|(
name|StratifiedIndex
name|Idx1
parameter_list|,
name|StratifiedIndex
name|Idx2
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Idx1
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|Idx2
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|&
name|linksAt
argument_list|(
name|Idx1
argument_list|)
operator|!=
operator|&
name|linksAt
argument_list|(
name|Idx2
argument_list|)
operator|&&
literal|"Merging a set into itself is not allowed"
argument_list|)
expr_stmt|;
comment|// CASE 1: If the set at `Idx1` is above or below `Idx2`, we need to merge
comment|// both the
comment|// given sets, and all sets between them, into one.
if|if
condition|(
name|tryMergeUpwards
argument_list|(
name|Idx1
argument_list|,
name|Idx2
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tryMergeUpwards
argument_list|(
name|Idx2
argument_list|,
name|Idx1
argument_list|)
condition|)
return|return;
comment|// CASE 2: The set at `Idx1` is not in the same chain as the set at `Idx2`.
comment|// We therefore need to merge the two chains together.
name|mergeDirect
argument_list|(
name|Idx1
argument_list|,
name|Idx2
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Merges two sets assuming that the set at `Idx1` is unreachable from
comment|/// traversing above or below the set at `Idx2`.
name|void
name|mergeDirect
parameter_list|(
name|StratifiedIndex
name|Idx1
parameter_list|,
name|StratifiedIndex
name|Idx2
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|Idx1
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|Idx2
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|Idx1
argument_list|)
expr_stmt|;
name|auto
operator|*
name|LinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|Idx2
argument_list|)
expr_stmt|;
comment|// Merging everything above LinksInto then proceeding to merge everything
comment|// below LinksInto becomes problematic, so we go as far "up" as possible!
while|while
condition|(
name|LinksInto
operator|->
name|hasAbove
argument_list|()
operator|&&
name|LinksFrom
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|LinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksFrom
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LinksFrom
operator|->
name|hasAbove
argument_list|()
condition|)
block|{
name|LinksInto
operator|->
name|setAbove
argument_list|(
name|LinksFrom
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewAbove
operator|=
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
name|NewAbove
operator|.
name|setBelow
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
comment|// Merging strategy:
comment|//> If neither has links below, stop.
comment|//> If only `LinksInto` has links below, stop.
comment|//> If only `LinksFrom` has links below, reset `LinksInto.Below` to
comment|//  match `LinksFrom.Below`
comment|//> If both have links above, deal with those next.
while|while
condition|(
name|LinksInto
operator|->
name|hasBelow
argument_list|()
operator|&&
name|LinksFrom
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
name|FromAttrs
init|=
name|LinksFrom
operator|->
name|getAttrs
argument_list|()
decl_stmt|;
name|LinksInto
operator|->
name|setAttrs
argument_list|(
name|FromAttrs
argument_list|)
expr_stmt|;
comment|// Remap needs to happen after getBelow(), but before
comment|// assignment of LinksFrom
name|auto
operator|*
name|NewLinksFrom
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksFrom
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|LinksFrom
operator|->
name|remapTo
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
name|LinksFrom
operator|=
name|NewLinksFrom
expr_stmt|;
name|LinksInto
operator|=
operator|&
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LinksFrom
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|LinksInto
operator|->
name|setBelow
argument_list|(
name|LinksFrom
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewBelow
operator|=
name|linksAt
argument_list|(
name|LinksInto
operator|->
name|getBelow
argument_list|()
argument_list|)
expr_stmt|;
name|NewBelow
operator|.
name|setAbove
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
name|LinksInto
operator|->
name|setAttrs
argument_list|(
name|LinksFrom
operator|->
name|getAttrs
argument_list|()
argument_list|)
expr_stmt|;
name|LinksFrom
operator|->
name|remapTo
argument_list|(
name|LinksInto
operator|->
name|Number
argument_list|)
expr_stmt|;
block|}
comment|/// Checks to see if lowerIndex is at a level lower than upperIndex. If so, it
comment|/// will merge lowerIndex with upperIndex (and all of the sets between) and
comment|/// return true. Otherwise, it will return false.
name|bool
name|tryMergeUpwards
parameter_list|(
name|StratifiedIndex
name|LowerIndex
parameter_list|,
name|StratifiedIndex
name|UpperIndex
parameter_list|)
block|{
name|assert
argument_list|(
name|inbounds
argument_list|(
name|LowerIndex
argument_list|)
operator|&&
name|inbounds
argument_list|(
name|UpperIndex
argument_list|)
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Lower
operator|=
operator|&
name|linksAt
argument_list|(
name|LowerIndex
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Upper
operator|=
operator|&
name|linksAt
argument_list|(
name|UpperIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lower
operator|==
name|Upper
condition|)
return|return
name|true
return|;
name|SmallVector
operator|<
name|BuilderLink
operator|*
operator|,
literal|8
operator|>
name|Found
expr_stmt|;
name|auto
operator|*
name|Current
operator|=
name|Lower
expr_stmt|;
name|auto
name|Attrs
init|=
name|Current
operator|->
name|getAttrs
argument_list|()
decl_stmt|;
while|while
condition|(
name|Current
operator|->
name|hasAbove
argument_list|()
operator|&&
name|Current
operator|!=
name|Upper
condition|)
block|{
name|Found
operator|.
name|push_back
argument_list|(
name|Current
argument_list|)
expr_stmt|;
name|Attrs
operator||=
name|Current
operator|->
name|getAttrs
argument_list|()
expr_stmt|;
name|Current
operator|=
operator|&
name|linksAt
argument_list|(
name|Current
operator|->
name|getAbove
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Current
operator|!=
name|Upper
condition|)
return|return
name|false
return|;
name|Upper
operator|->
name|setAttrs
argument_list|(
name|Attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lower
operator|->
name|hasBelow
argument_list|()
condition|)
block|{
name|auto
name|NewBelowIndex
init|=
name|Lower
operator|->
name|getBelow
argument_list|()
decl_stmt|;
name|Upper
operator|->
name|setBelow
argument_list|(
name|NewBelowIndex
argument_list|)
expr_stmt|;
name|auto
operator|&
name|NewBelow
operator|=
name|linksAt
argument_list|(
name|NewBelowIndex
argument_list|)
expr_stmt|;
name|NewBelow
operator|.
name|setAbove
argument_list|(
name|UpperIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Upper
operator|->
name|clearBelow
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Ptr
range|:
name|Found
control|)
name|Ptr
operator|->
name|remapTo
argument_list|(
name|Upper
operator|->
name|Number
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|Optional
operator|<
specifier|const
name|StratifiedInfo
operator|*
operator|>
name|get
argument_list|(
argument|const T&Val
argument_list|)
specifier|const
block|{
name|auto
name|Result
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
name|Result
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
return|return
name|None
return|;
return|return
operator|&
name|Result
operator|->
name|second
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|StratifiedInfo
operator|*
operator|>
name|get
argument_list|(
argument|const T&Val
argument_list|)
block|{
name|auto
name|Result
operator|=
name|Values
operator|.
name|find
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
name|Result
operator|==
name|Values
operator|.
name|end
argument_list|()
condition|)
return|return
name|None
return|;
end_expr_stmt

begin_return
return|return
operator|&
name|Result
operator|->
name|second
return|;
end_return

begin_expr_stmt
unit|}    Optional
operator|<
name|StratifiedIndex
operator|>
name|indexOf
argument_list|(
argument|const T&Val
argument_list|)
block|{
name|auto
name|MaybeVal
operator|=
name|get
argument_list|(
name|Val
argument_list|)
block|;
if|if
condition|(
operator|!
name|MaybeVal
operator|.
name|hasValue
argument_list|()
condition|)
return|return
name|None
return|;
name|auto
operator|*
name|Info
operator|=
operator|*
name|MaybeVal
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|auto
operator|&
name|Link
operator|=
name|linksAt
argument_list|(
name|Info
operator|->
name|Index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Link
operator|.
name|Number
return|;
end_return

begin_macro
unit|}    StratifiedIndex
name|addLinkBelow
argument_list|(
argument|StratifiedIndex Set
argument_list|)
end_macro

begin_block
block|{
name|auto
name|At
init|=
name|addLinks
argument_list|()
decl_stmt|;
name|Links
index|[
name|Set
index|]
operator|.
name|setBelow
argument_list|(
name|At
argument_list|)
expr_stmt|;
name|Links
index|[
name|At
index|]
operator|.
name|setAbove
argument_list|(
name|Set
argument_list|)
expr_stmt|;
return|return
name|At
return|;
block|}
end_block

begin_function
name|StratifiedIndex
name|addLinkAbove
parameter_list|(
name|StratifiedIndex
name|Set
parameter_list|)
block|{
name|auto
name|At
init|=
name|addLinks
argument_list|()
decl_stmt|;
name|Links
index|[
name|At
index|]
operator|.
name|setBelow
argument_list|(
name|Set
argument_list|)
expr_stmt|;
name|Links
index|[
name|Set
index|]
operator|.
name|setAbove
argument_list|(
name|At
argument_list|)
expr_stmt|;
return|return
name|At
return|;
block|}
end_function

begin_function
name|StratifiedIndex
name|getNewUnlinkedIndex
parameter_list|()
block|{
return|return
name|addLinks
argument_list|()
return|;
block|}
end_function

begin_function
name|StratifiedIndex
name|addLinks
parameter_list|()
block|{
name|auto
name|Link
init|=
name|Links
operator|.
name|size
argument_list|()
decl_stmt|;
name|Links
operator|.
name|push_back
argument_list|(
name|BuilderLink
argument_list|(
name|Link
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Link
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|inbounds
argument_list|(
name|StratifiedIndex
name|N
argument_list|)
decl|const
block|{
return|return
name|N
operator|<
name|Links
operator|.
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_endif
unit|}; } }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_STRATIFIEDSETS_H
end_comment

end_unit

