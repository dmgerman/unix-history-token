begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SmallVector class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SMALLVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SMALLVECTOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// SmallVectorBase - This is all the non-templated stuff common to all
comment|/// SmallVectors.
name|class
name|SmallVectorBase
block|{
name|protected
label|:
name|void
modifier|*
name|BeginX
decl_stmt|,
modifier|*
name|EndX
decl_stmt|,
modifier|*
name|CapacityX
decl_stmt|;
name|protected
label|:
name|SmallVectorBase
argument_list|(
argument|void *FirstEl
argument_list|,
argument|size_t Size
argument_list|)
block|:
name|BeginX
argument_list|(
name|FirstEl
argument_list|)
operator|,
name|EndX
argument_list|(
name|FirstEl
argument_list|)
operator|,
name|CapacityX
argument_list|(
argument|(char*)FirstEl+Size
argument_list|)
block|{}
comment|/// grow_pod - This is an implementation of the grow() method which only works
comment|/// on POD-like data types and is out of line to reduce code duplication.
name|void
name|grow_pod
argument_list|(
argument|void *FirstEl
argument_list|,
argument|size_t MinSizeInBytes
argument_list|,
argument|size_t TSize
argument_list|)
expr_stmt|;
name|public
label|:
comment|/// size_in_bytes - This returns size()*sizeof(T).
name|size_t
name|size_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EndX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
comment|/// capacity_in_bytes - This returns capacity()*sizeof(T).
name|size_t
name|capacity_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CapacityX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
name|bool
name|LLVM_ATTRIBUTE_UNUSED_RESULT
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|EndX
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
expr|struct
name|SmallVectorStorage
expr_stmt|;
comment|/// SmallVectorTemplateCommon - This is the part of SmallVectorTemplateBase
comment|/// which does not depend on whether the type T is a POD. The extra dummy
comment|/// template argument is used by ArrayRef to avoid unnecessarily requiring T
comment|/// to be complete.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|=
name|void
operator|>
name|class
name|SmallVectorTemplateCommon
operator|:
name|public
name|SmallVectorBase
block|{
name|private
operator|:
name|template
operator|<
name|typename
block|,
name|unsigned
operator|>
name|friend
expr|struct
name|SmallVectorStorage
block|;
comment|// Allocate raw space for N elements of type T.  If T has a ctor or dtor, we
comment|// don't want it to be automatically run, so we need to represent the space as
comment|// something else.  Use an array of char of sufficient alignment.
typedef|typedef
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
name|T
operator|>
name|U
expr_stmt|;
name|U
name|FirstEl
expr_stmt|;
comment|// Space after 'FirstEl' is clobbered, do not add any instance vars after it.
name|protected
label|:
name|SmallVectorTemplateCommon
argument_list|(
argument|size_t Size
argument_list|)
block|:
name|SmallVectorBase
argument_list|(
argument|&FirstEl
argument_list|,
argument|Size
argument_list|)
block|{}
name|void
name|grow_pod
parameter_list|(
name|size_t
name|MinSizeInBytes
parameter_list|,
name|size_t
name|TSize
parameter_list|)
block|{
name|SmallVectorBase
operator|::
name|grow_pod
argument_list|(
operator|&
name|FirstEl
argument_list|,
name|MinSizeInBytes
argument_list|,
name|TSize
argument_list|)
expr_stmt|;
block|}
comment|/// isSmall - Return true if this is a smallvector which has not had dynamic
comment|/// memory allocated for it.
name|bool
name|isSmall
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
return|;
block|}
comment|/// resetToSmall - Put this vector in a state of being small.
name|void
name|resetToSmall
parameter_list|()
block|{
name|BeginX
operator|=
name|EndX
operator|=
name|CapacityX
operator|=
operator|&
name|FirstEl
expr_stmt|;
block|}
name|void
name|setEnd
parameter_list|(
name|T
modifier|*
name|P
parameter_list|)
block|{
name|this
operator|->
name|EndX
operator|=
name|P
expr_stmt|;
block|}
name|public
label|:
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_iterator
typedef|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
comment|// forward iterator creation methods.
name|iterator
name|begin
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|protected
label|:
name|iterator
name|capacity_ptr
parameter_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|const_iterator
name|capacity_ptr
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|public
label|:
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|/// capacity - Return the total number of elements in the currently allocated
comment|/// buffer.
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|capacity_ptr
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|pointer
name|data
parameter_list|()
block|{
return|return
name|pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|begin
argument_list|()
operator|+
name|idx
operator|<
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|const_reference
name|operator
index|[]
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|begin
argument_list|()
operator|+
name|idx
operator|<
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// SmallVectorTemplateBase<isPodLike = false> - This is where we put method
end_comment

begin_comment
comment|/// implementations that are designed to work with non-POD-like T's.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|isPodLike
operator|>
name|class
name|SmallVectorTemplateBase
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|protected
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *S
argument_list|,
argument|T *E
argument_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// move - Use move-assignment to move the range [I, E) onto the
comment|/// objects starting with "Dest".  This is just<memory>'s
comment|/// std::move, but not all stdlibs actually provide that.
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|It2
name|move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|++
name|Dest
control|)
operator|*
name|Dest
operator|=
operator|::
name|std
operator|::
name|move
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Dest
return|;
end_return

begin_else
else|#
directive|else
end_else

begin_return
return|return
operator|::
name|std
operator|::
name|copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/// move_backward - Use move-assignment to move the range
end_comment

begin_comment
comment|/// [I, E) onto the objects ending at "Dest", moving objects
end_comment

begin_comment
comment|/// in reverse order.  This is just<algorithm>'s
end_comment

begin_comment
comment|/// std::move_backward, but not all stdlibs actually provide that.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|It2
name|move_backward
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
while|while
condition|(
name|I
operator|!=
name|E
condition|)
operator|*
operator|--
name|Dest
operator|=
operator|::
name|std
operator|::
name|move
argument_list|(
operator|*
operator|--
name|E
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Dest
return|;
end_return

begin_else
else|#
directive|else
end_else

begin_return
return|return
operator|::
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/// uninitialized_move - Move the range [I, E) into the uninitialized
end_comment

begin_comment
comment|/// memory starting with "Dest", constructing elements as needed.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|++
name|Dest
control|)
operator|::
name|new
argument_list|(
argument|(void*)&*Dest
argument_list|)
name|T
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|::
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized
end_comment

begin_comment
comment|/// memory starting with "Dest", constructing elements as needed.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// grow - Grow the allocated memory (without initializing new
comment|/// elements), doubling the size of the allocated memory.
comment|/// Guarantees space for at least one more element, or MinSize more
comment|/// elements if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function
name|void
name|push_back
parameter_list|(
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_function

begin_if
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_decl_stmt
name|void
name|push_back
argument_list|(
name|T
operator|&&
name|Elt
argument_list|)
block|{
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|Elt
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pop_back
parameter_list|()
block|{
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|->
name|end
argument_list|()
operator|->
operator|~
name|T
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|isPodLike
operator|>
name|void
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|>
operator|::
name|grow
argument_list|(
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|this
operator|->
name|capacity
argument_list|()
block|;
name|size_t
name|CurSize
operator|=
name|this
operator|->
name|size
argument_list|()
block|;
comment|// Always grow, even from zero.
name|size_t
name|NewCapacity
operator|=
name|size_t
argument_list|(
name|NextPowerOf2
argument_list|(
name|CurCapacity
operator|+
literal|2
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
name|T
operator|*
name|NewElts
operator|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|malloc
argument_list|(
name|NewCapacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Move the elements over.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Destroy the original elements.
end_comment

begin_expr_stmt
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If this wasn't grown from the inline copy, deallocate the old space.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|NewElts
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|BeginX
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|CapacityX
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NewCapacity
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// SmallVectorTemplateBase<isPodLike = true> - This is where we put method
end_comment

begin_comment
comment|/// implementations that are designed to work with POD-like T's.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|true
operator|>
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|protected
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
comment|// No need to do a destroy loop for POD's.
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *
argument_list|,
argument|T *
argument_list|)
block|{}
comment|/// move - Use move-assignment to move the range [I, E) onto the
comment|/// objects starting with "Dest".  For PODs, this is just memcpy.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|It2
name|move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
return|return
operator|::
name|std
operator|::
name|copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
return|;
block|}
comment|/// move_backward - Use move-assignment to move the range
comment|/// [I, E) onto the objects ending at "Dest", moving objects
comment|/// in reverse order.
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|It2
name|move_backward
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
return|return
operator|::
name|std
operator|::
name|copy_backward
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// uninitialized_move - Move the range [I, E) onto the uninitialized memory
end_comment

begin_comment
comment|/// starting with "Dest", constructing elements into it as needed.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
comment|// Just do a copy.
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|It1
operator|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
comment|// Arbitrary iterator types; just use the basic implementation.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|T1 *I
argument_list|,
argument|T1 *E
argument_list|,
argument|T2 *Dest
argument_list|)
block|{
comment|// Use memcpy for PODs iterated by pointers (which includes SmallVector
comment|// iterators): std::uninitialized_copy optimizes to memmove, but we can
comment|// use memcpy here.
name|memcpy
argument_list|(
name|Dest
argument_list|,
name|I
argument_list|,
operator|(
name|E
operator|-
name|I
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
comment|/// least one more element or MinSize if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
block|{
name|this
operator|->
name|grow_pod
argument_list|(
name|MinSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
name|void
name|push_back
argument_list|(
argument|const T&Elt
argument_list|)
block|{
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
name|memcpy
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
operator|&
name|Elt
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|Retry
goto|;
end_goto

begin_macro
unit|}      void
name|pop_back
argument_list|()
end_macro

begin_block
block|{
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
unit|};
comment|/// SmallVectorImpl - This class consists of common code factored out of the
end_comment

begin_comment
comment|/// SmallVector class to reduce code duplication based on the SmallVector 'N'
end_comment

begin_comment
comment|/// template parameter.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
operator|:
name|public
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{
typedef|typedef
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
name|SuperClass
expr_stmt|;
name|SmallVectorImpl
argument_list|(
argument|const SmallVectorImpl&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|typename
name|SuperClass
operator|::
name|iterator
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|SuperClass
operator|::
name|size_type
name|size_type
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_comment
comment|// Default ctor - Initialize to empty.
end_comment

begin_macro
name|explicit
end_macro

begin_macro
name|SmallVectorImpl
argument_list|(
argument|unsigned N
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
operator|(
name|N
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
block|{   }
name|public
operator|:
operator|~
name|SmallVectorImpl
argument_list|()
block|{
comment|// Destroy the constructed elements in the vector.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
block|;
comment|// If this wasn't grown from the inline copy, deallocate the old space.
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
name|void
name|clear
parameter_list|()
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|EndX
operator|=
name|this
operator|->
name|BeginX
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|std
operator|::
name|uninitialized_fill
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|T
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|,
specifier|const
name|T
modifier|&
name|NV
parameter_list|)
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|std
operator|::
name|uninitialized_fill
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|NV
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reserve
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|T
name|LLVM_ATTRIBUTE_UNUSED_RESULT
name|pop_back_val
parameter_list|()
block|{
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
name|T
name|Result
init|=
operator|::
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
decl_stmt|;
else|#
directive|else
name|T
name|Result
init|=
name|this
operator|->
name|back
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|this
operator|->
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_function_decl
name|void
name|swap
parameter_list|(
name|SmallVectorImpl
modifier|&
name|RHS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|append
argument_list|(
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|size_type
name|NumInputs
operator|=
name|std
operator|::
name|distance
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
comment|// TODO: NEED To compile time dispatch on whether in_iter is a random access
comment|// iterator to use the fast uninitialized_copy.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// append - Add the specified range to the end of the SmallVector.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|append
argument_list|(
argument|size_type NumInputs
argument_list|,
argument|const T&Elt
argument_list|)
end_macro

begin_block
block|{
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NumInputs
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|assign
parameter_list|(
name|unsigned
name|NumElts
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|NumElts
condition|)
name|this
operator|->
name|grow
argument_list|(
name|NumElts
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumElts
argument_list|)
expr_stmt|;
name|std
operator|::
name|uninitialized_fill
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Iterator to erase is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Erasing at past-the-end iterator."
argument_list|)
expr_stmt|;
name|iterator
name|N
init|=
name|I
decl_stmt|;
comment|// Shift all elts down one.
name|this
operator|->
name|move
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
comment|// Drop the last elt.
name|this
operator|->
name|pop_back
argument_list|()
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
name|iterator
name|S
parameter_list|,
name|iterator
name|E
parameter_list|)
block|{
name|assert
argument_list|(
name|S
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Range to erase is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|S
operator|<=
name|E
operator|&&
literal|"Trying to erase invalid range."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|E
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Trying to erase past the end."
argument_list|)
expr_stmt|;
name|iterator
name|N
init|=
name|S
decl_stmt|;
comment|// Shift all elts down.
name|iterator
name|I
init|=
name|this
operator|->
name|move
argument_list|(
name|E
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|S
argument_list|)
decl_stmt|;
comment|// Drop the last elts.
name|this
operator|->
name|destroy_range
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_decl_stmt
name|iterator
name|insert
argument_list|(
name|iterator
name|I
argument_list|,
name|T
operator|&&
name|Elt
argument_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|this
operator|->
name|push_back
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|Elt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|this
operator|->
name|move_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// If we just moved the element we're inserting, be sure to update
comment|// the reference.
name|T
modifier|*
name|EltPtr
init|=
operator|&
name|Elt
decl_stmt|;
if|if
condition|(
name|I
operator|<=
name|EltPtr
operator|&&
name|EltPtr
operator|<
name|this
operator|->
name|EndX
condition|)
operator|++
name|EltPtr
expr_stmt|;
operator|*
name|I
operator|=
operator|::
name|std
operator|::
name|move
argument_list|(
operator|*
name|EltPtr
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|this
operator|->
name|push_back
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|EndX
operator|<
name|this
operator|->
name|CapacityX
condition|)
block|{
name|Retry
label|:
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|this
operator|->
name|move_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// If we just moved the element we're inserting, be sure to update
comment|// the reference.
specifier|const
name|T
modifier|*
name|EltPtr
init|=
operator|&
name|Elt
decl_stmt|;
if|if
condition|(
name|I
operator|<=
name|EltPtr
operator|&&
name|EltPtr
operator|<
name|this
operator|->
name|EndX
condition|)
operator|++
name|EltPtr
expr_stmt|;
operator|*
name|I
operator|=
operator|*
name|EltPtr
expr_stmt|;
return|return
name|I
return|;
block|}
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
name|size_type
name|NumToInsert
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
comment|// Ensure there is enough space.
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
comment|// Uninvalidate the iterator.
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
comment|// If there are more elements between the insertion point and the end of the
comment|// range than there are being inserted, we can use a simple approach to
comment|// insertion.  Since we already reserved space, we know that this won't
comment|// reallocate the vector.
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|this
operator|->
name|move_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
comment|// Otherwise, we're inserting more elements than exist already, and we're
comment|// not inserting at the end.
comment|// Move over the elements that we're about to overwrite.
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
name|this
operator|->
name|uninitialized_move
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
comment|// Replace the overwritten part.
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
comment|// Insert the non-overwritten middle part.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|OldEnd
argument_list|,
name|NumToInsert
operator|-
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|ItTy From
argument_list|,
argument|ItTy To
argument_list|)
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
operator|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
block|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumToInsert
init|=
name|std
operator|::
name|distance
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Ensure there is enough space.
end_comment

begin_expr_stmt
name|reserve
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Uninvalidate the iterator.
end_comment

begin_expr_stmt
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If there are more elements between the insertion point and the end of the
end_comment

begin_comment
comment|// range than there are being inserted, we can use a simple approach to
end_comment

begin_comment
comment|// insertion.  Since we already reserved space, we know that this won't
end_comment

begin_comment
comment|// reallocate the vector.
end_comment

begin_if
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|this
operator|->
name|move_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|I
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_comment
comment|// Otherwise, we're inserting more elements than exist already, and we're
end_comment

begin_comment
comment|// not inserting at the end.
end_comment

begin_comment
comment|// Move over the elements that we're about to overwrite.
end_comment

begin_decl_stmt
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Replace the overwritten part.
end_comment

begin_for
for|for
control|(
name|T
modifier|*
name|J
init|=
name|I
init|;
name|NumOverwritten
operator|>
literal|0
condition|;
operator|--
name|NumOverwritten
control|)
block|{
operator|*
name|J
operator|=
operator|*
name|From
expr_stmt|;
operator|++
name|J
expr_stmt|;
operator|++
name|From
expr_stmt|;
block|}
end_for

begin_comment
comment|// Insert the non-overwritten middle part.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|I
return|;
end_return

begin_expr_stmt
unit|}    SmallVectorImpl
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_decl_stmt
name|SmallVectorImpl
modifier|&
name|operator
init|=
operator|(
name|SmallVectorImpl
operator|&&
name|RHS
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|!=
name|RHS
operator|.
name|size
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|equal
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   bool
name|operator
operator|!=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Set the array size to \p N, which the current array must have enough
end_comment

begin_comment
comment|/// capacity for.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This does not construct or destroy any elements in the vector.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Clients can use this in conjunction with capacity() to write past the end
end_comment

begin_comment
comment|/// of the buffer when they know that more elements are available, and only
end_comment

begin_comment
comment|/// update the size later. This avoids the cost of value initializing elements
end_comment

begin_comment
comment|/// which will only be overwritten.
end_comment

begin_function
name|void
name|set_size
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|this
operator|->
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|swap
argument_list|(
argument|SmallVectorImpl<T>&RHS
argument_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// We can only avoid copying elements if neither vector is small.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
operator|&&
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|BeginX
argument_list|,
name|RHS
operator|.
name|BeginX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|EndX
argument_list|,
name|RHS
operator|.
name|EndX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|CapacityX
argument_list|,
name|RHS
operator|.
name|CapacityX
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|capacity
argument_list|()
condition|)
name|this
operator|->
name|grow
argument_list|(
name|RHS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|capacity
argument_list|()
condition|)
name|RHS
operator|.
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Swap the shared elements.
end_comment

begin_decl_stmt
name|size_t
name|NumShared
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NumShared
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
name|NumShared
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_if

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|NumShared
operator|)
condition|;
operator|++
name|i
control|)
name|std
operator|::
name|swap
argument_list|(
operator|(
operator|*
name|this
operator|)
index|[
name|i
index|]
argument_list|,
name|RHS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// Copy over the extra elts.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|this
operator|->
name|size
argument_list|()
operator|-
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|RHS
operator|.
name|size
argument_list|()
operator|-
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
comment|// If we already have sufficient space, assign the common elements, then
comment|// destroy any excess.
name|size_t
name|RHSSize
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|CurSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|NewEnd
operator|=
name|this
operator|->
name|begin
argument_list|()
expr_stmt|;
comment|// Destroy excess elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Trim.
name|this
operator|->
name|setEnd
argument_list|(
name|NewEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_comment
comment|// FIXME: don't do this if they're efficiently moveable.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Copy construct the new elements in place.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_if
unit|}
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
end_expr_stmt

begin_comment
comment|// If the RHS isn't small, clear this vector and then steal its buffer.
end_comment

begin_if
if|if
condition|(
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|BeginX
operator|=
name|RHS
operator|.
name|BeginX
expr_stmt|;
name|this
operator|->
name|EndX
operator|=
name|RHS
operator|.
name|EndX
expr_stmt|;
name|this
operator|->
name|CapacityX
operator|=
name|RHS
operator|.
name|CapacityX
expr_stmt|;
name|RHS
operator|.
name|resetToSmall
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we already have sufficient space, assign the common elements, then
end_comment

begin_comment
comment|// destroy any excess.
end_comment

begin_decl_stmt
name|size_t
name|RHSSize
init|=
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|CurSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
init|=
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|this
operator|->
name|move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|NewEnd
argument_list|)
expr_stmt|;
comment|// Destroy excess elements and trim the bounds.
name|this
operator|->
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|NewEnd
argument_list|)
expr_stmt|;
comment|// Clear the RHS.
name|RHS
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_comment
comment|// FIXME: this may not actually make any sense if we can efficiently move
end_comment

begin_comment
comment|// elements.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|this
operator|->
name|move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Move-construct the new elements in place.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RHS
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/// Storage for the SmallVector elements which aren't contained in
end_comment

begin_comment
comment|/// SmallVectorTemplateCommon. There are 'N-1' elements here. The remaining '1'
end_comment

begin_comment
comment|/// element is in the base class. This is specialized for the N=1 and N=0 cases
end_comment

begin_comment
comment|/// to avoid allocating unnecessary storage.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
expr|struct
name|SmallVectorStorage
block|{
name|typename
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|::
name|U
name|InlineElts
index|[
name|N
operator|-
literal|1
index|]
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SmallVectorStorage
operator|<
name|T
operator|,
literal|1
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SmallVectorStorage
operator|<
name|T
operator|,
literal|0
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// SmallVector - This is a 'vector' (really, a variable-sized array), optimized
end_comment

begin_comment
comment|/// for the case when the array is small.  It contains some number of elements
end_comment

begin_comment
comment|/// in-place, which allows it to avoid heap allocation when the actual number of
end_comment

begin_comment
comment|/// elements is below that threshold.  This allows normal "small" cases to be
end_comment

begin_comment
comment|/// fast without losing generality for large inputs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that this does not attempt to be exception safe.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|SmallVector
operator|:
name|public
name|SmallVectorImpl
operator|<
name|T
operator|>
block|{
comment|/// Storage - Inline space for elements which aren't stored in the base class.
name|SmallVectorStorage
operator|<
name|T
block|,
name|N
operator|>
name|Storage
block|;
name|public
operator|:
name|SmallVector
argument_list|()
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{   }
name|explicit
name|SmallVector
argument_list|(
argument|unsigned Size
argument_list|,
argument|const T&Value = T()
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|assign
argument_list|(
name|Size
argument_list|,
name|Value
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|ItTy
operator|>
name|SmallVector
argument_list|(
argument|ItTy S
argument_list|,
argument|ItTy E
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|append
argument_list|(
name|S
argument_list|,
name|E
argument_list|)
block|;   }
name|SmallVector
argument_list|(
specifier|const
name|SmallVector
operator|&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
expr_stmt|;
block|}
specifier|const
name|SmallVector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallVector
operator|&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_expr_stmt
name|SmallVector
argument_list|(
name|SmallVector
operator|&&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
name|SmallVector
operator|&&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|static
specifier|inline
name|size_t
name|capacity_in_bytes
argument_list|(
argument|const SmallVector<T
argument_list|,
argument|N>&X
argument_list|)
block|{
return|return
name|X
operator|.
name|capacity_in_bytes
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVectorImpl<T>&LHS
argument_list|,
argument|llvm::SmallVectorImpl<T>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVector<T
argument_list|,
argument|N>&LHS
argument_list|,
argument|llvm::SmallVector<T
argument_list|,
argument|N>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

