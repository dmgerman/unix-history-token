begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SmallVector class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SMALLVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SMALLVECTOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<initializer_list>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This is all the non-templated stuff common to all SmallVectors.
name|class
name|SmallVectorBase
block|{
name|protected
label|:
name|void
modifier|*
name|BeginX
decl_stmt|,
modifier|*
name|EndX
decl_stmt|,
modifier|*
name|CapacityX
decl_stmt|;
name|protected
label|:
name|SmallVectorBase
argument_list|(
argument|void *FirstEl
argument_list|,
argument|size_t Size
argument_list|)
block|:
name|BeginX
argument_list|(
name|FirstEl
argument_list|)
operator|,
name|EndX
argument_list|(
name|FirstEl
argument_list|)
operator|,
name|CapacityX
argument_list|(
argument|(char*)FirstEl+Size
argument_list|)
block|{}
comment|/// This is an implementation of the grow() method which only works
comment|/// on POD-like data types and is out of line to reduce code duplication.
name|void
name|grow_pod
argument_list|(
argument|void *FirstEl
argument_list|,
argument|size_t MinSizeInBytes
argument_list|,
argument|size_t TSize
argument_list|)
expr_stmt|;
name|public
label|:
comment|/// This returns size()*sizeof(T).
name|size_t
name|size_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EndX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
comment|/// capacity_in_bytes - This returns capacity()*sizeof(T).
name|size_t
name|capacity_in_bytes
argument_list|()
specifier|const
block|{
return|return
name|size_t
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CapacityX
operator|-
operator|(
name|char
operator|*
operator|)
name|BeginX
argument_list|)
return|;
block|}
name|LLVM_NODISCARD
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|EndX
return|;
block|}
block|}
empty_stmt|;
comment|/// This is the part of SmallVectorTemplateBase which does not depend on whether
comment|/// the type T is a POD. The extra dummy template argument is used by ArrayRef
comment|/// to avoid unnecessarily requiring T to be complete.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|=
name|void
operator|>
name|class
name|SmallVectorTemplateCommon
operator|:
name|public
name|SmallVectorBase
block|{
name|private
operator|:
name|template
operator|<
name|typename
block|,
name|unsigned
operator|>
name|friend
expr|struct
name|SmallVectorStorage
block|;
comment|// Allocate raw space for N elements of type T.  If T has a ctor or dtor, we
comment|// don't want it to be automatically run, so we need to represent the space as
comment|// something else.  Use an array of char of sufficient alignment.
name|using
name|U
operator|=
name|AlignedCharArrayUnion
operator|<
name|T
operator|>
block|;
name|U
name|FirstEl
block|;
comment|// Space after 'FirstEl' is clobbered, do not add any instance vars after it.
name|protected
operator|:
name|SmallVectorTemplateCommon
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorBase
argument_list|(
argument|&FirstEl
argument_list|,
argument|Size
argument_list|)
block|{}
name|void
name|grow_pod
argument_list|(
argument|size_t MinSizeInBytes
argument_list|,
argument|size_t TSize
argument_list|)
block|{
name|SmallVectorBase
operator|::
name|grow_pod
argument_list|(
operator|&
name|FirstEl
argument_list|,
name|MinSizeInBytes
argument_list|,
name|TSize
argument_list|)
block|;   }
comment|/// Return true if this is a smallvector which has not had dynamic
comment|/// memory allocated for it.
name|bool
name|isSmall
argument_list|()
specifier|const
block|{
return|return
name|BeginX
operator|==
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
name|FirstEl
operator|)
return|;
block|}
comment|/// Put this vector in a state of being small.
name|void
name|resetToSmall
argument_list|()
block|{
name|BeginX
operator|=
name|EndX
operator|=
name|CapacityX
operator|=
operator|&
name|FirstEl
block|;   }
name|void
name|setEnd
argument_list|(
argument|T *P
argument_list|)
block|{
name|this
operator|->
name|EndX
operator|=
name|P
block|; }
name|public
operator|:
name|using
name|size_type
operator|=
name|size_t
block|;
name|using
name|difference_type
operator|=
name|ptrdiff_t
block|;
name|using
name|value_type
operator|=
name|T
block|;
name|using
name|iterator
operator|=
name|T
operator|*
block|;
name|using
name|const_iterator
operator|=
specifier|const
name|T
operator|*
block|;
name|using
name|const_reverse_iterator
operator|=
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
block|;
name|using
name|reverse_iterator
operator|=
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
block|;
name|using
name|reference
operator|=
name|T
operator|&
block|;
name|using
name|const_reference
operator|=
specifier|const
name|T
operator|&
block|;
name|using
name|pointer
operator|=
name|T
operator|*
block|;
name|using
name|const_pointer
operator|=
specifier|const
name|T
operator|*
block|;
comment|// forward iterator creation methods.
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|iterator
name|begin
argument_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|BeginX
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|iterator
name|end
argument_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|EndX
return|;
block|}
name|protected
operator|:
name|iterator
name|capacity_ptr
argument_list|()
block|{
return|return
operator|(
name|iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|const_iterator
name|capacity_ptr
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
operator|)
name|this
operator|->
name|CapacityX
return|;
block|}
name|public
operator|:
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
argument_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
argument_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|/// Return the total number of elements in the currently allocated buffer.
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|capacity_ptr
argument_list|()
operator|-
name|begin
argument_list|()
return|;
block|}
comment|/// Return a pointer to the vector's buffer, even if empty().
name|pointer
name|data
argument_list|()
block|{
return|return
name|pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
comment|/// Return a pointer to the vector's buffer, even if empty().
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|reference
name|operator
index|[]
operator|(
name|size_type
name|idx
operator|)
block|{
name|assert
argument_list|(
name|idx
operator|<
name|size
argument_list|()
argument_list|)
block|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|LLVM_ATTRIBUTE_ALWAYS_INLINE
name|const_reference
name|operator
index|[]
operator|(
name|size_type
name|idx
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|idx
operator|<
name|size
argument_list|()
argument_list|)
block|;
return|return
name|begin
argument_list|()
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
expr|}
block|;
comment|/// SmallVectorTemplateBase<isPodLike = false> - This is where we put method
comment|/// implementations that are designed to work with non-POD-like T's.
name|template
operator|<
name|typename
name|T
block|,
name|bool
name|isPodLike
operator|>
name|class
name|SmallVectorTemplateBase
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|protected
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *S
argument_list|,
argument|T *E
argument_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// Move the range [I, E) into the uninitialized memory starting with "Dest",
comment|/// constructing elements as needed.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|std
operator|::
name|make_move_iterator
argument_list|(
name|I
argument_list|)
argument_list|,
name|std
operator|::
name|make_move_iterator
argument_list|(
name|E
argument_list|)
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// Copy the range [I, E) onto the uninitialized memory starting with "Dest",
comment|/// constructing elements as needed.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// Grow the allocated memory (without initializing new elements), doubling
comment|/// the size of the allocated memory. Guarantees space for at least one more
comment|/// element, or MinSize more elements if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
block|;
name|public
operator|:
name|void
name|push_back
argument_list|(
argument|const T&Elt
argument_list|)
block|{
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
block|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
block|;   }
name|void
name|push_back
argument_list|(
argument|T&&Elt
argument_list|)
block|{
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|Elt
argument_list|)
argument_list|)
block|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
block|;   }
name|void
name|pop_back
argument_list|()
block|{
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|)
block|;
name|this
operator|->
name|end
argument_list|()
operator|->
operator|~
name|T
argument_list|()
block|;   }
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|isPodLike
operator|>
name|void
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|>
operator|::
name|grow
argument_list|(
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|this
operator|->
name|capacity
argument_list|()
block|;
name|size_t
name|CurSize
operator|=
name|this
operator|->
name|size
argument_list|()
block|;
comment|// Always grow, even from zero.
name|size_t
name|NewCapacity
operator|=
name|size_t
argument_list|(
name|NextPowerOf2
argument_list|(
name|CurCapacity
operator|+
literal|2
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
name|T
operator|*
name|NewElts
operator|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|malloc
argument_list|(
name|NewCapacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Move the elements over.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Destroy the original elements.
end_comment

begin_expr_stmt
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If this wasn't grown from the inline copy, deallocate the old space.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|NewElts
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|BeginX
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|CapacityX
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NewCapacity
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// SmallVectorTemplateBase<isPodLike = true> - This is where we put method
end_comment

begin_comment
comment|/// implementations that are designed to work with POD-like T's.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|true
operator|>
operator|:
name|public
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
block|{
name|protected
operator|:
name|SmallVectorTemplateBase
argument_list|(
argument|size_t Size
argument_list|)
operator|:
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|(
name|Size
operator|)
block|{}
comment|// No need to do a destroy loop for POD's.
specifier|static
name|void
name|destroy_range
argument_list|(
argument|T *
argument_list|,
argument|T *
argument_list|)
block|{}
comment|/// Move the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_move
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
comment|// Just do a copy.
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|It1
block|,
name|typename
name|It2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|It1 I
argument_list|,
argument|It1 E
argument_list|,
argument|It2 Dest
argument_list|)
block|{
comment|// Arbitrary iterator types; just use the basic implementation.
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|I
argument_list|,
name|E
argument_list|,
name|Dest
argument_list|)
block|;   }
comment|/// Copy the range [I, E) onto the uninitialized memory
comment|/// starting with "Dest", constructing elements into it as needed.
name|template
operator|<
name|typename
name|T1
block|,
name|typename
name|T2
operator|>
specifier|static
name|void
name|uninitialized_copy
argument_list|(
argument|T1 *I
argument_list|,
argument|T1 *E
argument_list|,
argument|T2 *Dest
argument_list|,
argument|typename std::enable_if<std::is_same<typename std::remove_const<T1>::type
argument_list|,
argument|T2>::value>::type * = nullptr
argument_list|)
block|{
comment|// Use memcpy for PODs iterated by pointers (which includes SmallVector
comment|// iterators): std::uninitialized_copy optimizes to memmove, but we can
comment|// use memcpy here. Note that I and E are iterators and thus might be
comment|// invalid for memcpy if they are equal.
if|if
condition|(
name|I
operator|!=
name|E
condition|)
name|memcpy
argument_list|(
name|Dest
argument_list|,
name|I
argument_list|,
operator|(
name|E
operator|-
name|I
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Double the size of the allocated memory, guaranteeing space for at
comment|/// least one more element or MinSize if specified.
name|void
name|grow
argument_list|(
argument|size_t MinSize =
literal|0
argument_list|)
block|{
name|this
operator|->
name|grow_pod
argument_list|(
name|MinSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
name|void
name|push_back
argument_list|(
argument|const T&Elt
argument_list|)
block|{
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
operator|&
name|Elt
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    void
name|pop_back
argument_list|()
end_macro

begin_block
block|{
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
unit|};
comment|/// This class consists of common code factored out of the SmallVector class to
end_comment

begin_comment
comment|/// reduce code duplication based on the SmallVector 'N' template parameter.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
operator|:
name|public
name|SmallVectorTemplateBase
operator|<
name|T
operator|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{
name|using
name|SuperClass
operator|=
name|SmallVectorTemplateBase
operator|<
name|T
block|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|;
name|public
operator|:
name|using
name|iterator
operator|=
name|typename
name|SuperClass
operator|::
name|iterator
block|;
name|using
name|const_iterator
operator|=
name|typename
name|SuperClass
operator|::
name|const_iterator
block|;
name|using
name|size_type
operator|=
name|typename
name|SuperClass
operator|::
name|size_type
block|;
name|protected
operator|:
comment|// Default ctor - Initialize to empty.
name|explicit
name|SmallVectorImpl
argument_list|(
argument|unsigned N
argument_list|)
operator|:
name|SmallVectorTemplateBase
operator|<
name|T
block|,
name|isPodLike
operator|<
name|T
operator|>
operator|::
name|value
operator|>
operator|(
name|N
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|)
block|{   }
name|public
operator|:
name|SmallVectorImpl
argument_list|(
specifier|const
name|SmallVectorImpl
operator|&
argument_list|)
operator|=
name|delete
block|;
operator|~
name|SmallVectorImpl
argument_list|()
block|{
comment|// Destroy the constructed elements in the vector.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
block|;
comment|// If this wasn't grown from the inline copy, deallocate the old space.
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
argument_list|()
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
block|;
name|this
operator|->
name|EndX
operator|=
name|this
operator|->
name|BeginX
block|;   }
name|void
name|resize
argument_list|(
argument|size_type N
argument_list|)
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|I
init|=
name|this
operator|->
name|end
argument_list|()
init|,
name|E
init|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|new
argument_list|(
argument|&*I
argument_list|)
name|T
argument_list|()
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_macro
unit|}    void
name|resize
argument_list|(
argument|size_type N
argument_list|,
argument|const T&NV
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|N
operator|<
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|std
operator|::
name|uninitialized_fill
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|,
name|NV
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|reserve
parameter_list|(
name|size_type
name|N
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|N
condition|)
name|this
operator|->
name|grow
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LLVM_NODISCARD
name|T
name|pop_back_val
parameter_list|()
block|{
name|T
name|Result
init|=
operator|::
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|->
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_function_decl
name|void
name|swap
parameter_list|(
name|SmallVectorImpl
modifier|&
name|RHS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Add the specified range to the end of the SmallVector.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|append
argument_list|(
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|size_type
name|NumInputs
operator|=
name|std
operator|::
name|distance
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// Add the specified range to the end of the SmallVector.
end_comment

begin_macro
unit|void
name|append
argument_list|(
argument|size_type NumInputs
argument_list|,
argument|const T&Elt
argument_list|)
end_macro

begin_block
block|{
comment|// Grow allocated space if needed.
if|if
condition|(
name|NumInputs
operator|>
name|size_type
argument_list|(
name|this
operator|->
name|capacity_ptr
argument_list|()
operator|-
name|this
operator|->
name|end
argument_list|()
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
comment|// Copy the new elements over.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|NumInputs
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumInputs
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|append
argument_list|(
name|std
operator|::
name|initializer_list
operator|<
name|T
operator|>
name|IL
argument_list|)
block|{
name|append
argument_list|(
name|IL
operator|.
name|begin
argument_list|()
argument_list|,
name|IL
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// FIXME: Consider assigning over existing elements, rather than clearing&
end_comment

begin_comment
comment|// re-initializing them - for all assign(...) variants.
end_comment

begin_function
name|void
name|assign
parameter_list|(
name|size_type
name|NumElts
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|NumElts
condition|)
name|this
operator|->
name|grow
argument_list|(
name|NumElts
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumElts
argument_list|)
expr_stmt|;
name|std
operator|::
name|uninitialized_fill
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|in_iter
operator|>
name|void
name|assign
argument_list|(
argument|in_iter in_start
argument_list|,
argument|in_iter in_end
argument_list|)
block|{
name|clear
argument_list|()
block|;
name|append
argument_list|(
name|in_start
argument_list|,
name|in_end
argument_list|)
block|;   }
name|void
name|assign
argument_list|(
argument|std::initializer_list<T> IL
argument_list|)
block|{
name|clear
argument_list|()
block|;
name|append
argument_list|(
name|IL
argument_list|)
block|;   }
name|iterator
name|erase
argument_list|(
argument|const_iterator CI
argument_list|)
block|{
comment|// Just cast away constness because this is a non-const member function.
name|iterator
name|I
operator|=
name|const_cast
operator|<
name|iterator
operator|>
operator|(
name|CI
operator|)
block|;
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Iterator to erase is out of bounds."
argument_list|)
block|;
name|assert
argument_list|(
name|I
operator|<
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Erasing at past-the-end iterator."
argument_list|)
block|;
name|iterator
name|N
operator|=
name|I
block|;
comment|// Shift all elts down one.
name|std
operator|::
name|move
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|I
argument_list|)
block|;
comment|// Drop the last elt.
name|this
operator|->
name|pop_back
argument_list|()
block|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|erase
parameter_list|(
name|const_iterator
name|CS
parameter_list|,
name|const_iterator
name|CE
parameter_list|)
block|{
comment|// Just cast away constness because this is a non-const member function.
name|iterator
name|S
init|=
name|const_cast
operator|<
name|iterator
operator|>
operator|(
name|CS
operator|)
decl_stmt|;
name|iterator
name|E
init|=
name|const_cast
operator|<
name|iterator
operator|>
operator|(
name|CE
operator|)
decl_stmt|;
name|assert
argument_list|(
name|S
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Range to erase is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|S
operator|<=
name|E
operator|&&
literal|"Trying to erase invalid range."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|E
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Trying to erase past the end."
argument_list|)
expr_stmt|;
name|iterator
name|N
init|=
name|S
decl_stmt|;
comment|// Shift all elts down.
name|iterator
name|I
init|=
name|std
operator|::
name|move
argument_list|(
name|E
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|S
argument_list|)
decl_stmt|;
comment|// Drop the last elts.
name|this
operator|->
name|destroy_range
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return
operator|(
name|N
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|iterator
name|insert
argument_list|(
name|iterator
name|I
argument_list|,
name|T
operator|&&
name|Elt
argument_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|this
operator|->
name|push_back
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|Elt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
condition|)
block|{
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
block|}
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|std
operator|::
name|move_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// If we just moved the element we're inserting, be sure to update
comment|// the reference.
name|T
modifier|*
name|EltPtr
init|=
operator|&
name|Elt
decl_stmt|;
if|if
condition|(
name|I
operator|<=
name|EltPtr
operator|&&
name|EltPtr
operator|<
name|this
operator|->
name|EndX
condition|)
operator|++
name|EltPtr
expr_stmt|;
operator|*
name|I
operator|=
operator|::
name|std
operator|::
name|move
argument_list|(
operator|*
name|EltPtr
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|this
operator|->
name|push_back
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
condition|)
block|{
name|size_t
name|EltNo
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|EltNo
expr_stmt|;
block|}
operator|::
name|new
argument_list|(
argument|(void*) this->end()
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|back
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Push everything else over.
name|std
operator|::
name|move_backward
argument_list|(
name|I
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// If we just moved the element we're inserting, be sure to update
comment|// the reference.
specifier|const
name|T
modifier|*
name|EltPtr
init|=
operator|&
name|Elt
decl_stmt|;
if|if
condition|(
name|I
operator|<=
name|EltPtr
operator|&&
name|EltPtr
operator|<
name|this
operator|->
name|EndX
condition|)
operator|++
name|EltPtr
expr_stmt|;
operator|*
name|I
operator|=
operator|*
name|EltPtr
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
name|size_type
name|NumToInsert
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
init|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
comment|// Ensure there is enough space.
name|reserve
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
comment|// Uninvalidate the iterator.
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
comment|// If there are more elements between the insertion point and the end of the
comment|// range than there are being inserted, we can use a simple approach to
comment|// insertion.  Since we already reserved space, we know that this won't
comment|// reallocate the vector.
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|std
operator|::
name|move_iterator
operator|<
name|iterator
operator|>
operator|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
operator|)
argument_list|,
name|std
operator|::
name|move_iterator
operator|<
name|iterator
operator|>
operator|(
name|this
operator|->
name|end
argument_list|()
operator|)
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|move_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumToInsert
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
comment|// Otherwise, we're inserting more elements than exist already, and we're
comment|// not inserting at the end.
comment|// Move over the elements that we're about to overwrite.
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
name|this
operator|->
name|uninitialized_move
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
comment|// Replace the overwritten part.
name|std
operator|::
name|fill_n
argument_list|(
name|I
argument_list|,
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
comment|// Insert the non-overwritten middle part.
name|std
operator|::
name|uninitialized_fill_n
argument_list|(
name|OldEnd
argument_list|,
name|NumToInsert
operator|-
name|NumOverwritten
argument_list|,
name|Elt
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|ItTy
operator|>
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|ItTy From
argument_list|,
argument|ItTy To
argument_list|)
block|{
comment|// Convert iterator to elt# to avoid invalidating iterator when we reserve()
name|size_t
name|InsertElt
operator|=
name|I
operator|-
name|this
operator|->
name|begin
argument_list|()
block|;
if|if
condition|(
name|I
operator|==
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Important special case for empty vector.
name|append
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
return|return
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
return|;
block|}
name|assert
argument_list|(
name|I
operator|>=
name|this
operator|->
name|begin
argument_list|()
operator|&&
literal|"Insertion iterator is out of bounds."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|I
operator|<=
name|this
operator|->
name|end
argument_list|()
operator|&&
literal|"Inserting past the end of the vector."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumToInsert
init|=
name|std
operator|::
name|distance
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Ensure there is enough space.
end_comment

begin_expr_stmt
name|reserve
argument_list|(
name|this
operator|->
name|size
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Uninvalidate the iterator.
end_comment

begin_expr_stmt
name|I
operator|=
name|this
operator|->
name|begin
argument_list|()
operator|+
name|InsertElt
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If there are more elements between the insertion point and the end of the
end_comment

begin_comment
comment|// range than there are being inserted, we can use a simple approach to
end_comment

begin_comment
comment|// insertion.  Since we already reserved space, we know that this won't
end_comment

begin_comment
comment|// reallocate the vector.
end_comment

begin_if
if|if
condition|(
name|size_t
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|I
argument_list|)
operator|>=
name|NumToInsert
condition|)
block|{
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|append
argument_list|(
name|std
operator|::
name|move_iterator
operator|<
name|iterator
operator|>
operator|(
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumToInsert
operator|)
argument_list|,
name|std
operator|::
name|move_iterator
operator|<
name|iterator
operator|>
operator|(
name|this
operator|->
name|end
argument_list|()
operator|)
argument_list|)
expr_stmt|;
comment|// Copy the existing elements that get replaced.
name|std
operator|::
name|move_backward
argument_list|(
name|I
argument_list|,
name|OldEnd
operator|-
name|NumToInsert
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|I
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_if

begin_comment
comment|// Otherwise, we're inserting more elements than exist already, and we're
end_comment

begin_comment
comment|// not inserting at the end.
end_comment

begin_comment
comment|// Move over the elements that we're about to overwrite.
end_comment

begin_decl_stmt
name|T
modifier|*
name|OldEnd
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|NumToInsert
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|NumOverwritten
init|=
name|OldEnd
operator|-
name|I
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|I
argument_list|,
name|OldEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
operator|-
name|NumOverwritten
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Replace the overwritten part.
end_comment

begin_for
for|for
control|(
name|T
modifier|*
name|J
init|=
name|I
init|;
name|NumOverwritten
operator|>
literal|0
condition|;
operator|--
name|NumOverwritten
control|)
block|{
operator|*
name|J
operator|=
operator|*
name|From
expr_stmt|;
operator|++
name|J
expr_stmt|;
operator|++
name|From
expr_stmt|;
block|}
end_for

begin_comment
comment|// Insert the non-overwritten middle part.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|OldEnd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|I
return|;
end_return

begin_macro
unit|}    void
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|std::initializer_list<T> IL
argument_list|)
end_macro

begin_block
block|{
name|insert
argument_list|(
name|I
argument_list|,
name|IL
operator|.
name|begin
argument_list|()
argument_list|,
name|IL
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|ArgTypes
operator|>
name|void
name|emplace_back
argument_list|(
argument|ArgTypes&&... Args
argument_list|)
block|{
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|this
operator|->
name|EndX
operator|>=
name|this
operator|->
name|CapacityX
argument_list|)
condition|)
name|this
operator|->
name|grow
argument_list|()
expr_stmt|;
operator|::
name|new
argument_list|(
argument|(void *)this->end()
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|ArgTypes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    SmallVectorImpl
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SmallVectorImpl
modifier|&
name|operator
init|=
operator|(
name|SmallVectorImpl
operator|&&
name|RHS
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|!=
name|RHS
operator|.
name|size
argument_list|()
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|equal
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   bool
name|operator
operator|!=
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|SmallVectorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Set the array size to \p N, which the current array must have enough
end_comment

begin_comment
comment|/// capacity for.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This does not construct or destroy any elements in the vector.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Clients can use this in conjunction with capacity() to write past the end
end_comment

begin_comment
comment|/// of the buffer when they know that more elements are available, and only
end_comment

begin_comment
comment|/// update the size later. This avoids the cost of value initializing elements
end_comment

begin_comment
comment|/// which will only be overwritten.
end_comment

begin_function
name|void
name|set_size
parameter_list|(
name|size_type
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|this
operator|->
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|swap
argument_list|(
argument|SmallVectorImpl<T>&RHS
argument_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// We can only avoid copying elements if neither vector is small.
end_comment

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
operator|&&
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|BeginX
argument_list|,
name|RHS
operator|.
name|BeginX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|EndX
argument_list|,
name|RHS
operator|.
name|EndX
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|this
operator|->
name|CapacityX
argument_list|,
name|RHS
operator|.
name|CapacityX
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|capacity
argument_list|()
condition|)
name|this
operator|->
name|grow
argument_list|(
name|RHS
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|capacity
argument_list|()
condition|)
name|RHS
operator|.
name|grow
argument_list|(
name|this
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Swap the shared elements.
end_comment

begin_decl_stmt
name|size_t
name|NumShared
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NumShared
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
name|NumShared
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_if

begin_for
for|for
control|(
name|size_type
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumShared
condition|;
operator|++
name|i
control|)
name|std
operator|::
name|swap
argument_list|(
operator|(
operator|*
name|this
operator|)
index|[
name|i
index|]
argument_list|,
name|RHS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// Copy over the extra elts.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|>
name|RHS
operator|.
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|this
operator|->
name|size
argument_list|()
operator|-
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RHS
operator|.
name|size
argument_list|()
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
block|{
name|size_t
name|EltDiff
init|=
name|RHS
operator|.
name|size
argument_list|()
operator|-
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|end
argument_list|()
operator|+
name|EltDiff
argument_list|)
expr_stmt|;
name|this
operator|->
name|destroy_range
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|RHS
operator|.
name|setEnd
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|NumShared
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
comment|// If we already have sufficient space, assign the common elements, then
comment|// destroy any excess.
name|size_t
name|RHSSize
operator|=
name|RHS
operator|.
name|size
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|CurSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|NewEnd
operator|=
name|this
operator|->
name|begin
argument_list|()
expr_stmt|;
comment|// Destroy excess elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Trim.
name|this
operator|->
name|setEnd
argument_list|(
name|NewEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_comment
comment|// FIXME: don't do this if they're efficiently moveable.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|std
operator|::
name|copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Copy construct the new elements in place.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_copy
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&&
name|RHS
operator|)
block|{
comment|// Avoid self-assignment.
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
end_expr_stmt

begin_comment
comment|// If the RHS isn't small, clear this vector and then steal its buffer.
end_comment

begin_if
if|if
condition|(
operator|!
name|RHS
operator|.
name|isSmall
argument_list|()
condition|)
block|{
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|BeginX
operator|=
name|RHS
operator|.
name|BeginX
expr_stmt|;
name|this
operator|->
name|EndX
operator|=
name|RHS
operator|.
name|EndX
expr_stmt|;
name|this
operator|->
name|CapacityX
operator|=
name|RHS
operator|.
name|CapacityX
expr_stmt|;
name|RHS
operator|.
name|resetToSmall
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we already have sufficient space, assign the common elements, then
end_comment

begin_comment
comment|// destroy any excess.
end_comment

begin_decl_stmt
name|size_t
name|RHSSize
init|=
name|RHS
operator|.
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|CurSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|CurSize
operator|>=
name|RHSSize
condition|)
block|{
comment|// Assign common elements.
name|iterator
name|NewEnd
init|=
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|RHSSize
condition|)
name|NewEnd
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|NewEnd
argument_list|)
expr_stmt|;
comment|// Destroy excess elements and trim the bounds.
name|this
operator|->
name|destroy_range
argument_list|(
name|NewEnd
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|NewEnd
argument_list|)
expr_stmt|;
comment|// Clear the RHS.
name|RHS
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_if

begin_comment
comment|// If we have to grow to have enough elements, destroy the current elements.
end_comment

begin_comment
comment|// This allows us to avoid copying them during the grow.
end_comment

begin_comment
comment|// FIXME: this may not actually make any sense if we can efficiently move
end_comment

begin_comment
comment|// elements.
end_comment

begin_if
if|if
condition|(
name|this
operator|->
name|capacity
argument_list|()
operator|<
name|RHSSize
condition|)
block|{
comment|// Destroy current elements.
name|this
operator|->
name|destroy_range
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CurSize
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|grow
argument_list|(
name|RHSSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CurSize
condition|)
block|{
comment|// Otherwise, use assignment for the already-constructed elements.
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|this
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Move-construct the new elements in place.
end_comment

begin_expr_stmt
name|this
operator|->
name|uninitialized_move
argument_list|(
name|RHS
operator|.
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|,
name|RHS
operator|.
name|end
argument_list|()
argument_list|,
name|this
operator|->
name|begin
argument_list|()
operator|+
name|CurSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set end.
end_comment

begin_expr_stmt
name|this
operator|->
name|setEnd
argument_list|(
name|this
operator|->
name|begin
argument_list|()
operator|+
name|RHSSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RHS
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_comment
unit|}
comment|/// Storage for the SmallVector elements which aren't contained in
end_comment

begin_comment
comment|/// SmallVectorTemplateCommon. There are 'N-1' elements here. The remaining '1'
end_comment

begin_comment
comment|/// element is in the base class. This is specialized for the N=1 and N=0 cases
end_comment

begin_comment
comment|/// to avoid allocating unnecessary storage.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
expr|struct
name|SmallVectorStorage
block|{
name|typename
name|SmallVectorTemplateCommon
operator|<
name|T
operator|>
operator|::
name|U
name|InlineElts
index|[
name|N
operator|-
literal|1
index|]
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SmallVectorStorage
operator|<
name|T
operator|,
literal|1
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SmallVectorStorage
operator|<
name|T
operator|,
literal|0
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// This is a 'vector' (really, a variable-sized array), optimized
end_comment

begin_comment
comment|/// for the case when the array is small.  It contains some number of elements
end_comment

begin_comment
comment|/// in-place, which allows it to avoid heap allocation when the actual number of
end_comment

begin_comment
comment|/// elements is below that threshold.  This allows normal "small" cases to be
end_comment

begin_comment
comment|/// fast without losing generality for large inputs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that this does not attempt to be exception safe.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|SmallVector
operator|:
name|public
name|SmallVectorImpl
operator|<
name|T
operator|>
block|{
comment|/// Inline space for elements which aren't stored in the base class.
name|SmallVectorStorage
operator|<
name|T
block|,
name|N
operator|>
name|Storage
block|;
name|public
operator|:
name|SmallVector
argument_list|()
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{}
name|explicit
name|SmallVector
argument_list|(
argument|size_t Size
argument_list|,
argument|const T&Value = T()
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|assign
argument_list|(
name|Size
argument_list|,
name|Value
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|ItTy
operator|>
name|SmallVector
argument_list|(
argument|ItTy S
argument_list|,
argument|ItTy E
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|append
argument_list|(
name|S
argument_list|,
name|E
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|RangeTy
operator|>
name|explicit
name|SmallVector
argument_list|(
specifier|const
name|iterator_range
operator|<
name|RangeTy
operator|>
operator|&
name|R
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|append
argument_list|(
name|R
operator|.
name|begin
argument_list|()
argument_list|,
name|R
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
name|SmallVector
argument_list|(
name|std
operator|::
name|initializer_list
operator|<
name|T
operator|>
name|IL
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
name|this
operator|->
name|assign
argument_list|(
name|IL
argument_list|)
block|;   }
name|SmallVector
argument_list|(
specifier|const
name|SmallVector
operator|&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
expr_stmt|;
block|}
specifier|const
name|SmallVector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallVector
operator|&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SmallVector
argument_list|(
name|SmallVector
operator|&&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|SmallVector
argument_list|(
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&&
name|RHS
argument_list|)
operator|:
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|(
name|N
operator|)
block|{
if|if
condition|(
operator|!
name|RHS
operator|.
name|empty
argument_list|()
condition|)
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
name|SmallVector
operator|&&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|&&
name|RHS
operator|)
block|{
name|SmallVectorImpl
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
operator|::
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|SmallVector
modifier|&
name|operator
init|=
operator|(
name|std
operator|::
name|initializer_list
operator|<
name|T
operator|>
name|IL
operator|)
block|{
name|this
operator|->
name|assign
argument_list|(
name|IL
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|static
specifier|inline
name|size_t
name|capacity_in_bytes
argument_list|(
argument|const SmallVector<T
argument_list|,
argument|N>&X
argument_list|)
block|{
return|return
name|X
operator|.
name|capacity_in_bytes
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVectorImpl<T>&LHS
argument_list|,
argument|llvm::SmallVectorImpl<T>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
comment|/// Implement std::swap in terms of SmallVector swap.
name|template
operator|<
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallVector<T
argument_list|,
argument|N>&LHS
argument_list|,
argument|llvm::SmallVector<T
argument_list|,
argument|N>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
block|}
end_block

begin_comment
comment|// end namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_SMALLVECTOR_H
end_comment

end_unit

