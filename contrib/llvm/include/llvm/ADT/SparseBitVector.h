begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector -*- C++ -*- ===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SparseBitVector class.  See the doxygen comment for
end_comment

begin_comment
comment|// SparseBitVector for more details on the algorithm used.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SPARSEBITVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SPARSEBITVECTOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// SparseBitVector is an implementation of a bitvector that is sparse by only
comment|/// storing the elements that have non-zero bits set.  In order to make this
comment|/// fast for the most common cases, SparseBitVector is implemented as a linked
comment|/// list of SparseBitVectorElements.  We maintain a pointer to the last
comment|/// SparseBitVectorElement accessed (in the form of a list iterator), in order
comment|/// to make multiple in-order test/set constant time after the first one is
comment|/// executed.  Note that using vectors to store SparseBitVectorElement's does
comment|/// not work out very well because it causes insertion in the middle to take
comment|/// enormous amounts of time with a large amount of bits.  Other structures that
comment|/// have better worst cases for insertion in the middle (various balanced trees,
comment|/// etc) do not perform as well in practice as a linked list with this iterator
comment|/// kept up to date.  They are also significantly more memory intensive.
name|template
operator|<
name|unsigned
name|ElementSize
operator|=
literal|128
operator|>
expr|struct
name|SparseBitVectorElement
block|{
name|public
operator|:
typedef|typedef
name|unsigned
name|long
name|BitWord
typedef|;
typedef|typedef
name|unsigned
name|size_type
typedef|;
enum|enum
block|{
name|BITWORD_SIZE
init|=
sizeof|sizeof
argument_list|(
name|BitWord
argument_list|)
operator|*
name|CHAR_BIT
block|,
name|BITWORDS_PER_ELEMENT
init|=
operator|(
name|ElementSize
operator|+
name|BITWORD_SIZE
operator|-
literal|1
operator|)
operator|/
name|BITWORD_SIZE
block|,
name|BITS_PER_ELEMENT
init|=
name|ElementSize
block|}
enum|;
name|private
label|:
comment|// Index of Element in terms of where first bit starts.
name|unsigned
name|ElementIndex
decl_stmt|;
name|BitWord
name|Bits
index|[
name|BITWORDS_PER_ELEMENT
index|]
decl_stmt|;
name|SparseBitVectorElement
argument_list|()
block|{
name|ElementIndex
operator|=
operator|~
literal|0U
expr_stmt|;
name|memset
argument_list|(
operator|&
name|Bits
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|BitWord
argument_list|)
operator|*
name|BITWORDS_PER_ELEMENT
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|explicit
name|SparseBitVectorElement
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|ElementIndex
operator|=
name|Idx
expr_stmt|;
name|memset
argument_list|(
operator|&
name|Bits
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|BitWord
argument_list|)
operator|*
name|BITWORDS_PER_ELEMENT
argument_list|)
expr_stmt|;
block|}
comment|// Comparison.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SparseBitVectorElement
operator|&
name|RHS
operator|)
specifier|const
block|{
if|if
condition|(
name|ElementIndex
operator|!=
name|RHS
operator|.
name|ElementIndex
condition|)
return|return
name|false
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
name|RHS
operator|.
name|Bits
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SparseBitVectorElement
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Return the bits that make up word Idx in our element.
end_comment

begin_decl_stmt
name|BitWord
name|word
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|BITWORDS_PER_ELEMENT
argument_list|)
expr_stmt|;
return|return
name|Bits
index|[
name|Idx
index|]
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|unsigned
name|index
argument_list|()
specifier|const
block|{
return|return
name|ElementIndex
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Bits
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_macro
unit|}    void
name|set
argument_list|(
argument|unsigned Idx
argument_list|)
end_macro

begin_block
block|{
name|Bits
index|[
name|Idx
operator|/
name|BITWORD_SIZE
index|]
operator||=
literal|1L
operator|<<
operator|(
name|Idx
operator|%
name|BITWORD_SIZE
operator|)
expr_stmt|;
block|}
end_block

begin_function
name|bool
name|test_and_set
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|bool
name|old
init|=
name|test
argument_list|(
name|Idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
block|{
name|set
argument_list|(
name|Idx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|reset
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|Bits
index|[
name|Idx
operator|/
name|BITWORD_SIZE
index|]
operator|&=
operator|~
operator|(
literal|1L
operator|<<
operator|(
name|Idx
operator|%
name|BITWORD_SIZE
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|test
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
return|return
name|Bits
index|[
name|Idx
operator|/
name|BITWORD_SIZE
index|]
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|Idx
operator|%
name|BITWORD_SIZE
operator|)
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|size_type
name|count
argument_list|()
specifier|const
block|{
name|unsigned
name|NumBits
operator|=
literal|0
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
name|NumBits
operator|+=
name|countPopulation
argument_list|(
name|Bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NumBits
return|;
end_return

begin_comment
unit|}
comment|/// find_first - Returns the index of the first set bit.
end_comment

begin_macro
unit|int
name|find_first
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|i
operator|*
name|BITWORD_SIZE
operator|+
name|countTrailingZeros
argument_list|(
name|Bits
index|[
name|i
index|]
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Illegal empty element"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// find_last - Returns the index of the last set bit.
end_comment

begin_macro
unit|int
name|find_last
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|I
control|)
block|{
name|unsigned
name|Idx
init|=
name|BITWORDS_PER_ELEMENT
operator|-
name|I
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|Bits
index|[
name|Idx
index|]
operator|!=
literal|0
condition|)
return|return
name|Idx
operator|*
name|BITWORD_SIZE
operator|+
name|BITWORD_SIZE
operator|-
name|countLeadingZeros
argument_list|(
name|Bits
index|[
name|Idx
index|]
argument_list|)
operator|-
literal|1
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Illegal empty element"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// find_next - Returns the index of the next set bit starting from the
end_comment

begin_comment
comment|/// "Curr" bit. Returns -1 if the next set bit is not found.
end_comment

begin_macro
unit|int
name|find_next
argument_list|(
argument|unsigned Curr
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|Curr
operator|>=
name|BITS_PER_ELEMENT
condition|)
return|return
operator|-
literal|1
return|;
name|unsigned
name|WordPos
operator|=
name|Curr
operator|/
name|BITWORD_SIZE
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|BitPos
init|=
name|Curr
operator|%
name|BITWORD_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BitWord
name|Copy
init|=
name|Bits
index|[
name|WordPos
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|assert
argument_list|(
name|WordPos
operator|<=
name|BITWORDS_PER_ELEMENT
operator|&&
literal|"Word Position outside of element"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Mask off previous bits.
end_comment

begin_expr_stmt
name|Copy
operator|&=
operator|~
literal|0UL
operator|<<
name|BitPos
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Copy
operator|!=
literal|0
condition|)
return|return
name|WordPos
operator|*
name|BITWORD_SIZE
operator|+
name|countTrailingZeros
argument_list|(
name|Copy
argument_list|)
return|;
end_if

begin_comment
comment|// Check subsequent words.
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
name|WordPos
operator|+
literal|1
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|i
operator|*
name|BITWORD_SIZE
operator|+
name|countTrailingZeros
argument_list|(
name|Bits
index|[
name|i
index|]
argument_list|)
return|;
end_for

begin_return
return|return
operator|-
literal|1
return|;
end_return

begin_comment
unit|}
comment|// Union this element with RHS and return true if this one changed.
end_comment

begin_macro
unit|bool
name|unionWith
argument_list|(
argument|const SparseBitVectorElement&RHS
argument_list|)
end_macro

begin_block
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
block|{
name|BitWord
name|old
init|=
name|changed
condition|?
literal|0
else|:
name|Bits
index|[
name|i
index|]
decl_stmt|;
name|Bits
index|[
name|i
index|]
operator||=
name|RHS
operator|.
name|Bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|changed
operator|&&
name|old
operator|!=
name|Bits
index|[
name|i
index|]
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_block

begin_comment
comment|// Return true if we have any bits in common with RHS
end_comment

begin_decl_stmt
name|bool
name|intersects
argument_list|(
specifier|const
name|SparseBitVectorElement
operator|&
name|RHS
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|RHS
operator|.
name|Bits
index|[
name|i
index|]
operator|&
name|Bits
index|[
name|i
index|]
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Intersect this Element with RHS and return true if this one changed.
end_comment

begin_comment
comment|// BecameZero is set to true if this element became all-zero bits.
end_comment

begin_function
name|bool
name|intersectWith
parameter_list|(
specifier|const
name|SparseBitVectorElement
modifier|&
name|RHS
parameter_list|,
name|bool
modifier|&
name|BecameZero
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bool
name|allzero
init|=
name|true
decl_stmt|;
name|BecameZero
operator|=
name|false
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
block|{
name|BitWord
name|old
init|=
name|changed
condition|?
literal|0
else|:
name|Bits
index|[
name|i
index|]
decl_stmt|;
name|Bits
index|[
name|i
index|]
operator|&=
name|RHS
operator|.
name|Bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|allzero
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|changed
operator|&&
name|old
operator|!=
name|Bits
index|[
name|i
index|]
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
name|BecameZero
operator|=
name|allzero
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|// Intersect this Element with the complement of RHS and return true if this
end_comment

begin_comment
comment|// one changed.  BecameZero is set to true if this element became all-zero
end_comment

begin_comment
comment|// bits.
end_comment

begin_function
name|bool
name|intersectWithComplement
parameter_list|(
specifier|const
name|SparseBitVectorElement
modifier|&
name|RHS
parameter_list|,
name|bool
modifier|&
name|BecameZero
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bool
name|allzero
init|=
name|true
decl_stmt|;
name|BecameZero
operator|=
name|false
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
block|{
name|BitWord
name|old
init|=
name|changed
condition|?
literal|0
else|:
name|Bits
index|[
name|i
index|]
decl_stmt|;
name|Bits
index|[
name|i
index|]
operator|&=
operator|~
name|RHS
operator|.
name|Bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|allzero
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|changed
operator|&&
name|old
operator|!=
name|Bits
index|[
name|i
index|]
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
name|BecameZero
operator|=
name|allzero
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|// Three argument version of intersectWithComplement that intersects
end_comment

begin_comment
comment|// RHS1& ~RHS2 into this element
end_comment

begin_function
name|void
name|intersectWithComplement
parameter_list|(
specifier|const
name|SparseBitVectorElement
modifier|&
name|RHS1
parameter_list|,
specifier|const
name|SparseBitVectorElement
modifier|&
name|RHS2
parameter_list|,
name|bool
modifier|&
name|BecameZero
parameter_list|)
block|{
name|bool
name|allzero
init|=
name|true
decl_stmt|;
name|BecameZero
operator|=
name|false
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BITWORDS_PER_ELEMENT
condition|;
operator|++
name|i
control|)
block|{
name|Bits
index|[
name|i
index|]
operator|=
name|RHS1
operator|.
name|Bits
index|[
name|i
index|]
operator|&
operator|~
name|RHS2
operator|.
name|Bits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|allzero
operator|=
name|false
expr_stmt|;
block|}
name|BecameZero
operator|=
name|allzero
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|unsigned
name|ElementSize
operator|=
literal|128
operator|>
name|class
name|SparseBitVector
block|{
typedef|typedef
name|std
operator|::
name|list
operator|<
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>>
name|ElementList
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ElementList
operator|::
name|iterator
name|ElementListIter
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ElementList
operator|::
name|const_iterator
name|ElementListConstIter
expr_stmt|;
end_typedef

begin_enum
enum|enum
block|{
name|BITWORD_SIZE
init|=
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|::
name|BITWORD_SIZE
block|}
enum|;
end_enum

begin_comment
comment|// Pointer to our current Element.
end_comment

begin_decl_stmt
name|ElementListIter
name|CurrElementIter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ElementList
name|Elements
decl_stmt|;
end_decl_stmt

begin_comment
comment|// This is like std::lower_bound, except we do linear searching from the
end_comment

begin_comment
comment|// current position.
end_comment

begin_function
name|ElementListIter
name|FindLowerBound
parameter_list|(
name|unsigned
name|ElementIndex
parameter_list|)
block|{
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
block|{
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
return|return
name|Elements
operator|.
name|begin
argument_list|()
return|;
block|}
comment|// Make sure our current iterator is valid.
if|if
condition|(
name|CurrElementIter
operator|==
name|Elements
operator|.
name|end
argument_list|()
condition|)
operator|--
name|CurrElementIter
expr_stmt|;
comment|// Search from our current iterator, either backwards or forwards,
comment|// depending on what element we are looking for.
name|ElementListIter
name|ElementIter
init|=
name|CurrElementIter
decl_stmt|;
if|if
condition|(
name|CurrElementIter
operator|->
name|index
argument_list|()
operator|==
name|ElementIndex
condition|)
block|{
return|return
name|ElementIter
return|;
block|}
elseif|else
if|if
condition|(
name|CurrElementIter
operator|->
name|index
argument_list|()
operator|>
name|ElementIndex
condition|)
block|{
while|while
condition|(
name|ElementIter
operator|!=
name|Elements
operator|.
name|begin
argument_list|()
operator|&&
name|ElementIter
operator|->
name|index
argument_list|()
operator|>
name|ElementIndex
condition|)
operator|--
name|ElementIter
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ElementIter
operator|!=
name|Elements
operator|.
name|end
argument_list|()
operator|&&
name|ElementIter
operator|->
name|index
argument_list|()
operator|<
name|ElementIndex
condition|)
operator|++
name|ElementIter
expr_stmt|;
block|}
name|CurrElementIter
operator|=
name|ElementIter
expr_stmt|;
return|return
name|ElementIter
return|;
block|}
end_function

begin_comment
comment|// Iterator to walk set bits in the bitmap.  This iterator is a lot uglier
end_comment

begin_comment
comment|// than it would be, in order to be efficient.
end_comment

begin_decl_stmt
name|class
name|SparseBitVectorIterator
block|{
name|private
label|:
name|bool
name|AtEnd
decl_stmt|;
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|BitVector
operator|=
name|nullptr
expr_stmt|;
comment|// Current element inside of bitmap.
name|ElementListConstIter
name|Iter
decl_stmt|;
comment|// Current bit number inside of our bitmap.
name|unsigned
name|BitNumber
decl_stmt|;
comment|// Current word number inside of our element.
name|unsigned
name|WordNumber
decl_stmt|;
comment|// Current bits from the element.
name|typename
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|::
name|BitWord
name|Bits
expr_stmt|;
comment|// Move our iterator to the first non-zero bit in the bitmap.
name|void
name|AdvanceToFirstNonZero
parameter_list|()
block|{
if|if
condition|(
name|AtEnd
condition|)
return|return;
if|if
condition|(
name|BitVector
operator|->
name|Elements
operator|.
name|empty
argument_list|()
condition|)
block|{
name|AtEnd
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|Iter
operator|=
name|BitVector
operator|->
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
name|BitNumber
operator|=
name|Iter
operator|->
name|index
argument_list|()
operator|*
name|ElementSize
expr_stmt|;
name|unsigned
name|BitPos
init|=
name|Iter
operator|->
name|find_first
argument_list|()
decl_stmt|;
name|BitNumber
operator|+=
name|BitPos
expr_stmt|;
name|WordNumber
operator|=
operator|(
name|BitNumber
operator|%
name|ElementSize
operator|)
operator|/
name|BITWORD_SIZE
expr_stmt|;
name|Bits
operator|=
name|Iter
operator|->
name|word
argument_list|(
name|WordNumber
argument_list|)
expr_stmt|;
name|Bits
operator|>>=
name|BitPos
operator|%
name|BITWORD_SIZE
expr_stmt|;
block|}
comment|// Move our iterator to the next non-zero bit.
name|void
name|AdvanceToNextNonZero
parameter_list|()
block|{
if|if
condition|(
name|AtEnd
condition|)
return|return;
while|while
condition|(
name|Bits
operator|&&
operator|!
operator|(
name|Bits
operator|&
literal|1
operator|)
condition|)
block|{
name|Bits
operator|>>=
literal|1
expr_stmt|;
name|BitNumber
operator|+=
literal|1
expr_stmt|;
block|}
comment|// See if we ran out of Bits in this word.
if|if
condition|(
operator|!
name|Bits
condition|)
block|{
name|int
name|NextSetBitNumber
init|=
name|Iter
operator|->
name|find_next
argument_list|(
name|BitNumber
operator|%
name|ElementSize
argument_list|)
decl_stmt|;
comment|// If we ran out of set bits in this element, move to next element.
if|if
condition|(
name|NextSetBitNumber
operator|==
operator|-
literal|1
operator|||
operator|(
name|BitNumber
operator|%
name|ElementSize
operator|==
literal|0
operator|)
condition|)
block|{
operator|++
name|Iter
expr_stmt|;
name|WordNumber
operator|=
literal|0
expr_stmt|;
comment|// We may run out of elements in the bitmap.
if|if
condition|(
name|Iter
operator|==
name|BitVector
operator|->
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|AtEnd
operator|=
name|true
expr_stmt|;
return|return;
block|}
comment|// Set up for next non-zero word in bitmap.
name|BitNumber
operator|=
name|Iter
operator|->
name|index
argument_list|()
operator|*
name|ElementSize
expr_stmt|;
name|NextSetBitNumber
operator|=
name|Iter
operator|->
name|find_first
argument_list|()
expr_stmt|;
name|BitNumber
operator|+=
name|NextSetBitNumber
expr_stmt|;
name|WordNumber
operator|=
operator|(
name|BitNumber
operator|%
name|ElementSize
operator|)
operator|/
name|BITWORD_SIZE
expr_stmt|;
name|Bits
operator|=
name|Iter
operator|->
name|word
argument_list|(
name|WordNumber
argument_list|)
expr_stmt|;
name|Bits
operator|>>=
name|NextSetBitNumber
operator|%
name|BITWORD_SIZE
expr_stmt|;
block|}
else|else
block|{
name|WordNumber
operator|=
operator|(
name|NextSetBitNumber
operator|%
name|ElementSize
operator|)
operator|/
name|BITWORD_SIZE
expr_stmt|;
name|Bits
operator|=
name|Iter
operator|->
name|word
argument_list|(
name|WordNumber
argument_list|)
expr_stmt|;
name|Bits
operator|>>=
name|NextSetBitNumber
operator|%
name|BITWORD_SIZE
expr_stmt|;
name|BitNumber
operator|=
name|Iter
operator|->
name|index
argument_list|()
operator|*
name|ElementSize
expr_stmt|;
name|BitNumber
operator|+=
name|NextSetBitNumber
expr_stmt|;
block|}
block|}
block|}
name|public
label|:
name|SparseBitVectorIterator
argument_list|()
operator|=
expr|default
expr_stmt|;
name|SparseBitVectorIterator
argument_list|(
argument|const SparseBitVector<ElementSize> *RHS
argument_list|,
argument|bool end = false
argument_list|)
block|:
name|BitVector
argument_list|(
argument|RHS
argument_list|)
block|{
name|Iter
operator|=
name|BitVector
operator|->
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
name|BitNumber
operator|=
literal|0
expr_stmt|;
name|Bits
operator|=
literal|0
expr_stmt|;
name|WordNumber
operator|=
operator|~
literal|0
expr_stmt|;
name|AtEnd
operator|=
name|end
expr_stmt|;
name|AdvanceToFirstNonZero
argument_list|()
expr_stmt|;
block|}
comment|// Preincrement.
specifier|inline
name|SparseBitVectorIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|BitNumber
block|;
name|Bits
operator|>>=
literal|1
block|;
name|AdvanceToNextNonZero
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
comment|// Postincrement.
specifier|inline
name|SparseBitVectorIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|SparseBitVectorIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
comment|// Return the current set bit number.
name|unsigned
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|BitNumber
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SparseBitVectorIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
comment|// If they are both at the end, ignore the rest of the fields.
if|if
condition|(
name|AtEnd
operator|&&
name|RHS
operator|.
name|AtEnd
condition|)
return|return
name|true
return|;
comment|// Otherwise they are the same if they have the same bit number and
comment|// bitmap.
return|return
name|AtEnd
operator|==
name|RHS
operator|.
name|AtEnd
operator|&&
name|RHS
operator|.
name|BitNumber
operator|==
name|BitNumber
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SparseBitVectorIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_label
unit|};
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|SparseBitVectorIterator
name|iterator
typedef|;
end_typedef

begin_macro
name|SparseBitVector
argument_list|()
end_macro

begin_block
block|{
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
operator|~
name|SparseBitVector
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_comment
comment|// SparseBitVector copy ctor.
end_comment

begin_macro
name|SparseBitVector
argument_list|(
argument|const SparseBitVector&RHS
argument_list|)
end_macro

begin_block
block|{
name|ElementListConstIter
name|ElementIter
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|ElementIter
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|Elements
operator|.
name|push_back
argument_list|(
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|(
operator|*
name|ElementIter
operator|)
argument_list|)
expr_stmt|;
operator|++
name|ElementIter
expr_stmt|;
block|}
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|// Clear.
end_comment

begin_function
name|void
name|clear
parameter_list|()
block|{
name|Elements
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// Assignment
end_comment

begin_decl_stmt
name|SparseBitVector
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SparseBitVector
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
operator|*
name|this
return|;
name|Elements
operator|.
name|clear
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ElementListConstIter
name|ElementIter
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|ElementIter
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|Elements
operator|.
name|push_back
argument_list|(
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|(
operator|*
name|ElementIter
operator|)
argument_list|)
expr_stmt|;
operator|++
name|ElementIter
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_comment
unit|}
comment|// Test, Reset, and Set a bit in the bitmap.
end_comment

begin_macro
unit|bool
name|test
argument_list|(
argument|unsigned Idx
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
name|unsigned
name|ElementIndex
init|=
name|Idx
operator|/
name|ElementSize
decl_stmt|;
name|ElementListIter
name|ElementIter
init|=
name|FindLowerBound
argument_list|(
name|ElementIndex
argument_list|)
decl_stmt|;
comment|// If we can't find an element that is supposed to contain this bit, there
comment|// is nothing more to do.
if|if
condition|(
name|ElementIter
operator|==
name|Elements
operator|.
name|end
argument_list|()
operator|||
name|ElementIter
operator|->
name|index
argument_list|()
operator|!=
name|ElementIndex
condition|)
return|return
name|false
return|;
return|return
name|ElementIter
operator|->
name|test
argument_list|(
name|Idx
operator|%
name|ElementSize
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|reset
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|unsigned
name|ElementIndex
init|=
name|Idx
operator|/
name|ElementSize
decl_stmt|;
name|ElementListIter
name|ElementIter
init|=
name|FindLowerBound
argument_list|(
name|ElementIndex
argument_list|)
decl_stmt|;
comment|// If we can't find an element that is supposed to contain this bit, there
comment|// is nothing more to do.
if|if
condition|(
name|ElementIter
operator|==
name|Elements
operator|.
name|end
argument_list|()
operator|||
name|ElementIter
operator|->
name|index
argument_list|()
operator|!=
name|ElementIndex
condition|)
return|return;
name|ElementIter
operator|->
name|reset
argument_list|(
name|Idx
operator|%
name|ElementSize
argument_list|)
expr_stmt|;
comment|// When the element is zeroed out, delete it.
if|if
condition|(
name|ElementIter
operator|->
name|empty
argument_list|()
condition|)
block|{
operator|++
name|CurrElementIter
expr_stmt|;
name|Elements
operator|.
name|erase
argument_list|(
name|ElementIter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|unsigned
name|ElementIndex
init|=
name|Idx
operator|/
name|ElementSize
decl_stmt|;
name|ElementListIter
name|ElementIter
decl_stmt|;
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
block|{
name|ElementIter
operator|=
name|Elements
operator|.
name|emplace
argument_list|(
name|Elements
operator|.
name|end
argument_list|()
argument_list|,
name|ElementIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ElementIter
operator|=
name|FindLowerBound
argument_list|(
name|ElementIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ElementIter
operator|==
name|Elements
operator|.
name|end
argument_list|()
operator|||
name|ElementIter
operator|->
name|index
argument_list|()
operator|!=
name|ElementIndex
condition|)
block|{
comment|// We may have hit the beginning of our SparseBitVector, in which case,
comment|// we may need to insert right after this element, which requires moving
comment|// the current iterator forward one, because insert does insert before.
if|if
condition|(
name|ElementIter
operator|!=
name|Elements
operator|.
name|end
argument_list|()
operator|&&
name|ElementIter
operator|->
name|index
argument_list|()
operator|<
name|ElementIndex
condition|)
operator|++
name|ElementIter
expr_stmt|;
name|ElementIter
operator|=
name|Elements
operator|.
name|emplace
argument_list|(
name|ElementIter
argument_list|,
name|ElementIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|CurrElementIter
operator|=
name|ElementIter
expr_stmt|;
name|ElementIter
operator|->
name|set
argument_list|(
name|Idx
operator|%
name|ElementSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|test_and_set
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|bool
name|old
init|=
name|test
argument_list|(
name|Idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
block|{
name|set
argument_list|(
name|Idx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SparseBitVector
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SparseBitVector
operator|&
name|RHS
operator|)
specifier|const
block|{
name|ElementListConstIter
name|Iter1
operator|=
name|Elements
operator|.
name|begin
argument_list|()
block|;
name|ElementListConstIter
name|Iter2
operator|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
block|;
for|for
control|(
init|;
name|Iter1
operator|!=
name|Elements
operator|.
name|end
argument_list|()
operator|&&
name|Iter2
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|;
operator|++
name|Iter1
operator|,
operator|++
name|Iter2
control|)
block|{
if|if
condition|(
operator|*
name|Iter1
operator|!=
operator|*
name|Iter2
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Iter1
operator|==
name|Elements
operator|.
name|end
argument_list|()
operator|&&
name|Iter2
operator|==
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|// Union our bitmap with the RHS and return true if we changed.
end_comment

begin_expr_stmt
unit|bool
name|operator
operator||=
operator|(
specifier|const
name|SparseBitVector
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
name|false
return|;
name|bool
name|changed
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ElementListIter
name|Iter1
init|=
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ElementListConstIter
name|Iter2
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// If RHS is empty, we are done
end_comment

begin_if
if|if
condition|(
name|RHS
operator|.
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
end_if

begin_while
while|while
condition|(
name|Iter2
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|==
name|Elements
operator|.
name|end
argument_list|()
operator|||
name|Iter1
operator|->
name|index
argument_list|()
operator|>
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
name|Elements
operator|.
name|insert
argument_list|(
name|Iter1
argument_list|,
operator|*
name|Iter2
argument_list|)
expr_stmt|;
operator|++
name|Iter2
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|==
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
name|changed
operator||=
name|Iter1
operator|->
name|unionWith
argument_list|(
operator|*
name|Iter2
argument_list|)
expr_stmt|;
operator|++
name|Iter1
expr_stmt|;
operator|++
name|Iter2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|Iter1
expr_stmt|;
block|}
block|}
end_while

begin_expr_stmt
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|changed
return|;
end_return

begin_comment
unit|}
comment|// Intersect our bitmap with the RHS and return true if ours changed.
end_comment

begin_expr_stmt
unit|bool
name|operator
operator|&=
operator|(
specifier|const
name|SparseBitVector
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
return|return
name|false
return|;
name|bool
name|changed
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ElementListIter
name|Iter1
init|=
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ElementListConstIter
name|Iter2
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Check if both bitmaps are empty.
end_comment

begin_if
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
operator|&&
name|RHS
operator|.
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
end_if

begin_comment
comment|// Loop through, intersecting as we go, erasing elements when necessary.
end_comment

begin_while
while|while
condition|(
name|Iter2
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|==
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|>
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
operator|++
name|Iter2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|==
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
name|bool
name|BecameZero
decl_stmt|;
name|changed
operator||=
name|Iter1
operator|->
name|intersectWith
argument_list|(
operator|*
name|Iter2
argument_list|,
name|BecameZero
argument_list|)
expr_stmt|;
if|if
condition|(
name|BecameZero
condition|)
block|{
name|ElementListIter
name|IterTmp
init|=
name|Iter1
decl_stmt|;
operator|++
name|Iter1
expr_stmt|;
name|Elements
operator|.
name|erase
argument_list|(
name|IterTmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|Iter1
expr_stmt|;
block|}
operator|++
name|Iter2
expr_stmt|;
block|}
else|else
block|{
name|ElementListIter
name|IterTmp
init|=
name|Iter1
decl_stmt|;
operator|++
name|Iter1
expr_stmt|;
name|Elements
operator|.
name|erase
argument_list|(
name|IterTmp
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
end_while

begin_if
if|if
condition|(
name|Iter1
operator|!=
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|Elements
operator|.
name|erase
argument_list|(
name|Iter1
argument_list|,
name|Elements
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|changed
return|;
end_return

begin_comment
unit|}
comment|// Intersect our bitmap with the complement of the RHS and return true
end_comment

begin_comment
comment|// if ours changed.
end_comment

begin_macro
unit|bool
name|intersectWithComplement
argument_list|(
argument|const SparseBitVector&RHS
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS
condition|)
block|{
if|if
condition|(
operator|!
name|empty
argument_list|()
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|ElementListIter
name|Iter1
init|=
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
name|ElementListConstIter
name|Iter2
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|// If either our bitmap or RHS is empty, we are done
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
operator|||
name|RHS
operator|.
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Loop through, intersecting as we go, erasing elements when necessary.
while|while
condition|(
name|Iter2
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|==
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|>
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
operator|++
name|Iter2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|==
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
name|bool
name|BecameZero
decl_stmt|;
name|changed
operator||=
name|Iter1
operator|->
name|intersectWithComplement
argument_list|(
operator|*
name|Iter2
argument_list|,
name|BecameZero
argument_list|)
expr_stmt|;
if|if
condition|(
name|BecameZero
condition|)
block|{
name|ElementListIter
name|IterTmp
init|=
name|Iter1
decl_stmt|;
operator|++
name|Iter1
expr_stmt|;
name|Elements
operator|.
name|erase
argument_list|(
name|IterTmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|Iter1
expr_stmt|;
block|}
operator|++
name|Iter2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|Iter1
expr_stmt|;
block|}
block|}
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_block

begin_decl_stmt
name|bool
name|intersectWithComplement
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|intersectWithComplement
argument_list|(
operator|*
name|RHS
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//  Three argument version of intersectWithComplement.
end_comment

begin_comment
comment|//  Result of RHS1& ~RHS2 is stored into this bitmap.
end_comment

begin_decl_stmt
name|void
name|intersectWithComplement
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS1
argument_list|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS2
argument_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|RHS1
condition|)
block|{
name|intersectWithComplement
argument_list|(
name|RHS2
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
operator|&
name|RHS2
condition|)
block|{
name|SparseBitVector
name|RHS2Copy
parameter_list|(
name|RHS2
parameter_list|)
function_decl|;
name|intersectWithComplement
argument_list|(
name|RHS1
argument_list|,
name|RHS2Copy
argument_list|)
expr_stmt|;
return|return;
block|}
name|Elements
operator|.
name|clear
argument_list|()
expr_stmt|;
name|CurrElementIter
operator|=
name|Elements
operator|.
name|begin
argument_list|()
expr_stmt|;
name|ElementListConstIter
name|Iter1
init|=
name|RHS1
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
name|ElementListConstIter
name|Iter2
init|=
name|RHS2
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|// If RHS1 is empty, we are done
comment|// If RHS2 is empty, we still have to copy RHS1
if|if
condition|(
name|RHS1
operator|.
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return;
comment|// Loop through, intersecting as we go, erasing elements when necessary.
while|while
condition|(
name|Iter2
operator|!=
name|RHS2
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|==
name|RHS1
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
return|return;
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|>
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
operator|++
name|Iter2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|==
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
name|bool
name|BecameZero
init|=
name|false
decl_stmt|;
name|Elements
operator|.
name|emplace_back
argument_list|(
name|Iter1
operator|->
name|index
argument_list|()
argument_list|)
expr_stmt|;
name|Elements
operator|.
name|back
argument_list|()
operator|.
name|intersectWithComplement
argument_list|(
operator|*
name|Iter1
argument_list|,
operator|*
name|Iter2
argument_list|,
name|BecameZero
argument_list|)
expr_stmt|;
if|if
condition|(
name|BecameZero
condition|)
name|Elements
operator|.
name|pop_back
argument_list|()
expr_stmt|;
operator|++
name|Iter1
expr_stmt|;
operator|++
name|Iter2
expr_stmt|;
block|}
else|else
block|{
name|Elements
operator|.
name|push_back
argument_list|(
operator|*
name|Iter1
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// copy the remaining elements
name|std
operator|::
name|copy
argument_list|(
name|Iter1
argument_list|,
name|RHS1
operator|.
name|Elements
operator|.
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|Elements
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|intersectWithComplement
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS1
argument_list|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS2
argument_list|)
block|{
name|intersectWithComplement
argument_list|(
operator|*
name|RHS1
argument_list|,
operator|*
name|RHS2
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|intersects
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|intersects
argument_list|(
operator|*
name|RHS
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Return true if we share any bits in common with RHS
end_comment

begin_decl_stmt
name|bool
name|intersects
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
argument_list|)
decl|const
block|{
name|ElementListConstIter
name|Iter1
init|=
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
name|ElementListConstIter
name|Iter2
init|=
name|RHS
operator|.
name|Elements
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|// Check if both bitmaps are empty.
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
operator|&&
name|RHS
operator|.
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Loop through, intersecting stopping when we hit bits in common.
while|while
condition|(
name|Iter2
operator|!=
name|RHS
operator|.
name|Elements
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|==
name|Elements
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|>
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
operator|++
name|Iter2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Iter1
operator|->
name|index
argument_list|()
operator|==
name|Iter2
operator|->
name|index
argument_list|()
condition|)
block|{
if|if
condition|(
name|Iter1
operator|->
name|intersects
argument_list|(
operator|*
name|Iter2
argument_list|)
condition|)
return|return
name|true
return|;
operator|++
name|Iter1
expr_stmt|;
operator|++
name|Iter2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|Iter1
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Return true iff all bits set in this SparseBitVector are
end_comment

begin_comment
comment|// also set in RHS.
end_comment

begin_decl_stmt
name|bool
name|contains
argument_list|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
argument_list|)
decl|const
block|{
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|Result
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|Result
operator|&=
name|RHS
expr_stmt|;
return|return
operator|(
name|Result
operator|==
name|RHS
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Return the first set bit in the bitmap.  Return -1 if no bits are set.
end_comment

begin_expr_stmt
name|int
name|find_first
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|&
name|First
operator|=
operator|*
operator|(
name|Elements
operator|.
name|begin
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|First
operator|.
name|index
argument_list|()
operator|*
name|ElementSize
operator|)
operator|+
name|First
operator|.
name|find_first
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|// Return the last set bit in the bitmap.  Return -1 if no bits are set.
end_comment

begin_macro
unit|int
name|find_last
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|Elements
operator|.
name|empty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|SparseBitVectorElement
operator|<
name|ElementSize
operator|>
operator|&
name|Last
operator|=
operator|*
operator|(
name|Elements
operator|.
name|rbegin
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|Last
operator|.
name|index
argument_list|()
operator|*
name|ElementSize
operator|)
operator|+
name|Last
operator|.
name|find_last
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|// Return true if the SparseBitVector is empty
end_comment

begin_macro
unit|bool
name|empty
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|Elements
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|count
argument_list|()
specifier|const
block|{
name|unsigned
name|BitCount
operator|=
literal|0
block|;
for|for
control|(
name|ElementListConstIter
name|Iter
init|=
name|Elements
operator|.
name|begin
argument_list|()
init|;
name|Iter
operator|!=
name|Elements
operator|.
name|end
argument_list|()
condition|;
operator|++
name|Iter
control|)
name|BitCount
operator|+=
name|Iter
operator|->
name|count
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|BitCount
return|;
end_return

begin_macro
unit|}    iterator
name|begin
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|true
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Convenience functions to allow Or and And without dereferencing in the user
end_comment

begin_comment
comment|// code.
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|bool
name|operator
operator||=
operator|(
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS
operator|)
block|{
return|return
name|LHS
operator||=
operator|*
name|RHS
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|bool
name|operator
operator||=
operator|(
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|->
name|operator
operator||=
operator|(
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|bool
name|operator
operator|&=
operator|(
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|->
name|operator
operator|&=
operator|(
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|bool
name|operator
operator|&=
operator|(
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|*
name|RHS
operator|)
block|{
return|return
name|LHS
operator|&=
operator|*
name|RHS
return|;
block|}
end_expr_stmt

begin_comment
comment|// Convenience functions for infix union, intersection, difference operators.
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|operator
operator||
operator|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
operator|)
block|{
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|Result
argument_list|(
name|LHS
argument_list|)
block|;
name|Result
operator||=
name|RHS
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|operator
operator|&
operator|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
operator|)
block|{
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|Result
argument_list|(
name|LHS
argument_list|)
block|;
name|Result
operator|&=
name|RHS
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
specifier|inline
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|operator
operator|-
operator|(
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|LHS
operator|,
specifier|const
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|&
name|RHS
operator|)
block|{
name|SparseBitVector
operator|<
name|ElementSize
operator|>
name|Result
block|;
name|Result
operator|.
name|intersectWithComplement
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_comment
comment|// Dump a SparseBitVector to a stream
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|ElementSize
operator|>
name|void
name|dump
argument_list|(
argument|const SparseBitVector<ElementSize>&LHS
argument_list|,
argument|raw_ostream&out
argument_list|)
block|{
name|out
operator|<<
literal|"["
block|;
name|typename
name|SparseBitVector
operator|<
name|ElementSize
operator|>
operator|::
name|iterator
name|bi
operator|=
name|LHS
operator|.
name|begin
argument_list|()
block|,
name|be
operator|=
name|LHS
operator|.
name|end
argument_list|()
block|;
if|if
condition|(
name|bi
operator|!=
name|be
condition|)
block|{
name|out
operator|<<
operator|*
name|bi
expr_stmt|;
for|for
control|(
operator|++
name|bi
init|;
name|bi
operator|!=
name|be
condition|;
operator|++
name|bi
control|)
block|{
name|out
operator|<<
literal|" "
operator|<<
operator|*
name|bi
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   out
operator|<<
literal|"]\n"
expr_stmt|;
end_expr_stmt

begin_comment
unit|}  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_SPARSEBITVECTOR_H
end_comment

end_unit

