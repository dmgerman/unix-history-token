begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the DenseMap class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_DENSEMAP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_DENSEMAP_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/EpochTracker.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|detail
block|{
comment|// We extend a pair to allow users to override the bucket type with their own
comment|// implementation without requiring two members.
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|>
expr|struct
name|DenseMapPair
operator|:
name|public
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
block|{
name|KeyT
operator|&
name|getFirst
argument_list|()
block|{
return|return
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
operator|::
name|first
return|;
block|}
specifier|const
name|KeyT
operator|&
name|getFirst
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
operator|::
name|first
return|;
block|}
name|ValueT
operator|&
name|getSecond
argument_list|()
block|{
return|return
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
operator|::
name|second
return|;
block|}
specifier|const
name|ValueT
operator|&
name|getSecond
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|pair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
operator|::
name|second
return|;
block|}
expr|}
block|;  }
comment|// end namespace detail
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|=
name|DenseMapInfo
operator|<
name|KeyT
operator|>
operator|,
name|typename
name|Bucket
operator|=
name|detail
operator|::
name|DenseMapPair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>
operator|,
name|bool
name|IsConst
operator|=
name|false
operator|>
name|class
name|DenseMapIterator
expr_stmt|;
name|template
operator|<
name|typename
name|DerivedT
operator|,
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|,
name|typename
name|BucketT
operator|>
name|class
name|DenseMapBase
operator|:
name|public
name|DebugEpochBase
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|using
name|const_arg_type_t
operator|=
name|typename
name|const_pointer_or_const_ref
operator|<
name|T
operator|>
operator|::
name|type
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
typedef|typedef
name|KeyT
name|key_type
typedef|;
typedef|typedef
name|ValueT
name|mapped_type
typedef|;
typedef|typedef
name|BucketT
name|value_type
typedef|;
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
name|iterator
expr_stmt|;
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|,
name|true
operator|>
name|const_iterator
expr_stmt|;
specifier|inline
name|iterator
name|begin
parameter_list|()
block|{
comment|// When the map is empty, avoid the overhead of AdvancePastEmptyBuckets().
return|return
name|empty
argument_list|()
condition|?
name|end
argument_list|()
else|:
name|iterator
argument_list|(
name|getBuckets
argument_list|()
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
specifier|inline
name|iterator
name|end
parameter_list|()
block|{
return|return
name|iterator
argument_list|(
name|getBucketsEnd
argument_list|()
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
block|}
specifier|inline
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|empty
argument_list|()
operator|?
name|end
argument_list|()
operator|:
name|const_iterator
argument_list|(
name|getBuckets
argument_list|()
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
specifier|inline
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|getBucketsEnd
argument_list|()
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
block|}
name|LLVM_NODISCARD
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|getNumEntries
argument_list|()
operator|==
literal|0
return|;
block|}
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|getNumEntries
argument_list|()
return|;
block|}
comment|/// Grow the densemap so that it can contain at least \p NumEntries items
comment|/// before resizing again.
name|void
name|reserve
parameter_list|(
name|size_type
name|NumEntries
parameter_list|)
block|{
name|auto
name|NumBuckets
init|=
name|getMinBucketToReserveForEntries
argument_list|(
name|NumEntries
argument_list|)
decl_stmt|;
name|incrementEpoch
argument_list|()
expr_stmt|;
if|if
condition|(
name|NumBuckets
operator|>
name|getNumBuckets
argument_list|()
condition|)
name|grow
argument_list|(
name|NumBuckets
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|incrementEpoch
argument_list|()
expr_stmt|;
if|if
condition|(
name|getNumEntries
argument_list|()
operator|==
literal|0
operator|&&
name|getNumTombstones
argument_list|()
operator|==
literal|0
condition|)
return|return;
comment|// If the capacity of the array is huge, and the # elements used is small,
comment|// shrink the array.
if|if
condition|(
name|getNumEntries
argument_list|()
operator|*
literal|4
operator|<
name|getNumBuckets
argument_list|()
operator|&&
name|getNumBuckets
argument_list|()
operator|>
literal|64
condition|)
block|{
name|shrink_and_clear
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|,
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
name|unsigned
name|NumEntries
init|=
name|getNumEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|getBuckets
argument_list|()
init|,
modifier|*
name|E
init|=
name|getBucketsEnd
argument_list|()
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
name|P
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
operator|--
name|NumEntries
expr_stmt|;
block|}
name|P
operator|->
name|getFirst
argument_list|()
operator|=
name|EmptyKey
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|NumEntries
operator|==
literal|0
operator|&&
literal|"Node count imbalance!"
argument_list|)
expr_stmt|;
name|setNumEntries
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setNumTombstones
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/// Return 1 if the specified key is in the map, 0 otherwise.
name|size_type
name|count
argument_list|(
name|const_arg_type_t
operator|<
name|KeyT
operator|>
name|Val
argument_list|)
decl|const
block|{
specifier|const
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
return|return
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
name|iterator
name|find
argument_list|(
name|const_arg_type_t
operator|<
name|KeyT
operator|>
name|Val
argument_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|find
argument_list|(
name|const_arg_type_t
operator|<
name|KeyT
operator|>
name|Val
argument_list|)
decl|const
block|{
specifier|const
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|const_iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
comment|/// Alternate version of find() which allows a different, and possibly
comment|/// less expensive, key type.
comment|/// The DenseMapInfo is responsible for supplying methods
comment|/// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key
comment|/// type used.
name|template
operator|<
name|class
name|LookupKeyT
operator|>
name|iterator
name|find_as
argument_list|(
argument|const LookupKeyT&Val
argument_list|)
block|{
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|LookupKeyT
operator|>
name|const_iterator
name|find_as
argument_list|(
argument|const LookupKeyT&Val
argument_list|)
specifier|const
block|{
specifier|const
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|const_iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
return|;
return|return
name|end
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// lookup - Return the entry for the specified key, or a default
end_comment

begin_comment
comment|/// constructed value if no such entry exists.
end_comment

begin_decl_stmt
name|ValueT
name|lookup
argument_list|(
name|const_arg_type_t
operator|<
name|KeyT
operator|>
name|Val
argument_list|)
decl|const
block|{
specifier|const
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|TheBucket
operator|->
name|getSecond
argument_list|()
return|;
return|return
name|ValueT
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|// Inserts key,value pair into the map if the key isn't already in the map.
end_comment

begin_comment
comment|// If the key is already in the map, it returns false and doesn't update the
end_comment

begin_comment
comment|// value.
end_comment

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|const std::pair<KeyT
argument_list|,
argument|ValueT>&KV
argument_list|)
block|{
return|return
name|try_emplace
argument_list|(
name|KV
operator|.
name|first
argument_list|,
name|KV
operator|.
name|second
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Inserts key,value pair into the map if the key isn't already in the map.
end_comment

begin_comment
comment|// If the key is already in the map, it returns false and doesn't update the
end_comment

begin_comment
comment|// value.
end_comment

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|std::pair<KeyT
argument_list|,
argument|ValueT>&&KV
argument_list|)
block|{
return|return
name|try_emplace
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|KV
operator|.
name|first
argument_list|)
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|KV
operator|.
name|second
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Inserts key,value pair into the map if the key isn't already in the map.
end_comment

begin_comment
comment|// The value is constructed in-place if the key is not in the map, otherwise
end_comment

begin_comment
comment|// it is not moved.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|Ts
operator|>
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|try_emplace
argument_list|(
argument|KeyT&&Key
argument_list|,
argument|Ts&&... Args
argument_list|)
block|{
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
comment|// Already in map.
comment|// Otherwise, insert the new element.
name|TheBucket
operator|=
name|InsertIntoBucket
argument_list|(
name|TheBucket
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Key
argument_list|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Ts
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Inserts key,value pair into the map if the key isn't already in the map.
end_comment

begin_comment
comment|// The value is constructed in-place if the key is not in the map, otherwise
end_comment

begin_comment
comment|// it is not moved.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
operator|...
name|Ts
operator|>
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|try_emplace
argument_list|(
argument|const KeyT&Key
argument_list|,
argument|Ts&&... Args
argument_list|)
block|{
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
comment|// Already in map.
comment|// Otherwise, insert the new element.
name|TheBucket
operator|=
name|InsertIntoBucket
argument_list|(
name|TheBucket
argument_list|,
name|Key
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Ts
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// Alternate version of insert() which allows a different, and possibly
end_comment

begin_comment
comment|/// less expensive, key type.
end_comment

begin_comment
comment|/// The DenseMapInfo is responsible for supplying methods
end_comment

begin_comment
comment|/// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key
end_comment

begin_comment
comment|/// type used.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|LookupKeyT
operator|>
name|std
operator|::
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert_as
argument_list|(
argument|std::pair<KeyT
argument_list|,
argument|ValueT>&&KV
argument_list|,
argument|const LookupKeyT&Val
argument_list|)
block|{
name|BucketT
operator|*
name|TheBucket
block|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|false
argument_list|)
return|;
comment|// Already in map.
comment|// Otherwise, insert the new element.
name|TheBucket
operator|=
name|InsertIntoBucketWithLookup
argument_list|(
name|TheBucket
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|KV
operator|.
name|first
argument_list|)
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|KV
operator|.
name|second
argument_list|)
argument_list|,
name|Val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|iterator
argument_list|(
name|TheBucket
argument_list|,
name|getBucketsEnd
argument_list|()
argument_list|,
operator|*
name|this
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// insert - Range insertion of pairs.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|InputIt
operator|>
name|void
name|insert
argument_list|(
argument|InputIt I
argument_list|,
argument|InputIt E
argument_list|)
block|{
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|insert
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
name|bool
name|erase
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Val
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
operator|!
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
name|false
return|;
comment|// not in map.
name|TheBucket
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
name|TheBucket
operator|->
name|getFirst
argument_list|()
operator|=
name|getTombstoneKey
argument_list|()
expr_stmt|;
name|decrementNumEntries
argument_list|()
expr_stmt|;
name|incrementNumTombstones
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
init|=
operator|&
operator|*
name|I
decl_stmt|;
name|TheBucket
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
name|TheBucket
operator|->
name|getFirst
argument_list|()
operator|=
name|getTombstoneKey
argument_list|()
expr_stmt|;
name|decrementNumEntries
argument_list|()
expr_stmt|;
name|incrementNumTombstones
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|value_type
modifier|&
name|FindAndConstruct
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Key
parameter_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
operator|*
name|TheBucket
return|;
return|return
operator|*
name|InsertIntoBucket
argument_list|(
name|TheBucket
argument_list|,
name|Key
argument_list|)
return|;
block|}
end_function

begin_function
name|ValueT
modifier|&
name|operator
function|[]
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|FindAndConstruct
argument_list|(
name|Key
argument_list|)
operator|.
name|second
return|;
block|}
end_function

begin_decl_stmt
name|value_type
modifier|&
name|FindAndConstruct
argument_list|(
name|KeyT
operator|&&
name|Key
argument_list|)
block|{
name|BucketT
modifier|*
name|TheBucket
decl_stmt|;
if|if
condition|(
name|LookupBucketFor
argument_list|(
name|Key
argument_list|,
name|TheBucket
argument_list|)
condition|)
return|return
operator|*
name|TheBucket
return|;
return|return
operator|*
name|InsertIntoBucket
argument_list|(
name|TheBucket
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Key
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|ValueT
modifier|&
name|operator
index|[]
argument_list|(
name|KeyT
operator|&&
name|Key
argument_list|)
block|{
return|return
name|FindAndConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Key
argument_list|)
argument_list|)
operator|.
name|second
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isPointerIntoBucketsArray - Return true if the specified pointer points
end_comment

begin_comment
comment|/// somewhere into the DenseMap's array of buckets (i.e. either to a key or
end_comment

begin_comment
comment|/// value in the DenseMap).
end_comment

begin_decl_stmt
name|bool
name|isPointerIntoBucketsArray
argument_list|(
specifier|const
name|void
operator|*
name|Ptr
argument_list|)
decl|const
block|{
return|return
name|Ptr
operator|>=
name|getBuckets
argument_list|()
operator|&&
name|Ptr
operator|<
name|getBucketsEnd
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets
end_comment

begin_comment
comment|/// array.  In conjunction with the previous method, this can be used to
end_comment

begin_comment
comment|/// determine whether an insertion caused the DenseMap to reallocate.
end_comment

begin_expr_stmt
specifier|const
name|void
operator|*
name|getPointerIntoBucketsArray
argument_list|()
specifier|const
block|{
return|return
name|getBuckets
argument_list|()
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|DenseMapBase
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|destroyAll
parameter_list|()
block|{
if|if
condition|(
name|getNumBuckets
argument_list|()
operator|==
literal|0
condition|)
comment|// Nothing to do.
return|return;
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|,
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|getBuckets
argument_list|()
init|,
modifier|*
name|E
init|=
name|getBucketsEnd
argument_list|()
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
name|P
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
name|P
operator|->
name|getFirst
argument_list|()
operator|.
operator|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|initEmpty
parameter_list|()
block|{
name|setNumEntries
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setNumTombstones
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|getNumBuckets
argument_list|()
operator|&
operator|(
name|getNumBuckets
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
literal|"# initial buckets must be a power of two!"
argument_list|)
expr_stmt|;
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|B
init|=
name|getBuckets
argument_list|()
init|,
modifier|*
name|E
init|=
name|getBucketsEnd
argument_list|()
init|;
name|B
operator|!=
name|E
condition|;
operator|++
name|B
control|)
operator|::
name|new
argument_list|(
argument|&B->getFirst()
argument_list|)
name|KeyT
argument_list|(
name|EmptyKey
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Returns the number of buckets to allocate to ensure that the DenseMap can
end_comment

begin_comment
comment|/// accommodate \p NumEntries without need to grow().
end_comment

begin_function
name|unsigned
name|getMinBucketToReserveForEntries
parameter_list|(
name|unsigned
name|NumEntries
parameter_list|)
block|{
comment|// Ensure that "NumEntries * 4< NumBuckets * 3"
if|if
condition|(
name|NumEntries
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// +1 is required because of the strict equality.
comment|// For example if NumEntries is 48, we need to return 401.
return|return
name|NextPowerOf2
argument_list|(
name|NumEntries
operator|*
literal|4
operator|/
literal|3
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|moveFromOldBuckets
parameter_list|(
name|BucketT
modifier|*
name|OldBucketsBegin
parameter_list|,
name|BucketT
modifier|*
name|OldBucketsEnd
parameter_list|)
block|{
name|initEmpty
argument_list|()
expr_stmt|;
comment|// Insert all the old elements.
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|B
init|=
name|OldBucketsBegin
init|,
modifier|*
name|E
init|=
name|OldBucketsEnd
init|;
name|B
operator|!=
name|E
condition|;
operator|++
name|B
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|B
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
comment|// Insert the key/value into the new table.
name|BucketT
modifier|*
name|DestBucket
decl_stmt|;
name|bool
name|FoundVal
init|=
name|LookupBucketFor
argument_list|(
name|B
operator|->
name|getFirst
argument_list|()
argument_list|,
name|DestBucket
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|FoundVal
expr_stmt|;
comment|// silence warning.
name|assert
argument_list|(
operator|!
name|FoundVal
operator|&&
literal|"Key already in new map?"
argument_list|)
expr_stmt|;
name|DestBucket
operator|->
name|getFirst
argument_list|()
operator|=
name|std
operator|::
name|move
argument_list|(
name|B
operator|->
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
operator|::
name|new
argument_list|(
argument|&DestBucket->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|B
operator|->
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|incrementNumEntries
argument_list|()
expr_stmt|;
comment|// Free the value.
name|B
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
name|B
operator|->
name|getFirst
argument_list|()
operator|.
operator|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|OtherBaseT
operator|>
name|void
name|copyFrom
argument_list|(
argument|const DenseMapBase<OtherBaseT
argument_list|,
argument|KeyT
argument_list|,
argument|ValueT
argument_list|,
argument|KeyInfoT
argument_list|,
argument|BucketT>&other
argument_list|)
block|{
name|assert
argument_list|(
operator|&
name|other
operator|!=
name|this
argument_list|)
block|;
name|assert
argument_list|(
name|getNumBuckets
argument_list|()
operator|==
name|other
operator|.
name|getNumBuckets
argument_list|()
argument_list|)
block|;
name|setNumEntries
argument_list|(
name|other
operator|.
name|getNumEntries
argument_list|()
argument_list|)
block|;
name|setNumTombstones
argument_list|(
name|other
operator|.
name|getNumTombstones
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|isPodLike
operator|<
name|KeyT
operator|>
operator|::
name|value
operator|&&
name|isPodLike
operator|<
name|ValueT
operator|>
operator|::
name|value
condition|)
name|memcpy
argument_list|(
name|getBuckets
argument_list|()
argument_list|,
name|other
operator|.
name|getBuckets
argument_list|()
argument_list|,
name|getNumBuckets
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getNumBuckets
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
operator|::
name|new
argument_list|(
argument|&getBuckets()[i].getFirst()
argument_list|)
name|KeyT
argument_list|(
name|other
operator|.
name|getBuckets
argument_list|()
index|[
name|i
index|]
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|getBuckets
argument_list|()
index|[
name|i
index|]
operator|.
name|getFirst
argument_list|()
argument_list|,
name|getEmptyKey
argument_list|()
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|getBuckets
argument_list|()
index|[
name|i
index|]
operator|.
name|getFirst
argument_list|()
argument_list|,
name|getTombstoneKey
argument_list|()
argument_list|)
condition|)
operator|::
name|new
argument_list|(
argument|&getBuckets()[i].getSecond()
argument_list|)
name|ValueT
argument_list|(
name|other
operator|.
name|getBuckets
argument_list|()
index|[
name|i
index|]
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
unit|}    static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyT
modifier|&
name|Val
parameter_list|)
block|{
return|return
name|KeyInfoT
operator|::
name|getHashValue
argument_list|(
name|Val
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|LookupKeyT
operator|>
specifier|static
name|unsigned
name|getHashValue
argument_list|(
argument|const LookupKeyT&Val
argument_list|)
block|{
return|return
name|KeyInfoT
operator|::
name|getHashValue
argument_list|(
name|Val
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|const
name|KeyT
name|getEmptyKey
parameter_list|()
block|{
name|static_assert
argument_list|(
name|std
operator|::
name|is_base_of
operator|<
name|DenseMapBase
argument_list|,
name|DerivedT
operator|>
operator|::
name|value
argument_list|,
literal|"Must pass the derived type to this template!"
argument_list|)
expr_stmt|;
return|return
name|KeyInfoT
operator|::
name|getEmptyKey
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|KeyT
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|KeyInfoT
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|unsigned
name|getNumEntries
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getNumEntries
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumEntries
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|setNumEntries
argument_list|(
name|Num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|incrementNumEntries
parameter_list|()
block|{
name|setNumEntries
argument_list|(
name|getNumEntries
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decrementNumEntries
parameter_list|()
block|{
name|setNumEntries
argument_list|(
name|getNumEntries
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getNumTombstones
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getNumTombstones
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumTombstones
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|setNumTombstones
argument_list|(
name|Num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|incrementNumTombstones
parameter_list|()
block|{
name|setNumTombstones
argument_list|(
name|getNumTombstones
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decrementNumTombstones
parameter_list|()
block|{
name|setNumTombstones
argument_list|(
name|getNumTombstones
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BucketT
operator|*
name|getBuckets
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getBuckets
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|BucketT
modifier|*
name|getBuckets
parameter_list|()
block|{
return|return
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getBuckets
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getNumBuckets
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getNumBuckets
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|BucketT
modifier|*
name|getBucketsEnd
parameter_list|()
block|{
return|return
name|getBuckets
argument_list|()
operator|+
name|getNumBuckets
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BucketT
operator|*
name|getBucketsEnd
argument_list|()
specifier|const
block|{
return|return
name|getBuckets
argument_list|()
operator|+
name|getNumBuckets
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|grow
parameter_list|(
name|unsigned
name|AtLeast
parameter_list|)
block|{
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|grow
argument_list|(
name|AtLeast
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shrink_and_clear
parameter_list|()
block|{
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|shrink_and_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyArg
operator|,
name|typename
operator|...
name|ValueArgs
operator|>
name|BucketT
operator|*
name|InsertIntoBucket
argument_list|(
argument|BucketT *TheBucket
argument_list|,
argument|KeyArg&&Key
argument_list|,
argument|ValueArgs&&... Values
argument_list|)
block|{
name|TheBucket
operator|=
name|InsertIntoBucketImpl
argument_list|(
name|Key
argument_list|,
name|Key
argument_list|,
name|TheBucket
argument_list|)
block|;
name|TheBucket
operator|->
name|getFirst
argument_list|()
operator|=
name|std
operator|::
name|forward
operator|<
name|KeyArg
operator|>
operator|(
name|Key
operator|)
block|;
operator|::
name|new
argument_list|(
argument|&TheBucket->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|forward
operator|<
name|ValueArgs
operator|>
operator|(
name|Values
operator|)
operator|...
argument_list|)
block|;
return|return
name|TheBucket
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|LookupKeyT
operator|>
name|BucketT
operator|*
name|InsertIntoBucketWithLookup
argument_list|(
argument|BucketT *TheBucket
argument_list|,
argument|KeyT&&Key
argument_list|,
argument|ValueT&&Value
argument_list|,
argument|LookupKeyT&Lookup
argument_list|)
block|{
name|TheBucket
operator|=
name|InsertIntoBucketImpl
argument_list|(
name|Key
argument_list|,
name|Lookup
argument_list|,
name|TheBucket
argument_list|)
block|;
name|TheBucket
operator|->
name|getFirst
argument_list|()
operator|=
name|std
operator|::
name|move
argument_list|(
name|Key
argument_list|)
block|;
operator|::
name|new
argument_list|(
argument|&TheBucket->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Value
argument_list|)
argument_list|)
block|;
return|return
name|TheBucket
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|LookupKeyT
operator|>
name|BucketT
operator|*
name|InsertIntoBucketImpl
argument_list|(
argument|const KeyT&Key
argument_list|,
argument|const LookupKeyT&Lookup
argument_list|,
argument|BucketT *TheBucket
argument_list|)
block|{
name|incrementEpoch
argument_list|()
block|;
comment|// If the load of the hash table is more than 3/4, or if fewer than 1/8 of
comment|// the buckets are empty (meaning that many are filled with tombstones),
comment|// grow the table.
comment|//
comment|// The later case is tricky.  For example, if we had one empty bucket with
comment|// tons of tombstones, failing lookups (e.g. for insertion) would have to
comment|// probe almost the entire table until it found the empty bucket.  If the
comment|// table completely filled with tombstones, no lookup would ever succeed,
comment|// causing infinite loops in lookup.
name|unsigned
name|NewNumEntries
operator|=
name|getNumEntries
argument_list|()
operator|+
literal|1
block|;
name|unsigned
name|NumBuckets
operator|=
name|getNumBuckets
argument_list|()
block|;
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|NewNumEntries
operator|*
literal|4
operator|>=
name|NumBuckets
operator|*
literal|3
argument_list|)
condition|)
block|{
name|this
operator|->
name|grow
argument_list|(
name|NumBuckets
operator|*
literal|2
argument_list|)
expr_stmt|;
name|LookupBucketFor
argument_list|(
name|Lookup
argument_list|,
name|TheBucket
argument_list|)
expr_stmt|;
name|NumBuckets
operator|=
name|getNumBuckets
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|LLVM_UNLIKELY
argument_list|(
name|NumBuckets
operator|-
operator|(
name|NewNumEntries
operator|+
name|getNumTombstones
argument_list|()
operator|)
operator|<=
name|NumBuckets
operator|/
literal|8
argument_list|)
condition|)
block|{
name|this
operator|->
name|grow
argument_list|(
name|NumBuckets
argument_list|)
expr_stmt|;
name|LookupBucketFor
argument_list|(
name|Lookup
argument_list|,
name|TheBucket
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_expr_stmt
name|assert
argument_list|(
name|TheBucket
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Only update the state after we've grown our bucket space appropriately
end_comment

begin_comment
comment|// so that when growing buckets we have self-consistent entry count.
end_comment

begin_expr_stmt
name|incrementNumEntries
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If we are writing over a tombstone, remember this.
end_comment

begin_decl_stmt
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|TheBucket
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
condition|)
name|decrementNumTombstones
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
name|TheBucket
return|;
end_return

begin_comment
unit|}
comment|/// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in
end_comment

begin_comment
comment|/// FoundBucket.  If the bucket contains the key and a value, this returns
end_comment

begin_comment
comment|/// true, otherwise it returns a bucket with an empty marker or tombstone and
end_comment

begin_comment
comment|/// returns false.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|LookupKeyT
operator|>
name|bool
name|LookupBucketFor
argument_list|(
argument|const LookupKeyT&Val
argument_list|,
argument|const BucketT *&FoundBucket
argument_list|)
specifier|const
block|{
specifier|const
name|BucketT
operator|*
name|BucketsPtr
operator|=
name|getBuckets
argument_list|()
block|;
specifier|const
name|unsigned
name|NumBuckets
operator|=
name|getNumBuckets
argument_list|()
block|;
if|if
condition|(
name|NumBuckets
operator|==
literal|0
condition|)
block|{
name|FoundBucket
operator|=
name|nullptr
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// FoundTombstone - Keep track of whether we find a tombstone while probing.
specifier|const
name|BucketT
operator|*
name|FoundTombstone
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|KeyT
name|EmptyKey
init|=
name|getEmptyKey
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|getTombstoneKey
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|assert
argument_list|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Val
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Val
argument_list|,
name|TombstoneKey
argument_list|)
operator|&&
literal|"Empty/Tombstone value shouldn't be inserted into map!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|BucketNo
init|=
name|getHashValue
argument_list|(
name|Val
argument_list|)
operator|&
operator|(
name|NumBuckets
operator|-
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ProbeAmt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|true
condition|)
block|{
specifier|const
name|BucketT
modifier|*
name|ThisBucket
init|=
name|BucketsPtr
operator|+
name|BucketNo
decl_stmt|;
comment|// Found Val's bucket?  If so, return it.
if|if
condition|(
name|LLVM_LIKELY
argument_list|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Val
argument_list|,
name|ThisBucket
operator|->
name|getFirst
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|FoundBucket
operator|=
name|ThisBucket
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// If we found an empty bucket, the key doesn't exist in the set.
comment|// Insert it and return the default value.
if|if
condition|(
name|LLVM_LIKELY
argument_list|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|ThisBucket
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
argument_list|)
condition|)
block|{
comment|// If we've already seen a tombstone while probing, fill it in instead
comment|// of the empty bucket we eventually probed to.
name|FoundBucket
operator|=
name|FoundTombstone
condition|?
name|FoundTombstone
else|:
name|ThisBucket
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// If this is a tombstone, remember it.  If Val ends up not in the map, we
comment|// prefer to return it than something that would require more probing.
if|if
condition|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|ThisBucket
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
operator|&&
operator|!
name|FoundTombstone
condition|)
name|FoundTombstone
operator|=
name|ThisBucket
expr_stmt|;
comment|// Remember the first tombstone found.
comment|// Otherwise, it's a hash collision or a tombstone, continue quadratic
comment|// probing.
name|BucketNo
operator|+=
name|ProbeAmt
operator|++
expr_stmt|;
name|BucketNo
operator|&=
operator|(
name|NumBuckets
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|LookupKeyT
operator|>
name|bool
name|LookupBucketFor
argument_list|(
argument|const LookupKeyT&Val
argument_list|,
argument|BucketT *&FoundBucket
argument_list|)
block|{
specifier|const
name|BucketT
operator|*
name|ConstFoundBucket
block|;
name|bool
name|Result
operator|=
name|const_cast
operator|<
specifier|const
name|DenseMapBase
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|LookupBucketFor
argument_list|(
name|Val
argument_list|,
name|ConstFoundBucket
argument_list|)
block|;
name|FoundBucket
operator|=
name|const_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|ConstFoundBucket
operator|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Return the approximate size (in bytes) of the actual map.
end_comment

begin_comment
comment|/// This is just the raw memory used by DenseMap.
end_comment

begin_comment
comment|/// If entries are pointers to objects, the size of the referenced objects
end_comment

begin_comment
comment|/// are not included.
end_comment

begin_expr_stmt
name|size_t
name|getMemorySize
argument_list|()
specifier|const
block|{
return|return
name|getNumBuckets
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|=
name|DenseMapInfo
operator|<
name|KeyT
operator|>
operator|,
name|typename
name|BucketT
operator|=
name|detail
operator|::
name|DenseMapPair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>>
name|class
name|DenseMap
operator|:
name|public
name|DenseMapBase
operator|<
name|DenseMap
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
block|{
comment|// Lift some types from the dependent base class into this class for
comment|// simplicity of referring to them.
typedef|typedef
name|DenseMapBase
operator|<
name|DenseMap
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
name|BaseT
expr_stmt|;
name|friend
name|class
name|DenseMapBase
operator|<
name|DenseMap
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BucketT
modifier|*
name|Buckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumEntries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumTombstones
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumBuckets
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Create a DenseMap wth an optional \p InitialReserve that guarantee that
end_comment

begin_comment
comment|/// this number of elements can be inserted in the map without grow()
end_comment

begin_function
name|explicit
name|DenseMap
parameter_list|(
name|unsigned
name|InitialReserve
init|=
literal|0
parameter_list|)
block|{
name|init
argument_list|(
name|InitialReserve
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DenseMap
argument_list|(
specifier|const
name|DenseMap
operator|&
name|other
argument_list|)
operator|:
name|BaseT
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|copyFrom
argument_list|(
name|other
argument_list|)
block|;   }
name|DenseMap
argument_list|(
name|DenseMap
operator|&&
name|other
argument_list|)
operator|:
name|BaseT
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|swap
argument_list|(
name|other
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|InputIt
operator|>
name|DenseMap
argument_list|(
argument|const InputIt&I
argument_list|,
argument|const InputIt&E
argument_list|)
block|{
name|init
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
argument_list|)
block|;
name|this
operator|->
name|insert
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
block|;   }
operator|~
name|DenseMap
argument_list|()
block|{
name|this
operator|->
name|destroyAll
argument_list|()
block|;
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
block|;   }
name|void
name|swap
argument_list|(
argument|DenseMap& RHS
argument_list|)
block|{
name|this
operator|->
name|incrementEpoch
argument_list|()
block|;
name|RHS
operator|.
name|incrementEpoch
argument_list|()
block|;
name|std
operator|::
name|swap
argument_list|(
name|Buckets
argument_list|,
name|RHS
operator|.
name|Buckets
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|NumEntries
argument_list|,
name|RHS
operator|.
name|NumEntries
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|NumTombstones
argument_list|,
name|RHS
operator|.
name|NumTombstones
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|NumBuckets
argument_list|,
name|RHS
operator|.
name|NumBuckets
argument_list|)
block|;   }
name|DenseMap
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DenseMap
operator|&
name|other
operator|)
block|{
if|if
condition|(
operator|&
name|other
operator|!=
name|this
condition|)
name|copyFrom
argument_list|(
name|other
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    DenseMap
operator|&
name|operator
operator|=
operator|(
name|DenseMap
operator|&&
name|other
operator|)
block|{
name|this
operator|->
name|destroyAll
argument_list|()
block|;
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
block|;
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|swap
argument_list|(
name|other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_function
name|void
name|copyFrom
parameter_list|(
specifier|const
name|DenseMap
modifier|&
name|other
parameter_list|)
block|{
name|this
operator|->
name|destroyAll
argument_list|()
expr_stmt|;
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
decl_stmt|;
if|if
condition|(
name|allocateBuckets
argument_list|(
name|other
operator|.
name|NumBuckets
argument_list|)
condition|)
block|{
name|this
operator|->
name|BaseT
operator|::
name|copyFrom
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NumEntries
operator|=
literal|0
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init
parameter_list|(
name|unsigned
name|InitNumEntries
parameter_list|)
block|{
name|auto
name|InitBuckets
init|=
name|BaseT
operator|::
name|getMinBucketToReserveForEntries
argument_list|(
name|InitNumEntries
argument_list|)
decl_stmt|;
if|if
condition|(
name|allocateBuckets
argument_list|(
name|InitBuckets
argument_list|)
condition|)
block|{
name|this
operator|->
name|BaseT
operator|::
name|initEmpty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|NumEntries
operator|=
literal|0
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|grow
parameter_list|(
name|unsigned
name|AtLeast
parameter_list|)
block|{
name|unsigned
name|OldNumBuckets
init|=
name|NumBuckets
decl_stmt|;
name|BucketT
modifier|*
name|OldBuckets
init|=
name|Buckets
decl_stmt|;
name|allocateBuckets
argument_list|(
name|std
operator|::
name|max
operator|<
name|unsigned
operator|>
operator|(
literal|64
operator|,
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|NextPowerOf2
argument_list|(
name|AtLeast
operator|-
literal|1
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Buckets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OldBuckets
condition|)
block|{
name|this
operator|->
name|BaseT
operator|::
name|initEmpty
argument_list|()
expr_stmt|;
return|return;
block|}
name|this
operator|->
name|moveFromOldBuckets
argument_list|(
name|OldBuckets
argument_list|,
name|OldBuckets
operator|+
name|OldNumBuckets
argument_list|)
expr_stmt|;
comment|// Free the old table.
name|operator
name|delete
argument_list|(
name|OldBuckets
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|shrink_and_clear
parameter_list|()
block|{
name|unsigned
name|OldNumEntries
init|=
name|NumEntries
decl_stmt|;
name|this
operator|->
name|destroyAll
argument_list|()
expr_stmt|;
comment|// Reduce the number of buckets.
name|unsigned
name|NewNumBuckets
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OldNumEntries
condition|)
name|NewNumBuckets
operator|=
name|std
operator|::
name|max
argument_list|(
literal|64
argument_list|,
literal|1
operator|<<
operator|(
name|Log2_32_Ceil
argument_list|(
name|OldNumEntries
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewNumBuckets
operator|==
name|NumBuckets
condition|)
block|{
name|this
operator|->
name|BaseT
operator|::
name|initEmpty
argument_list|()
expr_stmt|;
return|return;
block|}
name|operator
name|delete
argument_list|(
name|Buckets
argument_list|)
decl_stmt|;
name|init
argument_list|(
name|NewNumBuckets
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|unsigned
name|getNumEntries
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumEntries
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|NumEntries
operator|=
name|Num
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getNumTombstones
argument_list|()
specifier|const
block|{
return|return
name|NumTombstones
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumTombstones
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|NumTombstones
operator|=
name|Num
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|BucketT
operator|*
name|getBuckets
argument_list|()
specifier|const
block|{
return|return
name|Buckets
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getNumBuckets
argument_list|()
specifier|const
block|{
return|return
name|NumBuckets
return|;
block|}
end_expr_stmt

begin_function
name|bool
name|allocateBuckets
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|NumBuckets
operator|=
name|Num
expr_stmt|;
if|if
condition|(
name|NumBuckets
operator|==
literal|0
condition|)
block|{
name|Buckets
operator|=
name|nullptr
expr_stmt|;
return|return
name|false
return|;
block|}
name|Buckets
operator|=
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|NumBuckets
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|unsigned
name|InlineBuckets
operator|=
literal|4
operator|,
name|typename
name|KeyInfoT
operator|=
name|DenseMapInfo
operator|<
name|KeyT
operator|>
operator|,
name|typename
name|BucketT
operator|=
name|detail
operator|::
name|DenseMapPair
operator|<
name|KeyT
operator|,
name|ValueT
operator|>>
name|class
name|SmallDenseMap
operator|:
name|public
name|DenseMapBase
operator|<
name|SmallDenseMap
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|InlineBuckets
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
block|{
comment|// Lift some types from the dependent base class into this class for
comment|// simplicity of referring to them.
typedef|typedef
name|DenseMapBase
operator|<
name|SmallDenseMap
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
name|BaseT
expr_stmt|;
name|friend
name|class
name|DenseMapBase
operator|<
name|SmallDenseMap
operator|,
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|BucketT
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|static_assert
argument_list|(
name|isPowerOf2_64
argument_list|(
name|InlineBuckets
argument_list|)
argument_list|,
literal|"InlineBuckets must be a power of 2."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|Small
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumEntries
range|:
literal|31
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumTombstones
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|LargeRep
block|{
name|BucketT
modifier|*
name|Buckets
decl_stmt|;
name|unsigned
name|NumBuckets
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// A "union" of an inline bucket array and the struct representing
end_comment

begin_comment
comment|/// a large bucket. This union will be discriminated by the 'Small' bit.
end_comment

begin_expr_stmt
name|AlignedCharArrayUnion
operator|<
name|BucketT
index|[
name|InlineBuckets
index|]
operator|,
name|LargeRep
operator|>
name|storage
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function
name|explicit
name|SmallDenseMap
parameter_list|(
name|unsigned
name|NumInitBuckets
init|=
literal|0
parameter_list|)
block|{
name|init
argument_list|(
name|NumInitBuckets
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SmallDenseMap
argument_list|(
specifier|const
name|SmallDenseMap
operator|&
name|other
argument_list|)
operator|:
name|BaseT
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|copyFrom
argument_list|(
name|other
argument_list|)
block|;   }
name|SmallDenseMap
argument_list|(
name|SmallDenseMap
operator|&&
name|other
argument_list|)
operator|:
name|BaseT
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|swap
argument_list|(
name|other
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|InputIt
operator|>
name|SmallDenseMap
argument_list|(
argument|const InputIt&I
argument_list|,
argument|const InputIt&E
argument_list|)
block|{
name|init
argument_list|(
name|NextPowerOf2
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
argument_list|)
argument_list|)
block|;
name|this
operator|->
name|insert
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
block|;   }
operator|~
name|SmallDenseMap
argument_list|()
block|{
name|this
operator|->
name|destroyAll
argument_list|()
block|;
name|deallocateBuckets
argument_list|()
block|;   }
name|void
name|swap
argument_list|(
argument|SmallDenseMap& RHS
argument_list|)
block|{
name|unsigned
name|TmpNumEntries
operator|=
name|RHS
operator|.
name|NumEntries
block|;
name|RHS
operator|.
name|NumEntries
operator|=
name|NumEntries
block|;
name|NumEntries
operator|=
name|TmpNumEntries
block|;
name|std
operator|::
name|swap
argument_list|(
name|NumTombstones
argument_list|,
name|RHS
operator|.
name|NumTombstones
argument_list|)
block|;
specifier|const
name|KeyT
name|EmptyKey
operator|=
name|this
operator|->
name|getEmptyKey
argument_list|()
block|;
specifier|const
name|KeyT
name|TombstoneKey
operator|=
name|this
operator|->
name|getTombstoneKey
argument_list|()
block|;
if|if
condition|(
name|Small
operator|&&
name|RHS
operator|.
name|Small
condition|)
block|{
comment|// If we're swapping inline bucket arrays, we have to cope with some of
comment|// the tricky bits of DenseMap's storage system: the buckets are not
comment|// fully initialized. Thus we swap every key, but we may have
comment|// a one-directional move of the value.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|InlineBuckets
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|BucketT
modifier|*
name|LHSB
init|=
operator|&
name|getInlineBuckets
argument_list|()
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|RHSB
init|=
operator|&
name|RHS
operator|.
name|getInlineBuckets
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|bool
name|hasLHSValue
init|=
operator|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|LHSB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|LHSB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
operator|)
decl_stmt|;
name|bool
name|hasRHSValue
init|=
operator|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|RHSB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|RHSB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|hasLHSValue
operator|&&
name|hasRHSValue
condition|)
block|{
comment|// Swap together if we can...
name|std
operator|::
name|swap
argument_list|(
operator|*
name|LHSB
argument_list|,
operator|*
name|RHSB
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Swap separately and handle any assymetry.
name|std
operator|::
name|swap
argument_list|(
name|LHSB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|RHSB
operator|->
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|hasLHSValue
condition|)
block|{
operator|::
name|new
argument_list|(
argument|&RHSB->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|LHSB
operator|->
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LHSB
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasRHSValue
condition|)
block|{
operator|::
name|new
argument_list|(
argument|&LHSB->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHSB
operator|->
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|RHSB
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
end_if

begin_empty_stmt
unit|}       return
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|}     if
operator|(
operator|!
name|Small
operator|&&
operator|!
name|RHS
operator|.
name|Small
operator|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|getLargeRep
argument_list|()
operator|->
name|Buckets
argument_list|,
name|RHS
operator|.
name|getLargeRep
argument_list|()
operator|->
name|Buckets
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|getLargeRep
argument_list|()
operator|->
name|NumBuckets
argument_list|,
name|RHS
operator|.
name|getLargeRep
argument_list|()
operator|->
name|NumBuckets
argument_list|)
block|;
return|return;
block|}
end_expr_stmt

begin_decl_stmt
name|SmallDenseMap
modifier|&
name|SmallSide
init|=
name|Small
condition|?
operator|*
name|this
else|:
name|RHS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SmallDenseMap
modifier|&
name|LargeSide
init|=
name|Small
condition|?
name|RHS
else|:
operator|*
name|this
decl_stmt|;
end_decl_stmt

begin_comment
comment|// First stash the large side's rep and move the small side across.
end_comment

begin_decl_stmt
name|LargeRep
name|TmpRep
init|=
name|std
operator|::
name|move
argument_list|(
operator|*
name|LargeSide
operator|.
name|getLargeRep
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LargeSide
operator|.
name|getLargeRep
argument_list|()
operator|->
operator|~
name|LargeRep
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LargeSide
operator|.
name|Small
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_comment
comment|// This is similar to the standard move-from-old-buckets, but the bucket
end_comment

begin_comment
comment|// count hasn't actually rotated in this case. So we have to carefully
end_comment

begin_comment
comment|// move construct the keys and values into their new locations, but there
end_comment

begin_comment
comment|// is no need to re-hash things.
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|InlineBuckets
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|BucketT
modifier|*
name|NewB
init|=
operator|&
name|LargeSide
operator|.
name|getInlineBuckets
argument_list|()
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|OldB
init|=
operator|&
name|SmallSide
operator|.
name|getInlineBuckets
argument_list|()
index|[
name|i
index|]
decl_stmt|;
operator|::
name|new
argument_list|(
argument|&NewB->getFirst()
argument_list|)
name|KeyT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|OldB
operator|->
name|getFirst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|OldB
operator|->
name|getFirst
argument_list|()
operator|.
operator|~
name|KeyT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|NewB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|NewB
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
operator|::
name|new
argument_list|(
argument|&NewB->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|OldB
operator|->
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|OldB
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|// The hard part of moving the small buckets across is done, just move
end_comment

begin_comment
comment|// the TmpRep into its new home.
end_comment

begin_expr_stmt
name|SmallSide
operator|.
name|Small
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|SmallSide.getLargeRep()
argument_list|)
end_macro

begin_expr_stmt
name|LargeRep
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|TmpRep
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    SmallDenseMap
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallDenseMap
operator|&
name|other
operator|)
block|{
if|if
condition|(
operator|&
name|other
operator|!=
name|this
condition|)
name|copyFrom
argument_list|(
name|other
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    SmallDenseMap
operator|&
name|operator
operator|=
operator|(
name|SmallDenseMap
operator|&&
name|other
operator|)
block|{
name|this
operator|->
name|destroyAll
argument_list|()
block|;
name|deallocateBuckets
argument_list|()
block|;
name|init
argument_list|(
literal|0
argument_list|)
block|;
name|swap
argument_list|(
name|other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_function
name|void
name|copyFrom
parameter_list|(
specifier|const
name|SmallDenseMap
modifier|&
name|other
parameter_list|)
block|{
name|this
operator|->
name|destroyAll
argument_list|()
expr_stmt|;
name|deallocateBuckets
argument_list|()
expr_stmt|;
name|Small
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|getNumBuckets
argument_list|()
operator|>
name|InlineBuckets
condition|)
block|{
name|Small
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|getLargeRep()
argument_list|)
name|LargeRep
argument_list|(
name|allocateBuckets
argument_list|(
name|other
operator|.
name|getNumBuckets
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|->
name|BaseT
operator|::
name|copyFrom
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init
parameter_list|(
name|unsigned
name|InitBuckets
parameter_list|)
block|{
name|Small
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|InitBuckets
operator|>
name|InlineBuckets
condition|)
block|{
name|Small
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|getLargeRep()
argument_list|)
name|LargeRep
argument_list|(
name|allocateBuckets
argument_list|(
name|InitBuckets
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|->
name|BaseT
operator|::
name|initEmpty
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|grow
parameter_list|(
name|unsigned
name|AtLeast
parameter_list|)
block|{
if|if
condition|(
name|AtLeast
operator|>=
name|InlineBuckets
condition|)
name|AtLeast
operator|=
name|std
operator|::
name|max
operator|<
name|unsigned
operator|>
operator|(
literal|64
operator|,
name|NextPowerOf2
argument_list|(
name|AtLeast
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|Small
condition|)
block|{
if|if
condition|(
name|AtLeast
operator|<
name|InlineBuckets
condition|)
return|return;
comment|// Nothing to do.
comment|// First move the inline buckets into a temporary storage.
name|AlignedCharArrayUnion
operator|<
name|BucketT
index|[
name|InlineBuckets
index|]
operator|>
name|TmpStorage
expr_stmt|;
name|BucketT
modifier|*
name|TmpBegin
init|=
name|reinterpret_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|TmpStorage
operator|.
name|buffer
operator|)
decl_stmt|;
name|BucketT
modifier|*
name|TmpEnd
init|=
name|TmpBegin
decl_stmt|;
comment|// Loop over the buckets, moving non-empty, non-tombstones into the
comment|// temporary storage. Have the loop move the TmpEnd forward as it goes.
specifier|const
name|KeyT
name|EmptyKey
init|=
name|this
operator|->
name|getEmptyKey
argument_list|()
decl_stmt|;
specifier|const
name|KeyT
name|TombstoneKey
init|=
name|this
operator|->
name|getTombstoneKey
argument_list|()
decl_stmt|;
for|for
control|(
name|BucketT
modifier|*
name|P
init|=
name|getBuckets
argument_list|()
init|,
modifier|*
name|E
init|=
name|P
operator|+
name|InlineBuckets
init|;
name|P
operator|!=
name|E
condition|;
operator|++
name|P
control|)
block|{
if|if
condition|(
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|EmptyKey
argument_list|)
operator|&&
operator|!
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|,
name|TombstoneKey
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|size_t
argument_list|(
name|TmpEnd
operator|-
name|TmpBegin
argument_list|)
operator|<
name|InlineBuckets
operator|&&
literal|"Too many inline buckets!"
argument_list|)
expr_stmt|;
operator|::
name|new
argument_list|(
argument|&TmpEnd->getFirst()
argument_list|)
name|KeyT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|P
operator|->
name|getFirst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|::
name|new
argument_list|(
argument|&TmpEnd->getSecond()
argument_list|)
name|ValueT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|P
operator|->
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|TmpEnd
expr_stmt|;
name|P
operator|->
name|getSecond
argument_list|()
operator|.
operator|~
name|ValueT
argument_list|()
expr_stmt|;
block|}
name|P
operator|->
name|getFirst
argument_list|()
operator|.
operator|~
name|KeyT
argument_list|()
expr_stmt|;
block|}
comment|// Now make this map use the large rep, and move all the entries back
comment|// into it.
name|Small
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|getLargeRep()
argument_list|)
name|LargeRep
argument_list|(
name|allocateBuckets
argument_list|(
name|AtLeast
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|moveFromOldBuckets
argument_list|(
name|TmpBegin
argument_list|,
name|TmpEnd
argument_list|)
expr_stmt|;
return|return;
block|}
name|LargeRep
name|OldRep
init|=
name|std
operator|::
name|move
argument_list|(
operator|*
name|getLargeRep
argument_list|()
argument_list|)
decl_stmt|;
name|getLargeRep
argument_list|()
operator|->
operator|~
name|LargeRep
argument_list|()
expr_stmt|;
if|if
condition|(
name|AtLeast
operator|<=
name|InlineBuckets
condition|)
block|{
name|Small
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|new
argument_list|(
argument|getLargeRep()
argument_list|)
name|LargeRep
argument_list|(
name|allocateBuckets
argument_list|(
name|AtLeast
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|->
name|moveFromOldBuckets
argument_list|(
name|OldRep
operator|.
name|Buckets
argument_list|,
name|OldRep
operator|.
name|Buckets
operator|+
name|OldRep
operator|.
name|NumBuckets
argument_list|)
expr_stmt|;
comment|// Free the old table.
name|operator
name|delete
argument_list|(
name|OldRep
operator|.
name|Buckets
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|shrink_and_clear
parameter_list|()
block|{
name|unsigned
name|OldSize
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
name|this
operator|->
name|destroyAll
argument_list|()
expr_stmt|;
comment|// Reduce the number of buckets.
name|unsigned
name|NewNumBuckets
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OldSize
condition|)
block|{
name|NewNumBuckets
operator|=
literal|1
operator|<<
operator|(
name|Log2_32_Ceil
argument_list|(
name|OldSize
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|NewNumBuckets
operator|>
name|InlineBuckets
operator|&&
name|NewNumBuckets
operator|<
literal|64u
condition|)
name|NewNumBuckets
operator|=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Small
operator|&&
name|NewNumBuckets
operator|<=
name|InlineBuckets
operator|)
operator|||
operator|(
operator|!
name|Small
operator|&&
name|NewNumBuckets
operator|==
name|getLargeRep
argument_list|()
operator|->
name|NumBuckets
operator|)
condition|)
block|{
name|this
operator|->
name|BaseT
operator|::
name|initEmpty
argument_list|()
expr_stmt|;
return|return;
block|}
name|deallocateBuckets
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|NewNumBuckets
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|unsigned
name|getNumEntries
argument_list|()
specifier|const
block|{
return|return
name|NumEntries
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumEntries
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
comment|// NumEntries is hardcoded to be 31 bits wide.
name|assert
argument_list|(
name|Num
operator|<
operator|(
literal|1U
operator|<<
literal|31
operator|)
operator|&&
literal|"Cannot support more than 1<<31 entries"
argument_list|)
expr_stmt|;
name|NumEntries
operator|=
name|Num
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getNumTombstones
argument_list|()
specifier|const
block|{
return|return
name|NumTombstones
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNumTombstones
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|NumTombstones
operator|=
name|Num
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BucketT
operator|*
name|getInlineBuckets
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Small
argument_list|)
block|;
comment|// Note that this cast does not violate aliasing rules as we assert that
comment|// the memory's dynamic type is the small, inline bucket buffer, and the
comment|// 'storage.buffer' static type is 'char *'.
return|return
name|reinterpret_cast
operator|<
specifier|const
name|BucketT
operator|*
operator|>
operator|(
name|storage
operator|.
name|buffer
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|BucketT
modifier|*
name|getInlineBuckets
parameter_list|()
block|{
return|return
name|const_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|SmallDenseMap
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getInlineBuckets
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|LargeRep
operator|*
name|getLargeRep
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|Small
argument_list|)
block|;
comment|// Note, same rule about aliasing as with getInlineBuckets.
return|return
name|reinterpret_cast
operator|<
specifier|const
name|LargeRep
operator|*
operator|>
operator|(
name|storage
operator|.
name|buffer
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|LargeRep
modifier|*
name|getLargeRep
parameter_list|()
block|{
return|return
name|const_cast
operator|<
name|LargeRep
operator|*
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|SmallDenseMap
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getLargeRep
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BucketT
operator|*
name|getBuckets
argument_list|()
specifier|const
block|{
return|return
name|Small
operator|?
name|getInlineBuckets
argument_list|()
operator|:
name|getLargeRep
argument_list|()
operator|->
name|Buckets
return|;
block|}
end_expr_stmt

begin_function
name|BucketT
modifier|*
name|getBuckets
parameter_list|()
block|{
return|return
name|const_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|SmallDenseMap
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getBuckets
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getNumBuckets
argument_list|()
specifier|const
block|{
return|return
name|Small
operator|?
name|InlineBuckets
operator|:
name|getLargeRep
argument_list|()
operator|->
name|NumBuckets
return|;
block|}
end_expr_stmt

begin_function
name|void
name|deallocateBuckets
parameter_list|()
block|{
if|if
condition|(
name|Small
condition|)
return|return;
name|operator
name|delete
argument_list|(
name|getLargeRep
argument_list|()
operator|->
name|Buckets
argument_list|)
decl_stmt|;
name|getLargeRep
argument_list|()
operator|->
operator|~
name|LargeRep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|LargeRep
name|allocateBuckets
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|assert
argument_list|(
name|Num
operator|>
name|InlineBuckets
operator|&&
literal|"Must allocate more buckets than are inline"
argument_list|)
expr_stmt|;
name|LargeRep
name|Rep
init|=
block|{
name|static_cast
operator|<
name|BucketT
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|BucketT
argument_list|)
operator|*
name|Num
argument_list|)
operator|)
block|,
name|Num
block|}
decl_stmt|;
return|return
name|Rep
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|,
name|typename
name|Bucket
operator|,
name|bool
name|IsConst
operator|>
name|class
name|DenseMapIterator
operator|:
name|DebugEpochBase
operator|::
name|HandleBase
block|{
typedef|typedef
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|Bucket
operator|,
name|true
operator|>
name|ConstIterator
expr_stmt|;
name|friend
name|class
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|Bucket
operator|,
name|true
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|DenseMapIterator
operator|<
name|KeyT
operator|,
name|ValueT
operator|,
name|KeyInfoT
operator|,
name|Bucket
operator|,
name|false
operator|>
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|conditional
operator|<
name|IsConst
operator|,
specifier|const
name|Bucket
operator|,
name|Bucket
operator|>
operator|::
name|type
name|value_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|pointer
name|Ptr
decl_stmt|,
name|End
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|DenseMapIterator
argument_list|()
operator|:
name|Ptr
argument_list|(
name|nullptr
argument_list|)
operator|,
name|End
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|DenseMapIterator
argument_list|(
argument|pointer Pos
argument_list|,
argument|pointer E
argument_list|,
argument|const DebugEpochBase&Epoch
argument_list|,
argument|bool NoAdvance = false
argument_list|)
operator|:
name|DebugEpochBase
operator|::
name|HandleBase
argument_list|(
operator|&
name|Epoch
argument_list|)
operator|,
name|Ptr
argument_list|(
name|Pos
argument_list|)
operator|,
name|End
argument_list|(
argument|E
argument_list|)
block|{
name|assert
argument_list|(
name|isHandleInSync
argument_list|()
operator|&&
literal|"invalid construction!"
argument_list|)
block|;
if|if
condition|(
operator|!
name|NoAdvance
condition|)
name|AdvancePastEmptyBuckets
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Converting ctor from non-const iterators to const iterators. SFINAE'd out
end_comment

begin_comment
comment|// for const iterator destinations so it doesn't end up as a user defined copy
end_comment

begin_comment
comment|// constructor.
end_comment

begin_expr_stmt
name|template
operator|<
name|bool
name|IsConstSrc
operator|,
name|typename
operator|=
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|IsConstSrc
operator|&&
name|IsConst
operator|>
operator|::
name|type
operator|>
name|DenseMapIterator
argument_list|(
specifier|const
name|DenseMapIterator
operator|<
name|KeyT
argument_list|,
name|ValueT
argument_list|,
name|KeyInfoT
argument_list|,
name|Bucket
argument_list|,
name|IsConstSrc
operator|>
operator|&
name|I
argument_list|)
operator|:
name|DebugEpochBase
operator|::
name|HandleBase
argument_list|(
name|I
argument_list|)
operator|,
name|Ptr
argument_list|(
name|I
operator|.
name|Ptr
argument_list|)
operator|,
name|End
argument_list|(
argument|I.End
argument_list|)
block|{}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|isHandleInSync
argument_list|()
operator|&&
literal|"invalid iterator access!"
argument_list|)
block|;
return|return
operator|*
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
name|assert
argument_list|(
name|isHandleInSync
argument_list|()
operator|&&
literal|"invalid iterator access!"
argument_list|)
block|;
return|return
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ConstIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|!
name|Ptr
operator|||
name|isHandleInSync
argument_list|()
operator|)
operator|&&
literal|"handle not in sync!"
argument_list|)
block|;
name|assert
argument_list|(
operator|(
operator|!
name|RHS
operator|.
name|Ptr
operator|||
name|RHS
operator|.
name|isHandleInSync
argument_list|()
operator|)
operator|&&
literal|"handle not in sync!"
argument_list|)
block|;
name|assert
argument_list|(
name|getEpochAddress
argument_list|()
operator|==
name|RHS
operator|.
name|getEpochAddress
argument_list|()
operator|&&
literal|"comparing incomparable iterators!"
argument_list|)
block|;
return|return
name|Ptr
operator|==
name|RHS
operator|.
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ConstIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|!
name|Ptr
operator|||
name|isHandleInSync
argument_list|()
operator|)
operator|&&
literal|"handle not in sync!"
argument_list|)
block|;
name|assert
argument_list|(
operator|(
operator|!
name|RHS
operator|.
name|Ptr
operator|||
name|RHS
operator|.
name|isHandleInSync
argument_list|()
operator|)
operator|&&
literal|"handle not in sync!"
argument_list|)
block|;
name|assert
argument_list|(
name|getEpochAddress
argument_list|()
operator|==
name|RHS
operator|.
name|getEpochAddress
argument_list|()
operator|&&
literal|"comparing incomparable iterators!"
argument_list|)
block|;
return|return
name|Ptr
operator|!=
name|RHS
operator|.
name|Ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|DenseMapIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|assert
argument_list|(
name|isHandleInSync
argument_list|()
operator|&&
literal|"invalid iterator access!"
argument_list|)
block|;
operator|++
name|Ptr
block|;
name|AdvancePastEmptyBuckets
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DenseMapIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|assert
argument_list|(
name|isHandleInSync
argument_list|()
operator|&&
literal|"invalid iterator access!"
argument_list|)
block|;
name|DenseMapIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function
name|void
name|AdvancePastEmptyBuckets
parameter_list|()
block|{
specifier|const
name|KeyT
name|Empty
init|=
name|KeyInfoT
operator|::
name|getEmptyKey
argument_list|()
decl_stmt|;
specifier|const
name|KeyT
name|Tombstone
init|=
name|KeyInfoT
operator|::
name|getTombstoneKey
argument_list|()
decl_stmt|;
while|while
condition|(
name|Ptr
operator|!=
name|End
operator|&&
operator|(
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Ptr
operator|->
name|getFirst
argument_list|()
argument_list|,
name|Empty
argument_list|)
operator|||
name|KeyInfoT
operator|::
name|isEqual
argument_list|(
name|Ptr
operator|->
name|getFirst
argument_list|()
argument_list|,
name|Tombstone
argument_list|)
operator|)
condition|)
operator|++
name|Ptr
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyT
operator|,
name|typename
name|ValueT
operator|,
name|typename
name|KeyInfoT
operator|>
specifier|static
specifier|inline
name|size_t
name|capacity_in_bytes
argument_list|(
argument|const DenseMap<KeyT
argument_list|,
argument|ValueT
argument_list|,
argument|KeyInfoT>&X
argument_list|)
block|{
return|return
name|X
operator|.
name|getMemorySize
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_DENSEMAP_H
end_comment

end_unit

