begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/AllocatorList.h - Custom allocator list ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_ALLOCATORLIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_ALLOCATORLIST_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/simple_ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// A linked-list with a custom, local allocator.
comment|///
comment|/// Expose a std::list-like interface that owns and uses a custom LLVM-style
comment|/// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the
comment|/// implementation details.
comment|///
comment|/// Because this list owns the allocator, calling \a splice() with a different
comment|/// list isn't generally safe.  As such, \a splice has been left out of the
comment|/// interface entirely.
name|template
operator|<
name|class
name|T
operator|,
name|class
name|AllocatorT
operator|>
name|class
name|AllocatorList
operator|:
name|AllocatorT
block|{   struct
name|Node
operator|:
name|ilist_node
operator|<
name|Node
operator|>
block|{
name|Node
argument_list|(
name|Node
operator|&&
argument_list|)
operator|=
name|delete
block|;
name|Node
argument_list|(
specifier|const
name|Node
operator|&
argument_list|)
operator|=
name|delete
block|;
name|Node
operator|&
name|operator
operator|=
operator|(
name|Node
operator|&&
operator|)
operator|=
name|delete
block|;
name|Node
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Node
operator|&
operator|)
operator|=
name|delete
block|;
name|Node
argument_list|(
name|T
operator|&&
name|V
argument_list|)
operator|:
name|V
argument_list|(
argument|std::move(V)
argument_list|)
block|{}
name|Node
argument_list|(
specifier|const
name|T
operator|&
name|V
argument_list|)
operator|:
name|V
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
name|Node
argument_list|(
name|Ts
operator|&&
operator|...
name|Vs
argument_list|)
operator|:
name|V
argument_list|(
argument|std::forward<Ts>(Vs)...
argument_list|)
block|{}
name|T
name|V
block|;   }
block|;
name|using
name|list_type
operator|=
name|simple_ilist
operator|<
name|Node
operator|>
block|;
name|list_type
name|List
block|;
name|AllocatorT
operator|&
name|getAlloc
argument_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|AllocatorT
operator|&
name|getAlloc
argument_list|()
specifier|const
block|{
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|class
operator|...
name|ArgTs
operator|>
name|Node
operator|*
name|create
argument_list|(
argument|ArgTs&&... Args
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|getAlloc()
argument_list|)
name|Node
argument_list|(
name|std
operator|::
name|forward
operator|<
name|ArgTs
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
return|;
block|}
expr|struct
name|Cloner
block|{
name|AllocatorList
operator|&
name|AL
block|;
name|Cloner
argument_list|(
name|AllocatorList
operator|&
name|AL
argument_list|)
operator|:
name|AL
argument_list|(
argument|AL
argument_list|)
block|{}
name|Node
operator|*
name|operator
argument_list|()
operator|(
specifier|const
name|Node
operator|&
name|N
operator|)
specifier|const
block|{
return|return
name|AL
operator|.
name|create
argument_list|(
name|N
operator|.
name|V
argument_list|)
return|;
block|}
expr|}
block|;    struct
name|Disposer
block|{
name|AllocatorList
operator|&
name|AL
block|;
name|Disposer
argument_list|(
name|AllocatorList
operator|&
name|AL
argument_list|)
operator|:
name|AL
argument_list|(
argument|AL
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|Node
operator|*
name|N
operator|)
specifier|const
block|{
name|N
operator|->
expr|~
name|Node
argument_list|()
block|;
name|AL
operator|.
name|getAlloc
argument_list|()
operator|.
name|Deallocate
argument_list|(
name|N
argument_list|)
block|;     }
block|}
block|;
name|public
operator|:
name|using
name|value_type
operator|=
name|T
block|;
name|using
name|pointer
operator|=
name|T
operator|*
block|;
name|using
name|reference
operator|=
name|T
operator|&
block|;
name|using
name|const_pointer
operator|=
specifier|const
name|T
operator|*
block|;
name|using
name|const_reference
operator|=
specifier|const
name|T
operator|&
block|;
name|using
name|size_type
operator|=
name|typename
name|list_type
operator|::
name|size_type
block|;
name|using
name|difference_type
operator|=
name|typename
name|list_type
operator|::
name|difference_type
block|;
name|private
operator|:
name|template
operator|<
name|class
name|ValueT
block|,
name|class
name|IteratorBase
operator|>
name|class
name|IteratorImpl
operator|:
name|public
name|iterator_adaptor_base
operator|<
name|IteratorImpl
operator|<
name|ValueT
block|,
name|IteratorBase
operator|>
block|,
name|IteratorBase
block|,
name|std
operator|::
name|bidirectional_iterator_tag
block|,
name|ValueT
operator|>
block|{
name|template
operator|<
name|class
name|OtherValueT
block|,
name|class
name|OtherIteratorBase
operator|>
name|friend
name|class
name|IteratorImpl
block|;
name|friend
name|AllocatorList
block|;
name|using
name|base_type
operator|=
name|iterator_adaptor_base
operator|<
name|IteratorImpl
operator|<
name|ValueT
block|,
name|IteratorBase
operator|>
block|,
name|IteratorBase
block|,
name|std
operator|::
name|bidirectional_iterator_tag
block|,
name|ValueT
operator|>
block|;
name|public
operator|:
name|using
name|value_type
operator|=
name|ValueT
block|;
name|using
name|pointer
operator|=
name|ValueT
operator|*
block|;
name|using
name|reference
operator|=
name|ValueT
operator|&
block|;
name|IteratorImpl
argument_list|()
operator|=
expr|default
block|;
name|IteratorImpl
argument_list|(
specifier|const
name|IteratorImpl
operator|&
argument_list|)
operator|=
expr|default
block|;
name|IteratorImpl
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IteratorImpl
operator|&
operator|)
operator|=
expr|default
block|;
name|explicit
name|IteratorImpl
argument_list|(
specifier|const
name|IteratorBase
operator|&
name|I
argument_list|)
operator|:
name|base_type
argument_list|(
argument|I
argument_list|)
block|{}
name|template
operator|<
name|class
name|OtherValueT
block|,
name|class
name|OtherIteratorBase
operator|>
name|IteratorImpl
argument_list|(
argument|const IteratorImpl<OtherValueT
argument_list|,
argument|OtherIteratorBase>&X
argument_list|,
argument|typename std::enable_if<std::is_convertible<                      OtherIteratorBase
argument_list|,
argument|IteratorBase>::value>::type * = nullptr
argument_list|)
operator|:
name|base_type
argument_list|(
argument|X.wrapped()
argument_list|)
block|{}
operator|~
name|IteratorImpl
argument_list|()
operator|=
expr|default
block|;
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|base_type
operator|::
name|wrapped
argument_list|()
operator|->
name|V
return|;
block|}
name|pointer
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
operator|&
name|operator
operator|*
operator|(
operator|)
return|;
block|}
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|IteratorImpl
operator|&
name|L
operator|,
specifier|const
name|IteratorImpl
operator|&
name|R
operator|)
block|{
return|return
name|L
operator|.
name|wrapped
argument_list|()
operator|==
name|R
operator|.
name|wrapped
argument_list|()
return|;
block|}
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|IteratorImpl
operator|&
name|L
operator|,
specifier|const
name|IteratorImpl
operator|&
name|R
operator|)
block|{
return|return
operator|!
operator|(
name|L
operator|==
name|R
operator|)
return|;
block|}
expr|}
block|;
name|public
operator|:
name|using
name|iterator
operator|=
name|IteratorImpl
operator|<
name|T
block|,
name|typename
name|list_type
operator|::
name|iterator
operator|>
block|;
name|using
name|reverse_iterator
operator|=
name|IteratorImpl
operator|<
name|T
block|,
name|typename
name|list_type
operator|::
name|reverse_iterator
operator|>
block|;
name|using
name|const_iterator
operator|=
name|IteratorImpl
operator|<
specifier|const
name|T
block|,
name|typename
name|list_type
operator|::
name|const_iterator
operator|>
block|;
name|using
name|const_reverse_iterator
operator|=
name|IteratorImpl
operator|<
specifier|const
name|T
block|,
name|typename
name|list_type
operator|::
name|const_reverse_iterator
operator|>
block|;
name|AllocatorList
argument_list|()
operator|=
expr|default
block|;
name|AllocatorList
argument_list|(
name|AllocatorList
operator|&&
name|X
argument_list|)
operator|:
name|AllocatorT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|X
operator|.
name|getAlloc
argument_list|()
argument_list|)
argument_list|)
block|,
name|List
argument_list|(
argument|std::move(X.List)
argument_list|)
block|{}
name|AllocatorList
argument_list|(
argument|const AllocatorList&X
argument_list|)
block|{
name|List
operator|.
name|cloneFrom
argument_list|(
name|X
operator|.
name|List
argument_list|,
name|Cloner
argument_list|(
operator|*
name|this
argument_list|)
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;   }
name|AllocatorList
operator|&
name|operator
operator|=
operator|(
name|AllocatorList
operator|&&
name|X
operator|)
block|{
name|clear
argument_list|()
block|;
comment|// Dispose of current nodes explicitly.
name|List
operator|=
name|std
operator|::
name|move
argument_list|(
name|X
operator|.
name|List
argument_list|)
block|;
name|getAlloc
argument_list|()
operator|=
name|std
operator|::
name|move
argument_list|(
name|X
operator|.
name|getAlloc
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|AllocatorList
operator|&
name|operator
operator|=
operator|(
specifier|const
name|AllocatorList
operator|&
name|X
operator|)
block|{
name|List
operator|.
name|cloneFrom
argument_list|(
name|X
operator|.
name|List
argument_list|,
name|Cloner
argument_list|(
operator|*
name|this
argument_list|)
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
operator|~
name|AllocatorList
argument_list|()
block|{
name|clear
argument_list|()
block|; }
name|void
name|swap
argument_list|(
argument|AllocatorList&RHS
argument_list|)
block|{
name|List
operator|.
name|swap
argument_list|(
name|RHS
operator|.
name|List
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|getAlloc
argument_list|()
argument_list|,
name|RHS
operator|.
name|getAlloc
argument_list|()
argument_list|)
block|;   }
name|bool
name|empty
argument_list|()
block|{
return|return
name|List
operator|.
name|empty
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
block|{
return|return
name|List
operator|.
name|size
argument_list|()
return|;
block|}
name|iterator
name|begin
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|List
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|List
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rbegin
argument_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|List
operator|.
name|rbegin
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
argument_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|List
operator|.
name|rend
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|List
operator|.
name|rbegin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|List
operator|.
name|rend
argument_list|()
argument_list|)
return|;
block|}
name|T
operator|&
name|back
argument_list|()
block|{
return|return
name|List
operator|.
name|back
argument_list|()
operator|.
name|V
return|;
block|}
name|T
operator|&
name|front
argument_list|()
block|{
return|return
name|List
operator|.
name|front
argument_list|()
operator|.
name|V
return|;
block|}
specifier|const
name|T
operator|&
name|back
argument_list|()
specifier|const
block|{
return|return
name|List
operator|.
name|back
argument_list|()
operator|.
name|V
return|;
block|}
specifier|const
name|T
operator|&
name|front
argument_list|()
specifier|const
block|{
return|return
name|List
operator|.
name|front
argument_list|()
operator|.
name|V
return|;
block|}
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
name|iterator
name|emplace
argument_list|(
argument|iterator I
argument_list|,
argument|Ts&&... Vs
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|insert
argument_list|(
name|I
operator|.
name|wrapped
argument_list|()
argument_list|,
operator|*
name|create
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Ts
operator|>
operator|(
name|Vs
operator|)
operator|...
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|T&&V
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|insert
argument_list|(
name|I
operator|.
name|wrapped
argument_list|()
argument_list|,
operator|*
name|create
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|V
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|iterator
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|const T&V
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|insert
argument_list|(
name|I
operator|.
name|wrapped
argument_list|()
argument_list|,
operator|*
name|create
argument_list|(
name|V
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|Iterator
operator|>
name|void
name|insert
argument_list|(
argument|iterator I
argument_list|,
argument|Iterator First
argument_list|,
argument|Iterator Last
argument_list|)
block|{
for|for
control|(
init|;
name|First
operator|!=
name|Last
condition|;
operator|++
name|First
control|)
name|List
operator|.
name|insert
argument_list|(
name|I
operator|.
name|wrapped
argument_list|()
argument_list|,
operator|*
name|create
argument_list|(
operator|*
name|First
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iterator
name|erase
argument_list|(
argument|iterator I
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|eraseAndDispose
argument_list|(
name|I
operator|.
name|wrapped
argument_list|()
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|iterator
name|erase
argument_list|(
argument|iterator First
argument_list|,
argument|iterator Last
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|List
operator|.
name|eraseAndDispose
argument_list|(
name|First
operator|.
name|wrapped
argument_list|()
argument_list|,
name|Last
operator|.
name|wrapped
argument_list|()
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|List
operator|.
name|clearAndDispose
argument_list|(
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|; }
name|void
name|pop_back
argument_list|()
block|{
name|List
operator|.
name|eraseAndDispose
argument_list|(
operator|--
name|List
operator|.
name|end
argument_list|()
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|; }
name|void
name|pop_front
argument_list|()
block|{
name|List
operator|.
name|eraseAndDispose
argument_list|(
name|List
operator|.
name|begin
argument_list|()
argument_list|,
name|Disposer
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|; }
name|void
name|push_back
argument_list|(
argument|T&&V
argument_list|)
block|{
name|insert
argument_list|(
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|V
argument_list|)
argument_list|)
block|; }
name|void
name|push_front
argument_list|(
argument|T&&V
argument_list|)
block|{
name|insert
argument_list|(
name|begin
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|V
argument_list|)
argument_list|)
block|; }
name|void
name|push_back
argument_list|(
argument|const T&V
argument_list|)
block|{
name|insert
argument_list|(
name|end
argument_list|()
argument_list|,
name|V
argument_list|)
block|; }
name|void
name|push_front
argument_list|(
argument|const T&V
argument_list|)
block|{
name|insert
argument_list|(
name|begin
argument_list|()
argument_list|,
name|V
argument_list|)
block|; }
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
name|void
name|emplace_back
argument_list|(
argument|Ts&&... Vs
argument_list|)
block|{
name|emplace
argument_list|(
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Ts
operator|>
operator|(
name|Vs
operator|)
operator|...
argument_list|)
block|;   }
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
name|void
name|emplace_front
argument_list|(
argument|Ts&&... Vs
argument_list|)
block|{
name|emplace
argument_list|(
name|begin
argument_list|()
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Ts
operator|>
operator|(
name|Vs
operator|)
operator|...
argument_list|)
block|;   }
comment|/// Reset the underlying allocator.
comment|///
comment|/// \pre \c empty()
name|void
name|resetAlloc
argument_list|()
block|{
name|assert
argument_list|(
name|empty
argument_list|()
operator|&&
literal|"Cannot reset allocator if not empty"
argument_list|)
block|;
name|getAlloc
argument_list|()
operator|.
name|Reset
argument_list|()
block|;   }
expr|}
block|;
name|template
operator|<
name|class
name|T
operator|>
name|using
name|BumpPtrList
operator|=
name|AllocatorList
operator|<
name|T
block|,
name|BumpPtrAllocator
operator|>
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_ALLOCATORLIST_H
end_comment

end_unit

