begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains some templates that are useful if you are working with the
end_comment

begin_comment
comment|// STL at all.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// No library is required when using these functions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_STLEXTRAS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_STLEXTRAS_H
end_define

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_comment
comment|// for std::all_of
end_comment

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|// for std::size_t
end_comment

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_comment
comment|// for qsort
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<tuple>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_comment
comment|// for std::pair
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// Only used by compiler if both template types are the same.  Useful when
comment|// using SFINAE to test for the existence of member functions.
name|template
operator|<
name|typename
name|T
operator|,
name|T
operator|>
expr|struct
name|SameType
expr_stmt|;
name|namespace
name|detail
block|{
name|template
operator|<
name|typename
name|RangeT
operator|>
name|using
name|IterOfRange
operator|=
name|decltype
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|declval
operator|<
name|RangeT
operator|&
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|RangeT
operator|>
name|using
name|ValueOfRange
operator|=
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|decltype
argument_list|(
operator|*
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|declval
operator|<
name|RangeT
operator|&
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
operator|>
operator|::
name|type
expr_stmt|;
block|}
comment|// End detail namespace
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<functional>
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|identity
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|Ty
operator|,
name|Ty
operator|>
block|{
name|Ty
operator|&
name|operator
argument_list|()
operator|(
name|Ty
operator|&
name|self
operator|)
specifier|const
block|{
return|return
name|self
return|;
block|}
specifier|const
name|Ty
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|&
name|self
operator|)
specifier|const
block|{
return|return
name|self
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|less_ptr
operator|:
name|public
name|std
operator|::
name|binary_function
operator|<
name|Ty
block|,
name|Ty
block|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|*
name|left
operator|,
specifier|const
name|Ty
operator|*
name|right
operator|)
specifier|const
block|{
return|return
operator|*
name|left
operator|<
operator|*
name|right
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|Ty
operator|>
expr|struct
name|greater_ptr
operator|:
name|public
name|std
operator|::
name|binary_function
operator|<
name|Ty
block|,
name|Ty
block|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Ty
operator|*
name|left
operator|,
specifier|const
name|Ty
operator|*
name|right
operator|)
specifier|const
block|{
return|return
operator|*
name|right
operator|<
operator|*
name|left
return|;
block|}
expr|}
block|;
comment|/// An efficient, type-erasing, non-owning reference to a callable. This is
comment|/// intended for use as the type of a function parameter that is not used
comment|/// after the function in question returns.
comment|///
comment|/// This class does not own the callable, so it is not in general safe to store
comment|/// a function_ref.
name|template
operator|<
name|typename
name|Fn
operator|>
name|class
name|function_ref
block|;
name|template
operator|<
name|typename
name|Ret
block|,
name|typename
operator|...
name|Params
operator|>
name|class
name|function_ref
operator|<
name|Ret
argument_list|(
name|Params
operator|...
argument_list|)
operator|>
block|{
name|Ret
argument_list|(
argument|*callback
argument_list|)
operator|(
name|intptr_t
name|callable
operator|,
name|Params
operator|...
name|params
operator|)
block|;
name|intptr_t
name|callable
block|;
name|template
operator|<
name|typename
name|Callable
operator|>
specifier|static
name|Ret
name|callback_fn
argument_list|(
argument|intptr_t callable
argument_list|,
argument|Params ...params
argument_list|)
block|{
return|return
operator|(
operator|*
name|reinterpret_cast
operator|<
name|Callable
operator|*
operator|>
operator|(
name|callable
operator|)
operator|)
operator|(
name|std
operator|::
name|forward
operator|<
name|Params
operator|>
operator|(
name|params
operator|)
operator|...
operator|)
return|;
block|}
name|public
operator|:
name|function_ref
argument_list|()
operator|:
name|callback
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|template
operator|<
name|typename
name|Callable
operator|>
name|function_ref
argument_list|(
argument|Callable&&callable
argument_list|,
argument|typename std::enable_if<                    !std::is_same<typename std::remove_reference<Callable>::type
argument_list|,
argument|function_ref>::value>::type * = nullptr
argument_list|)
operator|:
name|callback
argument_list|(
argument|callback_fn<typename std::remove_reference<Callable>::type>
argument_list|)
block|,
name|callable
argument_list|(
argument|reinterpret_cast<intptr_t>(&callable)
argument_list|)
block|{}
name|Ret
name|operator
argument_list|()
operator|(
name|Params
operator|...
name|params
operator|)
specifier|const
block|{
return|return
name|callback
argument_list|(
name|callable
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Params
operator|>
operator|(
name|params
operator|)
operator|...
argument_list|)
return|;
block|}
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|callback
return|;
block|}
expr|}
block|;
comment|// deleter - Very very very simple method that is used to invoke operator
comment|// delete on something.  It is used like this:
comment|//
comment|//   for_each(V.begin(), B.end(), deleter<Interval>);
comment|//
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|void
name|deleter
argument_list|(
argument|T *Ptr
argument_list|)
block|{
name|delete
name|Ptr
block|; }
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<iterator>
comment|//===----------------------------------------------------------------------===//
comment|// mapped_iterator - This is a simple iterator adapter that causes a function to
comment|// be applied whenever operator* is invoked on the iterator.
comment|//
name|template
operator|<
name|class
name|RootIt
block|,
name|class
name|UnaryFunc
operator|>
name|class
name|mapped_iterator
block|{
name|RootIt
name|current
block|;
name|UnaryFunc
name|Fn
block|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|RootIt
operator|>
operator|::
name|iterator_category
name|iterator_category
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|RootIt
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
typedef|typedef
name|decltype
argument_list|(
argument|std::declval<UnaryFunc>()(*std::declval<RootIt>())
argument_list|)
name|value_type
expr_stmt|;
typedef|typedef
name|void
name|pointer
typedef|;
comment|//typedef typename UnaryFunc::result_type *pointer;
typedef|typedef
name|void
name|reference
typedef|;
comment|// Can't modify value returned by fn
typedef|typedef
name|RootIt
name|iterator_type
typedef|;
specifier|inline
specifier|const
name|RootIt
operator|&
name|getCurrent
argument_list|()
specifier|const
block|{
return|return
name|current
return|;
block|}
specifier|inline
specifier|const
name|UnaryFunc
operator|&
name|getFunc
argument_list|()
specifier|const
block|{
return|return
name|Fn
return|;
block|}
specifier|inline
name|explicit
name|mapped_iterator
argument_list|(
argument|const RootIt&I
argument_list|,
argument|UnaryFunc F
argument_list|)
operator|:
name|current
argument_list|(
name|I
argument_list|)
operator|,
name|Fn
argument_list|(
argument|F
argument_list|)
block|{}
specifier|inline
name|value_type
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
comment|// All this work to do this
return|return
name|Fn
argument_list|(
operator|*
name|current
argument_list|)
return|;
comment|// little change
block|}
name|mapped_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
name|mapped_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
name|mapped_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|mapped_iterator
name|__tmp
operator|=
operator|*
name|this
block|;
operator|++
name|current
block|;
return|return
name|__tmp
return|;
block|}
name|mapped_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|mapped_iterator
name|__tmp
operator|=
operator|*
name|this
block|;
operator|--
name|current
block|;
return|return
name|__tmp
return|;
block|}
name|mapped_iterator
name|operator
operator|+
operator|(
name|difference_type
name|n
operator|)
specifier|const
block|{
return|return
name|mapped_iterator
argument_list|(
name|current
operator|+
name|n
argument_list|,
name|Fn
argument_list|)
return|;
block|}
name|mapped_iterator
operator|&
name|operator
operator|+=
operator|(
name|difference_type
name|n
operator|)
block|{
name|current
operator|+=
name|n
block|;
return|return
operator|*
name|this
return|;
block|}
name|mapped_iterator
name|operator
operator|-
operator|(
name|difference_type
name|n
operator|)
specifier|const
block|{
return|return
name|mapped_iterator
argument_list|(
name|current
operator|-
name|n
argument_list|,
name|Fn
argument_list|)
return|;
block|}
name|mapped_iterator
operator|&
name|operator
operator|-=
operator|(
name|difference_type
name|n
operator|)
block|{
name|current
operator|-=
name|n
block|;
return|return
operator|*
name|this
return|;
block|}
name|reference
name|operator
index|[]
argument_list|(
name|difference_type
name|n
argument_list|)
decl|const
block|{
return|return
operator|*
operator|(
operator|*
name|this
operator|+
name|n
operator|)
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|mapped_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|X
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|mapped_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|==
name|X
operator|.
name|current
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|mapped_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|<
name|X
operator|.
name|current
return|;
block|}
name|difference_type
name|operator
operator|-
operator|(
specifier|const
name|mapped_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|current
operator|-
name|X
operator|.
name|current
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Iterator
operator|,
name|class
name|Func
operator|>
specifier|inline
name|mapped_iterator
operator|<
name|Iterator
operator|,
name|Func
operator|>
name|operator
operator|+
operator|(
name|typename
name|mapped_iterator
operator|<
name|Iterator
operator|,
name|Func
operator|>
operator|::
name|difference_type
name|N
operator|,
specifier|const
name|mapped_iterator
operator|<
name|Iterator
operator|,
name|Func
operator|>
operator|&
name|X
operator|)
block|{
return|return
name|mapped_iterator
operator|<
name|Iterator
operator|,
name|Func
operator|>
operator|(
name|X
operator|.
name|getCurrent
argument_list|()
operator|-
name|N
operator|,
name|X
operator|.
name|getFunc
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// map_iterator - Provide a convenient way to create mapped_iterators, just like
end_comment

begin_comment
comment|// make_pair is useful for creating pairs...
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ItTy
operator|,
name|class
name|FuncTy
operator|>
specifier|inline
name|mapped_iterator
operator|<
name|ItTy
operator|,
name|FuncTy
operator|>
name|map_iterator
argument_list|(
argument|const ItTy&I
argument_list|,
argument|FuncTy F
argument_list|)
block|{
return|return
name|mapped_iterator
operator|<
name|ItTy
operator|,
name|FuncTy
operator|>
operator|(
name|I
operator|,
name|F
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Helper to determine if type T has a member called rbegin().
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Ty
operator|>
name|class
name|has_rbegin_impl
block|{
typedef|typedef
name|char
name|yes
index|[
literal|1
index|]
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|char
name|no
index|[
literal|2
index|]
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|Inner
operator|>
specifier|static
name|yes
operator|&
name|test
argument_list|(
name|Inner
operator|*
name|I
argument_list|,
name|decltype
argument_list|(
name|I
operator|->
name|rbegin
argument_list|()
argument_list|)
operator|*
operator|=
name|nullptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
operator|>
specifier|static
name|no
operator|&
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|value
init|=
sizeof|sizeof
argument_list|(
name|test
operator|<
name|Ty
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|yes
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Metafunction to determine if T& or T has a member called rbegin().
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Ty
operator|>
expr|struct
name|has_rbegin
operator|:
name|has_rbegin_impl
operator|<
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|Ty
operator|>
operator|::
name|type
operator|>
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Returns an iterator_range over the given container which iterates in reverse.
end_comment

begin_comment
comment|// Note that the container must have rbegin()/rend() methods for this to work.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ContainerTy
operator|>
name|auto
name|reverse
argument_list|(
argument|ContainerTy&&C
argument_list|,
argument|typename std::enable_if<has_rbegin<ContainerTy>::value>::type * =                  nullptr
argument_list|)
operator|->
name|decltype
argument_list|(
argument|make_range(C.rbegin(), C.rend())
argument_list|)
block|{
return|return
name|make_range
argument_list|(
name|C
operator|.
name|rbegin
argument_list|()
argument_list|,
name|C
operator|.
name|rend
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Returns a std::reverse_iterator wrapped around the given iterator.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|IteratorTy
operator|>
name|std
operator|::
name|reverse_iterator
operator|<
name|IteratorTy
operator|>
name|make_reverse_iterator
argument_list|(
argument|IteratorTy It
argument_list|)
block|{
return|return
name|std
operator|::
name|reverse_iterator
operator|<
name|IteratorTy
operator|>
operator|(
name|It
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Returns an iterator_range over the given container which iterates in reverse.
end_comment

begin_comment
comment|// Note that the container must have begin()/end() methods which return
end_comment

begin_comment
comment|// bidirectional iterators for this to work.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ContainerTy
operator|>
name|auto
name|reverse
argument_list|(
argument|ContainerTy&&C
argument_list|,
argument|typename std::enable_if<!has_rbegin<ContainerTy>::value>::type * = nullptr
argument_list|)
operator|->
name|decltype
argument_list|(
argument|make_range(llvm::make_reverse_iterator(std::end(C)),                            llvm::make_reverse_iterator(std::begin(C)))
argument_list|)
block|{
return|return
name|make_range
argument_list|(
name|llvm
operator|::
name|make_reverse_iterator
argument_list|(
name|std
operator|::
name|end
argument_list|(
name|C
argument_list|)
argument_list|)
argument_list|,
name|llvm
operator|::
name|make_reverse_iterator
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|C
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// An iterator adaptor that filters the elements of given inner iterators.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The predicate parameter should be a callable object that accepts the wrapped
end_comment

begin_comment
comment|/// iterator's reference type and returns a bool. When incrementing or
end_comment

begin_comment
comment|/// decrementing the iterator, it will call the predicate on each element and
end_comment

begin_comment
comment|/// skip any where it returns false.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \code
end_comment

begin_comment
comment|///   int A[] = { 1, 2, 3, 4 };
end_comment

begin_comment
comment|///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });
end_comment

begin_comment
comment|///   // R contains { 1, 3 }.
end_comment

begin_comment
comment|/// \endcode
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|WrappedIteratorT
operator|,
name|typename
name|PredicateT
operator|>
name|class
name|filter_iterator
operator|:
name|public
name|iterator_adaptor_base
operator|<
name|filter_iterator
operator|<
name|WrappedIteratorT
operator|,
name|PredicateT
operator|>
operator|,
name|WrappedIteratorT
operator|,
name|typename
name|std
operator|::
name|common_type
operator|<
name|std
operator|::
name|forward_iterator_tag
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|WrappedIteratorT
operator|>
operator|::
name|iterator_category
operator|>
operator|::
name|type
operator|>
block|{
name|using
name|BaseT
operator|=
name|iterator_adaptor_base
operator|<
name|filter_iterator
operator|<
name|WrappedIteratorT
block|,
name|PredicateT
operator|>
block|,
name|WrappedIteratorT
block|,
name|typename
name|std
operator|::
name|common_type
operator|<
name|std
operator|::
name|forward_iterator_tag
block|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|WrappedIteratorT
operator|>
operator|::
name|iterator_category
operator|>
operator|::
name|type
operator|>
block|;    struct
name|PayloadType
block|{
name|WrappedIteratorT
name|End
block|;
name|PredicateT
name|Pred
block|;   }
block|;
name|Optional
operator|<
name|PayloadType
operator|>
name|Payload
block|;
name|void
name|findNextValid
argument_list|()
block|{
name|assert
argument_list|(
name|Payload
operator|&&
literal|"Payload should be engaged when findNextValid is called"
argument_list|)
block|;
while|while
condition|(
name|this
operator|->
name|I
operator|!=
name|Payload
operator|->
name|End
operator|&&
operator|!
name|Payload
operator|->
name|Pred
argument_list|(
operator|*
name|this
operator|->
name|I
argument_list|)
condition|)
name|BaseT
operator|::
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
block|}
comment|// Construct the begin iterator. The begin iterator requires to know where end
comment|// is, so that it can properly stop when it hits end.
name|filter_iterator
argument_list|(
argument|WrappedIteratorT Begin
argument_list|,
argument|WrappedIteratorT End
argument_list|,
argument|PredicateT Pred
argument_list|)
operator|:
name|BaseT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Begin
argument_list|)
argument_list|)
operator|,
name|Payload
argument_list|(
argument|PayloadType{std::move(End)
argument_list|,
argument|std::move(Pred)}
argument_list|)
block|{
name|findNextValid
argument_list|()
block|;   }
comment|// Construct the end iterator. It's not incrementable, so Payload doesn't
comment|// have to be engaged.
name|filter_iterator
argument_list|(
argument|WrappedIteratorT End
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|End
argument_list|)
block|{}
name|public
operator|:
name|using
name|BaseT
operator|::
name|operator
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|filter_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|BaseT
operator|::
name|operator
operator|++
operator|(
operator|)
block|;
name|findNextValid
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|RT
operator|,
name|typename
name|PT
operator|>
name|friend
name|iterator_range
operator|<
name|filter_iterator
operator|<
name|detail
operator|::
name|IterOfRange
operator|<
name|RT
operator|>
operator|,
name|PT
operator|>>
name|make_filter_range
argument_list|(
name|RT
operator|&&
argument_list|,
name|PT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// Convenience function that takes a range of elements and a predicate,
end_comment

begin_comment
comment|/// and return a new filter_iterator range.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// FIXME: Currently if RangeT&& is a rvalue reference to a temporary, the
end_comment

begin_comment
comment|/// lifetime of that temporary is not kept by the returned range object, and the
end_comment

begin_comment
comment|/// temporary is going to be dropped on the floor after the make_iterator_range
end_comment

begin_comment
comment|/// full expression that contains this function call.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|RangeT
operator|,
name|typename
name|PredicateT
operator|>
name|iterator_range
operator|<
name|filter_iterator
operator|<
name|detail
operator|::
name|IterOfRange
operator|<
name|RangeT
operator|>
operator|,
name|PredicateT
operator|>>
name|make_filter_range
argument_list|(
argument|RangeT&&Range
argument_list|,
argument|PredicateT Pred
argument_list|)
block|{
name|using
name|FilterIteratorT
operator|=
name|filter_iterator
operator|<
name|detail
operator|::
name|IterOfRange
operator|<
name|RangeT
operator|>
block|,
name|PredicateT
operator|>
block|;
return|return
name|make_range
argument_list|(
name|FilterIteratorT
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|forward
operator|<
name|RangeT
operator|>
operator|(
name|Range
operator|)
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|std
operator|::
name|forward
operator|<
name|RangeT
operator|>
operator|(
name|Range
operator|)
argument_list|)
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Pred
argument_list|)
argument_list|)
argument_list|,
name|FilterIteratorT
argument_list|(
name|std
operator|::
name|end
argument_list|(
name|std
operator|::
name|forward
operator|<
name|RangeT
operator|>
operator|(
name|Range
operator|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// forward declarations required by zip_shortest/zip_first
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|bool
name|all_of
argument_list|(
argument|R&&range
argument_list|,
argument|UnaryPredicate P
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|size_t
operator|...
name|I
operator|>
expr|struct
name|index_sequence
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
expr|struct
name|index_sequence_for
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|detail
block|{
name|using
name|std
operator|::
name|declval
expr_stmt|;
comment|// We have to alias this since inlining the actual type at the usage site
comment|// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.
name|template
operator|<
name|typename
operator|...
name|Iters
operator|>
expr|struct
name|ZipTupleType
block|{
typedef|typedef
name|std
operator|::
name|tuple
operator|<
name|decltype
argument_list|(
operator|*
name|declval
operator|<
name|Iters
operator|>
operator|(
operator|)
argument_list|)
operator|...
operator|>
name|type
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|ZipType
operator|,
name|typename
operator|...
name|Iters
operator|>
name|using
name|zip_traits
operator|=
name|iterator_facade_base
operator|<
name|ZipType
operator|,
name|typename
name|std
operator|::
name|common_type
operator|<
name|std
operator|::
name|bidirectional_iterator_tag
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|Iters
operator|>
operator|::
name|iterator_category
operator|...
operator|>
operator|::
name|type
operator|,
comment|// ^ TODO: Implement random access methods.
name|typename
name|ZipTupleType
operator|<
name|Iters
operator|...
operator|>
operator|::
name|type
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|typename
name|std
operator|::
name|tuple_element
operator|<
literal|0
operator|,
name|std
operator|::
name|tuple
operator|<
name|Iters
operator|...
operator|>>
operator|::
name|type
operator|>
operator|::
name|difference_type
operator|,
comment|// ^ FIXME: This follows boost::make_zip_iterator's assumption that all
comment|// inner iterators have the same difference_type. It would fail if, for
comment|// instance, the second field's difference_type were non-numeric while the
comment|// first is.
name|typename
name|ZipTupleType
operator|<
name|Iters
operator|...
operator|>
operator|::
name|type
operator|*
operator|,
name|typename
name|ZipTupleType
operator|<
name|Iters
operator|...
operator|>
operator|::
name|type
operator|>
expr_stmt|;
name|template
operator|<
name|typename
name|ZipType
operator|,
name|typename
operator|...
name|Iters
operator|>
expr|struct
name|zip_common
operator|:
name|public
name|zip_traits
operator|<
name|ZipType
operator|,
name|Iters
operator|...
operator|>
block|{
name|using
name|Base
operator|=
name|zip_traits
operator|<
name|ZipType
block|,
name|Iters
operator|...
operator|>
block|;
name|using
name|value_type
operator|=
name|typename
name|Base
operator|::
name|value_type
block|;
name|std
operator|::
name|tuple
operator|<
name|Iters
operator|...
operator|>
name|iterators
block|;
name|protected
operator|:
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|value_type
name|deref
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|value_type
argument_list|(
operator|*
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|iterators
operator|)
operator|...
argument_list|)
return|;
block|}
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|decltype
argument_list|(
argument|iterators
argument_list|)
name|tup_inc
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|tuple
operator|<
name|Iters
operator|...
operator|>
operator|(
name|std
operator|::
name|next
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|iterators
operator|)
argument_list|)
operator|...
operator|)
return|;
block|}
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|decltype
argument_list|(
argument|iterators
argument_list|)
name|tup_dec
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|tuple
operator|<
name|Iters
operator|...
operator|>
operator|(
name|std
operator|::
name|prev
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|iterators
operator|)
argument_list|)
operator|...
operator|)
return|;
block|}
name|public
operator|:
name|zip_common
argument_list|(
name|Iters
operator|&&
operator|...
name|ts
argument_list|)
operator|:
name|iterators
argument_list|(
argument|std::forward<Iters>(ts)...
argument_list|)
block|{}
name|value_type
name|operator
operator|*
operator|(
operator|)
block|{
return|return
name|deref
argument_list|(
name|index_sequence_for
operator|<
name|Iters
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
specifier|const
name|value_type
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|deref
argument_list|(
name|index_sequence_for
operator|<
name|Iters
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|ZipType
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|iterators
operator|=
name|tup_inc
argument_list|(
name|index_sequence_for
operator|<
name|Iters
operator|...
operator|>
block|{}
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|ZipType
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|ZipType
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|static_assert
argument_list|(
name|Base
operator|::
name|IsBidirectional
argument_list|,
literal|"All inner iterators must be at least bidirectional."
argument_list|)
block|;
name|iterators
operator|=
name|tup_dec
argument_list|(
name|index_sequence_for
operator|<
name|Iters
operator|...
operator|>
block|{}
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|ZipType
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
operator|...
name|Iters
operator|>
expr|struct
name|zip_first
operator|:
name|public
name|zip_common
operator|<
name|zip_first
operator|<
name|Iters
operator|...
operator|>
block|,
name|Iters
operator|...
operator|>
block|{
name|using
name|Base
operator|=
name|zip_common
operator|<
name|zip_first
operator|<
name|Iters
operator|...
operator|>
block|,
name|Iters
operator|...
operator|>
block|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|zip_first
operator|<
name|Iters
operator|...
operator|>
operator|&
name|other
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|get
operator|<
literal|0
operator|>
operator|(
name|this
operator|->
name|iterators
operator|)
operator|==
name|std
operator|::
name|get
operator|<
literal|0
operator|>
operator|(
name|other
operator|.
name|iterators
operator|)
return|;
block|}
name|zip_first
argument_list|(
name|Iters
operator|&&
operator|...
name|ts
argument_list|)
operator|:
name|Base
argument_list|(
argument|std::forward<Iters>(ts)...
argument_list|)
block|{}
expr|}
block|;
name|template
operator|<
name|typename
operator|...
name|Iters
operator|>
name|class
name|zip_shortest
operator|:
name|public
name|zip_common
operator|<
name|zip_shortest
operator|<
name|Iters
operator|...
operator|>
block|,
name|Iters
operator|...
operator|>
block|{
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|bool
name|test
argument_list|(
argument|const zip_shortest<Iters...>&other
argument_list|,
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|all_of
argument_list|(
name|std
operator|::
name|initializer_list
operator|<
name|bool
operator|>
block|{
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|this
operator|->
name|iterators
operator|)
operator|!=
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|other
operator|.
name|iterators
operator|)
operator|...
block|}
argument_list|,
name|identity
operator|<
name|bool
operator|>
block|{}
argument_list|)
return|;
block|}
name|public
operator|:
name|using
name|Base
operator|=
name|zip_common
operator|<
name|zip_shortest
operator|<
name|Iters
operator|...
operator|>
block|,
name|Iters
operator|...
operator|>
block|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|zip_shortest
operator|<
name|Iters
operator|...
operator|>
operator|&
name|other
operator|)
specifier|const
block|{
return|return
operator|!
name|test
argument_list|(
name|other
argument_list|,
name|index_sequence_for
operator|<
name|Iters
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|zip_shortest
argument_list|(
name|Iters
operator|&&
operator|...
name|ts
argument_list|)
operator|:
name|Base
argument_list|(
argument|std::forward<Iters>(ts)...
argument_list|)
block|{}
expr|}
block|;
name|template
operator|<
name|template
operator|<
name|typename
operator|...
operator|>
name|class
name|ItType
block|,
name|typename
operator|...
name|Args
operator|>
name|class
name|zippy
block|{
name|public
operator|:
name|using
name|iterator
operator|=
name|ItType
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|declval
operator|<
name|Args
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
operator|...
operator|>
block|;
name|using
name|iterator_category
operator|=
name|typename
name|iterator
operator|::
name|iterator_category
block|;
name|using
name|value_type
operator|=
name|typename
name|iterator
operator|::
name|value_type
block|;
name|using
name|difference_type
operator|=
name|typename
name|iterator
operator|::
name|difference_type
block|;
name|using
name|pointer
operator|=
name|typename
name|iterator
operator|::
name|pointer
block|;
name|using
name|reference
operator|=
name|typename
name|iterator
operator|::
name|reference
block|;
name|private
operator|:
name|std
operator|::
name|tuple
operator|<
name|Args
operator|...
operator|>
name|ts
block|;
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|iterator
name|begin_impl
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|ts
operator|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|iterator
name|end_impl
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|std
operator|::
name|end
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|ts
operator|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
name|public
operator|:
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|begin_impl
argument_list|(
name|index_sequence_for
operator|<
name|Args
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|end_impl
argument_list|(
name|index_sequence_for
operator|<
name|Args
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|zippy
argument_list|(
name|Args
operator|&&
operator|...
name|ts_
argument_list|)
operator|:
name|ts
argument_list|(
argument|std::forward<Args>(ts_)...
argument_list|)
block|{}
expr|}
block|; }
comment|// End detail namespace
comment|/// zip iterator for two or more iteratable types.
name|template
operator|<
name|typename
name|T
block|,
name|typename
name|U
block|,
name|typename
operator|...
name|Args
operator|>
name|detail
operator|::
name|zippy
operator|<
name|detail
operator|::
name|zip_shortest
block|,
name|T
block|,
name|U
block|,
name|Args
operator|...
operator|>
name|zip
argument_list|(
argument|T&&t
argument_list|,
argument|U&&u
argument_list|,
argument|Args&&... args
argument_list|)
block|{
return|return
name|detail
operator|::
name|zippy
operator|<
name|detail
operator|::
name|zip_shortest
operator|,
name|T
operator|,
name|U
operator|,
name|Args
operator|...
operator|>
operator|(
name|std
operator|::
name|forward
operator|<
name|T
operator|>
operator|(
name|t
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|U
operator|>
operator|(
name|u
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
operator|)
return|;
block|}
comment|/// zip iterator that, for the sake of efficiency, assumes the first iteratee to
comment|/// be the shortest.
name|template
operator|<
name|typename
name|T
block|,
name|typename
name|U
block|,
name|typename
operator|...
name|Args
operator|>
name|detail
operator|::
name|zippy
operator|<
name|detail
operator|::
name|zip_first
block|,
name|T
block|,
name|U
block|,
name|Args
operator|...
operator|>
name|zip_first
argument_list|(
argument|T&&t
argument_list|,
argument|U&&u
argument_list|,
argument|Args&&... args
argument_list|)
block|{
return|return
name|detail
operator|::
name|zippy
operator|<
name|detail
operator|::
name|zip_first
operator|,
name|T
operator|,
name|U
operator|,
name|Args
operator|...
operator|>
operator|(
name|std
operator|::
name|forward
operator|<
name|T
operator|>
operator|(
name|t
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|U
operator|>
operator|(
name|u
operator|)
operator|,
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
operator|)
return|;
block|}
comment|/// Iterator wrapper that concatenates sequences together.
comment|///
comment|/// This can concatenate different iterators, even with different types, into
comment|/// a single iterator provided the value types of all the concatenated
comment|/// iterators expose `reference` and `pointer` types that can be converted to
comment|/// `ValueT&` and `ValueT *` respectively. It doesn't support more
comment|/// interesting/customized pointer or reference types.
comment|///
comment|/// Currently this only supports forward or higher iterator categories as
comment|/// inputs and always exposes a forward iterator interface.
name|template
operator|<
name|typename
name|ValueT
block|,
name|typename
operator|...
name|IterTs
operator|>
name|class
name|concat_iterator
operator|:
name|public
name|iterator_facade_base
operator|<
name|concat_iterator
operator|<
name|ValueT
block|,
name|IterTs
operator|...
operator|>
block|,
name|std
operator|::
name|forward_iterator_tag
block|,
name|ValueT
operator|>
block|{
typedef|typedef
name|typename
name|concat_iterator
operator|::
name|iterator_facade_base
name|BaseT
expr_stmt|;
comment|/// We store both the current and end iterators for each concatenated
comment|/// sequence in a tuple of pairs.
comment|///
comment|/// Note that something like iterator_range seems nice at first here, but the
comment|/// range properties are of little benefit and end up getting in the way
comment|/// because we need to do mutation on the current iterators.
name|std
operator|::
name|tuple
operator|<
name|std
operator|::
name|pair
operator|<
name|IterTs
operator|,
name|IterTs
operator|>
operator|...
operator|>
name|IterPairs
block|;
comment|/// Attempts to increment a specific iterator.
comment|///
comment|/// Returns true if it was able to increment the iterator. Returns false if
comment|/// the iterator is already at the end iterator.
name|template
operator|<
name|size_t
name|Index
operator|>
name|bool
name|incrementHelper
argument_list|()
block|{
name|auto
operator|&
name|IterPair
operator|=
name|std
operator|::
name|get
operator|<
name|Index
operator|>
operator|(
name|IterPairs
operator|)
block|;
if|if
condition|(
name|IterPair
operator|.
name|first
operator|==
name|IterPair
operator|.
name|second
condition|)
return|return
name|false
return|;
operator|++
name|IterPair
operator|.
name|first
block|;
return|return
name|true
return|;
block|}
comment|/// Increments the first non-end iterator.
comment|///
comment|/// It is an error to call this with all iterators at the end.
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|void
name|increment
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
block|{
comment|// Build a sequence of functions to increment each iterator if possible.
name|bool
argument_list|(
name|concat_iterator
operator|::
operator|*
name|IncrementHelperFns
index|[]
argument_list|)
argument_list|()
operator|=
block|{
operator|&
name|concat_iterator
operator|::
name|incrementHelper
operator|<
name|Ns
operator|>
operator|...
block|}
block|;
comment|// Loop over them, and stop as soon as we succeed at incrementing one.
for|for
control|(
name|auto
operator|&
name|IncrementHelperFn
operator|:
name|IncrementHelperFns
control|)
if|if
condition|(
operator|(
name|this
operator|->*
name|IncrementHelperFn
operator|)
operator|(
operator|)
condition|)
return|return;
name|llvm_unreachable
argument_list|(
literal|"Attempted to increment an end concat iterator!"
argument_list|)
block|;   }
comment|/// Returns null if the specified iterator is at the end. Otherwise,
comment|/// dereferences the iterator and returns the address of the resulting
comment|/// reference.
name|template
operator|<
name|size_t
name|Index
operator|>
name|ValueT
operator|*
name|getHelper
argument_list|()
specifier|const
block|{
name|auto
operator|&
name|IterPair
operator|=
name|std
operator|::
name|get
operator|<
name|Index
operator|>
operator|(
name|IterPairs
operator|)
block|;
if|if
condition|(
name|IterPair
operator|.
name|first
operator|==
name|IterPair
operator|.
name|second
condition|)
return|return
name|nullptr
return|;
return|return
operator|&
operator|*
name|IterPair
operator|.
name|first
return|;
block|}
comment|/// Finds the first non-end iterator, dereferences, and returns the resulting
comment|/// reference.
comment|///
comment|/// It is an error to call this with all iterators at the end.
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|ValueT
operator|&
name|get
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
specifier|const
block|{
comment|// Build a sequence of functions to get from iterator if possible.
name|ValueT
operator|*
operator|(
name|concat_iterator
operator|::
operator|*
name|GetHelperFns
index|[]
operator|)
operator|(
operator|)
specifier|const
operator|=
block|{
operator|&
name|concat_iterator
operator|::
name|getHelper
operator|<
name|Ns
operator|>
operator|...
block|}
block|;
comment|// Loop over them, and return the first result we find.
for|for
control|(
name|auto
operator|&
name|GetHelperFn
operator|:
name|GetHelperFns
control|)
if|if
condition|(
name|ValueT
modifier|*
name|P
init|=
operator|(
name|this
operator|->*
name|GetHelperFn
operator|)
operator|(
operator|)
condition|)
return|return
operator|*
name|P
return|;
name|llvm_unreachable
argument_list|(
literal|"Attempted to get a pointer from an end concat iterator!"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Constructs an iterator from a squence of ranges.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// We need the full range to know how to switch between each of the
end_comment

begin_comment
comment|/// iterators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|RangeTs
operator|>
name|explicit
name|concat_iterator
argument_list|(
name|RangeTs
operator|&&
operator|...
name|Ranges
argument_list|)
operator|:
name|IterPairs
argument_list|(
argument|{std::begin(Ranges)
argument_list|,
argument|std::end(Ranges)}...
argument_list|)
block|{}
name|using
name|BaseT
operator|::
name|operator
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|concat_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|increment
argument_list|(
name|index_sequence_for
operator|<
name|IterTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ValueT
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|index_sequence_for
operator|<
name|IterTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|concat_iterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|IterPairs
operator|==
name|RHS
operator|.
name|IterPairs
return|;
block|}
end_expr_stmt

begin_decl_stmt
unit|};
name|namespace
name|detail
block|{
comment|/// Helper to store a sequence of ranges being concatenated and access them.
comment|///
comment|/// This is designed to facilitate providing actual storage when temporaries
comment|/// are passed into the constructor such that we can use it as part of range
comment|/// based for loops.
name|template
operator|<
name|typename
name|ValueT
operator|,
name|typename
operator|...
name|RangeTs
operator|>
name|class
name|concat_range
block|{
name|public
operator|:
typedef|typedef
name|concat_iterator
operator|<
name|ValueT
operator|,
name|decltype
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|std
operator|::
name|declval
operator|<
name|RangeTs
operator|&
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
operator|...
operator|>
name|iterator
expr_stmt|;
name|private
operator|:
name|std
operator|::
name|tuple
operator|<
name|RangeTs
operator|...
operator|>
name|Ranges
expr_stmt|;
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|iterator
name|begin_impl
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|Ranges
operator|)
operator|...
argument_list|)
return|;
block|}
name|template
operator|<
name|size_t
operator|...
name|Ns
operator|>
name|iterator
name|end_impl
argument_list|(
argument|index_sequence<Ns...>
argument_list|)
block|{
return|return
name|iterator
argument_list|(
name|make_range
argument_list|(
name|std
operator|::
name|end
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|Ranges
operator|)
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|std
operator|::
name|get
operator|<
name|Ns
operator|>
operator|(
name|Ranges
operator|)
argument_list|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
name|public
label|:
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|begin_impl
argument_list|(
name|index_sequence_for
operator|<
name|RangeTs
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|end_impl
argument_list|(
name|index_sequence_for
operator|<
name|RangeTs
operator|...
operator|>
block|{}
argument_list|)
return|;
block|}
name|concat_range
argument_list|(
name|RangeTs
operator|&&
operator|...
name|Ranges
argument_list|)
operator|:
name|Ranges
argument_list|(
argument|std::forward<RangeTs>(Ranges)...
argument_list|)
block|{}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/// Concatenated range across two or more ranges.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The desired value type must be explicitly specified.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|ValueT
operator|,
name|typename
operator|...
name|RangeTs
operator|>
name|detail
operator|::
name|concat_range
operator|<
name|ValueT
operator|,
name|RangeTs
operator|...
operator|>
name|concat
argument_list|(
argument|RangeTs&&... Ranges
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof...
argument_list|(
name|RangeTs
argument_list|)
operator|>
literal|1
argument_list|,
literal|"Need more than one range to concatenate!"
argument_list|)
block|;
return|return
name|detail
operator|::
name|concat_range
operator|<
name|ValueT
operator|,
name|RangeTs
operator|...
operator|>
operator|(
name|std
operator|::
name|forward
operator|<
name|RangeTs
operator|>
operator|(
name|Ranges
operator|)
operator|...
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//     Extra additions to<utility>
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief Function object to check whether the first component of a std::pair
end_comment

begin_comment
comment|/// compares less than the first component of another std::pair.
end_comment

begin_struct
struct|struct
name|less_first
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|lhs
operator|,
specifier|const
name|T
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|lhs
operator|.
name|first
operator|<
name|rhs
operator|.
name|first
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// \brief Function object to check whether the second component of a std::pair
end_comment

begin_comment
comment|/// compares less than the second component of another std::pair.
end_comment

begin_struct
struct|struct
name|less_second
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|lhs
operator|,
specifier|const
name|T
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|lhs
operator|.
name|second
operator|<
name|rhs
operator|.
name|second
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|// A subset of N3658. More stuff can be added as-needed.
end_comment

begin_comment
comment|/// \brief Represents a compile-time sequence of integers.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|T
operator|...
name|I
operator|>
expr|struct
name|integer_sequence
block|{
typedef|typedef
name|T
name|value_type
typedef|;
specifier|static
name|constexpr
name|size_t
name|size
argument_list|()
block|{
return|return
sizeof|sizeof...
argument_list|(
name|I
argument_list|)
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Alias for the common case of a sequence of size_ts.
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
operator|...
name|I
operator|>
expr|struct
name|index_sequence
operator|:
name|integer_sequence
operator|<
name|std
operator|::
name|size_t
operator|,
name|I
operator|...
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
name|N
operator|,
name|std
operator|::
name|size_t
operator|...
name|I
operator|>
expr|struct
name|build_index_impl
operator|:
name|build_index_impl
operator|<
name|N
operator|-
literal|1
operator|,
name|N
operator|-
literal|1
operator|,
name|I
operator|...
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
operator|...
name|I
operator|>
expr|struct
name|build_index_impl
operator|<
literal|0
operator|,
name|I
operator|...
operator|>
operator|:
name|index_sequence
operator|<
name|I
operator|...
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Creates a compile-time integer sequence for a parameter pack.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
operator|...
name|Ts
operator|>
expr|struct
name|index_sequence_for
operator|:
name|build_index_impl
operator|<
sizeof|sizeof...
argument_list|(
name|Ts
argument_list|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Utility type to build an inheritance chain that makes it easy to rank
end_comment

begin_comment
comment|/// overload candidates.
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|N
operator|>
expr|struct
name|rank
operator|:
name|rank
operator|<
name|N
operator|-
literal|1
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|rank
operator|<
literal|0
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief traits class for checking whether type T is one of any of the given
end_comment

begin_comment
comment|/// types in the variadic list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|...
name|Ts
operator|>
expr|struct
name|is_one_of
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|,
name|typename
operator|...
name|Ts
operator|>
expr|struct
name|is_one_of
operator|<
name|T
operator|,
name|U
operator|,
name|Ts
operator|...
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_same
operator|<
name|T
block|,
name|U
operator|>
operator|::
name|value
operator|||
name|is_one_of
operator|<
name|T
block|,
name|Ts
operator|...
operator|>
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief traits class for checking whether type T is a base class for all
end_comment

begin_comment
comment|///  the given types in the variadic list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|...
name|Ts
operator|>
expr|struct
name|are_base_of
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|,
name|typename
operator|...
name|Ts
operator|>
expr|struct
name|are_base_of
operator|<
name|T
operator|,
name|U
operator|,
name|Ts
operator|...
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_base_of
operator|<
name|T
block|,
name|U
operator|>
operator|::
name|value
operator|&&
name|are_base_of
operator|<
name|T
block|,
name|Ts
operator|...
operator|>
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//     Extra additions for arrays
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// Find the length of an array.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|std
operator|::
name|size_t
name|N
operator|>
name|constexpr
specifier|inline
name|size_t
name|array_lengthof
argument_list|(
argument|T (&)[N]
argument_list|)
block|{
return|return
name|N
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Adapt std::less<T> for array_pod_sort.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|int
name|array_pod_sort_comparator
argument_list|(
argument|const void *P1
argument_list|,
argument|const void *P2
argument_list|)
block|{
if|if
condition|(
name|std
operator|::
name|less
operator|<
name|T
operator|>
operator|(
operator|)
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P1
operator|)
operator|,
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P2
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|std
operator|::
name|less
operator|<
name|T
operator|>
operator|(
operator|)
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P2
operator|)
operator|,
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|P1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
end_if

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/// get_array_pod_sort_comparator - This is an internal helper function used to
end_comment

begin_comment
comment|/// get type deduction of T right.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|int
argument_list|(
argument|*get_array_pod_sort_comparator(const T&)
argument_list|)
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
block|{
return|return
name|array_pod_sort_comparator
operator|<
name|T
operator|>
return|;
block|}
end_expr_stmt

begin_comment
comment|/// array_pod_sort - This sorts an array with the specified start and end
end_comment

begin_comment
comment|/// extent.  This is just like std::sort, except that it calls qsort instead of
end_comment

begin_comment
comment|/// using an inlined template.  qsort is slightly slower than std::sort, but
end_comment

begin_comment
comment|/// most sorts are not performance critical in LLVM and std::sort has to be
end_comment

begin_comment
comment|/// template instantiated for each type, leading to significant measured code
end_comment

begin_comment
comment|/// bloat.  This function should generally be used instead of std::sort where
end_comment

begin_comment
comment|/// possible.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This function assumes that you have simple POD-like types that can be
end_comment

begin_comment
comment|/// compared with std::less and can be moved with memcpy.  If this isn't true,
end_comment

begin_comment
comment|/// you should use std::sort.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// NOTE: If qsort_r were portable, we could allow a custom comparator and
end_comment

begin_comment
comment|/// default to std::less.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|IteratorTy
operator|>
specifier|inline
name|void
name|array_pod_sort
argument_list|(
argument|IteratorTy Start
argument_list|,
argument|IteratorTy End
argument_list|)
block|{
comment|// Don't inefficiently call qsort with one element or trigger undefined
comment|// behavior with an empty sequence.
name|auto
name|NElts
operator|=
name|End
operator|-
name|Start
block|;
if|if
condition|(
name|NElts
operator|<=
literal|1
condition|)
return|return;
name|qsort
argument_list|(
operator|&
operator|*
name|Start
argument_list|,
name|NElts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|,
name|get_array_pod_sort_comparator
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|IteratorTy
operator|>
specifier|inline
name|void
name|array_pod_sort
argument_list|(
argument|IteratorTy Start
argument_list|,
argument|IteratorTy End
argument_list|,
argument|int (*Compare)(         const typename std::iterator_traits<IteratorTy>::value_type *,         const typename std::iterator_traits<IteratorTy>::value_type *)
argument_list|)
block|{
comment|// Don't inefficiently call qsort with one element or trigger undefined
comment|// behavior with an empty sequence.
name|auto
name|NElts
operator|=
name|End
operator|-
name|Start
block|;
if|if
condition|(
name|NElts
operator|<=
literal|1
condition|)
return|return;
name|qsort
argument_list|(
operator|&
operator|*
name|Start
argument_list|,
name|NElts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Start
argument_list|)
argument_list|,
name|reinterpret_cast
operator|<
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|>
operator|(
name|Compare
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//     Extra additions to<algorithm>
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// For a container of pointers, deletes the pointers and then clears the
end_comment

begin_comment
comment|/// container.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Container
operator|>
name|void
name|DeleteContainerPointers
argument_list|(
argument|Container&C
argument_list|)
block|{
for|for
control|(
name|auto
name|V
range|:
name|C
control|)
name|delete
name|V
decl_stmt|;
name|C
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// In a container of pairs (usually a map) whose second element is a pointer,
end_comment

begin_comment
comment|/// deletes the second elements and then clears the container.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Container
operator|>
name|void
name|DeleteContainerSeconds
argument_list|(
argument|Container&C
argument_list|)
block|{
for|for
control|(
name|auto
operator|&
name|V
operator|:
name|C
control|)
name|delete
name|V
operator|.
name|second
decl_stmt|;
name|C
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// Provide wrappers to std::all_of which take ranges instead of having to pass
end_comment

begin_comment
comment|/// begin/end explicitly.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|bool
name|all_of
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
return|return
name|std
operator|::
name|all_of
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::any_of which take ranges instead of having to pass
end_comment

begin_comment
comment|/// begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|bool
name|any_of
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
return|return
name|std
operator|::
name|any_of
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::none_of which take ranges instead of having to pass
end_comment

begin_comment
comment|/// begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|bool
name|none_of
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
return|return
name|std
operator|::
name|none_of
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::find which take ranges instead of having to pass
end_comment

begin_comment
comment|/// begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|T
operator|>
name|auto
name|find
argument_list|(
name|R
operator|&&
name|Range
argument_list|,
specifier|const
name|T
operator|&
name|Val
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::begin(Range)
argument_list|)
block|{
return|return
name|std
operator|::
name|find
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|Val
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::find_if which take ranges instead of having to pass
end_comment

begin_comment
comment|/// begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|auto
name|find_if
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::begin(Range)
argument_list|)
block|{
return|return
name|std
operator|::
name|find_if
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|auto
name|find_if_not
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::begin(Range)
argument_list|)
block|{
return|return
name|std
operator|::
name|find_if_not
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::remove_if which take ranges instead of having to
end_comment

begin_comment
comment|/// pass begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|auto
name|remove_if
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::begin(Range)
argument_list|)
block|{
return|return
name|std
operator|::
name|remove_if
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::copy_if which take ranges instead of having to
end_comment

begin_comment
comment|/// pass begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|OutputIt
operator|,
name|typename
name|UnaryPredicate
operator|>
name|OutputIt
name|copy_if
argument_list|(
argument|R&&Range
argument_list|,
argument|OutputIt Out
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
return|return
name|std
operator|::
name|copy_if
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|Out
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Wrapper function around std::find to detect if an element exists
end_comment

begin_comment
comment|/// in a container.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|E
operator|>
name|bool
name|is_contained
argument_list|(
argument|R&&Range
argument_list|,
argument|const E&Element
argument_list|)
block|{
return|return
name|std
operator|::
name|find
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|Element
argument_list|)
operator|!=
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Wrapper function around std::count to count the number of times an element
end_comment

begin_comment
comment|/// \p Element occurs in the given range \p Range.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|E
operator|>
name|auto
name|count
argument_list|(
name|R
operator|&&
name|Range
argument_list|,
specifier|const
name|E
operator|&
name|Element
argument_list|)
operator|->
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|)
operator|>
operator|::
name|difference_type
block|{
return|return
name|std
operator|::
name|count
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|Element
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Wrapper function around std::count_if to count the number of times an
end_comment

begin_comment
comment|/// element satisfying a given predicate occurs in a range.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|auto
name|count_if
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
operator|->
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|)
operator|>
operator|::
name|difference_type
block|{
return|return
name|std
operator|::
name|count_if
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Wrapper function around std::transform to apply a function to a range and
end_comment

begin_comment
comment|/// store the result elsewhere.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|OutputIt
operator|,
name|typename
name|UnaryPredicate
operator|>
name|OutputIt
name|transform
argument_list|(
argument|R&&Range
argument_list|,
argument|OutputIt d_first
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
return|return
name|std
operator|::
name|transform
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|d_first
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide wrappers to std::partition which take ranges instead of having to
end_comment

begin_comment
comment|/// pass begin/end explicitly.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|UnaryPredicate
operator|>
name|auto
name|partition
argument_list|(
argument|R&&Range
argument_list|,
argument|UnaryPredicate P
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::begin(Range)
argument_list|)
block|{
return|return
name|std
operator|::
name|partition
argument_list|(
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
argument_list|,
name|std
operator|::
name|end
argument_list|(
name|Range
argument_list|)
argument_list|,
name|P
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Given a range of type R, iterate the entire range and return a
end_comment

begin_comment
comment|/// SmallVector with elements of the vector.  This is useful, for example,
end_comment

begin_comment
comment|/// when you want to iterate a range and then sort the results.
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|Size
operator|,
name|typename
name|R
operator|>
name|SmallVector
operator|<
name|typename
name|std
operator|::
name|remove_const
operator|<
name|detail
operator|::
name|ValueOfRange
operator|<
name|R
operator|>>
operator|::
name|type
operator|,
name|Size
operator|>
name|to_vector
argument_list|(
argument|R&&Range
argument_list|)
block|{
return|return
block|{
name|std
operator|::
name|begin
argument_list|(
name|Range
argument_list|)
block|,
name|std
operator|::
name|end
argument_list|(
argument|Range
argument_list|)
block|}
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Provide a container algorithm similar to C++ Library Fundamentals v2's
end_comment

begin_comment
comment|/// `erase_if` which is equivalent to:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   C.erase(remove_if(C, pred), C.end());
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This version works for any container with an erase method call accepting
end_comment

begin_comment
comment|/// two iterators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Container
operator|,
name|typename
name|UnaryPredicate
operator|>
name|void
name|erase_if
argument_list|(
argument|Container&C
argument_list|,
argument|UnaryPredicate P
argument_list|)
block|{
name|C
operator|.
name|erase
argument_list|(
name|remove_if
argument_list|(
name|C
argument_list|,
name|P
argument_list|)
argument_list|,
name|C
operator|.
name|end
argument_list|()
argument_list|)
block|; }
comment|//===----------------------------------------------------------------------===//
comment|//     Extra additions to<memory>
comment|//===----------------------------------------------------------------------===//
comment|// Implement make_unique according to N3656.
comment|/// \brief Constructs a `new T()` with the given args and returns a
comment|///        `unique_ptr<T>` which owns the object.
comment|///
comment|/// Example:
comment|///
comment|///     auto p = make_unique<int>();
comment|///     auto p = make_unique<std::tuple<int, int>>(0, 1);
name|template
operator|<
name|class
name|T
operator|,
name|class
operator|...
name|Args
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|Args&&... args
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Constructs a `new T[n]` with the given args and returns a
end_comment

begin_comment
comment|///        `unique_ptr<T[]>` which owns the object.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param n size of the new array.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Example:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///     auto p = make_unique<int[]>(2); // value-initializes the array with 0's.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|std
operator|::
name|extent
operator|<
name|T
operator|>
operator|::
name|value
operator|==
literal|0
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>>
operator|::
name|type
name|make_unique
argument_list|(
argument|size_t n
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|T
operator|>
operator|(
name|new
name|typename
name|std
operator|::
name|remove_extent
operator|<
name|T
operator|>
operator|::
name|type
index|[
name|n
index|]
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// This function isn't used and is only here to provide better compile errors.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
operator|...
name|Args
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|extent
operator|<
name|T
operator|>
operator|::
name|value
operator|!=
literal|0
operator|>
operator|::
name|type
name|make_unique
argument_list|(
name|Args
operator|&&
operator|...
argument_list|)
operator|=
name|delete
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|FreeDeleter
block|{
name|void
name|operator
argument_list|()
operator|(
name|void
operator|*
name|v
operator|)
block|{
operator|::
name|free
argument_list|(
name|v
argument_list|)
block|;   }
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|typename
name|First
operator|,
name|typename
name|Second
operator|>
expr|struct
name|pair_hash
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|First
operator|,
name|Second
operator|>
operator|&
name|P
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|hash
operator|<
name|First
operator|>
operator|(
operator|)
operator|(
name|P
operator|.
name|first
operator|)
operator|*
literal|31
operator|+
name|std
operator|::
name|hash
operator|<
name|Second
operator|>
operator|(
operator|)
operator|(
name|P
operator|.
name|second
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// A functor like C++14's std::less<void> in its absence.
end_comment

begin_struct
struct|struct
name|less
block|{
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
name|bool
name|operator
argument_list|()
operator|(
name|A
operator|&&
name|a
operator|,
name|B
operator|&&
name|b
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|forward
operator|<
name|A
operator|>
operator|(
name|a
operator|)
operator|<
name|std
operator|::
name|forward
operator|<
name|B
operator|>
operator|(
name|b
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// A functor like C++14's std::equal<void> in its absence.
end_comment

begin_struct
struct|struct
name|equal
block|{
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
name|bool
name|operator
argument_list|()
operator|(
name|A
operator|&&
name|a
operator|,
name|B
operator|&&
name|b
operator|)
specifier|const
block|{
return|return
name|std
operator|::
name|forward
operator|<
name|A
operator|>
operator|(
name|a
operator|)
operator|==
name|std
operator|::
name|forward
operator|<
name|B
operator|>
operator|(
name|b
operator|)
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// Binary functor that adapts to any other binary functor after dereferencing
end_comment

begin_comment
comment|/// operands.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|deref
block|{
name|T
name|func
block|;
comment|// Could be further improved to cope with non-derivable functors and
comment|// non-binary functors (should be a variadic template member function
comment|// operator()).
name|template
operator|<
name|typename
name|A
block|,
name|typename
name|B
operator|>
name|auto
name|operator
argument_list|()
operator|(
name|A
operator|&
name|lhs
operator|,
name|B
operator|&
name|rhs
operator|)
specifier|const
operator|->
name|decltype
argument_list|(
argument|func(*lhs, *rhs)
argument_list|)
block|{
name|assert
argument_list|(
name|lhs
argument_list|)
block|;
name|assert
argument_list|(
name|rhs
argument_list|)
block|;
return|return
name|func
argument_list|(
operator|*
name|lhs
argument_list|,
operator|*
name|rhs
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
unit|};
name|namespace
name|detail
block|{
name|template
operator|<
name|typename
name|R
operator|>
name|class
name|enumerator_iter
expr_stmt|;
name|template
operator|<
name|typename
name|R
operator|>
expr|struct
name|result_pair
block|{
name|friend
name|class
name|enumerator_iter
operator|<
name|R
operator|>
block|;
name|result_pair
argument_list|()
operator|:
name|Index
argument_list|(
argument|-
literal|1
argument_list|)
block|{}
name|result_pair
argument_list|(
argument|std::size_t Index
argument_list|,
argument|IterOfRange<R> Iter
argument_list|)
operator|:
name|Index
argument_list|(
name|Index
argument_list|)
block|,
name|Iter
argument_list|(
argument|Iter
argument_list|)
block|{}
name|result_pair
operator|<
name|R
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|result_pair
operator|<
name|R
operator|>
operator|&
name|Other
operator|)
block|{
name|Index
operator|=
name|Other
operator|.
name|Index
block|;
name|Iter
operator|=
name|Other
operator|.
name|Iter
block|;
return|return
operator|*
name|this
return|;
block|}
name|std
operator|::
name|size_t
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
specifier|const
name|ValueOfRange
operator|<
name|R
operator|>
operator|&
name|value
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Iter
return|;
block|}
name|ValueOfRange
operator|<
name|R
operator|>
operator|&
name|value
argument_list|()
block|{
return|return
operator|*
name|Iter
return|;
block|}
name|private
operator|:
name|std
operator|::
name|size_t
name|Index
block|;
name|IterOfRange
operator|<
name|R
operator|>
name|Iter
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|R
operator|>
name|class
name|enumerator_iter
operator|:
name|public
name|iterator_facade_base
operator|<
name|enumerator_iter
operator|<
name|R
operator|>
operator|,
name|std
operator|::
name|forward_iterator_tag
operator|,
name|result_pair
operator|<
name|R
operator|>
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|IterOfRange
operator|<
name|R
operator|>>
operator|::
name|difference_type
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|IterOfRange
operator|<
name|R
operator|>>
operator|::
name|pointer
operator|,
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|IterOfRange
operator|<
name|R
operator|>>
operator|::
name|reference
operator|>
block|{
name|using
name|result_type
operator|=
name|result_pair
operator|<
name|R
operator|>
block|;
name|public
operator|:
name|explicit
name|enumerator_iter
argument_list|(
name|IterOfRange
operator|<
name|R
operator|>
name|EndIter
argument_list|)
operator|:
name|Result
argument_list|(
argument|std::numeric_limits<size_t>::max()
argument_list|,
argument|EndIter
argument_list|)
block|{ }
name|enumerator_iter
argument_list|(
argument|std::size_t Index
argument_list|,
argument|IterOfRange<R> Iter
argument_list|)
operator|:
name|Result
argument_list|(
argument|Index
argument_list|,
argument|Iter
argument_list|)
block|{}
name|result_type
operator|&
name|operator
operator|*
operator|(
operator|)
block|{
return|return
name|Result
return|;
block|}
specifier|const
name|result_type
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Result
return|;
block|}
name|enumerator_iter
operator|<
name|R
operator|>
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|assert
argument_list|(
name|Result
operator|.
name|Index
operator|!=
name|std
operator|::
name|numeric_limits
operator|<
name|size_t
operator|>
operator|::
name|max
argument_list|()
argument_list|)
block|;
operator|++
name|Result
operator|.
name|Iter
block|;
operator|++
name|Result
operator|.
name|Index
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|enumerator_iter
operator|<
name|R
operator|>
operator|&
name|RHS
operator|)
specifier|const
block|{
comment|// Don't compare indices here, only iterators.  It's possible for an end
comment|// iterator to have different indices depending on whether it was created
comment|// by calling std::end() versus incrementing a valid iterator.
return|return
name|Result
operator|.
name|Iter
operator|==
name|RHS
operator|.
name|Result
operator|.
name|Iter
return|;
block|}
name|enumerator_iter
operator|<
name|R
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|enumerator_iter
operator|<
name|R
operator|>
operator|&
name|Other
operator|)
block|{
name|Result
operator|=
name|Other
operator|.
name|Result
block|;
return|return
operator|*
name|this
return|;
block|}
name|private
operator|:
name|result_type
name|Result
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|R
operator|>
name|class
name|enumerator
block|{
name|public
operator|:
name|explicit
name|enumerator
argument_list|(
name|R
operator|&&
name|Range
argument_list|)
operator|:
name|TheRange
argument_list|(
argument|std::forward<R>(Range)
argument_list|)
block|{}
name|enumerator_iter
operator|<
name|R
operator|>
name|begin
argument_list|()
block|{
return|return
name|enumerator_iter
operator|<
name|R
operator|>
operator|(
literal|0
operator|,
name|std
operator|::
name|begin
argument_list|(
name|TheRange
argument_list|)
operator|)
return|;
block|}
name|enumerator_iter
operator|<
name|R
operator|>
name|end
argument_list|()
block|{
return|return
name|enumerator_iter
operator|<
name|R
operator|>
operator|(
name|std
operator|::
name|end
argument_list|(
name|TheRange
argument_list|)
operator|)
return|;
block|}
name|private
operator|:
name|R
name|TheRange
block|; }
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Given an input range, returns a new range whose values are are pair (A,B)
end_comment

begin_comment
comment|/// such that A is the 0-based index of the item in the sequence, and B is
end_comment

begin_comment
comment|/// the value from the original sequence.  Example:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// std::vector<char> Items = {'A', 'B', 'C', 'D'};
end_comment

begin_comment
comment|/// for (auto X : enumerate(Items)) {
end_comment

begin_comment
comment|///   printf("Item %d - %c\n", X.index(), X.value());
end_comment

begin_comment
comment|/// }
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Output:
end_comment

begin_comment
comment|///   Item 0 - A
end_comment

begin_comment
comment|///   Item 1 - B
end_comment

begin_comment
comment|///   Item 2 - C
end_comment

begin_comment
comment|///   Item 3 - D
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|>
name|detail
operator|::
name|enumerator
operator|<
name|R
operator|>
name|enumerate
argument_list|(
argument|R&&TheRange
argument_list|)
block|{
return|return
name|detail
operator|::
name|enumerator
operator|<
name|R
operator|>
operator|(
name|std
operator|::
name|forward
operator|<
name|R
operator|>
operator|(
name|TheRange
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|namespace
name|detail
block|{
name|template
operator|<
name|typename
name|F
operator|,
name|typename
name|Tuple
operator|,
name|std
operator|::
name|size_t
operator|...
name|I
operator|>
name|auto
name|apply_tuple_impl
argument_list|(
name|F
operator|&&
name|f
argument_list|,
name|Tuple
operator|&&
name|t
argument_list|,
name|index_sequence
operator|<
name|I
operator|...
operator|>
argument_list|)
operator|->
name|decltype
argument_list|(
argument|std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...)
argument_list|)
block|{
return|return
name|std
operator|::
name|forward
operator|<
name|F
operator|>
call|(
name|f
call|)
argument_list|(
name|std
operator|::
name|get
operator|<
name|I
operator|>
operator|(
name|std
operator|::
name|forward
operator|<
name|Tuple
operator|>
operator|(
name|t
operator|)
operator|)
operator|...
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/// Given an input tuple (a1, a2, ..., an), pass the arguments of the
end_comment

begin_comment
comment|/// tuple variadically to f as if by calling f(a1, a2, ..., an) and
end_comment

begin_comment
comment|/// return the result.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|F
operator|,
name|typename
name|Tuple
operator|>
name|auto
name|apply_tuple
argument_list|(
name|F
operator|&&
name|f
argument_list|,
name|Tuple
operator|&&
name|t
argument_list|)
operator|->
name|decltype
argument_list|(
argument|detail::apply_tuple_impl(     std::forward<F>(f), std::forward<Tuple>(t),     build_index_impl<         std::tuple_size<typename std::decay<Tuple>::type>::value>{})
argument_list|)
block|{
name|using
name|Indices
operator|=
name|build_index_impl
operator|<
name|std
operator|::
name|tuple_size
operator|<
name|typename
name|std
operator|::
name|decay
operator|<
name|Tuple
operator|>
operator|::
name|type
operator|>
operator|::
name|value
operator|>
block|;
return|return
name|detail
operator|::
name|apply_tuple_impl
argument_list|(
name|std
operator|::
name|forward
operator|<
name|F
operator|>
operator|(
name|f
operator|)
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Tuple
operator|>
operator|(
name|t
operator|)
argument_list|,
name|Indices
block|{}
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

