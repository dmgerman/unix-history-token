begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/SmallPtrSet.h - 'Normally small' pointer set ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the SmallPtrSet class.  See the doxygen comment for
end_comment

begin_comment
comment|// SmallPtrSetImplBase for more details on the algorithm used.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SMALLPTRSET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SMALLPTRSET_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PointerLikeTypeTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ReverseIteration.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<initializer_list>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// SmallPtrSetImplBase - This is the common code shared among all the
comment|/// SmallPtrSet<>'s, which is almost everything.  SmallPtrSet has two modes, one
comment|/// for small and one for large sets.
comment|///
comment|/// Small sets use an array of pointers allocated in the SmallPtrSet object,
comment|/// which is treated as a simple array of pointers.  When a pointer is added to
comment|/// the set, the array is scanned to see if the element already exists, if not
comment|/// the element is 'pushed back' onto the array.  If we run out of space in the
comment|/// array, we grow into the 'large set' case.  SmallSet should be used when the
comment|/// sets are often small.  In this case, no memory allocation is used, and only
comment|/// light-weight and cache-efficient scanning is used.
comment|///
comment|/// Large sets use a classic exponentially-probed hash table.  Empty buckets are
comment|/// represented with an illegal pointer value (-1) to allow null pointers to be
comment|/// inserted.  Tombstones are represented with another illegal pointer value
comment|/// (-2), to allow deletion.  The hash table is resized when the table is 3/4 or
comment|/// more.  When this happens, the table is doubled in size.
comment|///
name|class
name|SmallPtrSetImplBase
block|{
name|friend
name|class
name|SmallPtrSetIteratorImpl
decl_stmt|;
name|protected
label|:
comment|/// SmallArray - Points to a fixed size set of buckets, used in 'small mode'.
specifier|const
name|void
modifier|*
modifier|*
name|SmallArray
decl_stmt|;
comment|/// CurArray - This is the current set of buckets.  If equal to SmallArray,
comment|/// then the set is in 'small mode'.
specifier|const
name|void
modifier|*
modifier|*
name|CurArray
decl_stmt|;
comment|/// CurArraySize - The allocated size of CurArray, always a power of two.
name|unsigned
name|CurArraySize
decl_stmt|;
comment|/// Number of elements in CurArray that contain a value or are a tombstone.
comment|/// If small, all these elements are at the beginning of CurArray and the rest
comment|/// is uninitialized.
name|unsigned
name|NumNonEmpty
decl_stmt|;
comment|/// Number of tombstones in CurArray.
name|unsigned
name|NumTombstones
decl_stmt|;
comment|// Helpers to copy and move construct a SmallPtrSet.
name|SmallPtrSetImplBase
argument_list|(
specifier|const
name|void
operator|*
operator|*
name|SmallStorage
argument_list|,
specifier|const
name|SmallPtrSetImplBase
operator|&
name|that
argument_list|)
expr_stmt|;
name|SmallPtrSetImplBase
argument_list|(
argument|const void **SmallStorage
argument_list|,
argument|unsigned SmallSize
argument_list|,
argument|SmallPtrSetImplBase&&that
argument_list|)
empty_stmt|;
name|explicit
name|SmallPtrSetImplBase
argument_list|(
argument|const void **SmallStorage
argument_list|,
argument|unsigned SmallSize
argument_list|)
block|:
name|SmallArray
argument_list|(
name|SmallStorage
argument_list|)
operator|,
name|CurArray
argument_list|(
name|SmallStorage
argument_list|)
operator|,
name|CurArraySize
argument_list|(
name|SmallSize
argument_list|)
operator|,
name|NumNonEmpty
argument_list|(
literal|0
argument_list|)
operator|,
name|NumTombstones
argument_list|(
literal|0
argument_list|)
block|{
name|assert
argument_list|(
name|SmallSize
operator|&&
operator|(
name|SmallSize
operator|&
operator|(
name|SmallSize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
literal|"Initial size must be a power of two!"
argument_list|)
block|;   }
operator|~
name|SmallPtrSetImplBase
argument_list|()
block|{
if|if
condition|(
operator|!
name|isSmall
argument_list|()
condition|)
name|free
argument_list|(
name|CurArray
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|using
name|size_type
init|=
name|unsigned
decl_stmt|;
name|SmallPtrSetImplBase
modifier|&
name|operator
init|=
operator|(
specifier|const
name|SmallPtrSetImplBase
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|LLVM_NODISCARD
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|NumNonEmpty
operator|-
name|NumTombstones
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
comment|// If the capacity of the array is huge, and the # elements used is small,
comment|// shrink the array.
if|if
condition|(
operator|!
name|isSmall
argument_list|()
condition|)
block|{
if|if
condition|(
name|size
argument_list|()
operator|*
literal|4
operator|<
name|CurArraySize
operator|&&
name|CurArraySize
operator|>
literal|32
condition|)
return|return
name|shrink_and_clear
argument_list|()
return|;
comment|// Fill the array with empty markers.
name|memset
argument_list|(
name|CurArray
argument_list|,
operator|-
literal|1
argument_list|,
name|CurArraySize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NumNonEmpty
operator|=
literal|0
expr_stmt|;
name|NumTombstones
operator|=
literal|0
expr_stmt|;
block|}
name|protected
label|:
specifier|static
name|void
modifier|*
name|getTombstoneMarker
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
operator|-
literal|2
operator|)
return|;
block|}
specifier|static
name|void
modifier|*
name|getEmptyMarker
parameter_list|()
block|{
comment|// Note that -1 is chosen to make clear() efficiently implementable with
comment|// memset and because it's not a valid pointer value.
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
operator|-
literal|1
operator|)
return|;
block|}
specifier|const
name|void
operator|*
operator|*
name|EndPointer
argument_list|()
specifier|const
block|{
return|return
name|isSmall
argument_list|()
operator|?
name|CurArray
operator|+
name|NumNonEmpty
operator|:
name|CurArray
operator|+
name|CurArraySize
return|;
block|}
comment|/// insert_imp - This returns true if the pointer was new to the set, false if
comment|/// it was already in the set.  This is hidden from the client so that the
comment|/// derived class can check that the right type of pointer is passed in.
name|std
operator|::
name|pair
operator|<
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|,
name|bool
operator|>
name|insert_imp
argument_list|(
argument|const void *Ptr
argument_list|)
block|{
if|if
condition|(
name|isSmall
argument_list|()
condition|)
block|{
comment|// Check to see if it is already in the set.
specifier|const
name|void
modifier|*
modifier|*
name|LastTombstone
init|=
name|nullptr
decl_stmt|;
for|for
control|(
specifier|const
name|void
modifier|*
modifier|*
name|APtr
init|=
name|SmallArray
init|,
modifier|*
modifier|*
name|E
init|=
name|SmallArray
operator|+
name|NumNonEmpty
init|;
name|APtr
operator|!=
name|E
condition|;
operator|++
name|APtr
control|)
block|{
specifier|const
name|void
modifier|*
name|Value
init|=
operator|*
name|APtr
decl_stmt|;
if|if
condition|(
name|Value
operator|==
name|Ptr
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|APtr
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
name|Value
operator|==
name|getTombstoneMarker
argument_list|()
condition|)
name|LastTombstone
operator|=
name|APtr
expr_stmt|;
block|}
comment|// Did we find any tombstone marker?
if|if
condition|(
name|LastTombstone
operator|!=
name|nullptr
condition|)
block|{
operator|*
name|LastTombstone
operator|=
name|Ptr
expr_stmt|;
operator|--
name|NumTombstones
expr_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|LastTombstone
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|// Nope, there isn't.  If we stay small, just 'pushback' now.
if|if
condition|(
name|NumNonEmpty
operator|<
name|CurArraySize
condition|)
block|{
name|SmallArray
index|[
name|NumNonEmpty
operator|++
index|]
operator|=
name|Ptr
expr_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|SmallArray
operator|+
operator|(
name|NumNonEmpty
operator|-
literal|1
operator|)
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|// Otherwise, hit the big set case, which will call grow.
block|}
return|return
name|insert_imp_big
argument_list|(
name|Ptr
argument_list|)
return|;
block|}
comment|/// erase_imp - If the set contains the specified pointer, remove it and
comment|/// return true, otherwise return false.  This is hidden from the client so
comment|/// that the derived class can check that the right type of pointer is passed
comment|/// in.
name|bool
name|erase_imp
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|P
init|=
name|find_imp
argument_list|(
name|Ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|P
operator|==
name|EndPointer
argument_list|()
condition|)
return|return
name|false
return|;
specifier|const
name|void
modifier|*
modifier|*
name|Loc
init|=
name|const_cast
operator|<
specifier|const
name|void
operator|*
operator|*
operator|>
operator|(
name|P
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|*
name|Loc
operator|==
name|Ptr
operator|&&
literal|"broken find!"
argument_list|)
expr_stmt|;
operator|*
name|Loc
operator|=
name|getTombstoneMarker
argument_list|()
expr_stmt|;
name|NumTombstones
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// Returns the raw pointer needed to construct an iterator.  If element not
comment|/// found, this will be EndPointer.  Otherwise, it will be a pointer to the
comment|/// slot which stores Ptr;
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|find_imp
argument_list|(
specifier|const
name|void
operator|*
name|Ptr
argument_list|)
decl|const
block|{
if|if
condition|(
name|isSmall
argument_list|()
condition|)
block|{
comment|// Linear search for the item.
for|for
control|(
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|APtr
init|=
name|SmallArray
init|,
modifier|*
init|const
modifier|*
name|E
init|=
name|SmallArray
operator|+
name|NumNonEmpty
init|;
name|APtr
operator|!=
name|E
condition|;
operator|++
name|APtr
control|)
if|if
condition|(
operator|*
name|APtr
operator|==
name|Ptr
condition|)
return|return
name|APtr
return|;
return|return
name|EndPointer
argument_list|()
return|;
block|}
comment|// Big set case.
name|auto
operator|*
name|Bucket
operator|=
name|FindBucketFor
argument_list|(
name|Ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Bucket
operator|==
name|Ptr
condition|)
return|return
name|Bucket
return|;
return|return
name|EndPointer
argument_list|()
return|;
block|}
name|private
label|:
name|bool
name|isSmall
argument_list|()
specifier|const
block|{
return|return
name|CurArray
operator|==
name|SmallArray
return|;
block|}
name|std
operator|::
name|pair
operator|<
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|,
name|bool
operator|>
name|insert_imp_big
argument_list|(
specifier|const
name|void
operator|*
name|Ptr
argument_list|)
expr_stmt|;
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|FindBucketFor
argument_list|(
specifier|const
name|void
operator|*
name|Ptr
argument_list|)
decl|const
decl_stmt|;
name|void
name|shrink_and_clear
parameter_list|()
function_decl|;
comment|/// Grow - Allocate a larger backing store for the buckets and move it over.
name|void
name|Grow
parameter_list|(
name|unsigned
name|NewSize
parameter_list|)
function_decl|;
name|protected
label|:
comment|/// swap - Swaps the elements of two sets.
comment|/// Note: This method assumes that both sets have the same small size.
name|void
name|swap
parameter_list|(
name|SmallPtrSetImplBase
modifier|&
name|RHS
parameter_list|)
function_decl|;
name|void
name|CopyFrom
parameter_list|(
specifier|const
name|SmallPtrSetImplBase
modifier|&
name|RHS
parameter_list|)
function_decl|;
name|void
name|MoveFrom
argument_list|(
name|unsigned
name|SmallSize
argument_list|,
name|SmallPtrSetImplBase
operator|&&
name|RHS
argument_list|)
decl_stmt|;
name|private
label|:
comment|/// Code shared by MoveFrom() and move constructor.
name|void
name|MoveHelper
argument_list|(
name|unsigned
name|SmallSize
argument_list|,
name|SmallPtrSetImplBase
operator|&&
name|RHS
argument_list|)
decl_stmt|;
comment|/// Code shared by CopyFrom() and copy constructor.
name|void
name|CopyHelper
parameter_list|(
specifier|const
name|SmallPtrSetImplBase
modifier|&
name|RHS
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// SmallPtrSetIteratorImpl - This is the common base class shared between all
comment|/// instances of SmallPtrSetIterator.
name|class
name|SmallPtrSetIteratorImpl
block|{
name|protected
label|:
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|Bucket
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|End
decl_stmt|;
name|public
label|:
name|explicit
name|SmallPtrSetIteratorImpl
argument_list|(
specifier|const
name|void
operator|*
specifier|const
operator|*
name|BP
argument_list|,
specifier|const
name|void
operator|*
specifier|const
operator|*
name|E
argument_list|)
operator|:
name|Bucket
argument_list|(
name|BP
argument_list|)
operator|,
name|End
argument_list|(
argument|E
argument_list|)
block|{
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
if|if
condition|(
name|ReverseIterate
operator|<
name|bool
operator|>
operator|::
name|value
condition|)
block|{
name|RetreatIfNotValid
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|AdvanceIfNotValid
argument_list|()
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SmallPtrSetIteratorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Bucket
operator|==
name|RHS
operator|.
name|Bucket
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SmallPtrSetIteratorImpl
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Bucket
operator|!=
name|RHS
operator|.
name|Bucket
return|;
block|}
name|protected
label|:
comment|/// AdvanceIfNotValid - If the current bucket isn't valid, advance to a bucket
comment|/// that is.   This is guaranteed to stop because the end() bucket is marked
comment|/// valid.
name|void
name|AdvanceIfNotValid
parameter_list|()
block|{
name|assert
argument_list|(
name|Bucket
operator|<=
name|End
argument_list|)
expr_stmt|;
while|while
condition|(
name|Bucket
operator|!=
name|End
operator|&&
operator|(
operator|*
name|Bucket
operator|==
name|SmallPtrSetImplBase
operator|::
name|getEmptyMarker
argument_list|()
operator|||
operator|*
name|Bucket
operator|==
name|SmallPtrSetImplBase
operator|::
name|getTombstoneMarker
argument_list|()
operator|)
condition|)
operator|++
name|Bucket
expr_stmt|;
block|}
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
name|void
name|RetreatIfNotValid
parameter_list|()
block|{
name|assert
argument_list|(
name|Bucket
operator|>=
name|End
argument_list|)
expr_stmt|;
while|while
condition|(
name|Bucket
operator|!=
name|End
operator|&&
operator|(
name|Bucket
index|[
operator|-
literal|1
index|]
operator|==
name|SmallPtrSetImplBase
operator|::
name|getEmptyMarker
argument_list|()
operator|||
name|Bucket
index|[
operator|-
literal|1
index|]
operator|==
name|SmallPtrSetImplBase
operator|::
name|getTombstoneMarker
argument_list|()
operator|)
condition|)
block|{
operator|--
name|Bucket
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
empty_stmt|;
comment|/// SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.
name|template
operator|<
name|typename
name|PtrTy
operator|>
name|class
name|SmallPtrSetIterator
operator|:
name|public
name|SmallPtrSetIteratorImpl
block|{
name|using
name|PtrTraits
operator|=
name|PointerLikeTypeTraits
operator|<
name|PtrTy
operator|>
block|;
name|public
operator|:
name|using
name|value_type
operator|=
name|PtrTy
block|;
name|using
name|reference
operator|=
name|PtrTy
block|;
name|using
name|pointer
operator|=
name|PtrTy
block|;
name|using
name|difference_type
operator|=
name|std
operator|::
name|ptrdiff_t
block|;
name|using
name|iterator_category
operator|=
name|std
operator|::
name|forward_iterator_tag
block|;
name|explicit
name|SmallPtrSetIterator
argument_list|(
specifier|const
name|void
operator|*
specifier|const
operator|*
name|BP
argument_list|,
specifier|const
name|void
operator|*
specifier|const
operator|*
name|E
argument_list|)
operator|:
name|SmallPtrSetIteratorImpl
argument_list|(
argument|BP
argument_list|,
argument|E
argument_list|)
block|{}
comment|// Most methods provided by baseclass.
specifier|const
name|PtrTy
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
if|if
condition|(
name|ReverseIterate
operator|<
name|bool
operator|>
operator|::
name|value
condition|)
block|{
name|assert
argument_list|(
name|Bucket
operator|>
name|End
argument_list|)
expr_stmt|;
return|return
name|PtrTraits
operator|::
name|getFromVoidPointer
argument_list|(
name|const_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|Bucket
index|[
operator|-
literal|1
index|]
operator|)
argument_list|)
return|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|Bucket
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|PtrTraits
operator|::
name|getFromVoidPointer
argument_list|(
name|const_cast
operator|<
name|void
operator|*
operator|>
operator|(
operator|*
name|Bucket
operator|)
argument_list|)
return|;
block|}
specifier|inline
name|SmallPtrSetIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
if|if
condition|(
name|ReverseIterate
operator|<
name|bool
operator|>
operator|::
name|value
condition|)
block|{
operator|--
name|Bucket
expr_stmt|;
name|RetreatIfNotValid
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
operator|++
name|Bucket
expr_stmt|;
name|AdvanceIfNotValid
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SmallPtrSetIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|SmallPtrSetIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next
end_comment

begin_comment
comment|/// power of two (which means N itself if N is already a power of two).
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|N
operator|>
expr|struct
name|RoundUpToPowerOfTwo
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// RoundUpToPowerOfTwoH - If N is not a power of two, increase it.  This is a
end_comment

begin_comment
comment|/// helper template used to implement RoundUpToPowerOfTwo.
end_comment

begin_expr_stmt
name|template
operator|<
name|unsigned
name|N
operator|,
name|bool
name|isPowerTwo
operator|>
expr|struct
name|RoundUpToPowerOfTwoH
block|{   enum
block|{
name|Val
operator|=
name|N
block|}
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|N
operator|>
expr|struct
name|RoundUpToPowerOfTwoH
operator|<
name|N
operator|,
name|false
operator|>
block|{   enum
block|{
comment|// We could just use NextVal = N+1, but this converges faster.  N|(N-1) sets
comment|// the right-most zero bits to one all at once, e.g. 0b0011000 -> 0b0011111.
name|Val
operator|=
name|RoundUpToPowerOfTwo
operator|<
operator|(
name|N
operator||
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
operator|>
operator|::
name|Val
block|}
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|unsigned
name|N
operator|>
expr|struct
name|RoundUpToPowerOfTwo
block|{   enum
block|{
name|Val
operator|=
name|RoundUpToPowerOfTwoH
operator|<
name|N
block|,
operator|(
name|N
operator|&
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|>
operator|::
name|Val
block|}
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief A templated base class for \c SmallPtrSet which provides the
end_comment

begin_comment
comment|/// typesafe interface that is common across all small sizes.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is particularly useful for passing around between interface boundaries
end_comment

begin_comment
comment|/// to avoid encoding a particular small size in the interface boundary.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PtrType
operator|>
name|class
name|SmallPtrSetImpl
operator|:
name|public
name|SmallPtrSetImplBase
block|{
name|using
name|ConstPtrType
operator|=
name|typename
name|add_const_past_pointer
operator|<
name|PtrType
operator|>
operator|::
name|type
block|;
name|using
name|PtrTraits
operator|=
name|PointerLikeTypeTraits
operator|<
name|PtrType
operator|>
block|;
name|using
name|ConstPtrTraits
operator|=
name|PointerLikeTypeTraits
operator|<
name|ConstPtrType
operator|>
block|;
name|protected
operator|:
comment|// Constructors that forward to the base.
name|SmallPtrSetImpl
argument_list|(
specifier|const
name|void
operator|*
operator|*
name|SmallStorage
argument_list|,
specifier|const
name|SmallPtrSetImpl
operator|&
name|that
argument_list|)
operator|:
name|SmallPtrSetImplBase
argument_list|(
argument|SmallStorage
argument_list|,
argument|that
argument_list|)
block|{}
name|SmallPtrSetImpl
argument_list|(
argument|const void **SmallStorage
argument_list|,
argument|unsigned SmallSize
argument_list|,
argument|SmallPtrSetImpl&&that
argument_list|)
operator|:
name|SmallPtrSetImplBase
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSize
argument_list|,
argument|std::move(that)
argument_list|)
block|{}
name|explicit
name|SmallPtrSetImpl
argument_list|(
argument|const void **SmallStorage
argument_list|,
argument|unsigned SmallSize
argument_list|)
operator|:
name|SmallPtrSetImplBase
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSize
argument_list|)
block|{}
name|public
operator|:
name|using
name|iterator
operator|=
name|SmallPtrSetIterator
operator|<
name|PtrType
operator|>
block|;
name|using
name|const_iterator
operator|=
name|SmallPtrSetIterator
operator|<
name|PtrType
operator|>
block|;
name|using
name|key_type
operator|=
name|ConstPtrType
block|;
name|using
name|value_type
operator|=
name|PtrType
block|;
name|SmallPtrSetImpl
argument_list|(
specifier|const
name|SmallPtrSetImpl
operator|&
argument_list|)
operator|=
name|delete
block|;
comment|/// Inserts Ptr if and only if there is no element in the container equal to
comment|/// Ptr. The bool component of the returned pair is true if and only if the
comment|/// insertion takes place, and the iterator component of the pair points to
comment|/// the element equal to Ptr.
name|std
operator|::
name|pair
operator|<
name|iterator
block|,
name|bool
operator|>
name|insert
argument_list|(
argument|PtrType Ptr
argument_list|)
block|{
name|auto
name|p
operator|=
name|insert_imp
argument_list|(
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|Ptr
argument_list|)
argument_list|)
block|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|makeIterator
argument_list|(
name|p
operator|.
name|first
argument_list|)
argument_list|,
name|p
operator|.
name|second
argument_list|)
return|;
block|}
comment|/// erase - If the set contains the specified pointer, remove it and return
comment|/// true, otherwise return false.
name|bool
name|erase
argument_list|(
argument|PtrType Ptr
argument_list|)
block|{
return|return
name|erase_imp
argument_list|(
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|Ptr
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// count - Return 1 if the specified pointer is in the set, 0 otherwise.
end_comment

begin_decl_stmt
name|size_type
name|count
argument_list|(
name|ConstPtrType
name|Ptr
argument_list|)
decl|const
block|{
return|return
name|find
argument_list|(
name|Ptr
argument_list|)
operator|!=
name|end
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|iterator
name|find
argument_list|(
name|ConstPtrType
name|Ptr
argument_list|)
decl|const
block|{
return|return
name|makeIterator
argument_list|(
name|find_imp
argument_list|(
name|ConstPtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|Ptr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|IterT
operator|>
name|void
name|insert
argument_list|(
argument|IterT I
argument_list|,
argument|IterT E
argument_list|)
block|{
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|insert
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|insert
argument_list|(
name|std
operator|::
name|initializer_list
operator|<
name|PtrType
operator|>
name|IL
argument_list|)
block|{
name|insert
argument_list|(
name|IL
operator|.
name|begin
argument_list|()
argument_list|,
name|IL
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
if|if
condition|(
name|ReverseIterate
operator|<
name|bool
operator|>
operator|::
name|value
condition|)
return|return
name|makeIterator
argument_list|(
name|EndPointer
argument_list|()
operator|-
literal|1
argument_list|)
return|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|makeIterator
argument_list|(
name|CurArray
argument_list|)
return|;
end_return

begin_macro
unit|}   iterator
name|end
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|makeIterator
argument_list|(
name|EndPointer
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|/// Create an iterator that dereferences to same place as the given pointer.
end_comment

begin_decl_stmt
name|iterator
name|makeIterator
argument_list|(
specifier|const
name|void
operator|*
specifier|const
operator|*
name|P
argument_list|)
decl|const
block|{
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
if|if
condition|(
name|ReverseIterate
operator|<
name|bool
operator|>
operator|::
name|value
condition|)
return|return
name|iterator
argument_list|(
name|P
operator|==
name|EndPointer
argument_list|()
condition|?
name|CurArray
else|:
name|P
operator|+
literal|1
argument_list|,
name|CurArray
argument_list|)
return|;
endif|#
directive|endif
return|return
name|iterator
argument_list|(
name|P
argument_list|,
name|EndPointer
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|/// SmallPtrSet - This class implements a set which is optimized for holding
end_comment

begin_comment
comment|/// SmallSize or less elements.  This internally rounds up SmallSize to the next
end_comment

begin_comment
comment|/// power of two if it is not already a power of two.  See the comments above
end_comment

begin_comment
comment|/// SmallPtrSetImplBase for details of the algorithm.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|PtrType
operator|,
name|unsigned
name|SmallSize
operator|>
name|class
name|SmallPtrSet
operator|:
name|public
name|SmallPtrSetImpl
operator|<
name|PtrType
operator|>
block|{
comment|// In small mode SmallPtrSet uses linear search for the elements, so it is
comment|// not a good idea to choose this value too high. You may consider using a
comment|// DenseSet<> instead if you expect many elements in the set.
name|static_assert
argument_list|(
name|SmallSize
operator|<=
literal|32
argument_list|,
literal|"SmallSize should be small"
argument_list|)
block|;
name|using
name|BaseT
operator|=
name|SmallPtrSetImpl
operator|<
name|PtrType
operator|>
block|;
comment|// Make sure that SmallSize is a power of two, round up if not.
block|enum
block|{
name|SmallSizePowTwo
operator|=
name|RoundUpToPowerOfTwo
operator|<
name|SmallSize
operator|>
operator|::
name|Val
block|}
block|;
comment|/// SmallStorage - Fixed size storage used in 'small mode'.
specifier|const
name|void
operator|*
name|SmallStorage
index|[
name|SmallSizePowTwo
index|]
block|;
name|public
operator|:
name|SmallPtrSet
argument_list|()
operator|:
name|BaseT
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSizePowTwo
argument_list|)
block|{}
name|SmallPtrSet
argument_list|(
specifier|const
name|SmallPtrSet
operator|&
name|that
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|SmallStorage
argument_list|,
argument|that
argument_list|)
block|{}
name|SmallPtrSet
argument_list|(
name|SmallPtrSet
operator|&&
name|that
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSizePowTwo
argument_list|,
argument|std::move(that)
argument_list|)
block|{}
name|template
operator|<
name|typename
name|It
operator|>
name|SmallPtrSet
argument_list|(
argument|It I
argument_list|,
argument|It E
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSizePowTwo
argument_list|)
block|{
name|this
operator|->
name|insert
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
block|;   }
name|SmallPtrSet
argument_list|(
name|std
operator|::
name|initializer_list
operator|<
name|PtrType
operator|>
name|IL
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|SmallStorage
argument_list|,
argument|SmallSizePowTwo
argument_list|)
block|{
name|this
operator|->
name|insert
argument_list|(
name|IL
operator|.
name|begin
argument_list|()
argument_list|,
name|IL
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
name|SmallPtrSet
operator|<
name|PtrType
block|,
name|SmallSize
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|SmallPtrSet
operator|<
name|PtrType
operator|,
name|SmallSize
operator|>
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
operator|&
name|RHS
operator|!=
name|this
condition|)
name|this
operator|->
name|CopyFrom
argument_list|(
name|RHS
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SmallPtrSet
operator|<
name|PtrType
operator|,
name|SmallSize
operator|>
operator|&
name|operator
operator|=
operator|(
name|SmallPtrSet
operator|<
name|PtrType
operator|,
name|SmallSize
operator|>
operator|&&
name|RHS
operator|)
block|{
if|if
condition|(
operator|&
name|RHS
operator|!=
name|this
condition|)
name|this
operator|->
name|MoveFrom
argument_list|(
name|SmallSizePowTwo
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}    SmallPtrSet
operator|<
name|PtrType
operator|,
name|SmallSize
operator|>
operator|&
name|operator
operator|=
operator|(
name|std
operator|::
name|initializer_list
operator|<
name|PtrType
operator|>
name|IL
operator|)
block|{
name|this
operator|->
name|clear
argument_list|()
block|;
name|this
operator|->
name|insert
argument_list|(
name|IL
operator|.
name|begin
argument_list|()
argument_list|,
name|IL
operator|.
name|end
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// swap - Swaps the elements of two sets.
end_comment

begin_decl_stmt
name|void
name|swap
argument_list|(
name|SmallPtrSet
operator|<
name|PtrType
argument_list|,
name|SmallSize
operator|>
operator|&
name|RHS
argument_list|)
block|{
name|SmallPtrSetImplBase
operator|::
name|swap
argument_list|(
name|RHS
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
comment|/// Implement std::swap in terms of SmallPtrSet swap.
name|template
operator|<
name|class
name|T
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|llvm::SmallPtrSet<T
argument_list|,
argument|N>&LHS
argument_list|,
argument|llvm::SmallPtrSet<T
argument_list|,
argument|N>&RHS
argument_list|)
block|{
name|LHS
operator|.
name|swap
argument_list|(
name|RHS
argument_list|)
block|;   }
block|}
end_block

begin_comment
comment|// end namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_SMALLPTRSET_H
end_comment

end_unit

