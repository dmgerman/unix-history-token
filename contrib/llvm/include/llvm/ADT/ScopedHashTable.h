begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ScopedHashTable.h - A simple scoped hash table ---------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements an efficient scoped hash table, which is useful for
end_comment

begin_comment
comment|// things like dominator-based optimizations.  This allows clients to do things
end_comment

begin_comment
comment|// like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  ScopedHashTable<int, int> HT;
end_comment

begin_comment
comment|//  {
end_comment

begin_comment
comment|//    ScopedHashTableScope<int, int> Scope1(HT);
end_comment

begin_comment
comment|//    HT.insert(0, 0);
end_comment

begin_comment
comment|//    HT.insert(1, 1);
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      ScopedHashTableScope<int, int> Scope2(HT);
end_comment

begin_comment
comment|//      HT.insert(0, 42);
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Looking up the value for "0" in the Scope2 block will return 42.  Looking
end_comment

begin_comment
comment|// up the value for 0 before 42 is inserted or after Scope2 is popped will
end_comment

begin_comment
comment|// return 0.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SCOPEDHASHTABLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SCOPEDHASHTABLE_H
end_define

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|K
operator|,
name|typename
name|V
operator|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
expr|>
name|class
name|ScopedHashTable
expr_stmt|;
name|template
operator|<
name|typename
name|K
operator|,
name|typename
name|V
operator|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
expr|>
name|class
name|ScopedHashTableVal
block|{
name|ScopedHashTableVal
operator|*
name|NextInScope
block|;
name|ScopedHashTableVal
operator|*
name|NextForKey
block|;
name|K
name|Key
block|;
name|V
name|Val
block|;
name|public
operator|:
name|ScopedHashTableVal
argument_list|(
name|ScopedHashTableVal
operator|*
name|nextInScope
argument_list|,
name|ScopedHashTableVal
operator|*
name|nextForKey
argument_list|,
specifier|const
name|K
operator|&
name|key
argument_list|,
specifier|const
name|V
operator|&
name|val
argument_list|)
operator|:
name|NextInScope
argument_list|(
name|nextInScope
argument_list|)
block|,
name|NextForKey
argument_list|(
name|nextForKey
argument_list|)
block|,
name|Key
argument_list|(
name|key
argument_list|)
block|,
name|Val
argument_list|(
argument|val
argument_list|)
block|{   }
specifier|const
name|K
operator|&
name|getKey
argument_list|()
specifier|const
block|{
return|return
name|Key
return|;
block|}
specifier|const
name|V
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|V
operator|&
name|getValue
argument_list|()
block|{
return|return
name|Val
return|;
block|}
name|ScopedHashTableVal
operator|*
name|getNextForKey
argument_list|()
block|{
return|return
name|NextForKey
return|;
block|}
specifier|const
name|ScopedHashTableVal
operator|*
name|getNextForKey
argument_list|()
specifier|const
block|{
return|return
name|NextForKey
return|;
block|}
name|public
operator|:
name|ScopedHashTableVal
operator|*
name|getNextInScope
argument_list|()
block|{
return|return
name|NextInScope
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
expr|>
name|class
name|ScopedHashTableScope
block|{
comment|/// HT - The hashtable that we are active for.
name|ScopedHashTable
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|&
name|HT
block|;
comment|/// PrevScope - This is the scope that we are shadowing in HT.
name|ScopedHashTableScope
operator|*
name|PrevScope
block|;
comment|/// LastValInScope - This is the last value that was inserted for this scope
comment|/// or null if none have been inserted yet.
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
name|LastValInScope
block|;
name|void
name|operator
operator|=
operator|(
name|ScopedHashTableScope
operator|&
operator|)
block|;
comment|// DO NOT IMPLEMENT
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTableScope
operator|&
argument_list|)
block|;
comment|// DO NOT IMPLEMENT
name|public
operator|:
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTable
operator|<
name|K
argument_list|,
name|V
argument_list|,
name|KInfo
operator|>
operator|&
name|HT
argument_list|)
block|;
operator|~
name|ScopedHashTableScope
argument_list|()
block|;
name|private
operator|:
name|friend
name|class
name|ScopedHashTable
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
block|;
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
name|getLastValInScope
argument_list|()
block|{
return|return
name|LastValInScope
return|;
block|}
name|void
name|setLastValInScope
argument_list|(
argument|ScopedHashTableVal<K
argument_list|,
argument|V
argument_list|,
argument|KInfo> *Val
argument_list|)
block|{
name|LastValInScope
operator|=
name|Val
block|;   }
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
expr|>
name|class
name|ScopedHashTableIterator
block|{
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
name|Node
block|;
name|public
operator|:
name|ScopedHashTableIterator
argument_list|(
name|ScopedHashTableVal
operator|<
name|K
argument_list|,
name|V
argument_list|,
name|KInfo
operator|>
operator|*
name|node
argument_list|)
operator|:
name|Node
argument_list|(
argument|node
argument_list|)
block|{}
name|V
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Node
operator|&&
literal|"Dereference end()"
argument_list|)
block|;
return|return
name|Node
operator|->
name|getValue
argument_list|()
return|;
block|}
name|V
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
operator|&
name|Node
operator|->
name|getValue
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ScopedHashTableIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Node
operator|==
name|RHS
operator|.
name|Node
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ScopedHashTableIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Node
operator|!=
name|RHS
operator|.
name|Node
return|;
block|}
specifier|inline
name|ScopedHashTableIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|assert
argument_list|(
name|Node
operator|&&
literal|"incrementing past end()"
argument_list|)
block|;
name|Node
operator|=
name|Node
operator|->
name|getNextForKey
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|ScopedHashTableIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|ScopedHashTableIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|>
name|class
name|ScopedHashTable
block|{
name|DenseMap
operator|<
name|K
block|,
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
block|,
name|KInfo
operator|>
name|TopLevelMap
block|;
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
name|CurScope
block|;
name|ScopedHashTable
argument_list|(
specifier|const
name|ScopedHashTable
operator|&
argument_list|)
block|;
comment|// NOT YET IMPLEMENTED
name|void
name|operator
operator|=
operator|(
specifier|const
name|ScopedHashTable
operator|&
operator|)
block|;
comment|// NOT YET IMPLEMENTED
name|friend
name|class
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
block|;
name|public
operator|:
name|ScopedHashTable
argument_list|()
operator|:
name|CurScope
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|ScopedHashTable
argument_list|()
block|{
name|assert
argument_list|(
name|CurScope
operator|==
literal|0
operator|&&
name|TopLevelMap
operator|.
name|empty
argument_list|()
operator|&&
literal|"Scope imbalance!"
argument_list|)
block|;   }
name|bool
name|count
argument_list|(
argument|const K&Key
argument_list|)
specifier|const
block|{
return|return
name|TopLevelMap
operator|.
name|count
argument_list|(
name|Key
argument_list|)
return|;
block|}
name|V
name|lookup
argument_list|(
argument|const K&Key
argument_list|)
block|{
return|return
name|TopLevelMap
index|[
name|Key
index|]
operator|->
name|getValue
argument_list|()
return|;
block|}
name|void
name|insert
argument_list|(
argument|const K&Key
argument_list|,
argument|const V&Val
argument_list|)
block|{
name|assert
argument_list|(
name|CurScope
operator|&&
literal|"No scope active!"
argument_list|)
block|;
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
operator|&
name|KeyEntry
operator|=
name|TopLevelMap
index|[
name|Key
index|]
block|;
name|KeyEntry
operator|=
name|new
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|(
name|CurScope
operator|->
name|getLastValInScope
argument_list|()
operator|,
name|KeyEntry
operator|,
name|Key
operator|,
name|Val
operator|)
block|;
name|CurScope
operator|->
name|setLastValInScope
argument_list|(
name|KeyEntry
argument_list|)
block|;   }
typedef|typedef
name|ScopedHashTableIterator
operator|<
name|K
operator|,
name|V
operator|,
name|KInfo
operator|>
name|iterator
expr_stmt|;
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|iterator
name|begin
argument_list|(
argument|const K&Key
argument_list|)
block|{
name|typename
name|DenseMap
operator|<
name|K
block|,
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|*
block|,
name|KInfo
operator|>
operator|::
name|iterator
name|I
operator|=
name|TopLevelMap
operator|.
name|find
argument_list|(
name|Key
argument_list|)
block|;
if|if
condition|(
name|I
operator|==
name|TopLevelMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|end
argument_list|()
return|;
return|return
name|iterator
argument_list|(
name|I
operator|->
name|second
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ScopedHashTableScope ctor - Install this as the current scope for the hash
comment|/// table.
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|>
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|::
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTable
operator|<
name|K
argument_list|,
name|V
argument_list|,
name|KInfo
operator|>
operator|&
name|ht
argument_list|)
operator|:
name|HT
argument_list|(
argument|ht
argument_list|)
block|{
name|PrevScope
operator|=
name|HT
operator|.
name|CurScope
block|;
name|HT
operator|.
name|CurScope
operator|=
name|this
block|;
name|LastValInScope
operator|=
literal|0
block|; }
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|>
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
operator|::
operator|~
name|ScopedHashTableScope
argument_list|()
block|{
name|assert
argument_list|(
name|HT
operator|.
name|CurScope
operator|==
name|this
operator|&&
literal|"Scope imbalance!"
argument_list|)
block|;
name|HT
operator|.
name|CurScope
operator|=
name|PrevScope
block|;
comment|// Pop and delete all values corresponding to this scope.
while|while
condition|(
name|ScopedHashTableVal
operator|<
name|K
operator|,
name|V
operator|,
name|KInfo
operator|>
operator|*
name|ThisEntry
operator|=
name|LastValInScope
condition|)
block|{
comment|// Pop this value out of the TopLevelMap.
if|if
condition|(
name|ThisEntry
operator|->
name|getNextForKey
argument_list|()
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|HT
operator|.
name|TopLevelMap
index|[
name|ThisEntry
operator|->
name|getKey
argument_list|()
index|]
operator|==
name|ThisEntry
operator|&&
literal|"Scope imbalance!"
argument_list|)
expr_stmt|;
name|HT
operator|.
name|TopLevelMap
operator|.
name|erase
argument_list|(
name|ThisEntry
operator|->
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScopedHashTableVal
operator|<
name|K
operator|,
name|V
operator|,
name|KInfo
operator|>
operator|*
operator|&
name|KeyEntry
operator|=
name|HT
operator|.
name|TopLevelMap
index|[
name|ThisEntry
operator|->
name|getKey
argument_list|()
index|]
expr_stmt|;
name|assert
argument_list|(
name|KeyEntry
operator|==
name|ThisEntry
operator|&&
literal|"Scope imbalance!"
argument_list|)
expr_stmt|;
name|KeyEntry
operator|=
name|ThisEntry
operator|->
name|getNextForKey
argument_list|()
expr_stmt|;
block|}
comment|// Pop this value out of the scope.
name|LastValInScope
operator|=
name|ThisEntry
operator|->
name|getNextInScope
argument_list|()
expr_stmt|;
comment|// Delete this entry.
name|delete
name|ThisEntry
decl_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

