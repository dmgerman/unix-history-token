begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements an efficient scoped hash table, which is useful for
end_comment

begin_comment
comment|// things like dominator-based optimizations.  This allows clients to do things
end_comment

begin_comment
comment|// like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  ScopedHashTable<int, int> HT;
end_comment

begin_comment
comment|//  {
end_comment

begin_comment
comment|//    ScopedHashTableScope<int, int> Scope1(HT);
end_comment

begin_comment
comment|//    HT.insert(0, 0);
end_comment

begin_comment
comment|//    HT.insert(1, 1);
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      ScopedHashTableScope<int, int> Scope2(HT);
end_comment

begin_comment
comment|//      HT.insert(0, 42);
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Looking up the value for "0" in the Scope2 block will return 42.  Looking
end_comment

begin_comment
comment|// up the value for 0 before 42 is inserted or after Scope2 is popped will
end_comment

begin_comment
comment|// return 0.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_SCOPEDHASHTABLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_SCOPEDHASHTABLE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|K
operator|,
name|typename
name|V
operator|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
operator|,
name|typename
name|AllocatorTy
operator|=
name|MallocAllocator
operator|>
name|class
name|ScopedHashTable
expr_stmt|;
name|template
operator|<
name|typename
name|K
operator|,
name|typename
name|V
operator|>
name|class
name|ScopedHashTableVal
block|{
name|ScopedHashTableVal
operator|*
name|NextInScope
block|;
name|ScopedHashTableVal
operator|*
name|NextForKey
block|;
name|K
name|Key
block|;
name|V
name|Val
block|;
name|ScopedHashTableVal
argument_list|(
specifier|const
name|K
operator|&
name|key
argument_list|,
specifier|const
name|V
operator|&
name|val
argument_list|)
operator|:
name|Key
argument_list|(
name|key
argument_list|)
block|,
name|Val
argument_list|(
argument|val
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|K
operator|&
name|getKey
argument_list|()
specifier|const
block|{
return|return
name|Key
return|;
block|}
specifier|const
name|V
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|V
operator|&
name|getValue
argument_list|()
block|{
return|return
name|Val
return|;
block|}
name|ScopedHashTableVal
operator|*
name|getNextForKey
argument_list|()
block|{
return|return
name|NextForKey
return|;
block|}
specifier|const
name|ScopedHashTableVal
operator|*
name|getNextForKey
argument_list|()
specifier|const
block|{
return|return
name|NextForKey
return|;
block|}
name|ScopedHashTableVal
operator|*
name|getNextInScope
argument_list|()
block|{
return|return
name|NextInScope
return|;
block|}
name|template
operator|<
name|typename
name|AllocatorTy
operator|>
specifier|static
name|ScopedHashTableVal
operator|*
name|Create
argument_list|(
argument|ScopedHashTableVal *nextInScope
argument_list|,
argument|ScopedHashTableVal *nextForKey
argument_list|,
argument|const K&key
argument_list|,
argument|const V&val
argument_list|,
argument|AllocatorTy&Allocator
argument_list|)
block|{
name|ScopedHashTableVal
operator|*
name|New
operator|=
name|Allocator
operator|.
name|template
name|Allocate
operator|<
name|ScopedHashTableVal
operator|>
operator|(
operator|)
block|;
comment|// Set up the value.
name|new
argument_list|(
argument|New
argument_list|)
name|ScopedHashTableVal
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
block|;
name|New
operator|->
name|NextInScope
operator|=
name|nextInScope
block|;
name|New
operator|->
name|NextForKey
operator|=
name|nextForKey
block|;
return|return
name|New
return|;
block|}
name|template
operator|<
name|typename
name|AllocatorTy
operator|>
name|void
name|Destroy
argument_list|(
argument|AllocatorTy&Allocator
argument_list|)
block|{
comment|// Free memory referenced by the item.
name|this
operator|->
expr|~
name|ScopedHashTableVal
argument_list|()
block|;
name|Allocator
operator|.
name|Deallocate
argument_list|(
name|this
argument_list|)
block|;   }
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>
block|,
name|typename
name|AllocatorTy
operator|=
name|MallocAllocator
operator|>
name|class
name|ScopedHashTableScope
block|{
comment|/// HT - The hashtable that we are active for.
name|ScopedHashTable
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|AllocatorTy
operator|>
operator|&
name|HT
block|;
comment|/// PrevScope - This is the scope that we are shadowing in HT.
name|ScopedHashTableScope
operator|*
name|PrevScope
block|;
comment|/// LastValInScope - This is the last value that was inserted for this scope
comment|/// or null if none have been inserted yet.
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
operator|>
operator|*
name|LastValInScope
block|;
name|public
operator|:
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTable
operator|<
name|K
argument_list|,
name|V
argument_list|,
name|KInfo
argument_list|,
name|AllocatorTy
operator|>
operator|&
name|HT
argument_list|)
block|;
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTableScope
operator|&
argument_list|)
operator|=
name|delete
block|;
name|ScopedHashTableScope
operator|&
name|operator
operator|=
operator|(
name|ScopedHashTableScope
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|ScopedHashTableScope
argument_list|()
block|;
name|ScopedHashTableScope
operator|*
name|getParentScope
argument_list|()
block|{
return|return
name|PrevScope
return|;
block|}
specifier|const
name|ScopedHashTableScope
operator|*
name|getParentScope
argument_list|()
specifier|const
block|{
return|return
name|PrevScope
return|;
block|}
name|private
operator|:
name|friend
name|class
name|ScopedHashTable
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|AllocatorTy
operator|>
block|;
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
operator|>
operator|*
name|getLastValInScope
argument_list|()
block|{
return|return
name|LastValInScope
return|;
block|}
name|void
name|setLastValInScope
argument_list|(
argument|ScopedHashTableVal<K
argument_list|,
argument|V> *Val
argument_list|)
block|{
name|LastValInScope
operator|=
name|Val
block|;   }
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
operator|=
name|DenseMapInfo
operator|<
name|K
operator|>>
name|class
name|ScopedHashTableIterator
block|{
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
operator|>
operator|*
name|Node
block|;
name|public
operator|:
name|ScopedHashTableIterator
argument_list|(
name|ScopedHashTableVal
operator|<
name|K
argument_list|,
name|V
operator|>
operator|*
name|node
argument_list|)
operator|:
name|Node
argument_list|(
argument|node
argument_list|)
block|{}
name|V
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Node
operator|&&
literal|"Dereference end()"
argument_list|)
block|;
return|return
name|Node
operator|->
name|getValue
argument_list|()
return|;
block|}
name|V
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
operator|&
name|Node
operator|->
name|getValue
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ScopedHashTableIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Node
operator|==
name|RHS
operator|.
name|Node
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ScopedHashTableIterator
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Node
operator|!=
name|RHS
operator|.
name|Node
return|;
block|}
specifier|inline
name|ScopedHashTableIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
comment|// Preincrement
name|assert
argument_list|(
name|Node
operator|&&
literal|"incrementing past end()"
argument_list|)
block|;
name|Node
operator|=
name|Node
operator|->
name|getNextForKey
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|ScopedHashTableIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
comment|// Postincrement
name|ScopedHashTableIterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
block|,
name|typename
name|AllocatorTy
operator|>
name|class
name|ScopedHashTable
block|{
name|public
operator|:
comment|/// ScopeTy - This is a helpful typedef that allows clients to get easy access
comment|/// to the name of the scope for this hash table.
name|using
name|ScopeTy
operator|=
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|AllocatorTy
operator|>
block|;
name|using
name|size_type
operator|=
name|unsigned
block|;
name|private
operator|:
name|friend
name|class
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|AllocatorTy
operator|>
block|;
name|using
name|ValTy
operator|=
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
operator|>
block|;
name|DenseMap
operator|<
name|K
block|,
name|ValTy
operator|*
block|,
name|KInfo
operator|>
name|TopLevelMap
block|;
name|ScopeTy
operator|*
name|CurScope
operator|=
name|nullptr
block|;
name|AllocatorTy
name|Allocator
block|;
name|public
operator|:
name|ScopedHashTable
argument_list|()
operator|=
expr|default
block|;
name|ScopedHashTable
argument_list|(
argument|AllocatorTy A
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|A
argument_list|)
block|{}
name|ScopedHashTable
argument_list|(
specifier|const
name|ScopedHashTable
operator|&
argument_list|)
operator|=
name|delete
block|;
name|ScopedHashTable
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ScopedHashTable
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|ScopedHashTable
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|CurScope
operator|&&
name|TopLevelMap
operator|.
name|empty
argument_list|()
operator|&&
literal|"Scope imbalance!"
argument_list|)
block|;   }
comment|/// Access to the allocator.
name|AllocatorTy
operator|&
name|getAllocator
argument_list|()
block|{
return|return
name|Allocator
return|;
block|}
specifier|const
name|AllocatorTy
operator|&
name|getAllocator
argument_list|()
specifier|const
block|{
return|return
name|Allocator
return|;
block|}
comment|/// Return 1 if the specified key is in the table, 0 otherwise.
name|size_type
name|count
argument_list|(
argument|const K&Key
argument_list|)
specifier|const
block|{
return|return
name|TopLevelMap
operator|.
name|count
argument_list|(
name|Key
argument_list|)
return|;
block|}
name|V
name|lookup
argument_list|(
argument|const K&Key
argument_list|)
specifier|const
block|{
name|auto
name|I
operator|=
name|TopLevelMap
operator|.
name|find
argument_list|(
name|Key
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|TopLevelMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
operator|->
name|getValue
argument_list|()
return|;
return|return
name|V
argument_list|()
return|;
block|}
name|void
name|insert
argument_list|(
argument|const K&Key
argument_list|,
argument|const V&Val
argument_list|)
block|{
name|insertIntoScope
argument_list|(
name|CurScope
argument_list|,
name|Key
argument_list|,
name|Val
argument_list|)
block|;   }
name|using
name|iterator
operator|=
name|ScopedHashTableIterator
operator|<
name|K
block|,
name|V
block|,
name|KInfo
operator|>
block|;
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|iterator
name|begin
argument_list|(
argument|const K&Key
argument_list|)
block|{
name|typename
name|DenseMap
operator|<
name|K
block|,
name|ValTy
operator|*
block|,
name|KInfo
operator|>
operator|::
name|iterator
name|I
operator|=
name|TopLevelMap
operator|.
name|find
argument_list|(
name|Key
argument_list|)
block|;
if|if
condition|(
name|I
operator|==
name|TopLevelMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|end
argument_list|()
return|;
return|return
name|iterator
argument_list|(
name|I
operator|->
name|second
argument_list|)
return|;
block|}
name|ScopeTy
operator|*
name|getCurScope
argument_list|()
block|{
return|return
name|CurScope
return|;
block|}
specifier|const
name|ScopeTy
operator|*
name|getCurScope
argument_list|()
specifier|const
block|{
return|return
name|CurScope
return|;
block|}
comment|/// insertIntoScope - This inserts the specified key/value at the specified
comment|/// (possibly not the current) scope.  While it is ok to insert into a scope
comment|/// that isn't the current one, it isn't ok to insert *underneath* an existing
comment|/// value of the specified key.
name|void
name|insertIntoScope
argument_list|(
argument|ScopeTy *S
argument_list|,
argument|const K&Key
argument_list|,
argument|const V&Val
argument_list|)
block|{
name|assert
argument_list|(
name|S
operator|&&
literal|"No scope active!"
argument_list|)
block|;
name|ScopedHashTableVal
operator|<
name|K
block|,
name|V
operator|>
operator|*
operator|&
name|KeyEntry
operator|=
name|TopLevelMap
index|[
name|Key
index|]
block|;
name|KeyEntry
operator|=
name|ValTy
operator|::
name|Create
argument_list|(
name|S
operator|->
name|getLastValInScope
argument_list|()
argument_list|,
name|KeyEntry
argument_list|,
name|Key
argument_list|,
name|Val
argument_list|,
name|Allocator
argument_list|)
block|;
name|S
operator|->
name|setLastValInScope
argument_list|(
name|KeyEntry
argument_list|)
block|;   }
expr|}
block|;
comment|/// ScopedHashTableScope ctor - Install this as the current scope for the hash
comment|/// table.
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
block|,
name|typename
name|Allocator
operator|>
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|Allocator
operator|>
operator|::
name|ScopedHashTableScope
argument_list|(
name|ScopedHashTable
operator|<
name|K
argument_list|,
name|V
argument_list|,
name|KInfo
argument_list|,
name|Allocator
operator|>
operator|&
name|ht
argument_list|)
operator|:
name|HT
argument_list|(
argument|ht
argument_list|)
block|{
name|PrevScope
operator|=
name|HT
operator|.
name|CurScope
block|;
name|HT
operator|.
name|CurScope
operator|=
name|this
block|;
name|LastValInScope
operator|=
name|nullptr
block|; }
name|template
operator|<
name|typename
name|K
block|,
name|typename
name|V
block|,
name|typename
name|KInfo
block|,
name|typename
name|Allocator
operator|>
name|ScopedHashTableScope
operator|<
name|K
block|,
name|V
block|,
name|KInfo
block|,
name|Allocator
operator|>
operator|::
operator|~
name|ScopedHashTableScope
argument_list|()
block|{
name|assert
argument_list|(
name|HT
operator|.
name|CurScope
operator|==
name|this
operator|&&
literal|"Scope imbalance!"
argument_list|)
block|;
name|HT
operator|.
name|CurScope
operator|=
name|PrevScope
block|;
comment|// Pop and delete all values corresponding to this scope.
while|while
condition|(
name|ScopedHashTableVal
operator|<
name|K
operator|,
name|V
operator|>
operator|*
name|ThisEntry
operator|=
name|LastValInScope
condition|)
block|{
comment|// Pop this value out of the TopLevelMap.
if|if
condition|(
operator|!
name|ThisEntry
operator|->
name|getNextForKey
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|HT
operator|.
name|TopLevelMap
index|[
name|ThisEntry
operator|->
name|getKey
argument_list|()
index|]
operator|==
name|ThisEntry
operator|&&
literal|"Scope imbalance!"
argument_list|)
expr_stmt|;
name|HT
operator|.
name|TopLevelMap
operator|.
name|erase
argument_list|(
name|ThisEntry
operator|->
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScopedHashTableVal
operator|<
name|K
operator|,
name|V
operator|>
operator|*
operator|&
name|KeyEntry
operator|=
name|HT
operator|.
name|TopLevelMap
index|[
name|ThisEntry
operator|->
name|getKey
argument_list|()
index|]
expr_stmt|;
name|assert
argument_list|(
name|KeyEntry
operator|==
name|ThisEntry
operator|&&
literal|"Scope imbalance!"
argument_list|)
expr_stmt|;
name|KeyEntry
operator|=
name|ThisEntry
operator|->
name|getNextForKey
argument_list|()
expr_stmt|;
block|}
comment|// Pop this value out of the scope.
name|LastValInScope
operator|=
name|ThisEntry
operator|->
name|getNextInScope
argument_list|()
expr_stmt|;
comment|// Delete this entry.
name|ThisEntry
operator|->
name|Destroy
argument_list|(
name|HT
operator|.
name|getAllocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_SCOPEDHASHTABLE_H
end_comment

end_unit

