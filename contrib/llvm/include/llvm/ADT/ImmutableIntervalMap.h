begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ImmutableIntervalMap.h - Immutable (functional) map  ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the ImmutableIntervalMap class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_IMMUTABLEINTERVALMAP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_IMMUTABLEINTERVALMAP_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableMap.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Interval
block|{
name|private
label|:
name|int64_t
name|Start
decl_stmt|;
name|int64_t
name|End
decl_stmt|;
name|public
label|:
name|Interval
argument_list|(
argument|int64_t S
argument_list|,
argument|int64_t E
argument_list|)
block|:
name|Start
argument_list|(
name|S
argument_list|)
operator|,
name|End
argument_list|(
argument|E
argument_list|)
block|{}
name|int64_t
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Start
return|;
block|}
name|int64_t
name|getEnd
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ImutIntervalInfo
block|{
typedef|typedef
specifier|const
name|std
operator|::
name|pair
operator|<
name|Interval
operator|,
name|T
operator|>
name|value_type
expr_stmt|;
typedef|typedef
specifier|const
name|value_type
modifier|&
name|value_type_ref
typedef|;
typedef|typedef
specifier|const
name|Interval
name|key_type
typedef|;
typedef|typedef
specifier|const
name|Interval
modifier|&
name|key_type_ref
typedef|;
typedef|typedef
specifier|const
name|T
name|data_type
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|data_type_ref
typedef|;
specifier|static
name|key_type_ref
name|KeyOfValue
parameter_list|(
name|value_type_ref
name|V
parameter_list|)
block|{
return|return
name|V
operator|.
name|first
return|;
block|}
specifier|static
name|data_type_ref
name|DataOfValue
parameter_list|(
name|value_type_ref
name|V
parameter_list|)
block|{
return|return
name|V
operator|.
name|second
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
name|key_type_ref
name|L
parameter_list|,
name|key_type_ref
name|R
parameter_list|)
block|{
return|return
name|L
operator|.
name|getStart
argument_list|()
operator|==
name|R
operator|.
name|getStart
argument_list|()
operator|&&
name|L
operator|.
name|getEnd
argument_list|()
operator|==
name|R
operator|.
name|getEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|isDataEqual
parameter_list|(
name|data_type_ref
name|L
parameter_list|,
name|data_type_ref
name|R
parameter_list|)
block|{
return|return
name|ImutContainerInfo
operator|<
name|T
operator|>
operator|::
name|isEqual
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isLess
parameter_list|(
name|key_type_ref
name|L
parameter_list|,
name|key_type_ref
name|R
parameter_list|)
block|{
comment|// Assume L and R does not overlap.
if|if
condition|(
name|L
operator|.
name|getStart
argument_list|()
operator|<
name|R
operator|.
name|getStart
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|L
operator|.
name|getEnd
argument_list|()
operator|<
name|R
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|L
operator|.
name|getStart
argument_list|()
operator|==
name|R
operator|.
name|getStart
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|L
operator|.
name|getEnd
argument_list|()
operator|==
name|R
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|L
operator|.
name|getStart
argument_list|()
operator|>
name|R
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
specifier|static
name|bool
name|isContainedIn
parameter_list|(
name|key_type_ref
name|K
parameter_list|,
name|key_type_ref
name|L
parameter_list|)
block|{
if|if
condition|(
name|K
operator|.
name|getStart
argument_list|()
operator|>=
name|L
operator|.
name|getStart
argument_list|()
operator|&&
name|K
operator|.
name|getEnd
argument_list|()
operator|<=
name|L
operator|.
name|getEnd
argument_list|()
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
specifier|static
name|void
name|Profile
parameter_list|(
name|FoldingSetNodeID
modifier|&
name|ID
parameter_list|,
name|value_type_ref
name|V
parameter_list|)
block|{
name|ID
operator|.
name|AddInteger
argument_list|(
name|V
operator|.
name|first
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|V
operator|.
name|first
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|ImutProfileInfo
operator|<
name|T
operator|>
operator|::
name|Profile
argument_list|(
name|ID
argument_list|,
name|V
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ImutInfo
operator|>
name|class
name|ImutIntervalAVLFactory
operator|:
name|public
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
block|{
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutInfo
operator|>
name|TreeTy
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type
name|value_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|key_type
name|key_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|data_type
name|data_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutInfo
operator|::
name|data_type_ref
name|data_type_ref
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ImutIntervalAVLFactory
argument_list|(
name|BumpPtrAllocator
operator|&
name|Alloc
argument_list|)
operator|:
name|ImutAVLFactory
operator|<
name|ImutInfo
operator|>
operator|(
name|Alloc
operator|)
block|{}
name|TreeTy
operator|*
name|Add
argument_list|(
argument|TreeTy *T
argument_list|,
argument|value_type_ref V
argument_list|)
block|{
name|T
operator|=
name|add_internal
argument_list|(
name|V
argument_list|,
name|T
argument_list|)
block|;
name|this
operator|->
name|MarkImmutable
argument_list|(
name|T
argument_list|)
block|;
return|return
name|T
return|;
block|}
end_expr_stmt

begin_function
name|TreeTy
modifier|*
name|Find
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|key_type_ref
name|K
parameter_list|)
block|{
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|NULL
return|;
name|key_type_ref
name|CurrentKey
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|this
operator|->
name|getValue
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isContainedIn
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
return|return
name|T
return|;
elseif|else
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|CurrentKey
argument_list|)
condition|)
return|return
name|Find
argument_list|(
name|this
operator|->
name|getLeft
argument_list|(
name|T
argument_list|)
argument_list|,
name|K
argument_list|)
return|;
else|else
return|return
name|Find
argument_list|(
name|this
operator|->
name|getRight
argument_list|(
name|T
argument_list|)
argument_list|,
name|K
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function
name|TreeTy
modifier|*
name|add_internal
parameter_list|(
name|value_type_ref
name|V
parameter_list|,
name|TreeTy
modifier|*
name|T
parameter_list|)
block|{
name|key_type_ref
name|K
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|T
operator|=
name|removeAllOverlaps
argument_list|(
name|T
argument_list|,
name|K
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|isEmpty
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|this
operator|->
name|CreateNode
argument_list|(
name|NULL
argument_list|,
name|V
argument_list|,
name|NULL
argument_list|)
return|;
name|assert
argument_list|(
operator|!
name|T
operator|->
name|isMutable
argument_list|()
argument_list|)
expr_stmt|;
name|key_type_ref
name|KCurrent
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ImutInfo
operator|::
name|isLess
argument_list|(
name|K
argument_list|,
name|KCurrent
argument_list|)
condition|)
return|return
name|this
operator|->
name|Balance
argument_list|(
name|add_internal
argument_list|(
name|V
argument_list|,
name|this
operator|->
name|Left
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|this
operator|->
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
else|else
return|return
name|this
operator|->
name|Balance
argument_list|(
name|this
operator|->
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|add_internal
argument_list|(
name|V
argument_list|,
name|this
operator|->
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// Remove all overlaps from T.
end_comment

begin_function
name|TreeTy
modifier|*
name|removeAllOverlaps
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|key_type_ref
name|K
parameter_list|)
block|{
name|bool
name|Changed
decl_stmt|;
do|do
block|{
name|Changed
operator|=
name|false
expr_stmt|;
name|T
operator|=
name|removeOverlap
argument_list|(
name|T
argument_list|,
name|K
argument_list|,
name|Changed
argument_list|)
expr_stmt|;
name|this
operator|->
name|markImmutable
argument_list|(
name|T
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Changed
condition|)
do|;
return|return
name|T
return|;
block|}
end_function

begin_comment
comment|// Remove one overlap from T.
end_comment

begin_function
name|TreeTy
modifier|*
name|removeOverlap
parameter_list|(
name|TreeTy
modifier|*
name|T
parameter_list|,
name|key_type_ref
name|K
parameter_list|,
name|bool
modifier|&
name|Changed
parameter_list|)
block|{
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|NULL
return|;
name|Interval
name|CurrentK
init|=
name|ImutInfo
operator|::
name|KeyOfValue
argument_list|(
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
comment|// If current key does not overlap the inserted key.
if|if
condition|(
name|CurrentK
operator|.
name|getStart
argument_list|()
operator|>
name|K
operator|.
name|getEnd
argument_list|()
condition|)
return|return
name|this
operator|->
name|Balance
argument_list|(
name|removeOverlap
argument_list|(
name|this
operator|->
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|K
argument_list|,
name|Changed
argument_list|)
argument_list|,
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|this
operator|->
name|Right
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CurrentK
operator|.
name|getEnd
argument_list|()
operator|<
name|K
operator|.
name|getStart
argument_list|()
condition|)
return|return
name|this
operator|->
name|Balance
argument_list|(
name|this
operator|->
name|Left
argument_list|(
name|T
argument_list|)
argument_list|,
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|,
name|removeOverlap
argument_list|(
name|this
operator|->
name|Right
argument_list|(
name|T
argument_list|)
argument_list|,
name|K
argument_list|,
name|Changed
argument_list|)
argument_list|)
return|;
comment|// Current key overlaps with the inserted key.
comment|// Remove the current key.
name|Changed
operator|=
name|true
expr_stmt|;
name|data_type_ref
name|OldData
init|=
name|ImutInfo
operator|::
name|DataOfValue
argument_list|(
name|this
operator|->
name|Value
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
name|T
operator|=
name|this
operator|->
name|Remove_internal
argument_list|(
name|CurrentK
argument_list|,
name|T
argument_list|)
expr_stmt|;
comment|// Add back the unoverlapped part of the current key.
if|if
condition|(
name|CurrentK
operator|.
name|getStart
argument_list|()
operator|<
name|K
operator|.
name|getStart
argument_list|()
condition|)
block|{
if|if
condition|(
name|CurrentK
operator|.
name|getEnd
argument_list|()
operator|<=
name|K
operator|.
name|getEnd
argument_list|()
condition|)
block|{
name|Interval
name|NewK
argument_list|(
name|CurrentK
operator|.
name|getStart
argument_list|()
argument_list|,
name|K
operator|.
name|getStart
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|add_internal
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewK
argument_list|,
name|OldData
argument_list|)
argument_list|,
name|T
argument_list|)
return|;
block|}
else|else
block|{
name|Interval
name|NewK1
argument_list|(
name|CurrentK
operator|.
name|getStart
argument_list|()
argument_list|,
name|K
operator|.
name|getStart
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|T
operator|=
name|add_internal
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewK1
argument_list|,
name|OldData
argument_list|)
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|Interval
name|NewK2
argument_list|(
name|K
operator|.
name|getEnd
argument_list|()
operator|+
literal|1
argument_list|,
name|CurrentK
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|add_internal
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewK2
argument_list|,
name|OldData
argument_list|)
argument_list|,
name|T
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CurrentK
operator|.
name|getEnd
argument_list|()
operator|>
name|K
operator|.
name|getEnd
argument_list|()
condition|)
block|{
name|Interval
name|NewK
argument_list|(
name|K
operator|.
name|getEnd
argument_list|()
operator|+
literal|1
argument_list|,
name|CurrentK
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|add_internal
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewK
argument_list|,
name|OldData
argument_list|)
argument_list|,
name|T
argument_list|)
return|;
block|}
else|else
return|return
name|T
return|;
block|}
block|}
end_function

begin_comment
unit|};
comment|/// ImmutableIntervalMap maps an interval [start, end] to a value. The intervals
end_comment

begin_comment
comment|/// in the map are guaranteed to be disjoint.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ValT
operator|>
name|class
name|ImmutableIntervalMap
operator|:
name|public
name|ImmutableMap
operator|<
name|Interval
operator|,
name|ValT
operator|,
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
expr|>
block|{
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|value_type_ref
name|value_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|key_type
name|key_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|key_type_ref
name|key_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|data_type
name|data_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
operator|::
name|data_type_ref
name|data_type_ref
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ImutAVLTree
operator|<
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
expr|>
name|TreeTy
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_macro
name|explicit
end_macro

begin_expr_stmt
name|ImmutableIntervalMap
argument_list|(
name|TreeTy
operator|*
name|R
argument_list|)
operator|:
name|ImmutableMap
operator|<
name|Interval
operator|,
name|ValT
operator|,
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
expr|>
operator|(
name|R
operator|)
block|{}
name|class
name|Factory
block|{
name|ImutIntervalAVLFactory
operator|<
name|ImutIntervalInfo
operator|<
name|ValT
operator|>
expr|>
name|F
block|;
name|public
operator|:
name|Factory
argument_list|(
name|BumpPtrAllocator
operator|&
name|Alloc
argument_list|)
operator|:
name|F
argument_list|(
argument|Alloc
argument_list|)
block|{}
name|ImmutableIntervalMap
name|getEmptyMap
argument_list|()
block|{
return|return
name|ImmutableIntervalMap
argument_list|(
name|F
operator|.
name|getEmptyTree
argument_list|()
argument_list|)
return|;
block|}
name|ImmutableIntervalMap
name|add
argument_list|(
argument|ImmutableIntervalMap Old
argument_list|,
argument|key_type_ref K
argument_list|,
argument|data_type_ref D
argument_list|)
block|{
name|TreeTy
operator|*
name|T
operator|=
name|F
operator|.
name|add
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|std
operator|::
name|pair
operator|<
name|key_type
argument_list|,
name|data_type
operator|>
operator|(
name|K
operator|,
name|D
operator|)
argument_list|)
block|;
return|return
name|ImmutableIntervalMap
argument_list|(
name|F
operator|.
name|getCanonicalTree
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|ImmutableIntervalMap
name|remove
parameter_list|(
name|ImmutableIntervalMap
name|Old
parameter_list|,
name|key_type_ref
name|K
parameter_list|)
block|{
name|TreeTy
modifier|*
name|T
init|=
name|F
operator|.
name|remove
argument_list|(
name|Old
operator|.
name|Root
argument_list|,
name|K
argument_list|)
decl_stmt|;
return|return
name|ImmutableIntervalMap
argument_list|(
name|F
operator|.
name|getCanonicalTree
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|data_type
modifier|*
name|lookup
parameter_list|(
name|ImmutableIntervalMap
name|M
parameter_list|,
name|key_type_ref
name|K
parameter_list|)
block|{
name|TreeTy
modifier|*
name|T
init|=
name|F
operator|.
name|Find
argument_list|(
name|M
operator|.
name|getRoot
argument_list|()
argument_list|,
name|K
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
condition|)
return|return
operator|&
name|T
operator|->
name|getValue
argument_list|()
operator|.
name|second
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_label
unit|};
name|private
label|:
end_label

begin_comment
comment|// For ImmutableIntervalMap, the lookup operation has to be done by the
end_comment

begin_comment
comment|// factory.
end_comment

begin_decl_stmt
name|data_type
modifier|*
name|lookup
argument_list|(
name|key_type_ref
name|K
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

