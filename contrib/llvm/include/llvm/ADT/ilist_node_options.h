begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/ADT/ilist_node_options.h - ilist_node Options -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ADT_ILIST_NODE_OPTIONS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ADT_ILIST_NODE_OPTIONS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Config/abi-breaking.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Config/llvm-config.h"
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|bool
name|EnableSentinelTracking
operator|>
name|class
name|ilist_node_base
expr_stmt|;
name|template
operator|<
name|bool
name|EnableSentinelTracking
operator|>
name|class
name|ilist_base
expr_stmt|;
comment|/// Option to choose whether to track sentinels.
comment|///
comment|/// This option affects the ABI for the nodes.  When not specified explicitly,
comment|/// the ABI depends on LLVM_ENABLE_ABI_BREAKING_CHECKS.  Specify explicitly to
comment|/// enable \a ilist_node::isSentinel().
name|template
operator|<
name|bool
name|EnableSentinelTracking
operator|>
expr|struct
name|ilist_sentinel_tracking
block|{}
expr_stmt|;
comment|/// Option to specify a tag for the node type.
comment|///
comment|/// This option allows a single value type to be inserted in multiple lists
comment|/// simultaneously.  See \a ilist_node for usage examples.
name|template
operator|<
name|class
name|Tag
operator|>
expr|struct
name|ilist_tag
block|{}
expr_stmt|;
name|namespace
name|ilist_detail
block|{
comment|/// Helper trait for recording whether an option is specified explicitly.
name|template
operator|<
name|bool
name|IsExplicit
operator|>
expr|struct
name|explicitness
block|{
specifier|static
specifier|const
name|bool
name|is_explicit
operator|=
name|IsExplicit
block|; }
expr_stmt|;
typedef|typedef
name|explicitness
operator|<
name|true
operator|>
name|is_explicit
expr_stmt|;
typedef|typedef
name|explicitness
operator|<
name|false
operator|>
name|is_implicit
expr_stmt|;
comment|/// Check whether an option is valid.
comment|///
comment|/// The steps for adding and enabling a new ilist option include:
comment|/// \li define the option, ilist_foo<Bar>, above;
comment|/// \li add new parameters for Bar to \a ilist_detail::node_options;
comment|/// \li add an extraction meta-function, ilist_detail::extract_foo;
comment|/// \li call extract_foo from \a ilist_detail::compute_node_options and pass it
comment|/// into \a ilist_detail::node_options; and
comment|/// \li specialize \c is_valid_option<ilist_foo<Bar>> to inherit from \c
comment|/// std::true_type to get static assertions passing in \a simple_ilist and \a
comment|/// ilist_node.
name|template
operator|<
name|class
name|Option
operator|>
expr|struct
name|is_valid_option
operator|:
name|std
operator|::
name|false_type
block|{}
expr_stmt|;
comment|/// Extract sentinel tracking option.
comment|///
comment|/// Look through \p Options for the \a ilist_sentinel_tracking option, with the
comment|/// default depending on LLVM_ENABLE_ABI_BREAKING_CHECKS.
name|template
operator|<
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_sentinel_tracking
expr_stmt|;
name|template
operator|<
name|bool
name|EnableSentinelTracking
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_sentinel_tracking
operator|<
name|ilist_sentinel_tracking
operator|<
name|EnableSentinelTracking
operator|>
operator|,
name|Options
operator|...
operator|>
operator|:
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|EnableSentinelTracking
operator|>
operator|,
name|is_explicit
block|{}
expr_stmt|;
name|template
operator|<
name|class
name|Option1
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_sentinel_tracking
operator|<
name|Option1
operator|,
name|Options
operator|...
operator|>
operator|:
name|extract_sentinel_tracking
operator|<
name|Options
operator|...
operator|>
block|{}
expr_stmt|;
if|#
directive|if
name|LLVM_ENABLE_ABI_BREAKING_CHECKS
name|template
operator|<
operator|>
expr|struct
name|extract_sentinel_tracking
operator|<
operator|>
operator|:
name|std
operator|::
name|true_type
operator|,
name|is_implicit
block|{}
expr_stmt|;
else|#
directive|else
name|template
operator|<
operator|>
expr|struct
name|extract_sentinel_tracking
operator|<
operator|>
operator|:
name|std
operator|::
name|false_type
operator|,
name|is_implicit
block|{}
expr_stmt|;
endif|#
directive|endif
name|template
operator|<
name|bool
name|EnableSentinelTracking
operator|>
expr|struct
name|is_valid_option
operator|<
name|ilist_sentinel_tracking
operator|<
name|EnableSentinelTracking
operator|>>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
comment|/// Extract custom tag option.
comment|///
comment|/// Look through \p Options for the \a ilist_tag option, pulling out the
comment|/// custom tag type, using void as a default.
name|template
operator|<
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_tag
expr_stmt|;
name|template
operator|<
name|class
name|Tag
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_tag
operator|<
name|ilist_tag
operator|<
name|Tag
operator|>
operator|,
name|Options
operator|...
operator|>
block|{
typedef|typedef
name|Tag
name|type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Option1
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|extract_tag
operator|<
name|Option1
operator|,
name|Options
operator|...
operator|>
operator|:
name|extract_tag
operator|<
name|Options
operator|...
operator|>
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|extract_tag
operator|<
operator|>
block|{
typedef|typedef
name|void
name|type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tag
operator|>
expr|struct
name|is_valid_option
operator|<
name|ilist_tag
operator|<
name|Tag
operator|>>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
comment|/// Check whether options are valid.
comment|///
comment|/// The conjunction of \a is_valid_option on each individual option.
name|template
operator|<
name|class
operator|...
name|Options
operator|>
expr|struct
name|check_options
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|check_options
operator|<
operator|>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
name|template
operator|<
name|class
name|Option1
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|check_options
operator|<
name|Option1
operator|,
name|Options
operator|...
operator|>
operator|:
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|is_valid_option
operator|<
name|Option1
operator|>
operator|::
name|value
operator|&&
name|check_options
operator|<
name|Options
operator|...
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
comment|/// Traits for options for \a ilist_node.
comment|///
comment|/// This is usually computed via \a compute_node_options.
name|template
operator|<
name|class
name|T
operator|,
name|bool
name|EnableSentinelTracking
operator|,
name|bool
name|IsSentinelTrackingExplicit
operator|,
name|class
name|TagT
operator|>
expr|struct
name|node_options
block|{
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
specifier|static
specifier|const
name|bool
name|enable_sentinel_tracking
init|=
name|EnableSentinelTracking
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_sentinel_tracking_explicit
init|=
name|IsSentinelTrackingExplicit
decl_stmt|;
typedef|typedef
name|TagT
name|tag
typedef|;
typedef|typedef
name|ilist_node_base
operator|<
name|enable_sentinel_tracking
operator|>
name|node_base_type
expr_stmt|;
typedef|typedef
name|ilist_base
operator|<
name|enable_sentinel_tracking
operator|>
name|list_base_type
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|T
operator|,
name|class
operator|...
name|Options
operator|>
expr|struct
name|compute_node_options
block|{
typedef|typedef
name|node_options
operator|<
name|T
operator|,
name|extract_sentinel_tracking
operator|<
name|Options
operator|...
operator|>
operator|::
name|value
operator|,
name|extract_sentinel_tracking
operator|<
name|Options
operator|...
operator|>
operator|::
name|is_explicit
operator|,
name|typename
name|extract_tag
operator|<
name|Options
operator|...
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace ilist_detail
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_ADT_ILIST_NODE_OPTIONS_H
end_comment

end_unit

