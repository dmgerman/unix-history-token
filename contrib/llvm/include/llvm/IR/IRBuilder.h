begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---- llvm/IRBuilder.h - Builder for LLVM Instructions ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the IRBuilder class, which is used as a convenient way
end_comment

begin_comment
comment|// to create LLVM instructions with a consistent and simplified interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_IRBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_IRBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm-c/Types.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/None.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/BasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constant.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ConstantFolder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DataLayout.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DebugLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalVariable.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/InstrTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instruction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Intrinsics.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Type.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AtomicOrdering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CBindingWrapping.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|APInt
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|class
name|Use
decl_stmt|;
comment|/// \brief This provides the default implementation of the IRBuilder
comment|/// 'InsertHelper' method that is called whenever an instruction is created by
comment|/// IRBuilder and needs to be inserted.
comment|///
comment|/// By default, this inserts the instruction at the insertion point.
name|class
name|IRBuilderDefaultInserter
block|{
name|protected
label|:
name|void
name|InsertHelper
argument_list|(
name|Instruction
operator|*
name|I
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
argument_list|,
name|BasicBlock
operator|*
name|BB
argument_list|,
name|BasicBlock
operator|::
name|iterator
name|InsertPt
argument_list|)
decl|const
block|{
if|if
condition|(
name|BB
condition|)
name|BB
operator|->
name|getInstList
argument_list|()
operator|.
name|insert
argument_list|(
name|InsertPt
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|I
operator|->
name|setName
argument_list|(
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// Provides an 'InsertHelper' that calls a user-provided callback after
comment|/// performing the default insertion.
name|class
name|IRBuilderCallbackInserter
range|:
name|IRBuilderDefaultInserter
block|{
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|Instruction
operator|*
argument_list|)
operator|>
name|Callback
block|;
name|public
operator|:
name|IRBuilderCallbackInserter
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|Instruction
operator|*
argument_list|)
operator|>
name|Callback
argument_list|)
operator|:
name|Callback
argument_list|(
argument|std::move(Callback)
argument_list|)
block|{}
name|protected
operator|:
name|void
name|InsertHelper
argument_list|(
argument|Instruction *I
argument_list|,
argument|const Twine&Name
argument_list|,
argument|BasicBlock *BB
argument_list|,
argument|BasicBlock::iterator InsertPt
argument_list|)
specifier|const
block|{
name|IRBuilderDefaultInserter
operator|::
name|InsertHelper
argument_list|(
name|I
argument_list|,
name|Name
argument_list|,
name|BB
argument_list|,
name|InsertPt
argument_list|)
block|;
name|Callback
argument_list|(
name|I
argument_list|)
block|;   }
block|}
decl_stmt|;
comment|/// \brief Common base class shared among various IRBuilders.
name|class
name|IRBuilderBase
block|{
name|DebugLoc
name|CurDbgLocation
decl_stmt|;
name|protected
label|:
name|BasicBlock
modifier|*
name|BB
decl_stmt|;
name|BasicBlock
operator|::
name|iterator
name|InsertPt
expr_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|MDNode
modifier|*
name|DefaultFPMathTag
decl_stmt|;
name|FastMathFlags
name|FMF
decl_stmt|;
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|DefaultOperandBundles
expr_stmt|;
name|public
label|:
name|IRBuilderBase
argument_list|(
name|LLVMContext
operator|&
name|context
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
operator|=
name|None
argument_list|)
operator|:
name|Context
argument_list|(
name|context
argument_list|)
operator|,
name|DefaultFPMathTag
argument_list|(
name|FPMathTag
argument_list|)
operator|,
name|DefaultOperandBundles
argument_list|(
argument|OpBundles
argument_list|)
block|{
name|ClearInsertionPoint
argument_list|()
block|;   }
comment|//===--------------------------------------------------------------------===//
comment|// Builder configuration methods
comment|//===--------------------------------------------------------------------===//
comment|/// \brief Clear the insertion point: created instructions will not be
comment|/// inserted into a block.
name|void
name|ClearInsertionPoint
argument_list|()
block|{
name|BB
operator|=
name|nullptr
block|;
name|InsertPt
operator|=
name|BasicBlock
operator|::
name|iterator
argument_list|()
block|;   }
name|BasicBlock
operator|*
name|GetInsertBlock
argument_list|()
specifier|const
block|{
return|return
name|BB
return|;
block|}
name|BasicBlock
operator|::
name|iterator
name|GetInsertPoint
argument_list|()
specifier|const
block|{
return|return
name|InsertPt
return|;
block|}
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// \brief This specifies that created instructions should be appended to the
comment|/// end of the specified block.
name|void
name|SetInsertPoint
parameter_list|(
name|BasicBlock
modifier|*
name|TheBB
parameter_list|)
block|{
name|BB
operator|=
name|TheBB
expr_stmt|;
name|InsertPt
operator|=
name|BB
operator|->
name|end
argument_list|()
expr_stmt|;
block|}
comment|/// \brief This specifies that created instructions should be inserted before
comment|/// the specified instruction.
name|void
name|SetInsertPoint
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
name|BB
operator|=
name|I
operator|->
name|getParent
argument_list|()
expr_stmt|;
name|InsertPt
operator|=
name|I
operator|->
name|getIterator
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|InsertPt
operator|!=
name|BB
operator|->
name|end
argument_list|()
operator|&&
literal|"Can't read debug loc from end()"
argument_list|)
expr_stmt|;
name|SetCurrentDebugLocation
argument_list|(
name|I
operator|->
name|getDebugLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief This specifies that created instructions should be inserted at the
comment|/// specified point.
name|void
name|SetInsertPoint
argument_list|(
name|BasicBlock
operator|*
name|TheBB
argument_list|,
name|BasicBlock
operator|::
name|iterator
name|IP
argument_list|)
block|{
name|BB
operator|=
name|TheBB
expr_stmt|;
name|InsertPt
operator|=
name|IP
expr_stmt|;
if|if
condition|(
name|IP
operator|!=
name|TheBB
operator|->
name|end
argument_list|()
condition|)
name|SetCurrentDebugLocation
argument_list|(
name|IP
operator|->
name|getDebugLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Set location information used by debugging information.
name|void
name|SetCurrentDebugLocation
parameter_list|(
name|DebugLoc
name|L
parameter_list|)
block|{
name|CurDbgLocation
operator|=
name|std
operator|::
name|move
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Get location information used by debugging information.
specifier|const
name|DebugLoc
operator|&
name|getCurrentDebugLocation
argument_list|()
specifier|const
block|{
return|return
name|CurDbgLocation
return|;
block|}
comment|/// \brief If this builder has a current debug location, set it on the
comment|/// specified instruction.
name|void
name|SetInstDebugLocation
argument_list|(
name|Instruction
operator|*
name|I
argument_list|)
decl|const
block|{
if|if
condition|(
name|CurDbgLocation
condition|)
name|I
operator|->
name|setDebugLoc
argument_list|(
name|CurDbgLocation
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Get the return type of the current function that we're emitting
comment|/// into.
name|Type
modifier|*
name|getCurrentFunctionReturnType
parameter_list|()
function|const;
comment|/// InsertPoint - A saved insertion point.
name|class
name|InsertPoint
block|{
name|BasicBlock
modifier|*
name|Block
init|=
name|nullptr
decl_stmt|;
name|BasicBlock
operator|::
name|iterator
name|Point
expr_stmt|;
name|public
label|:
comment|/// \brief Creates a new insertion point which doesn't point to anything.
name|InsertPoint
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// \brief Creates a new insertion point at the given location.
name|InsertPoint
argument_list|(
argument|BasicBlock *InsertBlock
argument_list|,
argument|BasicBlock::iterator InsertPoint
argument_list|)
block|:
name|Block
argument_list|(
name|InsertBlock
argument_list|)
operator|,
name|Point
argument_list|(
argument|InsertPoint
argument_list|)
block|{}
comment|/// \brief Returns true if this insert point is set.
name|bool
name|isSet
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Block
operator|!=
name|nullptr
operator|)
return|;
block|}
name|BasicBlock
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
name|BasicBlock
operator|::
name|iterator
name|getPoint
argument_list|()
specifier|const
block|{
return|return
name|Point
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief Returns the current insert point.
name|InsertPoint
name|saveIP
argument_list|()
specifier|const
block|{
return|return
name|InsertPoint
argument_list|(
name|GetInsertBlock
argument_list|()
argument_list|,
name|GetInsertPoint
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Returns the current insert point, clearing it in the process.
name|InsertPoint
name|saveAndClearIP
parameter_list|()
block|{
name|InsertPoint
name|IP
argument_list|(
name|GetInsertBlock
argument_list|()
argument_list|,
name|GetInsertPoint
argument_list|()
argument_list|)
decl_stmt|;
name|ClearInsertionPoint
argument_list|()
expr_stmt|;
return|return
name|IP
return|;
block|}
comment|/// \brief Sets the current insert point to a previously-saved location.
name|void
name|restoreIP
parameter_list|(
name|InsertPoint
name|IP
parameter_list|)
block|{
if|if
condition|(
name|IP
operator|.
name|isSet
argument_list|()
condition|)
name|SetInsertPoint
argument_list|(
name|IP
operator|.
name|getBlock
argument_list|()
argument_list|,
name|IP
operator|.
name|getPoint
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ClearInsertionPoint
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Get the floating point math metadata being used.
name|MDNode
operator|*
name|getDefaultFPMathTag
argument_list|()
specifier|const
block|{
return|return
name|DefaultFPMathTag
return|;
block|}
comment|/// \brief Get the flags to be applied to created floating point ops
name|FastMathFlags
name|getFastMathFlags
argument_list|()
specifier|const
block|{
return|return
name|FMF
return|;
block|}
comment|/// \brief Clear the fast-math flags.
name|void
name|clearFastMathFlags
parameter_list|()
block|{
name|FMF
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Set the floating point math metadata to be used.
name|void
name|setDefaultFPMathTag
parameter_list|(
name|MDNode
modifier|*
name|FPMathTag
parameter_list|)
block|{
name|DefaultFPMathTag
operator|=
name|FPMathTag
expr_stmt|;
block|}
comment|/// \brief Set the fast-math flags to be used with generated fp-math operators
name|void
name|setFastMathFlags
parameter_list|(
name|FastMathFlags
name|NewFMF
parameter_list|)
block|{
name|FMF
operator|=
name|NewFMF
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// RAII helpers.
comment|//===--------------------------------------------------------------------===//
comment|// \brief RAII object that stores the current insertion point and restores it
comment|// when the object is destroyed. This includes the debug location.
name|class
name|InsertPointGuard
block|{
name|IRBuilderBase
modifier|&
name|Builder
decl_stmt|;
name|AssertingVH
operator|<
name|BasicBlock
operator|>
name|Block
expr_stmt|;
name|BasicBlock
operator|::
name|iterator
name|Point
expr_stmt|;
name|DebugLoc
name|DbgLoc
decl_stmt|;
name|public
label|:
name|InsertPointGuard
argument_list|(
name|IRBuilderBase
operator|&
name|B
argument_list|)
operator|:
name|Builder
argument_list|(
name|B
argument_list|)
operator|,
name|Block
argument_list|(
name|B
operator|.
name|GetInsertBlock
argument_list|()
argument_list|)
operator|,
name|Point
argument_list|(
name|B
operator|.
name|GetInsertPoint
argument_list|()
argument_list|)
operator|,
name|DbgLoc
argument_list|(
argument|B.getCurrentDebugLocation()
argument_list|)
block|{}
name|InsertPointGuard
argument_list|(
specifier|const
name|InsertPointGuard
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|InsertPointGuard
modifier|&
name|operator
init|=
operator|(
specifier|const
name|InsertPointGuard
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|InsertPointGuard
argument_list|()
block|{
name|Builder
operator|.
name|restoreIP
argument_list|(
name|InsertPoint
argument_list|(
name|Block
argument_list|,
name|Point
argument_list|)
argument_list|)
block|;
name|Builder
operator|.
name|SetCurrentDebugLocation
argument_list|(
name|DbgLoc
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|// \brief RAII object that stores the current fast math settings and restores
comment|// them when the object is destroyed.
name|class
name|FastMathFlagGuard
block|{
name|IRBuilderBase
modifier|&
name|Builder
decl_stmt|;
name|FastMathFlags
name|FMF
decl_stmt|;
name|MDNode
modifier|*
name|FPMathTag
decl_stmt|;
name|public
label|:
name|FastMathFlagGuard
argument_list|(
name|IRBuilderBase
operator|&
name|B
argument_list|)
operator|:
name|Builder
argument_list|(
name|B
argument_list|)
operator|,
name|FMF
argument_list|(
name|B
operator|.
name|FMF
argument_list|)
operator|,
name|FPMathTag
argument_list|(
argument|B.DefaultFPMathTag
argument_list|)
block|{}
name|FastMathFlagGuard
argument_list|(
specifier|const
name|FastMathFlagGuard
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|FastMathFlagGuard
modifier|&
name|operator
init|=
operator|(
specifier|const
name|FastMathFlagGuard
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|FastMathFlagGuard
argument_list|()
block|{
name|Builder
operator|.
name|FMF
operator|=
name|FMF
block|;
name|Builder
operator|.
name|DefaultFPMathTag
operator|=
name|FPMathTag
block|;     }
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Miscellaneous creation methods.
comment|//===--------------------------------------------------------------------===//
comment|/// \brief Make a new global variable with initializer type i8*
comment|///
comment|/// Make a new global variable with an initializer that has array of i8 type
comment|/// filled in with the null terminated string value specified.  The new global
comment|/// variable will be marked mergable with any others of the same contents.  If
comment|/// Name is specified, it is the name of the global variable created.
name|GlobalVariable
modifier|*
name|CreateGlobalString
parameter_list|(
name|StringRef
name|Str
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|unsigned
name|AddressSpace
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// \brief Get a constant value representing either true or false.
name|ConstantInt
modifier|*
name|getInt1
parameter_list|(
name|bool
name|V
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getInt1Ty
argument_list|()
argument_list|,
name|V
argument_list|)
return|;
block|}
comment|/// \brief Get the constant value for i1 true.
name|ConstantInt
modifier|*
name|getTrue
parameter_list|()
block|{
return|return
name|ConstantInt
operator|::
name|getTrue
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Get the constant value for i1 false.
name|ConstantInt
modifier|*
name|getFalse
parameter_list|()
block|{
return|return
name|ConstantInt
operator|::
name|getFalse
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Get a constant 8-bit value.
name|ConstantInt
modifier|*
name|getInt8
parameter_list|(
name|uint8_t
name|C
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getInt8Ty
argument_list|()
argument_list|,
name|C
argument_list|)
return|;
block|}
comment|/// \brief Get a constant 16-bit value.
name|ConstantInt
modifier|*
name|getInt16
parameter_list|(
name|uint16_t
name|C
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getInt16Ty
argument_list|()
argument_list|,
name|C
argument_list|)
return|;
block|}
comment|/// \brief Get a constant 32-bit value.
name|ConstantInt
modifier|*
name|getInt32
parameter_list|(
name|uint32_t
name|C
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getInt32Ty
argument_list|()
argument_list|,
name|C
argument_list|)
return|;
block|}
comment|/// \brief Get a constant 64-bit value.
name|ConstantInt
modifier|*
name|getInt64
parameter_list|(
name|uint64_t
name|C
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getInt64Ty
argument_list|()
argument_list|,
name|C
argument_list|)
return|;
block|}
comment|/// \brief Get a constant N-bit value, zero extended or truncated from
comment|/// a 64-bit value.
name|ConstantInt
modifier|*
name|getIntN
parameter_list|(
name|unsigned
name|N
parameter_list|,
name|uint64_t
name|C
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|getIntNTy
argument_list|(
name|N
argument_list|)
argument_list|,
name|C
argument_list|)
return|;
block|}
comment|/// \brief Get a constant integer value.
name|ConstantInt
modifier|*
name|getInt
parameter_list|(
specifier|const
name|APInt
modifier|&
name|AI
parameter_list|)
block|{
return|return
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|AI
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Type creation methods
comment|//===--------------------------------------------------------------------===//
comment|/// \brief Fetch the type representing a single bit
name|IntegerType
modifier|*
name|getInt1Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt1Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing an 8-bit integer.
name|IntegerType
modifier|*
name|getInt8Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt8Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 16-bit integer.
name|IntegerType
modifier|*
name|getInt16Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt16Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 32-bit integer.
name|IntegerType
modifier|*
name|getInt32Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 64-bit integer.
name|IntegerType
modifier|*
name|getInt64Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 128-bit integer.
name|IntegerType
modifier|*
name|getInt128Ty
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getInt128Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing an N-bit integer.
name|IntegerType
modifier|*
name|getIntNTy
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
return|return
name|Type
operator|::
name|getIntNTy
argument_list|(
name|Context
argument_list|,
name|N
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 16-bit floating point value.
name|Type
modifier|*
name|getHalfTy
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getHalfTy
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 32-bit floating point value.
name|Type
modifier|*
name|getFloatTy
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getFloatTy
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a 64-bit floating point value.
name|Type
modifier|*
name|getDoubleTy
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getDoubleTy
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing void.
name|Type
modifier|*
name|getVoidTy
parameter_list|()
block|{
return|return
name|Type
operator|::
name|getVoidTy
argument_list|(
name|Context
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a pointer to an 8-bit integer value.
name|PointerType
modifier|*
name|getInt8PtrTy
parameter_list|(
name|unsigned
name|AddrSpace
init|=
literal|0
parameter_list|)
block|{
return|return
name|Type
operator|::
name|getInt8PtrTy
argument_list|(
name|Context
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
comment|/// \brief Fetch the type representing a pointer to an integer value.
name|IntegerType
modifier|*
name|getIntPtrTy
parameter_list|(
specifier|const
name|DataLayout
modifier|&
name|DL
parameter_list|,
name|unsigned
name|AddrSpace
init|=
literal|0
parameter_list|)
block|{
return|return
name|DL
operator|.
name|getIntPtrType
argument_list|(
name|Context
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Intrinsic creation methods
comment|//===--------------------------------------------------------------------===//
comment|/// \brief Create and insert a memset to the specified pointer and the
comment|/// specified value.
comment|///
comment|/// If the pointer isn't an i8*, it will be converted. If a TBAA tag is
comment|/// specified, it will be added to the instruction. Likewise with alias.scope
comment|/// and noalias tags.
name|CallInst
modifier|*
name|CreateMemSet
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|Value
modifier|*
name|Val
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateMemSet
argument_list|(
name|Ptr
argument_list|,
name|Val
argument_list|,
name|getInt64
argument_list|(
name|Size
argument_list|)
argument_list|,
name|Align
argument_list|,
name|isVolatile
argument_list|,
name|TBAATag
argument_list|,
name|ScopeTag
argument_list|,
name|NoAliasTag
argument_list|)
return|;
block|}
name|CallInst
modifier|*
name|CreateMemSet
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|Value
modifier|*
name|Val
parameter_list|,
name|Value
modifier|*
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create and insert a memcpy between the specified pointers.
comment|///
comment|/// If the pointers aren't i8*, they will be converted.  If a TBAA tag is
comment|/// specified, it will be added to the instruction. Likewise with alias.scope
comment|/// and noalias tags.
name|CallInst
modifier|*
name|CreateMemCpy
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|TBAAStructTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateMemCpy
argument_list|(
name|Dst
argument_list|,
name|Src
argument_list|,
name|getInt64
argument_list|(
name|Size
argument_list|)
argument_list|,
name|Align
argument_list|,
name|isVolatile
argument_list|,
name|TBAATag
argument_list|,
name|TBAAStructTag
argument_list|,
name|ScopeTag
argument_list|,
name|NoAliasTag
argument_list|)
return|;
block|}
name|CallInst
modifier|*
name|CreateMemCpy
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|Value
modifier|*
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|TBAAStructTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create and insert an element unordered-atomic memcpy between the
comment|/// specified pointers.
comment|///
comment|/// If the pointers aren't i8*, they will be converted.  If a TBAA tag is
comment|/// specified, it will be added to the instruction. Likewise with alias.scope
comment|/// and noalias tags.
name|CallInst
modifier|*
name|CreateElementUnorderedAtomicMemCpy
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|uint32_t
name|ElementSize
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|TBAAStructTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateElementUnorderedAtomicMemCpy
argument_list|(
name|Dst
argument_list|,
name|Src
argument_list|,
name|getInt64
argument_list|(
name|Size
argument_list|)
argument_list|,
name|ElementSize
argument_list|,
name|TBAATag
argument_list|,
name|TBAAStructTag
argument_list|,
name|ScopeTag
argument_list|,
name|NoAliasTag
argument_list|)
return|;
block|}
name|CallInst
modifier|*
name|CreateElementUnorderedAtomicMemCpy
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|Value
modifier|*
name|Size
parameter_list|,
name|uint32_t
name|ElementSize
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|TBAAStructTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create and insert a memmove between the specified
comment|/// pointers.
comment|///
comment|/// If the pointers aren't i8*, they will be converted.  If a TBAA tag is
comment|/// specified, it will be added to the instruction. Likewise with alias.scope
comment|/// and noalias tags.
name|CallInst
modifier|*
name|CreateMemMove
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateMemMove
argument_list|(
name|Dst
argument_list|,
name|Src
argument_list|,
name|getInt64
argument_list|(
name|Size
argument_list|)
argument_list|,
name|Align
argument_list|,
name|isVolatile
argument_list|,
name|TBAATag
argument_list|,
name|ScopeTag
argument_list|,
name|NoAliasTag
argument_list|)
return|;
block|}
name|CallInst
modifier|*
name|CreateMemMove
parameter_list|(
name|Value
modifier|*
name|Dst
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|,
name|Value
modifier|*
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|,
name|MDNode
modifier|*
name|TBAATag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|ScopeTag
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|NoAliasTag
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create a vector fadd reduction intrinsic of the source vector.
comment|/// The first parameter is a scalar accumulator value for ordered reductions.
name|CallInst
modifier|*
name|CreateFAddReduce
parameter_list|(
name|Value
modifier|*
name|Acc
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector fmul reduction intrinsic of the source vector.
comment|/// The first parameter is a scalar accumulator value for ordered reductions.
name|CallInst
modifier|*
name|CreateFMulReduce
parameter_list|(
name|Value
modifier|*
name|Acc
parameter_list|,
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector int add reduction intrinsic of the source vector.
name|CallInst
modifier|*
name|CreateAddReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector int mul reduction intrinsic of the source vector.
name|CallInst
modifier|*
name|CreateMulReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector int AND reduction intrinsic of the source vector.
name|CallInst
modifier|*
name|CreateAndReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector int OR reduction intrinsic of the source vector.
name|CallInst
modifier|*
name|CreateOrReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector int XOR reduction intrinsic of the source vector.
name|CallInst
modifier|*
name|CreateXorReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// \brief Create a vector integer max reduction intrinsic of the source
comment|/// vector.
name|CallInst
modifier|*
name|CreateIntMaxReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|,
name|bool
name|IsSigned
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Create a vector integer min reduction intrinsic of the source
comment|/// vector.
name|CallInst
modifier|*
name|CreateIntMinReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|,
name|bool
name|IsSigned
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Create a vector float max reduction intrinsic of the source
comment|/// vector.
name|CallInst
modifier|*
name|CreateFPMaxReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|,
name|bool
name|NoNaN
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Create a vector float min reduction intrinsic of the source
comment|/// vector.
name|CallInst
modifier|*
name|CreateFPMinReduce
parameter_list|(
name|Value
modifier|*
name|Src
parameter_list|,
name|bool
name|NoNaN
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Create a lifetime.start intrinsic.
comment|///
comment|/// If the pointer isn't i8* it will be converted.
name|CallInst
modifier|*
name|CreateLifetimeStart
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|ConstantInt
modifier|*
name|Size
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create a lifetime.end intrinsic.
comment|///
comment|/// If the pointer isn't i8* it will be converted.
name|CallInst
modifier|*
name|CreateLifetimeEnd
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|ConstantInt
modifier|*
name|Size
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// Create a call to invariant.start intrinsic.
comment|///
comment|/// If the pointer isn't i8* it will be converted.
name|CallInst
modifier|*
name|CreateInvariantStart
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|ConstantInt
modifier|*
name|Size
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create a call to Masked Load intrinsic
name|CallInst
modifier|*
name|CreateMaskedLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|Value
modifier|*
name|Mask
parameter_list|,
name|Value
modifier|*
name|PassThru
init|=
name|nullptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
function_decl|;
comment|/// \brief Create a call to Masked Store intrinsic
name|CallInst
modifier|*
name|CreateMaskedStore
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|Value
modifier|*
name|Mask
parameter_list|)
function_decl|;
comment|/// \brief Create a call to Masked Gather intrinsic
name|CallInst
modifier|*
name|CreateMaskedGather
parameter_list|(
name|Value
modifier|*
name|Ptrs
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|Value
modifier|*
name|Mask
init|=
name|nullptr
parameter_list|,
name|Value
modifier|*
name|PassThru
init|=
name|nullptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
function_decl|;
comment|/// \brief Create a call to Masked Scatter intrinsic
name|CallInst
modifier|*
name|CreateMaskedScatter
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|Value
modifier|*
name|Ptrs
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|Value
modifier|*
name|Mask
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Create an assume intrinsic call that allows the optimizer to
comment|/// assume that the provided condition will be true.
name|CallInst
modifier|*
name|CreateAssumption
parameter_list|(
name|Value
modifier|*
name|Cond
parameter_list|)
function_decl|;
comment|/// \brief Create a call to the experimental.gc.statepoint intrinsic to
comment|/// start a new statepoint sequence.
name|CallInst
modifier|*
name|CreateGCStatepointCall
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualCallee
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|CallArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// \brief Create a call to the experimental.gc.statepoint intrinsic to
comment|/// start a new statepoint sequence.
name|CallInst
modifier|*
name|CreateGCStatepointCall
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualCallee
argument_list|,
name|uint32_t
name|Flags
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|CallArgs
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|TransitionArgs
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|// \brief Conveninence function for the common case when CallArgs are filled
comment|// in using makeArrayRef(CS.arg_begin(), CS.arg_end()); Use needs to be
comment|// .get()'ed to get the Value pointer.
name|CallInst
modifier|*
name|CreateGCStatepointCall
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualCallee
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|CallArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// brief Create an invoke to the experimental.gc.statepoint intrinsic to
comment|/// start a new statepoint sequence.
name|InvokeInst
modifier|*
name|CreateGCStatepointInvoke
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualInvokee
argument_list|,
name|BasicBlock
operator|*
name|NormalDest
argument_list|,
name|BasicBlock
operator|*
name|UnwindDest
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|InvokeArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// brief Create an invoke to the experimental.gc.statepoint intrinsic to
comment|/// start a new statepoint sequence.
name|InvokeInst
modifier|*
name|CreateGCStatepointInvoke
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualInvokee
argument_list|,
name|BasicBlock
operator|*
name|NormalDest
argument_list|,
name|BasicBlock
operator|*
name|UnwindDest
argument_list|,
name|uint32_t
name|Flags
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|InvokeArgs
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|TransitionArgs
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|// Conveninence function for the common case when CallArgs are filled in using
comment|// makeArrayRef(CS.arg_begin(), CS.arg_end()); Use needs to be .get()'ed to
comment|// get the Value *.
name|InvokeInst
modifier|*
name|CreateGCStatepointInvoke
argument_list|(
name|uint64_t
name|ID
argument_list|,
name|uint32_t
name|NumPatchBytes
argument_list|,
name|Value
operator|*
name|ActualInvokee
argument_list|,
name|BasicBlock
operator|*
name|NormalDest
argument_list|,
name|BasicBlock
operator|*
name|UnwindDest
argument_list|,
name|ArrayRef
operator|<
name|Use
operator|>
name|InvokeArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|DeoptArgs
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|GCArgs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// \brief Create a call to the experimental.gc.result intrinsic to extract
comment|/// the result from a call wrapped in a statepoint.
name|CallInst
modifier|*
name|CreateGCResult
parameter_list|(
name|Instruction
modifier|*
name|Statepoint
parameter_list|,
name|Type
modifier|*
name|ResultType
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
function_decl|;
comment|/// \brief Create a call to the experimental.gc.relocate intrinsics to
comment|/// project the relocated value of one pointer from the statepoint.
name|CallInst
modifier|*
name|CreateGCRelocate
parameter_list|(
name|Instruction
modifier|*
name|Statepoint
parameter_list|,
name|int
name|BaseOffset
parameter_list|,
name|int
name|DerivedOffset
parameter_list|,
name|Type
modifier|*
name|ResultType
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
function_decl|;
comment|/// Create a call to intrinsic \p ID with 2 operands which is mangled on the
comment|/// first type.
name|CallInst
modifier|*
name|CreateBinaryIntrinsic
argument_list|(
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// Create call to the minnum intrinsic.
name|CallInst
modifier|*
name|CreateMinNum
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateBinaryIntrinsic
argument_list|(
name|Intrinsic
operator|::
name|minnum
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
comment|/// Create call to the maxnum intrinsic.
name|CallInst
modifier|*
name|CreateMaxNum
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateBinaryIntrinsic
argument_list|(
name|Intrinsic
operator|::
name|minnum
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
name|private
label|:
comment|/// \brief Create a call to a masked intrinsic with given Id.
name|CallInst
modifier|*
name|CreateMaskedIntrinsic
argument_list|(
name|Intrinsic
operator|::
name|ID
name|Id
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Ops
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|OverloadedTypes
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|getCastedInt8PtrValue
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// \brief This provides a uniform API for creating instructions and inserting
comment|/// them into a basic block: either at the end of a BasicBlock, or at a specific
comment|/// iterator location in a block.
comment|///
comment|/// Note that the builder does not expose the full generality of LLVM
comment|/// instructions.  For access to extra instruction properties, use the mutators
comment|/// (e.g. setVolatile) on the instructions after they have been
comment|/// created. Convenience state exists to specify fast-math flags and fp-math
comment|/// tags.
comment|///
comment|/// The first template argument specifies a class to use for creating constants.
comment|/// This defaults to creating minimally folded constants.  The second template
comment|/// argument allows clients to specify custom insertion hooks that are called on
comment|/// every newly created insertion.
name|template
operator|<
name|typename
name|T
operator|=
name|ConstantFolder
operator|,
name|typename
name|Inserter
operator|=
name|IRBuilderDefaultInserter
operator|>
name|class
name|IRBuilder
operator|:
name|public
name|IRBuilderBase
operator|,
name|public
name|Inserter
block|{
name|T
name|Folder
block|;
name|public
operator|:
name|IRBuilder
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|const T&F
argument_list|,
argument|Inserter I = Inserter()
argument_list|,
argument|MDNode *FPMathTag = nullptr
argument_list|,
argument|ArrayRef<OperandBundleDef> OpBundles = None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|C
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Inserter
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|I
argument_list|)
argument_list|)
block|,
name|Folder
argument_list|(
argument|F
argument_list|)
block|{}
name|explicit
name|IRBuilder
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
operator|=
name|None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|C
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|()
block|{}
name|explicit
name|IRBuilder
argument_list|(
name|BasicBlock
operator|*
name|TheBB
argument_list|,
specifier|const
name|T
operator|&
name|F
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
operator|=
name|None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|TheBB
operator|->
name|getContext
argument_list|()
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|(
argument|F
argument_list|)
block|{
name|SetInsertPoint
argument_list|(
name|TheBB
argument_list|)
block|;   }
name|explicit
name|IRBuilder
argument_list|(
name|BasicBlock
operator|*
name|TheBB
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
operator|=
name|None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|TheBB
operator|->
name|getContext
argument_list|()
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|()
block|{
name|SetInsertPoint
argument_list|(
name|TheBB
argument_list|)
block|;   }
name|explicit
name|IRBuilder
argument_list|(
name|Instruction
operator|*
name|IP
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
operator|=
name|None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|IP
operator|->
name|getContext
argument_list|()
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|()
block|{
name|SetInsertPoint
argument_list|(
name|IP
argument_list|)
block|;   }
name|IRBuilder
argument_list|(
argument|BasicBlock *TheBB
argument_list|,
argument|BasicBlock::iterator IP
argument_list|,
argument|const T&F
argument_list|,
argument|MDNode *FPMathTag = nullptr
argument_list|,
argument|ArrayRef<OperandBundleDef> OpBundles = None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|TheBB
operator|->
name|getContext
argument_list|()
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|(
argument|F
argument_list|)
block|{
name|SetInsertPoint
argument_list|(
name|TheBB
argument_list|,
name|IP
argument_list|)
block|;   }
name|IRBuilder
argument_list|(
argument|BasicBlock *TheBB
argument_list|,
argument|BasicBlock::iterator IP
argument_list|,
argument|MDNode *FPMathTag = nullptr
argument_list|,
argument|ArrayRef<OperandBundleDef> OpBundles = None
argument_list|)
operator|:
name|IRBuilderBase
argument_list|(
name|TheBB
operator|->
name|getContext
argument_list|()
argument_list|,
name|FPMathTag
argument_list|,
name|OpBundles
argument_list|)
block|,
name|Folder
argument_list|()
block|{
name|SetInsertPoint
argument_list|(
name|TheBB
argument_list|,
name|IP
argument_list|)
block|;   }
comment|/// \brief Get the constant folder being used.
specifier|const
name|T
operator|&
name|getFolder
argument_list|()
block|{
return|return
name|Folder
return|;
block|}
comment|/// \brief Insert and return the specified instruction.
name|template
operator|<
name|typename
name|InstTy
operator|>
name|InstTy
operator|*
name|Insert
argument_list|(
argument|InstTy *I
argument_list|,
argument|const Twine&Name =
literal|""
argument_list|)
specifier|const
block|{
name|this
operator|->
name|InsertHelper
argument_list|(
name|I
argument_list|,
name|Name
argument_list|,
name|BB
argument_list|,
name|InsertPt
argument_list|)
block|;
name|this
operator|->
name|SetInstDebugLocation
argument_list|(
name|I
argument_list|)
block|;
return|return
name|I
return|;
block|}
comment|/// \brief No-op overload to handle constants.
name|Constant
operator|*
name|Insert
argument_list|(
argument|Constant *C
argument_list|,
argument|const Twine& =
literal|""
argument_list|)
specifier|const
block|{
return|return
name|C
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Instruction creation methods: Terminators
comment|//===--------------------------------------------------------------------===//
name|private
operator|:
comment|/// \brief Helper to add branch weight and unpredictable metadata onto an
comment|/// instruction.
comment|/// \returns The annotated instruction.
name|template
operator|<
name|typename
name|InstTy
operator|>
name|InstTy
operator|*
name|addBranchMetadata
argument_list|(
argument|InstTy *I
argument_list|,
argument|MDNode *Weights
argument_list|,
argument|MDNode *Unpredictable
argument_list|)
block|{
if|if
condition|(
name|Weights
condition|)
name|I
operator|->
name|setMetadata
argument_list|(
name|LLVMContext
operator|::
name|MD_prof
argument_list|,
name|Weights
argument_list|)
expr_stmt|;
if|if
condition|(
name|Unpredictable
condition|)
name|I
operator|->
name|setMetadata
argument_list|(
name|LLVMContext
operator|::
name|MD_unpredictable
argument_list|,
name|Unpredictable
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// \brief Create a 'ret void' instruction.
end_comment

begin_function
name|ReturnInst
modifier|*
name|CreateRetVoid
parameter_list|()
block|{
return|return
name|Insert
argument_list|(
name|ReturnInst
operator|::
name|Create
argument_list|(
name|Context
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a 'ret<val>' instruction.
end_comment

begin_function
name|ReturnInst
modifier|*
name|CreateRet
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|ReturnInst
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
name|V
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a sequence of N insertvalue instructions,
end_comment

begin_comment
comment|/// with one Value from the retVals array each, that build a aggregate
end_comment

begin_comment
comment|/// return value one value at a time, and a ret instruction to return
end_comment

begin_comment
comment|/// the resulting aggregate value.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is a convenience function for code that uses aggregate return values
end_comment

begin_comment
comment|/// as a vehicle for having multiple return values.
end_comment

begin_function
name|ReturnInst
modifier|*
name|CreateAggregateRet
parameter_list|(
name|Value
modifier|*
specifier|const
modifier|*
name|retVals
parameter_list|,
name|unsigned
name|N
parameter_list|)
block|{
name|Value
modifier|*
name|V
init|=
name|UndefValue
operator|::
name|get
argument_list|(
name|getCurrentFunctionReturnType
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|N
condition|;
operator|++
name|i
control|)
name|V
operator|=
name|CreateInsertValue
argument_list|(
name|V
argument_list|,
name|retVals
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
literal|"mrv"
argument_list|)
expr_stmt|;
return|return
name|Insert
argument_list|(
name|ReturnInst
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
name|V
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create an unconditional 'br label X' instruction.
end_comment

begin_function
name|BranchInst
modifier|*
name|CreateBr
parameter_list|(
name|BasicBlock
modifier|*
name|Dest
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|BranchInst
operator|::
name|Create
argument_list|(
name|Dest
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a conditional 'br Cond, TrueDest, FalseDest'
end_comment

begin_comment
comment|/// instruction.
end_comment

begin_function
name|BranchInst
modifier|*
name|CreateCondBr
parameter_list|(
name|Value
modifier|*
name|Cond
parameter_list|,
name|BasicBlock
modifier|*
name|True
parameter_list|,
name|BasicBlock
modifier|*
name|False
parameter_list|,
name|MDNode
modifier|*
name|BranchWeights
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|Unpredictable
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|addBranchMetadata
argument_list|(
name|BranchInst
operator|::
name|Create
argument_list|(
name|True
argument_list|,
name|False
argument_list|,
name|Cond
argument_list|)
argument_list|,
name|BranchWeights
argument_list|,
name|Unpredictable
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a conditional 'br Cond, TrueDest, FalseDest'
end_comment

begin_comment
comment|/// instruction. Copy branch meta data if available.
end_comment

begin_function
name|BranchInst
modifier|*
name|CreateCondBr
parameter_list|(
name|Value
modifier|*
name|Cond
parameter_list|,
name|BasicBlock
modifier|*
name|True
parameter_list|,
name|BasicBlock
modifier|*
name|False
parameter_list|,
name|Instruction
modifier|*
name|MDSrc
parameter_list|)
block|{
name|BranchInst
modifier|*
name|Br
init|=
name|BranchInst
operator|::
name|Create
argument_list|(
name|True
argument_list|,
name|False
argument_list|,
name|Cond
argument_list|)
decl_stmt|;
if|if
condition|(
name|MDSrc
condition|)
block|{
name|unsigned
name|WL
index|[
literal|4
index|]
init|=
block|{
name|LLVMContext
operator|::
name|MD_prof
block|,
name|LLVMContext
operator|::
name|MD_unpredictable
block|,
name|LLVMContext
operator|::
name|MD_make_implicit
block|,
name|LLVMContext
operator|::
name|MD_dbg
block|}
decl_stmt|;
name|Br
operator|->
name|copyMetadata
argument_list|(
operator|*
name|MDSrc
argument_list|,
name|makeArrayRef
argument_list|(
operator|&
name|WL
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Insert
argument_list|(
name|Br
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a switch instruction with the specified value, default dest,
end_comment

begin_comment
comment|/// and with a hint for the number of cases that will be added (for efficient
end_comment

begin_comment
comment|/// allocation).
end_comment

begin_function
name|SwitchInst
modifier|*
name|CreateSwitch
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|BasicBlock
modifier|*
name|Dest
parameter_list|,
name|unsigned
name|NumCases
init|=
literal|10
parameter_list|,
name|MDNode
modifier|*
name|BranchWeights
init|=
name|nullptr
parameter_list|,
name|MDNode
modifier|*
name|Unpredictable
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|addBranchMetadata
argument_list|(
name|SwitchInst
operator|::
name|Create
argument_list|(
name|V
argument_list|,
name|Dest
argument_list|,
name|NumCases
argument_list|)
argument_list|,
name|BranchWeights
argument_list|,
name|Unpredictable
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create an indirect branch instruction with the specified address
end_comment

begin_comment
comment|/// operand, with an optional hint for the number of destinations that will be
end_comment

begin_comment
comment|/// added (for efficient allocation).
end_comment

begin_function
name|IndirectBrInst
modifier|*
name|CreateIndirectBr
parameter_list|(
name|Value
modifier|*
name|Addr
parameter_list|,
name|unsigned
name|NumDests
init|=
literal|10
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|IndirectBrInst
operator|::
name|Create
argument_list|(
name|Addr
argument_list|,
name|NumDests
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create an invoke instruction.
end_comment

begin_decl_stmt
name|InvokeInst
modifier|*
name|CreateInvoke
argument_list|(
name|Value
operator|*
name|Callee
argument_list|,
name|BasicBlock
operator|*
name|NormalDest
argument_list|,
name|BasicBlock
operator|*
name|UnwindDest
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
operator|=
name|None
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|Insert
argument_list|(
name|InvokeInst
operator|::
name|Create
argument_list|(
name|Callee
argument_list|,
name|NormalDest
argument_list|,
name|UnwindDest
argument_list|,
name|Args
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|InvokeInst
modifier|*
name|CreateInvoke
argument_list|(
name|Value
operator|*
name|Callee
argument_list|,
name|BasicBlock
operator|*
name|NormalDest
argument_list|,
name|BasicBlock
operator|*
name|UnwindDest
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|Insert
argument_list|(
name|InvokeInst
operator|::
name|Create
argument_list|(
name|Callee
argument_list|,
name|NormalDest
argument_list|,
name|UnwindDest
argument_list|,
name|Args
argument_list|,
name|OpBundles
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|ResumeInst
modifier|*
name|CreateResume
parameter_list|(
name|Value
modifier|*
name|Exn
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|ResumeInst
operator|::
name|Create
argument_list|(
name|Exn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|CleanupReturnInst
modifier|*
name|CreateCleanupRet
parameter_list|(
name|CleanupPadInst
modifier|*
name|CleanupPad
parameter_list|,
name|BasicBlock
modifier|*
name|UnwindBB
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|CleanupReturnInst
operator|::
name|Create
argument_list|(
name|CleanupPad
argument_list|,
name|UnwindBB
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|CatchSwitchInst
modifier|*
name|CreateCatchSwitch
parameter_list|(
name|Value
modifier|*
name|ParentPad
parameter_list|,
name|BasicBlock
modifier|*
name|UnwindBB
parameter_list|,
name|unsigned
name|NumHandlers
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|CatchSwitchInst
operator|::
name|Create
argument_list|(
name|ParentPad
argument_list|,
name|UnwindBB
argument_list|,
name|NumHandlers
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|CatchPadInst
modifier|*
name|CreateCatchPad
argument_list|(
name|Value
operator|*
name|ParentPad
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|Insert
argument_list|(
name|CatchPadInst
operator|::
name|Create
argument_list|(
name|ParentPad
argument_list|,
name|Args
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|CleanupPadInst
modifier|*
name|CreateCleanupPad
argument_list|(
name|Value
operator|*
name|ParentPad
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
operator|=
name|None
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|Insert
argument_list|(
name|CleanupPadInst
operator|::
name|Create
argument_list|(
name|ParentPad
argument_list|,
name|Args
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|CatchReturnInst
modifier|*
name|CreateCatchRet
parameter_list|(
name|CatchPadInst
modifier|*
name|CatchPad
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|CatchReturnInst
operator|::
name|Create
argument_list|(
name|CatchPad
argument_list|,
name|BB
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|UnreachableInst
modifier|*
name|CreateUnreachable
parameter_list|()
block|{
return|return
name|Insert
argument_list|(
argument|new UnreachableInst(Context)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Instruction creation methods: Binary Operators
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|BinaryOperator
modifier|*
name|CreateInsertNUWNSWBinOp
argument_list|(
name|BinaryOperator
operator|::
name|BinaryOps
name|Opc
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
argument_list|,
name|bool
name|HasNUW
argument_list|,
name|bool
name|HasNSW
argument_list|)
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|Create
argument_list|(
name|Opc
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Instruction
modifier|*
name|AddFPMathAttributes
argument_list|(
name|Instruction
operator|*
name|I
argument_list|,
name|MDNode
operator|*
name|FPMathTag
argument_list|,
name|FastMathFlags
name|FMF
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|FPMathTag
condition|)
name|FPMathTag
operator|=
name|DefaultFPMathTag
expr_stmt|;
if|if
condition|(
name|FPMathTag
condition|)
name|I
operator|->
name|setMetadata
argument_list|(
name|LLVMContext
operator|::
name|MD_fpmath
argument_list|,
name|FPMathTag
argument_list|)
expr_stmt|;
name|I
operator|->
name|setFastMathFlags
argument_list|(
name|FMF
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_function
name|Value
modifier|*
name|CreateAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateAdd
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|CreateInsertNUWNSWBinOp
argument_list|(
name|Instruction
operator|::
name|Add
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNSWAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNUWAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFAdd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFAdd
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateSub
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|CreateInsertNUWNSWBinOp
argument_list|(
name|Instruction
operator|::
name|Sub
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNSWSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNUWSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFSub
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFSub
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateMul
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|CreateInsertNUWNSWBinOp
argument_list|(
name|Instruction
operator|::
name|Mul
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNSWMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNUWMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFMul
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFMul
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateUDiv
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateUDiv
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|isExact
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateExactUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateExactUDiv
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSDiv
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateSDiv
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|isExact
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateExactSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateExactSDiv
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFDiv
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFDiv
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateURem
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateURem
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateURem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSRem
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateSRem
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateSRem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFRem
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFRem
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFRem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateShl
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateShl
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|CreateInsertNUWNSWBinOp
argument_list|(
name|Instruction
operator|::
name|Shl
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateShl
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateShl
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateShl
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateShl
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateLShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateLShr
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|isExact
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateLShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateExactLShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateLShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateLShr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|isExact
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateLShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateLShr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|isExact
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateAShr
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|,
name|isExact
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateAShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateExactAShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateAShr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|isExact
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAShr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|isExact
init|=
name|false
parameter_list|)
block|{
return|return
name|CreateAShr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|,
name|isExact
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
block|{
if|if
condition|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|RC
operator|)
operator|&&
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|RC
operator|)
operator|->
name|isMinusOne
argument_list|()
condition|)
return|return
name|LHS
return|;
comment|// LHS& -1 -> LHS
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateAnd
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateAnd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateAnd
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAnd
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateAnd
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateOr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
block|{
if|if
condition|(
name|RC
operator|->
name|isNullValue
argument_list|()
condition|)
return|return
name|LHS
return|;
comment|// LHS | 0 -> LHS
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateOr
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateOr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateOr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateOr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateOr
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateOr
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateXor
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateXor
argument_list|(
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateXor
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateXor
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
specifier|const
name|APInt
modifier|&
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateXor
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateXor
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|uint64_t
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateXor
argument_list|(
name|LHS
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
argument_list|,
name|RHS
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|Value
modifier|*
name|CreateBinOp
argument_list|(
name|Instruction
operator|::
name|BinaryOps
name|Opc
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateBinOp
argument_list|(
name|Opc
argument_list|,
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
name|Instruction
modifier|*
name|BinOp
init|=
name|BinaryOperator
operator|::
name|Create
argument_list|(
name|Opc
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|isa
operator|<
name|FPMathOperator
operator|>
operator|(
name|BinOp
operator|)
condition|)
name|BinOp
operator|=
name|AddFPMathAttributes
argument_list|(
name|BinOp
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
expr_stmt|;
return|return
name|Insert
argument_list|(
name|BinOp
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|Value
modifier|*
name|CreateNeg
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|bool
name|HasNUW
init|=
name|false
parameter_list|,
name|bool
name|HasNSW
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateNeg
argument_list|(
name|VC
argument_list|,
name|HasNUW
argument_list|,
name|HasNSW
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
name|BinaryOperator
modifier|*
name|BO
init|=
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateNeg
argument_list|(
name|V
argument_list|)
argument_list|,
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNSWNeg
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateNeg
argument_list|(
name|V
argument_list|,
name|Name
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNUWNeg
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateNeg
argument_list|(
name|V
argument_list|,
name|Name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFNeg
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFNeg
argument_list|(
name|VC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
name|BinaryOperator
operator|::
name|CreateFNeg
argument_list|(
name|V
argument_list|)
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateNot
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateNot
argument_list|(
name|VC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|BinaryOperator
operator|::
name|CreateNot
argument_list|(
name|V
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Instruction creation methods: Memory Instructions
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_function
name|AllocaInst
modifier|*
name|CreateAlloca
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|,
name|Value
modifier|*
name|ArraySize
init|=
name|nullptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new AllocaInst(Ty, AddrSpace, ArraySize)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|AllocaInst
modifier|*
name|CreateAlloca
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|ArraySize
init|=
name|nullptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
specifier|const
name|DataLayout
modifier|&
name|DL
init|=
name|BB
operator|->
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
operator|->
name|getDataLayout
argument_list|()
decl_stmt|;
return|return
name|Insert
argument_list|(
argument|new AllocaInst(Ty, DL.getAllocaAddrSpace(), ArraySize)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// \brief Provided to resolve 'CreateLoad(Ptr, "...")' correctly, instead of
end_comment

begin_comment
comment|// converting the string to 'bool' for the isVolatile parameter.
end_comment

begin_function
name|LoadInst
modifier|*
name|CreateLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|Name
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new LoadInst(Ptr)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|LoadInst
modifier|*
name|CreateLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new LoadInst(Ptr)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|LoadInst
modifier|*
name|CreateLoad
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new LoadInst(Ty, Ptr)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|LoadInst
modifier|*
name|CreateLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|bool
name|isVolatile
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new LoadInst(Ptr, nullptr, isVolatile)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|StoreInst
modifier|*
name|CreateStore
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new StoreInst(Val, Ptr, isVolatile)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// \brief Provided to resolve 'CreateAlignedLoad(Ptr, Align, "...")'
end_comment

begin_comment
comment|// correctly, instead of converting the string to 'bool' for the isVolatile
end_comment

begin_comment
comment|// parameter.
end_comment

begin_function
name|LoadInst
modifier|*
name|CreateAlignedLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
specifier|const
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|LoadInst
modifier|*
name|LI
init|=
name|CreateLoad
argument_list|(
name|Ptr
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|LI
operator|->
name|setAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
return|return
name|LI
return|;
block|}
end_function

begin_function
name|LoadInst
modifier|*
name|CreateAlignedLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|LoadInst
modifier|*
name|LI
init|=
name|CreateLoad
argument_list|(
name|Ptr
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|LI
operator|->
name|setAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
return|return
name|LI
return|;
block|}
end_function

begin_function
name|LoadInst
modifier|*
name|CreateAlignedLoad
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|LoadInst
modifier|*
name|LI
init|=
name|CreateLoad
argument_list|(
name|Ptr
argument_list|,
name|isVolatile
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|LI
operator|->
name|setAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
return|return
name|LI
return|;
block|}
end_function

begin_function
name|StoreInst
modifier|*
name|CreateAlignedStore
parameter_list|(
name|Value
modifier|*
name|Val
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|)
block|{
name|StoreInst
modifier|*
name|SI
init|=
name|CreateStore
argument_list|(
name|Val
argument_list|,
name|Ptr
argument_list|,
name|isVolatile
argument_list|)
decl_stmt|;
name|SI
operator|->
name|setAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
return|return
name|SI
return|;
block|}
end_function

begin_decl_stmt
name|FenceInst
modifier|*
name|CreateFence
argument_list|(
name|AtomicOrdering
name|Ordering
argument_list|,
name|SyncScope
operator|::
name|ID
name|SSID
operator|=
name|SyncScope
operator|::
name|System
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new FenceInst(Context, Ordering, SSID)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|AtomicCmpXchgInst
modifier|*
name|CreateAtomicCmpXchg
argument_list|(
name|Value
operator|*
name|Ptr
argument_list|,
name|Value
operator|*
name|Cmp
argument_list|,
name|Value
operator|*
name|New
argument_list|,
name|AtomicOrdering
name|SuccessOrdering
argument_list|,
name|AtomicOrdering
name|FailureOrdering
argument_list|,
name|SyncScope
operator|::
name|ID
name|SSID
operator|=
name|SyncScope
operator|::
name|System
argument_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new AtomicCmpXchgInst(Ptr, Cmp, New, SuccessOrdering,                                         FailureOrdering, SSID)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|AtomicRMWInst
modifier|*
name|CreateAtomicRMW
argument_list|(
name|AtomicRMWInst
operator|::
name|BinOp
name|Op
argument_list|,
name|Value
operator|*
name|Ptr
argument_list|,
name|Value
operator|*
name|Val
argument_list|,
name|AtomicOrdering
name|Ordering
argument_list|,
name|SyncScope
operator|::
name|ID
name|SSID
operator|=
name|SyncScope
operator|::
name|System
argument_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new AtomicRMWInst(Op, Ptr, Val, Ordering, SSID)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateGEP
argument_list|(
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|CreateGEP
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|IdxList
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateGEP
argument_list|(
name|Type
operator|*
name|Ty
argument_list|,
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
block|{
comment|// Every index must be constant.
name|size_t
name|i
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|e
operator|=
name|IdxList
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|IdxList
index|[
name|i
index|]
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|e
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|IdxList
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|IdxList
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateInBoundsGEP
argument_list|(
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
return|return
name|CreateInBoundsGEP
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|IdxList
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateInBoundsGEP
argument_list|(
name|Type
operator|*
name|Ty
argument_list|,
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
block|{
comment|// Every index must be constant.
name|size_t
name|i
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|e
operator|=
name|IdxList
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|IdxList
index|[
name|i
index|]
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|e
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|IdxList
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|IdxList
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|Value
modifier|*
name|CreateGEP
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|Value
modifier|*
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateGEP
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateGEP
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|Value
modifier|*
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|IC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Idx
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|IC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateInBoundsGEP
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|Value
modifier|*
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|IC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Idx
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|IC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstGEP1_32
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx0
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateConstGEP1_32
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idx0
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstGEP1_32
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx0
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idx
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstInBoundsGEP1_32
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx0
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idx
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstGEP2_32
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx0
parameter_list|,
name|unsigned
name|Idx1
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idxs
index|[]
init|=
block|{
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
block|,
name|ConstantInt
operator|::
name|get
argument_list|(
argument|Type::getInt32Ty(Context)
argument_list|,
argument|Idx1
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstInBoundsGEP2_32
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx0
parameter_list|,
name|unsigned
name|Idx1
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idxs
index|[]
init|=
block|{
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
block|,
name|ConstantInt
operator|::
name|get
argument_list|(
argument|Type::getInt32Ty(Context)
argument_list|,
argument|Idx1
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|Ty
argument_list|,
name|PC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstGEP1_64
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|uint64_t
name|Idx0
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idx
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|nullptr
argument_list|,
name|PC
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstInBoundsGEP1_64
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|uint64_t
name|Idx0
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idx
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|nullptr
argument_list|,
name|PC
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstGEP2_64
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|uint64_t
name|Idx0
parameter_list|,
name|uint64_t
name|Idx1
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idxs
index|[]
init|=
block|{
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
block|,
name|ConstantInt
operator|::
name|get
argument_list|(
argument|Type::getInt64Ty(Context)
argument_list|,
argument|Idx1
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateGetElementPtr
argument_list|(
name|nullptr
argument_list|,
name|PC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateConstInBoundsGEP2_64
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|,
name|uint64_t
name|Idx0
parameter_list|,
name|uint64_t
name|Idx1
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|Value
modifier|*
name|Idxs
index|[]
init|=
block|{
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
name|Idx0
argument_list|)
block|,
name|ConstantInt
operator|::
name|get
argument_list|(
argument|Type::getInt64Ty(Context)
argument_list|,
argument|Idx1
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|Constant
modifier|*
name|PC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Ptr
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInBoundsGetElementPtr
argument_list|(
name|nullptr
argument_list|,
name|PC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|nullptr
argument_list|,
name|Ptr
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateStructGEP
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateConstInBoundsGEP2_32
argument_list|(
name|Ty
argument_list|,
name|Ptr
argument_list|,
literal|0
argument_list|,
name|Idx
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Same as CreateGlobalString, but return a pointer with "i8*" type
end_comment

begin_comment
comment|/// instead of a pointer to array of i8.
end_comment

begin_function
name|Value
modifier|*
name|CreateGlobalStringPtr
parameter_list|(
name|StringRef
name|Str
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|unsigned
name|AddressSpace
init|=
literal|0
parameter_list|)
block|{
name|GlobalVariable
modifier|*
name|gv
init|=
name|CreateGlobalString
argument_list|(
name|Str
argument_list|,
name|Name
argument_list|,
name|AddressSpace
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|zero
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Type
operator|::
name|getInt32Ty
argument_list|(
name|Context
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|Args
index|[]
init|=
block|{
name|zero
block|,
name|zero
block|}
decl_stmt|;
return|return
name|CreateInBoundsGEP
argument_list|(
name|gv
operator|->
name|getValueType
argument_list|()
argument_list|,
name|gv
argument_list|,
name|Args
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Instruction creation methods: Cast/Conversion Operators
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_function
name|Value
modifier|*
name|CreateTrunc
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|Trunc
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateZExt
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|ZExt
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSExt
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|SExt
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a ZExt or Trunc from the integer value V to DestTy. Return
end_comment

begin_comment
comment|/// the value untouched if the type of V is already DestTy.
end_comment

begin_function
name|Value
modifier|*
name|CreateZExtOrTrunc
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|assert
argument_list|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isIntOrIntVectorTy
argument_list|()
operator|&&
name|DestTy
operator|->
name|isIntOrIntVectorTy
argument_list|()
operator|&&
literal|"Can only zero extend/truncate integers!"
argument_list|)
expr_stmt|;
name|Type
modifier|*
name|VTy
init|=
name|V
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|VTy
operator|->
name|getScalarSizeInBits
argument_list|()
operator|<
name|DestTy
operator|->
name|getScalarSizeInBits
argument_list|()
condition|)
return|return
name|CreateZExt
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
name|VTy
operator|->
name|getScalarSizeInBits
argument_list|()
operator|>
name|DestTy
operator|->
name|getScalarSizeInBits
argument_list|()
condition|)
return|return
name|CreateTrunc
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|V
return|;
block|}
end_function

begin_comment
comment|/// \brief Create a SExt or Trunc from the integer value V to DestTy. Return
end_comment

begin_comment
comment|/// the value untouched if the type of V is already DestTy.
end_comment

begin_function
name|Value
modifier|*
name|CreateSExtOrTrunc
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|assert
argument_list|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isIntOrIntVectorTy
argument_list|()
operator|&&
name|DestTy
operator|->
name|isIntOrIntVectorTy
argument_list|()
operator|&&
literal|"Can only sign extend/truncate integers!"
argument_list|)
expr_stmt|;
name|Type
modifier|*
name|VTy
init|=
name|V
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|VTy
operator|->
name|getScalarSizeInBits
argument_list|()
operator|<
name|DestTy
operator|->
name|getScalarSizeInBits
argument_list|()
condition|)
return|return
name|CreateSExt
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
name|VTy
operator|->
name|getScalarSizeInBits
argument_list|()
operator|>
name|DestTy
operator|->
name|getScalarSizeInBits
argument_list|()
condition|)
return|return
name|CreateTrunc
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|V
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFPToUI
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|FPToUI
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFPToSI
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|FPToSI
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateUIToFP
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|UIToFP
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSIToFP
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|SIToFP
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFPTrunc
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|FPTrunc
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFPExt
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|FPExt
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreatePtrToInt
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|PtrToInt
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateIntToPtr
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|IntToPtr
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateBitCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|BitCast
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateAddrSpaceCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|AddrSpaceCast
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateZExtOrBitCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateZExtOrBitCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreateZExtOrBitCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateSExtOrBitCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateSExtOrBitCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreateSExtOrBitCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateTruncOrBitCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateTruncOrBitCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreateTruncOrBitCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|Value
modifier|*
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|CastOps
name|Op
argument_list|,
name|Value
operator|*
name|V
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateCast
argument_list|(
name|Op
argument_list|,
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|Create
argument_list|(
name|Op
argument_list|,
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|Value
modifier|*
name|CreatePointerCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreatePointerCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreatePointerCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreatePointerBitCastOrAddrSpaceCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
block|{
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreatePointerBitCastOrAddrSpaceCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreatePointerBitCastOrAddrSpaceCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateIntCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
name|bool
name|isSigned
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateIntCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|,
name|isSigned
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreateIntegerCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|isSigned
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateBitOrPointerCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isPtrOrPtrVectorTy
argument_list|()
operator|&&
name|DestTy
operator|->
name|isIntOrIntVectorTy
argument_list|()
condition|)
return|return
name|CreatePtrToInt
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isIntOrIntVectorTy
argument_list|()
operator|&&
name|DestTy
operator|->
name|isPtrOrPtrVectorTy
argument_list|()
condition|)
return|return
name|CreateIntToPtr
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|CreateBitCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|Value
modifier|*
name|CreateFPCast
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|Type
modifier|*
name|DestTy
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|==
name|DestTy
condition|)
return|return
name|V
return|;
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFPCast
argument_list|(
name|VC
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|CastInst
operator|::
name|CreateFPCast
argument_list|(
name|V
argument_list|,
name|DestTy
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// \brief Provided to resolve 'CreateIntCast(Ptr, Ptr, "...")', giving a
end_comment

begin_comment
comment|// compile time error, instead of converting the string to bool for the
end_comment

begin_comment
comment|// isSigned parameter.
end_comment

begin_function_decl
name|Value
modifier|*
name|CreateIntCast
parameter_list|(
name|Value
modifier|*
parameter_list|,
name|Type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
init|=
name|delete
function_decl|;
end_function_decl

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Instruction creation methods: Compare Instructions
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_function
name|Value
modifier|*
name|CreateICmpEQ
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_EQ
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpNE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_NE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpUGT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_UGT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpUGE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_UGE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpULT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_ULT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpULE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_ULE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpSGT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_SGT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpSGE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_SGE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpSLT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_SLT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateICmpSLE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmp
argument_list|(
name|ICmpInst
operator|::
name|ICMP_SLE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpOEQ
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_OEQ
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpOGT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_OGT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpOGE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_OGE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpOLT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_OLT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpOLE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_OLE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpONE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_ONE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpORD
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_ORD
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpUNO
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_UNO
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpUEQ
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_UEQ
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpUGT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_UGT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpUGE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_UGE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpULT
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_ULT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpULE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_ULE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateFCmpUNE
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|MDNode
modifier|*
name|FPMathTag
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|CreateFCmp
argument_list|(
name|FCmpInst
operator|::
name|FCMP_UNE
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|Value
modifier|*
name|CreateICmp
argument_list|(
name|CmpInst
operator|::
name|Predicate
name|P
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateICmp
argument_list|(
name|P
argument_list|,
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
argument|new ICmpInst(P, LHS, RHS)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateFCmp
argument_list|(
name|CmpInst
operator|::
name|Predicate
name|P
argument_list|,
name|Value
operator|*
name|LHS
argument_list|,
name|Value
operator|*
name|RHS
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|LC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|LHS
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|RC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateFCmp
argument_list|(
name|P
argument_list|,
name|LC
argument_list|,
name|RC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|AddFPMathAttributes
argument_list|(
argument|new FCmpInst(P, LHS, RHS)
argument_list|,
argument|FPMathTag
argument_list|,
argument|FMF
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Instruction creation methods: Other Instructions
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_function
name|PHINode
modifier|*
name|CreatePHI
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|unsigned
name|NumReservedValues
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|PHINode
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|NumReservedValues
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|CallInst
modifier|*
name|CreateCall
argument_list|(
name|Value
operator|*
name|Callee
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
operator|=
name|None
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
name|PointerType
modifier|*
name|PTy
init|=
name|cast
operator|<
name|PointerType
operator|>
operator|(
name|Callee
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|FunctionType
modifier|*
name|FTy
init|=
name|cast
operator|<
name|FunctionType
operator|>
operator|(
name|PTy
operator|->
name|getElementType
argument_list|()
operator|)
decl_stmt|;
return|return
name|CreateCall
argument_list|(
name|FTy
argument_list|,
name|Callee
argument_list|,
name|Args
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|CallInst
modifier|*
name|CreateCall
argument_list|(
name|FunctionType
operator|*
name|FTy
argument_list|,
name|Value
operator|*
name|Callee
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
name|CallInst
modifier|*
name|CI
init|=
name|CallInst
operator|::
name|Create
argument_list|(
name|FTy
argument_list|,
name|Callee
argument_list|,
name|Args
argument_list|,
name|DefaultOperandBundles
argument_list|)
decl_stmt|;
if|if
condition|(
name|isa
operator|<
name|FPMathOperator
operator|>
operator|(
name|CI
operator|)
condition|)
name|CI
operator|=
name|cast
operator|<
name|CallInst
operator|>
operator|(
name|AddFPMathAttributes
argument_list|(
name|CI
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
operator|)
expr_stmt|;
return|return
name|Insert
argument_list|(
name|CI
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|CallInst
modifier|*
name|CreateCall
argument_list|(
name|Value
operator|*
name|Callee
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|ArrayRef
operator|<
name|OperandBundleDef
operator|>
name|OpBundles
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
name|CallInst
modifier|*
name|CI
init|=
name|CallInst
operator|::
name|Create
argument_list|(
name|Callee
argument_list|,
name|Args
argument_list|,
name|OpBundles
argument_list|)
decl_stmt|;
if|if
condition|(
name|isa
operator|<
name|FPMathOperator
operator|>
operator|(
name|CI
operator|)
condition|)
name|CI
operator|=
name|cast
operator|<
name|CallInst
operator|>
operator|(
name|AddFPMathAttributes
argument_list|(
name|CI
argument_list|,
name|FPMathTag
argument_list|,
name|FMF
argument_list|)
operator|)
expr_stmt|;
return|return
name|Insert
argument_list|(
name|CI
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|CallInst
modifier|*
name|CreateCall
argument_list|(
name|Function
operator|*
name|Callee
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|,
name|MDNode
operator|*
name|FPMathTag
operator|=
name|nullptr
argument_list|)
block|{
return|return
name|CreateCall
argument_list|(
name|Callee
operator|->
name|getFunctionType
argument_list|()
argument_list|,
name|Callee
argument_list|,
name|Args
argument_list|,
name|Name
argument_list|,
name|FPMathTag
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|Value
modifier|*
name|CreateSelect
parameter_list|(
name|Value
modifier|*
name|C
parameter_list|,
name|Value
modifier|*
name|True
parameter_list|,
name|Value
modifier|*
name|False
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|,
name|Instruction
modifier|*
name|MDFrom
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|CC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|C
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|TC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|True
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|FC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|False
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateSelect
argument_list|(
name|CC
argument_list|,
name|TC
argument_list|,
name|FC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
name|SelectInst
modifier|*
name|Sel
init|=
name|SelectInst
operator|::
name|Create
argument_list|(
name|C
argument_list|,
name|True
argument_list|,
name|False
argument_list|)
decl_stmt|;
if|if
condition|(
name|MDFrom
condition|)
block|{
name|MDNode
modifier|*
name|Prof
init|=
name|MDFrom
operator|->
name|getMetadata
argument_list|(
name|LLVMContext
operator|::
name|MD_prof
argument_list|)
decl_stmt|;
name|MDNode
modifier|*
name|Unpred
init|=
name|MDFrom
operator|->
name|getMetadata
argument_list|(
name|LLVMContext
operator|::
name|MD_unpredictable
argument_list|)
decl_stmt|;
name|Sel
operator|=
name|addBranchMetadata
argument_list|(
name|Sel
argument_list|,
name|Prof
argument_list|,
name|Unpred
argument_list|)
expr_stmt|;
block|}
return|return
name|Insert
argument_list|(
name|Sel
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|VAArgInst
modifier|*
name|CreateVAArg
parameter_list|(
name|Value
modifier|*
name|List
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
argument|new VAArgInst(List, Ty)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateExtractElement
parameter_list|(
name|Value
modifier|*
name|Vec
parameter_list|,
name|Value
modifier|*
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Vec
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|IC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Idx
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateExtractElement
argument_list|(
name|VC
argument_list|,
name|IC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|ExtractElementInst
operator|::
name|Create
argument_list|(
name|Vec
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateExtractElement
parameter_list|(
name|Value
modifier|*
name|Vec
parameter_list|,
name|uint64_t
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateExtractElement
argument_list|(
name|Vec
argument_list|,
name|getInt64
argument_list|(
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateInsertElement
parameter_list|(
name|Value
modifier|*
name|Vec
parameter_list|,
name|Value
modifier|*
name|NewElt
parameter_list|,
name|Value
modifier|*
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|VC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Vec
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|NC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|NewElt
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|IC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Idx
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInsertElement
argument_list|(
name|VC
argument_list|,
name|NC
argument_list|,
name|IC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|InsertElementInst
operator|::
name|Create
argument_list|(
name|Vec
argument_list|,
name|NewElt
argument_list|,
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateInsertElement
parameter_list|(
name|Value
modifier|*
name|Vec
parameter_list|,
name|Value
modifier|*
name|NewElt
parameter_list|,
name|uint64_t
name|Idx
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateInsertElement
argument_list|(
name|Vec
argument_list|,
name|NewElt
argument_list|,
name|getInt64
argument_list|(
name|Idx
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_function
name|Value
modifier|*
name|CreateShuffleVector
parameter_list|(
name|Value
modifier|*
name|V1
parameter_list|,
name|Value
modifier|*
name|V2
parameter_list|,
name|Value
modifier|*
name|Mask
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|V1C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V1
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|V2C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V2
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|MC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Mask
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateShuffleVector
argument_list|(
name|V1C
argument_list|,
name|V2C
argument_list|,
name|MC
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
argument|new ShuffleVectorInst(V1, V2, Mask)
argument_list|,
argument|Name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|Value
modifier|*
name|CreateShuffleVector
argument_list|(
name|Value
operator|*
name|V1
argument_list|,
name|Value
operator|*
name|V2
argument_list|,
name|ArrayRef
operator|<
name|uint32_t
operator|>
name|IntMask
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
name|Value
modifier|*
name|Mask
init|=
name|ConstantDataVector
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|IntMask
argument_list|)
decl_stmt|;
return|return
name|CreateShuffleVector
argument_list|(
name|V1
argument_list|,
name|V2
argument_list|,
name|Mask
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateExtractValue
argument_list|(
name|Value
operator|*
name|Agg
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Idxs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|AggC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Agg
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateExtractValue
argument_list|(
name|AggC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|ExtractValueInst
operator|::
name|Create
argument_list|(
name|Agg
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Value
modifier|*
name|CreateInsertValue
argument_list|(
name|Value
operator|*
name|Agg
argument_list|,
name|Value
operator|*
name|Val
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Idxs
argument_list|,
specifier|const
name|Twine
operator|&
name|Name
operator|=
literal|""
argument_list|)
block|{
if|if
condition|(
name|Constant
modifier|*
name|AggC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Agg
operator|)
condition|)
if|if
condition|(
name|Constant
modifier|*
name|ValC
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|Val
operator|)
condition|)
return|return
name|Insert
argument_list|(
name|Folder
operator|.
name|CreateInsertValue
argument_list|(
name|AggC
argument_list|,
name|ValC
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
return|return
name|Insert
argument_list|(
name|InsertValueInst
operator|::
name|Create
argument_list|(
name|Agg
argument_list|,
name|Val
argument_list|,
name|Idxs
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|LandingPadInst
modifier|*
name|CreateLandingPad
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|unsigned
name|NumClauses
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|Insert
argument_list|(
name|LandingPadInst
operator|::
name|Create
argument_list|(
name|Ty
argument_list|,
name|NumClauses
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Utility creation methods
end_comment

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief Return an i1 value testing if \p Arg is null.
end_comment

begin_function
name|Value
modifier|*
name|CreateIsNull
parameter_list|(
name|Value
modifier|*
name|Arg
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmpEQ
argument_list|(
name|Arg
argument_list|,
name|Constant
operator|::
name|getNullValue
argument_list|(
name|Arg
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Return an i1 value testing if \p Arg is not null.
end_comment

begin_function
name|Value
modifier|*
name|CreateIsNotNull
parameter_list|(
name|Value
modifier|*
name|Arg
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
return|return
name|CreateICmpNE
argument_list|(
name|Arg
argument_list|,
name|Constant
operator|::
name|getNullValue
argument_list|(
name|Arg
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Return the i64 difference between two pointer values, dividing out
end_comment

begin_comment
comment|/// the size of the pointed-to objects.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is intended to implement C-style pointer subtraction. As such, the
end_comment

begin_comment
comment|/// pointers must be appropriately aligned for their element types and
end_comment

begin_comment
comment|/// pointing into the same object.
end_comment

begin_function
name|Value
modifier|*
name|CreatePtrDiff
parameter_list|(
name|Value
modifier|*
name|LHS
parameter_list|,
name|Value
modifier|*
name|RHS
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
init|=
literal|""
parameter_list|)
block|{
name|assert
argument_list|(
name|LHS
operator|->
name|getType
argument_list|()
operator|==
name|RHS
operator|->
name|getType
argument_list|()
operator|&&
literal|"Pointer subtraction operand types must match!"
argument_list|)
expr_stmt|;
name|PointerType
modifier|*
name|ArgType
init|=
name|cast
operator|<
name|PointerType
operator|>
operator|(
name|LHS
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Value
modifier|*
name|LHS_int
init|=
name|CreatePtrToInt
argument_list|(
name|LHS
argument_list|,
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|RHS_int
init|=
name|CreatePtrToInt
argument_list|(
name|RHS
argument_list|,
name|Type
operator|::
name|getInt64Ty
argument_list|(
name|Context
argument_list|)
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|Difference
init|=
name|CreateSub
argument_list|(
name|LHS_int
argument_list|,
name|RHS_int
argument_list|)
decl_stmt|;
return|return
name|CreateExactSDiv
argument_list|(
name|Difference
argument_list|,
name|ConstantExpr
operator|::
name|getSizeOf
argument_list|(
name|ArgType
operator|->
name|getElementType
argument_list|()
argument_list|)
argument_list|,
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Create an invariant.group.barrier intrinsic call, that stops
end_comment

begin_comment
comment|/// optimizer to propagate equality using invariant.group metadata.
end_comment

begin_comment
comment|/// If Ptr type is different from i8*, it's casted to i8* before call
end_comment

begin_comment
comment|/// and casted back to Ptr type after call.
end_comment

begin_function
name|Value
modifier|*
name|CreateInvariantGroupBarrier
parameter_list|(
name|Value
modifier|*
name|Ptr
parameter_list|)
block|{
name|Module
modifier|*
name|M
init|=
name|BB
operator|->
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|Function
modifier|*
name|FnInvariantGroupBarrier
init|=
name|Intrinsic
operator|::
name|getDeclaration
argument_list|(
name|M
argument_list|,
name|Intrinsic
operator|::
name|invariant_group_barrier
argument_list|)
decl_stmt|;
name|Type
modifier|*
name|ArgumentAndReturnType
init|=
name|FnInvariantGroupBarrier
operator|->
name|getReturnType
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|ArgumentAndReturnType
operator|==
name|FnInvariantGroupBarrier
operator|->
name|getFunctionType
argument_list|()
operator|->
name|getParamType
argument_list|(
literal|0
argument_list|)
operator|&&
literal|"InvariantGroupBarrier should take and return the same type"
argument_list|)
expr_stmt|;
name|Type
modifier|*
name|PtrType
init|=
name|Ptr
operator|->
name|getType
argument_list|()
decl_stmt|;
name|bool
name|PtrTypeConversionNeeded
init|=
name|PtrType
operator|!=
name|ArgumentAndReturnType
decl_stmt|;
if|if
condition|(
name|PtrTypeConversionNeeded
condition|)
name|Ptr
operator|=
name|CreateBitCast
argument_list|(
name|Ptr
argument_list|,
name|ArgumentAndReturnType
argument_list|)
expr_stmt|;
name|CallInst
modifier|*
name|Fn
init|=
name|CreateCall
argument_list|(
name|FnInvariantGroupBarrier
argument_list|,
block|{
name|Ptr
block|}
block|)
function|;
end_function

begin_if
if|if
condition|(
name|PtrTypeConversionNeeded
condition|)
return|return
name|CreateBitCast
argument_list|(
name|Fn
argument_list|,
name|PtrType
argument_list|)
return|;
end_if

begin_return
return|return
name|Fn
return|;
end_return

begin_comment
unit|}
comment|/// \brief Return a vector value that contains \arg V broadcasted to \p
end_comment

begin_comment
comment|/// NumElts elements.
end_comment

begin_expr_stmt
unit|Value
operator|*
name|CreateVectorSplat
argument_list|(
argument|unsigned NumElts
argument_list|,
argument|Value *V
argument_list|,
argument|const Twine&Name =
literal|""
argument_list|)
block|{
name|assert
argument_list|(
name|NumElts
operator|>
literal|0
operator|&&
literal|"Cannot splat to an empty vector!"
argument_list|)
block|;
comment|// First insert it into an undef vector so we can shuffle it.
name|Type
operator|*
name|I32Ty
operator|=
name|getInt32Ty
argument_list|()
block|;
name|Value
operator|*
name|Undef
operator|=
name|UndefValue
operator|::
name|get
argument_list|(
name|VectorType
operator|::
name|get
argument_list|(
name|V
operator|->
name|getType
argument_list|()
argument_list|,
name|NumElts
argument_list|)
argument_list|)
block|;
name|V
operator|=
name|CreateInsertElement
argument_list|(
name|Undef
argument_list|,
name|V
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|I32Ty
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Name
operator|+
literal|".splatinsert"
argument_list|)
block|;
comment|// Shuffle the value across the desired number of elements.
name|Value
operator|*
name|Zeros
operator|=
name|ConstantAggregateZero
operator|::
name|get
argument_list|(
name|VectorType
operator|::
name|get
argument_list|(
name|I32Ty
argument_list|,
name|NumElts
argument_list|)
argument_list|)
block|;
return|return
name|CreateShuffleVector
argument_list|(
name|V
argument_list|,
name|Undef
argument_list|,
name|Zeros
argument_list|,
name|Name
operator|+
literal|".splat"
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return a value that has been extracted from a larger integer type.
end_comment

begin_function
name|Value
modifier|*
name|CreateExtractInteger
parameter_list|(
specifier|const
name|DataLayout
modifier|&
name|DL
parameter_list|,
name|Value
modifier|*
name|From
parameter_list|,
name|IntegerType
modifier|*
name|ExtractedTy
parameter_list|,
name|uint64_t
name|Offset
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Name
parameter_list|)
block|{
name|IntegerType
modifier|*
name|IntTy
init|=
name|cast
operator|<
name|IntegerType
operator|>
operator|(
name|From
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|assert
argument_list|(
name|DL
operator|.
name|getTypeStoreSize
argument_list|(
name|ExtractedTy
argument_list|)
operator|+
name|Offset
operator|<=
name|DL
operator|.
name|getTypeStoreSize
argument_list|(
name|IntTy
argument_list|)
operator|&&
literal|"Element extends past full value"
argument_list|)
expr_stmt|;
name|uint64_t
name|ShAmt
init|=
literal|8
operator|*
name|Offset
decl_stmt|;
name|Value
modifier|*
name|V
init|=
name|From
decl_stmt|;
if|if
condition|(
name|DL
operator|.
name|isBigEndian
argument_list|()
condition|)
name|ShAmt
operator|=
literal|8
operator|*
operator|(
name|DL
operator|.
name|getTypeStoreSize
argument_list|(
name|IntTy
argument_list|)
operator|-
name|DL
operator|.
name|getTypeStoreSize
argument_list|(
name|ExtractedTy
argument_list|)
operator|-
name|Offset
operator|)
expr_stmt|;
if|if
condition|(
name|ShAmt
condition|)
block|{
name|V
operator|=
name|CreateLShr
argument_list|(
name|V
argument_list|,
name|ShAmt
argument_list|,
name|Name
operator|+
literal|".shift"
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ExtractedTy
operator|->
name|getBitWidth
argument_list|()
operator|<=
name|IntTy
operator|->
name|getBitWidth
argument_list|()
operator|&&
literal|"Cannot extract to a larger integer!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ExtractedTy
operator|!=
name|IntTy
condition|)
block|{
name|V
operator|=
name|CreateTrunc
argument_list|(
name|V
argument_list|,
name|ExtractedTy
argument_list|,
name|Name
operator|+
literal|".trunc"
argument_list|)
expr_stmt|;
block|}
return|return
name|V
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|/// \brief Helper function that creates an assume intrinsic call that
end_comment

begin_comment
comment|/// represents an alignment assumption on the provided Ptr, Mask, Type
end_comment

begin_comment
comment|/// and Offset.
end_comment

begin_function
name|CallInst
modifier|*
name|CreateAlignmentAssumptionHelper
parameter_list|(
specifier|const
name|DataLayout
modifier|&
name|DL
parameter_list|,
name|Value
modifier|*
name|PtrValue
parameter_list|,
name|Value
modifier|*
name|Mask
parameter_list|,
name|Type
modifier|*
name|IntPtrTy
parameter_list|,
name|Value
modifier|*
name|OffsetValue
parameter_list|)
block|{
name|Value
modifier|*
name|PtrIntValue
init|=
name|CreatePtrToInt
argument_list|(
name|PtrValue
argument_list|,
name|IntPtrTy
argument_list|,
literal|"ptrint"
argument_list|)
decl_stmt|;
if|if
condition|(
name|OffsetValue
condition|)
block|{
name|bool
name|IsOffsetZero
init|=
name|false
decl_stmt|;
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|OffsetValue
operator|)
condition|)
name|IsOffsetZero
operator|=
name|CI
operator|->
name|isZero
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IsOffsetZero
condition|)
block|{
if|if
condition|(
name|OffsetValue
operator|->
name|getType
argument_list|()
operator|!=
name|IntPtrTy
condition|)
name|OffsetValue
operator|=
name|CreateIntCast
argument_list|(
name|OffsetValue
argument_list|,
name|IntPtrTy
argument_list|,
comment|/*isSigned*/
name|true
argument_list|,
literal|"offsetcast"
argument_list|)
expr_stmt|;
name|PtrIntValue
operator|=
name|CreateSub
argument_list|(
name|PtrIntValue
argument_list|,
name|OffsetValue
argument_list|,
literal|"offsetptr"
argument_list|)
expr_stmt|;
block|}
block|}
name|Value
modifier|*
name|Zero
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|IntPtrTy
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|MaskedPtr
init|=
name|CreateAnd
argument_list|(
name|PtrIntValue
argument_list|,
name|Mask
argument_list|,
literal|"maskedptr"
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|InvCond
init|=
name|CreateICmpEQ
argument_list|(
name|MaskedPtr
argument_list|,
name|Zero
argument_list|,
literal|"maskcond"
argument_list|)
decl_stmt|;
return|return
name|CreateAssumption
argument_list|(
name|InvCond
argument_list|)
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// \brief Create an assume intrinsic call that represents an alignment
end_comment

begin_comment
comment|/// assumption on the provided pointer.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// An optional offset can be provided, and if it is provided, the offset
end_comment

begin_comment
comment|/// must be subtracted from the provided pointer to get the pointer with the
end_comment

begin_comment
comment|/// specified alignment.
end_comment

begin_function
name|CallInst
modifier|*
name|CreateAlignmentAssumption
parameter_list|(
specifier|const
name|DataLayout
modifier|&
name|DL
parameter_list|,
name|Value
modifier|*
name|PtrValue
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|Value
modifier|*
name|OffsetValue
init|=
name|nullptr
parameter_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|PointerType
operator|>
operator|(
name|PtrValue
operator|->
name|getType
argument_list|()
operator|)
operator|&&
literal|"trying to create an alignment assumption on a non-pointer?"
argument_list|)
expr_stmt|;
name|PointerType
modifier|*
name|PtrTy
init|=
name|cast
operator|<
name|PointerType
operator|>
operator|(
name|PtrValue
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Type
modifier|*
name|IntPtrTy
init|=
name|getIntPtrTy
argument_list|(
name|DL
argument_list|,
name|PtrTy
operator|->
name|getAddressSpace
argument_list|()
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|Mask
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|IntPtrTy
argument_list|,
name|Alignment
operator|>
literal|0
condition|?
name|Alignment
operator|-
literal|1
else|:
literal|0
argument_list|)
decl_stmt|;
return|return
name|CreateAlignmentAssumptionHelper
argument_list|(
name|DL
argument_list|,
name|PtrValue
argument_list|,
name|Mask
argument_list|,
name|IntPtrTy
argument_list|,
name|OffsetValue
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|/// \brief Create an assume intrinsic call that represents an alignment
end_comment

begin_comment
comment|/// assumption on the provided pointer.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// An optional offset can be provided, and if it is provided, the offset
end_comment

begin_comment
comment|/// must be subtracted from the provided pointer to get the pointer with the
end_comment

begin_comment
comment|/// specified alignment.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This overload handles the condition where the Alignment is dependent
end_comment

begin_comment
comment|/// on an existing value rather than a static value.
end_comment

begin_function
name|CallInst
modifier|*
name|CreateAlignmentAssumption
parameter_list|(
specifier|const
name|DataLayout
modifier|&
name|DL
parameter_list|,
name|Value
modifier|*
name|PtrValue
parameter_list|,
name|Value
modifier|*
name|Alignment
parameter_list|,
name|Value
modifier|*
name|OffsetValue
init|=
name|nullptr
parameter_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|PointerType
operator|>
operator|(
name|PtrValue
operator|->
name|getType
argument_list|()
operator|)
operator|&&
literal|"trying to create an alignment assumption on a non-pointer?"
argument_list|)
expr_stmt|;
name|PointerType
modifier|*
name|PtrTy
init|=
name|cast
operator|<
name|PointerType
operator|>
operator|(
name|PtrValue
operator|->
name|getType
argument_list|()
operator|)
decl_stmt|;
name|Type
modifier|*
name|IntPtrTy
init|=
name|getIntPtrTy
argument_list|(
name|DL
argument_list|,
name|PtrTy
operator|->
name|getAddressSpace
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Alignment
operator|->
name|getType
argument_list|()
operator|!=
name|IntPtrTy
condition|)
name|Alignment
operator|=
name|CreateIntCast
argument_list|(
name|Alignment
argument_list|,
name|IntPtrTy
argument_list|,
comment|/*isSigned*/
name|true
argument_list|,
literal|"alignmentcast"
argument_list|)
expr_stmt|;
name|Value
modifier|*
name|IsPositive
init|=
name|CreateICmp
argument_list|(
name|CmpInst
operator|::
name|ICMP_SGT
argument_list|,
name|Alignment
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|Alignment
operator|->
name|getType
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"ispositive"
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|PositiveMask
init|=
name|CreateSub
argument_list|(
name|Alignment
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|IntPtrTy
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"positivemask"
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|Mask
init|=
name|CreateSelect
argument_list|(
name|IsPositive
argument_list|,
name|PositiveMask
argument_list|,
name|ConstantInt
operator|::
name|get
argument_list|(
name|IntPtrTy
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"mask"
argument_list|)
decl_stmt|;
return|return
name|CreateAlignmentAssumptionHelper
argument_list|(
name|DL
argument_list|,
name|PtrValue
argument_list|,
name|Mask
argument_list|,
name|IntPtrTy
argument_list|,
name|OffsetValue
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|// Create wrappers for C Binding types (see CBindingWrapping.h).
end_comment

begin_macro
name|DEFINE_SIMPLE_CONVERSION_FUNCTIONS
argument_list|(
argument|IRBuilder<>
argument_list|,
argument|LLVMBuilderRef
argument_list|)
end_macro

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_IR_IRBUILDER_H
end_comment

end_unit

