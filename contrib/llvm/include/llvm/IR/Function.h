begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Function.h - Class to represent a single function ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the declaration of the Function class, which represents a
end_comment

begin_comment
comment|// single function/procedure in LLVM.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A function basically consists of a list of basic blocks, a list of arguments,
end_comment

begin_comment
comment|// and a symbol table.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_FUNCTION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Argument.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Attributes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/BasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallingConv.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalObject.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Intrinsics.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/OperandTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/SymbolTableListTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AssemblyAnnotationWriter
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|DISubprogram
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|Optional
expr_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|User
decl_stmt|;
name|class
name|Function
range|:
name|public
name|GlobalObject
decl_stmt|,
name|public
name|ilist_node
decl|<
name|Function
decl|>
block|{
name|public
label|:
name|using
name|BasicBlockListType
init|=
name|SymbolTableList
operator|<
name|BasicBlock
operator|>
decl_stmt|;
comment|// BasicBlock iterators...
name|using
name|iterator
init|=
name|BasicBlockListType
operator|::
name|iterator
decl_stmt|;
name|using
name|const_iterator
init|=
name|BasicBlockListType
operator|::
name|const_iterator
decl_stmt|;
name|using
name|arg_iterator
init|=
name|Argument
operator|*
decl_stmt|;
name|using
name|const_arg_iterator
init|=
specifier|const
name|Argument
operator|*
decl_stmt|;
name|private
label|:
comment|// Important things that make up a function!
name|BasicBlockListType
name|BasicBlocks
decl_stmt|;
comment|///< The basic blocks
name|mutable
name|Argument
modifier|*
name|Arguments
init|=
name|nullptr
decl_stmt|;
comment|///< The formal arguments
name|size_t
name|NumArgs
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ValueSymbolTable
operator|>
name|SymTab
expr_stmt|;
comment|///< Symbol table of args/instructions
name|AttributeList
name|AttributeSets
decl_stmt|;
comment|///< Parameter attributes
comment|/*    * Value::SubclassData    *    * bit 0      : HasLazyArguments    * bit 1      : HasPrefixData    * bit 2      : HasPrologueData    * bit 3      : HasPersonalityFn    * bits 4-13  : CallingConvention    * bits 14    : HasGC    * bits 15 : [reserved]    */
comment|/// Bits from GlobalObject::GlobalObjectSubclassData.
enum|enum
block|{
comment|/// Whether this function is materializable.
name|IsMaterializableBit
init|=
literal|0
block|,   }
enum|;
name|friend
name|class
name|SymbolTableListTraits
operator|<
name|Function
operator|>
expr_stmt|;
comment|/// hasLazyArguments/CheckLazyArguments - The argument list of a function is
comment|/// built on demand, so that the list isn't allocated until the first client
comment|/// needs it.  The hasLazyArguments predicate returns true if the arg list
comment|/// hasn't been set up yet.
name|public
label|:
name|bool
name|hasLazyArguments
argument_list|()
specifier|const
block|{
return|return
name|getSubclassDataFromValue
argument_list|()
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
return|;
block|}
name|private
label|:
name|void
name|CheckLazyArguments
argument_list|()
specifier|const
block|{
if|if
condition|(
name|hasLazyArguments
argument_list|()
condition|)
name|BuildLazyArguments
argument_list|()
expr_stmt|;
block|}
name|void
name|BuildLazyArguments
parameter_list|()
function_decl|const;
name|void
name|clearArguments
parameter_list|()
function_decl|;
comment|/// Function ctor - If the (optional) Module argument is specified, the
comment|/// function is automatically inserted into the end of the function list for
comment|/// the module.
comment|///
name|Function
argument_list|(
argument|FunctionType *Ty
argument_list|,
argument|LinkageTypes Linkage
argument_list|,
argument|const Twine&N =
literal|""
argument_list|,
argument|Module *M = nullptr
argument_list|)
empty_stmt|;
name|public
label|:
name|Function
argument_list|(
specifier|const
name|Function
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|Function
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|Function
argument_list|()
expr_stmt|;
specifier|static
name|Function
modifier|*
name|Create
parameter_list|(
name|FunctionType
modifier|*
name|Ty
parameter_list|,
name|LinkageTypes
name|Linkage
parameter_list|,
specifier|const
name|Twine
modifier|&
name|N
init|=
literal|""
parameter_list|,
name|Module
modifier|*
name|M
init|=
name|nullptr
parameter_list|)
block|{
return|return
name|new
name|Function
argument_list|(
name|Ty
argument_list|,
name|Linkage
argument_list|,
name|N
argument_list|,
name|M
argument_list|)
return|;
block|}
comment|// Provide fast operand accessors.
name|DECLARE_TRANSPARENT_OPERAND_ACCESSORS
argument_list|(
name|Value
argument_list|)
expr_stmt|;
comment|/// Returns the FunctionType for me.
name|FunctionType
operator|*
name|getFunctionType
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|FunctionType
operator|>
operator|(
name|getValueType
argument_list|()
operator|)
return|;
block|}
comment|/// Returns the type of the ret val.
name|Type
operator|*
name|getReturnType
argument_list|()
specifier|const
block|{
return|return
name|getFunctionType
argument_list|()
operator|->
name|getReturnType
argument_list|()
return|;
block|}
comment|/// getContext - Return a reference to the LLVMContext associated with this
comment|/// function.
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
expr_stmt|;
comment|/// isVarArg - Return true if this function takes a variable number of
comment|/// arguments.
name|bool
name|isVarArg
argument_list|()
specifier|const
block|{
return|return
name|getFunctionType
argument_list|()
operator|->
name|isVarArg
argument_list|()
return|;
block|}
name|bool
name|isMaterializable
argument_list|()
specifier|const
block|{
return|return
name|getGlobalObjectSubClassData
argument_list|()
operator|&
operator|(
literal|1
operator|<<
name|IsMaterializableBit
operator|)
return|;
block|}
name|void
name|setIsMaterializable
parameter_list|(
name|bool
name|V
parameter_list|)
block|{
name|unsigned
name|Mask
init|=
literal|1
operator|<<
name|IsMaterializableBit
decl_stmt|;
name|setGlobalObjectSubClassData
argument_list|(
operator|(
operator|~
name|Mask
operator|&
name|getGlobalObjectSubClassData
argument_list|()
operator|)
operator||
operator|(
name|V
condition|?
name|Mask
else|:
literal|0u
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/// getIntrinsicID - This method returns the ID number of the specified
comment|/// function, or Intrinsic::not_intrinsic if the function is not an
comment|/// intrinsic, or if the pointer is null.  This value is always defined to be
comment|/// zero to allow easy checking for whether a function is intrinsic or not.
comment|/// The particular intrinsic functions which correspond to this value are
comment|/// defined in llvm/Intrinsics.h.
name|Intrinsic
operator|::
name|ID
name|getIntrinsicID
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|IntID
return|;
block|}
comment|/// isIntrinsic - Returns true if the function's name starts with "llvm.".
comment|/// It's possible for this function to return true while getIntrinsicID()
comment|/// returns Intrinsic::not_intrinsic!
name|bool
name|isIntrinsic
argument_list|()
specifier|const
block|{
return|return
name|HasLLVMReservedName
return|;
block|}
specifier|static
name|Intrinsic
operator|::
name|ID
name|lookupIntrinsicID
argument_list|(
argument|StringRef Name
argument_list|)
expr_stmt|;
comment|/// \brief Recalculate the ID for this function if it is an Intrinsic defined
comment|/// in llvm/Intrinsics.h.  Sets the intrinsic ID to Intrinsic::not_intrinsic
comment|/// if the name of this function does not match an intrinsic in that header.
comment|/// Note, this method does not need to be called directly, as it is called
comment|/// from Value::setName() whenever the name of this function changes.
name|void
name|recalculateIntrinsicID
parameter_list|()
function_decl|;
comment|/// getCallingConv()/setCallingConv(CC) - These method get and set the
comment|/// calling convention of this function.  The enum values for the known
comment|/// calling conventions are defined in CallingConv.h.
name|CallingConv
operator|::
name|ID
name|getCallingConv
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|CallingConv
operator|::
name|ID
operator|>
operator|(
operator|(
name|getSubclassDataFromValue
argument_list|()
operator|>>
literal|4
operator|)
operator|&
name|CallingConv
operator|::
name|MaxID
operator|)
return|;
block|}
name|void
name|setCallingConv
argument_list|(
name|CallingConv
operator|::
name|ID
name|CC
argument_list|)
block|{
name|auto
name|ID
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CC
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|ID
operator|&
operator|~
name|CallingConv
operator|::
name|MaxID
operator|)
operator|&&
literal|"Unsupported calling convention"
argument_list|)
expr_stmt|;
name|setValueSubclassData
argument_list|(
operator|(
name|getSubclassDataFromValue
argument_list|()
operator|&
literal|0xc00f
operator|)
operator||
operator|(
name|ID
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Return the attribute list for this Function.
name|AttributeList
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|AttributeSets
return|;
block|}
comment|/// @brief Set the attribute list for this Function.
name|void
name|setAttributes
parameter_list|(
name|AttributeList
name|Attrs
parameter_list|)
block|{
name|AttributeSets
operator|=
name|Attrs
expr_stmt|;
block|}
comment|/// @brief Add function attributes to this function.
name|void
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
block|{
name|addAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Kind
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Add function attributes to this function.
name|void
name|addFnAttr
parameter_list|(
name|StringRef
name|Kind
parameter_list|,
name|StringRef
name|Val
init|=
name|StringRef
argument_list|()
parameter_list|)
block|{
name|addAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Attribute
operator|::
name|get
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|Kind
argument_list|,
name|Val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|addFnAttr
parameter_list|(
name|Attribute
name|Attr
parameter_list|)
block|{
name|addAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Attr
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Remove function attributes from this function.
name|void
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
block|{
name|removeAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Kind
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Remove function attribute from this function.
name|void
name|removeFnAttr
parameter_list|(
name|StringRef
name|Kind
parameter_list|)
block|{
name|setAttributes
argument_list|(
name|getAttributes
argument_list|()
operator|.
name|removeAttribute
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Kind
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Set the entry count for this function.
comment|///
comment|/// Entry count is the number of times this function was executed based on
comment|/// pgo data. \p Imports points to a set of GUIDs that needs to be imported
comment|/// by the function for sample PGO, to enable the same inlines as the
comment|/// profiled optimized binary.
name|void
name|setEntryCount
argument_list|(
name|uint64_t
name|Count
argument_list|,
specifier|const
name|DenseSet
operator|<
name|GlobalValue
operator|::
name|GUID
operator|>
operator|*
name|Imports
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// \brief Get the entry count for this function.
comment|///
comment|/// Entry count is the number of times the function was executed based on
comment|/// pgo data.
name|Optional
operator|<
name|uint64_t
operator|>
name|getEntryCount
argument_list|()
specifier|const
expr_stmt|;
comment|/// Returns the set of GUIDs that needs to be imported to the function for
comment|/// sample PGO, to enable the same inlines as the profiled optimized binary.
name|DenseSet
operator|<
name|GlobalValue
operator|::
name|GUID
operator|>
name|getImportGUIDs
argument_list|()
specifier|const
expr_stmt|;
comment|/// Set the section prefix for this function.
name|void
name|setSectionPrefix
parameter_list|(
name|StringRef
name|Prefix
parameter_list|)
function_decl|;
comment|/// Get the section prefix for this function.
name|Optional
operator|<
name|StringRef
operator|>
name|getSectionPrefix
argument_list|()
specifier|const
expr_stmt|;
comment|/// @brief Return true if the function has the attribute.
name|bool
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|hasFnAttribute
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|hasFnAttribute
argument_list|(
name|StringRef
name|Kind
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|hasFnAttribute
argument_list|(
name|Kind
argument_list|)
return|;
block|}
comment|/// @brief Return the attribute for the given attribute kind.
name|Attribute
name|getFnAttribute
argument_list|(
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|getAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Kind
argument_list|)
return|;
block|}
name|Attribute
name|getFnAttribute
argument_list|(
name|StringRef
name|Kind
argument_list|)
decl|const
block|{
return|return
name|getAttribute
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|,
name|Kind
argument_list|)
return|;
block|}
comment|/// \brief Return the stack alignment for the function.
name|unsigned
name|getFnStackAlignment
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|StackAlignment
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|AttributeSets
operator|.
name|getStackAlignment
argument_list|(
name|AttributeList
operator|::
name|FunctionIndex
argument_list|)
return|;
block|}
comment|/// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm
comment|///                             to use during code generation.
name|bool
name|hasGC
argument_list|()
specifier|const
block|{
return|return
name|getSubclassDataFromValue
argument_list|()
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getGC
argument_list|()
specifier|const
expr_stmt|;
name|void
name|setGC
argument_list|(
name|std
operator|::
name|string
name|Str
argument_list|)
decl_stmt|;
name|void
name|clearGC
parameter_list|()
function_decl|;
comment|/// @brief adds the attribute to the list of attributes.
name|void
name|addAttribute
argument_list|(
name|unsigned
name|i
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// @brief adds the attribute to the list of attributes.
name|void
name|addAttribute
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|Attribute
name|Attr
parameter_list|)
function_decl|;
comment|/// @brief adds the attributes to the list of attributes.
name|void
name|addAttributes
parameter_list|(
name|unsigned
name|i
parameter_list|,
specifier|const
name|AttrBuilder
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// @brief adds the attribute to the list of attributes for the given arg.
name|void
name|addParamAttr
argument_list|(
name|unsigned
name|ArgNo
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// @brief adds the attribute to the list of attributes for the given arg.
name|void
name|addParamAttr
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
name|Attribute
name|Attr
parameter_list|)
function_decl|;
comment|/// @brief adds the attributes to the list of attributes for the given arg.
name|void
name|addParamAttrs
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
specifier|const
name|AttrBuilder
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// @brief removes the attribute from the list of attributes.
name|void
name|removeAttribute
argument_list|(
name|unsigned
name|i
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// @brief removes the attribute from the list of attributes.
name|void
name|removeAttribute
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|StringRef
name|Kind
parameter_list|)
function_decl|;
comment|/// @brief removes the attributes from the list of attributes.
name|void
name|removeAttributes
parameter_list|(
name|unsigned
name|i
parameter_list|,
specifier|const
name|AttrBuilder
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// @brief removes the attribute from the list of attributes.
name|void
name|removeParamAttr
argument_list|(
name|unsigned
name|ArgNo
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// @brief removes the attribute from the list of attributes.
name|void
name|removeParamAttr
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
name|StringRef
name|Kind
parameter_list|)
function_decl|;
comment|/// @brief removes the attribute from the list of attributes.
name|void
name|removeParamAttrs
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
specifier|const
name|AttrBuilder
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// @brief check if an attributes is in the list of attributes.
name|bool
name|hasAttribute
argument_list|(
name|unsigned
name|i
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|getAttributes
argument_list|()
operator|.
name|hasAttribute
argument_list|(
name|i
argument_list|,
name|Kind
argument_list|)
return|;
block|}
comment|/// @brief check if an attributes is in the list of attributes.
name|bool
name|hasParamAttribute
argument_list|(
name|unsigned
name|ArgNo
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|getAttributes
argument_list|()
operator|.
name|hasParamAttribute
argument_list|(
name|ArgNo
argument_list|,
name|Kind
argument_list|)
return|;
block|}
name|Attribute
name|getAttribute
argument_list|(
name|unsigned
name|i
argument_list|,
name|Attribute
operator|::
name|AttrKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getAttribute
argument_list|(
name|i
argument_list|,
name|Kind
argument_list|)
return|;
block|}
name|Attribute
name|getAttribute
argument_list|(
name|unsigned
name|i
argument_list|,
name|StringRef
name|Kind
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getAttribute
argument_list|(
name|i
argument_list|,
name|Kind
argument_list|)
return|;
block|}
comment|/// @brief adds the dereferenceable attribute to the list of attributes.
name|void
name|addDereferenceableAttr
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|uint64_t
name|Bytes
parameter_list|)
function_decl|;
comment|/// @brief adds the dereferenceable attribute to the list of attributes for
comment|/// the given arg.
name|void
name|addDereferenceableParamAttr
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
name|uint64_t
name|Bytes
parameter_list|)
function_decl|;
comment|/// @brief adds the dereferenceable_or_null attribute to the list of
comment|/// attributes.
name|void
name|addDereferenceableOrNullAttr
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|uint64_t
name|Bytes
parameter_list|)
function_decl|;
comment|/// @brief adds the dereferenceable_or_null attribute to the list of
comment|/// attributes for the given arg.
name|void
name|addDereferenceableOrNullParamAttr
parameter_list|(
name|unsigned
name|ArgNo
parameter_list|,
name|uint64_t
name|Bytes
parameter_list|)
function_decl|;
comment|/// @brief Extract the alignment for a call or parameter (0=unknown).
name|unsigned
name|getParamAlignment
argument_list|(
name|unsigned
name|ArgNo
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getParamAlignment
argument_list|(
name|ArgNo
argument_list|)
return|;
block|}
comment|/// @brief Extract the number of dereferenceable bytes for a call or
comment|/// parameter (0=unknown).
comment|/// @param i AttributeList index, referring to a return value or argument.
name|uint64_t
name|getDereferenceableBytes
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getDereferenceableBytes
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/// @brief Extract the number of dereferenceable bytes for a parameter.
comment|/// @param ArgNo Index of an argument, with 0 being the first function arg.
name|uint64_t
name|getParamDereferenceableBytes
argument_list|(
name|unsigned
name|ArgNo
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getParamDereferenceableBytes
argument_list|(
name|ArgNo
argument_list|)
return|;
block|}
comment|/// @brief Extract the number of dereferenceable_or_null bytes for a call or
comment|/// parameter (0=unknown).
comment|/// @param i AttributeList index, referring to a return value or argument.
name|uint64_t
name|getDereferenceableOrNullBytes
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getDereferenceableOrNullBytes
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/// @brief Extract the number of dereferenceable_or_null bytes for a
comment|/// parameter.
comment|/// @param ArgNo AttributeList ArgNo, referring to an argument.
name|uint64_t
name|getParamDereferenceableOrNullBytes
argument_list|(
name|unsigned
name|ArgNo
argument_list|)
decl|const
block|{
return|return
name|AttributeSets
operator|.
name|getParamDereferenceableOrNullBytes
argument_list|(
name|ArgNo
argument_list|)
return|;
block|}
comment|/// @brief Determine if the function does not access memory.
name|bool
name|doesNotAccessMemory
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|ReadNone
argument_list|)
return|;
block|}
name|void
name|setDoesNotAccessMemory
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadNone
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function does not access or only reads memory.
name|bool
name|onlyReadsMemory
argument_list|()
specifier|const
block|{
return|return
name|doesNotAccessMemory
argument_list|()
operator|||
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|ReadOnly
argument_list|)
return|;
block|}
name|void
name|setOnlyReadsMemory
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function does not access or only writes memory.
name|bool
name|doesNotReadMemory
argument_list|()
specifier|const
block|{
return|return
name|doesNotAccessMemory
argument_list|()
operator|||
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|WriteOnly
argument_list|)
return|;
block|}
name|void
name|setDoesNotReadMemory
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the call can access memmory only using pointers based
comment|/// on its arguments.
name|bool
name|onlyAccessesArgMemory
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|ArgMemOnly
argument_list|)
return|;
block|}
name|void
name|setOnlyAccessesArgMemory
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|ArgMemOnly
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function may only access memory that is
comment|///  inaccessible from the IR.
name|bool
name|onlyAccessesInaccessibleMemory
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|InaccessibleMemOnly
argument_list|)
return|;
block|}
name|void
name|setOnlyAccessesInaccessibleMemory
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|InaccessibleMemOnly
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function may only access memory that is
comment|///  either inaccessible from the IR or pointed to by its arguments.
name|bool
name|onlyAccessesInaccessibleMemOrArgMem
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|InaccessibleMemOrArgMemOnly
argument_list|)
return|;
block|}
name|void
name|setOnlyAccessesInaccessibleMemOrArgMem
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|InaccessibleMemOrArgMemOnly
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function cannot return.
name|bool
name|doesNotReturn
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|NoReturn
argument_list|)
return|;
block|}
name|void
name|setDoesNotReturn
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoReturn
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the function cannot unwind.
name|bool
name|doesNotThrow
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|NoUnwind
argument_list|)
return|;
block|}
name|void
name|setDoesNotThrow
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoUnwind
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the call cannot be duplicated.
name|bool
name|cannotDuplicate
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|NoDuplicate
argument_list|)
return|;
block|}
name|void
name|setCannotDuplicate
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoDuplicate
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the call is convergent.
name|bool
name|isConvergent
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|Convergent
argument_list|)
return|;
block|}
name|void
name|setConvergent
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|Convergent
argument_list|)
expr_stmt|;
block|}
name|void
name|setNotConvergent
parameter_list|()
block|{
name|removeFnAttr
argument_list|(
name|Attribute
operator|::
name|Convergent
argument_list|)
expr_stmt|;
block|}
comment|/// @brief Determine if the call has sideeffects.
name|bool
name|isSpeculatable
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|Speculatable
argument_list|)
return|;
block|}
name|void
name|setSpeculatable
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|Speculatable
argument_list|)
expr_stmt|;
block|}
comment|/// Determine if the function is known not to recurse, directly or
comment|/// indirectly.
name|bool
name|doesNotRecurse
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|NoRecurse
argument_list|)
return|;
block|}
name|void
name|setDoesNotRecurse
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|NoRecurse
argument_list|)
expr_stmt|;
block|}
comment|/// @brief True if the ABI mandates (or the user requested) that this
comment|/// function be in a unwind table.
name|bool
name|hasUWTable
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|UWTable
argument_list|)
return|;
block|}
name|void
name|setHasUWTable
parameter_list|()
block|{
name|addFnAttr
argument_list|(
name|Attribute
operator|::
name|UWTable
argument_list|)
expr_stmt|;
block|}
comment|/// @brief True if this function needs an unwind table.
name|bool
name|needsUnwindTableEntry
argument_list|()
specifier|const
block|{
return|return
name|hasUWTable
argument_list|()
operator|||
operator|!
name|doesNotThrow
argument_list|()
return|;
block|}
comment|/// @brief Determine if the function returns a structure through first
comment|/// or second pointer argument.
name|bool
name|hasStructRetAttr
argument_list|()
specifier|const
block|{
return|return
name|AttributeSets
operator|.
name|hasParamAttribute
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|StructRet
argument_list|)
operator|||
name|AttributeSets
operator|.
name|hasParamAttribute
argument_list|(
literal|1
argument_list|,
name|Attribute
operator|::
name|StructRet
argument_list|)
return|;
block|}
comment|/// @brief Determine if the parameter or return value is marked with NoAlias
comment|/// attribute.
name|bool
name|returnDoesNotAlias
argument_list|()
specifier|const
block|{
return|return
name|AttributeSets
operator|.
name|hasAttribute
argument_list|(
name|AttributeList
operator|::
name|ReturnIndex
argument_list|,
name|Attribute
operator|::
name|NoAlias
argument_list|)
return|;
block|}
name|void
name|setReturnDoesNotAlias
parameter_list|()
block|{
name|addAttribute
argument_list|(
name|AttributeList
operator|::
name|ReturnIndex
argument_list|,
name|Attribute
operator|::
name|NoAlias
argument_list|)
expr_stmt|;
block|}
comment|/// Optimize this function for minimum size (-Oz).
name|bool
name|optForMinSize
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|MinSize
argument_list|)
return|;
block|}
comment|/// Optimize this function for size (-Os) or minimum size (-Oz).
name|bool
name|optForSize
argument_list|()
specifier|const
block|{
return|return
name|hasFnAttribute
argument_list|(
name|Attribute
operator|::
name|OptimizeForSize
argument_list|)
operator|||
name|optForMinSize
argument_list|()
return|;
block|}
comment|/// copyAttributesFrom - copy all additional attributes (those not needed to
comment|/// create a Function) from the Function Src to this one.
name|void
name|copyAttributesFrom
parameter_list|(
specifier|const
name|Function
modifier|*
name|Src
parameter_list|)
function_decl|;
comment|/// deleteBody - This method deletes the body of the function, and converts
comment|/// the linkage to external.
comment|///
name|void
name|deleteBody
parameter_list|()
block|{
name|dropAllReferences
argument_list|()
expr_stmt|;
name|setLinkage
argument_list|(
name|ExternalLinkage
argument_list|)
expr_stmt|;
block|}
comment|/// removeFromParent - This method unlinks 'this' from the containing module,
comment|/// but does not delete it.
comment|///
name|void
name|removeFromParent
parameter_list|()
function_decl|;
comment|/// eraseFromParent - This method unlinks 'this' from the containing module
comment|/// and deletes it.
comment|///
name|void
name|eraseFromParent
parameter_list|()
function_decl|;
comment|/// Steal arguments from another function.
comment|///
comment|/// Drop this function's arguments and splice in the ones from \c Src.
comment|/// Requires that this has no function body.
name|void
name|stealArgumentListFrom
parameter_list|(
name|Function
modifier|&
name|Src
parameter_list|)
function_decl|;
comment|/// Get the underlying elements of the Function... the basic block list is
comment|/// empty for external functions.
comment|///
specifier|const
name|BasicBlockListType
operator|&
name|getBasicBlockList
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
return|;
block|}
name|BasicBlockListType
modifier|&
name|getBasicBlockList
parameter_list|()
block|{
return|return
name|BasicBlocks
return|;
block|}
specifier|static
name|BasicBlockListType
name|Function
operator|::
operator|*
name|getSublistAccess
argument_list|(
argument|BasicBlock*
argument_list|)
block|{
return|return
operator|&
name|Function
operator|::
name|BasicBlocks
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|getEntryBlock
argument_list|()
specifier|const
block|{
return|return
name|front
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|getEntryBlock
parameter_list|()
block|{
return|return
name|front
argument_list|()
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Symbol Table Accessing functions...
comment|/// getSymbolTable() - Return the symbol table if any, otherwise nullptr.
comment|///
specifier|inline
name|ValueSymbolTable
modifier|*
name|getValueSymbolTable
parameter_list|()
block|{
return|return
name|SymTab
operator|.
name|get
argument_list|()
return|;
block|}
specifier|inline
specifier|const
name|ValueSymbolTable
operator|*
name|getValueSymbolTable
argument_list|()
specifier|const
block|{
return|return
name|SymTab
operator|.
name|get
argument_list|()
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// BasicBlock iterator forwarding functions
comment|//
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|front
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|front
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|front
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|front
argument_list|()
return|;
block|}
specifier|const
name|BasicBlock
operator|&
name|back
argument_list|()
specifier|const
block|{
return|return
name|BasicBlocks
operator|.
name|back
argument_list|()
return|;
block|}
name|BasicBlock
modifier|&
name|back
parameter_list|()
block|{
return|return
name|BasicBlocks
operator|.
name|back
argument_list|()
return|;
block|}
comment|/// @name Function Argument Iteration
comment|/// @{
name|arg_iterator
name|arg_begin
parameter_list|()
block|{
name|CheckLazyArguments
argument_list|()
expr_stmt|;
return|return
name|Arguments
return|;
block|}
name|const_arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
name|CheckLazyArguments
argument_list|()
block|;
return|return
name|Arguments
return|;
block|}
name|arg_iterator
name|arg_end
parameter_list|()
block|{
name|CheckLazyArguments
argument_list|()
expr_stmt|;
return|return
name|Arguments
operator|+
name|NumArgs
return|;
block|}
name|const_arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
name|CheckLazyArguments
argument_list|()
block|;
return|return
name|Arguments
operator|+
name|NumArgs
return|;
block|}
name|iterator_range
operator|<
name|arg_iterator
operator|>
name|args
argument_list|()
block|{
return|return
name|make_range
argument_list|(
name|arg_begin
argument_list|()
argument_list|,
name|arg_end
argument_list|()
argument_list|)
return|;
block|}
name|iterator_range
operator|<
name|const_arg_iterator
operator|>
name|args
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|arg_begin
argument_list|()
argument_list|,
name|arg_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// @}
name|size_t
name|arg_size
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
name|bool
name|arg_empty
argument_list|()
specifier|const
block|{
return|return
name|arg_size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/// \brief Check whether this function has a personality function.
name|bool
name|hasPersonalityFn
argument_list|()
specifier|const
block|{
return|return
name|getSubclassDataFromValue
argument_list|()
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
return|;
block|}
comment|/// \brief Get the personality function associated with this function.
name|Constant
operator|*
name|getPersonalityFn
argument_list|()
specifier|const
expr_stmt|;
name|void
name|setPersonalityFn
parameter_list|(
name|Constant
modifier|*
name|Fn
parameter_list|)
function_decl|;
comment|/// \brief Check whether this function has prefix data.
name|bool
name|hasPrefixData
argument_list|()
specifier|const
block|{
return|return
name|getSubclassDataFromValue
argument_list|()
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
return|;
block|}
comment|/// \brief Get the prefix data associated with this function.
name|Constant
operator|*
name|getPrefixData
argument_list|()
specifier|const
expr_stmt|;
name|void
name|setPrefixData
parameter_list|(
name|Constant
modifier|*
name|PrefixData
parameter_list|)
function_decl|;
comment|/// \brief Check whether this function has prologue data.
name|bool
name|hasPrologueData
argument_list|()
specifier|const
block|{
return|return
name|getSubclassDataFromValue
argument_list|()
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
return|;
block|}
comment|/// \brief Get the prologue data associated with this function.
name|Constant
operator|*
name|getPrologueData
argument_list|()
specifier|const
expr_stmt|;
name|void
name|setPrologueData
parameter_list|(
name|Constant
modifier|*
name|PrologueData
parameter_list|)
function_decl|;
comment|/// Print the function to an output stream with an optional
comment|/// AssemblyAnnotationWriter.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|AssemblyAnnotationWriter
operator|*
name|AAW
operator|=
name|nullptr
argument_list|,
name|bool
name|ShouldPreserveUseListOrder
operator|=
name|false
argument_list|,
name|bool
name|IsForDebug
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
comment|/// viewCFG - This function is meant for use from the debugger.  You can just
comment|/// say 'call F->viewCFG()' and a ghostview window should pop up from the
comment|/// program, displaying the CFG of the current function with the code for each
comment|/// basic block inside.  This depends on there being a 'dot' and 'gv' program
comment|/// in your path.
comment|///
name|void
name|viewCFG
argument_list|()
specifier|const
expr_stmt|;
comment|/// viewCFGOnly - This function is meant for use from the debugger.  It works
comment|/// just like viewCFG, but it does not include the contents of basic blocks
comment|/// into the nodes, just the label.  If you are only interested in the CFG
comment|/// this can make the graph smaller.
comment|///
name|void
name|viewCFGOnly
argument_list|()
specifier|const
expr_stmt|;
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|FunctionVal
return|;
block|}
comment|/// dropAllReferences() - This method causes all the subinstructions to "let
comment|/// go" of all references that they are maintaining.  This allows one to
comment|/// 'delete' a whole module at a time, even though there may be circular
comment|/// references... first all references are dropped, and all use counts go to
comment|/// zero.  Then everything is deleted for real.  Note that no operations are
comment|/// valid on an object that has "dropped all references", except operator
comment|/// delete.
comment|///
comment|/// Since no other object in the module can have references into the body of a
comment|/// function, dropping all references deletes the entire body of the function,
comment|/// including any contained basic blocks.
comment|///
name|void
name|dropAllReferences
parameter_list|()
function_decl|;
comment|/// hasAddressTaken - returns true if there are any uses of this function
comment|/// other than direct calls or invokes to it, or blockaddress expressions.
comment|/// Optionally passes back an offending user for diagnostic purposes.
comment|///
name|bool
name|hasAddressTaken
argument_list|(
specifier|const
name|User
operator|*
operator|*
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// isDefTriviallyDead - Return true if it is trivially safe to remove
comment|/// this function definition from the module (because it isn't externally
comment|/// visible, does not have its address taken, and has no callers).  To make
comment|/// this more accurate, call removeDeadConstantUsers first.
name|bool
name|isDefTriviallyDead
argument_list|()
specifier|const
expr_stmt|;
comment|/// callsFunctionThatReturnsTwice - Return true if the function has a call to
comment|/// setjmp or other function that gcc recognizes as "returning twice".
name|bool
name|callsFunctionThatReturnsTwice
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Set the attached subprogram.
comment|///
comment|/// Calls \a setMetadata() with \a LLVMContext::MD_dbg.
name|void
name|setSubprogram
parameter_list|(
name|DISubprogram
modifier|*
name|SP
parameter_list|)
function_decl|;
comment|/// \brief Get the attached subprogram.
comment|///
comment|/// Calls \a getMetadata() with \a LLVMContext::MD_dbg and casts the result
comment|/// to \a DISubprogram.
name|DISubprogram
operator|*
name|getSubprogram
argument_list|()
specifier|const
expr_stmt|;
comment|/// Returns true if we should emit debug info for profiling.
name|bool
name|isDebugInfoForProfiling
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|void
name|allocHungoffUselist
parameter_list|()
function_decl|;
name|template
operator|<
name|int
name|Idx
operator|>
name|void
name|setHungoffOperand
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
expr_stmt|;
comment|/// Shadow Value::setValueSubclassData with a private forwarding method so
comment|/// that subclasses cannot accidentally use it.
name|void
name|setValueSubclassData
parameter_list|(
name|unsigned
name|short
name|D
parameter_list|)
block|{
name|Value
operator|::
name|setValueSubclassData
argument_list|(
name|D
argument_list|)
expr_stmt|;
block|}
name|void
name|setValueSubclassDataBit
parameter_list|(
name|unsigned
name|Bit
parameter_list|,
name|bool
name|On
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|OperandTraits
operator|<
name|Function
operator|>
operator|:
name|public
name|HungoffOperandTraits
operator|<
literal|3
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_macro
name|DEFINE_TRANSPARENT_OPERAND_ACCESSORS
argument_list|(
argument|Function
argument_list|,
argument|Value
argument_list|)
end_macro

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_IR_FUNCTION_H
end_comment

end_unit

