begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ValueHandle.h - Value Smart Pointer classes --------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the ValueHandle class and its sub-classes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_VALUEHANDLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_VALUEHANDLE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ValueHandleBase
decl_stmt|;
name|template
operator|<
name|typename
name|From
operator|>
expr|struct
name|simplify_type
expr_stmt|;
comment|// ValueHandleBase** is only 4-byte aligned.
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|ValueHandleBase
operator|*
operator|*
operator|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|ValueHandleBase** P
argument_list|)
block|{
return|return
name|P
return|;
block|}
specifier|static
specifier|inline
name|ValueHandleBase
operator|*
operator|*
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|ValueHandleBase
operator|*
operator|*
operator|>
operator|(
name|P
operator|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
literal|2
block|}
block|; }
expr_stmt|;
comment|/// \brief This is the common base class of value handles.
comment|///
comment|/// ValueHandle's are smart pointers to Value's that have special behavior when
comment|/// the value is deleted or ReplaceAllUsesWith'd.  See the specific handles
comment|/// below for details.
name|class
name|ValueHandleBase
block|{
name|friend
name|class
name|Value
decl_stmt|;
name|protected
label|:
comment|/// \brief This indicates what sub class the handle actually is.
comment|///
comment|/// This is to avoid having a vtable for the light-weight handle pointers. The
comment|/// fully general Callback version does have a vtable.
enum|enum
name|HandleBaseKind
block|{
name|Assert
block|,
name|Callback
block|,
name|Tracking
block|,
name|Weak
block|}
enum|;
name|ValueHandleBase
argument_list|(
specifier|const
name|ValueHandleBase
operator|&
name|RHS
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|RHS.PrevPair.getInt()
argument_list|,
argument|RHS
argument_list|)
block|{}
name|ValueHandleBase
argument_list|(
argument|HandleBaseKind Kind
argument_list|,
argument|const ValueHandleBase&RHS
argument_list|)
operator|:
name|PrevPair
argument_list|(
name|nullptr
argument_list|,
name|Kind
argument_list|)
operator|,
name|Next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|V
argument_list|(
argument|RHS.V
argument_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|AddToExistingUseList
argument_list|(
name|RHS
operator|.
name|getPrevPtr
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|PointerIntPair
operator|<
name|ValueHandleBase
operator|*
operator|*
operator|,
literal|2
operator|,
name|HandleBaseKind
operator|>
name|PrevPair
expr_stmt|;
name|ValueHandleBase
modifier|*
name|Next
decl_stmt|;
name|Value
modifier|*
name|V
decl_stmt|;
name|public
label|:
name|explicit
name|ValueHandleBase
argument_list|(
argument|HandleBaseKind Kind
argument_list|)
block|:
name|PrevPair
argument_list|(
name|nullptr
argument_list|,
name|Kind
argument_list|)
operator|,
name|Next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|V
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|ValueHandleBase
argument_list|(
argument|HandleBaseKind Kind
argument_list|,
argument|Value *V
argument_list|)
operator|:
name|PrevPair
argument_list|(
name|nullptr
argument_list|,
name|Kind
argument_list|)
operator|,
name|Next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|V
argument_list|(
argument|V
argument_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|AddToUseList
argument_list|()
expr_stmt|;
block|}
operator|~
name|ValueHandleBase
argument_list|()
block|{
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|RemoveFromUseList
argument_list|()
expr_stmt|;
block|}
name|Value
modifier|*
name|operator
init|=
operator|(
name|Value
operator|*
name|RHS
operator|)
block|{
if|if
condition|(
name|V
operator|==
name|RHS
condition|)
return|return
name|RHS
return|;
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|RemoveFromUseList
argument_list|()
expr_stmt|;
name|V
operator|=
name|RHS
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|AddToUseList
argument_list|()
expr_stmt|;
return|return
name|RHS
return|;
block|}
name|Value
modifier|*
name|operator
init|=
operator|(
specifier|const
name|ValueHandleBase
operator|&
name|RHS
operator|)
block|{
if|if
condition|(
name|V
operator|==
name|RHS
operator|.
name|V
condition|)
return|return
name|RHS
operator|.
name|V
return|;
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|RemoveFromUseList
argument_list|()
expr_stmt|;
name|V
operator|=
name|RHS
operator|.
name|V
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|(
name|V
argument_list|)
condition|)
name|AddToExistingUseList
argument_list|(
name|RHS
operator|.
name|getPrevPtr
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|Value
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|V
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Value
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|V
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|Value
operator|*
name|getValPtr
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|isValid
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|V
operator|&&
name|V
operator|!=
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
operator|&&
name|V
operator|!=
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// Callbacks made from Value.
end_comment

begin_function_decl
specifier|static
name|void
name|ValueIsDeleted
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ValueIsRAUWd
parameter_list|(
name|Value
modifier|*
name|Old
parameter_list|,
name|Value
modifier|*
name|New
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|private
label|:
end_label

begin_comment
comment|// Internal implementation details.
end_comment

begin_expr_stmt
name|ValueHandleBase
operator|*
operator|*
name|getPrevPtr
argument_list|()
specifier|const
block|{
return|return
name|PrevPair
operator|.
name|getPointer
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|HandleBaseKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|PrevPair
operator|.
name|getInt
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setPrevPtr
parameter_list|(
name|ValueHandleBase
modifier|*
modifier|*
name|Ptr
parameter_list|)
block|{
name|PrevPair
operator|.
name|setPointer
argument_list|(
name|Ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Add this ValueHandle to the use list for V.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// List is the address of either the head of the list or a Next node within
end_comment

begin_comment
comment|/// the existing use list.
end_comment

begin_function_decl
name|void
name|AddToExistingUseList
parameter_list|(
name|ValueHandleBase
modifier|*
modifier|*
name|List
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Add this ValueHandle to the use list after Node.
end_comment

begin_function_decl
name|void
name|AddToExistingUseListAfter
parameter_list|(
name|ValueHandleBase
modifier|*
name|Node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Add this ValueHandle to the use list for V.
end_comment

begin_function_decl
name|void
name|AddToUseList
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Remove this ValueHandle from its current use list.
end_comment

begin_function_decl
name|void
name|RemoveFromUseList
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// \brief Value handle that is nullable, but tries to track the Value.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is a value handle that tries hard to point to a Value, even across
end_comment

begin_comment
comment|/// RAUW operations, but will null itself out if the value is destroyed.  this
end_comment

begin_comment
comment|/// is useful for advisory sorts of information, but should not be used as the
end_comment

begin_comment
comment|/// key of a map (since the map would have to rearrange itself when the pointer
end_comment

begin_comment
comment|/// changes).
end_comment

begin_decl_stmt
name|class
name|WeakVH
range|:
name|public
name|ValueHandleBase
block|{
name|public
operator|:
name|WeakVH
argument_list|()
operator|:
name|ValueHandleBase
argument_list|(
argument|Weak
argument_list|)
block|{}
name|WeakVH
argument_list|(
name|Value
operator|*
name|P
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Weak
argument_list|,
argument|P
argument_list|)
block|{}
name|WeakVH
argument_list|(
specifier|const
name|WeakVH
operator|&
name|RHS
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Weak
argument_list|,
argument|RHS
argument_list|)
block|{}
name|WeakVH
operator|&
name|operator
operator|=
operator|(
specifier|const
name|WeakVH
operator|&
name|RHS
operator|)
operator|=
expr|default
block|;
name|Value
operator|*
name|operator
operator|=
operator|(
name|Value
operator|*
name|RHS
operator|)
block|{
return|return
name|ValueHandleBase
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
return|;
block|}
name|Value
operator|*
name|operator
operator|=
operator|(
specifier|const
name|ValueHandleBase
operator|&
name|RHS
operator|)
block|{
return|return
name|ValueHandleBase
operator|::
name|operator
operator|=
operator|(
name|RHS
operator|)
return|;
block|}
name|operator
name|Value
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
expr|}
block|;
comment|// Specialize simplify_type to allow WeakVH to participate in
comment|// dyn_cast, isa, etc.
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
name|WeakVH
operator|>
block|{
typedef|typedef
name|Value
modifier|*
name|SimpleType
typedef|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|WeakVH&WVH
argument_list|)
block|{
return|return
name|WVH
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|WeakVH
operator|>
block|{
typedef|typedef
name|Value
modifier|*
name|SimpleType
typedef|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const WeakVH&WVH
argument_list|)
block|{
return|return
name|WVH
return|;
block|}
expr|}
block|;
comment|/// \brief Value handle that asserts if the Value is deleted.
comment|///
comment|/// This is a Value Handle that points to a value and asserts out if the value
comment|/// is destroyed while the handle is still live.  This is very useful for
comment|/// catching dangling pointer bugs and other things which can be non-obvious.
comment|/// One particularly useful place to use this is as the Key of a map.  Dangling
comment|/// pointer bugs often lead to really subtle bugs that only occur if another
comment|/// object happens to get allocated to the same address as the old one.  Using
comment|/// an AssertingVH ensures that an assert is triggered as soon as the bad
comment|/// delete occurs.
comment|///
comment|/// Note that an AssertingVH handle does *not* follow values across RAUW
comment|/// operations.  This means that RAUW's need to explicitly update the
comment|/// AssertingVH's as it moves.  This is required because in non-assert mode this
comment|/// class turns into a trivial wrapper around a pointer.
name|template
operator|<
name|typename
name|ValueTy
operator|>
name|class
name|AssertingVH
ifndef|#
directive|ifndef
name|NDEBUG
operator|:
name|public
name|ValueHandleBase
endif|#
directive|endif
block|{
name|friend
expr|struct
name|DenseMapInfo
operator|<
name|AssertingVH
operator|<
name|ValueTy
operator|>
expr|>
block|;
ifndef|#
directive|ifndef
name|NDEBUG
name|Value
operator|*
name|getRawValPtr
argument_list|()
specifier|const
block|{
return|return
name|ValueHandleBase
operator|::
name|getValPtr
argument_list|()
return|;
block|}
name|void
name|setRawValPtr
argument_list|(
argument|Value *P
argument_list|)
block|{
name|ValueHandleBase
operator|::
name|operator
operator|=
operator|(
name|P
operator|)
block|; }
else|#
directive|else
name|Value
operator|*
name|ThePtr
block|;
name|Value
operator|*
name|getRawValPtr
argument_list|()
specifier|const
block|{
return|return
name|ThePtr
return|;
block|}
name|void
name|setRawValPtr
argument_list|(
argument|Value *P
argument_list|)
block|{
name|ThePtr
operator|=
name|P
block|; }
endif|#
directive|endif
comment|// Convert a ValueTy*, which may be const, to the raw Value*.
specifier|static
name|Value
operator|*
name|GetAsValue
argument_list|(
argument|Value *V
argument_list|)
block|{
return|return
name|V
return|;
block|}
specifier|static
name|Value
operator|*
name|GetAsValue
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|Value
operator|*
operator|>
operator|(
name|V
operator|)
return|;
block|}
name|ValueTy
operator|*
name|getValPtr
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|ValueTy
operator|*
operator|>
operator|(
name|getRawValPtr
argument_list|()
operator|)
return|;
block|}
name|void
name|setValPtr
argument_list|(
argument|ValueTy *P
argument_list|)
block|{
name|setRawValPtr
argument_list|(
name|GetAsValue
argument_list|(
name|P
argument_list|)
argument_list|)
block|; }
name|public
operator|:
ifndef|#
directive|ifndef
name|NDEBUG
name|AssertingVH
argument_list|()
operator|:
name|ValueHandleBase
argument_list|(
argument|Assert
argument_list|)
block|{}
name|AssertingVH
argument_list|(
name|ValueTy
operator|*
name|P
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Assert
argument_list|,
argument|GetAsValue(P)
argument_list|)
block|{}
name|AssertingVH
argument_list|(
specifier|const
name|AssertingVH
operator|&
name|RHS
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Assert
argument_list|,
argument|RHS
argument_list|)
block|{}
else|#
directive|else
name|AssertingVH
argument_list|()
operator|:
name|ThePtr
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|AssertingVH
argument_list|(
name|ValueTy
operator|*
name|P
argument_list|)
operator|:
name|ThePtr
argument_list|(
argument|GetAsValue(P)
argument_list|)
block|{}
endif|#
directive|endif
name|operator
name|ValueTy
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|*
name|operator
operator|=
operator|(
name|ValueTy
operator|*
name|RHS
operator|)
block|{
name|setValPtr
argument_list|(
name|RHS
argument_list|)
block|;
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|*
name|operator
operator|=
operator|(
specifier|const
name|AssertingVH
operator|<
name|ValueTy
operator|>
operator|&
name|RHS
operator|)
block|{
name|setValPtr
argument_list|(
name|RHS
operator|.
name|getValPtr
argument_list|()
argument_list|)
block|;
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|getValPtr
argument_list|()
return|;
block|}
expr|}
block|;
comment|// Specialize DenseMapInfo to allow AssertingVH to participate in DenseMap.
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|AssertingVH
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
specifier|inline
name|AssertingVH
operator|<
name|T
operator|>
name|getEmptyKey
argument_list|()
block|{
name|AssertingVH
operator|<
name|T
operator|>
name|Res
block|;
name|Res
operator|.
name|setRawValPtr
argument_list|(
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|getEmptyKey
argument_list|()
argument_list|)
block|;
return|return
name|Res
return|;
block|}
specifier|static
specifier|inline
name|AssertingVH
operator|<
name|T
operator|>
name|getTombstoneKey
argument_list|()
block|{
name|AssertingVH
operator|<
name|T
operator|>
name|Res
block|;
name|Res
operator|.
name|setRawValPtr
argument_list|(
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|getTombstoneKey
argument_list|()
argument_list|)
block|;
return|return
name|Res
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
argument_list|(
argument|const AssertingVH<T>&Val
argument_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Val
operator|.
name|getRawValPtr
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
argument_list|(
argument|const AssertingVH<T>&LHS
argument_list|,
argument|const AssertingVH<T>&RHS
argument_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|Value
operator|*
operator|>
operator|::
name|isEqual
argument_list|(
name|LHS
operator|.
name|getRawValPtr
argument_list|()
argument_list|,
name|RHS
operator|.
name|getRawValPtr
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|isPodLike
operator|<
name|AssertingVH
operator|<
name|T
operator|>
expr|>
block|{
ifdef|#
directive|ifdef
name|NDEBUG
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;
else|#
directive|else
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;
endif|#
directive|endif
block|}
block|;
comment|/// \brief Value handle that tracks a Value across RAUW.
comment|///
comment|/// TrackingVH is designed for situations where a client needs to hold a handle
comment|/// to a Value (or subclass) across some operations which may move that value,
comment|/// but should never destroy it or replace it with some unacceptable type.
comment|///
comment|/// It is an error to do anything with a TrackingVH whose value has been
comment|/// destroyed, except to destruct it.
comment|///
comment|/// It is an error to attempt to replace a value with one of a type which is
comment|/// incompatible with any of its outstanding TrackingVHs.
name|template
operator|<
name|typename
name|ValueTy
operator|>
name|class
name|TrackingVH
operator|:
name|public
name|ValueHandleBase
block|{
name|void
name|CheckValidity
argument_list|()
specifier|const
block|{
name|Value
operator|*
name|VP
operator|=
name|ValueHandleBase
operator|::
name|getValPtr
argument_list|()
block|;
comment|// Null is always ok.
if|if
condition|(
operator|!
name|VP
condition|)
return|return;
comment|// Check that this value is valid (i.e., it hasn't been deleted). We
comment|// explicitly delay this check until access to avoid requiring clients to be
comment|// unnecessarily careful w.r.t. destruction.
name|assert
argument_list|(
name|ValueHandleBase
operator|::
name|isValid
argument_list|(
name|VP
argument_list|)
operator|&&
literal|"Tracked Value was deleted!"
argument_list|)
block|;
comment|// Check that the value is a member of the correct subclass. We would like
comment|// to check this property on assignment for better debugging, but we don't
comment|// want to require a virtual interface on this VH. Instead we allow RAUW to
comment|// replace this value with a value of an invalid type, and check it here.
name|assert
argument_list|(
name|isa
operator|<
name|ValueTy
operator|>
operator|(
name|VP
operator|)
operator|&&
literal|"Tracked Value was replaced by one with an invalid type!"
argument_list|)
block|;   }
name|ValueTy
operator|*
name|getValPtr
argument_list|()
specifier|const
block|{
name|CheckValidity
argument_list|()
block|;
return|return
operator|(
name|ValueTy
operator|*
operator|)
name|ValueHandleBase
operator|::
name|getValPtr
argument_list|()
return|;
block|}
name|void
name|setValPtr
argument_list|(
argument|ValueTy *P
argument_list|)
block|{
name|CheckValidity
argument_list|()
block|;
name|ValueHandleBase
operator|::
name|operator
operator|=
operator|(
name|GetAsValue
argument_list|(
name|P
argument_list|)
operator|)
block|;   }
comment|// Convert a ValueTy*, which may be const, to the type the base
comment|// class expects.
specifier|static
name|Value
operator|*
name|GetAsValue
argument_list|(
argument|Value *V
argument_list|)
block|{
return|return
name|V
return|;
block|}
specifier|static
name|Value
operator|*
name|GetAsValue
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|Value
operator|*
operator|>
operator|(
name|V
operator|)
return|;
block|}
name|public
operator|:
name|TrackingVH
argument_list|()
operator|:
name|ValueHandleBase
argument_list|(
argument|Tracking
argument_list|)
block|{}
name|TrackingVH
argument_list|(
name|ValueTy
operator|*
name|P
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Tracking
argument_list|,
argument|GetAsValue(P)
argument_list|)
block|{}
name|operator
name|ValueTy
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|*
name|operator
operator|=
operator|(
name|ValueTy
operator|*
name|RHS
operator|)
block|{
name|setValPtr
argument_list|(
name|RHS
argument_list|)
block|;
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
name|ValueTy
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|getValPtr
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Value handle with callbacks on RAUW and destruction.
comment|///
comment|/// This is a value handle that allows subclasses to define callbacks that run
comment|/// when the underlying Value has RAUW called on it or is destroyed.  This
comment|/// class can be used as the key of a map, as long as the user takes it out of
comment|/// the map before calling setValPtr() (since the map has to rearrange itself
comment|/// when the pointer changes).  Unlike ValueHandleBase, this class has a vtable.
name|class
name|CallbackVH
operator|:
name|public
name|ValueHandleBase
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|protected
operator|:
operator|~
name|CallbackVH
argument_list|()
operator|=
expr|default
block|;
name|CallbackVH
argument_list|(
specifier|const
name|CallbackVH
operator|&
argument_list|)
operator|=
expr|default
block|;
name|CallbackVH
operator|&
name|operator
operator|=
operator|(
specifier|const
name|CallbackVH
operator|&
operator|)
operator|=
expr|default
block|;
name|void
name|setValPtr
argument_list|(
argument|Value *P
argument_list|)
block|{
name|ValueHandleBase
operator|::
name|operator
operator|=
operator|(
name|P
operator|)
block|;   }
name|public
operator|:
name|CallbackVH
argument_list|()
operator|:
name|ValueHandleBase
argument_list|(
argument|Callback
argument_list|)
block|{}
name|CallbackVH
argument_list|(
name|Value
operator|*
name|P
argument_list|)
operator|:
name|ValueHandleBase
argument_list|(
argument|Callback
argument_list|,
argument|P
argument_list|)
block|{}
name|operator
name|Value
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
comment|/// \brief Callback for Value destruction.
comment|///
comment|/// Called when this->getValPtr() is destroyed, inside ~Value(), so you
comment|/// may call any non-virtual Value method on getValPtr(), but no subclass
comment|/// methods.  If WeakVH were implemented as a CallbackVH, it would use this
comment|/// method to call setValPtr(NULL).  AssertingVH would use this method to
comment|/// cause an assertion failure.
comment|///
comment|/// All implementations must remove the reference from this object to the
comment|/// Value that's being destroyed.
name|virtual
name|void
name|deleted
argument_list|()
block|{
name|setValPtr
argument_list|(
name|nullptr
argument_list|)
block|; }
comment|/// \brief Callback for Value RAUW.
comment|///
comment|/// Called when this->getValPtr()->replaceAllUsesWith(new_value) is called,
comment|/// _before_ any of the uses have actually been replaced.  If WeakVH were
comment|/// implemented as a CallbackVH, it would use this method to call
comment|/// setValPtr(new_value).  AssertingVH would do nothing in this method.
name|virtual
name|void
name|allUsesReplacedWith
argument_list|(
argument|Value *
argument_list|)
block|{}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

