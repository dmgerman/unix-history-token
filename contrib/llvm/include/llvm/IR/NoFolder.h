begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- NoFolder.h - Constant folding helper ---------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the NoFolder class, a helper for IRBuilder.  It provides
end_comment

begin_comment
comment|// IRBuilder with a set of methods for creating unfolded constants.  This is
end_comment

begin_comment
comment|// useful for learners trying to understand how LLVM IR works, and who don't
end_comment

begin_comment
comment|// want details to be hidden by the constant folder.  For general constant
end_comment

begin_comment
comment|// creation and folding, use ConstantExpr and the routines in
end_comment

begin_comment
comment|// llvm/Analysis/ConstantFolding.h.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note: since it is not actually possible to create unfolded constants, this
end_comment

begin_comment
comment|// class returns instructions rather than constants.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_NOFOLDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_NOFOLDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// NoFolder - Create "constants" (actually, instructions) with no folding.
name|class
name|NoFolder
block|{
name|public
label|:
name|explicit
name|NoFolder
parameter_list|()
block|{}
comment|//===--------------------------------------------------------------------===//
comment|// Binary Operators
comment|//===--------------------------------------------------------------------===//
name|Instruction
modifier|*
name|CreateAdd
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|HasNUW
operator|=
name|false
argument_list|,
name|bool
name|HasNSW
operator|=
name|false
argument_list|)
decl|const
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|BinaryOperator
operator|::
name|CreateAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
name|Instruction
modifier|*
name|CreateNSWAdd
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNSWAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateNUWAdd
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNUWAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFAdd
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFAdd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateSub
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|HasNUW
operator|=
name|false
argument_list|,
name|bool
name|HasNSW
operator|=
name|false
argument_list|)
decl|const
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|BinaryOperator
operator|::
name|CreateSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
name|Instruction
modifier|*
name|CreateNSWSub
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNSWSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateNUWSub
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNUWSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFSub
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFSub
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateMul
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|HasNUW
operator|=
name|false
argument_list|,
name|bool
name|HasNSW
operator|=
name|false
argument_list|)
decl|const
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|BinaryOperator
operator|::
name|CreateMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
name|Instruction
modifier|*
name|CreateNSWMul
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNSWMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateNUWMul
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNUWMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFMul
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFMul
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateUDiv
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|isExact
operator|=
name|false
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|BinaryOperator
operator|::
name|CreateUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
return|return
name|BinaryOperator
operator|::
name|CreateExactUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateExactUDiv
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateExactUDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateSDiv
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|isExact
operator|=
name|false
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|BinaryOperator
operator|::
name|CreateSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
return|return
name|BinaryOperator
operator|::
name|CreateExactSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateExactSDiv
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateExactSDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFDiv
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFDiv
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateURem
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateURem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateSRem
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateSRem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFRem
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFRem
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateShl
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|HasNUW
operator|=
name|false
argument_list|,
name|bool
name|HasNSW
operator|=
name|false
argument_list|)
decl|const
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|BinaryOperator
operator|::
name|CreateShl
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
name|Instruction
modifier|*
name|CreateLShr
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|isExact
operator|=
name|false
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|BinaryOperator
operator|::
name|CreateLShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
return|return
name|BinaryOperator
operator|::
name|CreateExactLShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateAShr
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|,
name|bool
name|isExact
operator|=
name|false
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isExact
condition|)
return|return
name|BinaryOperator
operator|::
name|CreateAShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
return|return
name|BinaryOperator
operator|::
name|CreateExactAShr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateAnd
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateAnd
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateOr
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateOr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateXor
argument_list|(
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateXor
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateBinOp
argument_list|(
name|Instruction
operator|::
name|BinaryOps
name|Opc
argument_list|,
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|Create
argument_list|(
name|Opc
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Unary Operators
comment|//===--------------------------------------------------------------------===//
name|Instruction
modifier|*
name|CreateNeg
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|bool
name|HasNUW
operator|=
name|false
argument_list|,
name|bool
name|HasNSW
operator|=
name|false
argument_list|)
decl|const
block|{
name|BinaryOperator
modifier|*
name|BO
init|=
name|BinaryOperator
operator|::
name|CreateNeg
argument_list|(
name|C
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasNUW
condition|)
name|BO
operator|->
name|setHasNoUnsignedWrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasNSW
condition|)
name|BO
operator|->
name|setHasNoSignedWrap
argument_list|()
expr_stmt|;
return|return
name|BO
return|;
block|}
name|Instruction
modifier|*
name|CreateNSWNeg
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNSWNeg
argument_list|(
name|C
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateNUWNeg
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNUWNeg
argument_list|(
name|C
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFNeg
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateFNeg
argument_list|(
name|C
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateNot
argument_list|(
name|Constant
operator|*
name|C
argument_list|)
decl|const
block|{
return|return
name|BinaryOperator
operator|::
name|CreateNot
argument_list|(
name|C
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Memory Instructions
comment|//===--------------------------------------------------------------------===//
name|Constant
modifier|*
name|CreateGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|ArrayRef
operator|<
name|Constant
operator|*
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|ConstantExpr
operator|::
name|getGetElementPtr
argument_list|(
name|C
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
name|Constant
modifier|*
name|CreateGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Constant
operator|*
name|Idx
argument_list|)
decl|const
block|{
comment|// This form of the function only exists to avoid ambiguous overload
comment|// warnings about whether to convert Idx to ArrayRef<Constant *> or
comment|// ArrayRef<Value *>.
return|return
name|ConstantExpr
operator|::
name|getGetElementPtr
argument_list|(
name|C
argument_list|,
name|Idx
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|GetElementPtrInst
operator|::
name|Create
argument_list|(
name|C
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
name|Constant
modifier|*
name|CreateInBoundsGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|ArrayRef
operator|<
name|Constant
operator|*
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|ConstantExpr
operator|::
name|getInBoundsGetElementPtr
argument_list|(
name|C
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
name|Constant
modifier|*
name|CreateInBoundsGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Constant
operator|*
name|Idx
argument_list|)
decl|const
block|{
comment|// This form of the function only exists to avoid ambiguous overload
comment|// warnings about whether to convert Idx to ArrayRef<Constant *> or
comment|// ArrayRef<Value *>.
return|return
name|ConstantExpr
operator|::
name|getInBoundsGetElementPtr
argument_list|(
name|C
argument_list|,
name|Idx
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateInBoundsGetElementPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|GetElementPtrInst
operator|::
name|CreateInBounds
argument_list|(
name|C
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Cast/Conversion Operators
comment|//===--------------------------------------------------------------------===//
name|Instruction
modifier|*
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|CastOps
name|Op
argument_list|,
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|Create
argument_list|(
name|Op
argument_list|,
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreatePointerCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreatePointerCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateIntCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|,
name|bool
name|isSigned
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreateIntegerCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|,
name|isSigned
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFPCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreateFPCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateBitCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|BitCast
argument_list|,
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateIntToPtr
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|IntToPtr
argument_list|,
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreatePtrToInt
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CreateCast
argument_list|(
name|Instruction
operator|::
name|PtrToInt
argument_list|,
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateZExtOrBitCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreateZExtOrBitCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateSExtOrBitCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreateSExtOrBitCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateTruncOrBitCast
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Type
operator|*
name|DestTy
argument_list|)
decl|const
block|{
return|return
name|CastInst
operator|::
name|CreateTruncOrBitCast
argument_list|(
name|C
argument_list|,
name|DestTy
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Compare Instructions
comment|//===--------------------------------------------------------------------===//
name|Instruction
modifier|*
name|CreateICmp
argument_list|(
name|CmpInst
operator|::
name|Predicate
name|P
argument_list|,
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|new
name|ICmpInst
argument_list|(
name|P
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateFCmp
argument_list|(
name|CmpInst
operator|::
name|Predicate
name|P
argument_list|,
name|Constant
operator|*
name|LHS
argument_list|,
name|Constant
operator|*
name|RHS
argument_list|)
decl|const
block|{
return|return
name|new
name|FCmpInst
argument_list|(
name|P
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Other Instructions
comment|//===--------------------------------------------------------------------===//
name|Instruction
modifier|*
name|CreateSelect
argument_list|(
name|Constant
operator|*
name|C
argument_list|,
name|Constant
operator|*
name|True
argument_list|,
name|Constant
operator|*
name|False
argument_list|)
decl|const
block|{
return|return
name|SelectInst
operator|::
name|Create
argument_list|(
name|C
argument_list|,
name|True
argument_list|,
name|False
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateExtractElement
argument_list|(
name|Constant
operator|*
name|Vec
argument_list|,
name|Constant
operator|*
name|Idx
argument_list|)
decl|const
block|{
return|return
name|ExtractElementInst
operator|::
name|Create
argument_list|(
name|Vec
argument_list|,
name|Idx
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateInsertElement
argument_list|(
name|Constant
operator|*
name|Vec
argument_list|,
name|Constant
operator|*
name|NewElt
argument_list|,
name|Constant
operator|*
name|Idx
argument_list|)
decl|const
block|{
return|return
name|InsertElementInst
operator|::
name|Create
argument_list|(
name|Vec
argument_list|,
name|NewElt
argument_list|,
name|Idx
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateShuffleVector
argument_list|(
name|Constant
operator|*
name|V1
argument_list|,
name|Constant
operator|*
name|V2
argument_list|,
name|Constant
operator|*
name|Mask
argument_list|)
decl|const
block|{
return|return
name|new
name|ShuffleVectorInst
argument_list|(
name|V1
argument_list|,
name|V2
argument_list|,
name|Mask
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateExtractValue
argument_list|(
name|Constant
operator|*
name|Agg
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|ExtractValueInst
operator|::
name|Create
argument_list|(
name|Agg
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
name|Instruction
modifier|*
name|CreateInsertValue
argument_list|(
name|Constant
operator|*
name|Agg
argument_list|,
name|Constant
operator|*
name|Val
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|IdxList
argument_list|)
decl|const
block|{
return|return
name|InsertValueInst
operator|::
name|Create
argument_list|(
name|Agg
argument_list|,
name|Val
argument_list|,
name|IdxList
argument_list|)
return|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

