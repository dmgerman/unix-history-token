begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Declarations for metadata specific to debug info.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_DEBUGINFOMETADATA_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_DEBUGINFOMETADATA_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_comment
comment|// Helper macros for defining get() overrides.
end_comment

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_UNPACK_IMPL
parameter_list|(
modifier|...
parameter_list|)
value|__VA_ARGS__
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_UNPACK
parameter_list|(
name|ARGS
parameter_list|)
value|DEFINE_MDNODE_GET_UNPACK_IMPL ARGS
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
parameter_list|(
name|CLASS
parameter_list|,
name|FORMAL
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static CLASS *getDistinct(LLVMContext&Context,                              \                             DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \   }                                                                            \   static Temp##CLASS getTemporary(LLVMContext&Context,                        \                                   DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \     return Temp##CLASS(                                                        \         getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \   }
end_define

begin_define
define|#
directive|define
name|DEFINE_MDNODE_GET
parameter_list|(
name|CLASS
parameter_list|,
name|FORMAL
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static CLASS *get(LLVMContext&Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \   }                                                                            \   static CLASS *getIfExists(LLVMContext&Context,                              \                             DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \     return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \
comment|/* ShouldCreate */
value|false);                                  \   }                                                                            \   DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// \brief Pointer union between a subclass of DINode and MDString.
comment|///
comment|/// \a DICompositeType can be referenced via an \a MDString unique identifier.
comment|/// This class allows some type safety in the face of that, requiring either a
comment|/// node of a particular type or an \a MDString.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|TypedDINodeRef
block|{
specifier|const
name|Metadata
operator|*
name|MD
operator|=
name|nullptr
block|;
name|public
operator|:
name|TypedDINodeRef
argument_list|()
operator|=
expr|default
block|;
name|TypedDINodeRef
argument_list|(
argument|std::nullptr_t
argument_list|)
block|{}
comment|/// \brief Construct from a raw pointer.
name|explicit
name|TypedDINodeRef
argument_list|(
specifier|const
name|Metadata
operator|*
name|MD
argument_list|)
operator|:
name|MD
argument_list|(
argument|MD
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|MD
operator|||
name|isa
operator|<
name|MDString
operator|>
operator|(
name|MD
operator|)
operator|||
name|isa
operator|<
name|T
operator|>
operator|(
name|MD
operator|)
operator|)
operator|&&
literal|"Expected valid ref"
argument_list|)
block|;   }
name|template
operator|<
name|class
name|U
operator|>
name|TypedDINodeRef
argument_list|(
argument|const TypedDINodeRef<U>&X
argument_list|,
argument|typename std::enable_if<std::is_convertible<U *
argument_list|,
argument|T *>::value>::type * =           nullptr
argument_list|)
operator|:
name|MD
argument_list|(
argument|X
argument_list|)
block|{}
name|operator
name|Metadata
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|MD
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|MD
operator|==
name|X
operator|.
name|MD
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|MD
operator|!=
name|X
operator|.
name|MD
return|;
block|}
comment|/// \brief Create a reference.
comment|///
comment|/// Get a reference to \c N, using an \a MDString reference if available.
specifier|static
name|TypedDINodeRef
name|get
argument_list|(
specifier|const
name|T
operator|*
name|N
argument_list|)
block|;
name|template
operator|<
name|class
name|MapTy
operator|>
name|T
operator|*
name|resolve
argument_list|(
argument|const MapTy&Map
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|MD
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
name|auto
operator|*
name|Typed
operator|=
name|dyn_cast
operator|<
name|T
operator|>
operator|(
name|MD
operator|)
condition|)
return|return
name|const_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Typed
operator|)
return|;
name|auto
operator|*
name|S
operator|=
name|cast
operator|<
name|MDString
operator|>
operator|(
name|MD
operator|)
expr_stmt|;
name|auto
name|I
init|=
name|Map
operator|.
name|find
argument_list|(
name|S
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|Map
operator|.
name|end
argument_list|()
operator|&&
literal|"Missing identifier in type map"
argument_list|)
expr_stmt|;
return|return
name|cast
operator|<
name|T
operator|>
operator|(
name|I
operator|->
name|second
operator|)
return|;
block|}
end_decl_stmt

begin_typedef
unit|};
typedef|typedef
name|TypedDINodeRef
operator|<
name|DINode
operator|>
name|DINodeRef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|TypedDINodeRef
operator|<
name|DIScope
operator|>
name|DIScopeRef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|TypedDINodeRef
operator|<
name|DIType
operator|>
name|DITypeRef
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|DITypeRefArray
block|{
specifier|const
name|MDTuple
modifier|*
name|N
init|=
name|nullptr
decl_stmt|;
name|public
label|:
name|DITypeRefArray
argument_list|()
operator|=
expr|default
expr_stmt|;
name|DITypeRefArray
argument_list|(
specifier|const
name|MDTuple
operator|*
name|N
argument_list|)
operator|:
name|N
argument_list|(
argument|N
argument_list|)
block|{}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|explicit
name|operator
name|MDTuple
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDTuple
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDTuple
operator|*
operator|>
operator|(
name|N
operator|)
return|;
block|}
name|MDTuple
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|MDTuple
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// FIXME: Fix callers and remove condition on N.
end_comment

begin_expr_stmt
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|N
operator|?
name|N
operator|->
name|getNumOperands
argument_list|()
operator|:
literal|0u
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|DITypeRef
name|operator
index|[]
argument_list|(
name|unsigned
name|I
argument_list|)
decl|const
block|{
return|return
name|DITypeRef
argument_list|(
name|N
operator|->
name|getOperand
argument_list|(
name|I
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|class
name|iterator
range|:
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
decl_stmt|,
name|DITypeRef
decl_stmt|,
name|std
decl|::
name|ptrdiff_t
decl_stmt|,
name|void
decl_stmt|,
name|DITypeRef
decl|>
block|{
name|MDNode
operator|::
name|op_iterator
name|I
operator|=
name|nullptr
expr_stmt|;
name|public
label|:
name|iterator
argument_list|()
operator|=
expr|default
expr_stmt|;
name|explicit
name|iterator
argument_list|(
name|MDNode
operator|::
name|op_iterator
name|I
argument_list|)
range|:
name|I
argument_list|(
argument|I
argument_list|)
block|{}
name|DITypeRef
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
operator|*
name|I
argument_list|)
return|;
block|}
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|iterator
name|Temp
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
name|I
block|;
return|return
name|Temp
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|X
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|X
operator|.
name|I
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// FIXME: Fix callers and remove condition on N.
end_comment

begin_expr_stmt
name|iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|N
operator|?
name|iterator
argument_list|(
name|N
operator|->
name|op_begin
argument_list|()
argument_list|)
operator|:
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|N
operator|?
name|iterator
argument_list|(
name|N
operator|->
name|op_end
argument_list|()
argument_list|)
operator|:
name|iterator
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// \brief Tagged DWARF-like metadata node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A metadata node with a DWARF tag (i.e., a constant named \c DW_TAG_*,
end_comment

begin_comment
comment|/// defined in llvm/Support/Dwarf.h).  Called \a DINode because it's
end_comment

begin_comment
comment|/// potentially used for non-DWARF output.
end_comment

begin_decl_stmt
name|class
name|DINode
range|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|protected
operator|:
name|DINode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2 = None
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|assert
argument_list|(
name|Tag
operator|<
literal|1u
operator|<<
literal|16
argument_list|)
block|;
name|SubclassData16
operator|=
name|Tag
block|;   }
operator|~
name|DINode
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|class
name|Ty
operator|>
name|Ty
operator|*
name|getOperandAs
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|Ty
operator|>
operator|(
name|getOperand
argument_list|(
name|I
argument_list|)
operator|)
return|;
block|}
name|StringRef
name|getStringOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|S
operator|=
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
name|I
operator|)
condition|)
return|return
name|S
operator|->
name|getString
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|MDString
modifier|*
name|getCanonicalMDString
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|,
name|StringRef
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|MDString
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|S
argument_list|)
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Debug info flags.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The three accessibility flags are mutually exclusive and rolled together
end_comment

begin_comment
comment|/// in the first two bits.
end_comment

begin_enum
enum|enum
name|DIFlags
block|{
define|#
directive|define
name|HANDLE_DI_FLAG
parameter_list|(
name|ID
parameter_list|,
name|NAME
parameter_list|)
value|Flag##NAME = ID,
include|#
directive|include
file|"llvm/IR/DebugInfoFlags.def"
name|FlagAccessibility
init|=
name|FlagPrivate
operator||
name|FlagProtected
operator||
name|FlagPublic
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|unsigned
name|getFlag
parameter_list|(
name|StringRef
name|Flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getFlagString
parameter_list|(
name|unsigned
name|Flag
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Split up a flags bitfield.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Split \c Flags into \c SplitFlags, a vector of its components.  Returns
end_comment

begin_comment
comment|/// any remaining (unrecognized) bits.
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|splitFlags
argument_list|(
name|unsigned
name|Flags
argument_list|,
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|SplitFlags
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DINodeRef
name|getRef
argument_list|()
specifier|const
block|{
return|return
name|DINodeRef
operator|::
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Metadata
modifier|*
name|MD
parameter_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|GenericDINodeKind
case|:
case|case
name|DISubrangeKind
case|:
case|case
name|DIEnumeratorKind
case|:
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
case|case
name|DIFileKind
case|:
case|case
name|DICompileUnitKind
case|:
case|case
name|DISubprogramKind
case|:
case|case
name|DILexicalBlockKind
case|:
case|case
name|DILexicalBlockFileKind
case|:
case|case
name|DINamespaceKind
case|:
case|case
name|DITemplateTypeParameterKind
case|:
case|case
name|DITemplateValueParameterKind
case|:
case|case
name|DIGlobalVariableKind
case|:
case|case
name|DILocalVariableKind
case|:
case|case
name|DIObjCPropertyKind
case|:
case|case
name|DIImportedEntityKind
case|:
case|case
name|DIModuleKind
case|:
return|return
name|true
return|;
block|}
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|simplify_type
operator|<
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>>
block|{
typedef|typedef
name|Metadata
modifier|*
name|SimpleType
typedef|;
specifier|static
name|SimpleType
name|getSimplifiedValue
argument_list|(
argument|const TypedDINodeRef<T>&MD
argument_list|)
block|{
return|return
name|MD
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|simplify_type
operator|<
name|TypedDINodeRef
operator|<
name|T
operator|>>
operator|:
name|simplify_type
operator|<
specifier|const
name|TypedDINodeRef
operator|<
name|T
operator|>>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Generic tagged DWARF-like metadata node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// An un-specialized DWARF-like metadata node.  The first operand is a
end_comment

begin_comment
comment|/// (possibly empty) null-separated \a MDString header that contains arbitrary
end_comment

begin_comment
comment|/// fields.  The remaining operands are \a dwarf_operands(), and are pointers
end_comment

begin_comment
comment|/// to other metadata.
end_comment

begin_decl_stmt
name|class
name|GenericDINode
range|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|GenericDINode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Hash
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2
argument_list|)
operator|:
name|DINode
argument_list|(
argument|C
argument_list|,
argument|GenericDINodeKind
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|setHash
argument_list|(
name|Hash
argument_list|)
block|;   }
operator|~
name|GenericDINode
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
name|void
name|setHash
argument_list|(
argument|unsigned Hash
argument_list|)
block|{
name|SubclassData32
operator|=
name|Hash
block|; }
name|void
name|recalculateHash
argument_list|()
block|;
specifier|static
name|GenericDINode
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Header
argument_list|,
argument|ArrayRef<Metadata *> DwarfOps
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Header
argument_list|)
argument_list|,
name|DwarfOps
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|GenericDINode
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Header
argument_list|,
argument|ArrayRef<Metadata *> DwarfOps
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempGenericDINode
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getHeader
argument_list|()
argument_list|,
name|SmallVector
operator|<
name|Metadata
operator|*
argument_list|,
literal|4
operator|>
operator|(
name|dwarf_op_begin
argument_list|()
expr|,
name|dwarf_op_end
argument_list|()
operator|)
argument_list|)
return|;
block|}
name|public
operator|:
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
name|DEFINE_MDNODE_GET
argument_list|(
argument|GenericDINode
argument_list|,
argument|(unsigned Tag, StringRef Header,                                     ArrayRef<Metadata *> DwarfOps)
argument_list|,
argument|(Tag, Header, DwarfOps)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|GenericDINode
argument_list|,
argument|(unsigned Tag, MDString *Header,                                     ArrayRef<Metadata *> DwarfOps)
argument_list|,
argument|(Tag, Header, DwarfOps)
argument_list|)
comment|/// \brief Return a (temporary) clone of this.
name|TempGenericDINode
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
name|StringRef
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|op_iterator
name|dwarf_op_begin
argument_list|()
specifier|const
block|{
return|return
name|op_begin
argument_list|()
operator|+
literal|1
return|;
block|}
name|op_iterator
name|dwarf_op_end
argument_list|()
specifier|const
block|{
return|return
name|op_end
argument_list|()
return|;
block|}
name|op_range
name|dwarf_operands
argument_list|()
specifier|const
block|{
return|return
name|op_range
argument_list|(
name|dwarf_op_begin
argument_list|()
argument_list|,
name|dwarf_op_end
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumDwarfOperands
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|-
literal|1
return|;
block|}
specifier|const
name|MDOperand
operator|&
name|getDwarfOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|getOperand
argument_list|(
name|I
operator|+
literal|1
argument_list|)
return|;
block|}
name|void
name|replaceDwarfOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
name|I
operator|+
literal|1
argument_list|,
name|New
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|GenericDINodeKind
return|;
block|}
expr|}
block|;
comment|/// \brief Array subrange.
comment|///
comment|/// TODO: Merge into node for DW_TAG_array_type, which should have a custom
comment|/// type.
name|class
name|DISubrange
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|int64_t
name|Count
block|;
name|int64_t
name|LowerBound
block|;
name|DISubrange
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|int64_t Count
argument_list|,
argument|int64_t LowerBound
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DISubrangeKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_subrange_type
argument_list|,
name|None
argument_list|)
block|,
name|Count
argument_list|(
name|Count
argument_list|)
block|,
name|LowerBound
argument_list|(
argument|LowerBound
argument_list|)
block|{}
operator|~
name|DISubrange
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubrange
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Count
argument_list|,
argument|int64_t LowerBound
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubrange
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getCount
argument_list|()
argument_list|,
name|getLowerBound
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubrange
argument_list|,
argument|(int64_t Count, int64_t LowerBound =
literal|0
argument|)
argument_list|,
argument|(Count, LowerBound)
argument_list|)
name|TempDISubrange
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|int64_t
name|getLowerBound
argument_list|()
specifier|const
block|{
return|return
name|LowerBound
return|;
block|}
name|int64_t
name|getCount
argument_list|()
specifier|const
block|{
return|return
name|Count
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubrangeKind
return|;
block|}
expr|}
block|;
comment|/// \brief Enumeration value.
comment|///
comment|/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no
comment|/// longer creates a type cycle.
name|class
name|DIEnumerator
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|int64_t
name|Value
block|;
name|DIEnumerator
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|int64_t Value
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIEnumeratorKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_enumerator
argument_list|,
name|Ops
argument_list|)
block|,
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
operator|~
name|DIEnumerator
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIEnumerator
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Value
argument_list|,
argument|StringRef Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Value
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIEnumerator
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|int64_t Value
argument_list|,
argument|MDString *Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIEnumerator
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIEnumerator
argument_list|,
argument|(int64_t Value, StringRef Name)
argument_list|,
argument|(Value, Name)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIEnumerator
argument_list|,
argument|(int64_t Value, MDString *Name)
argument_list|,
argument|(Value, Name)
argument_list|)
name|TempDIEnumerator
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIEnumeratorKind
return|;
block|}
expr|}
block|;
comment|/// \brief Base class for scope-like contexts.
comment|///
comment|/// Base class for lexical scopes and types (which are also declaration
comment|/// contexts).
comment|///
comment|/// TODO: Separate the concepts of declaration contexts and lexical scopes.
name|class
name|DIScope
operator|:
name|public
name|DINode
block|{
name|protected
operator|:
name|DIScope
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIScope
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
specifier|inline
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|;
specifier|inline
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|;
comment|/// \brief Return the raw underlying file.
comment|///
comment|/// An \a DIFile is an \a DIScope, but it doesn't point at a separate file
comment|/// (it\em is the file).  If \c this is an \a DIFile, we need to return \c
comment|/// this.  Otherwise, return the first operand, which is where all other
comment|/// subclasses store their file pointer.
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|isa
operator|<
name|DIFile
operator|>
operator|(
name|this
operator|)
operator|?
name|const_cast
operator|<
name|DIScope
operator|*
operator|>
operator|(
name|this
operator|)
operator|:
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
name|DIScopeRef
name|getRef
argument_list|()
specifier|const
block|{
return|return
name|DIScopeRef
operator|::
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
case|case
name|DIFileKind
case|:
case|case
name|DICompileUnitKind
case|:
case|case
name|DISubprogramKind
case|:
case|case
name|DILexicalBlockKind
case|:
case|case
name|DILexicalBlockFileKind
case|:
case|case
name|DINamespaceKind
case|:
case|case
name|DIModuleKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
comment|/// \brief File.
comment|///
comment|/// TODO: Merge with directory/file node (including users).
comment|/// TODO: Canonicalize paths on creation.
name|class
name|DIFile
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DIFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|C
argument_list|,
argument|DIFileKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_file_type
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Filename
argument_list|,
argument|StringRef Directory
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Filename
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Directory
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Filename
argument_list|,
argument|MDString *Directory
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getFilename
argument_list|()
argument_list|,
name|getDirectory
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIFile
argument_list|,
argument|(StringRef Filename, StringRef Directory)
argument_list|,
argument|(Filename, Directory)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIFile
argument_list|,
argument|(MDString * Filename, MDString *Directory)
argument_list|,
argument|(Filename, Directory)
argument_list|)
name|TempDIFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawFilename
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawDirectory
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIFileKind
return|;
block|}
expr|}
block|;
name|StringRef
name|DIScope
operator|::
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|DIScope
operator|::
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
comment|/// \brief Base class for types.
comment|///
comment|/// TODO: Remove the hardcoded name and context, since many types don't use
comment|/// them.
comment|/// TODO: Split up flags.
name|class
name|DIType
operator|:
name|public
name|DIScope
block|{
name|unsigned
name|Line
block|;
name|unsigned
name|Flags
block|;
name|uint64_t
name|SizeInBits
block|;
name|uint64_t
name|AlignInBits
block|;
name|uint64_t
name|OffsetInBits
block|;
name|protected
operator|:
name|DIType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|C
argument_list|,
name|ID
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|SizeInBits
argument_list|(
name|SizeInBits
argument_list|)
block|,
name|AlignInBits
argument_list|(
name|AlignInBits
argument_list|)
block|,
name|OffsetInBits
argument_list|(
argument|OffsetInBits
argument_list|)
block|{}
operator|~
name|DIType
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|TempDIType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|TempDIType
argument_list|(
name|cast
operator|<
name|DIType
operator|>
operator|(
name|MDNode
operator|::
name|clone
argument_list|()
operator|.
name|release
argument_list|()
operator|)
argument_list|)
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|uint64_t
name|getSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|SizeInBits
return|;
block|}
name|uint64_t
name|getAlignInBits
argument_list|()
specifier|const
block|{
return|return
name|AlignInBits
return|;
block|}
name|uint64_t
name|getOffsetInBits
argument_list|()
specifier|const
block|{
return|return
name|OffsetInBits
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|DIScopeRef
argument_list|(
name|getRawScope
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|void
name|setFlags
argument_list|(
argument|unsigned NewFlags
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isUniqued
argument_list|()
operator|&&
literal|"Cannot set flags on uniqued nodes"
argument_list|)
block|;
name|Flags
operator|=
name|NewFlags
block|;   }
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
name|bool
name|isForwardDecl
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagFwdDecl
return|;
block|}
name|bool
name|isAppleBlockExtension
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagAppleBlock
return|;
block|}
name|bool
name|isBlockByrefStruct
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagBlockByrefStruct
return|;
block|}
name|bool
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagVirtual
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
return|;
block|}
name|bool
name|isObjcClassComplete
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjcClassComplete
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagVector
return|;
block|}
name|bool
name|isStaticMember
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagStaticMember
return|;
block|}
name|bool
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
return|;
block|}
name|bool
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
return|;
block|}
name|bool
name|isExternalTypeRef
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagExternalTypeRef
return|;
block|}
name|DITypeRef
name|getRef
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
operator|::
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIBasicTypeKind
case|:
case|case
name|DIDerivedTypeKind
case|:
case|case
name|DICompositeTypeKind
case|:
case|case
name|DISubroutineTypeKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
comment|/// \brief Basic type, like 'int' or 'float'.
comment|///
comment|/// TODO: Split out DW_TAG_unspecified_type.
comment|/// TODO: Drop unused accessors.
name|class
name|DIBasicType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Encoding
block|;
name|DIBasicType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DIBasicTypeKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
literal|0
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Ops
argument_list|)
block|,
name|Encoding
argument_list|(
argument|Encoding
argument_list|)
block|{}
operator|~
name|DIBasicType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIBasicType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|Encoding
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIBasicType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|unsigned Encoding
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIBasicType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getEncoding
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, StringRef Name)
argument_list|,
argument|(Tag, Name,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, StringRef Name, uint64_t SizeInBits,                      uint64_t AlignInBits, unsigned Encoding)
argument_list|,
argument|(Tag, Name, SizeInBits, AlignInBits, Encoding)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIBasicType
argument_list|,
argument|(unsigned Tag, MDString *Name, uint64_t SizeInBits,                      uint64_t AlignInBits, unsigned Encoding)
argument_list|,
argument|(Tag, Name, SizeInBits, AlignInBits, Encoding)
argument_list|)
name|TempDIBasicType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getEncoding
argument_list|()
specifier|const
block|{
return|return
name|Encoding
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIBasicTypeKind
return|;
block|}
expr|}
block|;
comment|/// \brief Derived types.
comment|///
comment|/// This includes qualified types, pointers, references, friends, typedefs, and
comment|/// class members.
comment|///
comment|/// TODO: Split out members (inheritance, fields, methods, etc.).
name|class
name|DIDerivedType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DIDerivedType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
argument|C
argument_list|,
argument|DIDerivedTypeKind
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Line
argument_list|,
argument|SizeInBits
argument_list|,
argument|AlignInBits
argument_list|,
argument|OffsetInBits
argument_list|,
argument|Flags
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIDerivedType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIDerivedType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|DITypeRef BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *ExtraData
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Scope
argument_list|,
name|BaseType
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|ExtraData
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIDerivedType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *ExtraData
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIDerivedType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getBaseType
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getOffsetInBits
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getExtraData
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIDerivedType
argument_list|,
argument|(unsigned Tag, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Scope, Metadata *BaseType,                      uint64_t SizeInBits, uint64_t AlignInBits,                      uint64_t OffsetInBits, unsigned Flags,                      Metadata *ExtraData = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, ExtraData)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIDerivedType
argument_list|,
argument|(unsigned Tag, StringRef Name, DIFile *File, unsigned Line,                      DIScopeRef Scope, DITypeRef BaseType, uint64_t SizeInBits,                      uint64_t AlignInBits, uint64_t OffsetInBits,                      unsigned Flags, Metadata *ExtraData = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, ExtraData)
argument_list|)
name|TempDIDerivedType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|//// Get the base type this is derived from.
name|DITypeRef
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawBaseType
argument_list|()
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawBaseType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
comment|/// \brief Get extra data associated with this derived type.
comment|///
comment|/// Class type for pointer-to-members, objective-c property node for ivars,
comment|/// or global constant wrapper for static members.
comment|///
comment|/// TODO: Separate out types that need this extra operand: pointer-to-member
comment|/// types and member fields (static members and ivars).
name|Metadata
operator|*
name|getExtraData
argument_list|()
specifier|const
block|{
return|return
name|getRawExtraData
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|getRawExtraData
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/// \brief Get casted version of extra data.
comment|/// @{
name|DITypeRef
name|getClassType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_ptr_to_member_type
argument_list|)
block|;
return|return
name|DITypeRef
argument_list|(
name|getExtraData
argument_list|()
argument_list|)
return|;
block|}
name|DIObjCProperty
operator|*
name|getObjCProperty
argument_list|()
specifier|const
block|{
return|return
name|dyn_cast_or_null
operator|<
name|DIObjCProperty
operator|>
operator|(
name|getExtraData
argument_list|()
operator|)
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|&&
name|isStaticMember
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
operator|*
name|C
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getExtraData
argument_list|()
operator|)
condition|)
return|return
name|C
operator|->
name|getValue
argument_list|()
return|;
return|return
name|nullptr
return|;
block|}
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIDerivedTypeKind
return|;
block|}
expr|}
block|;
comment|/// \brief Composite types.
comment|///
comment|/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).
comment|/// TODO: Create a custom, unrelated node for DW_TAG_array_type.
name|class
name|DICompositeType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|RuntimeLang
block|;
name|DICompositeType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
name|C
argument_list|,
name|DICompositeTypeKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Line
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|Ops
argument_list|)
block|,
name|RuntimeLang
argument_list|(
argument|RuntimeLang
argument_list|)
block|{}
operator|~
name|DICompositeType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DICompositeType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|DITypeRef BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|uint64_t Flags
argument_list|,
argument|DINodeArray Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|DITypeRef VTableHolder
argument_list|,
argument|DITemplateParameterArray TemplateParams
argument_list|,
argument|StringRef Identifier
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Scope
argument_list|,
name|BaseType
argument_list|,
name|SizeInBits
argument_list|,
name|AlignInBits
argument_list|,
name|OffsetInBits
argument_list|,
name|Flags
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|,
name|RuntimeLang
argument_list|,
name|VTableHolder
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Identifier
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DICompositeType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *BaseType
argument_list|,
argument|uint64_t SizeInBits
argument_list|,
argument|uint64_t AlignInBits
argument_list|,
argument|uint64_t OffsetInBits
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|unsigned RuntimeLang
argument_list|,
argument|Metadata *VTableHolder
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|MDString *Identifier
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDICompositeType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getBaseType
argument_list|()
argument_list|,
name|getSizeInBits
argument_list|()
argument_list|,
name|getAlignInBits
argument_list|()
argument_list|,
name|getOffsetInBits
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|,
name|getRuntimeLang
argument_list|()
argument_list|,
name|getVTableHolder
argument_list|()
argument_list|,
name|getTemplateParams
argument_list|()
argument_list|,
name|getIdentifier
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DICompositeType
argument_list|,
argument|(unsigned Tag, StringRef Name, DIFile *File, unsigned Line,                      DIScopeRef Scope, DITypeRef BaseType, uint64_t SizeInBits,                      uint64_t AlignInBits, uint64_t OffsetInBits,                      unsigned Flags, DINodeArray Elements, unsigned RuntimeLang,                      DITypeRef VTableHolder,                      DITemplateParameterArray TemplateParams = nullptr,                      StringRef Identifier =
literal|""
argument|)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, Elements, RuntimeLang,                      VTableHolder, TemplateParams, Identifier)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DICompositeType
argument_list|,
argument|(unsigned Tag, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Scope, Metadata *BaseType,                      uint64_t SizeInBits, uint64_t AlignInBits,                      uint64_t OffsetInBits, unsigned Flags, Metadata *Elements,                      unsigned RuntimeLang, Metadata *VTableHolder,                      Metadata *TemplateParams = nullptr,                      MDString *Identifier = nullptr)
argument_list|,
argument|(Tag, Name, File, Line, Scope, BaseType, SizeInBits,                      AlignInBits, OffsetInBits, Flags, Elements, RuntimeLang,                      VTableHolder, TemplateParams, Identifier)
argument_list|)
name|TempDICompositeType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|DITypeRef
name|getBaseType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawBaseType
argument_list|()
argument_list|)
return|;
block|}
name|DINodeArray
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawElements
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getVTableHolder
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawVTableHolder
argument_list|()
argument_list|)
return|;
block|}
name|DITemplateParameterArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTemplateParams
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getIdentifier
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|unsigned
name|getRuntimeLang
argument_list|()
specifier|const
block|{
return|return
name|RuntimeLang
return|;
block|}
name|Metadata
operator|*
name|getRawBaseType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawElements
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawVTableHolder
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawIdentifier
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|7
operator|)
return|;
block|}
comment|/// \brief Replace operands.
comment|///
comment|/// If this \a isUniqued() and not \a isResolved(), on a uniquing collision
comment|/// this will be RAUW'ed and deleted.  Use a \a TrackingMDRef to keep track
comment|/// of its movement if necessary.
comment|/// @{
name|void
name|replaceElements
argument_list|(
argument|DINodeArray Elements
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
name|DINode
modifier|*
name|Op
range|:
name|getElements
argument_list|()
control|)
name|assert
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|Elements
operator|->
name|op_begin
argument_list|()
argument_list|,
name|Elements
operator|->
name|op_end
argument_list|()
argument_list|,
name|Op
argument_list|)
operator|&&
literal|"Lost a member during member list replacement"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|replaceOperandWith
argument_list|(
literal|4
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceVTableHolder
argument_list|(
argument|DITypeRef VTableHolder
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|5
argument_list|,
name|VTableHolder
argument_list|)
block|;   }
name|void
name|replaceTemplateParams
argument_list|(
argument|DITemplateParameterArray TemplateParams
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|6
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DICompositeTypeKind
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|T
operator|>
name|TypedDINodeRef
operator|<
name|T
operator|>
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|::
name|get
argument_list|(
argument|const T *N
argument_list|)
block|{
if|if
condition|(
name|N
condition|)
if|if
condition|(
name|auto
operator|*
name|Composite
operator|=
name|dyn_cast
operator|<
name|DICompositeType
operator|>
operator|(
name|N
operator|)
condition|)
if|if
condition|(
name|auto
operator|*
name|S
operator|=
name|Composite
operator|->
name|getRawIdentifier
argument_list|()
condition|)
return|return
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|(
name|S
operator|)
return|;
return|return
name|TypedDINodeRef
operator|<
name|T
operator|>
operator|(
name|N
operator|)
return|;
block|}
comment|/// \brief Type array for a subprogram.
comment|///
comment|/// TODO: Fold the array of types in directly as operands.
name|class
name|DISubroutineType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DISubroutineType
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIType
argument_list|(
argument|C
argument_list|,
argument|DISubroutineTypeKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_subroutine_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|Flags
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DISubroutineType
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubroutineType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Flags
argument_list|,
argument|DITypeRefArray TypeArray
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Flags
argument_list|,
name|TypeArray
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DISubroutineType
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Flags
argument_list|,
argument|Metadata *TypeArray
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubroutineType
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getTypeArray
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubroutineType
argument_list|,
argument|(unsigned Flags, DITypeRefArray TypeArray)
argument_list|,
argument|(Flags, TypeArray)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubroutineType
argument_list|,
argument|(unsigned Flags, Metadata *TypeArray)
argument_list|,
argument|(Flags, TypeArray)
argument_list|)
name|TempDISubroutineType
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|DITypeRefArray
name|getTypeArray
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTypeArray
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawTypeArray
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubroutineTypeKind
return|;
block|}
expr|}
block|;
comment|/// \brief Compile unit.
name|class
name|DICompileUnit
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|SourceLanguage
block|;
name|bool
name|IsOptimized
block|;
name|unsigned
name|RuntimeVersion
block|;
name|unsigned
name|EmissionKind
block|;
name|uint64_t
name|DWOId
block|;
name|DICompileUnit
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|C
argument_list|,
name|DICompileUnitKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_compile_unit
argument_list|,
name|Ops
argument_list|)
block|,
name|SourceLanguage
argument_list|(
name|SourceLanguage
argument_list|)
block|,
name|IsOptimized
argument_list|(
name|IsOptimized
argument_list|)
block|,
name|RuntimeVersion
argument_list|(
name|RuntimeVersion
argument_list|)
block|,
name|EmissionKind
argument_list|(
name|EmissionKind
argument_list|)
block|,
name|DWOId
argument_list|(
argument|DWOId
argument_list|)
block|{
name|assert
argument_list|(
name|Storage
operator|!=
name|Uniqued
argument_list|)
block|;   }
operator|~
name|DICompileUnit
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DICompileUnit
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|DIFile *File
argument_list|,
argument|StringRef Producer
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|StringRef Flags
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|StringRef SplitDebugFilename
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|DICompositeTypeArray EnumTypes
argument_list|,
argument|DITypeArray RetainedTypes
argument_list|,
argument|DISubprogramArray Subprograms
argument_list|,
argument|DIGlobalVariableArray GlobalVariables
argument_list|,
argument|DIImportedEntityArray ImportedEntities
argument_list|,
argument|DIMacroNodeArray Macros
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|SourceLanguage
argument_list|,
name|File
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Producer
argument_list|)
argument_list|,
name|IsOptimized
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Flags
argument_list|)
argument_list|,
name|RuntimeVersion
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|SplitDebugFilename
argument_list|)
argument_list|,
name|EmissionKind
argument_list|,
name|EnumTypes
operator|.
name|get
argument_list|()
argument_list|,
name|RetainedTypes
operator|.
name|get
argument_list|()
argument_list|,
name|Subprograms
operator|.
name|get
argument_list|()
argument_list|,
name|GlobalVariables
operator|.
name|get
argument_list|()
argument_list|,
name|ImportedEntities
operator|.
name|get
argument_list|()
argument_list|,
name|Macros
operator|.
name|get
argument_list|()
argument_list|,
name|DWOId
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DICompileUnit
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned SourceLanguage
argument_list|,
argument|Metadata *File
argument_list|,
argument|MDString *Producer
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|MDString *Flags
argument_list|,
argument|unsigned RuntimeVersion
argument_list|,
argument|MDString *SplitDebugFilename
argument_list|,
argument|unsigned EmissionKind
argument_list|,
argument|Metadata *EnumTypes
argument_list|,
argument|Metadata *RetainedTypes
argument_list|,
argument|Metadata *Subprograms
argument_list|,
argument|Metadata *GlobalVariables
argument_list|,
argument|Metadata *ImportedEntities
argument_list|,
argument|Metadata *Macros
argument_list|,
argument|uint64_t DWOId
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDICompileUnit
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getSourceLanguage
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getProducer
argument_list|()
argument_list|,
name|isOptimized
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getRuntimeVersion
argument_list|()
argument_list|,
name|getSplitDebugFilename
argument_list|()
argument_list|,
name|getEmissionKind
argument_list|()
argument_list|,
name|getEnumTypes
argument_list|()
argument_list|,
name|getRetainedTypes
argument_list|()
argument_list|,
name|getSubprograms
argument_list|()
argument_list|,
name|getGlobalVariables
argument_list|()
argument_list|,
name|getImportedEntities
argument_list|()
argument_list|,
name|getMacros
argument_list|()
argument_list|,
name|DWOId
argument_list|)
return|;
block|}
specifier|static
name|void
name|get
argument_list|()
operator|=
name|delete
block|;
specifier|static
name|void
name|getIfExists
argument_list|()
operator|=
name|delete
block|;
name|public
operator|:
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
argument_list|(
argument|DICompileUnit
argument_list|,
argument|(unsigned SourceLanguage, DIFile *File, StringRef Producer,        bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,        StringRef SplitDebugFilename, unsigned EmissionKind,        DICompositeTypeArray EnumTypes, DITypeArray RetainedTypes,        DISubprogramArray Subprograms, DIGlobalVariableArray GlobalVariables,        DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,        uint64_t DWOId)
argument_list|,
argument|(SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,        SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes, Subprograms,        GlobalVariables, ImportedEntities, Macros, DWOId)
argument_list|)
name|DEFINE_MDNODE_GET_DISTINCT_TEMPORARY
argument_list|(
argument|DICompileUnit
argument_list|,
argument|(unsigned SourceLanguage, Metadata *File, MDString *Producer,        bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,        MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,        Metadata *RetainedTypes, Metadata *Subprograms,        Metadata *GlobalVariables, Metadata *ImportedEntities, Metadata *Macros,        uint64_t DWOId)
argument_list|,
argument|(SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,        SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes, Subprograms,        GlobalVariables, ImportedEntities, Macros, DWOId)
argument_list|)
name|TempDICompileUnit
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getSourceLanguage
argument_list|()
specifier|const
block|{
return|return
name|SourceLanguage
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|IsOptimized
return|;
block|}
name|unsigned
name|getRuntimeVersion
argument_list|()
specifier|const
block|{
return|return
name|RuntimeVersion
return|;
block|}
name|unsigned
name|getEmissionKind
argument_list|()
specifier|const
block|{
return|return
name|EmissionKind
return|;
block|}
name|StringRef
name|getProducer
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|DICompositeTypeArray
name|getEnumTypes
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawEnumTypes
argument_list|()
operator|)
return|;
block|}
name|DITypeArray
name|getRetainedTypes
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawRetainedTypes
argument_list|()
operator|)
return|;
block|}
name|DISubprogramArray
name|getSubprograms
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawSubprograms
argument_list|()
operator|)
return|;
block|}
name|DIGlobalVariableArray
name|getGlobalVariables
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawGlobalVariables
argument_list|()
operator|)
return|;
block|}
name|DIImportedEntityArray
name|getImportedEntities
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawImportedEntities
argument_list|()
operator|)
return|;
block|}
name|DIMacroNodeArray
name|getMacros
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawMacros
argument_list|()
operator|)
return|;
block|}
name|uint64_t
name|getDWOId
argument_list|()
specifier|const
block|{
return|return
name|DWOId
return|;
block|}
name|void
name|setDWOId
argument_list|(
argument|uint64_t DwoId
argument_list|)
block|{
name|DWOId
operator|=
name|DwoId
block|; }
name|MDString
operator|*
name|getRawProducer
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawFlags
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawEnumTypes
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawRetainedTypes
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawSubprograms
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawGlobalVariables
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawImportedEntities
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|8
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawMacros
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|9
argument_list|)
return|;
block|}
comment|/// \brief Replace arrays.
comment|///
comment|/// If this \a isUniqued() and not \a isResolved(), it will be RAUW'ed and
comment|/// deleted on a uniquing collision.  In practice, uniquing collisions on \a
comment|/// DICompileUnit should be fairly rare.
comment|/// @{
name|void
name|replaceEnumTypes
argument_list|(
argument|DICompositeTypeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|4
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceRetainedTypes
argument_list|(
argument|DITypeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|5
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceSubprograms
argument_list|(
argument|DISubprogramArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|6
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceGlobalVariables
argument_list|(
argument|DIGlobalVariableArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|7
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceImportedEntities
argument_list|(
argument|DIImportedEntityArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|8
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|void
name|replaceMacros
argument_list|(
argument|DIMacroNodeArray N
argument_list|)
block|{
name|replaceOperandWith
argument_list|(
literal|9
argument_list|,
name|N
operator|.
name|get
argument_list|()
argument_list|)
block|; }
comment|/// @}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DICompileUnitKind
return|;
block|}
expr|}
block|;
comment|/// \brief A scope for locals.
comment|///
comment|/// A legal scope for lexical blocks, local variables, and debug info
comment|/// locations.  Subclasses are \a DISubprogram, \a DILexicalBlock, and \a
comment|/// DILexicalBlockFile.
name|class
name|DILocalScope
operator|:
name|public
name|DIScope
block|{
name|protected
operator|:
name|DILocalScope
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DILocalScope
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
comment|/// \brief Get the subprogram for this scope.
comment|///
comment|/// Return this if it's an \a DISubprogram; otherwise, look up the scope
comment|/// chain.
name|DISubprogram
operator|*
name|getSubprogram
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubprogramKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
comment|/// \brief Debug location.
comment|///
comment|/// A debug location in source code, used for debug info and otherwise.
name|class
name|DILocation
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DILocation
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|ArrayRef<Metadata *> MDs
argument_list|)
block|;
operator|~
name|DILocation
argument_list|()
block|{
name|dropAllReferences
argument_list|()
block|; }
specifier|static
name|DILocation
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *InlinedAt
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
specifier|static
name|DILocation
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DILocation *InlinedAt
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|InlinedAt
operator|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
name|TempDILocation
name|cloneImpl
argument_list|()
specifier|const
block|{
comment|// Get the raw scope/inlinedAt since it is possible to invoke this on
comment|// a DILocation containing temporary metadata.
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getColumn
argument_list|()
argument_list|,
name|getRawScope
argument_list|()
argument_list|,
name|getRawInlinedAt
argument_list|()
argument_list|)
return|;
block|}
comment|// Disallow replacing operands.
name|void
name|replaceOperandWith
argument_list|(
argument|unsigned I
argument_list|,
argument|Metadata *New
argument_list|)
operator|=
name|delete
block|;
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocation
argument_list|,
argument|(unsigned Line, unsigned Column, Metadata *Scope,                      Metadata *InlinedAt = nullptr)
argument_list|,
argument|(Line, Column, Scope, InlinedAt)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocation
argument_list|,
argument|(unsigned Line, unsigned Column, DILocalScope *Scope,                      DILocation *InlinedAt = nullptr)
argument_list|,
argument|(Line, Column, Scope, InlinedAt)
argument_list|)
comment|/// \brief Return a (temporary) clone of this.
name|TempDILocation
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|SubclassData32
return|;
block|}
name|unsigned
name|getColumn
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|DILocation
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DILocation
operator|>
operator|(
name|getRawInlinedAt
argument_list|()
operator|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getFile
argument_list|()
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|->
name|getDirectory
argument_list|()
return|;
block|}
comment|/// \brief Get the scope where this is inlined.
comment|///
comment|/// Walk through \a getInlinedAt() and return \a getScope() from the deepest
comment|/// location.
name|DILocalScope
operator|*
name|getInlinedAtScope
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|IA
operator|=
name|getInlinedAt
argument_list|()
condition|)
return|return
name|IA
operator|->
name|getInlinedAtScope
argument_list|()
return|;
return|return
name|getScope
argument_list|()
return|;
block|}
comment|/// \brief Check whether this can be discriminated from another location.
comment|///
comment|/// Check \c this can be discriminated from \c RHS in a linetable entry.
comment|/// Scope and inlined-at chains are not recorded in the linetable, so they
comment|/// cannot be used to distinguish basic blocks.
comment|///
comment|/// The current implementation is weaker than it should be, since it just
comment|/// checks filename and line.
comment|///
comment|/// FIXME: Add a check for getDiscriminator().
comment|/// FIXME: Add a check for getColumn().
comment|/// FIXME: Change the getFilename() check to getFile() (or add one for
comment|/// getDirectory()).
name|bool
name|canDiscriminate
argument_list|(
argument|const DILocation&RHS
argument_list|)
specifier|const
block|{
return|return
name|getFilename
argument_list|()
operator|!=
name|RHS
operator|.
name|getFilename
argument_list|()
operator|||
name|getLine
argument_list|()
operator|!=
name|RHS
operator|.
name|getLine
argument_list|()
return|;
block|}
comment|/// \brief Get the DWARF discriminator.
comment|///
comment|/// DWARF discriminators distinguish identical file locations between
comment|/// instructions that are on different basic blocks.
specifier|inline
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|;
comment|/// \brief Compute new discriminator in the given context.
comment|///
comment|/// This modifies the \a LLVMContext that \c this is in to increment the next
comment|/// discriminator for \c this's line/filename combination.
comment|///
comment|/// FIXME: Delete this.  See comments in implementation and at the only call
comment|/// site in \a AddDiscriminators::runOnFunction().
name|unsigned
name|computeNewDiscriminator
argument_list|()
specifier|const
block|;
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawInlinedAt
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getNumOperands
argument_list|()
operator|==
literal|2
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocationKind
return|;
block|}
expr|}
block|;
comment|/// \brief Subprogram description.
comment|///
comment|/// TODO: Remove DisplayName.  It's always equal to Name.
comment|/// TODO: Split up flags.
name|class
name|DISubprogram
operator|:
name|public
name|DILocalScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|unsigned
name|ScopeLine
block|;
name|unsigned
name|Virtuality
block|;
name|unsigned
name|VirtualIndex
block|;
name|unsigned
name|Flags
block|;
name|bool
name|IsLocalToUnit
block|;
name|bool
name|IsDefinition
block|;
name|bool
name|IsOptimized
block|;
name|DISubprogram
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|unsigned Flags
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILocalScope
argument_list|(
name|C
argument_list|,
name|DISubprogramKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_subprogram
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|ScopeLine
argument_list|(
name|ScopeLine
argument_list|)
block|,
name|Virtuality
argument_list|(
name|Virtuality
argument_list|)
block|,
name|VirtualIndex
argument_list|(
name|VirtualIndex
argument_list|)
block|,
name|Flags
argument_list|(
name|Flags
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
name|IsDefinition
argument_list|)
block|,
name|IsOptimized
argument_list|(
argument|IsOptimized
argument_list|)
block|{}
operator|~
name|DISubprogram
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DISubprogram
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScopeRef Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef LinkageName
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DISubroutineType *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|DITypeRef ContainingType
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|unsigned Flags
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|DITemplateParameterArray TemplateParams
argument_list|,
argument|DISubprogram *Declaration
argument_list|,
argument|DILocalVariableArray Variables
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|LinkageName
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|IsLocalToUnit
argument_list|,
name|IsDefinition
argument_list|,
name|ScopeLine
argument_list|,
name|ContainingType
argument_list|,
name|Virtuality
argument_list|,
name|VirtualIndex
argument_list|,
name|Flags
argument_list|,
name|IsOptimized
argument_list|,
name|TemplateParams
operator|.
name|get
argument_list|()
argument_list|,
name|Declaration
argument_list|,
name|Variables
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DISubprogram
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|unsigned ScopeLine
argument_list|,
argument|Metadata *ContainingType
argument_list|,
argument|unsigned Virtuality
argument_list|,
argument|unsigned VirtualIndex
argument_list|,
argument|unsigned Flags
argument_list|,
argument|bool IsOptimized
argument_list|,
argument|Metadata *TemplateParams
argument_list|,
argument|Metadata *Declaration
argument_list|,
argument|Metadata *Variables
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDISubprogram
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getLinkageName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|isLocalToUnit
argument_list|()
argument_list|,
name|isDefinition
argument_list|()
argument_list|,
name|getScopeLine
argument_list|()
argument_list|,
name|getContainingType
argument_list|()
argument_list|,
name|getVirtuality
argument_list|()
argument_list|,
name|getVirtualIndex
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|isOptimized
argument_list|()
argument_list|,
name|getTemplateParams
argument_list|()
argument_list|,
name|getDeclaration
argument_list|()
argument_list|,
name|getVariables
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubprogram
argument_list|,
argument|(DIScopeRef Scope, StringRef Name, StringRef LinkageName,                      DIFile *File, unsigned Line, DISubroutineType *Type,                      bool IsLocalToUnit, bool IsDefinition, unsigned ScopeLine,                      DITypeRef ContainingType, unsigned Virtuality,                      unsigned VirtualIndex, unsigned Flags, bool IsOptimized,                      DITemplateParameterArray TemplateParams = nullptr,                      DISubprogram *Declaration = nullptr,                      DILocalVariableArray Variables = nullptr)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, ScopeLine, ContainingType, Virtuality,                      VirtualIndex, Flags, IsOptimized, TemplateParams,                      Declaration, Variables)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DISubprogram
argument_list|,
argument|(Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,        unsigned Line, Metadata *Type, bool IsLocalToUnit, bool IsDefinition,        unsigned ScopeLine, Metadata *ContainingType, unsigned Virtuality,        unsigned VirtualIndex, unsigned Flags, bool IsOptimized,        Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,        Metadata *Variables = nullptr)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit, IsDefinition,        ScopeLine, ContainingType, Virtuality, VirtualIndex, Flags, IsOptimized,        TemplateParams, Declaration, Variables)
argument_list|)
name|TempDISubprogram
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|public
operator|:
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getVirtuality
argument_list|()
specifier|const
block|{
return|return
name|Virtuality
return|;
block|}
name|unsigned
name|getVirtualIndex
argument_list|()
specifier|const
block|{
return|return
name|VirtualIndex
return|;
block|}
name|unsigned
name|getScopeLine
argument_list|()
specifier|const
block|{
return|return
name|ScopeLine
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|bool
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|IsLocalToUnit
return|;
block|}
name|bool
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|IsDefinition
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|IsOptimized
return|;
block|}
name|unsigned
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
name|bool
name|isExplicit
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagExplicit
return|;
block|}
name|bool
name|isPrototyped
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagPrototyped
return|;
block|}
comment|/// \brief Check if this is reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 reference-qualified non-static
comment|/// member function (void foo()&).
name|unsigned
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
return|;
block|}
comment|/// \brief Check if this is rvalue-reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 rvalue-reference-qualified
comment|/// non-static member function (void foo()&&).
name|unsigned
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
return|;
block|}
name|DIScopeRef
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|DIScopeRef
argument_list|(
name|getRawScope
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|4
operator|)
return|;
block|}
name|DISubroutineType
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DISubroutineType
operator|>
operator|(
name|getRawType
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawContainingType
argument_list|()
argument_list|)
return|;
block|}
name|DITemplateParameterArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawTemplateParams
argument_list|()
operator|)
return|;
block|}
name|DISubprogram
operator|*
name|getDeclaration
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DISubprogram
operator|>
operator|(
name|getRawDeclaration
argument_list|()
operator|)
return|;
block|}
name|DILocalVariableArray
name|getVariables
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawVariables
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawContainingType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|8
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawVariables
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|9
argument_list|)
return|;
block|}
comment|/// \brief Check if this subprogram describes the given function.
comment|///
comment|/// FIXME: Should this be looking through bitcasts?
name|bool
name|describes
argument_list|(
argument|const Function *F
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DISubprogramKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlockBase
operator|:
name|public
name|DILocalScope
block|{
name|protected
operator|:
name|DILexicalBlockBase
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILocalScope
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_lexical_block
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DILexicalBlockBase
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlock
operator|:
name|public
name|DILexicalBlockBase
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|uint16_t
name|Column
block|;
name|DILexicalBlock
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILexicalBlockBase
argument_list|(
name|C
argument_list|,
name|DILexicalBlockKind
argument_list|,
name|Storage
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Column
argument_list|(
argument|Column
argument_list|)
block|{
name|assert
argument_list|(
name|Column
operator|<
operator|(
literal|1u
operator|<<
literal|16
operator|)
operator|&&
literal|"Expected 16-bit column"
argument_list|)
block|;   }
operator|~
name|DILexicalBlock
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILexicalBlock
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Line
argument_list|,
name|Column
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILexicalBlock
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Column
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILexicalBlock
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlock
argument_list|,
argument|(DILocalScope * Scope, DIFile *File,                                      unsigned Line, unsigned Column)
argument_list|,
argument|(Scope, File, Line, Column)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlock
argument_list|,
argument|(Metadata * Scope, Metadata *File,                                      unsigned Line, unsigned Column)
argument_list|,
argument|(Scope, File, Line, Column)
argument_list|)
name|TempDILexicalBlock
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getColumn
argument_list|()
specifier|const
block|{
return|return
name|Column
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockKind
return|;
block|}
expr|}
block|;
name|class
name|DILexicalBlockFile
operator|:
name|public
name|DILexicalBlockBase
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Discriminator
block|;
name|DILexicalBlockFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DILexicalBlockBase
argument_list|(
name|C
argument_list|,
name|DILexicalBlockFileKind
argument_list|,
name|Storage
argument_list|,
name|Ops
argument_list|)
block|,
name|Discriminator
argument_list|(
argument|Discriminator
argument_list|)
block|{}
operator|~
name|DILexicalBlockFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILexicalBlockFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DILocalScope *Scope
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Scope
operator|)
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Discriminator
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILexicalBlockFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Discriminator
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILexicalBlockFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getDiscriminator
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlockFile
argument_list|,
argument|(DILocalScope * Scope, DIFile *File,                                          unsigned Discriminator)
argument_list|,
argument|(Scope, File, Discriminator)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILexicalBlockFile
argument_list|,
argument|(Metadata * Scope, Metadata *File, unsigned Discriminator)
argument_list|,
argument|(Scope, File, Discriminator)
argument_list|)
name|TempDILexicalBlockFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|// TODO: Remove these once they're gone from DILexicalBlockBase.
name|unsigned
name|getLine
argument_list|()
specifier|const
operator|=
name|delete
block|;
name|unsigned
name|getColumn
argument_list|()
specifier|const
operator|=
name|delete
block|;
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|{
return|return
name|Discriminator
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILexicalBlockFileKind
return|;
block|}
expr|}
block|;
name|unsigned
name|DILocation
operator|::
name|getDiscriminator
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|dyn_cast
operator|<
name|DILexicalBlockFile
operator|>
operator|(
name|getScope
argument_list|()
operator|)
condition|)
return|return
name|F
operator|->
name|getDiscriminator
argument_list|()
return|;
return|return
literal|0
return|;
block|}
name|class
name|DINamespace
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DINamespace
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
name|Context
argument_list|,
name|DINamespaceKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_namespace
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DINamespace
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DINamespace
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|DIFile *File
argument_list|,
argument|StringRef Name
argument_list|,
argument|unsigned Line
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|File
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Line
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DINamespace
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *File
argument_list|,
argument|MDString *Name
argument_list|,
argument|unsigned Line
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDINamespace
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DINamespace
argument_list|,
argument|(DIScope * Scope, DIFile *File, StringRef Name,                                   unsigned Line)
argument_list|,
argument|(Scope, File, Name, Line)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DINamespace
argument_list|,
argument|(Metadata * Scope, Metadata *File,                                   MDString *Name, unsigned Line)
argument_list|,
argument|(Scope, File, Name, Line)
argument_list|)
name|TempDINamespace
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DINamespaceKind
return|;
block|}
expr|}
block|;
comment|/// \brief A (clang) module that has been imported by the compile unit.
comment|///
name|class
name|DIModule
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DIModule
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|Context
argument_list|,
argument|DIModuleKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_module
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DIModule
argument_list|()
block|{}
specifier|static
name|DIModule
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef ConfigurationMacros
argument_list|,
argument|StringRef IncludePath
argument_list|,
argument|StringRef ISysRoot
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|ConfigurationMacros
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|IncludePath
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|ISysRoot
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIModule
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *ConfigurationMacros
argument_list|,
argument|MDString *IncludePath
argument_list|,
argument|MDString *ISysRoot
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIModule
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getConfigurationMacros
argument_list|()
argument_list|,
name|getIncludePath
argument_list|()
argument_list|,
name|getISysRoot
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIModule
argument_list|,
argument|(DIScope *Scope, StringRef Name,                                StringRef ConfigurationMacros, StringRef IncludePath,                                StringRef ISysRoot)
argument_list|,
argument|(Scope, Name, ConfigurationMacros, IncludePath, ISysRoot)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIModule
argument_list|,
argument|(Metadata *Scope, MDString *Name, MDString *ConfigurationMacros,                      MDString *IncludePath, MDString *ISysRoot)
argument_list|,
argument|(Scope, Name, ConfigurationMacros, IncludePath, ISysRoot)
argument_list|)
name|TempDIModule
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getConfigurationMacros
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getIncludePath
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getISysRoot
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawConfigurationMacros
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawIncludePath
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawISysRoot
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|4
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIModuleKind
return|;
block|}
expr|}
block|;
comment|/// \brief Base class for template parameters.
name|class
name|DITemplateParameter
operator|:
name|public
name|DINode
block|{
name|protected
operator|:
name|DITemplateParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
argument|Context
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateParameter
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateTypeParameterKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateValueParameterKind
return|;
block|}
expr|}
block|;
name|class
name|DITemplateTypeParameter
operator|:
name|public
name|DITemplateParameter
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DITemplateTypeParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DITemplateParameter
argument_list|(
argument|Context
argument_list|,
argument|DITemplateTypeParameterKind
argument_list|,
argument|Storage
argument_list|,
argument|dwarf::DW_TAG_template_type_parameter
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateTypeParameter
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DITemplateTypeParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Name
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Type
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DITemplateTypeParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDITemplateTypeParameter
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateTypeParameter
argument_list|,
argument|(StringRef Name, DITypeRef Type)
argument_list|,
argument|(Name, Type)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateTypeParameter
argument_list|,
argument|(MDString * Name, Metadata *Type)
argument_list|,
argument|(Name, Type)
argument_list|)
name|TempDITemplateTypeParameter
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateTypeParameterKind
return|;
block|}
expr|}
block|;
name|class
name|DITemplateValueParameter
operator|:
name|public
name|DITemplateParameter
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|DITemplateValueParameter
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DITemplateParameter
argument_list|(
argument|Context
argument_list|,
argument|DITemplateValueParameterKind
argument_list|,
argument|Storage
argument_list|,
argument|Tag
argument_list|,
argument|Ops
argument_list|)
block|{}
operator|~
name|DITemplateValueParameter
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DITemplateValueParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|StringRef Name
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|Metadata *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DITemplateValueParameter
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *Type
argument_list|,
argument|Metadata *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDITemplateValueParameter
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateValueParameter
argument_list|,
argument|(unsigned Tag, StringRef Name,                                                DITypeRef Type, Metadata *Value)
argument_list|,
argument|(Tag, Name, Type, Value)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DITemplateValueParameter
argument_list|,
argument|(unsigned Tag, MDString *Name,                                                Metadata *Type, Metadata *Value)
argument_list|,
argument|(Tag, Name, Type, Value)
argument_list|)
name|TempDITemplateValueParameter
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|Metadata
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DITemplateValueParameterKind
return|;
block|}
expr|}
block|;
comment|/// \brief Base class for variables.
name|class
name|DIVariable
operator|:
name|public
name|DINode
block|{
name|unsigned
name|Line
block|;
name|protected
operator|:
name|DIVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|ID
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_variable
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIVariable
argument_list|()
operator|=
expr|default
block|;
name|public
operator|:
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocalVariableKind
operator|||
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIGlobalVariableKind
return|;
block|}
expr|}
block|;
comment|/// \brief Global variables.
comment|///
comment|/// TODO: Remove DisplayName.  It's always equal to Name.
name|class
name|DIGlobalVariable
operator|:
name|public
name|DIVariable
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|bool
name|IsLocalToUnit
block|;
name|bool
name|IsDefinition
block|;
name|DIGlobalVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIVariable
argument_list|(
name|C
argument_list|,
name|DIGlobalVariableKind
argument_list|,
name|Storage
argument_list|,
name|Line
argument_list|,
name|Ops
argument_list|)
block|,
name|IsLocalToUnit
argument_list|(
name|IsLocalToUnit
argument_list|)
block|,
name|IsDefinition
argument_list|(
argument|IsDefinition
argument_list|)
block|{}
operator|~
name|DIGlobalVariable
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIGlobalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef LinkageName
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|Constant *Variable
argument_list|,
argument|DIDerivedType *StaticDataMemberDeclaration
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|LinkageName
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|IsLocalToUnit
argument_list|,
name|IsDefinition
argument_list|,
name|Variable
operator|?
name|ConstantAsMetadata
operator|::
name|get
argument_list|(
name|Variable
argument_list|)
operator|:
name|nullptr
argument_list|,
name|StaticDataMemberDeclaration
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIGlobalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *LinkageName
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|bool IsLocalToUnit
argument_list|,
argument|bool IsDefinition
argument_list|,
argument|Metadata *Variable
argument_list|,
argument|Metadata *StaticDataMemberDeclaration
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIGlobalVariable
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getLinkageName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|isLocalToUnit
argument_list|()
argument_list|,
name|isDefinition
argument_list|()
argument_list|,
name|getVariable
argument_list|()
argument_list|,
name|getStaticDataMemberDeclaration
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIGlobalVariable
argument_list|,
argument|(DIScope * Scope, StringRef Name, StringRef LinkageName,                      DIFile *File, unsigned Line, DITypeRef Type,                      bool IsLocalToUnit, bool IsDefinition, Constant *Variable,                      DIDerivedType *StaticDataMemberDeclaration)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, Variable, StaticDataMemberDeclaration)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIGlobalVariable
argument_list|,
argument|(Metadata * Scope, MDString *Name, MDString *LinkageName,                      Metadata *File, unsigned Line, Metadata *Type,                      bool IsLocalToUnit, bool IsDefinition, Metadata *Variable,                      Metadata *StaticDataMemberDeclaration)
argument_list|,
argument|(Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,                      IsDefinition, Variable, StaticDataMemberDeclaration)
argument_list|)
name|TempDIGlobalVariable
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|bool
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|IsLocalToUnit
return|;
block|}
name|bool
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|IsDefinition
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|Constant
operator|*
name|getVariable
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|C
operator|=
name|cast_or_null
operator|<
name|ConstantAsMetadata
operator|>
operator|(
name|getRawVariable
argument_list|()
operator|)
condition|)
return|return
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|C
operator|->
name|getValue
argument_list|()
operator|)
return|;
return|return
name|nullptr
return|;
block|}
name|DIDerivedType
operator|*
name|getStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIDerivedType
operator|>
operator|(
name|getRawStaticDataMemberDeclaration
argument_list|()
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawVariable
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|7
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIGlobalVariableKind
return|;
block|}
expr|}
block|;
comment|/// \brief Local variable.
comment|///
comment|/// TODO: Split up flags.
name|class
name|DILocalVariable
operator|:
name|public
name|DIVariable
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Arg
block|;
name|unsigned
name|Flags
block|;
name|DILocalVariable
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Arg
argument_list|,
argument|unsigned Flags
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIVariable
argument_list|(
name|C
argument_list|,
name|DILocalVariableKind
argument_list|,
name|Storage
argument_list|,
name|Line
argument_list|,
name|Ops
argument_list|)
block|,
name|Arg
argument_list|(
name|Arg
argument_list|)
block|,
name|Flags
argument_list|(
argument|Flags
argument_list|)
block|{}
operator|~
name|DILocalVariable
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DILocalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|unsigned Arg
argument_list|,
argument|unsigned Flags
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Scope
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|Type
argument_list|,
name|Arg
argument_list|,
name|Flags
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DILocalVariable
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *Type
argument_list|,
argument|unsigned Arg
argument_list|,
argument|unsigned Flags
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDILocalVariable
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|,
name|getArg
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocalVariable
argument_list|,
argument|(DILocalScope * Scope, StringRef Name, DIFile *File,                      unsigned Line, DITypeRef Type, unsigned Arg,                      unsigned Flags)
argument_list|,
argument|(Scope, Name, File, Line, Type, Arg, Flags)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DILocalVariable
argument_list|,
argument|(Metadata * Scope, MDString *Name, Metadata *File,                      unsigned Line, Metadata *Type, unsigned Arg,                      unsigned Flags)
argument_list|,
argument|(Scope, Name, File, Line, Type, Arg, Flags)
argument_list|)
name|TempDILocalVariable
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
comment|/// \brief Get the local scope for this variable.
comment|///
comment|/// Variables must be defined in a local scope.
name|DILocalScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|DILocalScope
operator|>
operator|(
name|DIVariable
operator|::
name|getScope
argument_list|()
operator|)
return|;
block|}
name|bool
name|isParameter
argument_list|()
specifier|const
block|{
return|return
name|Arg
return|;
block|}
name|unsigned
name|getArg
argument_list|()
specifier|const
block|{
return|return
name|Arg
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
return|;
block|}
comment|/// \brief Check that a location is valid for this variable.
comment|///
comment|/// Check that \c DL exists, is in the same subprogram, and has the same
comment|/// inlined-at location as \c this.  (Otherwise, it's not a valid attachment
comment|/// to a \a DbgInfoIntrinsic.)
name|bool
name|isValidLocationForIntrinsic
argument_list|(
argument|const DILocation *DL
argument_list|)
specifier|const
block|{
return|return
name|DL
operator|&&
name|getScope
argument_list|()
operator|->
name|getSubprogram
argument_list|()
operator|==
name|DL
operator|->
name|getScope
argument_list|()
operator|->
name|getSubprogram
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DILocalVariableKind
return|;
block|}
expr|}
block|;
comment|/// \brief DWARF expression.
comment|///
comment|/// This is (almost) a DWARF expression that modifies the location of a
comment|/// variable or (or the location of a single piece of a variable).
comment|///
comment|/// FIXME: Instead of DW_OP_plus taking an argument, this should use DW_OP_const
comment|/// and have DW_OP_plus consume the topmost elements on the stack.
comment|///
comment|/// TODO: Co-allocate the expression elements.
comment|/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary
comment|/// storage types.
name|class
name|DIExpression
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Elements
block|;
name|DIExpression
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|ArrayRef<uint64_t> Elements
argument_list|)
operator|:
name|MDNode
argument_list|(
name|C
argument_list|,
name|DIExpressionKind
argument_list|,
name|Storage
argument_list|,
name|None
argument_list|)
block|,
name|Elements
argument_list|(
argument|Elements.begin()
argument_list|,
argument|Elements.end()
argument_list|)
block|{}
operator|~
name|DIExpression
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIExpression
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|ArrayRef<uint64_t> Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIExpression
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIExpression
argument_list|,
argument|(ArrayRef<uint64_t> Elements)
argument_list|,
argument|(Elements)
argument_list|)
name|TempDIExpression
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|Elements
return|;
block|}
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|{
return|return
name|Elements
operator|.
name|size
argument_list|()
return|;
block|}
name|uint64_t
name|getElement
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|I
operator|<
name|Elements
operator|.
name|size
argument_list|()
operator|&&
literal|"Index out of range"
argument_list|)
block|;
return|return
name|Elements
index|[
name|I
index|]
return|;
block|}
comment|/// \brief Return whether this is a piece of an aggregate variable.
name|bool
name|isBitPiece
argument_list|()
specifier|const
block|;
comment|/// \brief Return the offset of this piece in bits.
name|uint64_t
name|getBitPieceOffset
argument_list|()
specifier|const
block|;
comment|/// \brief Return the size of this piece in bits.
name|uint64_t
name|getBitPieceSize
argument_list|()
specifier|const
block|;
typedef|typedef
name|ArrayRef
operator|<
name|uint64_t
operator|>
operator|::
name|iterator
name|element_iterator
expr_stmt|;
name|element_iterator
name|elements_begin
argument_list|()
specifier|const
block|{
return|return
name|getElements
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
name|element_iterator
name|elements_end
argument_list|()
specifier|const
block|{
return|return
name|getElements
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief A lightweight wrapper around an expression operand.
comment|///
comment|/// TODO: Store arguments directly and change \a DIExpression to store a
comment|/// range of these.
name|class
name|ExprOperand
block|{
specifier|const
name|uint64_t
operator|*
name|Op
block|;
name|public
operator|:
name|explicit
name|ExprOperand
argument_list|(
specifier|const
name|uint64_t
operator|*
name|Op
argument_list|)
operator|:
name|Op
argument_list|(
argument|Op
argument_list|)
block|{}
specifier|const
name|uint64_t
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
comment|/// \brief Get the operand code.
name|uint64_t
name|getOp
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Op
return|;
block|}
comment|/// \brief Get an argument to the operand.
comment|///
comment|/// Never returns the operand itself.
name|uint64_t
name|getArg
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|Op
index|[
name|I
operator|+
literal|1
index|]
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|getSize
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/// \brief Return the size of the operand.
comment|///
comment|/// Return the number of elements in the operand (1 + args).
name|unsigned
name|getSize
argument_list|()
specifier|const
block|;   }
block|;
comment|/// \brief An iterator for expression operands.
name|class
name|expr_op_iterator
operator|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
block|,
name|ExprOperand
operator|>
block|{
name|ExprOperand
name|Op
block|;
name|public
operator|:
name|explicit
name|expr_op_iterator
argument_list|(
argument|element_iterator I
argument_list|)
operator|:
name|Op
argument_list|(
argument|I
argument_list|)
block|{}
name|element_iterator
name|getBase
argument_list|()
specifier|const
block|{
return|return
name|Op
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|ExprOperand
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Op
return|;
block|}
specifier|const
name|ExprOperand
operator|*
name|operator
operator|->
expr|(
block|)
specifier|const
block|{
return|return
operator|&
name|Op
return|;
block|}
name|expr_op_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|expr_op_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|expr_op_iterator
name|T
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|increment
argument_list|()
block|;
return|return
name|T
return|;
block|}
comment|/// \brief Get the next iterator.
comment|///
comment|/// \a std::next() doesn't work because this is technically an
comment|/// input_iterator, but it's a perfectly valid operation.  This is an
comment|/// accessor to provide the same functionality.
name|expr_op_iterator
name|getNext
argument_list|()
specifier|const
block|{
return|return
operator|++
name|expr_op_iterator
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|expr_op_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|getBase
argument_list|()
operator|==
name|X
operator|.
name|getBase
argument_list|()
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|expr_op_iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|getBase
argument_list|()
operator|!=
name|X
operator|.
name|getBase
argument_list|()
return|;
block|}
name|private
operator|:
name|void
name|increment
argument_list|()
block|{
name|Op
operator|=
name|ExprOperand
argument_list|(
name|getBase
argument_list|()
operator|+
name|Op
operator|.
name|getSize
argument_list|()
argument_list|)
block|; }
expr|}
block|;
comment|/// \brief Visit the elements via ExprOperand wrappers.
comment|///
comment|/// These range iterators visit elements through \a ExprOperand wrappers.
comment|/// This is not guaranteed to be a valid range unless \a isValid() gives \c
comment|/// true.
comment|///
comment|/// \pre \a isValid() gives \c true.
comment|/// @{
name|expr_op_iterator
name|expr_op_begin
argument_list|()
specifier|const
block|{
return|return
name|expr_op_iterator
argument_list|(
name|elements_begin
argument_list|()
argument_list|)
return|;
block|}
name|expr_op_iterator
name|expr_op_end
argument_list|()
specifier|const
block|{
return|return
name|expr_op_iterator
argument_list|(
name|elements_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// @}
name|bool
name|isValid
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIExpressionKind
return|;
block|}
expr|}
block|;
name|class
name|DIObjCProperty
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|unsigned
name|Attributes
block|;
name|DIObjCProperty
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Line
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIObjCPropertyKind
argument_list|,
name|Storage
argument_list|,
name|dwarf
operator|::
name|DW_TAG_APPLE_property
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
name|Line
argument_list|)
block|,
name|Attributes
argument_list|(
argument|Attributes
argument_list|)
block|{}
operator|~
name|DIObjCProperty
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIObjCProperty
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef Name
argument_list|,
argument|DIFile *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef GetterName
argument_list|,
argument|StringRef SetterName
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|DITypeRef Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|File
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|GetterName
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|SetterName
argument_list|)
argument_list|,
name|Attributes
argument_list|,
name|Type
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIObjCProperty
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|MDString *Name
argument_list|,
argument|Metadata *File
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *GetterName
argument_list|,
argument|MDString *SetterName
argument_list|,
argument|unsigned Attributes
argument_list|,
argument|Metadata *Type
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIObjCProperty
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getGetterName
argument_list|()
argument_list|,
name|getSetterName
argument_list|()
argument_list|,
name|getAttributes
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIObjCProperty
argument_list|,
argument|(StringRef Name, DIFile *File, unsigned Line,                      StringRef GetterName, StringRef SetterName,                      unsigned Attributes, DITypeRef Type)
argument_list|,
argument|(Name, File, Line, GetterName, SetterName, Attributes,                      Type)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIObjCProperty
argument_list|,
argument|(MDString * Name, Metadata *File, unsigned Line,                      MDString *GetterName, MDString *SetterName,                      unsigned Attributes, Metadata *Type)
argument_list|,
argument|(Name, File, Line, GetterName, SetterName, Attributes,                      Type)
argument_list|)
name|TempDIObjCProperty
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|unsigned
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|Attributes
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|StringRef
name|getGetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getSetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|DITypeRef
argument_list|(
name|getRawType
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getFilename
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|F
operator|=
name|getFile
argument_list|()
condition|)
return|return
name|F
operator|->
name|getDirectory
argument_list|()
return|;
return|return
literal|""
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawGetterName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawSetterName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|4
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIObjCPropertyKind
return|;
block|}
expr|}
block|;
comment|/// \brief An imported module (C++ using directive or similar).
name|class
name|DIImportedEntity
operator|:
name|public
name|DINode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIImportedEntity
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned Tag
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DINode
argument_list|(
name|C
argument_list|,
name|DIImportedEntityKind
argument_list|,
name|Storage
argument_list|,
name|Tag
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIImportedEntity
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIImportedEntity
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|DIScope *Scope
argument_list|,
argument|DINodeRef Entity
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|Tag
argument_list|,
name|Scope
argument_list|,
name|Entity
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIImportedEntity
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned Tag
argument_list|,
argument|Metadata *Scope
argument_list|,
argument|Metadata *Entity
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIImportedEntity
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getTag
argument_list|()
argument_list|,
name|getScope
argument_list|()
argument_list|,
name|getEntity
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIImportedEntity
argument_list|,
argument|(unsigned Tag, DIScope *Scope, DINodeRef Entity,                      unsigned Line, StringRef Name =
literal|""
argument|)
argument_list|,
argument|(Tag, Scope, Entity, Line, Name)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIImportedEntity
argument_list|,
argument|(unsigned Tag, Metadata *Scope, Metadata *Entity,                      unsigned Line, MDString *Name)
argument_list|,
argument|(Tag, Scope, Entity, Line, Name)
argument_list|)
name|TempDIImportedEntity
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIScope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIScope
operator|>
operator|(
name|getRawScope
argument_list|()
operator|)
return|;
block|}
name|DINodeRef
name|getEntity
argument_list|()
specifier|const
block|{
return|return
name|DINodeRef
argument_list|(
name|getRawEntity
argument_list|()
argument_list|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawScope
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawEntity
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|2
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIImportedEntityKind
return|;
block|}
expr|}
block|;
comment|/// \brief Macro Info DWARF-like metadata node.
comment|///
comment|/// A metadata node with a DWARF macro info (i.e., a constant named
comment|/// \c DW_MACINFO_*, defined in llvm/Support/Dwarf.h).  Called \a DIMacroNode
comment|/// because it's potentially used for non-DWARF output.
name|class
name|DIMacroNode
operator|:
name|public
name|MDNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|protected
operator|:
name|DIMacroNode
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|unsigned ID
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|ArrayRef<Metadata *> Ops1
argument_list|,
argument|ArrayRef<Metadata *> Ops2 = None
argument_list|)
operator|:
name|MDNode
argument_list|(
argument|C
argument_list|,
argument|ID
argument_list|,
argument|Storage
argument_list|,
argument|Ops1
argument_list|,
argument|Ops2
argument_list|)
block|{
name|assert
argument_list|(
name|MIType
operator|<
literal|1u
operator|<<
literal|16
argument_list|)
block|;
name|SubclassData16
operator|=
name|MIType
block|;   }
operator|~
name|DIMacroNode
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|class
name|Ty
operator|>
name|Ty
operator|*
name|getOperandAs
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|Ty
operator|>
operator|(
name|getOperand
argument_list|(
name|I
argument_list|)
operator|)
return|;
block|}
name|StringRef
name|getStringOperand
argument_list|(
argument|unsigned I
argument_list|)
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|S
operator|=
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
name|I
operator|)
condition|)
return|return
name|S
operator|->
name|getString
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
specifier|static
name|MDString
operator|*
name|getCanonicalMDString
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|StringRef S
argument_list|)
block|{
if|if
condition|(
name|S
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|MDString
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|S
argument_list|)
return|;
block|}
name|public
operator|:
name|unsigned
name|getMacinfoType
argument_list|()
specifier|const
block|{
return|return
name|SubclassData16
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
switch|switch
condition|(
name|MD
operator|->
name|getMetadataID
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|DIMacroKind
case|:
case|case
name|DIMacroFileKind
case|:
return|return
name|true
return|;
block|}
block|}
expr|}
block|;
name|class
name|DIMacro
operator|:
name|public
name|DIMacroNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIMacro
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIMacroNode
argument_list|(
name|C
argument_list|,
name|DIMacroKind
argument_list|,
name|Storage
argument_list|,
name|MIType
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIMacro
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIMacro
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|StringRef Name
argument_list|,
argument|StringRef Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MIType
argument_list|,
name|Line
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|)
argument_list|,
name|getCanonicalMDString
argument_list|(
name|Context
argument_list|,
name|Value
argument_list|)
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIMacro
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|MDString *Name
argument_list|,
argument|MDString *Value
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIMacro
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getMacinfoType
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
name|getValue
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacro
argument_list|,
argument|(unsigned MIType, unsigned Line, StringRef Name,                               StringRef Value =
literal|""
argument|)
argument_list|,
argument|(MIType, Line, Name, Value)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacro
argument_list|,
argument|(unsigned MIType, unsigned Line, MDString *Name,                               MDString *Value)
argument_list|,
argument|(MIType, Line, Name, Value)
argument_list|)
name|TempDIMacro
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|StringRef
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getStringOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|MDString
operator|*
name|getRawName
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|0
operator|)
return|;
block|}
name|MDString
operator|*
name|getRawValue
argument_list|()
specifier|const
block|{
return|return
name|getOperandAs
operator|<
name|MDString
operator|>
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIMacroKind
return|;
block|}
expr|}
block|;
name|class
name|DIMacroFile
operator|:
name|public
name|DIMacroNode
block|{
name|friend
name|class
name|LLVMContextImpl
block|;
name|friend
name|class
name|MDNode
block|;
name|unsigned
name|Line
block|;
name|DIMacroFile
argument_list|(
argument|LLVMContext&C
argument_list|,
argument|StorageType Storage
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|ArrayRef<Metadata *> Ops
argument_list|)
operator|:
name|DIMacroNode
argument_list|(
name|C
argument_list|,
name|DIMacroFileKind
argument_list|,
name|Storage
argument_list|,
name|MIType
argument_list|,
name|Ops
argument_list|)
block|,
name|Line
argument_list|(
argument|Line
argument_list|)
block|{}
operator|~
name|DIMacroFile
argument_list|()
operator|=
expr|default
block|;
specifier|static
name|DIMacroFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|DIFile *File
argument_list|,
argument|DIMacroNodeArray Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|{
return|return
name|getImpl
argument_list|(
name|Context
argument_list|,
name|MIType
argument_list|,
name|Line
argument_list|,
name|static_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|File
operator|)
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|,
name|Storage
argument_list|,
name|ShouldCreate
argument_list|)
return|;
block|}
specifier|static
name|DIMacroFile
operator|*
name|getImpl
argument_list|(
argument|LLVMContext&Context
argument_list|,
argument|unsigned MIType
argument_list|,
argument|unsigned Line
argument_list|,
argument|Metadata *File
argument_list|,
argument|Metadata *Elements
argument_list|,
argument|StorageType Storage
argument_list|,
argument|bool ShouldCreate = true
argument_list|)
block|;
name|TempDIMacroFile
name|cloneImpl
argument_list|()
specifier|const
block|{
return|return
name|getTemporary
argument_list|(
name|getContext
argument_list|()
argument_list|,
name|getMacinfoType
argument_list|()
argument_list|,
name|getLine
argument_list|()
argument_list|,
name|getFile
argument_list|()
argument_list|,
name|getElements
argument_list|()
argument_list|)
return|;
block|}
name|public
operator|:
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacroFile
argument_list|,
argument|(unsigned MIType, unsigned Line, DIFile *File,                                   DIMacroNodeArray Elements)
argument_list|,
argument|(MIType, Line, File, Elements)
argument_list|)
name|DEFINE_MDNODE_GET
argument_list|(
argument|DIMacroFile
argument_list|,
argument|(unsigned MIType, unsigned Line,                                   Metadata *File, Metadata *Elements)
argument_list|,
argument|(MIType, Line, File, Elements)
argument_list|)
name|TempDIMacroFile
name|clone
argument_list|()
specifier|const
block|{
return|return
name|cloneImpl
argument_list|()
return|;
block|}
name|void
name|replaceElements
argument_list|(
argument|DIMacroNodeArray Elements
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
name|DIMacroNode
modifier|*
name|Op
range|:
name|getElements
argument_list|()
control|)
name|assert
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|Elements
operator|->
name|op_begin
argument_list|()
argument_list|,
name|Elements
operator|->
name|op_end
argument_list|()
argument_list|,
name|Op
argument_list|)
operator|&&
literal|"Lost a macro node during macro node list replacement"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|replaceOperandWith
argument_list|(
literal|1
argument_list|,
name|Elements
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|unsigned
name|getLine
argument_list|()
specifier|const
block|{
return|return
name|Line
return|;
block|}
name|DIFile
operator|*
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|DIFile
operator|>
operator|(
name|getRawFile
argument_list|()
operator|)
return|;
block|}
name|DIMacroNodeArray
name|getElements
argument_list|()
specifier|const
block|{
return|return
name|cast_or_null
operator|<
name|MDTuple
operator|>
operator|(
name|getRawElements
argument_list|()
operator|)
return|;
block|}
name|Metadata
operator|*
name|getRawFile
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|Metadata
operator|*
name|getRawElements
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Metadata *MD
argument_list|)
block|{
return|return
name|MD
operator|->
name|getMetadataID
argument_list|()
operator|==
name|DIMacroFileKind
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET_UNPACK_IMPL
end_undef

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET_UNPACK
end_undef

begin_undef
undef|#
directive|undef
name|DEFINE_MDNODE_GET
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

