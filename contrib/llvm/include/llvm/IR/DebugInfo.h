begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- DebugInfo.h - Debug Information Helpers ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines a bunch of datatypes that are useful for creating and
end_comment

begin_comment
comment|// walking debug info in LLVM IR form. They essentially provide wrappers around
end_comment

begin_comment
comment|// the information in the global variables that's needed when constructing the
end_comment

begin_comment
comment|// DWARF information.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_DEBUGINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_DEBUGINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|GlobalVariable
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|DbgValueInst
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|Metadata
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|MDString
decl_stmt|;
name|class
name|NamedMDNode
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|DIFile
decl_stmt|;
name|class
name|DISubprogram
decl_stmt|;
name|class
name|DILexicalBlock
decl_stmt|;
name|class
name|DILexicalBlockFile
decl_stmt|;
name|class
name|DIVariable
decl_stmt|;
name|class
name|DIType
decl_stmt|;
name|class
name|DIScope
decl_stmt|;
name|class
name|DIObjCProperty
decl_stmt|;
comment|/// \brief Maps from type identifier to the actual MDNode.
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|MDString
operator|*
operator|,
name|MDNode
operator|*
operator|>
name|DITypeIdentifierMap
expr_stmt|;
name|class
name|DIHeaderFieldIterator
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
decl_stmt|,
name|StringRef
decl_stmt|,
name|std
decl|::
name|ptrdiff_t
decl_stmt|,                            const
name|StringRef
modifier|*
decl_stmt|,
name|StringRef
decl|>
block|{
name|StringRef
name|Header
decl_stmt|;
name|StringRef
name|Current
decl_stmt|;
name|public
label|:
name|DIHeaderFieldIterator
argument_list|()
block|{}
name|DIHeaderFieldIterator
argument_list|(
argument|StringRef Header
argument_list|)
block|:
name|Header
argument_list|(
name|Header
argument_list|)
operator|,
name|Current
argument_list|(
argument|Header.slice(
literal|0
argument|, Header.find(
literal|'\0'
argument|))
argument_list|)
block|{}
name|StringRef
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Current
return|;
block|}
specifier|const
name|StringRef
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
operator|&
name|Current
return|;
block|}
name|DIHeaderFieldIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|DIHeaderFieldIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|DIHeaderFieldIterator
name|X
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|increment
argument_list|()
block|;
return|return
name|X
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|DIHeaderFieldIterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|Current
operator|.
name|data
argument_list|()
operator|==
name|X
operator|.
name|Current
operator|.
name|data
argument_list|()
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|DIHeaderFieldIterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|X
operator|)
return|;
block|}
name|StringRef
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|Header
return|;
block|}
name|StringRef
name|getCurrent
argument_list|()
specifier|const
block|{
return|return
name|Current
return|;
block|}
name|StringRef
name|getPrefix
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Current
operator|.
name|begin
argument_list|()
operator|==
name|Header
operator|.
name|begin
argument_list|()
condition|)
return|return
name|StringRef
argument_list|()
return|;
return|return
name|Header
operator|.
name|slice
argument_list|(
literal|0
argument_list|,
name|Current
operator|.
name|begin
argument_list|()
operator|-
name|Header
operator|.
name|begin
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|StringRef
name|getSuffix
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Current
operator|.
name|end
argument_list|()
operator|==
name|Header
operator|.
name|end
argument_list|()
condition|)
return|return
name|StringRef
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|Header
operator|.
name|slice
argument_list|(
name|Current
operator|.
name|end
argument_list|()
operator|-
name|Header
operator|.
name|begin
argument_list|()
operator|+
literal|1
argument_list|,
name|StringRef
operator|::
name|npos
argument_list|)
return|;
end_return

begin_function
unit|}  private:
name|void
name|increment
parameter_list|()
block|{
name|assert
argument_list|(
name|Current
operator|.
name|data
argument_list|()
operator|!=
name|nullptr
operator|&&
literal|"Cannot increment past the end"
argument_list|)
expr_stmt|;
name|StringRef
name|Suffix
init|=
name|getSuffix
argument_list|()
decl_stmt|;
name|Current
operator|=
name|Suffix
operator|.
name|slice
argument_list|(
literal|0
argument_list|,
name|Suffix
operator|.
name|find
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief A thin wraper around MDNode to access encoded debug info.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This should not be stored in a container, because the underlying MDNode may
end_comment

begin_comment
comment|/// change in certain situations.
end_comment

begin_decl_stmt
name|class
name|DIDescriptor
block|{
comment|// Befriends DIRef so DIRef can befriend the protected member
comment|// function: getFieldAs<DIRef>.
name|template
operator|<
name|typename
name|T
operator|>
name|friend
name|class
name|DIRef
expr_stmt|;
name|public
label|:
comment|/// \brief Accessibility flags.
comment|///
comment|/// The three accessibility flags are mutually exclusive and rolled together
comment|/// in the first two bits.
enum|enum
block|{
name|FlagAccessibility
init|=
literal|1
operator|<<
literal|0
operator||
literal|1
operator|<<
literal|1
block|,
name|FlagPrivate
init|=
literal|1
block|,
name|FlagProtected
init|=
literal|2
block|,
name|FlagPublic
init|=
literal|3
block|,
name|FlagFwdDecl
init|=
literal|1
operator|<<
literal|2
block|,
name|FlagAppleBlock
init|=
literal|1
operator|<<
literal|3
block|,
name|FlagBlockByrefStruct
init|=
literal|1
operator|<<
literal|4
block|,
name|FlagVirtual
init|=
literal|1
operator|<<
literal|5
block|,
name|FlagArtificial
init|=
literal|1
operator|<<
literal|6
block|,
name|FlagExplicit
init|=
literal|1
operator|<<
literal|7
block|,
name|FlagPrototyped
init|=
literal|1
operator|<<
literal|8
block|,
name|FlagObjcClassComplete
init|=
literal|1
operator|<<
literal|9
block|,
name|FlagObjectPointer
init|=
literal|1
operator|<<
literal|10
block|,
name|FlagVector
init|=
literal|1
operator|<<
literal|11
block|,
name|FlagStaticMember
init|=
literal|1
operator|<<
literal|12
block|,
name|FlagIndirectVariable
init|=
literal|1
operator|<<
literal|13
block|,
name|FlagLValueReference
init|=
literal|1
operator|<<
literal|14
block|,
name|FlagRValueReference
init|=
literal|1
operator|<<
literal|15
block|}
enum|;
name|protected
label|:
specifier|const
name|MDNode
modifier|*
name|DbgNode
decl_stmt|;
name|StringRef
name|getStringField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|getUnsignedField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|getUInt64Field
argument_list|(
name|Elt
argument_list|)
return|;
block|}
name|uint64_t
name|getUInt64Field
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|int64_t
name|getInt64Field
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|DIDescriptor
name|getDescriptorField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|template
operator|<
name|typename
name|DescTy
operator|>
name|DescTy
name|getFieldAs
argument_list|(
argument|unsigned Elt
argument_list|)
specifier|const
block|{
return|return
name|DescTy
argument_list|(
name|getDescriptorField
argument_list|(
name|Elt
argument_list|)
argument_list|)
return|;
block|}
name|GlobalVariable
modifier|*
name|getGlobalVariableField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|Constant
modifier|*
name|getConstantField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|Function
modifier|*
name|getFunctionField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|void
name|replaceFunctionField
parameter_list|(
name|unsigned
name|Elt
parameter_list|,
name|Function
modifier|*
name|F
parameter_list|)
function_decl|;
name|public
label|:
name|explicit
name|DIDescriptor
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DbgNode
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|Verify
argument_list|()
specifier|const
expr_stmt|;
name|MDNode
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|DbgNode
operator|)
return|;
block|}
name|operator
name|MDNode
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|MDNode
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|// An explicit operator bool so that we can do testing of DI values
end_comment

begin_comment
comment|// easily.
end_comment

begin_comment
comment|// FIXME: This operator bool isn't actually protecting anything at the
end_comment

begin_comment
comment|// moment due to the conversion operator above making DIDescriptor nodes
end_comment

begin_comment
comment|// implicitly convertable to bool.
end_comment

begin_expr_stmt
name|LLVM_EXPLICIT
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|DbgNode
operator|!=
name|nullptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
name|DIDescriptor
name|Other
operator|)
specifier|const
block|{
return|return
name|DbgNode
operator|==
name|Other
operator|.
name|DbgNode
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
name|DIDescriptor
name|Other
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|Other
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getHeader
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|getNumHeaderFields
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|DIHeaderFieldIterator
argument_list|(
name|getHeader
argument_list|()
argument_list|)
argument_list|,
name|DIHeaderFieldIterator
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|StringRef
name|getHeaderField
argument_list|(
name|unsigned
name|Index
argument_list|)
decl|const
block|{
comment|// Since callers expect an empty string for out-of-range accesses, we can't
comment|// use std::advance() here.
for|for
control|(
name|DIHeaderFieldIterator
name|I
argument_list|(
name|getHeader
argument_list|()
argument_list|)
init|,
name|E
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|--
name|Index
control|)
if|if
condition|(
operator|!
name|Index
condition|)
return|return
operator|*
name|I
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|T
name|getHeaderFieldAs
argument_list|(
argument|unsigned Index
argument_list|)
specifier|const
block|{
name|T
name|Int
block|;
if|if
condition|(
name|getHeaderField
argument_list|(
name|Index
argument_list|)
operator|.
name|getAsInteger
argument_list|(
literal|0
argument_list|,
name|Int
argument_list|)
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_return
return|return
name|Int
return|;
end_return

begin_macro
unit|}    uint16_t
name|getTag
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|uint16_t
operator|>
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isDerivedType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isCompositeType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isSubroutineType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isBasicType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isVariable
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isSubprogram
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isGlobalVariable
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isScope
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isFile
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isCompileUnit
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isNameSpace
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isLexicalBlockFile
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isLexicalBlock
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isSubrange
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isEnumerator
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isTemplateTypeParameter
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isTemplateValueParameter
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isObjCProperty
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isImportedEntity
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExpression
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Replace all uses of debug info referenced by this descriptor.
end_comment

begin_function_decl
name|void
name|replaceAllUsesWith
parameter_list|(
name|LLVMContext
modifier|&
name|VMContext
parameter_list|,
name|DIDescriptor
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|replaceAllUsesWith
parameter_list|(
name|MDNode
modifier|*
name|D
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// \brief This is used to represent ranges, for array bounds.
end_comment

begin_decl_stmt
name|class
name|DISubrange
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DISubrange
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|int64_t
name|getLo
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|int64_t
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|int64_t
name|getCount
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|int64_t
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief This descriptor holds an array of nodes with type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|DITypedArray
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DITypedArray
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|{
return|return
name|DbgNode
operator|?
name|DbgNode
operator|->
name|getNumOperands
argument_list|()
operator|:
literal|0
return|;
block|}
name|T
name|getElement
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|T
operator|>
operator|(
name|Idx
operator|)
return|;
block|}
end_expr_stmt

begin_typedef
unit|};
typedef|typedef
name|DITypedArray
operator|<
name|DIDescriptor
operator|>
name|DIArray
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief A wrapper for an enumerator (e.g. X and Y in 'enum {X,Y}').
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// FIXME: it seems strange that this doesn't have either a reference to the
end_comment

begin_comment
comment|/// type/precision or a file/line pair for location info.
end_comment

begin_decl_stmt
name|class
name|DIEnumerator
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIEnumerator
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|int64_t
name|getEnumValue
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|int64_t
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|DIRef
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|DIRef
operator|<
name|DIScope
operator|>
name|DIScopeRef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DIRef
operator|<
name|DIType
operator|>
name|DITypeRef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DITypedArray
operator|<
name|DITypeRef
operator|>
name|DITypeArray
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief A base class for various scopes.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Although, implementation-wise, DIScope is the parent class of most
end_comment

begin_comment
comment|/// other DIxxx classes, including DIType and its descendants, most of
end_comment

begin_comment
comment|/// DIScope's descendants are not a substitutable subtype of
end_comment

begin_comment
comment|/// DIScope. The DIDescriptor::isScope() method only is true for
end_comment

begin_comment
comment|/// DIScopes that are scopes in the strict lexical scope sense
end_comment

begin_comment
comment|/// (DICompileUnit, DISubprogram, etc.), but not for, e.g., a DIType.
end_comment

begin_decl_stmt
name|class
name|DIScope
range|:
name|public
name|DIDescriptor
block|{
name|protected
operator|:
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIScope
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
comment|/// \brief Get the parent scope.
comment|///
comment|/// Gets the parent scope for this scope node or returns a default
comment|/// constructed scope.
name|DIScopeRef
name|getContext
argument_list|()
specifier|const
block|;
comment|/// \brief Get the scope name.
comment|///
comment|/// If the scope node has a name, return that, else return an empty string.
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|;
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|;
comment|/// \brief Generate a reference to this DIScope.
comment|///
comment|/// Uses the type identifier instead of the actual MDNode if possible, to
comment|/// help type uniquing.
name|DIScopeRef
name|getRef
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Represents reference to a DIDescriptor.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Abstracts over direct and identifier-based metadata references.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|DIRef
block|{
name|template
operator|<
name|typename
name|DescTy
operator|>
name|friend
name|DescTy
name|DIDescriptor
operator|::
name|getFieldAs
argument_list|(
argument|unsigned Elt
argument_list|)
specifier|const
block|;
name|friend
name|DIScopeRef
name|DIScope
operator|::
name|getContext
argument_list|()
specifier|const
block|;
name|friend
name|DIScopeRef
name|DIScope
operator|::
name|getRef
argument_list|()
specifier|const
block|;
name|friend
name|class
name|DIType
block|;
comment|/// \brief Val can be either a MDNode or a MDString.
comment|///
comment|/// In the latter, MDString specifies the type identifier.
specifier|const
name|Metadata
operator|*
name|Val
block|;
name|explicit
name|DIRef
argument_list|(
specifier|const
name|Metadata
operator|*
name|V
argument_list|)
block|;
name|public
operator|:
name|T
name|resolve
argument_list|(
argument|const DITypeIdentifierMap&Map
argument_list|)
specifier|const
block|;
name|StringRef
name|getName
argument_list|()
specifier|const
block|;
name|operator
name|Metadata
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Metadata
operator|*
operator|>
operator|(
name|Val
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|DIRef
operator|<
name|T
operator|>
operator|::
name|resolve
argument_list|(
argument|const DITypeIdentifierMap&Map
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|T
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
specifier|const
name|MDNode
modifier|*
name|MD
init|=
name|dyn_cast
operator|<
name|MDNode
operator|>
operator|(
name|Val
operator|)
condition|)
return|return
name|T
argument_list|(
name|MD
argument_list|)
return|;
end_if

begin_decl_stmt
specifier|const
name|MDString
modifier|*
name|MS
init|=
name|cast
operator|<
name|MDString
operator|>
operator|(
name|Val
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Find the corresponding MDNode.
end_comment

begin_expr_stmt
name|DITypeIdentifierMap
operator|::
name|const_iterator
name|Iter
operator|=
name|Map
operator|.
name|find
argument_list|(
name|MS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|Iter
operator|!=
name|Map
operator|.
name|end
argument_list|()
operator|&&
literal|"Identifier not in the type map?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|DIDescriptor
argument_list|(
name|Iter
operator|->
name|second
argument_list|)
operator|.
name|isType
argument_list|()
operator|&&
literal|"MDNode in DITypeIdentifierMap should be a DIType."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|T
argument_list|(
name|Iter
operator|->
name|second
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|>
name|StringRef
name|DIRef
operator|<
name|T
operator|>
operator|::
name|getName
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|Val
condition|)
return|return
name|StringRef
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
specifier|const
name|MDNode
modifier|*
name|MD
init|=
name|dyn_cast
operator|<
name|MDNode
operator|>
operator|(
name|Val
operator|)
condition|)
return|return
name|T
argument_list|(
name|MD
argument_list|)
operator|.
name|getName
argument_list|()
return|;
end_if

begin_decl_stmt
specifier|const
name|MDString
modifier|*
name|MS
init|=
name|cast
operator|<
name|MDString
operator|>
operator|(
name|Val
operator|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|MS
operator|->
name|getString
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// \brief Handle fields that are references to DIScopes.
end_comment

begin_expr_stmt
unit|template
operator|<
operator|>
name|DIScopeRef
name|DIDescriptor
operator|::
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
name|unsigned
name|Elt
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Specialize DIRef constructor for DIScopeRef.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|DIRef
operator|<
name|DIScope
operator|>
operator|::
name|DIRef
argument_list|(
specifier|const
name|Metadata
operator|*
name|V
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Handle fields that are references to DITypes.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|DITypeRef
name|DIDescriptor
operator|::
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
name|unsigned
name|Elt
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Specialize DIRef constructor for DITypeRef.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|DIRef
operator|<
name|DIType
operator|>
operator|::
name|DIRef
argument_list|(
specifier|const
name|Metadata
operator|*
name|V
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \briefThis is a wrapper for a type.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// FIXME: Types should be factored much better so that CV qualifiers and
end_comment

begin_comment
comment|/// others do not require a huge and empty descriptor full of zeros.
end_comment

begin_decl_stmt
name|class
name|DIType
range|:
name|public
name|DIScope
block|{
name|protected
operator|:
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|operator
name|DITypeRef
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isType
argument_list|()
operator|&&
literal|"constructing DITypeRef from an MDNode that is not a type"
argument_list|)
block|;
return|return
name|DITypeRef
argument_list|(
operator|&
operator|*
name|getRef
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;
name|DIScopeRef
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|uint64_t
name|getSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|uint64_t
name|getAlignInBits
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|4
operator|)
return|;
block|}
comment|// FIXME: Offset is only used for DW_TAG_member nodes.  Making every type
comment|// carry this is just plain insane.
name|uint64_t
name|getOffsetInBits
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|6
operator|)
return|;
block|}
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
name|bool
name|isForwardDecl
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagFwdDecl
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isAppleBlockExtension
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAppleBlock
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isBlockByrefStruct
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagBlockByrefStruct
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagVirtual
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjcClassComplete
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagObjcClassComplete
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagVector
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isStaticMember
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagStaticMember
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|DbgNode
operator|&&
name|isType
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief A basic type, like 'int' or 'float'.
name|class
name|DIBasicType
operator|:
name|public
name|DIType
block|{
name|public
operator|:
name|explicit
name|DIBasicType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIType
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getEncoding
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|7
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief A simple derived type
comment|///
comment|/// Like a const qualified type, a typedef, a pointer or reference, et cetera.
comment|/// Or, a data member of a class/struct/union.
name|class
name|DIDerivedType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIDerivedType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIType
argument_list|(
argument|N
argument_list|)
block|{}
name|DITypeRef
name|getTypeDerivedFrom
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|3
operator|)
return|;
block|}
comment|/// \brief Return property node, if this ivar is associated with one.
name|MDNode
operator|*
name|getObjCProperty
argument_list|()
specifier|const
block|;
name|DITypeRef
name|getClassType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_ptr_to_member_type
argument_list|)
block|;
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|4
operator|)
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|)
operator|&&
name|isStaticMember
argument_list|()
argument_list|)
block|;
return|return
name|getConstantField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief Types that refer to multiple other types.
comment|///
comment|/// This descriptor holds a type that can refer to multiple other types, like a
comment|/// function or struct.
comment|///
comment|/// DICompositeType is derived from DIDerivedType because some
comment|/// composite types (such as enums) can be derived from basic types
comment|// FIXME: Make this derive from DIType directly& just store the
comment|// base type in a single DIType field.
name|class
name|DICompositeType
operator|:
name|public
name|DIDerivedType
block|{
name|friend
name|class
name|DIBuilder
block|;
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// \brief Set the array of member DITypes.
name|void
name|setArraysHelper
argument_list|(
name|MDNode
operator|*
name|Elements
argument_list|,
name|MDNode
operator|*
name|TParams
argument_list|)
block|;
name|public
operator|:
name|explicit
name|DICompositeType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDerivedType
argument_list|(
argument|N
argument_list|)
block|{}
name|DIArray
name|getElements
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isSubroutineType
argument_list|()
operator|&&
literal|"no elements for DISubroutineType"
argument_list|)
block|;
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|4
operator|)
return|;
block|}
name|private
operator|:
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|setArrays
argument_list|(
argument|DITypedArray<T> Elements
argument_list|,
argument|DIArray TParams = DIArray()
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|TParams
operator|||
name|DbgNode
operator|->
name|getNumOperands
argument_list|()
operator|==
literal|8
operator|)
operator|&&
literal|"If you're setting the template parameters this should include a slot "
literal|"for that!"
argument_list|)
block|;
name|setArraysHelper
argument_list|(
name|Elements
argument_list|,
name|TParams
argument_list|)
block|;   }
name|public
operator|:
name|unsigned
name|getRunTimeLang
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|7
operator|)
return|;
block|}
name|DITypeRef
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|private
operator|:
comment|/// \brief Set the containing type.
name|void
name|setContainingType
argument_list|(
argument|DICompositeType ContainingType
argument_list|)
block|;
name|public
operator|:
name|DIArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|6
operator|)
return|;
block|}
name|MDString
operator|*
name|getIdentifier
argument_list|()
specifier|const
block|;
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
name|class
name|DISubroutineType
operator|:
name|public
name|DICompositeType
block|{
name|public
operator|:
name|explicit
name|DISubroutineType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DICompositeType
argument_list|(
argument|N
argument_list|)
block|{}
name|DITypedArray
operator|<
name|DITypeRef
operator|>
name|getTypeArray
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypedArray
operator|<
name|DITypeRef
operator|>>
operator|(
literal|4
operator|)
return|;
block|}
expr|}
block|;
comment|/// \brief This is a wrapper for a file.
name|class
name|DIFile
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|public
operator|:
name|explicit
name|DIFile
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
comment|/// \brief Retrieve the MDNode for the directory/file pair.
name|MDNode
operator|*
name|getFileNode
argument_list|()
specifier|const
block|;
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief A wrapper for a compile unit.
name|class
name|DICompileUnit
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DICompileUnit
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|dwarf
operator|::
name|SourceLanguage
name|getLanguage
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|dwarf
operator|::
name|SourceLanguage
operator|>
operator|(
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|1
operator|)
operator|)
return|;
block|}
name|StringRef
name|getProducer
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|bool
operator|>
operator|(
literal|3
operator|)
operator|!=
literal|0
return|;
block|}
name|StringRef
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|unsigned
name|getRunTimeVersion
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|DIArray
name|getEnumTypes
argument_list|()
specifier|const
block|;
name|DIArray
name|getRetainedTypes
argument_list|()
specifier|const
block|;
name|DIArray
name|getSubprograms
argument_list|()
specifier|const
block|;
name|DIArray
name|getGlobalVariables
argument_list|()
specifier|const
block|;
name|DIArray
name|getImportedEntities
argument_list|()
specifier|const
block|;
name|void
name|replaceSubprograms
argument_list|(
argument|DIArray Subprograms
argument_list|)
block|;
name|void
name|replaceGlobalVariables
argument_list|(
argument|DIArray GlobalVariables
argument_list|)
block|;
name|StringRef
name|getSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|unsigned
name|getEmissionKind
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|7
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for a subprogram (e.g. a function).
name|class
name|DISubprogram
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DISubprogram
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|4
operator|)
return|;
block|}
comment|/// \brief Check if this is local (like 'static' in C).
name|unsigned
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|unsigned
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|6
operator|)
return|;
block|}
name|unsigned
name|getVirtuality
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|7
operator|)
return|;
block|}
name|unsigned
name|getVirtualIndex
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|8
operator|)
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|9
operator|)
return|;
block|}
name|unsigned
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|bool
operator|>
operator|(
literal|10
operator|)
return|;
block|}
comment|/// \brief Get the beginning of the scope of the function (not the name).
name|unsigned
name|getScopeLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|11
operator|)
return|;
block|}
name|DIScopeRef
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|DISubroutineType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DISubroutineType
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|DITypeRef
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|4
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;
comment|/// \brief Check if this provides debugging information for the function F.
name|bool
name|describes
argument_list|(
specifier|const
name|Function
operator|*
name|F
argument_list|)
block|;
name|Function
operator|*
name|getFunction
argument_list|()
specifier|const
block|{
return|return
name|getFunctionField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|void
name|replaceFunction
argument_list|(
argument|Function *F
argument_list|)
block|{
name|replaceFunctionField
argument_list|(
literal|5
argument_list|,
name|F
argument_list|)
block|; }
name|DIArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|6
operator|)
return|;
block|}
name|DISubprogram
name|getFunctionDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DISubprogram
operator|>
operator|(
literal|7
operator|)
return|;
block|}
name|MDNode
operator|*
name|getVariablesNodes
argument_list|()
specifier|const
block|;
name|DIArray
name|getVariables
argument_list|()
specifier|const
block|;
name|unsigned
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Check for the "private" access specifier.
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPrivate
return|;
block|}
comment|/// \brief Check for the "protected" access specifier.
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagProtected
return|;
block|}
comment|/// \brief Check for the "public" access specifier.
name|bool
name|isPublic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAccessibility
operator|)
operator|==
name|FlagPublic
return|;
block|}
comment|/// \brief Check for "explicit".
name|bool
name|isExplicit
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagExplicit
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Check if this is prototyped.
name|bool
name|isPrototyped
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagPrototyped
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Check if this is reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 reference-qualified non-static
comment|/// member function (void foo()&).
name|unsigned
name|isLValueReference
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagLValueReference
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Check if this is rvalue-reference-qualified.
comment|///
comment|/// Return true if this subprogram is a C++11 rvalue-reference-qualified
comment|/// non-static member function (void foo()&&).
name|unsigned
name|isRValueReference
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagRValueReference
operator|)
operator|!=
literal|0
return|;
block|}
expr|}
block|;
comment|/// \brief This is a wrapper for a lexical block.
name|class
name|DILexicalBlock
operator|:
name|public
name|DIScope
block|{
name|public
operator|:
name|explicit
name|DILexicalBlock
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for a lexical block with a filename change.
name|class
name|DILexicalBlockFile
operator|:
name|public
name|DIScope
block|{
name|public
operator|:
name|explicit
name|DILexicalBlockFile
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getScope
argument_list|()
operator|.
name|isSubprogram
argument_list|()
condition|)
return|return
name|getScope
argument_list|()
return|;
return|return
name|getScope
argument_list|()
operator|.
name|getContext
argument_list|()
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getLineNumber
argument_list|()
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getColumnNumber
argument_list|()
return|;
block|}
name|DILexicalBlock
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DILexicalBlock
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief A wrapper for a C++ style name space.
name|class
name|DINameSpace
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DINameSpace
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for template type parameter.
name|class
name|DITemplateTypeParameter
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DITemplateTypeParameter
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|DIScopeRef
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|3
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|3
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for template value parameter.
name|class
name|DITemplateValueParameter
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DITemplateValueParameter
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|DIScopeRef
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|Metadata
operator|*
name|getValue
argument_list|()
specifier|const
block|;
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|4
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|4
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for a global variable.
name|class
name|DIGlobalVariable
operator|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIGlobalVariable
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|4
operator|)
return|;
block|}
name|unsigned
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|bool
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|unsigned
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|bool
operator|>
operator|(
literal|6
operator|)
return|;
block|}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|2
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|2
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|GlobalVariable
operator|*
name|getGlobal
argument_list|()
specifier|const
block|{
return|return
name|getGlobalVariableField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
return|return
name|getConstantField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|DIDerivedType
name|getStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIDerivedType
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This is a wrapper for a variable (e.g. parameter, local, global etc).
name|class
name|DIVariable
operator|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIVariable
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
comment|// FIXME: Line number and arg number shouldn't be merged together like this.
return|return
operator|(
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
operator|<<
literal|8
operator|)
operator|>>
literal|8
return|;
block|}
name|unsigned
name|getArgNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
operator|>>
literal|24
return|;
block|}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|DIFile
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|DITypeRef
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DITypeRef
operator|>
operator|(
literal|3
operator|)
return|;
block|}
comment|/// \brief Return true if this variable is marked as "artificial".
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
operator|&
name|FlagObjectPointer
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Return true if this variable is represented as a pointer.
name|bool
name|isIndirect
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|3
operator|)
operator|&
name|FlagIndirectVariable
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief If this variable is inlined then return inline location.
name|MDNode
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|;
name|bool
name|Verify
argument_list|()
specifier|const
block|;
comment|/// \brief Check if this is a "__block" variable (Apple Blocks).
name|bool
name|isBlockByrefVariable
argument_list|(
argument|const DITypeIdentifierMap&Map
argument_list|)
specifier|const
block|{
return|return
operator|(
name|getType
argument_list|()
operator|.
name|resolve
argument_list|(
name|Map
argument_list|)
operator|)
operator|.
name|isBlockByrefStruct
argument_list|()
return|;
block|}
comment|/// \brief Check if this is an inlined function argument.
name|bool
name|isInlinedFnArgument
argument_list|(
specifier|const
name|Function
operator|*
name|CurFn
argument_list|)
block|;
comment|/// \brief Return the size reported by the variable's type.
name|unsigned
name|getSizeInBits
argument_list|(
specifier|const
name|DITypeIdentifierMap
operator|&
name|Map
argument_list|)
block|;
name|void
name|printExtendedName
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|; }
block|;
comment|/// \brief A complex location expression.
name|class
name|DIExpression
operator|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIExpression
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
name|nullptr
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|bool
name|Verify
argument_list|()
specifier|const
block|;
comment|/// \brief Return the number of elements in the complex expression.
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|DbgNode
condition|)
return|return
literal|0
return|;
name|unsigned
name|N
operator|=
name|getNumHeaderFields
argument_list|()
block|;
name|assert
argument_list|(
name|N
operator|>
literal|0
operator|&&
literal|"missing tag"
argument_list|)
block|;
return|return
name|N
operator|-
literal|1
return|;
block|}
comment|/// \brief return the Idx'th complex address element.
name|uint64_t
name|getElement
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|;
comment|/// \brief Return whether this is a piece of an aggregate variable.
name|bool
name|isVariablePiece
argument_list|()
specifier|const
block|;
comment|/// \brief Return the offset of this piece in bytes.
name|uint64_t
name|getPieceOffset
argument_list|()
specifier|const
block|;
comment|/// \brief Return the size of this piece in bytes.
name|uint64_t
name|getPieceSize
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief This object holds location information.
comment|///
comment|/// This object is not associated with any DWARF tag.
name|class
name|DILocation
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DILocation
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|L
operator|=
name|dyn_cast_or_null
operator|<
name|MDLocation
operator|>
operator|(
name|DbgNode
operator|)
condition|)
return|return
name|L
operator|->
name|getLine
argument_list|()
return|;
return|return
literal|0
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|L
operator|=
name|dyn_cast_or_null
operator|<
name|MDLocation
operator|>
operator|(
name|DbgNode
operator|)
condition|)
return|return
name|L
operator|->
name|getColumn
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|DIScope
name|getScope
argument_list|()
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|L
operator|=
name|dyn_cast_or_null
operator|<
name|MDLocation
operator|>
operator|(
name|DbgNode
operator|)
condition|)
return|return
name|DIScope
argument_list|(
name|dyn_cast_or_null
operator|<
name|MDNode
operator|>
operator|(
name|L
operator|->
name|getScope
argument_list|()
operator|)
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|DIScope
argument_list|(
name|nullptr
argument_list|)
return|;
end_return

begin_macro
unit|}   DILocation
name|getOrigLocation
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|auto
operator|*
name|L
operator|=
name|dyn_cast_or_null
operator|<
name|MDLocation
operator|>
operator|(
name|DbgNode
operator|)
condition|)
return|return
name|DILocation
argument_list|(
name|dyn_cast_or_null
operator|<
name|MDNode
operator|>
operator|(
name|L
operator|->
name|getInlinedAt
argument_list|()
operator|)
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|DILocation
argument_list|(
name|nullptr
argument_list|)
return|;
end_return

begin_macro
unit|}   StringRef
name|getFilename
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getFilename
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getDirectory
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|Verify
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|atSameLineAs
argument_list|(
specifier|const
name|DILocation
operator|&
name|Other
argument_list|)
decl|const
block|{
return|return
operator|(
name|getLineNumber
argument_list|()
operator|==
name|Other
operator|.
name|getLineNumber
argument_list|()
operator|&&
name|getFilename
argument_list|()
operator|==
name|Other
operator|.
name|getFilename
argument_list|()
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Get the DWAF discriminator.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// DWARF discriminators are used to distinguish identical file locations for
end_comment

begin_comment
comment|/// instructions that are on different basic blocks. If two instructions are
end_comment

begin_comment
comment|/// inside the same lexical block and are in different basic blocks, we
end_comment

begin_comment
comment|/// create a new lexical block with identical location as the original but
end_comment

begin_comment
comment|/// with a different discriminator value
end_comment

begin_comment
comment|/// (lib/Transforms/Util/AddDiscriminators.cpp for details).
end_comment

begin_expr_stmt
name|unsigned
name|getDiscriminator
argument_list|()
specifier|const
block|{
comment|// Since discriminators are associated with lexical blocks, make
comment|// sure this location is a lexical block before retrieving its
comment|// value.
return|return
name|getScope
argument_list|()
operator|.
name|isLexicalBlockFile
argument_list|()
operator|?
name|DILexicalBlockFile
argument_list|(
name|cast
operator|<
name|MDNode
operator|>
operator|(
name|cast
operator|<
name|MDLocation
operator|>
operator|(
name|DbgNode
operator|)
operator|->
name|getScope
argument_list|()
operator|)
argument_list|)
operator|.
name|getDiscriminator
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Generate a new discriminator value for this location.
end_comment

begin_function_decl
name|unsigned
name|computeNewDiscriminator
parameter_list|(
name|LLVMContext
modifier|&
name|Ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Return a copy of this location with a different scope.
end_comment

begin_function_decl
name|DILocation
name|copyWithNewScope
parameter_list|(
name|LLVMContext
modifier|&
name|Ctx
parameter_list|,
name|DILexicalBlockFile
name|NewScope
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
unit|};
name|class
name|DIObjCProperty
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIObjCProperty
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getObjCPropertyName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIFile
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getObjCPropertyGetterName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getObjCPropertySetterName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|unsigned
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|5
operator|)
return|;
block|}
name|bool
name|isReadOnlyObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_readonly
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isReadWriteObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_readwrite
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isAssignObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_assign
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isRetainObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_retain
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isCopyObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_copy
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isNonAtomicObjCProperty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getAttributes
argument_list|()
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_nonatomic
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// \brief Get the type.
comment|///
comment|/// \note Objective-C doesn't have an ODR, so there is no benefit in storing
comment|/// the type as a DITypeRef here.
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief An imported module (C++ using directive or similar).
end_comment

begin_decl_stmt
name|class
name|DIImportedEntity
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIImportedEntity
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|DIScopeRef
name|getEntity
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScopeRef
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getHeaderFieldAs
operator|<
name|unsigned
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getHeaderField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Find subprogram that is enclosing this scope.
end_comment

begin_function_decl
name|DISubprogram
name|getDISubprogram
parameter_list|(
specifier|const
name|MDNode
modifier|*
name|Scope
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Find debug info for a given function.
end_comment

begin_comment
comment|/// \returns a valid DISubprogram, if found. Otherwise, it returns an empty
end_comment

begin_comment
comment|/// DISubprogram.
end_comment

begin_function_decl
name|DISubprogram
name|getDISubprogram
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Find underlying composite type.
end_comment

begin_function_decl
name|DICompositeType
name|getDICompositeType
parameter_list|(
name|DIType
name|T
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Create a new inlined variable based on current variable.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// @param DV            Current Variable.
end_comment

begin_comment
comment|/// @param InlinedScope  Location at current variable is inlined.
end_comment

begin_function_decl
name|DIVariable
name|createInlinedVariable
parameter_list|(
name|MDNode
modifier|*
name|DV
parameter_list|,
name|MDNode
modifier|*
name|InlinedScope
parameter_list|,
name|LLVMContext
modifier|&
name|VMContext
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Remove inlined scope from the variable.
end_comment

begin_function_decl
name|DIVariable
name|cleanseInlinedVariable
parameter_list|(
name|MDNode
modifier|*
name|DV
parameter_list|,
name|LLVMContext
modifier|&
name|VMContext
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Generate map by visiting all retained types.
end_comment

begin_function_decl
name|DITypeIdentifierMap
name|generateDITypeIdentifierMap
parameter_list|(
specifier|const
name|NamedMDNode
modifier|*
name|CU_Nodes
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Strip debug info in the module if it exists.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// To do this, we remove all calls to the debugger intrinsics and any named
end_comment

begin_comment
comment|/// metadata for debugging. We also remove debug locations for instructions.
end_comment

begin_comment
comment|/// Return true if module is modified.
end_comment

begin_function_decl
name|bool
name|StripDebugInfo
parameter_list|(
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Return Debug Info Metadata Version by checking module flags.
end_comment

begin_function_decl
name|unsigned
name|getDebugMetadataVersionFromModule
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// \brief Utility to find all debug info in a module.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// DebugInfoFinder tries to list all debug info MDNodes used in a module. To
end_comment

begin_comment
comment|/// list debug info MDNodes used by an instruction, DebugInfoFinder uses
end_comment

begin_comment
comment|/// processDeclare, processValue and processLocation to handle DbgDeclareInst,
end_comment

begin_comment
comment|/// DbgValueInst and DbgLoc attached to instructions. processModule will go
end_comment

begin_comment
comment|/// through all DICompileUnits in llvm.dbg.cu and list debug info MDNodes
end_comment

begin_comment
comment|/// used by the CUs.
end_comment

begin_decl_stmt
name|class
name|DebugInfoFinder
block|{
name|public
label|:
name|DebugInfoFinder
argument_list|()
operator|:
name|TypeMapInitialized
argument_list|(
argument|false
argument_list|)
block|{}
comment|/// \brief Process entire module and collect debug info anchors.
name|void
name|processModule
argument_list|(
specifier|const
name|Module
operator|&
name|M
argument_list|)
expr_stmt|;
comment|/// \brief Process DbgDeclareInst.
name|void
name|processDeclare
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|,
specifier|const
name|DbgDeclareInst
modifier|*
name|DDI
parameter_list|)
function_decl|;
comment|/// \brief Process DbgValueInst.
name|void
name|processValue
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|,
specifier|const
name|DbgValueInst
modifier|*
name|DVI
parameter_list|)
function_decl|;
comment|/// \brief Process DILocation.
name|void
name|processLocation
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|,
name|DILocation
name|Loc
parameter_list|)
function_decl|;
comment|/// \brief Clear all lists.
name|void
name|reset
parameter_list|()
function_decl|;
name|private
label|:
name|void
name|InitializeTypeMap
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
name|void
name|processType
parameter_list|(
name|DIType
name|DT
parameter_list|)
function_decl|;
name|void
name|processSubprogram
parameter_list|(
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
name|void
name|processScope
parameter_list|(
name|DIScope
name|Scope
parameter_list|)
function_decl|;
name|bool
name|addCompileUnit
parameter_list|(
name|DICompileUnit
name|CU
parameter_list|)
function_decl|;
name|bool
name|addGlobalVariable
parameter_list|(
name|DIGlobalVariable
name|DIG
parameter_list|)
function_decl|;
name|bool
name|addSubprogram
parameter_list|(
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
name|bool
name|addType
parameter_list|(
name|DIType
name|DT
parameter_list|)
function_decl|;
name|bool
name|addScope
parameter_list|(
name|DIScope
name|Scope
parameter_list|)
function_decl|;
name|public
label|:
typedef|typedef
name|SmallVectorImpl
operator|<
name|DICompileUnit
operator|>
operator|::
name|const_iterator
name|compile_unit_iterator
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|DISubprogram
operator|>
operator|::
name|const_iterator
name|subprogram_iterator
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|DIGlobalVariable
operator|>
operator|::
name|const_iterator
name|global_variable_iterator
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|DIType
operator|>
operator|::
name|const_iterator
name|type_iterator
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|DIScope
operator|>
operator|::
name|const_iterator
name|scope_iterator
expr_stmt|;
name|iterator_range
operator|<
name|compile_unit_iterator
operator|>
name|compile_units
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|compile_unit_iterator
operator|>
operator|(
name|CUs
operator|.
name|begin
argument_list|()
operator|,
name|CUs
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|iterator_range
operator|<
name|subprogram_iterator
operator|>
name|subprograms
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|subprogram_iterator
operator|>
operator|(
name|SPs
operator|.
name|begin
argument_list|()
operator|,
name|SPs
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|iterator_range
operator|<
name|global_variable_iterator
operator|>
name|global_variables
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|global_variable_iterator
operator|>
operator|(
name|GVs
operator|.
name|begin
argument_list|()
operator|,
name|GVs
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|iterator_range
operator|<
name|type_iterator
operator|>
name|types
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|type_iterator
operator|>
operator|(
name|TYs
operator|.
name|begin
argument_list|()
operator|,
name|TYs
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|iterator_range
operator|<
name|scope_iterator
operator|>
name|scopes
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|scope_iterator
operator|>
operator|(
name|Scopes
operator|.
name|begin
argument_list|()
operator|,
name|Scopes
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|unsigned
name|compile_unit_count
argument_list|()
specifier|const
block|{
return|return
name|CUs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|global_variable_count
argument_list|()
specifier|const
block|{
return|return
name|GVs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|subprogram_count
argument_list|()
specifier|const
block|{
return|return
name|SPs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|type_count
argument_list|()
specifier|const
block|{
return|return
name|TYs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|scope_count
argument_list|()
specifier|const
block|{
return|return
name|Scopes
operator|.
name|size
argument_list|()
return|;
block|}
name|private
label|:
name|SmallVector
operator|<
name|DICompileUnit
operator|,
literal|8
operator|>
name|CUs
expr_stmt|;
name|SmallVector
operator|<
name|DISubprogram
operator|,
literal|8
operator|>
name|SPs
expr_stmt|;
name|SmallVector
operator|<
name|DIGlobalVariable
operator|,
literal|8
operator|>
name|GVs
expr_stmt|;
name|SmallVector
operator|<
name|DIType
operator|,
literal|8
operator|>
name|TYs
expr_stmt|;
name|SmallVector
operator|<
name|DIScope
operator|,
literal|8
operator|>
name|Scopes
expr_stmt|;
name|SmallPtrSet
operator|<
name|MDNode
operator|*
operator|,
literal|64
operator|>
name|NodesSeen
expr_stmt|;
name|DITypeIdentifierMap
name|TypeIdentifierMap
decl_stmt|;
comment|/// \brief Specify if TypeIdentifierMap is initialized.
name|bool
name|TypeMapInitialized
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|DenseMap
operator|<
specifier|const
name|Function
operator|*
operator|,
name|DISubprogram
operator|>
name|makeSubprogramMap
argument_list|(
specifier|const
name|Module
operator|&
name|M
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

