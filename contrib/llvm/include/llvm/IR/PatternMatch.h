begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides a simple and efficient mechanism for performing general
end_comment

begin_comment
comment|// tree-based pattern matches on the LLVM IR.  The power of these routines is
end_comment

begin_comment
comment|// that it allows you to write concise patterns that are expressive and easy to
end_comment

begin_comment
comment|// understand.  The other major advantage of this is that it allows you to
end_comment

begin_comment
comment|// trivially capture/bind elements in the pattern to variables.  For example,
end_comment

begin_comment
comment|// you can do something like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Value *Exp = ...
end_comment

begin_comment
comment|//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X& C1) | (Y& C2)
end_comment

begin_comment
comment|//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),
end_comment

begin_comment
comment|//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {
end_comment

begin_comment
comment|//    ... Pattern is matched and variables are bound ...
end_comment

begin_comment
comment|//  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This is primarily useful to things like the instruction combiner, but can
end_comment

begin_comment
comment|// also be useful for static analysis tools or code generators.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_IR_PATTERNMATCH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_IR_PATTERNMATCH_H
end_define

begin_include
include|#
directive|include
file|"llvm/IR/CallSite.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Intrinsics.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PatternMatch
block|{
name|template
operator|<
name|typename
name|Val
operator|,
name|typename
name|Pattern
operator|>
name|bool
name|match
argument_list|(
argument|Val *V
argument_list|,
argument|const Pattern&P
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|Pattern
operator|&
operator|>
operator|(
name|P
operator|)
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|SubPattern_t
operator|>
expr|struct
name|OneUse_match
block|{
name|SubPattern_t
name|SubPattern
block|;
name|OneUse_match
argument_list|(
specifier|const
name|SubPattern_t
operator|&
name|SP
argument_list|)
operator|:
name|SubPattern
argument_list|(
argument|SP
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
return|return
name|V
operator|->
name|hasOneUse
argument_list|()
operator|&&
name|SubPattern
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|OneUse_match
operator|<
name|T
operator|>
name|m_OneUse
argument_list|(
argument|const T&SubPattern
argument_list|)
block|{
return|return
name|SubPattern
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|class_match
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
return|;
block|}
expr|}
block|;
comment|/// \brief Match an arbitrary value and ignore it.
specifier|inline
name|class_match
operator|<
name|Value
operator|>
name|m_Value
argument_list|()
block|{
return|return
name|class_match
operator|<
name|Value
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Match an arbitrary binary operation and ignore it.
specifier|inline
name|class_match
operator|<
name|BinaryOperator
operator|>
name|m_BinOp
argument_list|()
block|{
return|return
name|class_match
operator|<
name|BinaryOperator
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches any compare instruction and ignore it.
specifier|inline
name|class_match
operator|<
name|CmpInst
operator|>
name|m_Cmp
argument_list|()
block|{
return|return
name|class_match
operator|<
name|CmpInst
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Match an arbitrary ConstantInt and ignore it.
specifier|inline
name|class_match
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|class_match
operator|<
name|ConstantInt
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Match an arbitrary undef constant.
specifier|inline
name|class_match
operator|<
name|UndefValue
operator|>
name|m_Undef
argument_list|()
block|{
return|return
name|class_match
operator|<
name|UndefValue
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Match an arbitrary Constant and ignore it.
specifier|inline
name|class_match
operator|<
name|Constant
operator|>
name|m_Constant
argument_list|()
block|{
return|return
name|class_match
operator|<
name|Constant
operator|>
operator|(
operator|)
return|;
block|}
comment|/// Matching combinators
name|template
operator|<
name|typename
name|LTy
block|,
name|typename
name|RTy
operator|>
expr|struct
name|match_combine_or
block|{
name|LTy
name|L
block|;
name|RTy
name|R
block|;
name|match_combine_or
argument_list|(
specifier|const
name|LTy
operator|&
name|Left
argument_list|,
specifier|const
name|RTy
operator|&
name|Right
argument_list|)
operator|:
name|L
argument_list|(
name|Left
argument_list|)
block|,
name|R
argument_list|(
argument|Right
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|R
operator|.
name|match
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LTy
block|,
name|typename
name|RTy
operator|>
expr|struct
name|match_combine_and
block|{
name|LTy
name|L
block|;
name|RTy
name|R
block|;
name|match_combine_and
argument_list|(
specifier|const
name|LTy
operator|&
name|Left
argument_list|,
specifier|const
name|RTy
operator|&
name|Right
argument_list|)
operator|:
name|L
argument_list|(
name|Left
argument_list|)
block|,
name|R
argument_list|(
argument|Right
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|V
argument_list|)
condition|)
if|if
condition|(
name|R
operator|.
name|match
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// Combine two pattern matchers matching L || R
name|template
operator|<
name|typename
name|LTy
block|,
name|typename
name|RTy
operator|>
specifier|inline
name|match_combine_or
operator|<
name|LTy
block|,
name|RTy
operator|>
name|m_CombineOr
argument_list|(
argument|const LTy&L
argument_list|,
argument|const RTy&R
argument_list|)
block|{
return|return
name|match_combine_or
operator|<
name|LTy
operator|,
name|RTy
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// Combine two pattern matchers matching L&& R
name|template
operator|<
name|typename
name|LTy
block|,
name|typename
name|RTy
operator|>
specifier|inline
name|match_combine_and
operator|<
name|LTy
block|,
name|RTy
operator|>
name|m_CombineAnd
argument_list|(
argument|const LTy&L
argument_list|,
argument|const RTy&R
argument_list|)
block|{
return|return
name|match_combine_and
operator|<
name|LTy
operator|,
name|RTy
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
expr|struct
name|match_zero
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|->
name|isNullValue
argument_list|()
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match an arbitrary zero/null constant.  This includes
comment|/// zero_initializer for vectors and ConstantPointerNull for pointers.
specifier|inline
name|match_zero
name|m_Zero
argument_list|()
block|{
return|return
name|match_zero
argument_list|()
return|;
block|}
expr|struct
name|match_neg_zero
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|->
name|isNegativeZeroValue
argument_list|()
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match an arbitrary zero/null constant.  This includes
comment|/// zero_initializer for vectors and ConstantPointerNull for pointers. For
comment|/// floating point constants, this will match negative zero but not positive
comment|/// zero
specifier|inline
name|match_neg_zero
name|m_NegZero
argument_list|()
block|{
return|return
name|match_neg_zero
argument_list|()
return|;
block|}
comment|/// \brief - Match an arbitrary zero/null constant.  This includes
comment|/// zero_initializer for vectors and ConstantPointerNull for pointers. For
comment|/// floating point constants, this will match negative zero and positive zero
specifier|inline
name|match_combine_or
operator|<
name|match_zero
block|,
name|match_neg_zero
operator|>
name|m_AnyZero
argument_list|()
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_Zero
argument_list|()
argument_list|,
name|m_NegZero
argument_list|()
argument_list|)
return|;
block|}
expr|struct
name|match_nan
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantFP
operator|>
operator|(
name|V
operator|)
condition|)
block|{
specifier|const
name|APFloat
modifier|&
name|APF
init|=
name|C
operator|->
name|getValueAPF
argument_list|()
decl_stmt|;
return|return
name|APF
operator|.
name|isNaN
argument_list|()
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// Match an arbitrary NaN constant. This includes quiet and signalling nans.
specifier|inline
name|match_nan
name|m_NaN
argument_list|()
block|{
return|return
name|match_nan
argument_list|()
return|;
block|}
expr|struct
name|apint_match
block|{
specifier|const
name|APInt
operator|*
operator|&
name|Res
block|;
name|apint_match
argument_list|(
specifier|const
name|APInt
operator|*
operator|&
name|R
argument_list|)
operator|:
name|Res
argument_list|(
argument|R
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|CI
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|auto
operator|*
name|CI
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|C
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a ConstantInt or splatted ConstantVector, binding the
comment|/// specified pointer to the contained APInt.
specifier|inline
name|apint_match
name|m_APInt
argument_list|(
argument|const APInt *&Res
argument_list|)
block|{
return|return
name|Res
return|;
block|}
name|template
operator|<
name|int64_t
name|Val
operator|>
expr|struct
name|constantint_match
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
block|{
specifier|const
name|APInt
modifier|&
name|CIV
init|=
name|CI
operator|->
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Val
operator|>=
literal|0
condition|)
return|return
name|CIV
operator|==
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|Val
operator|)
return|;
comment|// If Val is negative, and CI is shorter than it, truncate to the right
comment|// number of bits.  If it is larger, then we have to sign extend.  Just
comment|// compare their negated values.
return|return
operator|-
name|CIV
operator|==
operator|-
name|Val
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a ConstantInt with a specific value.
name|template
operator|<
name|int64_t
name|Val
operator|>
specifier|inline
name|constantint_match
operator|<
name|Val
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|constantint_match
operator|<
name|Val
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief This helper class is used to match scalar and vector constants that
comment|/// satisfy a specified predicate.
name|template
operator|<
name|typename
name|Predicate
operator|>
expr|struct
name|cst_pred_ty
operator|:
name|public
name|Predicate
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|C
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
return|return
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief This helper class is used to match scalar and vector constants that
comment|/// satisfy a specified predicate, and bind them to an APInt.
name|template
operator|<
name|typename
name|Predicate
operator|>
expr|struct
name|api_pred_ty
operator|:
name|public
name|Predicate
block|{
specifier|const
name|APInt
operator|*
operator|&
name|Res
block|;
name|api_pred_ty
argument_list|(
specifier|const
name|APInt
operator|*
operator|&
name|R
argument_list|)
operator|:
name|Res
argument_list|(
argument|R
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|auto
operator|*
name|CI
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|C
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
if|if
condition|(
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;  struct
name|is_one
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|==
literal|1
return|;
block|}
expr|}
block|;
comment|/// \brief Match an integer 1 or a vector with all elements equal to 1.
specifier|inline
name|cst_pred_ty
operator|<
name|is_one
operator|>
name|m_One
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_one
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_one
operator|>
name|m_One
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_all_ones
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isAllOnesValue
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Match an integer or vector with all bits set to true.
specifier|inline
name|cst_pred_ty
operator|<
name|is_all_ones
operator|>
name|m_AllOnes
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_all_ones
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_all_ones
operator|>
name|m_AllOnes
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_sign_mask
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isSignMask
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Match an integer or vector with only the sign bit(s) set.
specifier|inline
name|cst_pred_ty
operator|<
name|is_sign_mask
operator|>
name|m_SignMask
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_sign_mask
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_sign_mask
operator|>
name|m_SignMask
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_power2
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isPowerOf2
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// \brief Match an integer or vector power of 2.
specifier|inline
name|cst_pred_ty
operator|<
name|is_power2
operator|>
name|m_Power2
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_power2
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_power2
operator|>
name|m_Power2
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_maxsignedvalue
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isMaxSignedValue
argument_list|()
return|;
block|}
expr|}
block|;
specifier|inline
name|cst_pred_ty
operator|<
name|is_maxsignedvalue
operator|>
name|m_MaxSignedValue
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_maxsignedvalue
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_maxsignedvalue
operator|>
name|m_MaxSignedValue
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|bind_ty
block|{
name|Class
operator|*
operator|&
name|VR
block|;
name|bind_ty
argument_list|(
name|Class
operator|*
operator|&
name|V
argument_list|)
operator|:
name|VR
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|CV
operator|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
block|{
name|VR
operator|=
name|CV
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a value, capturing it if we match.
specifier|inline
name|bind_ty
operator|<
name|Value
operator|>
name|m_Value
argument_list|(
argument|Value *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
specifier|inline
name|bind_ty
operator|<
specifier|const
name|Value
operator|>
name|m_Value
argument_list|(
argument|const Value *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|/// \brief Match an instruction, capturing it if we match.
specifier|inline
name|bind_ty
operator|<
name|Instruction
operator|>
name|m_Instruction
argument_list|(
argument|Instruction *&I
argument_list|)
block|{
return|return
name|I
return|;
block|}
comment|/// \brief Match a binary operator, capturing it if we match.
specifier|inline
name|bind_ty
operator|<
name|BinaryOperator
operator|>
name|m_BinOp
argument_list|(
argument|BinaryOperator *&I
argument_list|)
block|{
return|return
name|I
return|;
block|}
comment|/// \brief Match a ConstantInt, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|(
argument|ConstantInt *&CI
argument_list|)
block|{
return|return
name|CI
return|;
block|}
comment|/// \brief Match a Constant, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|Constant
operator|>
name|m_Constant
argument_list|(
argument|Constant *&C
argument_list|)
block|{
return|return
name|C
return|;
block|}
comment|/// \brief Match a ConstantFP, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|ConstantFP
operator|>
name|m_ConstantFP
argument_list|(
argument|ConstantFP *&C
argument_list|)
block|{
return|return
name|C
return|;
block|}
comment|/// \brief Match a specified Value*.
expr|struct
name|specificval_ty
block|{
specifier|const
name|Value
operator|*
name|Val
block|;
name|specificval_ty
argument_list|(
specifier|const
name|Value
operator|*
name|V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|V
operator|==
name|Val
return|;
block|}
expr|}
block|;
comment|/// \brief Match if we have a specific specified value.
specifier|inline
name|specificval_ty
name|m_Specific
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|/// \brief Match a specified floating point value or vector of all elements of
comment|/// that value.
expr|struct
name|specific_fpval
block|{
name|double
name|Val
block|;
name|specific_fpval
argument_list|(
argument|double V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CFP
init|=
name|dyn_cast
operator|<
name|ConstantFP
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|CFP
operator|->
name|isExactlyValue
argument_list|(
name|Val
argument_list|)
return|;
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|auto
operator|*
name|CFP
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantFP
operator|>
operator|(
name|C
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
return|return
name|CFP
operator|->
name|isExactlyValue
argument_list|(
name|Val
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a specific floating point value or vector with all elements
comment|/// equal to the value.
specifier|inline
name|specific_fpval
name|m_SpecificFP
argument_list|(
argument|double V
argument_list|)
block|{
return|return
name|specific_fpval
argument_list|(
name|V
argument_list|)
return|;
block|}
comment|/// \brief Match a float 1.0 or vector with all elements equal to 1.0.
specifier|inline
name|specific_fpval
name|m_FPOne
argument_list|()
block|{
return|return
name|m_SpecificFP
argument_list|(
literal|1.0
argument_list|)
return|;
block|}
expr|struct
name|bind_const_intval_ty
block|{
name|uint64_t
operator|&
name|VR
block|;
name|bind_const_intval_ty
argument_list|(
name|uint64_t
operator|&
name|V
argument_list|)
operator|:
name|VR
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|CV
operator|->
name|getBitWidth
argument_list|()
operator|<=
literal|64
condition|)
block|{
name|VR
operator|=
name|CV
operator|->
name|getZExtValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a specified integer value or vector of all elements of that
comment|// value.
block|struct
name|specific_intval
block|{
name|uint64_t
name|Val
block|;
name|specific_intval
argument_list|(
argument|uint64_t V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
specifier|const
name|auto
operator|*
name|CI
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
block|;
if|if
condition|(
operator|!
name|CI
operator|&&
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isVectorTy
argument_list|()
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
name|CI
operator|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|C
operator|->
name|getSplatValue
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|CI
operator|&&
name|CI
operator|->
name|getBitWidth
argument_list|()
operator|<=
literal|64
condition|)
return|return
name|CI
operator|->
name|getZExtValue
argument_list|()
operator|==
name|Val
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a specific integer value or vector with all elements equal to
comment|/// the value.
specifier|inline
name|specific_intval
name|m_SpecificInt
argument_list|(
argument|uint64_t V
argument_list|)
block|{
return|return
name|specific_intval
argument_list|(
name|V
argument_list|)
return|;
block|}
comment|/// \brief Match a ConstantInt and bind to its value.  This does not match
comment|/// ConstantInts wider than 64-bits.
specifier|inline
name|bind_const_intval_ty
name|m_ConstantInt
argument_list|(
argument|uint64_t&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matcher for any binary operator.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
operator|>
expr|struct
name|AnyBinaryOp_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|AnyBinaryOp_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|I
operator|=
name|dyn_cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|AnyBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
operator|>
name|m_BinOp
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|AnyBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for specific binary operators.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opcode
operator|>
expr|struct
name|BinaryOp_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinaryOp_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opcode
condition|)
block|{
name|auto
operator|*
name|I
operator|=
name|cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
expr_stmt|;
return|return
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|auto
operator|*
name|CE
operator|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
operator|>
name|m_Add
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Add
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FAdd
operator|>
name|m_FAdd
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FAdd
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Sub
operator|>
name|m_Sub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Sub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FSub
operator|>
name|m_FSub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FSub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
operator|>
name|m_Mul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Mul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FMul
operator|>
name|m_FMul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FMul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|UDiv
operator|>
name|m_UDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|UDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SDiv
operator|>
name|m_SDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FDiv
operator|>
name|m_FDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|URem
operator|>
name|m_URem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|URem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SRem
operator|>
name|m_SRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FRem
operator|>
name|m_FRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|And
operator|>
name|m_And
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|And
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Or
operator|>
name|m_Or
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Or
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Xor
operator|>
name|m_Xor
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Xor
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Shl
operator|>
name|m_Shl
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Shl
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
operator|>
name|m_LShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|AShr
operator|>
name|m_AShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|AShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opcode
block|,
name|unsigned
name|WrapFlags
operator|=
literal|0
operator|>
expr|struct
name|OverflowingBinaryOp_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|OverflowingBinaryOp_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|Op
operator|=
name|dyn_cast
operator|<
name|OverflowingBinaryOperator
operator|>
operator|(
name|V
operator|)
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|getOpcode
argument_list|()
operator|!=
name|Opcode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|WrapFlags
operator|&
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|&&
operator|!
name|Op
operator|->
name|hasNoUnsignedWrap
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|WrapFlags
operator|&
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|&&
operator|!
name|Op
operator|->
name|hasNoSignedWrap
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|L
operator|.
name|match
argument_list|(
name|Op
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|Op
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
block|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
name|m_NSWAdd
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Add
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Sub
block|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
name|m_NSWSub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Sub
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
block|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
name|m_NSWMul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Mul
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Shl
block|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
name|m_NSWShl
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Shl
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoSignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
block|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
name|m_NUWAdd
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Add
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Sub
block|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
name|m_NUWSub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Sub
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
block|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
name|m_NUWMul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Mul
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|OverflowingBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Shl
block|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
name|m_NUWShl
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|OverflowingBinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Shl
operator|,
name|OverflowingBinaryOperator
operator|::
name|NoUnsignedWrap
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Class that matches two different binary ops.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opc1
block|,
name|unsigned
name|Opc2
operator|>
expr|struct
name|BinOp2_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinOp2_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opc1
operator|||
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opc2
condition|)
block|{
name|auto
operator|*
name|I
operator|=
name|cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
expr_stmt|;
return|return
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|auto
operator|*
name|CE
operator|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
operator|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opc1
operator|||
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opc2
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Matches LShr or AShr.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
block|,
name|Instruction
operator|::
name|AShr
operator|>
name|m_Shr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|,
name|Instruction
operator|::
name|AShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief Matches LShr or Shl.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
block|,
name|Instruction
operator|::
name|Shl
operator|>
name|m_LogicalShift
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|,
name|Instruction
operator|::
name|Shl
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief Matches UDiv and SDiv.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SDiv
block|,
name|Instruction
operator|::
name|UDiv
operator|>
name|m_IDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SDiv
operator|,
name|Instruction
operator|::
name|UDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Class that matches exact binary ops.
comment|//
name|template
operator|<
name|typename
name|SubPattern_t
operator|>
expr|struct
name|Exact_match
block|{
name|SubPattern_t
name|SubPattern
block|;
name|Exact_match
argument_list|(
specifier|const
name|SubPattern_t
operator|&
name|SP
argument_list|)
operator|:
name|SubPattern
argument_list|(
argument|SP
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|PEO
operator|=
name|dyn_cast
operator|<
name|PossiblyExactOperator
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|PEO
operator|->
name|isExact
argument_list|()
operator|&&
name|SubPattern
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|Exact_match
operator|<
name|T
operator|>
name|m_Exact
argument_list|(
argument|const T&SubPattern
argument_list|)
block|{
return|return
name|SubPattern
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CmpInst classes
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Class
block|,
name|typename
name|PredicateTy
operator|>
expr|struct
name|CmpClass_match
block|{
name|PredicateTy
operator|&
name|Predicate
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|CmpClass_match
argument_list|(
name|PredicateTy
operator|&
name|Pred
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|Predicate
argument_list|(
name|Pred
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|I
operator|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|Predicate
operator|=
name|I
operator|->
name|getPredicate
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|CmpInst
block|,
name|CmpInst
operator|::
name|Predicate
operator|>
name|m_Cmp
argument_list|(
argument|CmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|CmpInst
operator|,
name|CmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|ICmpInst
block|,
name|ICmpInst
operator|::
name|Predicate
operator|>
name|m_ICmp
argument_list|(
argument|ICmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|ICmpInst
operator|,
name|ICmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|FCmpInst
block|,
name|FCmpInst
operator|::
name|Predicate
operator|>
name|m_FCmp
argument_list|(
argument|FCmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|FCmpInst
operator|,
name|FCmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for SelectInst classes
comment|//
name|template
operator|<
name|typename
name|Cond_t
block|,
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
operator|>
expr|struct
name|SelectClass_match
block|{
name|Cond_t
name|C
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|SelectClass_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|Cond
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|C
argument_list|(
name|Cond
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|I
operator|=
name|dyn_cast
operator|<
name|SelectInst
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Cond
block|,
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|LHS
block|,
name|RHS
operator|>
name|m_Select
argument_list|(
argument|const Cond&C
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|SelectClass_match
operator|<
name|Cond
operator|,
name|LHS
operator|,
name|RHS
operator|>
operator|(
name|C
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief This matches a select of two constants, e.g.:
comment|/// m_SelectCst<-1, 0>(m_Value(V))
name|template
operator|<
name|int64_t
name|L
block|,
name|int64_t
name|R
block|,
name|typename
name|Cond
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|constantint_match
operator|<
name|L
operator|>
block|,
name|constantint_match
operator|<
name|R
operator|>>
name|m_SelectCst
argument_list|(
argument|const Cond&C
argument_list|)
block|{
return|return
name|m_Select
argument_list|(
name|C
argument_list|,
name|m_ConstantInt
operator|<
name|L
operator|>
operator|(
operator|)
argument_list|,
name|m_ConstantInt
operator|<
name|R
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CastInst classes
comment|//
name|template
operator|<
name|typename
name|Op_t
block|,
name|unsigned
name|Opcode
operator|>
expr|struct
name|CastClass_match
block|{
name|Op_t
name|Op
block|;
name|CastClass_match
argument_list|(
specifier|const
name|Op_t
operator|&
name|OpMatch
argument_list|)
operator|:
name|Op
argument_list|(
argument|OpMatch
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|O
operator|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|Op
operator|.
name|match
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Matches BitCast.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|BitCast
operator|>
name|m_BitCast
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|BitCast
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches PtrToInt.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|PtrToInt
operator|>
name|m_PtrToInt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|PtrToInt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches Trunc.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|Trunc
operator|>
name|m_Trunc
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|Trunc
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches SExt.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|SExt
operator|>
name|m_SExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|SExt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches ZExt.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|ZExt
operator|>
name|m_ZExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|ZExt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|match_combine_or
operator|<
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|ZExt
operator|>
block|,
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|SExt
operator|>>
name|m_ZExtOrSExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_ZExt
argument_list|(
name|Op
argument_list|)
argument_list|,
name|m_SExt
argument_list|(
name|Op
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches UIToFP.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|UIToFP
operator|>
name|m_UIToFP
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|UIToFP
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches SIToFP.
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|SIToFP
operator|>
name|m_SIToFP
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|SIToFP
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches FPTrunc
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|FPTrunc
operator|>
name|m_FPTrunc
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|FPTrunc
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// \brief Matches FPExt
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|FPExt
operator|>
name|m_FPExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|FPExt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for unary operators
comment|//
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|not_match
block|{
name|LHS_t
name|L
block|;
name|not_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|O
operator|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Xor
condition|)
return|return
name|matchIfNot
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfNot
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
return|return
operator|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|RHS
operator|)
operator|||
name|isa
operator|<
name|ConstantDataVector
operator|>
operator|(
name|RHS
operator|)
operator|||
comment|// FIXME: Remove CV.
name|isa
operator|<
name|ConstantVector
operator|>
operator|(
name|RHS
operator|)
operator|)
operator|&&
name|cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|not_match
operator|<
name|LHS
operator|>
name|m_Not
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|neg_match
block|{
name|LHS_t
name|L
block|;
name|neg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|O
operator|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
return|return
name|matchIfNeg
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfNeg
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
return|return
operator|(
operator|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|LHS
operator|)
operator|&&
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|LHS
operator|)
operator|->
name|isZero
argument_list|()
operator|)
operator|||
name|isa
operator|<
name|ConstantAggregateZero
operator|>
operator|(
name|LHS
operator|)
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Match an integer negate.
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|neg_match
operator|<
name|LHS
operator|>
name|m_Neg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|fneg_match
block|{
name|LHS_t
name|L
block|;
name|fneg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|O
operator|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|FSub
condition|)
return|return
name|matchIfFNeg
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfFNeg
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantFP
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|C
operator|->
name|isNegativeZeroValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match a floating point negate.
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|fneg_match
operator|<
name|LHS
operator|>
name|m_FNeg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for control flow.
comment|//
expr|struct
name|br_match
block|{
name|BasicBlock
operator|*
operator|&
name|Succ
block|;
name|br_match
argument_list|(
name|BasicBlock
operator|*
operator|&
name|Succ
argument_list|)
operator|:
name|Succ
argument_list|(
argument|Succ
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|BI
operator|=
name|dyn_cast
operator|<
name|BranchInst
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BI
operator|->
name|isUnconditional
argument_list|()
condition|)
block|{
name|Succ
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
specifier|inline
name|br_match
name|m_UnconditionalBr
argument_list|(
argument|BasicBlock *&Succ
argument_list|)
block|{
return|return
name|br_match
argument_list|(
name|Succ
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|Cond_t
operator|>
expr|struct
name|brc_match
block|{
name|Cond_t
name|Cond
block|;
name|BasicBlock
operator|*
operator|&
name|T
block|,
operator|*
operator|&
name|F
block|;
name|brc_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|C
argument_list|,
name|BasicBlock
operator|*
operator|&
name|t
argument_list|,
name|BasicBlock
operator|*
operator|&
name|f
argument_list|)
operator|:
name|Cond
argument_list|(
name|C
argument_list|)
block|,
name|T
argument_list|(
name|t
argument_list|)
block|,
name|F
argument_list|(
argument|f
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|BI
operator|=
name|dyn_cast
operator|<
name|BranchInst
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BI
operator|->
name|isConditional
argument_list|()
operator|&&
name|Cond
operator|.
name|match
argument_list|(
name|BI
operator|->
name|getCondition
argument_list|()
argument_list|)
condition|)
block|{
name|T
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|F
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Cond_t
operator|>
specifier|inline
name|brc_match
operator|<
name|Cond_t
operator|>
name|m_Br
argument_list|(
argument|const Cond_t&C
argument_list|,
argument|BasicBlock *&T
argument_list|,
argument|BasicBlock *&F
argument_list|)
block|{
return|return
name|brc_match
operator|<
name|Cond_t
operator|>
operator|(
name|C
operator|,
name|T
operator|,
name|F
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).
comment|//
name|template
operator|<
name|typename
name|CmpInst_t
block|,
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Pred_t
operator|>
expr|struct
name|MaxMin_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|MaxMin_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
comment|// Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".
name|auto
operator|*
name|SI
operator|=
name|dyn_cast
operator|<
name|SelectInst
operator|>
operator|(
name|V
operator|)
block|;
if|if
condition|(
operator|!
name|SI
condition|)
return|return
name|false
return|;
name|auto
operator|*
name|Cmp
operator|=
name|dyn_cast
operator|<
name|CmpInst_t
operator|>
operator|(
name|SI
operator|->
name|getCondition
argument_list|()
operator|)
block|;
if|if
condition|(
operator|!
name|Cmp
condition|)
return|return
name|false
return|;
comment|// At this point we have a select conditioned on a comparison.  Check that
comment|// it is the values returned by the select that are being compared.
name|Value
operator|*
name|TrueVal
operator|=
name|SI
operator|->
name|getTrueValue
argument_list|()
block|;
name|Value
operator|*
name|FalseVal
operator|=
name|SI
operator|->
name|getFalseValue
argument_list|()
block|;
name|Value
operator|*
name|LHS
operator|=
name|Cmp
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
block|;
name|Value
operator|*
name|RHS
operator|=
name|Cmp
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
block|;
if|if
condition|(
operator|(
name|TrueVal
operator|!=
name|LHS
operator|||
name|FalseVal
operator|!=
name|RHS
operator|)
operator|&&
operator|(
name|TrueVal
operator|!=
name|RHS
operator|||
name|FalseVal
operator|!=
name|LHS
operator|)
condition|)
return|return
name|false
return|;
name|typename
name|CmpInst_t
operator|::
name|Predicate
name|Pred
operator|=
name|LHS
operator|==
name|TrueVal
condition|?
name|Cmp
operator|->
name|getPredicate
argument_list|()
else|:
name|Cmp
operator|->
name|getSwappedPredicate
argument_list|()
block|;
comment|// Does "(x pred y) ? x : y" represent the desired max/min operation?
if|if
condition|(
operator|!
name|Pred_t
operator|::
name|match
argument_list|(
name|Pred
argument_list|)
condition|)
return|return
name|false
return|;
comment|// It does!  Bind the operands.
return|return
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying signed max predicates.
block|struct
name|smax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SGE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying signed min predicates.
block|struct
name|smin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SLT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SLE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying unsigned max predicates.
block|struct
name|umax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_UGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_UGE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying unsigned min predicates.
block|struct
name|umin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_ULT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_ULE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying ordered max predicates.
block|struct
name|ofmax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|FCmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_OGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_OGE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying ordered min predicates.
block|struct
name|ofmin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|FCmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_OLT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_OLE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying unordered max predicates.
block|struct
name|ufmax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|FCmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_UGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_UGE
return|;
block|}
expr|}
block|;
comment|/// \brief Helper class for identifying unordered min predicates.
block|struct
name|ufmin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|FCmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_ULT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|FCMP_ULE
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|smax_pred_ty
operator|>
name|m_SMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|ICmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|smax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|smin_pred_ty
operator|>
name|m_SMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|ICmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|smin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|umax_pred_ty
operator|>
name|m_UMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|ICmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|umax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|umin_pred_ty
operator|>
name|m_UMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|ICmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|umin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief Match an 'ordered' floating point maximum function.
comment|/// Floating point has one special value 'NaN'. Therefore, there is no total
comment|/// order. However, if we can ignore the 'NaN' value (for example, because of a
comment|/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'
comment|/// semantics. In the presence of 'NaN' we have to preserve the original
comment|/// select(fcmp(ogt/ge, L, R), L, R) semantics matched by this predicate.
comment|///
comment|///                         max(L, R)  iff L and R are not NaN
comment|///  m_OrdFMax(L, R) =      R          iff L or R are NaN
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|FCmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|ofmax_pred_ty
operator|>
name|m_OrdFMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|FCmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|ofmax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief Match an 'ordered' floating point minimum function.
comment|/// Floating point has one special value 'NaN'. Therefore, there is no total
comment|/// order. However, if we can ignore the 'NaN' value (for example, because of a
comment|/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'
comment|/// semantics. In the presence of 'NaN' we have to preserve the original
comment|/// select(fcmp(olt/le, L, R), L, R) semantics matched by this predicate.
comment|///
comment|///                         max(L, R)  iff L and R are not NaN
comment|///  m_OrdFMin(L, R) =      R          iff L or R are NaN
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|FCmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|ofmin_pred_ty
operator|>
name|m_OrdFMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|FCmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|ofmin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// \brief Match an 'unordered' floating point maximum function.
comment|/// Floating point has one special value 'NaN'. Therefore, there is no total
comment|/// order. However, if we can ignore the 'NaN' value (for example, because of a
comment|/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'maximum'
comment|/// semantics. In the presence of 'NaN' we have to preserve the original
comment|/// select(fcmp(ugt/ge, L, R), L, R) semantics matched by this predicate.
comment|///
comment|///                         max(L, R)  iff L and R are not NaN
comment|///  m_UnordFMin(L, R) =    L          iff L or R are NaN
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|FCmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|ufmax_pred_ty
operator|>
name|m_UnordFMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|FCmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|ufmax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for overflow check patterns: e.g. (a + b) u< a
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Sum_t
operator|>
expr|struct
name|UAddWithOverflow_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|Sum_t
name|S
block|;
name|UAddWithOverflow_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|L
argument_list|,
specifier|const
name|RHS_t
operator|&
name|R
argument_list|,
specifier|const
name|Sum_t
operator|&
name|S
argument_list|)
operator|:
name|L
argument_list|(
name|L
argument_list|)
block|,
name|R
argument_list|(
name|R
argument_list|)
block|,
name|S
argument_list|(
argument|S
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
name|Value
operator|*
name|ICmpLHS
block|,
operator|*
name|ICmpRHS
block|;
name|ICmpInst
operator|::
name|Predicate
name|Pred
block|;
if|if
condition|(
operator|!
name|m_ICmp
argument_list|(
name|Pred
argument_list|,
name|m_Value
argument_list|(
name|ICmpLHS
argument_list|)
argument_list|,
name|m_Value
argument_list|(
name|ICmpRHS
argument_list|)
argument_list|)
operator|.
name|match
argument_list|(
name|V
argument_list|)
condition|)
return|return
name|false
return|;
name|Value
operator|*
name|AddLHS
operator|,
operator|*
name|AddRHS
block|;
name|auto
name|AddExpr
operator|=
name|m_Add
argument_list|(
name|m_Value
argument_list|(
name|AddLHS
argument_list|)
argument_list|,
name|m_Value
argument_list|(
name|AddRHS
argument_list|)
argument_list|)
block|;
comment|// (a + b) u< a, (a + b) u< b
if|if
condition|(
name|Pred
operator|==
name|ICmpInst
operator|::
name|ICMP_ULT
condition|)
if|if
condition|(
name|AddExpr
operator|.
name|match
argument_list|(
name|ICmpLHS
argument_list|)
operator|&&
operator|(
name|ICmpRHS
operator|==
name|AddLHS
operator|||
name|ICmpRHS
operator|==
name|AddRHS
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|AddLHS
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|AddRHS
argument_list|)
operator|&&
name|S
operator|.
name|match
argument_list|(
name|ICmpLHS
argument_list|)
return|;
comment|// a>u (a + b), b>u (a + b)
if|if
condition|(
name|Pred
operator|==
name|ICmpInst
operator|::
name|ICMP_UGT
condition|)
if|if
condition|(
name|AddExpr
operator|.
name|match
argument_list|(
name|ICmpRHS
argument_list|)
operator|&&
operator|(
name|ICmpLHS
operator|==
name|AddLHS
operator|||
name|ICmpLHS
operator|==
name|AddRHS
operator|)
condition|)
return|return
name|L
operator|.
name|match
argument_list|(
name|AddLHS
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|AddRHS
argument_list|)
operator|&&
name|S
operator|.
name|match
argument_list|(
name|ICmpRHS
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// \brief Match an icmp instruction checking for unsigned overflow on addition.
comment|///
comment|/// S is matched to the addition whose result is being checked for overflow, and
comment|/// L and R are matched to the LHS and RHS of S.
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Sum_t
operator|>
name|UAddWithOverflow_match
operator|<
name|LHS_t
block|,
name|RHS_t
block|,
name|Sum_t
operator|>
name|m_UAddWithOverflow
argument_list|(
argument|const LHS_t&L
argument_list|,
argument|const RHS_t&R
argument_list|,
argument|const Sum_t&S
argument_list|)
block|{
return|return
name|UAddWithOverflow_match
operator|<
name|LHS_t
operator|,
name|RHS_t
operator|,
name|Sum_t
operator|>
operator|(
name|L
operator|,
name|R
operator|,
name|S
operator|)
return|;
block|}
comment|/// \brief Match an 'unordered' floating point minimum function.
comment|/// Floating point has one special value 'NaN'. Therefore, there is no total
comment|/// order. However, if we can ignore the 'NaN' value (for example, because of a
comment|/// 'no-nans-float-math' flag) a combination of a fcmp and select has 'minimum'
comment|/// semantics. In the presence of 'NaN' we have to preserve the original
comment|/// select(fcmp(ult/le, L, R), L, R) semantics matched by this predicate.
comment|///
comment|///                          max(L, R)  iff L and R are not NaN
comment|///  m_UnordFMin(L, R) =     L          iff L or R are NaN
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|FCmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|ufmin_pred_ty
operator|>
name|m_UnordFMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|FCmpInst
operator|,
name|LHS
operator|,
name|RHS
operator|,
name|ufmin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Opnd_t
operator|>
expr|struct
name|Argument_match
block|{
name|unsigned
name|OpI
block|;
name|Opnd_t
name|Val
block|;
name|Argument_match
argument_list|(
argument|unsigned OpIdx
argument_list|,
argument|const Opnd_t&V
argument_list|)
operator|:
name|OpI
argument_list|(
name|OpIdx
argument_list|)
block|,
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
name|CallSite
name|CS
argument_list|(
name|V
argument_list|)
block|;
return|return
name|CS
operator|.
name|isCall
argument_list|()
operator|&&
name|Val
operator|.
name|match
argument_list|(
name|CS
operator|.
name|getArgument
argument_list|(
name|OpI
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Match an argument.
name|template
operator|<
name|unsigned
name|OpI
block|,
name|typename
name|Opnd_t
operator|>
specifier|inline
name|Argument_match
operator|<
name|Opnd_t
operator|>
name|m_Argument
argument_list|(
argument|const Opnd_t&Op
argument_list|)
block|{
return|return
name|Argument_match
operator|<
name|Opnd_t
operator|>
operator|(
name|OpI
operator|,
name|Op
operator|)
return|;
block|}
comment|/// \brief Intrinsic matchers.
expr|struct
name|IntrinsicID_match
block|{
name|unsigned
name|ID
block|;
name|IntrinsicID_match
argument_list|(
argument|Intrinsic::ID IntrID
argument_list|)
operator|:
name|ID
argument_list|(
argument|IntrID
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|CallInst
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|F
init|=
name|CI
operator|->
name|getCalledFunction
argument_list|()
condition|)
return|return
name|F
operator|->
name|getIntrinsicID
argument_list|()
operator|==
name|ID
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// Intrinsic matches are combinations of ID matchers, and argument
comment|/// matchers. Higher arity matcher are defined recursively in terms of and-ing
comment|/// them with lower arity matchers. Here's some convenient typedefs for up to
comment|/// several arguments, and more can be added as needed
name|template
operator|<
name|typename
name|T0
operator|=
name|void
block|,
name|typename
name|T1
operator|=
name|void
block|,
name|typename
name|T2
operator|=
name|void
block|,
name|typename
name|T3
operator|=
name|void
block|,
name|typename
name|T4
operator|=
name|void
block|,
name|typename
name|T5
operator|=
name|void
block|,
name|typename
name|T6
operator|=
name|void
block|,
name|typename
name|T7
operator|=
name|void
block|,
name|typename
name|T8
operator|=
name|void
block|,
name|typename
name|T9
operator|=
name|void
block|,
name|typename
name|T10
operator|=
name|void
operator|>
expr|struct
name|m_Intrinsic_Ty
block|;
name|template
operator|<
name|typename
name|T0
operator|>
expr|struct
name|m_Intrinsic_Ty
operator|<
name|T0
operator|>
block|{
typedef|typedef
name|match_combine_and
operator|<
name|IntrinsicID_match
operator|,
name|Argument_match
operator|<
name|T0
operator|>>
name|Ty
expr_stmt|;
block|}
block|;
name|template
operator|<
name|typename
name|T0
block|,
name|typename
name|T1
operator|>
expr|struct
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
operator|>
block|{
typedef|typedef
name|match_combine_and
operator|<
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
operator|>
operator|::
name|Ty
operator|,
name|Argument_match
operator|<
name|T1
operator|>>
name|Ty
expr_stmt|;
block|}
block|;
name|template
operator|<
name|typename
name|T0
block|,
name|typename
name|T1
block|,
name|typename
name|T2
operator|>
expr|struct
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
block|,
name|T2
operator|>
block|{
typedef|typedef
name|match_combine_and
operator|<
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
operator|,
name|T1
operator|>
operator|::
name|Ty
operator|,
name|Argument_match
operator|<
name|T2
operator|>>
name|Ty
expr_stmt|;
block|}
block|;
name|template
operator|<
name|typename
name|T0
block|,
name|typename
name|T1
block|,
name|typename
name|T2
block|,
name|typename
name|T3
operator|>
expr|struct
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
block|,
name|T2
block|,
name|T3
operator|>
block|{
typedef|typedef
name|match_combine_and
operator|<
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
operator|,
name|T1
operator|,
name|T2
operator|>
operator|::
name|Ty
operator|,
name|Argument_match
operator|<
name|T3
operator|>>
name|Ty
expr_stmt|;
block|}
block|;
comment|/// \brief Match intrinsic calls like this:
comment|/// m_Intrinsic<Intrinsic::fabs>(m_Value(X))
name|template
operator|<
name|Intrinsic
operator|::
name|ID
name|IntrID
operator|>
specifier|inline
name|IntrinsicID_match
name|m_Intrinsic
argument_list|()
block|{
return|return
name|IntrinsicID_match
argument_list|(
name|IntrID
argument_list|)
return|;
block|}
name|template
operator|<
name|Intrinsic
operator|::
name|ID
name|IntrID
block|,
name|typename
name|T0
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
operator|>
operator|::
name|Ty
name|m_Intrinsic
argument_list|(
argument|const T0&Op0
argument_list|)
block|{
return|return
name|m_CombineAnd
argument_list|(
name|m_Intrinsic
operator|<
name|IntrID
operator|>
operator|(
operator|)
argument_list|,
name|m_Argument
operator|<
literal|0
operator|>
operator|(
name|Op0
operator|)
argument_list|)
return|;
block|}
name|template
operator|<
name|Intrinsic
operator|::
name|ID
name|IntrID
block|,
name|typename
name|T0
block|,
name|typename
name|T1
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
operator|>
operator|::
name|Ty
name|m_Intrinsic
argument_list|(
argument|const T0&Op0
argument_list|,
argument|const T1&Op1
argument_list|)
block|{
return|return
name|m_CombineAnd
argument_list|(
name|m_Intrinsic
operator|<
name|IntrID
operator|>
operator|(
name|Op0
operator|)
argument_list|,
name|m_Argument
operator|<
literal|1
operator|>
operator|(
name|Op1
operator|)
argument_list|)
return|;
block|}
name|template
operator|<
name|Intrinsic
operator|::
name|ID
name|IntrID
block|,
name|typename
name|T0
block|,
name|typename
name|T1
block|,
name|typename
name|T2
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
block|,
name|T2
operator|>
operator|::
name|Ty
name|m_Intrinsic
argument_list|(
argument|const T0&Op0
argument_list|,
argument|const T1&Op1
argument_list|,
argument|const T2&Op2
argument_list|)
block|{
return|return
name|m_CombineAnd
argument_list|(
name|m_Intrinsic
operator|<
name|IntrID
operator|>
operator|(
name|Op0
operator|,
name|Op1
operator|)
argument_list|,
name|m_Argument
operator|<
literal|2
operator|>
operator|(
name|Op2
operator|)
argument_list|)
return|;
block|}
name|template
operator|<
name|Intrinsic
operator|::
name|ID
name|IntrID
block|,
name|typename
name|T0
block|,
name|typename
name|T1
block|,
name|typename
name|T2
block|,
name|typename
name|T3
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|T0
block|,
name|T1
block|,
name|T2
block|,
name|T3
operator|>
operator|::
name|Ty
name|m_Intrinsic
argument_list|(
argument|const T0&Op0
argument_list|,
argument|const T1&Op1
argument_list|,
argument|const T2&Op2
argument_list|,
argument|const T3&Op3
argument_list|)
block|{
return|return
name|m_CombineAnd
argument_list|(
name|m_Intrinsic
operator|<
name|IntrID
operator|>
operator|(
name|Op0
operator|,
name|Op1
operator|,
name|Op2
operator|)
argument_list|,
name|m_Argument
operator|<
literal|3
operator|>
operator|(
name|Op3
operator|)
argument_list|)
return|;
block|}
comment|// Helper intrinsic matching specializations.
name|template
operator|<
name|typename
name|Opnd0
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|Opnd0
operator|>
operator|::
name|Ty
name|m_BSwap
argument_list|(
argument|const Opnd0&Op0
argument_list|)
block|{
return|return
name|m_Intrinsic
operator|<
name|Intrinsic
operator|::
name|bswap
operator|>
operator|(
name|Op0
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Opnd0
block|,
name|typename
name|Opnd1
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|Opnd0
block|,
name|Opnd1
operator|>
operator|::
name|Ty
name|m_FMin
argument_list|(
argument|const Opnd0&Op0
argument_list|,
argument|const Opnd1&Op1
argument_list|)
block|{
return|return
name|m_Intrinsic
operator|<
name|Intrinsic
operator|::
name|minnum
operator|>
operator|(
name|Op0
operator|,
name|Op1
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Opnd0
block|,
name|typename
name|Opnd1
operator|>
specifier|inline
name|typename
name|m_Intrinsic_Ty
operator|<
name|Opnd0
block|,
name|Opnd1
operator|>
operator|::
name|Ty
name|m_FMax
argument_list|(
argument|const Opnd0&Op0
argument_list|,
argument|const Opnd1&Op1
argument_list|)
block|{
return|return
name|m_Intrinsic
operator|<
name|Intrinsic
operator|::
name|maxnum
operator|>
operator|(
name|Op0
operator|,
name|Op1
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Opnd_t
operator|>
expr|struct
name|Signum_match
block|{
name|Opnd_t
name|Val
block|;
name|Signum_match
argument_list|(
specifier|const
name|Opnd_t
operator|&
name|V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
name|unsigned
name|TypeSize
operator|=
name|V
operator|->
name|getType
argument_list|()
operator|->
name|getScalarSizeInBits
argument_list|()
block|;
if|if
condition|(
name|TypeSize
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|unsigned
name|ShiftWidth
operator|=
name|TypeSize
operator|-
literal|1
block|;
name|Value
operator|*
name|OpL
operator|=
name|nullptr
block|,
operator|*
name|OpR
operator|=
name|nullptr
block|;
comment|// This is the representation of signum we match:
comment|//
comment|//  signum(x) == (x>> 63) | (-x>>u 63)
comment|//
comment|// An i1 value is its own signum, so it's correct to match
comment|//
comment|//  signum(x) == (x>> 0)  | (-x>>u 0)
comment|//
comment|// for i1 values.
name|auto
name|LHS
operator|=
name|m_AShr
argument_list|(
name|m_Value
argument_list|(
name|OpL
argument_list|)
argument_list|,
name|m_SpecificInt
argument_list|(
name|ShiftWidth
argument_list|)
argument_list|)
block|;
name|auto
name|RHS
operator|=
name|m_LShr
argument_list|(
name|m_Neg
argument_list|(
name|m_Value
argument_list|(
name|OpR
argument_list|)
argument_list|)
argument_list|,
name|m_SpecificInt
argument_list|(
name|ShiftWidth
argument_list|)
argument_list|)
block|;
name|auto
name|Signum
operator|=
name|m_Or
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
block|;
return|return
name|Signum
operator|.
name|match
argument_list|(
name|V
argument_list|)
operator|&&
name|OpL
operator|==
name|OpR
operator|&&
name|Val
operator|.
name|match
argument_list|(
name|OpL
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Matches a signum pattern.
comment|///
comment|/// signum(x) =
comment|///      x>  0  ->  1
comment|///      x == 0  ->  0
comment|///      x<  0  -> -1
name|template
operator|<
name|typename
name|Val_t
operator|>
specifier|inline
name|Signum_match
operator|<
name|Val_t
operator|>
name|m_Signum
argument_list|(
argument|const Val_t&V
argument_list|)
block|{
return|return
name|Signum_match
operator|<
name|Val_t
operator|>
operator|(
name|V
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for two-operands operators with the operators in either order
comment|//
comment|/// \brief Matches a BinaryOperator with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|AnyBinaryOp_match
operator|<
name|LHS
block|,
name|RHS
operator|>
block|,
name|AnyBinaryOp_match
operator|<
name|RHS
block|,
name|LHS
operator|>>
name|m_c_BinOp
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_BinOp
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_BinOp
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches an ICmp with a predicate over LHS and RHS in either order.
comment|/// Does not swap the predicate.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|ICmpInst
block|,
name|ICmpInst
operator|::
name|Predicate
operator|>
block|,
name|CmpClass_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|ICmpInst
block|,
name|ICmpInst
operator|::
name|Predicate
operator|>>
name|m_c_ICmp
argument_list|(
argument|ICmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_ICmp
argument_list|(
name|Pred
argument_list|,
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_ICmp
argument_list|(
name|Pred
argument_list|,
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches a Add with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
operator|>
block|,
name|BinaryOp_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|Instruction
operator|::
name|Add
operator|>>
name|m_c_Add
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_Add
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_Add
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches a Mul with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
operator|>
block|,
name|BinaryOp_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|Instruction
operator|::
name|Mul
operator|>>
name|m_c_Mul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_Mul
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_Mul
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches an And with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|And
operator|>
block|,
name|BinaryOp_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|Instruction
operator|::
name|And
operator|>>
name|m_c_And
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_And
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_And
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches an Or with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Or
operator|>
block|,
name|BinaryOp_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|Instruction
operator|::
name|Or
operator|>>
name|m_c_Or
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_Or
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_Or
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches an Xor with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Xor
operator|>
block|,
name|BinaryOp_match
operator|<
name|RHS
block|,
name|LHS
block|,
name|Instruction
operator|::
name|Xor
operator|>>
name|m_c_Xor
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_Xor
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_Xor
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// Matches an SMin with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|smin_pred_ty
operator|>
block|,
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|RHS
block|,
name|LHS
block|,
name|smin_pred_ty
operator|>>
name|m_c_SMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_SMin
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_SMin
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// Matches an SMax with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|smax_pred_ty
operator|>
block|,
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|RHS
block|,
name|LHS
block|,
name|smax_pred_ty
operator|>>
name|m_c_SMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_SMax
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_SMax
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// Matches a UMin with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|umin_pred_ty
operator|>
block|,
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|RHS
block|,
name|LHS
block|,
name|umin_pred_ty
operator|>>
name|m_c_UMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_UMin
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_UMin
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
comment|/// Matches a UMax with LHS and RHS in either order.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|match_combine_or
operator|<
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|LHS
block|,
name|RHS
block|,
name|umax_pred_ty
operator|>
block|,
name|MaxMin_match
operator|<
name|ICmpInst
block|,
name|RHS
block|,
name|LHS
block|,
name|umax_pred_ty
operator|>>
name|m_c_UMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|m_CombineOr
argument_list|(
name|m_UMax
argument_list|(
name|L
argument_list|,
name|R
argument_list|)
argument_list|,
name|m_UMax
argument_list|(
name|R
argument_list|,
name|L
argument_list|)
argument_list|)
return|;
block|}
expr|}
comment|// end namespace PatternMatch
expr|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

