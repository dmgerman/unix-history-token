begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/AtomicOrdering.h ---Atomic Ordering---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Atomic ordering constants.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These values are used by LLVM to represent atomic ordering for C++11's
end_comment

begin_comment
comment|/// memory model and more, as detailed in docs/Atomics.rst.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_ATOMICORDERING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_ATOMICORDERING_H
end_define

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// Atomic ordering for C11 / C++11's memody models.
comment|///
comment|/// These values cannot change because they are shared with standard library
comment|/// implementations as well as with other compilers.
name|enum
name|class
name|AtomicOrderingCABI
block|{
name|relaxed
operator|=
literal|0
operator|,
name|consume
operator|=
literal|1
operator|,
name|acquire
operator|=
literal|2
operator|,
name|release
operator|=
literal|3
operator|,
name|acq_rel
operator|=
literal|4
operator|,
name|seq_cst
operator|=
literal|5
operator|,
block|}
empty_stmt|;
name|bool
name|operator
operator|<
operator|(
name|AtomicOrderingCABI
operator|,
name|AtomicOrderingCABI
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|>
operator|(
name|AtomicOrderingCABI
operator|,
name|AtomicOrderingCABI
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|<=
operator|(
name|AtomicOrderingCABI
operator|,
name|AtomicOrderingCABI
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|>=
operator|(
name|AtomicOrderingCABI
operator|,
name|AtomicOrderingCABI
operator|)
operator|=
name|delete
expr_stmt|;
comment|// Validate an integral value which isn't known to fit within the enum's range
comment|// is a valid AtomicOrderingCABI.
name|template
operator|<
name|typename
name|Int
operator|>
specifier|static
specifier|inline
name|bool
name|isValidAtomicOrderingCABI
argument_list|(
argument|Int I
argument_list|)
block|{
return|return
operator|(
name|Int
operator|)
name|AtomicOrderingCABI
operator|::
name|relaxed
operator|<=
name|I
operator|&&
name|I
operator|<=
operator|(
name|Int
operator|)
name|AtomicOrderingCABI
operator|::
name|seq_cst
return|;
block|}
comment|/// Atomic ordering for LLVM's memory model.
comment|///
comment|/// C++ defines ordering as a lattice. LLVM supplements this with NotAtomic and
comment|/// Unordered, which are both below the C++ orders.
comment|///
comment|/// not_atomic-->unordered-->relaxed-->release--------------->acq_rel-->seq_cst
comment|///                                   \-->consume-->acquire--/
name|enum
name|class
name|AtomicOrdering
block|{
name|NotAtomic
operator|=
literal|0
operator|,
name|Unordered
operator|=
literal|1
operator|,
name|Monotonic
operator|=
literal|2
operator|,
comment|// Equivalent to C++'s relaxed.
comment|// Consume = 3,  // Not specified yet.
name|Acquire
operator|=
literal|4
operator|,
name|Release
operator|=
literal|5
operator|,
name|AcquireRelease
operator|=
literal|6
operator|,
name|SequentiallyConsistent
operator|=
literal|7
block|}
empty_stmt|;
name|bool
name|operator
operator|<
operator|(
name|AtomicOrdering
operator|,
name|AtomicOrdering
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|>
operator|(
name|AtomicOrdering
operator|,
name|AtomicOrdering
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|<=
operator|(
name|AtomicOrdering
operator|,
name|AtomicOrdering
operator|)
operator|=
name|delete
expr_stmt|;
name|bool
name|operator
operator|>=
operator|(
name|AtomicOrdering
operator|,
name|AtomicOrdering
operator|)
operator|=
name|delete
expr_stmt|;
comment|// Validate an integral value which isn't known to fit within the enum's range
comment|// is a valid AtomicOrdering.
name|template
operator|<
name|typename
name|Int
operator|>
specifier|static
specifier|inline
name|bool
name|isValidAtomicOrdering
argument_list|(
argument|Int I
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|Int
operator|>
operator|(
name|AtomicOrdering
operator|::
name|NotAtomic
operator|)
operator|<=
name|I
operator|&&
name|I
operator|<=
name|static_cast
operator|<
name|Int
operator|>
operator|(
name|AtomicOrdering
operator|::
name|SequentiallyConsistent
operator|)
return|;
block|}
comment|/// String used by LLVM IR to represent atomic ordering.
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|toIRString
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[
literal|8
index|]
init|=
block|{
literal|"not_atomic"
block|,
literal|"unordered"
block|,
literal|"monotonic"
block|,
literal|"consume"
block|,
literal|"acquire"
block|,
literal|"release"
block|,
literal|"acq_rel"
block|,
literal|"seq_cst"
block|}
decl_stmt|;
return|return
name|names
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|ao
operator|)
index|]
return|;
block|}
comment|/// Returns true if ao is stronger than other as defined by the AtomicOrdering
comment|/// lattice, which is based on C++'s definition.
specifier|static
specifier|inline
name|bool
name|isStrongerThan
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|,
name|AtomicOrdering
name|other
parameter_list|)
block|{
specifier|static
specifier|const
name|bool
name|lookup
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
comment|//               NA     UN     RX     CO     AC     RE     AR     SC
comment|/* NotAtomic */
block|{
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* Unordered */
block|{
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* relaxed   */
block|{
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* consume   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* acquire   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* release   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* acq_rel   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* seq_cst   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
block|,   }
decl_stmt|;
return|return
name|lookup
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|ao
operator|)
index|]
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|other
operator|)
index|]
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isAtLeastOrStrongerThan
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|,
name|AtomicOrdering
name|other
parameter_list|)
block|{
specifier|static
specifier|const
name|bool
name|lookup
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
comment|//               NA     UN     RX     CO     AC     RE     AR     SC
comment|/* NotAtomic */
block|{
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* Unordered */
block|{
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* relaxed   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* consume   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* acquire   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* release   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|false
block|}
block|,
comment|/* acq_rel   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
block|,
comment|/* seq_cst   */
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
block|,   }
decl_stmt|;
return|return
name|lookup
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|ao
operator|)
index|]
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|other
operator|)
index|]
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isStrongerThanUnordered
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
return|return
name|isStrongerThan
argument_list|(
name|ao
argument_list|,
name|AtomicOrdering
operator|::
name|Unordered
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isStrongerThanMonotonic
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
return|return
name|isStrongerThan
argument_list|(
name|ao
argument_list|,
name|AtomicOrdering
operator|::
name|Monotonic
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isAcquireOrStronger
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
return|return
name|isAtLeastOrStrongerThan
argument_list|(
name|ao
argument_list|,
name|AtomicOrdering
operator|::
name|Acquire
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isReleaseOrStronger
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
return|return
name|isAtLeastOrStrongerThan
argument_list|(
name|ao
argument_list|,
name|AtomicOrdering
operator|::
name|Release
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|AtomicOrderingCABI
name|toCABI
parameter_list|(
name|AtomicOrdering
name|ao
parameter_list|)
block|{
specifier|static
specifier|const
name|AtomicOrderingCABI
name|lookup
index|[
literal|8
index|]
init|=
block|{
comment|/* NotAtomic */
name|AtomicOrderingCABI
operator|::
name|relaxed
block|,
comment|/* Unordered */
name|AtomicOrderingCABI
operator|::
name|relaxed
block|,
comment|/* relaxed   */
name|AtomicOrderingCABI
operator|::
name|relaxed
block|,
comment|/* consume   */
name|AtomicOrderingCABI
operator|::
name|consume
block|,
comment|/* acquire   */
name|AtomicOrderingCABI
operator|::
name|acquire
block|,
comment|/* release   */
name|AtomicOrderingCABI
operator|::
name|release
block|,
comment|/* acq_rel   */
name|AtomicOrderingCABI
operator|::
name|acq_rel
block|,
comment|/* seq_cst   */
name|AtomicOrderingCABI
operator|::
name|seq_cst
block|,   }
decl_stmt|;
return|return
name|lookup
index|[
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|ao
operator|)
index|]
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_ATOMICORDERING_H
end_comment

end_unit

