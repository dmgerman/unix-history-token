begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- IntegersSubsetMapping.h - Mapping subset ==> Successor ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// @file
end_comment

begin_comment
comment|/// IntegersSubsetMapping is mapping from A to B, where
end_comment

begin_comment
comment|/// Items in A is subsets of integers,
end_comment

begin_comment
comment|/// Items in B some pointers (Successors).
end_comment

begin_comment
comment|/// If user which to add another subset for successor that is already
end_comment

begin_comment
comment|/// exists in mapping, IntegersSubsetMapping merges existing subset with
end_comment

begin_comment
comment|/// added one.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CRSBUILDER_H_
end_ifndef

begin_define
define|#
directive|define
name|CRSBUILDER_H_
end_define

begin_include
include|#
directive|include
file|"llvm/Support/IntegersSubset.h"
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|SuccessorClass
operator|,
name|class
name|IntegersSubsetTy
operator|=
name|IntegersSubset
operator|,
name|class
name|IntTy
operator|=
name|IntItem
operator|>
name|class
name|IntegersSubsetMapping
block|{
comment|// FIXME: To much similar iterators typedefs, similar names.
comment|//        - Rename RangeIterator to the cluster iterator.
comment|//        - Remove unused "add" methods.
comment|//        - Class contents needs cleaning.
name|public
operator|:
typedef|typedef
name|IntRange
operator|<
name|IntTy
operator|>
name|RangeTy
expr_stmt|;
block|struct
name|RangeEx
operator|:
name|public
name|RangeTy
block|{
name|RangeEx
argument_list|()
operator|:
name|Weight
argument_list|(
literal|1
argument_list|)
block|{}
name|RangeEx
argument_list|(
specifier|const
name|RangeTy
operator|&
name|R
argument_list|)
operator|:
name|RangeTy
argument_list|(
name|R
argument_list|)
block|,
name|Weight
argument_list|(
literal|1
argument_list|)
block|{}
name|RangeEx
argument_list|(
specifier|const
name|IntTy
operator|&
name|C
argument_list|)
operator|:
name|RangeTy
argument_list|(
name|C
argument_list|)
block|,
name|Weight
argument_list|(
literal|1
argument_list|)
block|{}
name|RangeEx
argument_list|(
specifier|const
name|IntTy
operator|&
name|L
argument_list|,
specifier|const
name|IntTy
operator|&
name|H
argument_list|)
operator|:
name|RangeTy
argument_list|(
name|L
argument_list|,
name|H
argument_list|)
block|,
name|Weight
argument_list|(
literal|1
argument_list|)
block|{}
name|RangeEx
argument_list|(
argument|const IntTy&L
argument_list|,
argument|const IntTy&H
argument_list|,
argument|unsigned W
argument_list|)
operator|:
name|RangeTy
argument_list|(
name|L
argument_list|,
name|H
argument_list|)
block|,
name|Weight
argument_list|(
argument|W
argument_list|)
block|{}
name|unsigned
name|Weight
block|;   }
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|RangeEx
operator|,
name|SuccessorClass
operator|*
operator|>
name|Cluster
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|RangeTy
operator|>
name|RangesCollection
expr_stmt|;
typedef|typedef
name|typename
name|RangesCollection
operator|::
name|iterator
name|RangesCollectionIt
expr_stmt|;
typedef|typedef
name|typename
name|RangesCollection
operator|::
name|const_iterator
name|RangesCollectionConstIt
expr_stmt|;
typedef|typedef
name|IntegersSubsetMapping
operator|<
name|SuccessorClass
operator|,
name|IntegersSubsetTy
operator|,
name|IntTy
operator|>
name|self
expr_stmt|;
name|protected
label|:
typedef|typedef
name|std
operator|::
name|list
operator|<
name|Cluster
operator|>
name|CaseItems
expr_stmt|;
typedef|typedef
name|typename
name|CaseItems
operator|::
name|iterator
name|CaseItemIt
expr_stmt|;
typedef|typedef
name|typename
name|CaseItems
operator|::
name|const_iterator
name|CaseItemConstIt
expr_stmt|;
comment|// TODO: Change unclean CRS prefixes to SubsetMap for example.
typedef|typedef
name|std
operator|::
name|map
operator|<
name|SuccessorClass
operator|*
operator|,
name|RangesCollection
operator|>
name|CRSMap
expr_stmt|;
typedef|typedef
name|typename
name|CRSMap
operator|::
name|iterator
name|CRSMapIt
expr_stmt|;
struct|struct
name|ClustersCmp
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Cluster
operator|&
name|C1
operator|,
specifier|const
name|Cluster
operator|&
name|C2
operator|)
block|{
return|return
name|C1
operator|.
name|first
operator|<
name|C2
operator|.
name|first
return|;
block|}
block|}
struct|;
name|CaseItems
name|Items
decl_stmt|;
name|bool
name|Sorted
decl_stmt|;
name|bool
name|isIntersected
parameter_list|(
name|CaseItemIt
modifier|&
name|LItem
parameter_list|,
name|CaseItemIt
modifier|&
name|RItem
parameter_list|)
block|{
return|return
name|LItem
operator|->
name|first
operator|.
name|getHigh
argument_list|()
operator|>=
name|RItem
operator|->
name|first
operator|.
name|getLow
argument_list|()
return|;
block|}
name|bool
name|isJoinable
parameter_list|(
name|CaseItemIt
modifier|&
name|LItem
parameter_list|,
name|CaseItemIt
modifier|&
name|RItem
parameter_list|)
block|{
if|if
condition|(
name|LItem
operator|->
name|second
operator|!=
name|RItem
operator|->
name|second
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isIntersected
argument_list|(
name|LItem
argument_list|,
name|RItem
argument_list|)
operator|&&
literal|"Intersected items with different successors!"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|APInt
name|RLow
init|=
name|RItem
operator|->
name|first
operator|.
name|getLow
argument_list|()
decl_stmt|;
if|if
condition|(
name|RLow
operator|!=
name|APInt
operator|::
name|getNullValue
argument_list|(
name|RLow
operator|.
name|getBitWidth
argument_list|()
argument_list|)
condition|)
operator|--
name|RLow
expr_stmt|;
return|return
name|LItem
operator|->
name|first
operator|.
name|getHigh
argument_list|()
operator|>=
name|RLow
return|;
block|}
name|void
name|sort
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Sorted
condition|)
block|{
name|std
operator|::
name|vector
operator|<
name|Cluster
operator|>
name|clustersVector
expr_stmt|;
name|clustersVector
operator|.
name|reserve
argument_list|(
name|Items
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|clustersVector
operator|.
name|insert
argument_list|(
name|clustersVector
operator|.
name|begin
argument_list|()
argument_list|,
name|Items
operator|.
name|begin
argument_list|()
argument_list|,
name|Items
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|clustersVector
operator|.
name|begin
argument_list|()
argument_list|,
name|clustersVector
operator|.
name|end
argument_list|()
argument_list|,
name|ClustersCmp
argument_list|()
argument_list|)
expr_stmt|;
name|Items
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Items
operator|.
name|insert
argument_list|(
name|Items
operator|.
name|begin
argument_list|()
argument_list|,
name|clustersVector
operator|.
name|begin
argument_list|()
argument_list|,
name|clustersVector
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Sorted
operator|=
name|true
expr_stmt|;
block|}
block|}
enum|enum
name|DiffProcessState
block|{
name|L_OPENED
block|,
name|INTERSECT_OPENED
block|,
name|R_OPENED
block|,
name|ALL_IS_CLOSED
block|}
enum|;
name|class
name|DiffStateMachine
block|{
name|DiffProcessState
name|State
decl_stmt|;
name|IntTy
name|OpenPt
decl_stmt|;
name|SuccessorClass
modifier|*
name|CurrentLSuccessor
decl_stmt|;
name|SuccessorClass
modifier|*
name|CurrentRSuccessor
decl_stmt|;
name|self
modifier|*
name|LeftMapping
decl_stmt|;
name|self
modifier|*
name|IntersectionMapping
decl_stmt|;
name|self
modifier|*
name|RightMapping
decl_stmt|;
name|public
label|:
typedef|typedef
name|IntegersSubsetMapping
operator|<
name|SuccessorClass
operator|,
name|IntegersSubsetTy
operator|,
name|IntTy
operator|>
name|MappingTy
expr_stmt|;
name|DiffStateMachine
argument_list|(
name|MappingTy
operator|*
name|L
argument_list|,
name|MappingTy
operator|*
name|Intersection
argument_list|,
name|MappingTy
operator|*
name|R
argument_list|)
operator|:
name|State
argument_list|(
name|ALL_IS_CLOSED
argument_list|)
operator|,
name|LeftMapping
argument_list|(
name|L
argument_list|)
operator|,
name|IntersectionMapping
argument_list|(
name|Intersection
argument_list|)
operator|,
name|RightMapping
argument_list|(
argument|R
argument_list|)
block|{}
name|void
name|onLOpen
argument_list|(
argument|const IntTy&Pt
argument_list|,
argument|SuccessorClass *S
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|R_OPENED
case|:
if|if
condition|(
name|Pt
operator|>
name|OpenPt
comment|/*Don't add empty ranges.*/
operator|&&
name|RightMapping
condition|)
name|RightMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
operator|-
literal|1
argument_list|,
name|CurrentRSuccessor
argument_list|)
expr_stmt|;
name|State
operator|=
name|INTERSECT_OPENED
expr_stmt|;
break|break;
case|case
name|ALL_IS_CLOSED
case|:
name|State
operator|=
name|L_OPENED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
name|CurrentLSuccessor
operator|=
name|S
expr_stmt|;
name|OpenPt
operator|=
name|Pt
block|;     }
name|void
name|onLClose
argument_list|(
argument|const IntTy&Pt
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|L_OPENED
case|:
name|assert
argument_list|(
name|Pt
operator|>=
name|OpenPt
operator|&&
literal|"Subset is not sorted or contains overlapped ranges"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LeftMapping
condition|)
name|LeftMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
argument_list|,
name|CurrentLSuccessor
argument_list|)
expr_stmt|;
name|State
operator|=
name|ALL_IS_CLOSED
expr_stmt|;
break|break;
case|case
name|INTERSECT_OPENED
case|:
if|if
condition|(
name|IntersectionMapping
condition|)
name|IntersectionMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
argument_list|,
name|CurrentLSuccessor
argument_list|)
expr_stmt|;
name|OpenPt
operator|=
name|Pt
operator|+
literal|1
expr_stmt|;
name|State
operator|=
name|R_OPENED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|void
name|onROpen
argument_list|(
argument|const IntTy&Pt
argument_list|,
argument|SuccessorClass *S
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|L_OPENED
case|:
if|if
condition|(
name|Pt
operator|>
name|OpenPt
operator|&&
name|LeftMapping
condition|)
name|LeftMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
operator|-
literal|1
argument_list|,
name|CurrentLSuccessor
argument_list|)
expr_stmt|;
name|State
operator|=
name|INTERSECT_OPENED
expr_stmt|;
break|break;
case|case
name|ALL_IS_CLOSED
case|:
name|State
operator|=
name|R_OPENED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
name|CurrentRSuccessor
operator|=
name|S
expr_stmt|;
name|OpenPt
operator|=
name|Pt
block|;           }
name|void
name|onRClose
argument_list|(
argument|const IntTy&Pt
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|R_OPENED
case|:
name|assert
argument_list|(
name|Pt
operator|>=
name|OpenPt
operator|&&
literal|"Subset is not sorted or contains overlapped ranges"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RightMapping
condition|)
name|RightMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
argument_list|,
name|CurrentRSuccessor
argument_list|)
expr_stmt|;
name|State
operator|=
name|ALL_IS_CLOSED
expr_stmt|;
break|break;
case|case
name|INTERSECT_OPENED
case|:
if|if
condition|(
name|IntersectionMapping
condition|)
name|IntersectionMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
argument_list|,
name|CurrentLSuccessor
argument_list|)
expr_stmt|;
name|OpenPt
operator|=
name|Pt
operator|+
literal|1
expr_stmt|;
name|State
operator|=
name|L_OPENED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|void
name|onLROpen
argument_list|(
argument|const IntTy&Pt
argument_list|,
argument|SuccessorClass *LS
argument_list|,
argument|SuccessorClass *RS
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|ALL_IS_CLOSED
case|:
name|State
operator|=
name|INTERSECT_OPENED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
name|CurrentLSuccessor
operator|=
name|LS
expr_stmt|;
name|CurrentRSuccessor
operator|=
name|RS
block|;
name|OpenPt
operator|=
name|Pt
block|;             }
name|void
name|onLRClose
argument_list|(
argument|const IntTy&Pt
argument_list|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|INTERSECT_OPENED
case|:
if|if
condition|(
name|IntersectionMapping
condition|)
name|IntersectionMapping
operator|->
name|add
argument_list|(
name|OpenPt
argument_list|,
name|Pt
argument_list|,
name|CurrentLSuccessor
argument_list|)
expr_stmt|;
name|State
operator|=
name|ALL_IS_CLOSED
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Got unexpected point."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|bool
name|isLOpened
argument_list|()
block|{
return|return
name|State
operator|==
name|L_OPENED
return|;
block|}
name|bool
name|isROpened
parameter_list|()
block|{
return|return
name|State
operator|==
name|R_OPENED
return|;
block|}
block|}
empty_stmt|;
name|public
label|:
comment|// Don't public CaseItems itself. Don't allow edit the Items directly.
comment|// Just present the user way to iterate over the internal collection
comment|// sharing iterator, begin() and end(). Editing should be controlled by
comment|// factory.
typedef|typedef
name|CaseItemIt
name|RangeIterator
typedef|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|SuccessorClass
operator|*
operator|,
name|IntegersSubsetTy
operator|>
name|Case
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|Case
operator|>
name|Cases
expr_stmt|;
typedef|typedef
name|typename
name|Cases
operator|::
name|iterator
name|CasesIt
expr_stmt|;
name|IntegersSubsetMapping
argument_list|()
block|{
name|Sorted
operator|=
name|false
expr_stmt|;
block|}
name|bool
name|verify
parameter_list|()
block|{
name|RangeIterator
name|DummyErrItem
decl_stmt|;
return|return
name|verify
argument_list|(
name|DummyErrItem
argument_list|)
return|;
block|}
name|bool
name|verify
parameter_list|(
name|RangeIterator
modifier|&
name|errItem
parameter_list|)
block|{
if|if
condition|(
name|Items
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
name|sort
argument_list|()
expr_stmt|;
for|for
control|(
name|CaseItemIt
name|j
init|=
name|Items
operator|.
name|begin
argument_list|()
init|,
name|i
init|=
name|j
operator|++
init|,
name|e
init|=
name|Items
operator|.
name|end
argument_list|()
init|;
name|j
operator|!=
name|e
condition|;
name|i
operator|=
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isIntersected
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|i
operator|->
name|second
operator|!=
name|j
operator|->
name|second
condition|)
block|{
name|errItem
operator|=
name|j
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
name|bool
name|isOverlapped
parameter_list|(
name|self
modifier|&
name|RHS
parameter_list|)
block|{
if|if
condition|(
name|Items
operator|.
name|empty
argument_list|()
operator|||
name|RHS
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
name|CaseItemIt
name|L
init|=
name|Items
operator|.
name|begin
argument_list|()
init|,
name|R
init|=
name|RHS
operator|.
name|Items
operator|.
name|begin
argument_list|()
init|,
name|el
init|=
name|Items
operator|.
name|end
argument_list|()
init|,
name|er
init|=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
init|;
name|L
operator|!=
name|el
operator|&&
name|R
operator|!=
name|er
condition|;
control|)
block|{
specifier|const
name|RangeTy
modifier|&
name|LRange
init|=
name|L
operator|->
name|first
decl_stmt|;
specifier|const
name|RangeTy
modifier|&
name|RRange
init|=
name|R
operator|->
name|first
decl_stmt|;
if|if
condition|(
name|LRange
operator|.
name|getLow
argument_list|()
operator|>
name|RRange
operator|.
name|getLow
argument_list|()
condition|)
block|{
if|if
condition|(
name|RRange
operator|.
name|isSingleNumber
argument_list|()
operator|||
name|LRange
operator|.
name|getLow
argument_list|()
operator|>
name|RRange
operator|.
name|getHigh
argument_list|()
condition|)
operator|++
name|R
expr_stmt|;
else|else
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|LRange
operator|.
name|getLow
argument_list|()
operator|<
name|RRange
operator|.
name|getLow
argument_list|()
condition|)
block|{
if|if
condition|(
name|LRange
operator|.
name|isSingleNumber
argument_list|()
operator|||
name|LRange
operator|.
name|getHigh
argument_list|()
operator|<
name|RRange
operator|.
name|getLow
argument_list|()
condition|)
operator|++
name|L
expr_stmt|;
else|else
return|return
name|true
return|;
block|}
else|else
comment|// iRange.getLow() == jRange.getLow()
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|void
name|optimize
parameter_list|()
block|{
if|if
condition|(
name|Items
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
return|return;
name|sort
argument_list|()
expr_stmt|;
name|CaseItems
name|OldItems
init|=
name|Items
decl_stmt|;
name|Items
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|IntTy
modifier|*
name|Low
init|=
operator|&
name|OldItems
operator|.
name|begin
argument_list|()
operator|->
name|first
operator|.
name|getLow
argument_list|()
decl_stmt|;
specifier|const
name|IntTy
modifier|*
name|High
init|=
operator|&
name|OldItems
operator|.
name|begin
argument_list|()
operator|->
name|first
operator|.
name|getHigh
argument_list|()
decl_stmt|;
name|unsigned
name|Weight
init|=
literal|1
decl_stmt|;
name|SuccessorClass
modifier|*
name|Successor
init|=
name|OldItems
operator|.
name|begin
argument_list|()
operator|->
name|second
decl_stmt|;
for|for
control|(
name|CaseItemIt
name|j
init|=
name|OldItems
operator|.
name|begin
argument_list|()
init|,
name|i
init|=
name|j
operator|++
init|,
name|e
init|=
name|OldItems
operator|.
name|end
argument_list|()
init|;
name|j
operator|!=
name|e
condition|;
name|i
operator|=
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isJoinable
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
condition|)
block|{
specifier|const
name|IntTy
modifier|*
name|CurHigh
init|=
operator|&
name|j
operator|->
name|first
operator|.
name|getHigh
argument_list|()
decl_stmt|;
operator|++
name|Weight
expr_stmt|;
if|if
condition|(
operator|*
name|CurHigh
operator|>
operator|*
name|High
condition|)
name|High
operator|=
name|CurHigh
expr_stmt|;
block|}
else|else
block|{
name|RangeEx
name|R
argument_list|(
operator|*
name|Low
argument_list|,
operator|*
name|High
argument_list|,
name|Weight
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|R
argument_list|,
name|Successor
argument_list|)
expr_stmt|;
name|Low
operator|=
operator|&
name|j
operator|->
name|first
operator|.
name|getLow
argument_list|()
expr_stmt|;
name|High
operator|=
operator|&
name|j
operator|->
name|first
operator|.
name|getHigh
argument_list|()
expr_stmt|;
name|Weight
operator|=
literal|1
expr_stmt|;
name|Successor
operator|=
name|j
operator|->
name|second
expr_stmt|;
block|}
block|}
name|RangeEx
name|R
argument_list|(
operator|*
name|Low
argument_list|,
operator|*
name|High
argument_list|,
name|Weight
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|R
argument_list|,
name|Successor
argument_list|)
expr_stmt|;
comment|// We recollected the Items, but we kept it sorted.
name|Sorted
operator|=
name|true
expr_stmt|;
block|}
comment|/// Adds a constant value.
name|void
name|add
parameter_list|(
specifier|const
name|IntTy
modifier|&
name|C
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
name|RangeTy
name|R
argument_list|(
name|C
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|R
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
comment|/// Adds a range.
name|void
name|add
parameter_list|(
specifier|const
name|IntTy
modifier|&
name|Low
parameter_list|,
specifier|const
name|IntTy
modifier|&
name|High
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
name|RangeTy
name|R
argument_list|(
name|Low
argument_list|,
name|High
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|R
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
name|void
name|add
parameter_list|(
specifier|const
name|RangeTy
modifier|&
name|R
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
name|RangeEx
name|REx
init|=
name|R
decl_stmt|;
name|add
argument_list|(
name|REx
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
name|void
name|add
parameter_list|(
specifier|const
name|RangeEx
modifier|&
name|R
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
name|Items
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
argument_list|,
name|S
argument_list|)
argument_list|)
expr_stmt|;
name|Sorted
operator|=
name|false
expr_stmt|;
block|}
comment|/// Adds all ranges and values from given ranges set to the current
comment|/// mapping.
name|void
name|add
parameter_list|(
specifier|const
name|IntegersSubsetTy
modifier|&
name|CRS
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|CRS
operator|.
name|getNumItems
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
name|RangeTy
name|R
init|=
name|CRS
operator|.
name|getItem
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|R
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|add
parameter_list|(
name|self
modifier|&
name|RHS
parameter_list|)
block|{
name|Items
operator|.
name|insert
argument_list|(
name|Items
operator|.
name|end
argument_list|()
argument_list|,
name|RHS
operator|.
name|Items
operator|.
name|begin
argument_list|()
argument_list|,
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|add
parameter_list|(
name|self
modifier|&
name|RHS
parameter_list|,
name|SuccessorClass
modifier|*
name|S
parameter_list|)
block|{
for|for
control|(
name|CaseItemIt
name|i
init|=
name|RHS
operator|.
name|Items
operator|.
name|begin
argument_list|()
init|,
name|e
init|=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|add
argument_list|(
name|i
operator|->
name|first
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
name|void
name|add
parameter_list|(
specifier|const
name|RangesCollection
modifier|&
name|RHS
parameter_list|,
name|SuccessorClass
modifier|*
name|S
init|=
literal|0
parameter_list|)
block|{
for|for
control|(
name|RangesCollectionConstIt
name|i
init|=
name|RHS
operator|.
name|begin
argument_list|()
init|,
name|e
init|=
name|RHS
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|add
argument_list|(
operator|*
name|i
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
comment|/// Removes items from set.
name|void
name|removeItem
parameter_list|(
name|RangeIterator
name|i
parameter_list|)
block|{
name|Items
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/// Moves whole case from current mapping to the NewMapping object.
name|void
name|detachCase
parameter_list|(
name|self
modifier|&
name|NewMapping
parameter_list|,
name|SuccessorClass
modifier|*
name|Succ
parameter_list|)
block|{
for|for
control|(
name|CaseItemIt
name|i
init|=
name|Items
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|;
control|)
if|if
condition|(
name|i
operator|->
name|second
operator|==
name|Succ
condition|)
block|{
name|NewMapping
operator|.
name|add
argument_list|(
name|i
operator|->
name|first
argument_list|,
name|i
operator|->
name|second
argument_list|)
expr_stmt|;
name|Items
operator|.
name|erase
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
comment|/// Removes all clusters for given successor.
name|void
name|removeCase
parameter_list|(
name|SuccessorClass
modifier|*
name|Succ
parameter_list|)
block|{
for|for
control|(
name|CaseItemIt
name|i
init|=
name|Items
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|;
control|)
if|if
condition|(
name|i
operator|->
name|second
operator|==
name|Succ
condition|)
block|{
name|Items
operator|.
name|erase
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
comment|/// Find successor that satisfies given value.
name|SuccessorClass
modifier|*
name|findSuccessor
parameter_list|(
specifier|const
name|IntTy
modifier|&
name|Val
parameter_list|)
block|{
for|for
control|(
name|CaseItemIt
name|i
init|=
name|Items
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|->
name|first
operator|.
name|isInRange
argument_list|(
name|Val
argument_list|)
condition|)
return|return
name|i
operator|->
name|second
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/// Calculates the difference between this mapping and RHS.
comment|/// THIS without RHS is placed into LExclude,
comment|/// RHS without THIS is placed into RExclude,
comment|/// THIS intersect RHS is placed into Intersection.
name|void
name|diff
parameter_list|(
name|self
modifier|*
name|LExclude
parameter_list|,
name|self
modifier|*
name|Intersection
parameter_list|,
name|self
modifier|*
name|RExclude
parameter_list|,
specifier|const
name|self
modifier|&
name|RHS
parameter_list|)
block|{
name|DiffStateMachine
name|Machine
argument_list|(
name|LExclude
argument_list|,
name|Intersection
argument_list|,
name|RExclude
argument_list|)
decl_stmt|;
name|CaseItemConstIt
name|L
init|=
name|Items
operator|.
name|begin
argument_list|()
decl_stmt|,
name|R
init|=
name|RHS
operator|.
name|Items
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|L
operator|!=
name|Items
operator|.
name|end
argument_list|()
operator|&&
name|R
operator|!=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|Cluster
modifier|&
name|LCluster
init|=
operator|*
name|L
decl_stmt|;
specifier|const
name|RangeEx
modifier|&
name|LRange
init|=
name|LCluster
operator|.
name|first
decl_stmt|;
specifier|const
name|Cluster
modifier|&
name|RCluster
init|=
operator|*
name|R
decl_stmt|;
specifier|const
name|RangeEx
modifier|&
name|RRange
init|=
name|RCluster
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|LRange
operator|.
name|getHigh
argument_list|()
operator|<
name|RRange
operator|.
name|getLow
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onLOpen
argument_list|(
name|LRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|LCluster
operator|.
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onLClose
argument_list|(
name|LRange
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LRange
operator|.
name|getLow
argument_list|()
operator|>
name|RRange
operator|.
name|getHigh
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onROpen
argument_list|(
name|RRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|RCluster
operator|.
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onRClose
argument_list|(
name|RRange
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|R
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LRange
operator|.
name|getLow
argument_list|()
operator|<
name|RRange
operator|.
name|getLow
argument_list|()
condition|)
block|{
comment|// May be opened in previous iteration.
if|if
condition|(
operator|!
name|Machine
operator|.
name|isLOpened
argument_list|()
condition|)
name|Machine
operator|.
name|onLOpen
argument_list|(
name|LRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|LCluster
operator|.
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onROpen
argument_list|(
name|RRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|RCluster
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RRange
operator|.
name|getLow
argument_list|()
operator|<
name|LRange
operator|.
name|getLow
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|Machine
operator|.
name|isROpened
argument_list|()
condition|)
name|Machine
operator|.
name|onROpen
argument_list|(
name|RRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|RCluster
operator|.
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onLOpen
argument_list|(
name|LRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|LCluster
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
else|else
name|Machine
operator|.
name|onLROpen
argument_list|(
name|LRange
operator|.
name|getLow
argument_list|()
argument_list|,
name|LCluster
operator|.
name|second
argument_list|,
name|RCluster
operator|.
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|LRange
operator|.
name|getHigh
argument_list|()
operator|<
name|RRange
operator|.
name|getHigh
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onLClose
argument_list|(
name|LRange
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
while|while
condition|(
name|L
operator|!=
name|Items
operator|.
name|end
argument_list|()
operator|&&
name|L
operator|->
name|first
operator|.
name|getHigh
argument_list|()
operator|<
name|RRange
operator|.
name|getHigh
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onLOpen
argument_list|(
name|L
operator|->
name|first
operator|.
name|getLow
argument_list|()
argument_list|,
name|L
operator|->
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onLClose
argument_list|(
name|L
operator|->
name|first
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|RRange
operator|.
name|getHigh
argument_list|()
operator|<
name|LRange
operator|.
name|getHigh
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onRClose
argument_list|(
name|RRange
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|R
expr_stmt|;
while|while
condition|(
name|R
operator|!=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
operator|&&
name|R
operator|->
name|first
operator|.
name|getHigh
argument_list|()
operator|<
name|LRange
operator|.
name|getHigh
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onROpen
argument_list|(
name|R
operator|->
name|first
operator|.
name|getLow
argument_list|()
argument_list|,
name|R
operator|->
name|second
argument_list|)
expr_stmt|;
name|Machine
operator|.
name|onRClose
argument_list|(
name|R
operator|->
name|first
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|R
expr_stmt|;
block|}
block|}
else|else
block|{
name|Machine
operator|.
name|onLRClose
argument_list|(
name|LRange
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
operator|++
name|R
expr_stmt|;
block|}
block|}
if|if
condition|(
name|L
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Machine
operator|.
name|isLOpened
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onLClose
argument_list|(
name|L
operator|->
name|first
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
block|}
if|if
condition|(
name|LExclude
condition|)
while|while
condition|(
name|L
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|)
block|{
name|LExclude
operator|->
name|add
argument_list|(
name|L
operator|->
name|first
argument_list|,
name|L
operator|->
name|second
argument_list|)
expr_stmt|;
operator|++
name|L
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|R
operator|!=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|Machine
operator|.
name|isROpened
argument_list|()
condition|)
block|{
name|Machine
operator|.
name|onRClose
argument_list|(
name|R
operator|->
name|first
operator|.
name|getHigh
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|R
expr_stmt|;
block|}
if|if
condition|(
name|RExclude
condition|)
while|while
condition|(
name|R
operator|!=
name|RHS
operator|.
name|Items
operator|.
name|end
argument_list|()
condition|)
block|{
name|RExclude
operator|->
name|add
argument_list|(
name|R
operator|->
name|first
argument_list|,
name|R
operator|->
name|second
argument_list|)
expr_stmt|;
operator|++
name|R
expr_stmt|;
block|}
block|}
block|}
comment|/// Builds the finalized case objects.
name|void
name|getCases
parameter_list|(
name|Cases
modifier|&
name|TheCases
parameter_list|,
name|bool
name|PreventMerging
init|=
name|false
parameter_list|)
block|{
comment|//FIXME: PreventMerging is a temporary parameter.
comment|//Currently a set of passes is still knows nothing about
comment|//switches with case ranges, and if these passes meet switch
comment|//with complex case that crashs the application.
if|if
condition|(
name|PreventMerging
condition|)
block|{
for|for
control|(
name|RangeIterator
name|i
init|=
name|this
operator|->
name|begin
argument_list|()
init|;
name|i
operator|!=
name|this
operator|->
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|RangesCollection
name|SingleRange
decl_stmt|;
name|SingleRange
operator|.
name|push_back
argument_list|(
name|i
operator|->
name|first
argument_list|)
expr_stmt|;
name|TheCases
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|i
operator|->
name|second
argument_list|,
name|IntegersSubsetTy
argument_list|(
name|SingleRange
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|CRSMap
name|TheCRSMap
decl_stmt|;
for|for
control|(
name|RangeIterator
name|i
init|=
name|this
operator|->
name|begin
argument_list|()
init|;
name|i
operator|!=
name|this
operator|->
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|TheCRSMap
index|[
name|i
operator|->
name|second
index|]
operator|.
name|push_back
argument_list|(
name|i
operator|->
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|CRSMapIt
name|i
init|=
name|TheCRSMap
operator|.
name|begin
argument_list|()
init|,
name|e
init|=
name|TheCRSMap
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|TheCases
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|i
operator|->
name|first
argument_list|,
name|IntegersSubsetTy
argument_list|(
name|i
operator|->
name|second
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Builds the finalized case objects ignoring successor values, as though
comment|/// all ranges belongs to the same successor.
name|IntegersSubsetTy
name|getCase
parameter_list|()
block|{
name|RangesCollection
name|Ranges
decl_stmt|;
for|for
control|(
name|RangeIterator
name|i
init|=
name|this
operator|->
name|begin
argument_list|()
init|;
name|i
operator|!=
name|this
operator|->
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|Ranges
operator|.
name|push_back
argument_list|(
name|i
operator|->
name|first
argument_list|)
expr_stmt|;
return|return
name|IntegersSubsetTy
argument_list|(
name|Ranges
argument_list|)
return|;
block|}
comment|/// Returns pointer to value of case if it is single-numbered or 0
comment|/// in another case.
specifier|const
name|IntTy
modifier|*
name|getCaseSingleNumber
parameter_list|(
name|SuccessorClass
modifier|*
name|Succ
parameter_list|)
block|{
specifier|const
name|IntTy
modifier|*
name|Res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CaseItemIt
name|i
init|=
name|Items
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|Items
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|->
name|second
operator|==
name|Succ
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|->
name|first
operator|.
name|isSingleNumber
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Res
condition|)
return|return
literal|0
return|;
else|else
name|Res
operator|=
operator|&
operator|(
name|i
operator|->
name|first
operator|.
name|getLow
argument_list|()
operator|)
expr_stmt|;
block|}
return|return
name|Res
return|;
block|}
comment|/// Returns true if there is no ranges and values inside.
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Items
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Items
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Don't reset Sorted flag:
comment|// 1. For empty mapping it matters nothing.
comment|// 2. After first item will added Sorted flag will cleared.
block|}
comment|// Returns number of clusters
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|Items
operator|.
name|size
argument_list|()
return|;
block|}
name|RangeIterator
name|begin
parameter_list|()
block|{
return|return
name|Items
operator|.
name|begin
argument_list|()
return|;
block|}
name|RangeIterator
name|end
parameter_list|()
block|{
return|return
name|Items
operator|.
name|end
argument_list|()
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|BasicBlock
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|IntegersSubsetMapping
operator|<
name|BasicBlock
operator|>
name|IntegersSubsetToBB
expr_stmt|;
end_typedef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRSBUILDER_H_ */
end_comment

end_unit

