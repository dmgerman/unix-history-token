begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- Allocator.h - Simple memory allocation abstraction -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This file defines the MallocAllocator and BumpPtrAllocator interfaces. Both
end_comment

begin_comment
comment|/// of these conform to an LLVM "Allocator" concept which consists of an
end_comment

begin_comment
comment|/// Allocate method accepting a size and alignment, and a Deallocate accepting
end_comment

begin_comment
comment|/// a pointer and size. Further, the LLVM "Allocator" concept has overloads of
end_comment

begin_comment
comment|/// Allocate and Deallocate for setting size and alignment based on the final
end_comment

begin_comment
comment|/// type. These overloads are typically provided by a base class template \c
end_comment

begin_comment
comment|/// AllocatorBase.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_ALLOCATOR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// \brief CRTP base class providing obvious overloads for the core \c
comment|/// Allocate() methods of LLVM-style allocators.
comment|///
comment|/// This base class both documents the full public interface exposed by all
comment|/// LLVM-style allocators, and redirects all of the overloads to a single core
comment|/// set of methods which the derived class must define.
name|template
operator|<
name|typename
name|DerivedT
operator|>
name|class
name|AllocatorBase
block|{
name|public
operator|:
comment|/// \brief Allocate \a Size bytes of \a Alignment aligned memory. This method
comment|/// must be implemented by \c DerivedT.
name|void
operator|*
name|Allocate
argument_list|(
argument|size_t Size
argument_list|,
argument|size_t Alignment
argument_list|)
block|{
ifdef|#
directive|ifdef
name|__clang__
name|static_assert
argument_list|(
name|static_cast
operator|<
name|void
operator|*
operator|(
name|AllocatorBase
operator|::
operator|*
operator|)
operator|(
name|size_t
operator|,
name|size_t
operator|)
operator|>
operator|(
operator|&
name|AllocatorBase
operator|::
name|Allocate
operator|)
operator|!=
name|static_cast
operator|<
name|void
operator|*
operator|(
name|DerivedT
operator|::
operator|*
operator|)
operator|(
name|size_t
operator|,
name|size_t
operator|)
operator|>
operator|(
operator|&
name|DerivedT
operator|::
name|Allocate
operator|)
argument_list|,
literal|"Class derives from AllocatorBase without implementing the "
literal|"core Allocate(size_t, size_t) overload!"
argument_list|)
block|;
endif|#
directive|endif
return|return
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|Allocate
argument_list|(
name|Size
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
comment|/// \brief Deallocate \a Ptr to \a Size bytes of memory allocated by this
comment|/// allocator.
name|void
name|Deallocate
argument_list|(
argument|const void *Ptr
argument_list|,
argument|size_t Size
argument_list|)
block|{
ifdef|#
directive|ifdef
name|__clang__
name|static_assert
argument_list|(
name|static_cast
operator|<
name|void
argument_list|(
name|AllocatorBase
operator|::
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
operator|>
operator|(
operator|&
name|AllocatorBase
operator|::
name|Deallocate
operator|)
operator|!=
name|static_cast
operator|<
name|void
argument_list|(
name|DerivedT
operator|::
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
operator|>
operator|(
operator|&
name|DerivedT
operator|::
name|Deallocate
operator|)
argument_list|,
literal|"Class derives from AllocatorBase without implementing the "
literal|"core Deallocate(void *) overload!"
argument_list|)
block|;
endif|#
directive|endif
return|return
name|static_cast
operator|<
name|DerivedT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|Deallocate
argument_list|(
name|Ptr
argument_list|,
name|Size
argument_list|)
return|;
block|}
comment|// The rest of these methods are helpers that redirect to one of the above
comment|// core methods.
comment|/// \brief Allocate space for a sequence of objects without constructing them.
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|Allocate
argument_list|(
argument|size_t Num =
literal|1
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Allocate
argument_list|(
name|Num
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
name|alignof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Deallocate space for a sequence of objects without constructing them.
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_same
operator|<
name|typename
name|std
operator|::
name|remove_cv
operator|<
name|T
operator|>
operator|::
name|type
block|,
name|void
operator|>
operator|::
name|value
block|,
name|void
operator|>
operator|::
name|type
name|Deallocate
argument_list|(
argument|T *Ptr
argument_list|,
argument|size_t Num =
literal|1
argument_list|)
block|{
name|Deallocate
argument_list|(
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|Ptr
operator|)
argument_list|,
name|Num
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
block|}
expr_stmt|;
name|class
name|MallocAllocator
range|:
name|public
name|AllocatorBase
operator|<
name|MallocAllocator
operator|>
block|{
name|public
operator|:
name|void
name|Reset
argument_list|()
block|{}
name|LLVM_ATTRIBUTE_RETURNS_NONNULL
name|void
operator|*
name|Allocate
argument_list|(
argument|size_t Size
argument_list|,
argument|size_t
comment|/*Alignment*/
argument_list|)
block|{
return|return
name|malloc
argument_list|(
name|Size
argument_list|)
return|;
block|}
comment|// Pull in base class overloads.
name|using
name|AllocatorBase
operator|<
name|MallocAllocator
operator|>
operator|::
name|Allocate
block|;
name|void
name|Deallocate
argument_list|(
argument|const void *Ptr
argument_list|,
argument|size_t
comment|/*Size*/
argument_list|)
block|{
name|free
argument_list|(
name|const_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|Ptr
operator|)
argument_list|)
block|;   }
comment|// Pull in base class overloads.
name|using
name|AllocatorBase
operator|<
name|MallocAllocator
operator|>
operator|::
name|Deallocate
block|;
name|void
name|PrintStats
argument_list|()
specifier|const
block|{}
block|}
decl_stmt|;
name|namespace
name|detail
block|{
comment|// We call out to an external function to actually print the message as the
comment|// printing code uses Allocator.h in its implementation.
name|void
name|printBumpPtrAllocatorStats
parameter_list|(
name|unsigned
name|NumSlabs
parameter_list|,
name|size_t
name|BytesAllocated
parameter_list|,
name|size_t
name|TotalMemory
parameter_list|)
function_decl|;
block|}
comment|// end namespace detail
comment|/// \brief Allocate memory in an ever growing pool, as if by bump-pointer.
comment|///
comment|/// This isn't strictly a bump-pointer allocator as it uses backing slabs of
comment|/// memory rather than relying on a boundless contiguous heap. However, it has
comment|/// bump-pointer semantics in that it is a monotonically growing pool of memory
comment|/// where every allocation is found by merely allocating the next N bytes in
comment|/// the slab, or the next N bytes in the next slab.
comment|///
comment|/// Note that this also has a threshold for forcing allocations above a certain
comment|/// size into their own slab.
comment|///
comment|/// The BumpPtrAllocatorImpl template defaults to using a MallocAllocator
comment|/// object, which wraps malloc, to allocate memory, but it can be changed to
comment|/// use a custom allocator.
name|template
operator|<
name|typename
name|AllocatorT
operator|=
name|MallocAllocator
operator|,
name|size_t
name|SlabSize
operator|=
literal|4096
operator|,
name|size_t
name|SizeThreshold
operator|=
name|SlabSize
operator|>
name|class
name|BumpPtrAllocatorImpl
operator|:
name|public
name|AllocatorBase
operator|<
name|BumpPtrAllocatorImpl
operator|<
name|AllocatorT
operator|,
name|SlabSize
operator|,
name|SizeThreshold
operator|>>
block|{
name|public
operator|:
name|static_assert
argument_list|(
name|SizeThreshold
operator|<=
name|SlabSize
argument_list|,
literal|"The SizeThreshold must be at most the SlabSize to ensure "
literal|"that objects larger than a slab go into their own memory "
literal|"allocation."
argument_list|)
block|;
name|BumpPtrAllocatorImpl
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|typename
name|T
operator|>
name|BumpPtrAllocatorImpl
argument_list|(
name|T
operator|&&
name|Allocator
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|std::forward<T&&>(Allocator)
argument_list|)
block|{}
comment|// Manually implement a move constructor as we must clear the old allocator's
comment|// slabs as a matter of correctness.
name|BumpPtrAllocatorImpl
argument_list|(
name|BumpPtrAllocatorImpl
operator|&&
name|Old
argument_list|)
operator|:
name|CurPtr
argument_list|(
name|Old
operator|.
name|CurPtr
argument_list|)
block|,
name|End
argument_list|(
name|Old
operator|.
name|End
argument_list|)
block|,
name|Slabs
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Old
operator|.
name|Slabs
argument_list|)
argument_list|)
block|,
name|CustomSizedSlabs
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Old
operator|.
name|CustomSizedSlabs
argument_list|)
argument_list|)
block|,
name|BytesAllocated
argument_list|(
name|Old
operator|.
name|BytesAllocated
argument_list|)
block|,
name|RedZoneSize
argument_list|(
name|Old
operator|.
name|RedZoneSize
argument_list|)
block|,
name|Allocator
argument_list|(
argument|std::move(Old.Allocator)
argument_list|)
block|{
name|Old
operator|.
name|CurPtr
operator|=
name|Old
operator|.
name|End
operator|=
name|nullptr
block|;
name|Old
operator|.
name|BytesAllocated
operator|=
literal|0
block|;
name|Old
operator|.
name|Slabs
operator|.
name|clear
argument_list|()
block|;
name|Old
operator|.
name|CustomSizedSlabs
operator|.
name|clear
argument_list|()
block|;   }
operator|~
name|BumpPtrAllocatorImpl
argument_list|()
block|{
name|DeallocateSlabs
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|Slabs
operator|.
name|end
argument_list|()
argument_list|)
block|;
name|DeallocateCustomSizedSlabs
argument_list|()
block|;   }
name|BumpPtrAllocatorImpl
operator|&
name|operator
operator|=
operator|(
name|BumpPtrAllocatorImpl
operator|&&
name|RHS
operator|)
block|{
name|DeallocateSlabs
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|Slabs
operator|.
name|end
argument_list|()
argument_list|)
block|;
name|DeallocateCustomSizedSlabs
argument_list|()
block|;
name|CurPtr
operator|=
name|RHS
operator|.
name|CurPtr
block|;
name|End
operator|=
name|RHS
operator|.
name|End
block|;
name|BytesAllocated
operator|=
name|RHS
operator|.
name|BytesAllocated
block|;
name|RedZoneSize
operator|=
name|RHS
operator|.
name|RedZoneSize
block|;
name|Slabs
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Slabs
argument_list|)
block|;
name|CustomSizedSlabs
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|CustomSizedSlabs
argument_list|)
block|;
name|Allocator
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Allocator
argument_list|)
block|;
name|RHS
operator|.
name|CurPtr
operator|=
name|RHS
operator|.
name|End
operator|=
name|nullptr
block|;
name|RHS
operator|.
name|BytesAllocated
operator|=
literal|0
block|;
name|RHS
operator|.
name|Slabs
operator|.
name|clear
argument_list|()
block|;
name|RHS
operator|.
name|CustomSizedSlabs
operator|.
name|clear
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Deallocate all but the current slab and reset the current pointer
comment|/// to the beginning of it, freeing all memory allocated so far.
name|void
name|Reset
argument_list|()
block|{
comment|// Deallocate all but the first slab, and deallocate all custom-sized slabs.
name|DeallocateCustomSizedSlabs
argument_list|()
block|;
name|CustomSizedSlabs
operator|.
name|clear
argument_list|()
block|;
if|if
condition|(
name|Slabs
operator|.
name|empty
argument_list|()
condition|)
return|return;
comment|// Reset the state.
name|BytesAllocated
operator|=
literal|0
block|;
name|CurPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|Slabs
operator|.
name|front
argument_list|()
block|;
name|End
operator|=
name|CurPtr
operator|+
name|SlabSize
block|;
name|__asan_poison_memory_region
argument_list|(
operator|*
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|computeSlabSize
argument_list|(
literal|0
argument_list|)
argument_list|)
block|;
name|DeallocateSlabs
argument_list|(
name|std
operator|::
name|next
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|)
argument_list|,
name|Slabs
operator|.
name|end
argument_list|()
argument_list|)
block|;
name|Slabs
operator|.
name|erase
argument_list|(
name|std
operator|::
name|next
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|)
argument_list|,
name|Slabs
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
comment|/// \brief Allocate space at the specified alignment.
name|LLVM_ATTRIBUTE_RETURNS_NONNULL
name|LLVM_ATTRIBUTE_RETURNS_NOALIAS
name|void
operator|*
name|Allocate
argument_list|(
argument|size_t Size
argument_list|,
argument|size_t Alignment
argument_list|)
block|{
name|assert
argument_list|(
name|Alignment
operator|>
literal|0
operator|&&
literal|"0-byte alignnment is not allowed. Use 1 instead."
argument_list|)
block|;
comment|// Keep track of how many bytes we've allocated.
name|BytesAllocated
operator|+=
name|Size
block|;
name|size_t
name|Adjustment
operator|=
name|alignmentAdjustment
argument_list|(
name|CurPtr
argument_list|,
name|Alignment
argument_list|)
block|;
name|assert
argument_list|(
name|Adjustment
operator|+
name|Size
operator|>=
name|Size
operator|&&
literal|"Adjustment + Size must not overflow"
argument_list|)
block|;
name|size_t
name|SizeToAllocate
operator|=
name|Size
block|;
if|#
directive|if
name|LLVM_ADDRESS_SANITIZER_BUILD
comment|// Add trailing bytes as a "red zone" under ASan.
name|SizeToAllocate
operator|+=
name|RedZoneSize
block|;
endif|#
directive|endif
comment|// Check if we have enough space.
if|if
condition|(
name|Adjustment
operator|+
name|SizeToAllocate
operator|<=
name|size_t
argument_list|(
name|End
operator|-
name|CurPtr
argument_list|)
condition|)
block|{
name|char
modifier|*
name|AlignedPtr
init|=
name|CurPtr
operator|+
name|Adjustment
decl_stmt|;
name|CurPtr
operator|=
name|AlignedPtr
operator|+
name|SizeToAllocate
expr_stmt|;
comment|// Update the allocation point of this memory block in MemorySanitizer.
comment|// Without this, MemorySanitizer messages for values originated from here
comment|// will point to the allocation of the entire slab.
name|__msan_allocated_memory
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
comment|// Similarly, tell ASan about this space.
name|__asan_unpoison_memory_region
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
return|return
name|AlignedPtr
return|;
block|}
comment|// If Size is really big, allocate a separate slab for it.
name|size_t
name|PaddedSize
init|=
name|SizeToAllocate
operator|+
name|Alignment
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|PaddedSize
operator|>
name|SizeThreshold
condition|)
block|{
name|void
modifier|*
name|NewSlab
init|=
name|Allocator
operator|.
name|Allocate
argument_list|(
name|PaddedSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// We own the new slab and don't want anyone reading anyting other than
comment|// pieces returned from this method.  So poison the whole slab.
name|__asan_poison_memory_region
argument_list|(
name|NewSlab
argument_list|,
name|PaddedSize
argument_list|)
expr_stmt|;
name|CustomSizedSlabs
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewSlab
argument_list|,
name|PaddedSize
argument_list|)
argument_list|)
expr_stmt|;
name|uintptr_t
name|AlignedAddr
init|=
name|alignAddr
argument_list|(
name|NewSlab
argument_list|,
name|Alignment
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|AlignedAddr
operator|+
name|Size
operator|<=
operator|(
name|uintptr_t
operator|)
name|NewSlab
operator|+
name|PaddedSize
argument_list|)
expr_stmt|;
name|char
modifier|*
name|AlignedPtr
init|=
operator|(
name|char
operator|*
operator|)
name|AlignedAddr
decl_stmt|;
name|__msan_allocated_memory
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
name|__asan_unpoison_memory_region
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
return|return
name|AlignedPtr
return|;
block|}
comment|// Otherwise, start a new slab and try again.
name|StartNewSlab
argument_list|()
expr_stmt|;
name|uintptr_t
name|AlignedAddr
init|=
name|alignAddr
argument_list|(
name|CurPtr
argument_list|,
name|Alignment
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|AlignedAddr
operator|+
name|SizeToAllocate
operator|<=
operator|(
name|uintptr_t
operator|)
name|End
operator|&&
literal|"Unable to allocate memory!"
argument_list|)
expr_stmt|;
name|char
modifier|*
name|AlignedPtr
init|=
operator|(
name|char
operator|*
operator|)
name|AlignedAddr
decl_stmt|;
name|CurPtr
operator|=
name|AlignedPtr
operator|+
name|SizeToAllocate
expr_stmt|;
name|__msan_allocated_memory
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
name|__asan_unpoison_memory_region
argument_list|(
name|AlignedPtr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
return|return
name|AlignedPtr
return|;
block|}
end_decl_stmt

begin_comment
comment|// Pull in base class overloads.
end_comment

begin_expr_stmt
name|using
name|AllocatorBase
operator|<
name|BumpPtrAllocatorImpl
operator|>
operator|::
name|Allocate
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Deallocate
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|,
name|size_t
name|Size
parameter_list|)
block|{
name|__asan_poison_memory_region
argument_list|(
name|Ptr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Pull in base class overloads.
end_comment

begin_expr_stmt
name|using
name|AllocatorBase
operator|<
name|BumpPtrAllocatorImpl
operator|>
operator|::
name|Deallocate
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetNumSlabs
argument_list|()
specifier|const
block|{
return|return
name|Slabs
operator|.
name|size
argument_list|()
operator|+
name|CustomSizedSlabs
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|getTotalMemory
argument_list|()
specifier|const
block|{
name|size_t
name|TotalMemory
operator|=
literal|0
block|;
for|for
control|(
name|auto
name|I
init|=
name|Slabs
operator|.
name|begin
argument_list|()
init|,
name|E
init|=
name|Slabs
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|TotalMemory
operator|+=
name|computeSlabSize
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|I
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
operator|&
name|PtrAndSize
operator|:
name|CustomSizedSlabs
control|)
name|TotalMemory
operator|+=
name|PtrAndSize
operator|.
name|second
expr_stmt|;
end_for

begin_return
return|return
name|TotalMemory
return|;
end_return

begin_macro
unit|}    size_t
name|getBytesAllocated
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|BytesAllocated
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setRedZoneSize
parameter_list|(
name|size_t
name|NewSize
parameter_list|)
block|{
name|RedZoneSize
operator|=
name|NewSize
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|void
name|PrintStats
argument_list|()
specifier|const
block|{
name|detail
operator|::
name|printBumpPtrAllocatorStats
argument_list|(
name|Slabs
operator|.
name|size
argument_list|()
argument_list|,
name|BytesAllocated
argument_list|,
name|getTotalMemory
argument_list|()
argument_list|)
block|;   }
name|private
operator|:
comment|/// \brief The current pointer into the current slab.
comment|///
comment|/// This points to the next free byte in the slab.
name|char
operator|*
name|CurPtr
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief The end of the current slab.
end_comment

begin_decl_stmt
name|char
modifier|*
name|End
init|=
name|nullptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief The slabs allocated so far.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|void
operator|*
operator|,
literal|4
operator|>
name|Slabs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Custom-sized slabs allocated for too-large allocation requests.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|void
operator|*
operator|,
name|size_t
operator|>
operator|,
literal|0
operator|>
name|CustomSizedSlabs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief How many bytes we've allocated.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Used so that we can compute how much space was wasted.
end_comment

begin_decl_stmt
name|size_t
name|BytesAllocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief The number of bytes to put between allocations when running under
end_comment

begin_comment
comment|/// a sanitizer.
end_comment

begin_decl_stmt
name|size_t
name|RedZoneSize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief The allocator instance we use to get slabs of memory.
end_comment

begin_decl_stmt
name|AllocatorT
name|Allocator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|computeSlabSize
parameter_list|(
name|unsigned
name|SlabIdx
parameter_list|)
block|{
comment|// Scale the actual allocated slab size based on the number of slabs
comment|// allocated. Every 128 slabs allocated, we double the allocated size to
comment|// reduce allocation frequency, but saturate at multiplying the slab size by
comment|// 2^30.
return|return
name|SlabSize
operator|*
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|std
operator|::
name|min
operator|<
name|size_t
operator|>
operator|(
literal|30
operator|,
name|SlabIdx
operator|/
literal|128
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Allocate a new slab and move the bump pointers over into the new
end_comment

begin_comment
comment|/// slab, modifying CurPtr and End.
end_comment

begin_function
name|void
name|StartNewSlab
parameter_list|()
block|{
name|size_t
name|AllocatedSlabSize
init|=
name|computeSlabSize
argument_list|(
name|Slabs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|void
modifier|*
name|NewSlab
init|=
name|Allocator
operator|.
name|Allocate
argument_list|(
name|AllocatedSlabSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// We own the new slab and don't want anyone reading anything other than
comment|// pieces returned from this method.  So poison the whole slab.
name|__asan_poison_memory_region
argument_list|(
name|NewSlab
argument_list|,
name|AllocatedSlabSize
argument_list|)
expr_stmt|;
name|Slabs
operator|.
name|push_back
argument_list|(
name|NewSlab
argument_list|)
expr_stmt|;
name|CurPtr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|NewSlab
operator|)
expr_stmt|;
name|End
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NewSlab
operator|)
operator|+
name|AllocatedSlabSize
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Deallocate a sequence of slabs.
end_comment

begin_decl_stmt
name|void
name|DeallocateSlabs
argument_list|(
name|SmallVectorImpl
operator|<
name|void
operator|*
operator|>
operator|::
name|iterator
name|I
argument_list|,
name|SmallVectorImpl
operator|<
name|void
operator|*
operator|>
operator|::
name|iterator
name|E
argument_list|)
block|{
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|size_t
name|AllocatedSlabSize
init|=
name|computeSlabSize
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|I
argument_list|)
argument_list|)
decl_stmt|;
name|Allocator
operator|.
name|Deallocate
argument_list|(
operator|*
name|I
argument_list|,
name|AllocatedSlabSize
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/// \brief Deallocate all memory for custom sized slabs.
end_comment

begin_function
name|void
name|DeallocateCustomSizedSlabs
parameter_list|()
block|{
for|for
control|(
name|auto
operator|&
name|PtrAndSize
operator|:
name|CustomSizedSlabs
control|)
block|{
name|void
modifier|*
name|Ptr
init|=
name|PtrAndSize
operator|.
name|first
decl_stmt|;
name|size_t
name|Size
init|=
name|PtrAndSize
operator|.
name|second
decl_stmt|;
name|Allocator
operator|.
name|Deallocate
argument_list|(
name|Ptr
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|friend
name|class
name|SpecificBumpPtrAllocator
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief The standard BumpPtrAllocator which just uses the default template
end_comment

begin_comment
comment|/// parameters.
end_comment

begin_typedef
typedef|typedef
name|BumpPtrAllocatorImpl
operator|<
operator|>
name|BumpPtrAllocator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief A BumpPtrAllocator that allows only elements of a specific type to be
end_comment

begin_comment
comment|/// allocated.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This allows calling the destructor in DestroyAll() and when the allocator is
end_comment

begin_comment
comment|/// destroyed.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SpecificBumpPtrAllocator
block|{
name|BumpPtrAllocator
name|Allocator
block|;
name|public
operator|:
name|SpecificBumpPtrAllocator
argument_list|()
block|{
comment|// Because SpecificBumpPtrAllocator walks the memory to call destructors,
comment|// it can't have red zones between allocations.
name|Allocator
operator|.
name|setRedZoneSize
argument_list|(
literal|0
argument_list|)
block|;   }
name|SpecificBumpPtrAllocator
argument_list|(
name|SpecificBumpPtrAllocator
operator|&&
name|Old
argument_list|)
operator|:
name|Allocator
argument_list|(
argument|std::move(Old.Allocator)
argument_list|)
block|{}
operator|~
name|SpecificBumpPtrAllocator
argument_list|()
block|{
name|DestroyAll
argument_list|()
block|; }
name|SpecificBumpPtrAllocator
operator|&
name|operator
operator|=
operator|(
name|SpecificBumpPtrAllocator
operator|&&
name|RHS
operator|)
block|{
name|Allocator
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Allocator
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Call the destructor of each allocated object and deallocate all but the
comment|/// current slab and reset the current pointer to the beginning of it, freeing
comment|/// all memory allocated so far.
name|void
name|DestroyAll
argument_list|()
block|{
name|auto
name|DestroyElements
operator|=
index|[]
operator|(
name|char
operator|*
name|Begin
operator|,
name|char
operator|*
name|End
operator|)
block|{
name|assert
argument_list|(
name|Begin
operator|==
operator|(
name|char
operator|*
operator|)
name|alignAddr
argument_list|(
name|Begin
argument_list|,
name|alignof
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|)
block|;
for|for
control|(
name|char
modifier|*
name|Ptr
init|=
name|Begin
init|;
name|Ptr
operator|+
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|<=
name|End
condition|;
name|Ptr
operator|+=
sizeof|sizeof
argument_list|(
name|T
argument_list|)
control|)
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Ptr
operator|)
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|I
init|=
name|Allocator
operator|.
name|Slabs
operator|.
name|begin
argument_list|()
init|,
name|E
init|=
name|Allocator
operator|.
name|Slabs
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|size_t
name|AllocatedSlabSize
init|=
name|BumpPtrAllocator
operator|::
name|computeSlabSize
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|Allocator
operator|.
name|Slabs
operator|.
name|begin
argument_list|()
argument_list|,
name|I
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|Begin
init|=
operator|(
name|char
operator|*
operator|)
name|alignAddr
argument_list|(
operator|*
name|I
argument_list|,
name|alignof
argument_list|(
name|T
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|End
init|=
operator|*
name|I
operator|==
name|Allocator
operator|.
name|Slabs
operator|.
name|back
argument_list|()
condition|?
name|Allocator
operator|.
name|CurPtr
else|:
operator|(
name|char
operator|*
operator|)
operator|*
name|I
operator|+
name|AllocatedSlabSize
decl_stmt|;
name|DestroyElements
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|auto
operator|&
name|PtrAndSize
operator|:
name|Allocator
operator|.
name|CustomSizedSlabs
control|)
block|{
name|void
modifier|*
name|Ptr
init|=
name|PtrAndSize
operator|.
name|first
decl_stmt|;
name|size_t
name|Size
init|=
name|PtrAndSize
operator|.
name|second
decl_stmt|;
name|DestroyElements
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alignAddr
argument_list|(
name|Ptr
argument_list|,
name|alignof
argument_list|(
name|T
argument_list|)
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Ptr
operator|+
name|Size
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|Allocator
operator|.
name|Reset
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief Allocate space for an array of objects without constructing them.
end_comment

begin_expr_stmt
unit|T
operator|*
name|Allocate
argument_list|(
argument|size_t num =
literal|1
argument_list|)
block|{
return|return
name|Allocator
operator|.
name|Allocate
operator|<
name|T
operator|>
operator|(
name|num
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace llvm
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|AllocatorT
operator|,
name|size_t
name|SlabSize
operator|,
name|size_t
name|SizeThreshold
operator|>
name|void
operator|*
name|operator
name|new
argument_list|(
argument|size_t Size
argument_list|,
argument|llvm::BumpPtrAllocatorImpl<AllocatorT
argument_list|,
argument|SlabSize
argument_list|,
argument|SizeThreshold>&Allocator
argument_list|)
block|{   struct
name|S
block|{
name|char
name|c
block|;
expr|union
block|{
name|double
name|D
block|;
name|long
name|double
name|LD
block|;
name|long
name|long
name|L
block|;
name|void
operator|*
name|P
block|;     }
name|x
block|;   }
block|;
return|return
name|Allocator
operator|.
name|Allocate
argument_list|(
name|Size
argument_list|,
name|std
operator|::
name|min
argument_list|(
operator|(
name|size_t
operator|)
name|llvm
operator|::
name|NextPowerOf2
argument_list|(
name|Size
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|S
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|AllocatorT
operator|,
name|size_t
name|SlabSize
operator|,
name|size_t
name|SizeThreshold
operator|>
name|void
name|operator
name|delete
argument_list|(
argument|void *
argument_list|,
argument|llvm::BumpPtrAllocatorImpl<AllocatorT
argument_list|,
argument|SlabSize
argument_list|,
argument|SizeThreshold>&
argument_list|)
block|{ }
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_ALLOCATOR_H
end_comment

end_unit

