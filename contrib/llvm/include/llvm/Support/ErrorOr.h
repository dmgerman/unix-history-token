begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/ErrorOr.h - Error Smart Pointer -----------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Provides ErrorOr<T> smart pointer.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_ERROR_OR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_ERROR_OR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/system_error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_if
if|#
directive|if
name|LLVM_HAS_CXX11_TYPETRAITS
end_if

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|llvm
block|{
struct|struct
name|ErrorHolderBase
block|{
name|error_code
name|Error
decl_stmt|;
name|uint16_t
name|RefCount
decl_stmt|;
name|bool
name|HasUserData
decl_stmt|;
name|ErrorHolderBase
argument_list|()
operator|:
name|RefCount
argument_list|(
literal|1
argument_list|)
block|{}
name|void
name|aquire
argument_list|()
block|{
operator|++
name|RefCount
block|;   }
name|void
name|release
argument_list|()
block|{
if|if
condition|(
operator|--
name|RefCount
operator|==
literal|0
condition|)
name|delete
name|this
decl_stmt|;
block|}
name|protected
label|:
name|virtual
operator|~
name|ErrorHolderBase
argument_list|()
block|{}
block|}
struct|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ErrorHolder
operator|:
name|ErrorHolderBase
block|{
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
name|ErrorHolder
argument_list|(
name|T
operator|&&
name|UD
argument_list|)
operator|:
name|UserData
argument_list|(
argument|llvm_move(UD)
argument_list|)
block|{}
else|#
directive|else
name|ErrorHolder
argument_list|(
name|T
operator|&
name|UD
argument_list|)
operator|:
name|UserData
argument_list|(
argument|UD
argument_list|)
block|{}
endif|#
directive|endif
name|T
name|UserData
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|Tp
operator|>
expr|struct
name|ErrorOrUserDataTraits
operator|:
name|llvm
operator|::
name|false_type
block|{}
expr_stmt|;
if|#
directive|if
name|LLVM_HAS_CXX11_TYPETRAITS
operator|&&
name|LLVM_HAS_RVALUE_REFERENCES
name|template
operator|<
name|class
name|T
operator|,
name|class
name|V
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_constructible
operator|<
name|T
operator|,
name|V
operator|>
operator|::
name|value
operator|,
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|V
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|&&
name|moveIfMoveConstructible
argument_list|(
argument|V&Val
argument_list|)
block|{
return|return
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|,
name|class
name|V
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_constructible
operator|<
name|T
operator|,
name|V
operator|>
operator|::
name|value
operator|,
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|V
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|&
name|moveIfMoveConstructible
argument_list|(
argument|V&Val
argument_list|)
block|{
return|return
name|Val
return|;
block|}
else|#
directive|else
name|template
operator|<
name|class
name|T
operator|,
name|class
name|V
operator|>
name|V
operator|&
name|moveIfMoveConstructible
argument_list|(
argument|V&Val
argument_list|)
block|{
return|return
name|Val
return|;
block|}
endif|#
directive|endif
comment|/// \brief Stores a reference that can be changed.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ReferenceStorage
block|{
name|T
operator|*
name|Storage
block|;
name|public
operator|:
name|ReferenceStorage
argument_list|(
name|T
operator|&
name|Ref
argument_list|)
operator|:
name|Storage
argument_list|(
argument|&Ref
argument_list|)
block|{}
name|operator
name|T
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|Storage
return|;
block|}
name|T
operator|&
name|get
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Storage
return|;
block|}
expr|}
block|;
comment|/// \brief Represents either an error or a value T.
comment|///
comment|/// ErrorOr<T> is a pointer-like class that represents the result of an
comment|/// operation. The result is either an error, or a value of type T. This is
comment|/// designed to emulate the usage of returning a pointer where nullptr indicates
comment|/// failure. However instead of just knowing that the operation failed, we also
comment|/// have an error_code and optional user data that describes why it failed.
comment|///
comment|/// It is used like the following.
comment|/// \code
comment|///   ErrorOr<Buffer> getBuffer();
comment|///   void handleError(error_code ec);
comment|///
comment|///   auto buffer = getBuffer();
comment|///   if (!buffer)
comment|///     handleError(buffer);
comment|///   buffer->write("adena");
comment|/// \endcode
comment|///
comment|/// ErrorOr<T> also supports user defined data for specific error_codes. To use
comment|/// this feature you must first add a template specialization of
comment|/// ErrorOrUserDataTraits derived from std::true_type for your type in the lld
comment|/// namespace. This specialization must have a static error_code error()
comment|/// function that returns the error_code this data is used with.
comment|///
comment|/// getError<UserData>() may be called to get either the stored user data, or
comment|/// a default constructed UserData if none was stored.
comment|///
comment|/// Example:
comment|/// \code
comment|///   struct InvalidArgError {
comment|///     InvalidArgError() {}
comment|///     InvalidArgError(std::string S) : ArgName(S) {}
comment|///     std::string ArgName;
comment|///   };
comment|///
comment|///   namespace llvm {
comment|///   template<>
comment|///   struct ErrorOrUserDataTraits<InvalidArgError> : std::true_type {
comment|///     static error_code error() {
comment|///       return make_error_code(errc::invalid_argument);
comment|///     }
comment|///   };
comment|///   } // end namespace llvm
comment|///
comment|///   using namespace llvm;
comment|///
comment|///   ErrorOr<int> foo() {
comment|///     return InvalidArgError("adena");
comment|///   }
comment|///
comment|///   int main() {
comment|///     auto a = foo();
comment|///     if (!a&& error_code(a) == errc::invalid_argument)
comment|///       llvm::errs()<< a.getError<InvalidArgError>().ArgName<< "\n";
comment|///   }
comment|/// \endcode
comment|///
comment|/// An implicit conversion to bool provides a way to check if there was an
comment|/// error. The unary * and -> operators provide pointer like access to the
comment|/// value. Accessing the value when there is an error has undefined behavior.
comment|///
comment|/// When T is a reference type the behaivor is slightly different. The reference
comment|/// is held in a std::reference_wrapper<std::remove_reference<T>::type>, and
comment|/// there is special handling to make operator -> work as if T was not a
comment|/// reference.
comment|///
comment|/// T cannot be a rvalue reference.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|ErrorOr
block|{
name|template
operator|<
name|class
name|OtherT
operator|>
name|friend
name|class
name|ErrorOr
block|;
specifier|static
specifier|const
name|bool
name|isRef
operator|=
name|is_reference
operator|<
name|T
operator|>
operator|::
name|value
block|;
typedef|typedef
name|ReferenceStorage
operator|<
name|typename
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|>
name|wrap
expr_stmt|;
name|public
operator|:
typedef|typedef
name|typename
name|conditional
operator|<
name|isRef
operator|,
name|wrap
operator|,
name|T
operator|>
operator|::
name|type
name|storage_type
expr_stmt|;
name|private
operator|:
typedef|typedef
name|typename
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|&
name|reference
expr_stmt|;
typedef|typedef
name|typename
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|*
name|pointer
expr_stmt|;
name|public
label|:
name|ErrorOr
argument_list|()
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{}
name|template
operator|<
name|class
name|E
operator|>
name|ErrorOr
argument_list|(
argument|E ErrorCode
argument_list|,
argument|typename enable_if_c<is_error_code_enum<E>::value ||                                             is_error_condition_enum<E>::value
argument_list|,
argument|void *>::type =
literal|0
argument_list|)
operator|:
name|HasError
argument_list|(
name|true
argument_list|)
operator|,
name|IsValid
argument_list|(
argument|true
argument_list|)
block|{
name|Error
operator|=
name|new
name|ErrorHolderBase
block|;
name|Error
operator|->
name|Error
operator|=
name|make_error_code
argument_list|(
name|ErrorCode
argument_list|)
block|;
name|Error
operator|->
name|HasUserData
operator|=
name|false
block|;   }
name|ErrorOr
argument_list|(
argument|llvm::error_code EC
argument_list|)
operator|:
name|HasError
argument_list|(
name|true
argument_list|)
operator|,
name|IsValid
argument_list|(
argument|true
argument_list|)
block|{
name|Error
operator|=
name|new
name|ErrorHolderBase
block|;
name|Error
operator|->
name|Error
operator|=
name|EC
block|;
name|Error
operator|->
name|HasUserData
operator|=
name|false
block|;   }
name|template
operator|<
name|class
name|UserDataT
operator|>
name|ErrorOr
argument_list|(
argument|UserDataT UD
argument_list|,
argument|typename           enable_if_c<ErrorOrUserDataTraits<UserDataT>::value>::type* =
literal|0
argument_list|)
operator|:
name|HasError
argument_list|(
name|true
argument_list|)
operator|,
name|IsValid
argument_list|(
argument|true
argument_list|)
block|{
name|Error
operator|=
name|new
name|ErrorHolder
operator|<
name|UserDataT
operator|>
operator|(
name|llvm_move
argument_list|(
name|UD
argument_list|)
operator|)
block|;
name|Error
operator|->
name|Error
operator|=
name|ErrorOrUserDataTraits
operator|<
name|UserDataT
operator|>
operator|::
name|error
argument_list|()
block|;
name|Error
operator|->
name|HasUserData
operator|=
name|true
block|;   }
name|ErrorOr
argument_list|(
argument|T Val
argument_list|)
operator|:
name|HasError
argument_list|(
name|false
argument_list|)
operator|,
name|IsValid
argument_list|(
argument|true
argument_list|)
block|{
name|new
argument_list|(
argument|get()
argument_list|)
name|storage_type
argument_list|(
name|moveIfMoveConstructible
operator|<
name|storage_type
operator|>
operator|(
name|Val
operator|)
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
specifier|const
name|ErrorOr
operator|&
name|Other
argument_list|)
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{
name|copyConstruct
argument_list|(
name|Other
argument_list|)
block|;   }
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
argument_list|(
specifier|const
name|ErrorOr
operator|<
name|OtherT
operator|>
operator|&
name|Other
argument_list|)
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{
name|copyConstruct
argument_list|(
name|Other
argument_list|)
block|;   }
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ErrorOr
operator|&
name|Other
operator|)
block|{
name|copyAssign
argument_list|(
name|Other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ErrorOr
operator|<
name|OtherT
operator|>
operator|&
name|Other
operator|)
block|{
name|copyAssign
argument_list|(
name|Other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
name|ErrorOr
argument_list|(
name|ErrorOr
operator|&&
name|Other
argument_list|)
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{
name|moveConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;   }
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
argument_list|(
name|ErrorOr
operator|<
name|OtherT
operator|>
operator|&&
name|Other
argument_list|)
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{
name|moveConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;   }
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
name|ErrorOr
operator|&&
name|Other
operator|)
block|{
name|moveAssign
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
name|ErrorOr
operator|<
name|OtherT
operator|>
operator|&&
name|Other
operator|)
block|{
name|moveAssign
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
operator|~
name|ErrorOr
argument_list|()
block|{
if|if
condition|(
operator|!
name|IsValid
condition|)
return|return;
if|if
condition|(
name|HasError
condition|)
name|Error
operator|->
name|release
argument_list|()
expr_stmt|;
else|else
name|get
argument_list|()
operator|->
operator|~
name|storage_type
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ET
operator|>
name|ET
name|getError
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsValid
operator|&&
literal|"Cannot get the error of a default constructed ErrorOr!"
argument_list|)
block|;
name|assert
argument_list|(
name|HasError
operator|&&
literal|"Cannot get an error if none exists!"
argument_list|)
block|;
name|assert
argument_list|(
name|ErrorOrUserDataTraits
operator|<
name|ET
operator|>
operator|::
name|error
argument_list|()
operator|==
name|Error
operator|->
name|Error
operator|&&
literal|"Incorrect user error data type for error!"
argument_list|)
block|;
if|if
condition|(
operator|!
name|Error
operator|->
name|HasUserData
condition|)
return|return
name|ET
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|reinterpret_cast
operator|<
specifier|const
name|ErrorHolder
operator|<
name|ET
operator|>
operator|*
operator|>
operator|(
name|Error
operator|)
operator|->
name|UserData
return|;
end_return

begin_function_decl
unit|}    typedef
name|void
function_decl|(
modifier|*
name|unspecified_bool_type
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|unspecified_bool_true
parameter_list|()
block|{}
end_function

begin_comment
comment|/// \brief Return false if there is an error.
end_comment

begin_expr_stmt
name|operator
name|unspecified_bool_type
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsValid
operator|&&
literal|"Can't do anything on a default constructed ErrorOr!"
argument_list|)
block|;
return|return
name|HasError
condition|?
literal|0
else|:
name|unspecified_bool_true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|operator
name|llvm
operator|::
name|error_code
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsValid
operator|&&
literal|"Can't do anything on a default constructed ErrorOr!"
argument_list|)
block|;
return|return
name|HasError
condition|?
name|Error
operator|->
name|Error
else|:
name|llvm
operator|::
name|error_code
operator|::
name|success
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|toPointer
argument_list|(
name|get
argument_list|()
argument_list|)
return|;
block|}
end_block

begin_function
name|reference
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|get
argument_list|()
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|OtherT
operator|>
name|void
name|copyConstruct
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|)
block|{
comment|// Construct an invalid ErrorOr if other is invalid.
if|if
condition|(
operator|!
name|Other
operator|.
name|IsValid
condition|)
return|return;
name|IsValid
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Other
operator|.
name|HasError
condition|)
block|{
comment|// Get the other value.
name|HasError
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|get()
argument_list|)
name|storage_type
argument_list|(
operator|*
name|Other
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Get other's error.
name|Error
operator|=
name|Other
operator|.
name|Error
expr_stmt|;
name|HasError
operator|=
name|true
expr_stmt|;
name|Error
operator|->
name|aquire
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}    template
operator|<
name|class
name|T1
operator|>
specifier|static
name|bool
name|compareThisIfSameType
argument_list|(
argument|const T1&a
argument_list|,
argument|const T1&b
argument_list|)
block|{
return|return
operator|&
name|a
operator|==
operator|&
name|b
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|static
name|bool
name|compareThisIfSameType
argument_list|(
argument|const T1&a
argument_list|,
argument|const T2&b
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|OtherT
operator|>
name|void
name|copyAssign
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|)
block|{
if|if
condition|(
name|compareThisIfSameType
argument_list|(
operator|*
name|this
argument_list|,
name|Other
argument_list|)
condition|)
return|return;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|Other
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
unit|}
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_expr_stmt
unit|template
operator|<
name|class
name|OtherT
operator|>
name|void
name|moveConstruct
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|)
block|{
comment|// Construct an invalid ErrorOr if other is invalid.
if|if
condition|(
operator|!
name|Other
operator|.
name|IsValid
condition|)
return|return;
name|IsValid
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Other
operator|.
name|HasError
condition|)
block|{
comment|// Get the other value.
name|HasError
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|get()
argument_list|)
name|storage_type
argument_list|(
name|std
operator|::
name|move
argument_list|(
operator|*
name|Other
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Tell other not to do any destruction.
name|Other
operator|.
name|IsValid
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|// Get other's error.
name|Error
operator|=
name|Other
operator|.
name|Error
expr_stmt|;
name|HasError
operator|=
name|true
expr_stmt|;
comment|// Tell other not to do any destruction.
name|Other
operator|.
name|IsValid
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}    template
operator|<
name|class
name|OtherT
operator|>
name|void
name|moveAssign
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|)
block|{
if|if
condition|(
name|compareThisIfSameType
argument_list|(
operator|*
name|this
argument_list|,
name|Other
argument_list|)
condition|)
return|return;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|pointer
name|toPointer
argument_list|(
argument|pointer Val
argument_list|)
end_macro

begin_block
block|{
return|return
name|Val
return|;
block|}
end_block

begin_function
name|pointer
name|toPointer
parameter_list|(
name|wrap
modifier|*
name|Val
parameter_list|)
block|{
return|return
operator|&
name|Val
operator|->
name|get
argument_list|()
return|;
block|}
end_function

begin_function
name|storage_type
modifier|*
name|get
parameter_list|()
block|{
name|assert
argument_list|(
name|IsValid
operator|&&
literal|"Can't do anything on a default constructed ErrorOr!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|HasError
operator|&&
literal|"Cannot get value when an error exists!"
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|storage_type
operator|*
operator|>
operator|(
name|TStorage
operator|.
name|buffer
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|storage_type
operator|*
name|get
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsValid
operator|&&
literal|"Can't do anything on a default constructed ErrorOr!"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|HasError
operator|&&
literal|"Cannot get value when an error exists!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
specifier|const
name|storage_type
operator|*
operator|>
operator|(
name|TStorage
operator|.
name|buffer
operator|)
return|;
block|}
end_expr_stmt

begin_union
union|union
block|{
name|AlignedCharArrayUnion
operator|<
name|storage_type
operator|>
name|TStorage
expr_stmt|;
name|ErrorHolderBase
modifier|*
name|Error
decl_stmt|;
block|}
union|;
end_union

begin_decl_stmt
name|bool
name|HasError
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|IsValid
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// ErrorOr specialization for void.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|ErrorOr
operator|<
name|void
operator|>
block|{
name|public
operator|:
name|ErrorOr
argument_list|()
operator|:
name|Error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{}
name|template
operator|<
name|class
name|E
operator|>
name|ErrorOr
argument_list|(
argument|E ErrorCode
argument_list|,
argument|typename enable_if_c<is_error_code_enum<E>::value ||                                             is_error_condition_enum<E>::value
argument_list|,
argument|void *> ::type =
literal|0
argument_list|)
operator|:
name|Error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
name|error_code
name|EC
operator|=
name|make_error_code
argument_list|(
name|ErrorCode
argument_list|)
block|;
if|if
condition|(
name|EC
operator|==
name|errc
operator|::
name|success
condition|)
block|{
name|Error
operator|.
name|setInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ErrorHolderBase
operator|*
name|EHB
operator|=
name|new
name|ErrorHolderBase
block|;
name|EHB
operator|->
name|Error
operator|=
name|EC
block|;
name|EHB
operator|->
name|HasUserData
operator|=
name|false
block|;
name|Error
operator|.
name|setPointer
argument_list|(
name|EHB
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
argument|llvm::error_code EC
argument_list|)
operator|:
name|Error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
if|if
condition|(
name|EC
operator|==
name|errc
operator|::
name|success
condition|)
block|{
name|Error
operator|.
name|setInt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ErrorHolderBase
operator|*
name|E
operator|=
name|new
name|ErrorHolderBase
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|E
operator|->
name|Error
operator|=
name|EC
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|E
operator|->
name|HasUserData
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Error
operator|.
name|setPointer
argument_list|(
name|E
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|class
name|UserDataT
operator|>
name|ErrorOr
argument_list|(
argument|UserDataT UD
argument_list|,
argument|typename           enable_if_c<ErrorOrUserDataTraits<UserDataT>::value>::type* =
literal|0
argument_list|)
operator|:
name|Error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
name|ErrorHolderBase
operator|*
name|E
operator|=
name|new
name|ErrorHolder
operator|<
name|UserDataT
operator|>
operator|(
name|llvm_move
argument_list|(
name|UD
argument_list|)
operator|)
block|;
name|E
operator|->
name|Error
operator|=
name|ErrorOrUserDataTraits
operator|<
name|UserDataT
operator|>
operator|::
name|error
argument_list|()
block|;
name|E
operator|->
name|HasUserData
operator|=
name|true
block|;
name|Error
operator|.
name|setPointer
argument_list|(
name|E
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
specifier|const
name|ErrorOr
operator|&
name|Other
argument_list|)
operator|:
name|Error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{
name|Error
operator|=
name|Other
operator|.
name|Error
block|;
if|if
condition|(
name|Other
operator|.
name|Error
operator|.
name|getPointer
argument_list|()
operator|->
name|Error
condition|)
block|{
name|Error
operator|.
name|getPointer
argument_list|()
operator|->
name|aquire
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    ErrorOr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ErrorOr
operator|&
name|Other
operator|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|Other
condition|)
return|return
operator|*
name|this
return|;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|Other
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_if
unit|}
if|#
directive|if
name|LLVM_HAS_RVALUE_REFERENCES
end_if

begin_expr_stmt
unit|ErrorOr
operator|(
name|ErrorOr
operator|&&
name|Other
operator|)
operator|:
name|Error
argument_list|(
literal|0
argument_list|)
block|{
comment|// Get other's error.
name|Error
operator|=
name|Other
operator|.
name|Error
block|;
comment|// Tell other not to do any destruction.
name|Other
operator|.
name|Error
operator|.
name|setPointer
argument_list|(
literal|0
argument_list|)
block|;   }
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
name|ErrorOr
operator|&&
name|Other
operator|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|Other
condition|)
return|return
operator|*
name|this
return|;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|~
name|ErrorOr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Error
operator|.
name|getPointer
argument_list|()
condition|)
name|Error
operator|.
name|getPointer
argument_list|()
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|template
operator|<
name|class
name|ET
operator|>
name|ET
name|getError
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|ErrorOrUserDataTraits
operator|<
name|ET
operator|>
operator|::
name|error
argument_list|()
operator|==
operator|*
name|this
operator|&&
literal|"Incorrect user error data type for error!"
argument_list|)
block|;
if|if
condition|(
operator|!
name|Error
operator|.
name|getPointer
argument_list|()
operator|->
name|HasUserData
condition|)
return|return
name|ET
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|reinterpret_cast
operator|<
specifier|const
name|ErrorHolder
operator|<
name|ET
operator|>
operator|*
operator|>
operator|(
name|Error
operator|.
name|getPointer
argument_list|()
operator|)
operator|->
name|UserData
return|;
end_return

begin_function_decl
unit|}    typedef
name|void
function_decl|(
modifier|*
name|unspecified_bool_type
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|unspecified_bool_true
parameter_list|()
block|{}
end_function

begin_comment
comment|/// \brief Return false if there is an error.
end_comment

begin_expr_stmt
name|operator
name|unspecified_bool_type
argument_list|()
specifier|const
block|{
return|return
name|Error
operator|.
name|getInt
argument_list|()
operator|?
name|unspecified_bool_true
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|operator
name|llvm
operator|::
name|error_code
argument_list|()
specifier|const
block|{
return|return
name|Error
operator|.
name|getInt
argument_list|()
operator|?
name|make_error_code
argument_list|(
name|errc
operator|::
name|success
argument_list|)
operator|:
name|Error
operator|.
name|getPointer
argument_list|()
operator|->
name|Error
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|// If the bit is 1, the error is success.
end_comment

begin_expr_stmt
name|llvm
operator|::
name|PointerIntPair
operator|<
name|ErrorHolderBase
operator|*
operator|,
literal|1
operator|>
name|Error
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|,
name|class
name|E
operator|>
name|typename
name|enable_if_c
operator|<
name|is_error_code_enum
operator|<
name|E
operator|>
operator|::
name|value
operator|||
name|is_error_condition_enum
operator|<
name|E
operator|>
operator|::
name|value
operator|,
name|bool
operator|>
operator|::
name|type
name|operator
operator|==
operator|(
name|ErrorOr
operator|<
name|T
operator|>
operator|&
name|Err
operator|,
name|E
name|Code
operator|)
block|{
return|return
name|error_code
argument_list|(
name|Err
argument_list|)
operator|==
name|Code
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

