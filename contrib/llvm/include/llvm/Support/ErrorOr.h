begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/ErrorOr.h - Error Smart Pointer -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Provides ErrorOr<T> smart pointer.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_ERROROR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_ERROROR_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|T
operator|,
name|class
name|V
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_constructible
operator|<
name|T
operator|,
name|V
operator|>
operator|::
name|value
operator|,
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|V
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|&&
name|moveIfMoveConstructible
argument_list|(
argument|V&Val
argument_list|)
block|{
return|return
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|,
name|class
name|V
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_constructible
operator|<
name|T
operator|,
name|V
operator|>
operator|::
name|value
operator|,
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|V
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|&
name|moveIfMoveConstructible
argument_list|(
argument|V&Val
argument_list|)
block|{
return|return
name|Val
return|;
block|}
comment|/// \brief Stores a reference that can be changed.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ReferenceStorage
block|{
name|T
operator|*
name|Storage
block|;
name|public
operator|:
name|ReferenceStorage
argument_list|(
name|T
operator|&
name|Ref
argument_list|)
operator|:
name|Storage
argument_list|(
argument|&Ref
argument_list|)
block|{}
name|operator
name|T
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|Storage
return|;
block|}
name|T
operator|&
name|get
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Storage
return|;
block|}
expr|}
block|;
comment|/// \brief Represents either an error or a value T.
comment|///
comment|/// ErrorOr<T> is a pointer-like class that represents the result of an
comment|/// operation. The result is either an error, or a value of type T. This is
comment|/// designed to emulate the usage of returning a pointer where nullptr indicates
comment|/// failure. However instead of just knowing that the operation failed, we also
comment|/// have an error_code and optional user data that describes why it failed.
comment|///
comment|/// It is used like the following.
comment|/// \code
comment|///   ErrorOr<Buffer> getBuffer();
comment|///
comment|///   auto buffer = getBuffer();
comment|///   if (error_code ec = buffer.getError())
comment|///     return ec;
comment|///   buffer->write("adena");
comment|/// \endcode
comment|///
comment|///
comment|/// Implicit conversion to bool returns true if there is a usable value. The
comment|/// unary * and -> operators provide pointer like access to the value. Accessing
comment|/// the value when there is an error has undefined behavior.
comment|///
comment|/// When T is a reference type the behaivor is slightly different. The reference
comment|/// is held in a std::reference_wrapper<std::remove_reference<T>::type>, and
comment|/// there is special handling to make operator -> work as if T was not a
comment|/// reference.
comment|///
comment|/// T cannot be a rvalue reference.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|ErrorOr
block|{
name|template
operator|<
name|class
name|OtherT
operator|>
name|friend
name|class
name|ErrorOr
block|;
specifier|static
specifier|const
name|bool
name|isRef
operator|=
name|std
operator|::
name|is_reference
operator|<
name|T
operator|>
operator|::
name|value
block|;
typedef|typedef
name|ReferenceStorage
operator|<
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|>
name|wrap
expr_stmt|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|conditional
operator|<
name|isRef
operator|,
name|wrap
operator|,
name|T
operator|>
operator|::
name|type
name|storage_type
expr_stmt|;
name|private
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|&
name|reference
expr_stmt|;
typedef|typedef
specifier|const
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|&
name|const_reference
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|*
name|pointer
expr_stmt|;
typedef|typedef
specifier|const
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|*
name|const_pointer
expr_stmt|;
name|public
label|:
name|template
operator|<
name|class
name|E
operator|>
name|ErrorOr
argument_list|(
argument|E ErrorCode
argument_list|,
argument|typename std::enable_if<std::is_error_code_enum<E>::value ||                                       std::is_error_condition_enum<E>::value
argument_list|,
argument|void *>::type =
literal|0
argument_list|)
operator|:
name|HasError
argument_list|(
argument|true
argument_list|)
block|{
name|new
argument_list|(
argument|getErrorStorage()
argument_list|)
name|std
operator|::
name|error_code
argument_list|(
name|make_error_code
argument_list|(
name|ErrorCode
argument_list|)
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
argument|std::error_code EC
argument_list|)
operator|:
name|HasError
argument_list|(
argument|true
argument_list|)
block|{
name|new
argument_list|(
argument|getErrorStorage()
argument_list|)
name|std
operator|::
name|error_code
argument_list|(
name|EC
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
argument|T Val
argument_list|)
operator|:
name|HasError
argument_list|(
argument|false
argument_list|)
block|{
name|new
argument_list|(
argument|getStorage()
argument_list|)
name|storage_type
argument_list|(
name|moveIfMoveConstructible
operator|<
name|storage_type
operator|>
operator|(
name|Val
operator|)
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
argument|const ErrorOr&Other
argument_list|)
block|{
name|copyConstruct
argument_list|(
name|Other
argument_list|)
block|;   }
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
block|{
name|copyConstruct
argument_list|(
name|Other
argument_list|)
block|;   }
name|template
operator|<
name|class
name|OtherT
operator|>
name|explicit
name|ErrorOr
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|,
argument|typename std::enable_if<           !std::is_convertible<OtherT
argument_list|,
argument|const T&>::value>::type * = nullptr
argument_list|)
block|{
name|copyConstruct
argument_list|(
name|Other
argument_list|)
block|;   }
name|ErrorOr
argument_list|(
argument|ErrorOr&&Other
argument_list|)
block|{
name|moveConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;   }
name|template
operator|<
name|class
name|OtherT
operator|>
name|ErrorOr
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
block|{
name|moveConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;   }
comment|// This might eventually need SFINAE but it's more complex than is_convertible
comment|//& I'm too lazy to write it right now.
name|template
operator|<
name|class
name|OtherT
operator|>
name|explicit
name|ErrorOr
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<!std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
block|{
name|moveConstruct
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;   }
name|ErrorOr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ErrorOr
operator|&
name|Other
operator|)
block|{
name|copyAssign
argument_list|(
name|Other
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|ErrorOr
modifier|&
name|operator
init|=
operator|(
name|ErrorOr
operator|&&
name|Other
operator|)
block|{
name|moveAssign
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
operator|~
name|ErrorOr
argument_list|()
block|{
if|if
condition|(
operator|!
name|HasError
condition|)
name|getStorage
argument_list|()
operator|->
operator|~
name|storage_type
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Return false if there is an error.
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|!
name|HasError
return|;
block|}
name|reference
name|get
parameter_list|()
block|{
return|return
operator|*
name|getStorage
argument_list|()
return|;
block|}
name|const_reference
name|get
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ErrorOr
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|get
argument_list|()
return|;
block|}
name|std
operator|::
name|error_code
name|getError
argument_list|()
specifier|const
block|{
return|return
name|HasError
operator|?
operator|*
name|getErrorStorage
argument_list|()
operator|:
name|std
operator|::
name|error_code
argument_list|()
return|;
block|}
name|pointer
name|operator
operator|->
expr|(
block|)
block|{
return|return
name|toPointer
argument_list|(
name|getStorage
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|const_pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|toPointer
argument_list|(
name|getStorage
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|reference
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|getStorage
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|getStorage
argument_list|()
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|OtherT
operator|>
name|void
name|copyConstruct
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|)
block|{
if|if
condition|(
operator|!
name|Other
operator|.
name|HasError
condition|)
block|{
comment|// Get the other value.
name|HasError
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|getStorage()
argument_list|)
name|storage_type
argument_list|(
operator|*
name|Other
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|// Get other's error.
name|HasError
operator|=
name|true
expr_stmt|;
name|new
argument_list|(
argument|getErrorStorage()
argument_list|)
name|std
operator|::
name|error_code
argument_list|(
name|Other
operator|.
name|getError
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    template
operator|<
name|class
name|T1
operator|>
specifier|static
name|bool
name|compareThisIfSameType
argument_list|(
argument|const T1&a
argument_list|,
argument|const T1&b
argument_list|)
block|{
return|return
operator|&
name|a
operator|==
operator|&
name|b
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|static
name|bool
name|compareThisIfSameType
argument_list|(
argument|const T1&a
argument_list|,
argument|const T2&b
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|OtherT
operator|>
name|void
name|copyAssign
argument_list|(
argument|const ErrorOr<OtherT>&Other
argument_list|)
block|{
if|if
condition|(
name|compareThisIfSameType
argument_list|(
operator|*
name|this
argument_list|,
name|Other
argument_list|)
condition|)
return|return;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|Other
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|class
name|OtherT
operator|>
name|void
name|moveConstruct
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|)
block|{
if|if
condition|(
operator|!
name|Other
operator|.
name|HasError
condition|)
block|{
comment|// Get the other value.
name|HasError
operator|=
name|false
expr_stmt|;
name|new
argument_list|(
argument|getStorage()
argument_list|)
name|storage_type
argument_list|(
name|std
operator|::
name|move
argument_list|(
operator|*
name|Other
operator|.
name|getStorage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|// Get other's error.
name|HasError
operator|=
name|true
expr_stmt|;
name|new
argument_list|(
argument|getErrorStorage()
argument_list|)
name|std
operator|::
name|error_code
argument_list|(
name|Other
operator|.
name|getError
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    template
operator|<
name|class
name|OtherT
operator|>
name|void
name|moveAssign
argument_list|(
argument|ErrorOr<OtherT>&&Other
argument_list|)
block|{
if|if
condition|(
name|compareThisIfSameType
argument_list|(
operator|*
name|this
argument_list|,
name|Other
argument_list|)
condition|)
return|return;
name|this
operator|->
block|~
name|ErrorOr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|new
argument_list|(
argument|this
argument_list|)
end_macro

begin_expr_stmt
name|ErrorOr
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    pointer
name|toPointer
argument_list|(
argument|pointer Val
argument_list|)
end_macro

begin_block
block|{
return|return
name|Val
return|;
block|}
end_block

begin_decl_stmt
name|const_pointer
name|toPointer
argument_list|(
name|const_pointer
name|Val
argument_list|)
decl|const
block|{
return|return
name|Val
return|;
block|}
end_decl_stmt

begin_function
name|pointer
name|toPointer
parameter_list|(
name|wrap
modifier|*
name|Val
parameter_list|)
block|{
return|return
operator|&
name|Val
operator|->
name|get
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|const_pointer
name|toPointer
argument_list|(
specifier|const
name|wrap
operator|*
name|Val
argument_list|)
decl|const
block|{
return|return
operator|&
name|Val
operator|->
name|get
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|storage_type
modifier|*
name|getStorage
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|HasError
operator|&&
literal|"Cannot get value when an error exists!"
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|storage_type
operator|*
operator|>
operator|(
name|TStorage
operator|.
name|buffer
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|storage_type
operator|*
name|getStorage
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|HasError
operator|&&
literal|"Cannot get value when an error exists!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
specifier|const
name|storage_type
operator|*
operator|>
operator|(
name|TStorage
operator|.
name|buffer
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|error_code
operator|*
name|getErrorStorage
argument_list|()
block|{
name|assert
argument_list|(
name|HasError
operator|&&
literal|"Cannot get error when a value exists!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|std
operator|::
name|error_code
operator|*
operator|>
operator|(
name|ErrorStorage
operator|.
name|buffer
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|std
operator|::
name|error_code
operator|*
name|getErrorStorage
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ErrorOr
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getErrorStorage
argument_list|()
return|;
block|}
end_expr_stmt

begin_union
union|union
block|{
name|AlignedCharArrayUnion
operator|<
name|storage_type
operator|>
name|TStorage
expr_stmt|;
name|AlignedCharArrayUnion
operator|<
name|std
operator|::
name|error_code
operator|>
name|ErrorStorage
expr_stmt|;
block|}
union|;
end_union

begin_decl_stmt
name|bool
name|HasError
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|,
name|class
name|E
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_error_code_enum
operator|<
name|E
operator|>
operator|::
name|value
operator|||
name|std
operator|::
name|is_error_condition_enum
operator|<
name|E
operator|>
operator|::
name|value
operator|,
name|bool
operator|>
operator|::
name|type
name|operator
operator|==
operator|(
specifier|const
name|ErrorOr
operator|<
name|T
operator|>
operator|&
name|Err
operator|,
name|E
name|Code
operator|)
block|{
return|return
name|Err
operator|.
name|getError
argument_list|()
operator|==
name|Code
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

