begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===--- ConvertUTF.h - Universal Character Names conversions ---------------===  *  *                     The LLVM Compiler Infrastructure  *  * This file is distributed under the University of Illinois Open Source  * License. See LICENSE.TXT for details.  *  *==------------------------------------------------------------------------==*/
end_comment

begin_comment
comment|/*  * Copyright 2001-2004 Unicode, Inc.  *  * Disclaimer  *  * This source code is provided as is by Unicode, Inc. No claims are  * made as to fitness for any particular purpose. No warranties of any  * kind are expressed or implied. The recipient agrees to determine  * applicability of information provided. If this file has been  * purchased on magnetic or optical media from Unicode, Inc., the  * sole remedy for any claim will be exchange of defective media  * within 90 days of receipt.  *  * Limitations on Rights to Redistribute This Code  *  * Unicode, Inc. hereby grants the right to freely use the information  * supplied in this file in the creation of products supporting the  * Unicode Standard, and to make copies of this file in any form  * for internal or external distribution as long as this notice  * remains attached.  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------      Conversions between UTF32, UTF-16, and UTF-8.  Header file.      Several funtions are included here, forming a complete set of     conversions between the three formats.  UTF-7 is not included     here, but is handled in a separate source file.      Each of these routines takes pointers to input buffers and output     buffers.  The input buffers are const.      Each routine converts the text between *sourceStart and sourceEnd,     putting the result into the buffer between *targetStart and     targetEnd. Note: the end pointers are *after* the last item: e.g.     *(sourceEnd - 1) is the last item.      The return result indicates whether the conversion was successful,     and if not, whether the problem was in the source or target buffers.     (Only the first encountered problem is indicated.)      After the conversion, *sourceStart and *targetStart are both     updated to point to the end of last text successfully converted in     the respective buffers.      Input parameters:         sourceStart - pointer to a pointer to the source buffer.                 The contents of this are modified on return so that                 it points at the next thing to be converted.         targetStart - similarly, pointer to pointer to the target buffer.         sourceEnd, targetEnd - respectively pointers to the ends of the                 two buffers, for overflow checking only.      These conversion functions take a ConversionFlags argument. When this     flag is set to strict, both irregular sequences and isolated surrogates     will cause an error.  When the flag is set to lenient, both irregular     sequences and isolated surrogates are converted.      Whether the flag is strict or lenient, all illegal sequences will cause     an error return. This includes sequences such as:<F4 90 80 80>,<C0 80>,     or<A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code     must check for illegal sequences.      When the flag is set to lenient, characters over 0x10FFFF are converted     to the replacement character; otherwise (when the flag is set to strict)     they constitute an error.      Output parameters:         The value "sourceIllegal" is returned from some routines if the input         sequence is malformed.  When "sourceIllegal" is returned, the source         value will point to the illegal value that caused the problem. E.g.,         in UTF-8 when a sequence is malformed, it points to the start of the         malformed sequence.      Author: Mark E. Davis, 1994.     Rev History: Rick McGowan, fixes& updates May 2001.          Fixes& updates, Sept 2001.  ------------------------------------------------------------------------ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_CONVERTUTF_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_CONVERTUTF_H
end_define

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_comment
comment|// Wrap everything in namespace llvm so that programs can link with llvm and
end_comment

begin_comment
comment|// their own version of the unicode libraries.
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/* ---------------------------------------------------------------------     The following 4 definitions are compiler-specific.     The C standard does not guarantee that wchar_t has at least     16 bits, so wchar_t is no less portable than unsigned short!     All should be unsigned values to avoid sign extension during     bit mask& shift operations. ------------------------------------------------------------------------ */
typedef|typedef
name|unsigned
name|int
name|UTF32
typedef|;
comment|/* at least 32 bits */
typedef|typedef
name|unsigned
name|short
name|UTF16
typedef|;
comment|/* at least 16 bits */
typedef|typedef
name|unsigned
name|char
name|UTF8
typedef|;
comment|/* typically 8 bits */
typedef|typedef
name|unsigned
name|char
name|Boolean
typedef|;
comment|/* 0 or 1 */
comment|/* Some fundamental constants */
define|#
directive|define
name|UNI_REPLACEMENT_CHAR
value|(UTF32)0x0000FFFD
define|#
directive|define
name|UNI_MAX_BMP
value|(UTF32)0x0000FFFF
define|#
directive|define
name|UNI_MAX_UTF16
value|(UTF32)0x0010FFFF
define|#
directive|define
name|UNI_MAX_UTF32
value|(UTF32)0x7FFFFFFF
define|#
directive|define
name|UNI_MAX_LEGAL_UTF32
value|(UTF32)0x0010FFFF
define|#
directive|define
name|UNI_MAX_UTF8_BYTES_PER_CODE_POINT
value|4
define|#
directive|define
name|UNI_UTF16_BYTE_ORDER_MARK_NATIVE
value|0xFEFF
define|#
directive|define
name|UNI_UTF16_BYTE_ORDER_MARK_SWAPPED
value|0xFFFE
typedef|typedef
enum|enum
block|{
name|conversionOK
block|,
comment|/* conversion successful */
name|sourceExhausted
block|,
comment|/* partial character in source, but hit end */
name|targetExhausted
block|,
comment|/* insuff. room in target for conversion */
name|sourceIllegal
comment|/* source sequence is illegal/malformed */
block|}
name|ConversionResult
typedef|;
typedef|typedef
enum|enum
block|{
name|strictConversion
init|=
literal|0
block|,
name|lenientConversion
block|}
name|ConversionFlags
typedef|;
name|ConversionResult
name|ConvertUTF8toUTF16
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF16
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF16
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Convert a partial UTF8 sequence to UTF32.  If the sequence ends in an  * incomplete code unit sequence, returns \c sourceExhausted.  */
name|ConversionResult
name|ConvertUTF8toUTF32Partial
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF32
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Convert a partial UTF8 sequence to UTF32.  If the sequence ends in an  * incomplete code unit sequence, returns \c sourceIllegal.  */
name|ConversionResult
name|ConvertUTF8toUTF32
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF32
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
name|ConversionResult
name|ConvertUTF16toUTF8
parameter_list|(
specifier|const
name|UTF16
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF16
modifier|*
name|sourceEnd
parameter_list|,
name|UTF8
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF8
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
name|ConversionResult
name|ConvertUTF32toUTF8
parameter_list|(
specifier|const
name|UTF32
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF32
modifier|*
name|sourceEnd
parameter_list|,
name|UTF8
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF8
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
name|ConversionResult
name|ConvertUTF16toUTF32
parameter_list|(
specifier|const
name|UTF16
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF16
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF32
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
name|ConversionResult
name|ConvertUTF32toUTF16
parameter_list|(
specifier|const
name|UTF32
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF32
modifier|*
name|sourceEnd
parameter_list|,
name|UTF16
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF16
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
function_decl|;
name|Boolean
name|isLegalUTF8Sequence
parameter_list|(
specifier|const
name|UTF8
modifier|*
name|source
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|)
function_decl|;
name|Boolean
name|isLegalUTF8String
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|source
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|)
function_decl|;
name|unsigned
name|getNumBytesForUTF8
parameter_list|(
name|UTF8
name|firstByte
parameter_list|)
function_decl|;
comment|/*************************************************************************/
comment|/* Below are LLVM-specific wrappers of the functions above. */
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ArrayRef
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SmallVectorImpl
expr_stmt|;
name|class
name|StringRef
decl_stmt|;
comment|/**  * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on  * WideCharWidth. The converted data is written to ResultPtr, which needs to  * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,  * ResultPtr will point one after the end of the copied string. On failure,  * ResultPtr will not be changed, and ErrorPtr will be set to the location of  * the first character which could not be converted.  * \return true on success.  */
name|bool
name|ConvertUTF8toWide
argument_list|(
name|unsigned
name|WideCharWidth
argument_list|,
name|llvm
operator|::
name|StringRef
name|Source
argument_list|,
name|char
operator|*
operator|&
name|ResultPtr
argument_list|,
specifier|const
name|UTF8
operator|*
operator|&
name|ErrorPtr
argument_list|)
decl_stmt|;
comment|/** * Converts a UTF-8 StringRef to a std::wstring. * \return true on success. */
name|bool
name|ConvertUTF8toWide
argument_list|(
name|llvm
operator|::
name|StringRef
name|Source
argument_list|,
name|std
operator|::
name|wstring
operator|&
name|Result
argument_list|)
decl_stmt|;
comment|/** * Converts a UTF-8 C-string to a std::wstring. * \return true on success. */
name|bool
name|ConvertUTF8toWide
argument_list|(
specifier|const
name|char
operator|*
name|Source
argument_list|,
name|std
operator|::
name|wstring
operator|&
name|Result
argument_list|)
decl_stmt|;
comment|/** * Converts a std::wstring to a UTF-8 encoded std::string. * \return true on success. */
name|bool
name|convertWideToUTF8
argument_list|(
specifier|const
name|std
operator|::
name|wstring
operator|&
name|Source
argument_list|,
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
comment|/**  * Convert an Unicode code point to UTF8 sequence.  *  * \param Source a Unicode code point.  * \param [in,out] ResultPtr pointer to the output buffer, needs to be at least  * \c UNI_MAX_UTF8_BYTES_PER_CODE_POINT bytes.  On success \c ResultPtr is  * updated one past end of the converted sequence.  *  * \returns true on success.  */
name|bool
name|ConvertCodePointToUTF8
parameter_list|(
name|unsigned
name|Source
parameter_list|,
name|char
modifier|*
modifier|&
name|ResultPtr
parameter_list|)
function_decl|;
comment|/**  * Convert the first UTF8 sequence in the given source buffer to a UTF32  * code point.  *  * \param [in,out] source A pointer to the source buffer. If the conversion  * succeeds, this pointer will be updated to point to the byte just past the  * end of the converted sequence.  * \param sourceEnd A pointer just past the end of the source buffer.  * \param [out] target The converted code  * \param flags Whether the conversion is strict or lenient.  *  * \returns conversionOK on success  *  * \sa ConvertUTF8toUTF32  */
specifier|static
specifier|inline
name|ConversionResult
name|convertUTF8Sequence
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|source
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
name|target
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|*
name|source
operator|==
name|sourceEnd
condition|)
return|return
name|sourceExhausted
return|;
name|unsigned
name|size
init|=
name|getNumBytesForUTF8
argument_list|(
operator|*
operator|*
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ptrdiff_t
operator|)
name|size
operator|>
name|sourceEnd
operator|-
operator|*
name|source
condition|)
return|return
name|sourceExhausted
return|;
return|return
name|ConvertUTF8toUTF32
argument_list|(
name|source
argument_list|,
operator|*
name|source
operator|+
name|size
argument_list|,
operator|&
name|target
argument_list|,
name|target
operator|+
literal|1
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/**  * Returns true if a blob of text starts with a UTF-16 big or little endian byte  * order mark.  */
name|bool
name|hasUTF16ByteOrderMark
argument_list|(
name|ArrayRef
operator|<
name|char
operator|>
name|SrcBytes
argument_list|)
decl_stmt|;
comment|/**  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.  *  * \param [in] SrcBytes A buffer of what is assumed to be UTF-16 encoded text.  * \param [out] Out Converted UTF-8 is stored here on success.  * \returns true on success  */
name|bool
name|convertUTF16ToUTF8String
argument_list|(
name|ArrayRef
operator|<
name|char
operator|>
name|SrcBytes
argument_list|,
name|std
operator|::
name|string
operator|&
name|Out
argument_list|)
decl_stmt|;
comment|/** * Converts a UTF16 string into a UTF8 std::string. * * \param [in] Src A buffer of UTF-16 encoded text. * \param [out] Out Converted UTF-8 is stored here on success. * \returns true on success */
name|bool
name|convertUTF16ToUTF8String
argument_list|(
name|ArrayRef
operator|<
name|UTF16
operator|>
name|Src
argument_list|,
name|std
operator|::
name|string
operator|&
name|Out
argument_list|)
decl_stmt|;
comment|/**  * Converts a UTF-8 string into a UTF-16 string with native endianness.  *  * \returns true on success  */
name|bool
name|convertUTF8ToUTF16String
argument_list|(
name|StringRef
name|SrcUTF8
argument_list|,
name|SmallVectorImpl
operator|<
name|UTF16
operator|>
operator|&
name|DstUTF16
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* end namespace llvm */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

