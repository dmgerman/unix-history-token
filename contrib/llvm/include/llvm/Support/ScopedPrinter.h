begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ScopedPrinter.h ---------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_SCOPEDPRINTER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_SCOPEDPRINTER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/APSInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|EnumEntry
block|{
name|StringRef
name|Name
block|;
comment|// While Name suffices in most of the cases, in certain cases
comment|// GNU style and LLVM style of ELFDumper do not
comment|// display same string for same enum. The AltName if initialized appropriately
comment|// will hold the string that GNU style emits.
comment|// Example:
comment|// "EM_X86_64" string on LLVM style for Elf_Ehdr->e_machine corresponds to
comment|// "Advanced Micro Devices X86-64" on GNU style
name|StringRef
name|AltName
block|;
name|T
name|Value
block|;
name|EnumEntry
argument_list|(
argument|StringRef N
argument_list|,
argument|StringRef A
argument_list|,
argument|T V
argument_list|)
operator|:
name|Name
argument_list|(
name|N
argument_list|)
block|,
name|AltName
argument_list|(
name|A
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|EnumEntry
argument_list|(
argument|StringRef N
argument_list|,
argument|T V
argument_list|)
operator|:
name|Name
argument_list|(
name|N
argument_list|)
block|,
name|AltName
argument_list|(
name|N
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
block|}
expr_stmt|;
struct|struct
name|HexNumber
block|{
comment|// To avoid sign-extension we have to explicitly cast to the appropriate
comment|// unsigned type. The overloads are here so that every type that is implicitly
comment|// convertible to an integer (including enums and endian helpers) can be used
comment|// without requiring type traits or call-site changes.
name|HexNumber
argument_list|(
argument|char Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned char>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|signed char Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned char>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|signed short Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned short>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|signed int Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned int>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|signed long Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned long>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|signed long long Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<unsigned long long>(Value)
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|unsigned char Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|unsigned short Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|unsigned int Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|unsigned long Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|HexNumber
argument_list|(
argument|unsigned long long Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{}
name|uint64_t
name|Value
decl_stmt|;
block|}
struct|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|HexNumber
operator|&
name|Value
operator|)
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|to_hexString
argument_list|(
argument|uint64_t Value
argument_list|,
argument|bool UpperCase = true
argument_list|)
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
specifier|const
name|std
operator|::
name|string
name|to_string
argument_list|(
argument|const T&Value
argument_list|)
block|{
name|std
operator|::
name|string
name|number
block|;
name|llvm
operator|::
name|raw_string_ostream
name|stream
argument_list|(
name|number
argument_list|)
block|;
name|stream
operator|<<
name|Value
block|;
return|return
name|stream
operator|.
name|str
argument_list|()
return|;
block|}
name|class
name|ScopedPrinter
block|{
name|public
label|:
name|ScopedPrinter
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
operator|:
name|OS
argument_list|(
name|OS
argument_list|)
operator|,
name|IndentLevel
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|flush
argument_list|()
block|{
name|OS
operator|.
name|flush
argument_list|()
block|; }
name|void
name|indent
argument_list|(
argument|int Levels =
literal|1
argument_list|)
block|{
name|IndentLevel
operator|+=
name|Levels
block|; }
name|void
name|unindent
argument_list|(
argument|int Levels =
literal|1
argument_list|)
block|{
name|IndentLevel
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|IndentLevel
operator|-
name|Levels
argument_list|)
block|;   }
name|void
name|resetIndent
argument_list|()
block|{
name|IndentLevel
operator|=
literal|0
block|; }
name|void
name|setPrefix
argument_list|(
argument|StringRef P
argument_list|)
block|{
name|Prefix
operator|=
name|P
block|; }
name|void
name|printIndent
argument_list|()
block|{
name|OS
operator|<<
name|Prefix
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IndentLevel
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
literal|"  "
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|HexNumber
name|hex
argument_list|(
argument|T Value
argument_list|)
block|{
return|return
name|HexNumber
argument_list|(
name|Value
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|TEnum
operator|>
name|void
name|printEnum
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|,
argument|ArrayRef<EnumEntry<TEnum>> EnumValues
argument_list|)
block|{
name|StringRef
name|Name
block|;
name|bool
name|Found
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|EnumItem
range|:
name|EnumValues
control|)
block|{
if|if
condition|(
name|EnumItem
operator|.
name|Value
operator|==
name|Value
condition|)
block|{
name|Name
operator|=
name|EnumItem
operator|.
name|Name
expr_stmt|;
name|Found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Found
condition|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Name
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
block|}
else|else
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|TFlag
operator|>
name|void
name|printFlags
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|,
argument|ArrayRef<EnumEntry<TFlag>> Flags
argument_list|,
argument|TFlag EnumMask1 = {}
argument_list|,
argument|TFlag EnumMask2 = {}
argument_list|,
argument|TFlag EnumMask3 = {}
argument_list|)
block|{
typedef|typedef
name|EnumEntry
operator|<
name|TFlag
operator|>
name|FlagEntry
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|FlagEntry
operator|,
literal|10
operator|>
name|FlagVector
expr_stmt|;
name|FlagVector
name|SetFlags
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Flag
range|:
name|Flags
control|)
block|{
if|if
condition|(
name|Flag
operator|.
name|Value
operator|==
literal|0
condition|)
continue|continue;
name|TFlag
name|EnumMask
block|{}
empty_stmt|;
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask1
condition|)
name|EnumMask
operator|=
name|EnumMask1
expr_stmt|;
elseif|else
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask2
condition|)
name|EnumMask
operator|=
name|EnumMask2
expr_stmt|;
elseif|else
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask3
condition|)
name|EnumMask
operator|=
name|EnumMask3
expr_stmt|;
name|bool
name|IsEnum
init|=
operator|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|IsEnum
operator|&&
operator|(
name|Value
operator|&
name|Flag
operator|.
name|Value
operator|)
operator|==
name|Flag
operator|.
name|Value
operator|)
operator|||
operator|(
name|IsEnum
operator|&&
operator|(
name|Value
operator|&
name|EnumMask
operator|)
operator|==
name|Flag
operator|.
name|Value
operator|)
condition|)
block|{
name|SetFlags
operator|.
name|push_back
argument_list|(
name|Flag
argument_list|)
expr_stmt|;
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|SetFlags
operator|.
name|begin
argument_list|()
argument_list|,
name|SetFlags
operator|.
name|end
argument_list|()
argument_list|,
operator|&
name|flagName
operator|<
name|TFlag
operator|>
argument_list|)
expr_stmt|;
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|" [ ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Flag
range|:
name|SetFlags
control|)
block|{
name|startLine
argument_list|()
operator|<<
literal|"  "
operator|<<
name|Flag
operator|.
name|Name
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Flag
operator|.
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
block|}
name|startLine
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printFlags
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|" [ ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
block|;
name|uint64_t
name|Flag
operator|=
literal|1
block|;
name|uint64_t
name|Curr
operator|=
name|Value
block|;
while|while
condition|(
name|Curr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|Curr
operator|&
literal|1
condition|)
name|startLine
argument_list|()
operator|<<
literal|"  "
operator|<<
name|hex
argument_list|(
name|Flag
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
name|Curr
operator|>>=
literal|1
expr_stmt|;
name|Flag
operator|<<=
literal|1
expr_stmt|;
block|}
name|startLine
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint32_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint16_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint8_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|unsigned
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int64_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int32_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int16_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int8_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|int
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
specifier|const
name|APSInt
modifier|&
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printBoolean
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|bool
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
operator|(
name|Value
condition|?
literal|"Yes"
else|:
literal|"No"
operator|)
operator|<<
literal|'\n'
expr_stmt|;
block|}
name|template
operator|<
name|typename
operator|...
name|T
operator|>
name|void
name|printVersion
argument_list|(
argument|StringRef Label
argument_list|,
argument|T... Version
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
block|;
name|printVersionInternal
argument_list|(
name|Version
operator|...
argument_list|)
block|;
name|getOStream
argument_list|()
operator|<<
literal|"\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printList
argument_list|(
argument|StringRef Label
argument_list|,
argument|const T&List
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": ["
block|;
name|bool
name|Comma
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Item
range|:
name|List
control|)
block|{
if|if
condition|(
name|Comma
condition|)
name|OS
operator|<<
literal|", "
expr_stmt|;
name|OS
operator|<<
name|Item
expr_stmt|;
name|Comma
operator|=
name|true
expr_stmt|;
block|}
name|OS
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|void
name|printList
argument_list|(
argument|StringRef Label
argument_list|,
argument|const T&List
argument_list|,
argument|const U&Printer
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": ["
block|;
name|bool
name|Comma
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Item
range|:
name|List
control|)
block|{
if|if
condition|(
name|Comma
condition|)
name|OS
operator|<<
literal|", "
expr_stmt|;
name|Printer
argument_list|(
name|OS
argument_list|,
name|Item
argument_list|)
expr_stmt|;
name|Comma
operator|=
name|true
expr_stmt|;
block|}
name|OS
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printHexList
argument_list|(
argument|StringRef Label
argument_list|,
argument|const T&List
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": ["
block|;
name|bool
name|Comma
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Item
range|:
name|List
control|)
block|{
if|if
condition|(
name|Comma
condition|)
name|OS
operator|<<
literal|", "
expr_stmt|;
name|OS
operator|<<
name|hex
argument_list|(
name|Item
argument_list|)
expr_stmt|;
name|Comma
operator|=
name|true
expr_stmt|;
block|}
name|OS
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printHex
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printHex
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Str
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printSymbolOffset
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Symbol
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Symbol
operator|<<
literal|'+'
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|'\n'
block|;   }
name|void
name|printString
argument_list|(
argument|StringRef Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Value
operator|<<
literal|"\n"
block|; }
name|void
name|printString
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
block|;   }
name|void
name|printString
argument_list|(
argument|StringRef Label
argument_list|,
argument|const std::string&Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printNumber
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Str
operator|<<
literal|" ("
operator|<<
name|Value
operator|<<
literal|")\n"
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|Str
argument_list|,
name|Value
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|ArrayRef<char> Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|Str
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|Value
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<char> Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinaryBlock
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|,
argument|uint32_t StartOffset
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|Value
argument_list|,
name|true
argument_list|,
name|StartOffset
argument_list|)
block|;   }
name|void
name|printBinaryBlock
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|Value
argument_list|,
name|true
argument_list|)
block|;   }
name|void
name|printBinaryBlock
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|true
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printObject
argument_list|(
argument|StringRef Label
argument_list|,
argument|const T&Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
block|;   }
name|raw_ostream
operator|&
name|startLine
argument_list|()
block|{
name|printIndent
argument_list|()
block|;
return|return
name|OS
return|;
block|}
name|raw_ostream
modifier|&
name|getOStream
parameter_list|()
block|{
return|return
name|OS
return|;
block|}
name|private
label|:
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printVersionInternal
argument_list|(
argument|T Value
argument_list|)
block|{
name|getOStream
argument_list|()
operator|<<
name|Value
block|;   }
name|template
operator|<
name|typename
name|S
operator|,
name|typename
name|T
operator|,
name|typename
operator|...
name|TArgs
operator|>
name|void
name|printVersionInternal
argument_list|(
argument|S Value
argument_list|,
argument|T Value2
argument_list|,
argument|TArgs... Args
argument_list|)
block|{
name|getOStream
argument_list|()
operator|<<
name|Value
operator|<<
literal|"."
block|;
name|printVersionInternal
argument_list|(
name|Value2
argument_list|,
name|Args
operator|...
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|flagName
argument_list|(
argument|const EnumEntry<T>&lhs
argument_list|,
argument|const EnumEntry<T>&rhs
argument_list|)
block|{
return|return
name|lhs
operator|.
name|Name
operator|<
name|rhs
operator|.
name|Name
return|;
block|}
name|void
name|printBinaryImpl
argument_list|(
name|StringRef
name|Label
argument_list|,
name|StringRef
name|Str
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|Value
argument_list|,
name|bool
name|Block
argument_list|,
name|uint32_t
name|StartOffset
operator|=
literal|0
argument_list|)
decl_stmt|;
name|raw_ostream
modifier|&
name|OS
decl_stmt|;
name|int
name|IndentLevel
decl_stmt|;
name|StringRef
name|Prefix
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
specifier|inline
name|void
name|ScopedPrinter
operator|::
name|printHex
operator|<
name|support
operator|::
name|ulittle16_t
operator|>
operator|(
name|StringRef
name|Label
operator|,
name|support
operator|::
name|ulittle16_t
name|Value
operator|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
block|; }
name|template
operator|<
name|char
name|Open
operator|,
name|char
name|Close
operator|>
expr|struct
name|DelimitedScope
block|{
name|explicit
name|DelimitedScope
argument_list|(
name|ScopedPrinter
operator|&
name|W
argument_list|)
operator|:
name|W
argument_list|(
argument|W
argument_list|)
block|{
name|W
operator|.
name|startLine
argument_list|()
operator|<<
name|Open
operator|<<
literal|'\n'
block|;
name|W
operator|.
name|indent
argument_list|()
block|;   }
name|DelimitedScope
argument_list|(
argument|ScopedPrinter&W
argument_list|,
argument|StringRef N
argument_list|)
operator|:
name|W
argument_list|(
argument|W
argument_list|)
block|{
name|W
operator|.
name|startLine
argument_list|()
operator|<<
name|N
block|;
if|if
condition|(
operator|!
name|N
operator|.
name|empty
argument_list|()
condition|)
name|W
operator|.
name|getOStream
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|W
operator|.
name|getOStream
argument_list|()
operator|<<
name|Open
operator|<<
literal|'\n'
block|;
name|W
operator|.
name|indent
argument_list|()
block|;   }
operator|~
name|DelimitedScope
argument_list|()
block|{
name|W
operator|.
name|unindent
argument_list|()
block|;
name|W
operator|.
name|startLine
argument_list|()
operator|<<
name|Close
operator|<<
literal|'\n'
block|;   }
name|ScopedPrinter
operator|&
name|W
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|};
name|using
name|DictScope
init|=
name|DelimitedScope
operator|<
literal|'{'
decl_stmt|, '}'>;
end_decl_stmt

begin_decl_stmt
name|using
name|ListScope
init|=
name|DelimitedScope
operator|<
literal|'['
decl_stmt|, ']'>;
end_decl_stmt

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

