begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Support/Parallel.h - Parallel algorithms ----------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_PARALLEL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_PARALLEL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Config/llvm-config.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<condition_variable>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|LLVM_ENABLE_THREADS
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4530
name|)
end_pragma

begin_include
include|#
directive|include
file|<concrt.h>
end_include

begin_include
include|#
directive|include
file|<ppl.h>
end_include

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|parallel
block|{
struct|struct
name|sequential_execution_policy
block|{}
struct|;
struct|struct
name|parallel_execution_policy
block|{}
struct|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_execution_policy
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|llvm
operator|::
name|is_one_of
operator|<
name|T
operator|,
name|sequential_execution_policy
operator|,
name|parallel_execution_policy
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
name|constexpr
name|sequential_execution_policy
name|seq
block|{}
empty_stmt|;
name|constexpr
name|parallel_execution_policy
name|par
block|{}
empty_stmt|;
name|namespace
name|detail
block|{
if|#
directive|if
name|LLVM_ENABLE_THREADS
name|class
name|Latch
block|{
name|uint32_t
name|Count
decl_stmt|;
name|mutable
name|std
operator|::
name|mutex
name|Mutex
expr_stmt|;
name|mutable
name|std
operator|::
name|condition_variable
name|Cond
expr_stmt|;
name|public
label|:
name|explicit
name|Latch
argument_list|(
argument|uint32_t Count =
literal|0
argument_list|)
block|:
name|Count
argument_list|(
argument|Count
argument_list|)
block|{}
operator|~
name|Latch
argument_list|()
block|{
name|sync
argument_list|()
block|; }
name|void
name|inc
argument_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|Mutex
argument_list|)
block|;
operator|++
name|Count
block|;   }
name|void
name|dec
argument_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|Mutex
argument_list|)
block|;
if|if
condition|(
operator|--
name|Count
operator|==
literal|0
condition|)
name|Cond
operator|.
name|notify_all
argument_list|()
expr_stmt|;
block|}
name|void
name|sync
argument_list|()
specifier|const
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|Mutex
argument_list|)
block|;
name|Cond
operator|.
name|wait
argument_list|(
name|lock
argument_list|,
index|[
operator|&
index|]
block|{
return|return
name|Count
operator|==
literal|0
return|;
block|}
argument_list|)
block|;   }
block|}
empty_stmt|;
name|class
name|TaskGroup
block|{
name|Latch
name|L
decl_stmt|;
name|public
label|:
name|void
name|spawn
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|f
argument_list|)
decl_stmt|;
name|void
name|sync
argument_list|()
specifier|const
block|{
name|L
operator|.
name|sync
argument_list|()
block|; }
block|}
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|>
name|void
name|parallel_sort
argument_list|(
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_sort
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|)
block|; }
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each
argument_list|(
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
name|template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each_n
argument_list|(
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_for
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
else|#
directive|else
specifier|const
name|ptrdiff_t
name|MinParallelSize
operator|=
literal|1024
expr_stmt|;
comment|/// \brief Inclusive median.
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|>
name|RandomAccessIterator
name|medianOf3
argument_list|(
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp
argument_list|)
block|{
name|RandomAccessIterator
name|Mid
operator|=
name|Start
operator|+
operator|(
name|std
operator|::
name|distance
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
operator|/
literal|2
operator|)
block|;
return|return
name|Comp
argument_list|(
operator|*
name|Start
argument_list|,
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|)
condition|?
operator|(
name|Comp
argument_list|(
operator|*
name|Mid
argument_list|,
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|)
condition|?
operator|(
name|Comp
argument_list|(
operator|*
name|Start
argument_list|,
operator|*
name|Mid
argument_list|)
condition|?
name|Mid
else|:
name|Start
operator|)
else|:
name|End
operator|-
literal|1
operator|)
else|:
operator|(
name|Comp
argument_list|(
operator|*
name|Mid
argument_list|,
operator|*
name|Start
argument_list|)
condition|?
operator|(
name|Comp
argument_list|(
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|Mid
argument_list|)
condition|?
name|Mid
else|:
name|End
operator|-
literal|1
operator|)
else|:
name|Start
operator|)
return|;
block|}
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|>
name|void
name|parallel_quick_sort
argument_list|(
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp
argument_list|,
argument|TaskGroup&TG
argument_list|,
argument|size_t Depth
argument_list|)
block|{
comment|// Do a sequential sort for small inputs.
if|if
condition|(
name|std
operator|::
name|distance
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
operator|<
name|detail
operator|::
name|MinParallelSize
operator|||
name|Depth
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Partition.
name|auto
name|Pivot
init|=
name|medianOf3
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|)
decl_stmt|;
comment|// Move Pivot to End.
name|std
operator|::
name|swap
argument_list|(
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|Pivot
argument_list|)
expr_stmt|;
name|Pivot
operator|=
name|std
operator|::
name|partition
argument_list|(
name|Start
argument_list|,
name|End
operator|-
literal|1
argument_list|,
index|[
operator|&
name|Comp
operator|,
name|End
index|]
operator|(
name|decltype
argument_list|(
argument|*Start
argument_list|)
name|V
operator|)
block|{
return|return
name|Comp
argument_list|(
name|V
argument_list|,
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
block|)
decl_stmt|;
comment|// Move Pivot to middle of partition.
name|std
operator|::
name|swap
argument_list|(
operator|*
name|Pivot
argument_list|,
operator|*
operator|(
name|End
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|// Recurse.
name|TG
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Comp
operator|,
operator|&
name|TG
index|]
block|{
name|parallel_quick_sort
argument_list|(
name|Start
argument_list|,
name|Pivot
argument_list|,
name|Comp
argument_list|,
name|TG
argument_list|,
name|Depth
operator|-
literal|1
argument_list|)
block|;   }
argument_list|)
expr_stmt|;
name|parallel_quick_sort
argument_list|(
name|Pivot
operator|+
literal|1
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|,
name|TG
argument_list|,
name|Depth
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|>
name|void
name|parallel_sort
argument_list|(
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp
argument_list|)
block|{
name|TaskGroup
name|TG
block|;
name|parallel_quick_sort
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|,
name|TG
argument_list|,
name|llvm
operator|::
name|Log2_64
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
block|; }
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each
argument_list|(
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
comment|// TaskGroup has a relatively high overhead, so we want to reduce
comment|// the number of spawn() calls. We'll create up to 1024 tasks here.
comment|// (Note that 1024 is an arbitrary number. This code probably needs
comment|// improving to take the number of available cores into account.)
name|ptrdiff_t
name|TaskSize
operator|=
name|std
operator|::
name|distance
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
operator|/
literal|1024
block|;
if|if
condition|(
name|TaskSize
operator|==
literal|0
condition|)
name|TaskSize
operator|=
literal|1
expr_stmt|;
name|TaskGroup
name|TG
expr_stmt|;
while|while
condition|(
name|TaskSize
operator|<=
name|std
operator|::
name|distance
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
condition|)
block|{
name|TG
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|Begin
operator|+
name|TaskSize
argument_list|,
name|Fn
argument_list|)
block|; }
argument_list|)
expr_stmt|;
name|Begin
operator|+=
name|TaskSize
expr_stmt|;
block|}
name|TG
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each_n
argument_list|(
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|ptrdiff_t
name|TaskSize
operator|=
operator|(
name|End
operator|-
name|Begin
operator|)
operator|/
literal|1024
block|;
if|if
condition|(
name|TaskSize
operator|==
literal|0
condition|)
name|TaskSize
operator|=
literal|1
expr_stmt|;
name|TaskGroup
name|TG
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|IndexTy
name|I
init|=
name|Begin
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|I
operator|+
name|TaskSize
operator|<
name|End
condition|;
name|I
operator|+=
name|TaskSize
control|)
block|{
name|TG
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
for|for
control|(
name|IndexTy
name|J
init|=
name|I
init|,
name|E
init|=
name|I
operator|+
name|TaskSize
init|;
name|J
operator|!=
name|E
condition|;
operator|++
name|J
control|)
name|Fn
argument_list|(
name|J
argument_list|)
expr_stmt|;
block|}
block|)
empty_stmt|;
end_for

begin_expr_stmt
unit|}   TG
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
for|for
control|(
name|IndexTy
name|J
init|=
name|I
init|;
name|J
operator|<
name|End
condition|;
operator|++
name|J
control|)
name|Fn
argument_list|(
name|J
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|template
operator|<
name|typename
name|Iter
operator|>
name|using
name|DefComparator
operator|=
name|std
operator|::
name|less
operator|<
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|Iter
operator|>
operator|::
name|value_type
operator|>
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// namespace detail
end_comment

begin_comment
comment|// sequential algorithm implementations.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|Policy
operator|,
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|=
name|detail
operator|::
name|DefComparator
operator|<
name|RandomAccessIterator
operator|>>
name|void
name|sort
argument_list|(
argument|Policy policy
argument_list|,
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp = Comparator()
argument_list|)
block|{
name|static_assert
argument_list|(
name|is_execution_policy
operator|<
name|Policy
operator|>
operator|::
name|value
argument_list|,
literal|"Invalid execution policy!"
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|)
block|; }
name|template
operator|<
name|class
name|Policy
operator|,
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|for_each
argument_list|(
argument|Policy policy
argument_list|,
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|static_assert
argument_list|(
name|is_execution_policy
operator|<
name|Policy
operator|>
operator|::
name|value
argument_list|,
literal|"Invalid execution policy!"
argument_list|)
block|;
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
name|template
operator|<
name|class
name|Policy
operator|,
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|for_each_n
argument_list|(
argument|Policy policy
argument_list|,
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|static_assert
argument_list|(
name|is_execution_policy
operator|<
name|Policy
operator|>
operator|::
name|value
argument_list|,
literal|"Invalid execution policy!"
argument_list|)
block|;
for|for
control|(
name|IndexTy
name|I
init|=
name|Begin
init|;
name|I
operator|!=
name|End
condition|;
operator|++
name|I
control|)
name|Fn
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Parallel algorithm implementations, only available when LLVM_ENABLE_THREADS
end_comment

begin_comment
comment|// is true.
end_comment

begin_if
if|#
directive|if
name|LLVM_ENABLE_THREADS
end_if

begin_expr_stmt
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comparator
operator|=
name|detail
operator|::
name|DefComparator
operator|<
name|RandomAccessIterator
operator|>>
name|void
name|sort
argument_list|(
argument|parallel_execution_policy policy
argument_list|,
argument|RandomAccessIterator Start
argument_list|,
argument|RandomAccessIterator End
argument_list|,
argument|const Comparator&Comp = Comparator()
argument_list|)
block|{
name|detail
operator|::
name|parallel_sort
argument_list|(
name|Start
argument_list|,
name|End
argument_list|,
name|Comp
argument_list|)
block|; }
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|for_each
argument_list|(
argument|parallel_execution_policy policy
argument_list|,
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|detail
operator|::
name|parallel_for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
name|template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|for_each_n
argument_list|(
argument|parallel_execution_policy policy
argument_list|,
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|detail
operator|::
name|parallel_for_each_n
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|// namespace parallel
end_comment

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_PARALLEL_H
end_comment

end_unit

