begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GenericDomTree.h - Generic dominator trees for graphs ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This file defines a set of templates that efficiently compute a dominator
end_comment

begin_comment
comment|/// tree over a generic graph. This is used typically in LLVM for fast
end_comment

begin_comment
comment|/// dominance queries on the CFG, but is fully generic w.r.t. the underlying
end_comment

begin_comment
comment|/// graph types.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Unlike ADT/* graph algorithms, generic dominator tree has more reuiqrement
end_comment

begin_comment
comment|/// on the graph's NodeRef. The NodeRef should be a pointer and, depending on
end_comment

begin_comment
comment|/// the implementation, e.g. NodeRef->getParent() return the parent node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// FIXME: Maybe GenericDomTree needs a TreeTraits, instead of GraphTraits.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GENERICDOMTREE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GENERICDOMTREE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorTreeBase
expr_stmt|;
name|namespace
name|detail
block|{
name|template
operator|<
name|typename
name|GT
operator|>
expr|struct
name|DominatorTreeBaseTraits
block|{
name|static_assert
argument_list|(
argument|std::is_pointer<typename GT::NodeRef>::value
argument_list|,
literal|"Currently NodeRef must be a pointer type."
argument_list|)
block|;
name|using
name|type
operator|=
name|DominatorTreeBase
operator|<
name|typename
name|std
operator|::
name|remove_pointer
operator|<
name|typename
name|GT
operator|::
name|NodeRef
operator|>
operator|::
name|type
operator|>
block|; }
expr_stmt|;
block|}
comment|// End namespace detail
name|template
operator|<
name|typename
name|GT
operator|>
name|using
name|DominatorTreeBaseByGraphTraits
operator|=
name|typename
name|detail
operator|::
name|DominatorTreeBaseTraits
operator|<
name|GT
operator|>
operator|::
name|type
expr_stmt|;
comment|/// \brief Base class that other, more interesting dominator analyses
comment|/// inherit from.
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorBase
block|{
name|protected
operator|:
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
name|Roots
block|;
name|bool
name|IsPostDominators
block|;
name|explicit
name|DominatorBase
argument_list|(
argument|bool isPostDom
argument_list|)
operator|:
name|Roots
argument_list|()
block|,
name|IsPostDominators
argument_list|(
argument|isPostDom
argument_list|)
block|{}
name|DominatorBase
argument_list|(
name|DominatorBase
operator|&&
name|Arg
argument_list|)
operator|:
name|Roots
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|Roots
argument_list|)
argument_list|)
block|,
name|IsPostDominators
argument_list|(
argument|std::move(Arg.IsPostDominators)
argument_list|)
block|{
name|Arg
operator|.
name|Roots
operator|.
name|clear
argument_list|()
block|;   }
name|DominatorBase
operator|&
name|operator
operator|=
operator|(
name|DominatorBase
operator|&&
name|RHS
operator|)
block|{
name|Roots
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Roots
argument_list|)
block|;
name|IsPostDominators
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|IsPostDominators
argument_list|)
block|;
name|RHS
operator|.
name|Roots
operator|.
name|clear
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|public
operator|:
comment|/// getRoots - Return the root blocks of the current CFG.  This may include
comment|/// multiple blocks if we are computing post dominators.  For forward
comment|/// dominators, this will always be a single block (the entry node).
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
operator|&
name|getRoots
argument_list|()
specifier|const
block|{
return|return
name|Roots
return|;
block|}
comment|/// isPostDominator - Returns true if analysis based of postdoms
comment|///
name|bool
name|isPostDominator
argument_list|()
specifier|const
block|{
return|return
name|IsPostDominators
return|;
block|}
expr|}
block|;  struct
name|PostDominatorTree
block|;
comment|/// \brief Base class for the actual dominator tree node.
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DomTreeNodeBase
block|{
name|NodeT
operator|*
name|TheBB
block|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
block|;
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
name|Children
block|;
name|mutable
name|int
name|DFSNumIn
block|,
name|DFSNumOut
block|;
name|template
operator|<
name|class
name|N
operator|>
name|friend
name|class
name|DominatorTreeBase
block|;
name|friend
expr|struct
name|PostDominatorTree
block|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|Children
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|Children
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|end
argument_list|()
return|;
block|}
name|NodeT
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|TheBB
return|;
block|}
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getIDom
argument_list|()
specifier|const
block|{
return|return
name|IDom
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|&
name|getChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
return|;
block|}
name|DomTreeNodeBase
argument_list|(
name|NodeT
operator|*
name|BB
argument_list|,
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|iDom
argument_list|)
operator|:
name|TheBB
argument_list|(
name|BB
argument_list|)
operator|,
name|IDom
argument_list|(
name|iDom
argument_list|)
operator|,
name|DFSNumIn
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|DFSNumOut
argument_list|(
argument|-
literal|1
argument_list|)
block|{}
name|std
operator|::
name|unique_ptr
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
name|addChild
argument_list|(
argument|std::unique_ptr<DomTreeNodeBase<NodeT>> C
argument_list|)
block|{
name|Children
operator|.
name|push_back
argument_list|(
name|C
operator|.
name|get
argument_list|()
argument_list|)
block|;
return|return
name|C
return|;
block|}
name|size_t
name|getNumChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|clearAllChildren
parameter_list|()
block|{
name|Children
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|compare
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Other
argument_list|)
decl|const
block|{
if|if
condition|(
name|getNumChildren
argument_list|()
operator|!=
name|Other
operator|->
name|getNumChildren
argument_list|()
condition|)
return|return
name|true
return|;
name|SmallPtrSet
operator|<
specifier|const
name|NodeT
operator|*
operator|,
literal|4
operator|>
name|OtherChildren
expr_stmt|;
for|for
control|(
specifier|const
name|DomTreeNodeBase
modifier|*
name|I
range|:
operator|*
name|Other
control|)
block|{
specifier|const
name|NodeT
modifier|*
name|Nd
init|=
name|I
operator|->
name|getBlock
argument_list|()
decl_stmt|;
name|OtherChildren
operator|.
name|insert
argument_list|(
name|Nd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|const
name|DomTreeNodeBase
modifier|*
name|I
range|:
operator|*
name|this
control|)
block|{
specifier|const
name|NodeT
modifier|*
name|N
init|=
name|I
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|OtherChildren
operator|.
name|count
argument_list|(
name|N
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|void
name|setIDom
argument_list|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewIDom
argument_list|)
block|{
name|assert
argument_list|(
name|IDom
operator|&&
literal|"No immediate dominator?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDom
operator|!=
name|NewIDom
condition|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|find
argument_list|(
name|IDom
operator|->
name|Children
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
operator|&&
literal|"Not in immediate dominator children set!"
argument_list|)
expr_stmt|;
comment|// I am no longer your child...
name|IDom
operator|->
name|Children
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Switch to new dominator
name|IDom
operator|=
name|NewIDom
expr_stmt|;
name|IDom
operator|->
name|Children
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// getDFSNumIn/getDFSNumOut - These return the DFS visitation order for nodes
comment|/// in the dominator tree. They are only guaranteed valid if
comment|/// updateDFSNumbers() has been called.
name|unsigned
name|getDFSNumIn
argument_list|()
specifier|const
block|{
return|return
name|DFSNumIn
return|;
block|}
name|unsigned
name|getDFSNumOut
argument_list|()
specifier|const
block|{
return|return
name|DFSNumOut
return|;
block|}
name|private
label|:
comment|// Return true if this node is dominated by other. Use this only if DFS info
comment|// is valid.
name|bool
name|DominatedBy
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|other
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|DFSNumIn
operator|>=
name|other
operator|->
name|DFSNumIn
operator|&&
name|this
operator|->
name|DFSNumOut
operator|<=
name|other
operator|->
name|DFSNumOut
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|o
operator|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|)
block|{
if|if
condition|(
name|Node
operator|->
name|getBlock
argument_list|()
condition|)
name|Node
operator|->
name|getBlock
argument_list|()
operator|->
name|printAsOperand
argument_list|(
name|o
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|o
operator|<<
literal|"<<exit node>>"
expr_stmt|;
name|o
operator|<<
literal|" {"
operator|<<
name|Node
operator|->
name|getDFSNumIn
argument_list|()
operator|<<
literal|","
operator|<<
name|Node
operator|->
name|getDFSNumOut
argument_list|()
operator|<<
literal|"}"
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|o
operator|<<
literal|"\n"
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|NodeT
operator|>
name|void
name|PrintDomTree
argument_list|(
argument|const DomTreeNodeBase<NodeT> *N
argument_list|,
argument|raw_ostream&o
argument_list|,
argument|unsigned Lev
argument_list|)
block|{
name|o
operator|.
name|indent
argument_list|(
literal|2
operator|*
name|Lev
argument_list|)
operator|<<
literal|"["
operator|<<
name|Lev
operator|<<
literal|"] "
operator|<<
name|N
block|;
for|for
control|(
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|N
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|N
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|PrintDomTree
operator|<
name|NodeT
operator|>
operator|(
operator|*
name|I
operator|,
name|o
operator|,
name|Lev
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// The calculate routine is provided in a separate header but referenced here.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|N
operator|>
name|void
name|Calculate
argument_list|(
name|DominatorTreeBaseByGraphTraits
operator|<
name|GraphTraits
operator|<
name|N
operator|>>
operator|&
name|DT
argument_list|,
name|FuncT
operator|&
name|F
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Core dominator tree base class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This class is a generic template over graph nodes. It is instantiated for
end_comment

begin_comment
comment|/// various graphs in the LLVM IR or in the code generator.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorTreeBase
operator|:
name|public
name|DominatorBase
operator|<
name|NodeT
operator|>
block|{
name|DominatorTreeBase
argument_list|(
specifier|const
name|DominatorTreeBase
operator|&
argument_list|)
operator|=
name|delete
block|;
name|DominatorTreeBase
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DominatorTreeBase
operator|&
operator|)
operator|=
name|delete
block|;
name|bool
name|dominatedBySlowTreeWalk
argument_list|(
argument|const DomTreeNodeBase<NodeT> *A
argument_list|,
argument|const DomTreeNodeBase<NodeT> *B
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|A
operator|!=
name|B
argument_list|)
block|;
name|assert
argument_list|(
name|isReachableFromEntry
argument_list|(
name|B
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|isReachableFromEntry
argument_list|(
name|A
argument_list|)
argument_list|)
block|;
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
block|;
while|while
condition|(
operator|(
name|IDom
operator|=
name|B
operator|->
name|getIDom
argument_list|()
operator|)
operator|!=
name|nullptr
operator|&&
name|IDom
operator|!=
name|A
operator|&&
name|IDom
operator|!=
name|B
condition|)
name|B
operator|=
name|IDom
expr_stmt|;
comment|// Walk up the tree
return|return
name|IDom
operator|!=
name|nullptr
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Wipe this tree's state without releasing any resources.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is essentially a post-move helper only. It leaves the object in an
end_comment

begin_comment
comment|/// assignable and destroyable state, but otherwise invalid.
end_comment

begin_function
name|void
name|wipe
parameter_list|()
block|{
name|DomTreeNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Vertex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Info
operator|.
name|clear
argument_list|()
expr_stmt|;
name|RootNode
operator|=
name|nullptr
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>>
name|DomTreeNodeMapType
expr_stmt|;
end_typedef

begin_decl_stmt
name|DomTreeNodeMapType
name|DomTreeNodes
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|RootNode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|mutable
name|bool
name|DFSInfoValid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|unsigned
name|int
name|SlowQueries
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Information record used during immediate dominators computation.
end_comment

begin_struct
struct|struct
name|InfoRec
block|{
name|unsigned
name|DFSNum
decl_stmt|;
name|unsigned
name|Parent
decl_stmt|;
name|unsigned
name|Semi
decl_stmt|;
name|NodeT
modifier|*
name|Label
decl_stmt|;
name|InfoRec
argument_list|()
operator|:
name|DFSNum
argument_list|(
literal|0
argument_list|)
operator|,
name|Parent
argument_list|(
literal|0
argument_list|)
operator|,
name|Semi
argument_list|(
literal|0
argument_list|)
operator|,
name|Label
argument_list|(
argument|nullptr
argument_list|)
block|{}
block|}
struct|;
end_struct

begin_expr_stmt
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|NodeT
operator|*
operator|>
name|IDoms
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Vertex - Map the DFS number to the NodeT*
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
name|Vertex
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Info - Collection of information used during the computation of idoms.
end_comment

begin_expr_stmt
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|InfoRec
operator|>
name|Info
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
block|{
name|DomTreeNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|->
name|Roots
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Vertex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|RootNode
operator|=
name|nullptr
expr_stmt|;
name|DFSInfoValid
operator|=
name|false
expr_stmt|;
name|SlowQueries
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|// NewBB is split and now it has one successor. Update dominator tree to
end_comment

begin_comment
comment|// reflect this change.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|N
operator|,
name|class
name|GraphT
operator|>
name|void
name|Split
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef NewBB
argument_list|)
block|{
name|assert
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|GraphT
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
argument_list|,
name|GraphT
operator|::
name|child_end
argument_list|(
name|NewBB
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
literal|"NewBB should have a single successor!"
argument_list|)
block|;
name|typename
name|GraphT
operator|::
name|NodeRef
name|NewBBSucc
operator|=
operator|*
name|GraphT
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
block|;
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeRef
operator|>
name|PredBlocks
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|N
operator|>>
name|InvTraits
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|InvTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvTraits
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
operator|,
name|PE
operator|=
name|InvTraits
operator|::
name|child_end
argument_list|(
name|NewBB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
name|PredBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|PI
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|assert
argument_list|(
operator|!
name|PredBlocks
operator|.
name|empty
argument_list|()
operator|&&
literal|"No predblocks?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|NewBBDominatesNewBBSucc
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|typename
name|InvTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvTraits
operator|::
name|child_begin
argument_list|(
name|NewBBSucc
argument_list|)
operator|,
name|E
operator|=
name|InvTraits
operator|::
name|child_end
argument_list|(
name|NewBBSucc
argument_list|)
init|;
name|PI
operator|!=
name|E
condition|;
operator|++
name|PI
control|)
block|{
name|typename
name|InvTraits
operator|::
name|NodeRef
name|ND
operator|=
operator|*
name|PI
expr_stmt|;
if|if
condition|(
name|ND
operator|!=
name|NewBB
operator|&&
operator|!
name|DT
operator|.
name|dominates
argument_list|(
name|NewBBSucc
argument_list|,
name|ND
argument_list|)
operator|&&
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|ND
argument_list|)
condition|)
block|{
name|NewBBDominatesNewBBSucc
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_comment
comment|// Find NewBB's immediate dominator and create new dominator tree node for
end_comment

begin_comment
comment|// NewBB.
end_comment

begin_decl_stmt
name|NodeT
modifier|*
name|NewBBIDom
init|=
name|nullptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PredBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|PredBlocks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|NewBBIDom
operator|=
name|PredBlocks
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
end_for

begin_comment
comment|// It's possible that none of the predecessors of NewBB are reachable;
end_comment

begin_comment
comment|// in that case, NewBB itself is unreachable, so nothing needs to be
end_comment

begin_comment
comment|// changed.
end_comment

begin_if
if|if
condition|(
operator|!
name|NewBBIDom
condition|)
return|return;
end_if

begin_for
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|PredBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|PredBlocks
index|[
name|i
index|]
argument_list|)
condition|)
name|NewBBIDom
operator|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|NewBBIDom
argument_list|,
name|PredBlocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Create the new dominator tree node... and set the idom of NewBB.
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewBBNode
operator|=
name|DT
operator|.
name|addNewBlock
argument_list|(
name|NewBB
argument_list|,
name|NewBBIDom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If NewBB strictly dominates other blocks, then it is now the immediate
end_comment

begin_comment
comment|// dominator of NewBBSucc.  Update the dominator tree as appropriate.
end_comment

begin_if
if|if
condition|(
name|NewBBDominatesNewBBSucc
condition|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewBBSuccNode
operator|=
name|DT
operator|.
name|getNode
argument_list|(
name|NewBBSucc
argument_list|)
expr_stmt|;
name|DT
operator|.
name|changeImmediateDominator
argument_list|(
name|NewBBSuccNode
argument_list|,
name|NewBBNode
argument_list|)
expr_stmt|;
block|}
end_if

begin_macro
unit|}  public:
name|explicit
end_macro

begin_macro
name|DominatorTreeBase
argument_list|(
argument|bool isPostDom
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|(
name|isPostDom
operator|)
operator|,
name|DFSInfoValid
argument_list|(
name|false
argument_list|)
operator|,
name|SlowQueries
argument_list|(
literal|0
argument_list|)
block|{}
name|DominatorTreeBase
argument_list|(
name|DominatorTreeBase
operator|&&
name|Arg
argument_list|)
operator|:
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|static_cast
operator|<
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|&
operator|>
operator|(
name|Arg
operator|)
argument_list|)
operator|)
operator|,
name|DomTreeNodes
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|DomTreeNodes
argument_list|)
argument_list|)
operator|,
name|RootNode
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|RootNode
argument_list|)
argument_list|)
operator|,
name|DFSInfoValid
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|DFSInfoValid
argument_list|)
argument_list|)
operator|,
name|SlowQueries
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|SlowQueries
argument_list|)
argument_list|)
operator|,
name|IDoms
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|IDoms
argument_list|)
argument_list|)
operator|,
name|Vertex
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|Vertex
argument_list|)
argument_list|)
operator|,
name|Info
argument_list|(
argument|std::move(Arg.Info)
argument_list|)
block|{
name|Arg
operator|.
name|wipe
argument_list|()
block|;   }
name|DominatorTreeBase
operator|&
name|operator
operator|=
operator|(
name|DominatorTreeBase
operator|&&
name|RHS
operator|)
block|{
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|::
name|operator
operator|=
operator|(
name|std
operator|::
name|move
argument_list|(
name|static_cast
operator|<
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|&
operator|>
operator|(
name|RHS
operator|)
argument_list|)
operator|)
block|;
name|DomTreeNodes
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|DomTreeNodes
argument_list|)
block|;
name|RootNode
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|RootNode
argument_list|)
block|;
name|DFSInfoValid
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|DFSInfoValid
argument_list|)
block|;
name|SlowQueries
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|SlowQueries
argument_list|)
block|;
name|IDoms
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|IDoms
argument_list|)
block|;
name|Vertex
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Vertex
argument_list|)
block|;
name|Info
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Info
argument_list|)
block|;
name|RHS
operator|.
name|wipe
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// compare - Return false if the other dominator tree base matches this
end_comment

begin_comment
comment|/// dominator tree base. Otherwise return true.
end_comment

begin_decl_stmt
name|bool
name|compare
argument_list|(
specifier|const
name|DominatorTreeBase
operator|&
name|Other
argument_list|)
decl|const
block|{
specifier|const
name|DomTreeNodeMapType
modifier|&
name|OtherDomTreeNodes
init|=
name|Other
operator|.
name|DomTreeNodes
decl_stmt|;
if|if
condition|(
name|DomTreeNodes
operator|.
name|size
argument_list|()
operator|!=
name|OtherDomTreeNodes
operator|.
name|size
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|DomTreeNode
range|:
name|this
operator|->
name|DomTreeNodes
control|)
block|{
name|NodeT
modifier|*
name|BB
init|=
name|DomTreeNode
operator|.
name|first
decl_stmt|;
name|typename
name|DomTreeNodeMapType
operator|::
name|const_iterator
name|OI
operator|=
name|OtherDomTreeNodes
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|OI
operator|==
name|OtherDomTreeNodes
operator|.
name|end
argument_list|()
condition|)
return|return
name|true
return|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|&
name|MyNd
operator|=
operator|*
name|DomTreeNode
operator|.
name|second
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|&
name|OtherNd
operator|=
operator|*
name|OI
operator|->
name|second
expr_stmt|;
if|if
condition|(
name|MyNd
operator|.
name|compare
argument_list|(
operator|&
name|OtherNd
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|void
name|releaseMemory
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// getNode - return the (Post)DominatorTree node for the specified basic
end_comment

begin_comment
comment|/// block.  This is the same as using operator[] on this class.  The result
end_comment

begin_comment
comment|/// may (but is not required to) be null for a forward (backwards)
end_comment

begin_comment
comment|/// statically unreachable block.
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getNode
argument_list|(
argument|NodeT *BB
argument_list|)
specifier|const
block|{
name|auto
name|I
operator|=
name|DomTreeNodes
operator|.
name|find
argument_list|(
name|BB
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|DomTreeNodes
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|nullptr
return|;
end_return

begin_comment
unit|}
comment|/// See getNode.
end_comment

begin_expr_stmt
unit|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|operator
index|[]
operator|(
name|NodeT
operator|*
name|BB
operator|)
specifier|const
block|{
return|return
name|getNode
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getRootNode - This returns the entry node for the CFG of the function.  If
end_comment

begin_comment
comment|/// this tree represents the post-dominance relations for a function, however,
end_comment

begin_comment
comment|/// this root may be a node with the block == NULL.  This is the case when
end_comment

begin_comment
comment|/// there are multiple exit nodes from a particular function.  Consumers of
end_comment

begin_comment
comment|/// post-dominance information must be capable of dealing with this
end_comment

begin_comment
comment|/// possibility.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getRootNode
argument_list|()
block|{
return|return
name|RootNode
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getRootNode
argument_list|()
specifier|const
block|{
return|return
name|RootNode
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Get all nodes dominated by R, including R itself.
end_comment

begin_decl_stmt
name|void
name|getDescendants
argument_list|(
name|NodeT
operator|*
name|R
argument_list|,
name|SmallVectorImpl
operator|<
name|NodeT
operator|*
operator|>
operator|&
name|Result
argument_list|)
decl|const
block|{
name|Result
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|RN
operator|=
name|getNode
argument_list|(
name|R
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RN
condition|)
return|return;
comment|// If R is unreachable, it will not be present in the DOM tree.
name|SmallVector
operator|<
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|,
literal|8
operator|>
name|WL
expr_stmt|;
name|WL
operator|.
name|push_back
argument_list|(
name|RN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|WL
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|N
operator|=
name|WL
operator|.
name|pop_back_val
argument_list|()
expr_stmt|;
name|Result
operator|.
name|push_back
argument_list|(
name|N
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|WL
operator|.
name|append
argument_list|(
name|N
operator|->
name|begin
argument_list|()
argument_list|,
name|N
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/// properlyDominates - Returns true iff A dominates B and A != B.
end_comment

begin_comment
comment|/// Note that this is not a constant time operation!
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|bool
name|properlyDominates
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|B
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|A
operator|||
operator|!
name|B
condition|)
return|return
name|false
return|;
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|false
return|;
return|return
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|properlyDominates
argument_list|(
specifier|const
name|NodeT
operator|*
name|A
argument_list|,
specifier|const
name|NodeT
operator|*
name|B
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// isReachableFromEntry - Return true if A is dominated by the entry
end_comment

begin_comment
comment|/// block of the function containing it.
end_comment

begin_decl_stmt
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|NodeT
operator|*
name|A
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|isPostDominator
argument_list|()
operator|&&
literal|"This is not implemented for post dominators"
argument_list|)
expr_stmt|;
return|return
name|isReachableFromEntry
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|)
decl|const
block|{
return|return
name|A
return|;
block|}
end_decl_stmt

begin_comment
comment|/// dominates - Returns true iff A dominates B.  Note that this is not a
end_comment

begin_comment
comment|/// constant time operation!
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|B
argument_list|)
decl|const
block|{
comment|// A node trivially dominates itself.
if|if
condition|(
name|B
operator|==
name|A
condition|)
return|return
name|true
return|;
comment|// An unreachable node is dominated by anything.
if|if
condition|(
operator|!
name|isReachableFromEntry
argument_list|(
name|B
argument_list|)
condition|)
return|return
name|true
return|;
comment|// And dominates nothing.
if|if
condition|(
operator|!
name|isReachableFromEntry
argument_list|(
name|A
argument_list|)
condition|)
return|return
name|false
return|;
comment|// Compare the result of the tree walk and the dfs numbers, if expensive
comment|// checks are enabled.
ifdef|#
directive|ifdef
name|EXPENSIVE_CHECKS
name|assert
argument_list|(
operator|(
operator|!
name|DFSInfoValid
operator|||
operator|(
name|dominatedBySlowTreeWalk
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
operator|==
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
operator|)
operator|)
operator|&&
literal|"Tree walk disagrees with dfs numbers!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DFSInfoValid
condition|)
return|return
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
return|;
comment|// If we end up with too many slow queries, just update the
comment|// DFS numbers on the theory that we are going to keep querying.
name|SlowQueries
operator|++
expr_stmt|;
if|if
condition|(
name|SlowQueries
operator|>
literal|32
condition|)
block|{
name|updateDFSNumbers
argument_list|()
expr_stmt|;
return|return
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
return|;
block|}
return|return
name|dominatedBySlowTreeWalk
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|NodeT
operator|*
name|A
argument_list|,
specifier|const
name|NodeT
operator|*
name|B
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NodeT
operator|*
name|getRoot
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|this
operator|->
name|Roots
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Should always have entry node!"
argument_list|)
block|;
return|return
name|this
operator|->
name|Roots
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_comment
comment|/// findNearestCommonDominator - Find nearest common dominator basic block
end_comment

begin_comment
comment|/// for basic block A and B. If there is no such block then return NULL.
end_comment

begin_function
name|NodeT
modifier|*
name|findNearestCommonDominator
parameter_list|(
name|NodeT
modifier|*
name|A
parameter_list|,
name|NodeT
modifier|*
name|B
parameter_list|)
block|{
name|assert
argument_list|(
name|A
operator|->
name|getParent
argument_list|()
operator|==
name|B
operator|->
name|getParent
argument_list|()
operator|&&
literal|"Two blocks are not in same function"
argument_list|)
expr_stmt|;
comment|// If either A or B is a entry block then it is nearest common dominator
comment|// (for forward-dominators).
if|if
condition|(
operator|!
name|this
operator|->
name|isPostDominator
argument_list|()
condition|)
block|{
name|NodeT
modifier|&
name|Entry
init|=
name|A
operator|->
name|getParent
argument_list|()
operator|->
name|front
argument_list|()
decl_stmt|;
if|if
condition|(
name|A
operator|==
operator|&
name|Entry
operator|||
name|B
operator|==
operator|&
name|Entry
condition|)
return|return
operator|&
name|Entry
return|;
block|}
comment|// If B dominates A then B is nearest common dominator.
if|if
condition|(
name|dominates
argument_list|(
name|B
argument_list|,
name|A
argument_list|)
condition|)
return|return
name|B
return|;
comment|// If A dominates B then A is nearest common dominator.
if|if
condition|(
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
condition|)
return|return
name|A
return|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NodeA
operator|=
name|getNode
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NodeB
operator|=
name|getNode
argument_list|(
name|B
argument_list|)
expr_stmt|;
comment|// If we have DFS info, then we can avoid all allocations by just querying
comment|// it from each IDom. Note that because we call 'dominates' twice above, we
comment|// expect to call through this code at most 16 times in a row without
comment|// building valid DFS information. This is important as below is a *very*
comment|// slow tree walk.
if|if
condition|(
name|DFSInfoValid
condition|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomA
operator|=
name|NodeA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
while|while
condition|(
name|IDomA
condition|)
block|{
if|if
condition|(
name|NodeB
operator|->
name|DominatedBy
argument_list|(
name|IDomA
argument_list|)
condition|)
return|return
name|IDomA
operator|->
name|getBlock
argument_list|()
return|;
name|IDomA
operator|=
name|IDomA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
block|}
return|return
name|nullptr
return|;
block|}
comment|// Collect NodeA dominators set.
name|SmallPtrSet
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|,
literal|16
operator|>
name|NodeADoms
expr_stmt|;
name|NodeADoms
operator|.
name|insert
argument_list|(
name|NodeA
argument_list|)
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomA
operator|=
name|NodeA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
while|while
condition|(
name|IDomA
condition|)
block|{
name|NodeADoms
operator|.
name|insert
argument_list|(
name|IDomA
argument_list|)
expr_stmt|;
name|IDomA
operator|=
name|IDomA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
block|}
comment|// Walk NodeB immediate dominators chain and find common dominator node.
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomB
operator|=
name|NodeB
operator|->
name|getIDom
argument_list|()
expr_stmt|;
while|while
condition|(
name|IDomB
condition|)
block|{
if|if
condition|(
name|NodeADoms
operator|.
name|count
argument_list|(
name|IDomB
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|IDomB
operator|->
name|getBlock
argument_list|()
return|;
name|IDomB
operator|=
name|IDomB
operator|->
name|getIDom
argument_list|()
expr_stmt|;
block|}
return|return
name|nullptr
return|;
block|}
end_function

begin_function
specifier|const
name|NodeT
modifier|*
name|findNearestCommonDominator
parameter_list|(
specifier|const
name|NodeT
modifier|*
name|A
parameter_list|,
specifier|const
name|NodeT
modifier|*
name|B
parameter_list|)
block|{
comment|// Cast away the const qualifiers here. This is ok since
comment|// const is re-introduced on the return type.
return|return
name|findNearestCommonDominator
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|,
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// API to update (Post)DominatorTree information based on modifications to
end_comment

begin_comment
comment|// the CFG...
end_comment

begin_comment
comment|/// Add a new node to the dominator tree information.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This creates a new node as a child of DomBB dominator node, linking it
end_comment

begin_comment
comment|/// into the children list of the immediate dominator.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param BB New node in CFG.
end_comment

begin_comment
comment|/// \param DomBB CFG node that is dominator for BB.
end_comment

begin_comment
comment|/// \returns New dominator tree node that represents new CFG node.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|addNewBlock
argument_list|(
argument|NodeT *BB
argument_list|,
argument|NodeT *DomBB
argument_list|)
block|{
name|assert
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
operator|==
name|nullptr
operator|&&
literal|"Block already in dominator tree!"
argument_list|)
block|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomNode
operator|=
name|getNode
argument_list|(
name|DomBB
argument_list|)
block|;
name|assert
argument_list|(
name|IDomNode
operator|&&
literal|"Not immediate dominator specified for block!"
argument_list|)
block|;
name|DFSInfoValid
operator|=
name|false
block|;
return|return
operator|(
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|BB
operator|,
name|IDomNode
operator|)
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Add a new node to the forward dominator tree and make it a new root.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param BB New node in CFG.
end_comment

begin_comment
comment|/// \returns New dominator tree node that represents new CFG node.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|setNewRoot
argument_list|(
argument|NodeT *BB
argument_list|)
block|{
name|assert
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
operator|==
name|nullptr
operator|&&
literal|"Block already in dominator tree!"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|this
operator|->
name|isPostDominator
argument_list|()
operator|&&
literal|"Cannot change root of post-dominator tree"
argument_list|)
block|;
name|DFSInfoValid
operator|=
name|false
block|;
name|auto
operator|&
name|Roots
operator|=
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|::
name|Roots
block|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewNode
operator|=
operator|(
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|BB
operator|,
name|nullptr
operator|)
operator|)
operator|.
name|get
argument_list|()
block|;
if|if
condition|(
name|Roots
operator|.
name|empty
argument_list|()
condition|)
block|{
name|addRoot
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|assert
argument_list|(
name|Roots
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|NodeT
modifier|*
name|OldRoot
init|=
name|Roots
operator|.
name|front
argument_list|()
decl_stmt|;
name|DomTreeNodes
index|[
name|OldRoot
index|]
operator|=
name|NewNode
operator|->
name|addChild
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|DomTreeNodes
index|[
name|OldRoot
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Roots
index|[
literal|0
index|]
operator|=
name|BB
expr_stmt|;
block|}
end_else

begin_return
return|return
name|RootNode
operator|=
name|NewNode
return|;
end_return

begin_comment
unit|}
comment|/// changeImmediateDominator - This method is used to update the dominator
end_comment

begin_comment
comment|/// tree information when a node's immediate dominator changes.
end_comment

begin_comment
comment|///
end_comment

begin_macro
unit|void
name|changeImmediateDominator
argument_list|(
argument|DomTreeNodeBase<NodeT> *N
argument_list|,
argument|DomTreeNodeBase<NodeT> *NewIDom
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|N
operator|&&
name|NewIDom
operator|&&
literal|"Cannot change null node pointers!"
argument_list|)
expr_stmt|;
name|DFSInfoValid
operator|=
name|false
expr_stmt|;
name|N
operator|->
name|setIDom
argument_list|(
name|NewIDom
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|changeImmediateDominator
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|,
name|NodeT
modifier|*
name|NewBB
parameter_list|)
block|{
name|changeImmediateDominator
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|NewBB
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// eraseNode - Removes a node from the dominator tree. Block must not
end_comment

begin_comment
comment|/// dominate any other blocks. Removes node from its immediate dominator's
end_comment

begin_comment
comment|/// children list. Deletes dominator node associated with basic block BB.
end_comment

begin_function
name|void
name|eraseNode
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|getNode
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Node
operator|&&
literal|"Removing node that isn't in dominator tree."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Node
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
literal|"Node is not a leaf node."
argument_list|)
expr_stmt|;
comment|// Remove node from immediate dominator's children list.
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
operator|=
name|Node
operator|->
name|getIDom
argument_list|()
expr_stmt|;
if|if
condition|(
name|IDom
condition|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|find
argument_list|(
name|IDom
operator|->
name|Children
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
operator|&&
literal|"Not in immediate dominator children set!"
argument_list|)
expr_stmt|;
comment|// I am no longer your child...
name|IDom
operator|->
name|Children
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
name|DomTreeNodes
operator|.
name|erase
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// splitBlock - BB is split and now it has one successor. Update dominator
end_comment

begin_comment
comment|/// tree to reflect this change.
end_comment

begin_function
name|void
name|splitBlock
parameter_list|(
name|NodeT
modifier|*
name|NewBB
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|IsPostDominators
condition|)
name|this
operator|->
name|Split
operator|<
name|Inverse
operator|<
name|NodeT
operator|*
operator|>
operator|,
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|*
operator|>>>
operator|(
operator|*
name|this
operator|,
name|NewBB
operator|)
expr_stmt|;
else|else
name|this
operator|->
name|Split
operator|<
name|NodeT
operator|*
operator|,
name|GraphTraits
operator|<
name|NodeT
operator|*
operator|>>
operator|(
operator|*
name|this
operator|,
name|NewBB
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// print - Convert to human readable form
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|o
argument_list|)
decl|const
block|{
name|o
operator|<<
literal|"=============================--------------------------------\n"
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|isPostDominator
argument_list|()
condition|)
name|o
operator|<<
literal|"Inorder PostDominator Tree: "
expr_stmt|;
else|else
name|o
operator|<<
literal|"Inorder Dominator Tree: "
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|DFSInfoValid
condition|)
name|o
operator|<<
literal|"DFSNumbers invalid: "
operator|<<
name|SlowQueries
operator|<<
literal|" slow queries."
expr_stmt|;
name|o
operator|<<
literal|"\n"
expr_stmt|;
comment|// The postdom tree can have a null root if there are no returns.
if|if
condition|(
name|getRootNode
argument_list|()
condition|)
name|PrintDomTree
operator|<
name|NodeT
operator|>
operator|(
name|getRootNode
argument_list|()
operator|,
name|o
operator|,
literal|1
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|friend
name|typename
name|GraphT
operator|::
name|NodeRef
name|Eval
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef V
argument_list|,
argument|unsigned LastLinked
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|friend
name|unsigned
name|DFSPass
argument_list|(
argument|DominatorTreeBaseByGraphTraits<GraphT>&DT
argument_list|,
argument|typename GraphT::NodeRef V
argument_list|,
argument|unsigned N
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|N
operator|>
name|friend
name|void
name|Calculate
argument_list|(
name|DominatorTreeBaseByGraphTraits
operator|<
name|GraphTraits
operator|<
name|N
operator|>>
operator|&
name|DT
argument_list|,
name|FuncT
operator|&
name|F
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getNodeForBlock
argument_list|(
argument|NodeT *BB
argument_list|)
block|{
if|if
condition|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|getNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|Node
return|;
comment|// Haven't calculated this node yet?  Get or calculate the node for the
comment|// immediate dominator.
name|NodeT
operator|*
name|IDom
operator|=
name|getIDom
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|IDom
operator|||
name|this
operator|->
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomNode
operator|=
name|getNodeForBlock
argument_list|(
name|IDom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Add a new tree node for this NodeT, and link it as a child of
end_comment

begin_comment
comment|// IDomNode
end_comment

begin_return
return|return
operator|(
name|this
operator|->
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|BB
operator|,
name|IDomNode
operator|)
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}    NodeT
operator|*
name|getIDom
argument_list|(
argument|NodeT *BB
argument_list|)
specifier|const
block|{
return|return
name|IDoms
operator|.
name|lookup
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|addRoot
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|)
block|{
name|this
operator|->
name|Roots
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// updateDFSNumbers - Assign In and Out numbers to the nodes while walking
end_comment

begin_comment
comment|/// dominator tree in dfs order.
end_comment

begin_expr_stmt
name|void
name|updateDFSNumbers
argument_list|()
specifier|const
block|{
if|if
condition|(
name|DFSInfoValid
condition|)
block|{
name|SlowQueries
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|unsigned
name|DFSNum
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|,
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|const_iterator
operator|>
operator|,
literal|32
operator|>
name|WorkStack
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|ThisRoot
operator|=
name|getRootNode
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|ThisRoot
condition|)
return|return;
end_if

begin_comment
comment|// Even in the case of multiple exits that form the post dominator root
end_comment

begin_comment
comment|// nodes, do not iterate over all exits, but start from the virtual root
end_comment

begin_comment
comment|// node. Otherwise bbs, that are not post dominated by any exit but by the
end_comment

begin_comment
comment|// virtual root node, will never be assigned a DFS number.
end_comment

begin_expr_stmt
name|WorkStack
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ThisRoot
argument_list|,
name|ThisRoot
operator|->
name|begin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ThisRoot
operator|->
name|DFSNumIn
operator|=
name|DFSNum
operator|++
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|!
name|WorkStack
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|first
expr_stmt|;
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|const_iterator
name|ChildIt
operator|=
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
comment|// If we visited all of the children of this node, "recurse" back up the
comment|// stack setting the DFOutNum.
if|if
condition|(
name|ChildIt
operator|==
name|Node
operator|->
name|end
argument_list|()
condition|)
block|{
name|Node
operator|->
name|DFSNumOut
operator|=
name|DFSNum
operator|++
expr_stmt|;
name|WorkStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise, recursively visit this child.
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Child
operator|=
operator|*
name|ChildIt
expr_stmt|;
operator|++
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
name|WorkStack
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Child
argument_list|,
name|Child
operator|->
name|begin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Child
operator|->
name|DFSNumIn
operator|=
name|DFSNum
operator|++
expr_stmt|;
block|}
block|}
end_while

begin_expr_stmt
name|SlowQueries
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DFSInfoValid
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// recalculate - compute a dominator tree for the given function
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|FT
operator|>
name|void
name|recalculate
argument_list|(
argument|FT&F
argument_list|)
block|{
typedef|typedef
name|GraphTraits
operator|<
name|FT
operator|*
operator|>
name|TraitsTy
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|Vertex
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|IsPostDominators
condition|)
block|{
comment|// Initialize root
name|NodeT
modifier|*
name|entry
init|=
name|TraitsTy
operator|::
name|getEntryNode
argument_list|(
operator|&
name|F
argument_list|)
decl_stmt|;
name|addRoot
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|Calculate
operator|<
name|FT
operator|,
name|NodeT
operator|*
operator|>
operator|(
operator|*
name|this
operator|,
name|F
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Initialize the roots list
for|for
control|(
name|typename
name|TraitsTy
operator|::
name|nodes_iterator
name|I
operator|=
name|TraitsTy
operator|::
name|nodes_begin
argument_list|(
operator|&
name|F
argument_list|)
operator|,
name|E
operator|=
name|TraitsTy
operator|::
name|nodes_end
argument_list|(
operator|&
name|F
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|TraitsTy
operator|::
name|child_begin
argument_list|(
operator|*
name|I
argument_list|)
operator|==
name|TraitsTy
operator|::
name|child_end
argument_list|(
operator|*
name|I
argument_list|)
condition|)
name|addRoot
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
name|Calculate
operator|<
name|FT
operator|,
name|Inverse
operator|<
name|NodeT
operator|*
operator|>>
operator|(
operator|*
name|this
operator|,
name|F
operator|)
expr_stmt|;
block|}
end_if

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|// These two functions are declared out of line as a workaround for building
end_comment

begin_comment
comment|// with old (< r147295) versions of clang because of pr11642.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
name|bool
name|DominatorTreeBase
operator|<
name|NodeT
operator|>
operator|::
name|dominates
argument_list|(
argument|const NodeT *A
argument_list|,
argument|const NodeT *B
argument_list|)
specifier|const
block|{
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_comment
comment|// Cast away the const qualifiers here. This is ok since
end_comment

begin_comment
comment|// this function doesn't actually return the values returned
end_comment

begin_comment
comment|// from getNode.
end_comment

begin_return
return|return
name|dominates
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|} template
operator|<
name|class
name|NodeT
operator|>
name|bool
name|DominatorTreeBase
operator|<
name|NodeT
operator|>
operator|::
name|properlyDominates
argument_list|(
argument|const NodeT *A
argument_list|,
argument|const NodeT *B
argument_list|)
specifier|const
block|{
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_comment
comment|// Cast away the const qualifiers here. This is ok since
end_comment

begin_comment
comment|// this function doesn't actually return the values returned
end_comment

begin_comment
comment|// from getNode.
end_comment

begin_return
return|return
name|dominates
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
argument_list|)
return|;
end_return

begin_endif
unit|}  }
endif|#
directive|endif
end_endif

end_unit

