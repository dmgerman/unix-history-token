begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Supporrt/YAMLTraits.h -------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_YAMLTRAITS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_YAMLTRAITS_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SourceMgr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/YAMLParser.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/system_error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|yaml
block|{
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a YAML mapping.  For example:
comment|///
comment|///     struct ScalarBitSetTraits<MyStruct> {
comment|///       static void mapping(IO&io, MyStruct&s) {
comment|///         io.mapRequired("name", s.name);
comment|///         io.mapRequired("size", s.size);
comment|///         io.mapOptional("age",  s.age);
comment|///       }
comment|///     };
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MappingTraits
block|{
comment|// Must provide:
comment|// static void mapping(IO&io, T&fields);
block|}
expr_stmt|;
comment|/// This class should be specialized by any integral type that converts
comment|/// to/from a YAML scalar where there is a one-to-one mapping between
comment|/// in-memory values and a string in YAML.  For example:
comment|///
comment|///     struct ScalarEnumerationTraits<Colors> {
comment|///         static void enumeration(IO&io, Colors&value) {
comment|///           io.enumCase(value, "red",   cRed);
comment|///           io.enumCase(value, "blue",  cBlue);
comment|///           io.enumCase(value, "green", cGreen);
comment|///         }
comment|///       };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarEnumerationTraits
block|{
comment|// Must provide:
comment|// static void enumeration(IO&io, T&value);
block|}
expr_stmt|;
comment|/// This class should be specialized by any integer type that is a union
comment|/// of bit values and the YAML representation is a flow sequence of
comment|/// strings.  For example:
comment|///
comment|///      struct ScalarBitSetTraits<MyFlags> {
comment|///        static void bitset(IO&io, MyFlags&value) {
comment|///          io.bitSetCase(value, "big",   flagBig);
comment|///          io.bitSetCase(value, "flat",  flagFlat);
comment|///          io.bitSetCase(value, "round", flagRound);
comment|///        }
comment|///      };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarBitSetTraits
block|{
comment|// Must provide:
comment|// static void bitset(IO&io, T&value);
block|}
expr_stmt|;
comment|/// This class should be specialized by type that requires custom conversion
comment|/// to/from a yaml scalar.  For example:
comment|///
comment|///    template<>
comment|///    struct ScalarTraits<MyType> {
comment|///      static void output(const MyType&val, void*, llvm::raw_ostream&out) {
comment|///        // stream out custom formatting
comment|///        out<< llvm::format("%x", val);
comment|///      }
comment|///      static StringRef input(StringRef scalar, void*, MyType&value) {
comment|///        // parse scalar and set `value`
comment|///        // return empty string on success, or error string
comment|///        return StringRef();
comment|///      }
comment|///    };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ScalarTraits
block|{
comment|// Must provide:
comment|//
comment|// Function to write the value as a string:
comment|//static void output(const T&value, void *ctxt, llvm::raw_ostream&out);
comment|//
comment|// Function to convert a string to a value.  Returns the empty
comment|// StringRef on success or an error string if string is malformed:
comment|//static StringRef input(StringRef scalar, void *ctxt, T&value);
block|}
expr_stmt|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a YAML sequence.  For example:
comment|///
comment|///    template<>
comment|///    struct SequenceTraits< std::vector<MyType>> {
comment|///      static size_t size(IO&io, std::vector<MyType>&seq) {
comment|///        return seq.size();
comment|///      }
comment|///      static MyType& element(IO&, std::vector<MyType>&seq, size_t index) {
comment|///        if ( index>= seq.size() )
comment|///          seq.resize(index+1);
comment|///        return seq[index];
comment|///      }
comment|///    };
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|SequenceTraits
block|{
comment|// Must provide:
comment|// static size_t size(IO&io, T&seq);
comment|// static T::value_type& element(IO&io, T&seq, size_t index);
comment|//
comment|// The following is option and will cause generated YAML to use
comment|// a flow sequence (e.g. [a,b,c]).
comment|// static const bool flow = true;
block|}
expr_stmt|;
comment|/// This class should be specialized by any type that needs to be converted
comment|/// to/from a list of YAML documents.
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DocumentListTraits
block|{
comment|// Must provide:
comment|// static size_t size(IO&io, T&seq);
comment|// static T::value_type& element(IO&io, T&seq, size_t index);
block|}
expr_stmt|;
comment|// Only used by compiler if both template types are the same
name|template
operator|<
name|typename
name|T
operator|,
name|T
operator|>
expr|struct
name|SameType
expr_stmt|;
comment|// Only used for better diagnostics of missing traits
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|MissingTrait
expr_stmt|;
comment|// Test if ScalarEnumerationTraits<T> is defined on type T.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarEnumerationTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_enumeration
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_enumeration
argument_list|,
operator|&
name|U
operator|::
name|enumeration
operator|>
operator|*
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
name|public
label|:
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarEnumerationTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
block|}
empty_stmt|;
comment|// Test if ScalarBitSetTraits<T> is defined on type T.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarBitSetTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_bitset
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_bitset
argument_list|,
operator|&
name|U
operator|::
name|bitset
operator|>
operator|*
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
name|public
label|:
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarBitSetTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Test if ScalarTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_ScalarTraits
block|{
typedef|typedef
name|StringRef
function_decl|(
modifier|*
name|Signature_input
function_decl|)
parameter_list|(
name|StringRef
parameter_list|,
name|void
modifier|*
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|void
argument_list|(
operator|*
name|Signature_output
argument_list|)
argument_list|(
specifier|const
name|T
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_input
argument_list|,
operator|&
name|U
operator|::
name|input
operator|>
operator|*
argument_list|,
name|SameType
operator|<
name|Signature_output
argument_list|,
operator|&
name|U
operator|::
name|output
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|ScalarTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
expr|,
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if MappingTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_MappingTraits
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|Signature_mapping
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_mapping
argument_list|,
operator|&
name|U
operator|::
name|mapping
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|MappingTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Test if SequenceTraits<T> is defined on type T.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_SequenceMethodTraits
block|{
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|Signature_size
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_size
argument_list|,
operator|&
name|U
operator|::
name|size
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|SequenceTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// has_FlowTraits<int> will cause an error with some compilers because
end_comment

begin_comment
comment|// it subclasses int.  Using this wrapper only instantiates the
end_comment

begin_comment
comment|// real has_FlowTraits only if the template type is a class.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|bool
name|Enabled
operator|=
name|llvm
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
operator|>
name|class
name|has_FlowTraits
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Some older gcc compilers don't support straight forward tests
end_comment

begin_comment
comment|// for members, so test for ambiguity cause by the base and derived
end_comment

begin_comment
comment|// classes both defining the member.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_FlowTraits
operator|<
name|T
operator|,
name|true
operator|>
block|{   struct
name|Fallback
block|{
name|bool
name|flow
block|; }
block|;   struct
name|Derived
operator|:
name|T
block|,
name|Fallback
block|{ }
block|;
name|template
operator|<
name|typename
name|C
operator|>
specifier|static
name|char
argument_list|(
operator|&
name|f
argument_list|(
argument|SameType<bool Fallback::*
argument_list|,
argument|&C::flow>*
argument_list|)
argument_list|)
index|[
literal|1
index|]
block|;
name|template
operator|<
name|typename
name|C
operator|>
specifier|static
name|char
argument_list|(
operator|&
name|f
argument_list|(
operator|...
argument_list|)
argument_list|)
index|[
literal|2
index|]
block|;
name|public
operator|:
specifier|static
name|bool
specifier|const
name|value
operator|=
sizeof|sizeof
argument_list|(
name|f
operator|<
name|Derived
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|2
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Test if SequenceTraits<T> is defined on type T
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|has_SequenceTraits
operator|:
name|public
name|llvm
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|has_SequenceMethodTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Test if DocumentListTraits<T> is defined on type T
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_DocumentListTraits
block|{
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|Signature_size
function_decl|)
parameter_list|(
name|class
name|IO
modifier|&
parameter_list|,
name|T
modifier|&
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|char
name|test
argument_list|(
name|SameType
operator|<
name|Signature_size
argument_list|,
operator|&
name|U
operator|::
name|size
operator|>
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|U
operator|>
specifier|static
name|double
name|test
argument_list|(
operator|...
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|static
name|bool
specifier|const
name|value
init|=
operator|(
sizeof|sizeof
argument_list|(
name|test
operator|<
name|DocumentListTraits
operator|<
name|T
operator|>
expr|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|missingTraits
operator|:
name|public
name|llvm
operator|::
name|integral_constant
operator|<
name|bool
operator|,
operator|!
name|has_ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_ScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_MappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
operator|!
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Base class for Input and Output.
end_comment

begin_decl_stmt
name|class
name|IO
block|{
name|public
label|:
name|IO
argument_list|(
name|void
operator|*
name|Ctxt
operator|=
name|NULL
argument_list|)
expr_stmt|;
name|virtual
operator|~
name|IO
argument_list|()
expr_stmt|;
name|virtual
name|bool
name|outputting
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|unsigned
name|beginSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightElement
parameter_list|(
name|unsigned
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightElement
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|canElideEmptySequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|unsigned
name|beginFlowSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightFlowElement
parameter_list|(
name|unsigned
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightFlowElement
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endFlowSequence
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|mapTag
parameter_list|(
name|StringRef
name|Tag
parameter_list|,
name|bool
name|Default
init|=
name|false
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|beginMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endMapping
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|preflightKey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|&
parameter_list|,
name|void
modifier|*
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|postflightKey
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|beginEnumScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|matchEnumScalar
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endEnumScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|beginBitSetScalar
parameter_list|(
name|bool
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|bitSetMatch
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|endBitSetScalar
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|void
name|scalarString
parameter_list|(
name|StringRef
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|setError
parameter_list|(
specifier|const
name|Twine
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|enumCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const T ConstVal
argument_list|)
block|{
if|if
condition|(
name|matchEnumScalar
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|ConstVal
expr_stmt|;
block|}
block|}
comment|// allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|enumCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const uint32_t ConstVal
argument_list|)
block|{
if|if
condition|(
name|matchEnumScalar
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|static_cast
operator|<
name|T
operator|>
operator|(
name|ConstVal
operator|)
argument_list|)
condition|)
block|{
name|Val
operator|=
name|ConstVal
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|bitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const T ConstVal
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|ConstVal
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|Val
operator||
name|ConstVal
expr_stmt|;
block|}
block|}
comment|// allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|bitSetCase
argument_list|(
argument|T&Val
argument_list|,
argument|const char* Str
argument_list|,
argument|const uint32_t ConstVal
argument_list|)
block|{
if|if
condition|(
name|bitSetMatch
argument_list|(
name|Str
argument_list|,
name|outputting
argument_list|()
operator|&&
operator|(
name|Val
operator|&
name|ConstVal
operator|)
operator|==
name|ConstVal
argument_list|)
condition|)
block|{
name|Val
operator|=
name|Val
operator||
name|ConstVal
expr_stmt|;
block|}
block|}
name|void
operator|*
name|getContext
argument_list|()
expr_stmt|;
name|void
name|setContext
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|mapRequired
argument_list|(
argument|const char* Key
argument_list|,
argument|T& Val
argument_list|)
block|{
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|true
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|mapOptional
argument_list|(
argument|const char* Key
argument_list|,
argument|T& Val
argument_list|)
block|{
comment|// omit key/value instead of outputting empty sequence
if|if
condition|(
name|this
operator|->
name|canElideEmptySequence
argument_list|()
operator|&&
operator|!
operator|(
name|Val
operator|.
name|begin
argument_list|()
operator|!=
name|Val
operator|.
name|end
argument_list|()
operator|)
condition|)
return|return;
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
operator|!
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|mapOptional
argument_list|(
argument|const char* Key
argument_list|,
argument|T& Val
argument_list|)
block|{
name|this
operator|->
name|processKey
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|false
argument_list|)
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|mapOptional
argument_list|(
argument|const char* Key
argument_list|,
argument|T& Val
argument_list|,
argument|const T& Default
argument_list|)
block|{
name|this
operator|->
name|processKeyWithDefault
argument_list|(
name|Key
argument_list|,
name|Val
argument_list|,
name|Default
argument_list|,
name|false
argument_list|)
block|;   }
name|private
operator|:
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|processKeyWithDefault
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|const T& DefaultValue
argument_list|,
argument|bool Required
argument_list|)
block|{
name|void
operator|*
name|SaveInfo
block|;
name|bool
name|UseDefault
block|;
specifier|const
name|bool
name|sameAsDefault
operator|=
name|outputting
argument_list|()
operator|&&
name|Val
operator|==
name|DefaultValue
block|;
if|if
condition|(
name|this
operator|->
name|preflightKey
argument_list|(
name|Key
argument_list|,
name|Required
argument_list|,
name|sameAsDefault
argument_list|,
name|UseDefault
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Val
argument_list|,
name|Required
argument_list|)
expr_stmt|;
name|this
operator|->
name|postflightKey
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
if|if
condition|(
name|UseDefault
condition|)
name|Val
operator|=
name|DefaultValue
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|T
operator|>
name|void
name|processKey
argument_list|(
argument|const char *Key
argument_list|,
argument|T&Val
argument_list|,
argument|bool Required
argument_list|)
block|{
name|void
operator|*
name|SaveInfo
block|;
name|bool
name|UseDefault
block|;
if|if
condition|(
name|this
operator|->
name|preflightKey
argument_list|(
name|Key
argument_list|,
name|Required
argument_list|,
name|false
argument_list|,
name|UseDefault
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
operator|*
name|this
argument_list|,
name|Val
argument_list|,
name|Required
argument_list|)
expr_stmt|;
name|this
operator|->
name|postflightKey
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
unit|}  private:
name|void
modifier|*
name|Ctxt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|)
block|{
name|io
operator|.
name|beginEnumScalar
argument_list|()
block|;
name|ScalarEnumerationTraits
operator|<
name|T
operator|>
operator|::
name|enumeration
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
block|;
name|io
operator|.
name|endEnumScalar
argument_list|()
block|; }
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|)
block|{
name|bool
name|DoClear
block|;
if|if
condition|(
name|io
operator|.
name|beginBitSetScalar
argument_list|(
name|DoClear
argument_list|)
condition|)
block|{
if|if
condition|(
name|DoClear
condition|)
name|Val
operator|=
name|static_cast
operator|<
name|T
operator|>
operator|(
literal|0
operator|)
expr_stmt|;
name|ScalarBitSetTraits
operator|<
name|T
operator|>
operator|::
name|bitset
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
expr_stmt|;
name|io
operator|.
name|endBitSetScalar
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_ScalarTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|std
operator|::
name|string
name|Storage
expr_stmt|;
name|llvm
operator|::
name|raw_string_ostream
name|Buffer
argument_list|(
name|Storage
argument_list|)
expr_stmt|;
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|output
argument_list|(
name|Val
argument_list|,
name|io
operator|.
name|getContext
argument_list|()
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|StringRef
name|Str
init|=
name|Buffer
operator|.
name|str
argument_list|()
decl_stmt|;
name|io
operator|.
name|scalarString
argument_list|(
name|Str
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|StringRef
name|Str
decl_stmt|;
name|io
operator|.
name|scalarString
argument_list|(
name|Str
argument_list|)
expr_stmt|;
name|StringRef
name|Result
init|=
name|ScalarTraits
operator|<
name|T
operator|>
operator|::
name|input
argument_list|(
name|Str
argument_list|,
name|io
operator|.
name|getContext
argument_list|()
argument_list|,
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Result
operator|.
name|empty
argument_list|()
condition|)
block|{
name|io
operator|.
name|setError
argument_list|(
name|llvm
operator|::
name|Twine
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_MappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|)
block|{
name|io
operator|.
name|beginMapping
argument_list|()
block|;
name|MappingTraits
operator|<
name|T
operator|>
operator|::
name|mapping
argument_list|(
name|io
argument_list|,
name|Val
argument_list|)
block|;
name|io
operator|.
name|endMapping
argument_list|()
block|; }
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|missingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Val
argument_list|,
argument|bool
argument_list|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|; }
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|void
operator|>
operator|::
name|type
name|yamlize
argument_list|(
argument|IO&io
argument_list|,
argument|T&Seq
argument_list|,
argument|bool
argument_list|)
block|{
if|if
condition|(
name|has_FlowTraits
operator|<
name|SequenceTraits
operator|<
name|T
operator|>
expr|>
operator|::
name|value
condition|)
block|{
name|unsigned
name|incnt
init|=
name|io
operator|.
name|beginFlowSequence
argument_list|()
decl_stmt|;
name|unsigned
name|count
init|=
name|io
operator|.
name|outputting
argument_list|()
condition|?
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|)
else|:
name|incnt
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|SaveInfo
decl_stmt|;
if|if
condition|(
name|io
operator|.
name|preflightFlowElement
argument_list|(
name|i
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|io
argument_list|,
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|io
operator|.
name|postflightFlowElement
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     io
operator|.
name|endFlowSequence
argument_list|()
expr_stmt|;
end_expr_stmt

begin_block
unit|}   else
block|{
name|unsigned
name|incnt
init|=
name|io
operator|.
name|beginSequence
argument_list|()
decl_stmt|;
name|unsigned
name|count
init|=
name|io
operator|.
name|outputting
argument_list|()
condition|?
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|)
else|:
name|incnt
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|SaveInfo
decl_stmt|;
if|if
condition|(
name|io
operator|.
name|preflightElement
argument_list|(
name|i
argument_list|,
name|SaveInfo
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|io
argument_list|,
name|SequenceTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|io
argument_list|,
name|Seq
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|io
operator|.
name|postflightElement
argument_list|(
name|SaveInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|io
operator|.
name|endSequence
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}   template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|bool
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|bool
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|bool
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|StringRef
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|StringRef
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|StringRef
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint8_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint8_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint8_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint16_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint16_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint16_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint32_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint32_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint32_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|uint64_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|uint64_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|uint64_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int8_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int8_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int8_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int16_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int16_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int16_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int32_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int32_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int32_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|int64_t
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|int64_t
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|int64_t
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|float
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|float
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|float
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|double
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|double
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|double
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Utility for use within MappingTraits<>::mapping() method
end_comment

begin_comment
comment|// to [de]normalize an object for use with YAML conversion.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|TNorm
operator|,
name|typename
name|TFinal
operator|>
expr|struct
name|MappingNormalization
block|{
name|MappingNormalization
argument_list|(
name|IO
operator|&
name|i_o
argument_list|,
name|TFinal
operator|&
name|Obj
argument_list|)
operator|:
name|io
argument_list|(
name|i_o
argument_list|)
block|,
name|BufPtr
argument_list|(
name|NULL
argument_list|)
block|,
name|Result
argument_list|(
argument|Obj
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|,
name|Obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}    ~
name|MappingNormalization
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|Result
operator|=
name|BufPtr
operator|->
name|denormalize
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|BufPtr
operator|->
expr|~
name|TNorm
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|TNorm
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|BufPtr
return|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
name|TNorm
operator|>
name|Storage
expr_stmt|;
end_typedef

begin_decl_stmt
name|Storage
name|Buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IO
modifier|&
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TNorm
modifier|*
name|BufPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TFinal
modifier|&
name|Result
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Utility for use within MappingTraits<>::mapping() method
end_comment

begin_comment
comment|// to [de]normalize an object for use with YAML conversion.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|TNorm
operator|,
name|typename
name|TFinal
operator|>
expr|struct
name|MappingNormalizationHeap
block|{
name|MappingNormalizationHeap
argument_list|(
name|IO
operator|&
name|i_o
argument_list|,
name|TFinal
operator|&
name|Obj
argument_list|)
operator|:
name|io
argument_list|(
name|i_o
argument_list|)
block|,
name|BufPtr
argument_list|(
name|NULL
argument_list|)
block|,
name|Result
argument_list|(
argument|Obj
argument_list|)
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|=
name|new
argument_list|(
argument|&Buffer
argument_list|)
name|TNorm
argument_list|(
name|io
argument_list|,
name|Obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BufPtr
operator|=
name|new
name|TNorm
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}    ~
name|MappingNormalizationHeap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|io
operator|.
name|outputting
argument_list|()
condition|)
block|{
name|BufPtr
operator|->
expr|~
name|TNorm
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Result
operator|=
name|BufPtr
operator|->
name|denormalize
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|TNorm
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|BufPtr
return|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
name|TNorm
operator|>
name|Storage
expr_stmt|;
end_typedef

begin_decl_stmt
name|Storage
name|Buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IO
modifier|&
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TNorm
modifier|*
name|BufPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TFinal
modifier|&
name|Result
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|///
end_comment

begin_comment
comment|/// The Input class is used to parse a yaml document into in-memory structs
end_comment

begin_comment
comment|/// and vectors.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// It works by using YAMLParser to do a syntax parse of the entire yaml
end_comment

begin_comment
comment|/// document, then the Input class builds a graph of HNodes which wraps
end_comment

begin_comment
comment|/// each yaml Node.  The extra layer is buffering.  The low level yaml
end_comment

begin_comment
comment|/// parser only lets you look at each node once.  The buffering layer lets
end_comment

begin_comment
comment|/// you search and interate multiple times.  This is necessary because
end_comment

begin_comment
comment|/// the mapRequired() method calls may not be in the same order
end_comment

begin_comment
comment|/// as the keys in the document.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Input
range|:
name|public
name|IO
block|{
name|public
operator|:
comment|// Construct a yaml Input object from a StringRef and optional
comment|// user-data. The DiagHandler can be specified to provide
comment|// alternative error reporting.
name|Input
argument_list|(
argument|StringRef InputContent
argument_list|,
argument|void *Ctxt = NULL
argument_list|,
argument|SourceMgr::DiagHandlerTy DiagHandler = NULL
argument_list|,
argument|void *DiagHandlerCtxt = NULL
argument_list|)
block|;
operator|~
name|Input
argument_list|()
block|;
comment|// Check if there was an syntax or semantic error during parsing.
name|llvm
operator|::
name|error_code
name|error
argument_list|()
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const IO *io
argument_list|)
block|{
return|return
operator|!
name|io
operator|->
name|outputting
argument_list|()
return|;
block|}
name|private
operator|:
name|virtual
name|bool
name|outputting
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|mapTag
argument_list|(
name|StringRef
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|beginMapping
argument_list|()
block|;
name|virtual
name|void
name|endMapping
argument_list|()
block|;
name|virtual
name|bool
name|preflightKey
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|,
name|bool
operator|&
argument_list|,
name|void
operator|*
operator|&
argument_list|)
block|;
name|virtual
name|void
name|postflightKey
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|unsigned
name|beginSequence
argument_list|()
block|;
name|virtual
name|void
name|endSequence
argument_list|()
block|;
name|virtual
name|bool
name|preflightElement
argument_list|(
argument|unsigned index
argument_list|,
argument|void *&
argument_list|)
block|;
name|virtual
name|void
name|postflightElement
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|unsigned
name|beginFlowSequence
argument_list|()
block|;
name|virtual
name|bool
name|preflightFlowElement
argument_list|(
name|unsigned
argument_list|,
name|void
operator|*
operator|&
argument_list|)
block|;
name|virtual
name|void
name|postflightFlowElement
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|void
name|endFlowSequence
argument_list|()
block|;
name|virtual
name|void
name|beginEnumScalar
argument_list|()
block|;
name|virtual
name|bool
name|matchEnumScalar
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|endEnumScalar
argument_list|()
block|;
name|virtual
name|bool
name|beginBitSetScalar
argument_list|(
name|bool
operator|&
argument_list|)
block|;
name|virtual
name|bool
name|bitSetMatch
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|endBitSetScalar
argument_list|()
block|;
name|virtual
name|void
name|scalarString
argument_list|(
name|StringRef
operator|&
argument_list|)
block|;
name|virtual
name|void
name|setError
argument_list|(
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|virtual
name|bool
name|canElideEmptySequence
argument_list|()
block|;
name|class
name|HNode
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|HNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|_node
argument_list|(
argument|n
argument_list|)
block|{ }
name|virtual
operator|~
name|HNode
argument_list|()
block|{ }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|Node
operator|*
name|_node
block|;   }
block|;
name|class
name|EmptyHNode
operator|:
name|public
name|HNode
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|EmptyHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|NullNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const EmptyHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|ScalarHNode
operator|:
name|public
name|HNode
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|ScalarHNode
argument_list|(
argument|Node *n
argument_list|,
argument|StringRef s
argument_list|)
operator|:
name|HNode
argument_list|(
name|n
argument_list|)
block|,
name|_value
argument_list|(
argument|s
argument_list|)
block|{ }
name|StringRef
name|value
argument_list|()
specifier|const
block|{
return|return
name|_value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|ScalarNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const ScalarHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|StringRef
name|_value
block|;   }
block|;
name|class
name|MapHNode
operator|:
name|public
name|HNode
block|{
name|public
operator|:
name|MapHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
name|virtual
operator|~
name|MapHNode
argument_list|()
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|MappingNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MapHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
typedef|typedef
name|llvm
operator|::
name|StringMap
operator|<
name|HNode
operator|*
operator|>
name|NameToNode
expr_stmt|;
name|bool
name|isValidKey
argument_list|(
argument|StringRef key
argument_list|)
block|;
name|NameToNode
name|Mapping
block|;
name|llvm
operator|::
name|SmallVector
operator|<
specifier|const
name|char
operator|*
block|,
literal|6
operator|>
name|ValidKeys
block|;   }
block|;
name|class
name|SequenceHNode
operator|:
name|public
name|HNode
block|{
name|public
operator|:
name|SequenceHNode
argument_list|(
name|Node
operator|*
name|n
argument_list|)
operator|:
name|HNode
argument_list|(
argument|n
argument_list|)
block|{ }
name|virtual
operator|~
name|SequenceHNode
argument_list|()
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const HNode *n
argument_list|)
block|{
return|return
name|SequenceNode
operator|::
name|classof
argument_list|(
name|n
operator|->
name|_node
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SequenceHNode *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|HNode
operator|*
operator|>
name|Entries
block|;   }
block|;
name|Input
operator|::
name|HNode
operator|*
name|createHNodes
argument_list|(
name|Node
operator|*
name|node
argument_list|)
block|;
name|void
name|setError
argument_list|(
name|HNode
operator|*
name|hnode
argument_list|,
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|void
name|setError
argument_list|(
name|Node
operator|*
name|node
argument_list|,
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|public
operator|:
comment|// These are only used by operator>>. They could be private
comment|// if those templated things could be made friends.
name|bool
name|setCurrentDocument
argument_list|()
block|;
name|void
name|nextDocument
argument_list|()
block|;
name|private
operator|:
name|llvm
operator|::
name|SourceMgr
name|SrcMgr
block|;
comment|// must be before Strm
name|OwningPtr
operator|<
name|llvm
operator|::
name|yaml
operator|::
name|Stream
operator|>
name|Strm
block|;
name|OwningPtr
operator|<
name|HNode
operator|>
name|TopNode
block|;
name|llvm
operator|::
name|error_code
name|EC
block|;
name|llvm
operator|::
name|BumpPtrAllocator
name|StringAllocator
block|;
name|llvm
operator|::
name|yaml
operator|::
name|document_iterator
name|DocIterator
block|;
name|std
operator|::
name|vector
operator|<
name|bool
operator|>
name|BitValuesUsed
block|;
name|HNode
operator|*
name|CurrentNode
block|;
name|bool
name|ScalarMatchFound
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|///
end_comment

begin_comment
comment|/// The Output class is used to generate a yaml document from in-memory structs
end_comment

begin_comment
comment|/// and vectors.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Output
range|:
name|public
name|IO
block|{
name|public
operator|:
name|Output
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|,
name|void
operator|*
name|Ctxt
operator|=
name|NULL
argument_list|)
block|;
name|virtual
operator|~
name|Output
argument_list|()
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const IO *io
argument_list|)
block|{
return|return
name|io
operator|->
name|outputting
argument_list|()
return|;
block|}
name|virtual
name|bool
name|outputting
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|mapTag
argument_list|(
name|StringRef
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|beginMapping
argument_list|()
block|;
name|virtual
name|void
name|endMapping
argument_list|()
block|;
name|virtual
name|bool
name|preflightKey
argument_list|(
specifier|const
name|char
operator|*
name|key
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|,
name|bool
operator|&
argument_list|,
name|void
operator|*
operator|&
argument_list|)
block|;
name|virtual
name|void
name|postflightKey
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|unsigned
name|beginSequence
argument_list|()
block|;
name|virtual
name|void
name|endSequence
argument_list|()
block|;
name|virtual
name|bool
name|preflightElement
argument_list|(
name|unsigned
argument_list|,
name|void
operator|*
operator|&
argument_list|)
block|;
name|virtual
name|void
name|postflightElement
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|unsigned
name|beginFlowSequence
argument_list|()
block|;
name|virtual
name|bool
name|preflightFlowElement
argument_list|(
name|unsigned
argument_list|,
name|void
operator|*
operator|&
argument_list|)
block|;
name|virtual
name|void
name|postflightFlowElement
argument_list|(
name|void
operator|*
argument_list|)
block|;
name|virtual
name|void
name|endFlowSequence
argument_list|()
block|;
name|virtual
name|void
name|beginEnumScalar
argument_list|()
block|;
name|virtual
name|bool
name|matchEnumScalar
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|endEnumScalar
argument_list|()
block|;
name|virtual
name|bool
name|beginBitSetScalar
argument_list|(
name|bool
operator|&
argument_list|)
block|;
name|virtual
name|bool
name|bitSetMatch
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|bool
argument_list|)
block|;
name|virtual
name|void
name|endBitSetScalar
argument_list|()
block|;
name|virtual
name|void
name|scalarString
argument_list|(
name|StringRef
operator|&
argument_list|)
block|;
name|virtual
name|void
name|setError
argument_list|(
specifier|const
name|Twine
operator|&
name|message
argument_list|)
block|;
name|virtual
name|bool
name|canElideEmptySequence
argument_list|()
block|;
name|public
operator|:
comment|// These are only used by operator<<. They could be private
comment|// if that templated operator could be made a friend.
name|void
name|beginDocuments
argument_list|()
block|;
name|bool
name|preflightDocument
argument_list|(
name|unsigned
argument_list|)
block|;
name|void
name|postflightDocument
argument_list|()
block|;
name|void
name|endDocuments
argument_list|()
block|;
name|private
operator|:
name|void
name|output
argument_list|(
argument|StringRef s
argument_list|)
block|;
name|void
name|outputUpToEndOfLine
argument_list|(
argument|StringRef s
argument_list|)
block|;
name|void
name|newLineCheck
argument_list|()
block|;
name|void
name|outputNewLine
argument_list|()
block|;
name|void
name|paddedKey
argument_list|(
argument|StringRef key
argument_list|)
block|;    enum
name|InState
block|{
name|inSeq
block|,
name|inFlowSeq
block|,
name|inMapFirstKey
block|,
name|inMapOtherKey
block|}
block|;
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
block|;
name|SmallVector
operator|<
name|InState
block|,
literal|8
operator|>
name|StateStack
block|;
name|int
name|Column
block|;
name|int
name|ColumnAtFlowStart
block|;
name|bool
name|NeedBitValueComma
block|;
name|bool
name|NeedFlowSequenceComma
block|;
name|bool
name|EnumerationMatchFound
block|;
name|bool
name|NeedsNewLine
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// YAML I/O does conversion based on types. But often native data types
end_comment

begin_comment
comment|/// are just a typedef of built in intergral types (e.g. int).  But the C++
end_comment

begin_comment
comment|/// type matching system sees through the typedef and all the typedefed types
end_comment

begin_comment
comment|/// look like a built in type. This will cause the generic YAML I/O conversion
end_comment

begin_comment
comment|/// to be used. To provide better control over the YAML conversion, you can
end_comment

begin_comment
comment|/// use this macro instead of typedef.  It will create a class with one field
end_comment

begin_comment
comment|/// and automatic conversion operators to and from the base type.
end_comment

begin_comment
comment|/// Based on BOOST_STRONG_TYPEDEF
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_STRONG_TYPEDEF
parameter_list|(
name|_base
parameter_list|,
name|_type
parameter_list|)
define|\
value|struct _type {                                                             \         _type() { }                                                            \         _type(const _base v) : value(v) { }                                    \         _type(const _type&v) : value(v.value) {}                              \         _type&operator=(const _type&rhs) { value = rhs.value; return *this; }\         _type&operator=(const _base&rhs) { value = rhs; return *this; }      \         operator const _base& () const { return value; }                      \         bool operator==(const _type&rhs) const { return value == rhs.value; } \         bool operator==(const _base&rhs) const { return value == rhs; }       \         bool operator<(const _type&rhs) const { return value< rhs.value; }   \         _base value;                                                           \     };
end_define

begin_comment
comment|///
end_comment

begin_comment
comment|/// Use these types instead of uintXX_t in any mapping to have
end_comment

begin_comment
comment|/// its yaml output formatted as hexadecimal.
end_comment

begin_comment
comment|///
end_comment

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint8_t
argument_list|,
argument|Hex8
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint16_t
argument_list|,
argument|Hex16
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint32_t
argument_list|,
argument|Hex32
argument_list|)
end_macro

begin_macro
name|LLVM_YAML_STRONG_TYPEDEF
argument_list|(
argument|uint64_t
argument_list|,
argument|Hex64
argument_list|)
end_macro

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex8
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex8
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex8
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex16
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex16
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex16
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex32
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex32
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex32
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|ScalarTraits
operator|<
name|Hex64
operator|>
block|{
specifier|static
name|void
name|output
argument_list|(
specifier|const
name|Hex64
operator|&
argument_list|,
name|void
operator|*
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
argument_list|)
block|;
specifier|static
name|StringRef
name|input
argument_list|(
name|StringRef
argument_list|,
name|void
operator|*
argument_list|,
name|Hex64
operator|&
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Define non-member operator>> so that Input can stream in a document list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docList
operator|)
block|{
name|int
name|i
operator|=
literal|0
block|;
while|while
condition|(
name|yin
operator|.
name|setCurrentDocument
argument_list|()
condition|)
block|{
name|yamlize
argument_list|(
name|yin
argument_list|,
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|yin
argument_list|,
name|docList
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|yin
operator|.
name|error
argument_list|()
condition|)
return|return
name|yin
return|;
name|yin
operator|.
name|nextDocument
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|yin
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator>> so that Input can stream in a map as a document.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_MappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docMap
operator|)
block|{
name|yin
operator|.
name|setCurrentDocument
argument_list|()
block|;
name|yamlize
argument_list|(
name|yin
argument_list|,
name|docMap
argument_list|,
name|true
argument_list|)
block|;
return|return
name|yin
return|;
block|}
end_expr_stmt

begin_comment
comment|// Define non-member operator>> so that Input can stream in a sequence as
end_comment

begin_comment
comment|// a document.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docSeq
operator|)
block|{
if|if
condition|(
name|yin
operator|.
name|setCurrentDocument
argument_list|()
condition|)
name|yamlize
argument_list|(
name|yin
argument_list|,
name|docSeq
argument_list|,
name|true
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yin
return|;
end_return

begin_comment
unit|}
comment|// Provide better error message about types missing a trait specialization
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|missingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Input
operator|&
operator|>
operator|::
name|type
name|operator
operator|>>
operator|(
name|Input
operator|&
name|yin
operator|,
name|T
operator|&
name|docSeq
operator|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|;
return|return
name|yin
return|;
block|}
end_expr_stmt

begin_comment
comment|// Define non-member operator<< so that Output can stream out document list.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|docList
operator|)
block|{
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
specifier|const
name|size_t
name|count
operator|=
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|size
argument_list|(
name|yout
argument_list|,
name|docList
argument_list|)
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|DocumentListTraits
operator|<
name|T
operator|>
operator|::
name|element
argument_list|(
name|yout
argument_list|,
name|docList
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a map.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_MappingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|map
operator|)
block|{
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|map
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Define non-member operator<< so that Output can stream out a sequence.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|has_SequenceTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|seq
operator|)
block|{
name|yout
operator|.
name|beginDocuments
argument_list|()
block|;
if|if
condition|(
name|yout
operator|.
name|preflightDocument
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|yamlize
argument_list|(
name|yout
argument_list|,
name|seq
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|yout
operator|.
name|postflightDocument
argument_list|()
expr_stmt|;
block|}
name|yout
operator|.
name|endDocuments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|yout
return|;
end_return

begin_comment
unit|}
comment|// Provide better error message about types missing a trait specialization
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|typename
name|llvm
operator|::
name|enable_if_c
operator|<
name|missingTraits
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|Output
operator|&
operator|>
operator|::
name|type
name|operator
operator|<<
operator|(
name|Output
operator|&
name|yout
operator|,
name|T
operator|&
name|seq
operator|)
block|{
name|char
name|missing_yaml_trait_for_type
index|[
sizeof|sizeof
argument_list|(
name|MissingTrait
operator|<
name|T
operator|>
argument_list|)
index|]
block|;
return|return
name|yout
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace yaml
end_comment

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML sequence.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_SEQUENCE_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                          \   namespace yaml {                                                          \     template<>                                                              \     struct SequenceTraits< std::vector<_type>> {                           \       static size_t size(IO&io, std::vector<_type>&seq) {                 \         return seq.size();                                                  \       }                                                                     \       static _type& element(IO&io, std::vector<_type>&seq, size_t index) {\         if ( index>= seq.size() )                                          \           seq.resize(index+1);                                              \         return seq[index];                                                  \       }                                                                     \     };                                                                      \   }                                                                         \   }
end_define

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML flow sequence.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                          \   namespace yaml {                                                          \     template<>                                                              \     struct SequenceTraits< std::vector<_type>> {                           \       static size_t size(IO&io, std::vector<_type>&seq) {                 \         return seq.size();                                                  \       }                                                                     \       static _type& element(IO&io, std::vector<_type>&seq, size_t index) {\         if ( index>= seq.size() )                                          \           seq.resize(index+1);                                              \         return seq[index];                                                  \       }                                                                     \       static const bool flow = true;                                        \     };                                                                      \   }                                                                         \   }
end_define

begin_comment
comment|/// Utility for declaring that a std::vector of a particular type
end_comment

begin_comment
comment|/// should be considered a YAML document list.
end_comment

begin_define
define|#
directive|define
name|LLVM_YAML_IS_DOCUMENT_LIST_VECTOR
parameter_list|(
name|_type
parameter_list|)
define|\
value|namespace llvm {                                                          \   namespace yaml {                                                          \     template<>                                                              \     struct DocumentListTraits< std::vector<_type>> {                       \       static size_t size(IO&io, std::vector<_type>&seq) {                 \         return seq.size();                                                  \       }                                                                     \       static _type& element(IO&io, std::vector<_type>&seq, size_t index) {\         if ( index>= seq.size() )                                          \           seq.resize(index+1);                                              \         return seq[index];                                                  \       }                                                                     \     };                                                                      \   }                                                                         \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_SUPPORT_YAMLTRAITS_H
end_comment

end_unit

