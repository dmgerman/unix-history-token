begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BranchProbability.h - Branch Probability Wrapper ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Definition of BranchProbability shared by IR and Machine Instructions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_BRANCHPROBABILITY_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_BRANCHPROBABILITY_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<numeric>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
comment|// This class represents Branch Probability as a non-negative fraction that is
comment|// no greater than 1. It uses a fixed-point-like implementation, in which the
comment|// denominator is always a constant value (here we use 1<<31 for maximum
comment|// precision).
name|class
name|BranchProbability
block|{
comment|// Numerator
name|uint32_t
name|N
decl_stmt|;
comment|// Denominator, which is a constant value.
specifier|static
specifier|const
name|uint32_t
name|D
init|=
literal|1u
operator|<<
literal|31
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|UnknownN
init|=
name|UINT32_MAX
decl_stmt|;
comment|// Construct a BranchProbability with only numerator assuming the denominator
comment|// is 1<<31. For internal use only.
name|explicit
name|BranchProbability
argument_list|(
argument|uint32_t n
argument_list|)
block|:
name|N
argument_list|(
argument|n
argument_list|)
block|{}
name|public
label|:
name|BranchProbability
argument_list|()
operator|:
name|N
argument_list|(
argument|UnknownN
argument_list|)
block|{}
name|BranchProbability
argument_list|(
argument|uint32_t Numerator
argument_list|,
argument|uint32_t Denominator
argument_list|)
expr_stmt|;
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|N
operator|==
literal|0
return|;
block|}
name|bool
name|isUnknown
argument_list|()
specifier|const
block|{
return|return
name|N
operator|==
name|UnknownN
return|;
block|}
specifier|static
name|BranchProbability
name|getZero
parameter_list|()
block|{
return|return
name|BranchProbability
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|static
name|BranchProbability
name|getOne
parameter_list|()
block|{
return|return
name|BranchProbability
argument_list|(
name|D
argument_list|)
return|;
block|}
specifier|static
name|BranchProbability
name|getUnknown
parameter_list|()
block|{
return|return
name|BranchProbability
argument_list|(
name|UnknownN
argument_list|)
return|;
block|}
comment|// Create a BranchProbability object with the given numerator and 1<<31
comment|// as denominator.
specifier|static
name|BranchProbability
name|getRaw
parameter_list|(
name|uint32_t
name|N
parameter_list|)
block|{
return|return
name|BranchProbability
argument_list|(
name|N
argument_list|)
return|;
block|}
comment|// Create a BranchProbability object from 64-bit integers.
specifier|static
name|BranchProbability
name|getBranchProbability
parameter_list|(
name|uint64_t
name|Numerator
parameter_list|,
name|uint64_t
name|Denominator
parameter_list|)
function_decl|;
comment|// Normalize given probabilties so that the sum of them becomes approximate
comment|// one.
name|template
operator|<
name|class
name|ProbabilityIter
operator|>
specifier|static
name|void
name|normalizeProbabilities
argument_list|(
argument|ProbabilityIter Begin
argument_list|,
argument|ProbabilityIter End
argument_list|)
expr_stmt|;
name|uint32_t
name|getNumerator
argument_list|()
specifier|const
block|{
return|return
name|N
return|;
block|}
specifier|static
name|uint32_t
name|getDenominator
parameter_list|()
block|{
return|return
name|D
return|;
block|}
comment|// Return (1 - Probability).
name|BranchProbability
name|getCompl
argument_list|()
specifier|const
block|{
return|return
name|BranchProbability
argument_list|(
name|D
operator|-
name|N
argument_list|)
return|;
block|}
name|raw_ostream
modifier|&
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Scale a large integer.
comment|///
comment|/// Scales \c Num.  Guarantees full precision.  Returns the floor of the
comment|/// result.
comment|///
comment|/// \return \c Num times \c this.
name|uint64_t
name|scale
argument_list|(
name|uint64_t
name|Num
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Scale a large integer by the inverse.
comment|///
comment|/// Scales \c Num by the inverse of \c this.  Guarantees full precision.
comment|/// Returns the floor of the result.
comment|///
comment|/// \return \c Num divided by \c this.
name|uint64_t
name|scaleByInverse
argument_list|(
name|uint64_t
name|Num
argument_list|)
decl|const
decl_stmt|;
name|BranchProbability
operator|&
name|operator
operator|+=
operator|(
name|BranchProbability
name|RHS
operator|)
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in arithmetics."
argument_list|)
block|;
comment|// Saturate the result in case of overflow.
name|N
operator|=
operator|(
name|uint64_t
argument_list|(
name|N
argument_list|)
operator|+
name|RHS
operator|.
name|N
operator|>
name|D
operator|)
condition|?
name|D
else|:
name|N
operator|+
name|RHS
operator|.
name|N
block|;
return|return
operator|*
name|this
return|;
block|}
name|BranchProbability
operator|&
name|operator
operator|-=
operator|(
name|BranchProbability
name|RHS
operator|)
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in arithmetics."
argument_list|)
block|;
comment|// Saturate the result in case of underflow.
name|N
operator|=
name|N
operator|<
name|RHS
operator|.
name|N
condition|?
literal|0
else|:
name|N
operator|-
name|RHS
operator|.
name|N
block|;
return|return
operator|*
name|this
return|;
block|}
name|BranchProbability
operator|&
name|operator
operator|*=
operator|(
name|BranchProbability
name|RHS
operator|)
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in arithmetics."
argument_list|)
block|;
name|N
operator|=
operator|(
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|N
operator|)
operator|*
name|RHS
operator|.
name|N
operator|+
name|D
operator|/
literal|2
operator|)
operator|/
name|D
block|;
return|return
operator|*
name|this
return|;
block|}
name|BranchProbability
operator|&
name|operator
operator|*=
operator|(
name|uint32_t
name|RHS
operator|)
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in arithmetics."
argument_list|)
block|;
name|N
operator|=
operator|(
name|uint64_t
argument_list|(
name|N
argument_list|)
operator|*
name|RHS
operator|>
name|D
operator|)
condition|?
name|D
else|:
name|N
operator|*
name|RHS
block|;
return|return
operator|*
name|this
return|;
block|}
name|BranchProbability
operator|&
name|operator
operator|/=
operator|(
name|uint32_t
name|RHS
operator|)
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in arithmetics."
argument_list|)
block|;
name|assert
argument_list|(
name|RHS
operator|>
literal|0
operator|&&
literal|"The divider cannot be zero."
argument_list|)
block|;
name|N
operator|/=
name|RHS
block|;
return|return
operator|*
name|this
return|;
block|}
name|BranchProbability
name|operator
operator|+
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|BranchProbability
name|Prob
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
name|Prob
operator|+=
name|RHS
return|;
block|}
name|BranchProbability
name|operator
operator|-
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|BranchProbability
name|Prob
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
name|Prob
operator|-=
name|RHS
return|;
block|}
name|BranchProbability
name|operator
modifier|*
argument_list|(
name|BranchProbability
name|RHS
argument_list|)
decl|const
block|{
name|BranchProbability
name|Prob
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
return|return
name|Prob
operator|*=
name|RHS
return|;
block|}
name|BranchProbability
name|operator
modifier|*
argument_list|(
name|uint32_t
name|RHS
argument_list|)
decl|const
block|{
name|BranchProbability
name|Prob
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
return|return
name|Prob
operator|*=
name|RHS
return|;
block|}
name|BranchProbability
name|operator
operator|/
operator|(
name|uint32_t
name|RHS
operator|)
specifier|const
block|{
name|BranchProbability
name|Prob
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
name|Prob
operator|/=
name|RHS
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
return|return
name|N
operator|==
name|RHS
operator|.
name|N
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
name|bool
name|operator
operator|<
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in comparisons."
argument_list|)
block|;
return|return
name|N
operator|<
name|RHS
operator|.
name|N
return|;
block|}
name|bool
name|operator
operator|>
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in comparisons."
argument_list|)
block|;
return|return
name|RHS
operator|<
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in comparisons."
argument_list|)
block|;
return|return
operator|!
operator|(
name|RHS
operator|<
operator|*
name|this
operator|)
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
name|BranchProbability
name|RHS
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|N
operator|!=
name|UnknownN
operator|&&
name|RHS
operator|.
name|N
operator|!=
name|UnknownN
operator|&&
literal|"Unknown probability cannot participate in comparisons."
argument_list|)
block|;
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|RHS
operator|)
return|;
block|}
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
name|BranchProbability
name|Prob
operator|)
block|{
return|return
name|Prob
operator|.
name|print
argument_list|(
name|OS
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|ProbabilityIter
operator|>
name|void
name|BranchProbability
operator|::
name|normalizeProbabilities
argument_list|(
argument|ProbabilityIter Begin
argument_list|,
argument|ProbabilityIter End
argument_list|)
block|{
if|if
condition|(
name|Begin
operator|==
name|End
condition|)
return|return;
name|unsigned
name|UnknownProbCount
operator|=
literal|0
expr_stmt|;
name|uint64_t
name|Sum
init|=
name|std
operator|::
name|accumulate
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|uint64_t
argument_list|(
literal|0
argument_list|)
argument_list|,
index|[
operator|&
index|]
operator|(
name|uint64_t
name|S
expr|,
specifier|const
name|BranchProbability
operator|&
name|BP
operator|)
block|{
if|if
condition|(
operator|!
name|BP
operator|.
name|isUnknown
argument_list|()
condition|)
return|return
name|S
operator|+
name|BP
operator|.
name|N
return|;
name|UnknownProbCount
operator|++
argument_list|;                                    return
name|S
argument_list|;
block|}
end_decl_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|UnknownProbCount
operator|>
literal|0
condition|)
block|{
name|BranchProbability
name|ProbForUnknown
init|=
name|BranchProbability
operator|::
name|getZero
argument_list|()
decl_stmt|;
comment|// If the sum of all known probabilities is less than one, evenly distribute
comment|// the complement of sum to unknown probabilities. Otherwise, set unknown
comment|// probabilities to zeros and continue to normalize known probabilities.
if|if
condition|(
name|Sum
operator|<
name|BranchProbability
operator|::
name|getDenominator
argument_list|()
condition|)
name|ProbForUnknown
operator|=
name|BranchProbability
operator|::
name|getRaw
argument_list|(
operator|(
name|BranchProbability
operator|::
name|getDenominator
argument_list|()
operator|-
name|Sum
operator|)
operator|/
name|UnknownProbCount
argument_list|)
expr_stmt|;
name|std
operator|::
name|replace_if
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
index|[]
operator|(
specifier|const
name|BranchProbability
operator|&
name|BP
operator|)
block|{
return|return
name|BP
operator|.
name|isUnknown
argument_list|()
return|;
block|}
operator|,
name|ProbForUnknown
block|)
empty_stmt|;
end_if

begin_if
if|if
condition|(
name|Sum
operator|<=
name|BranchProbability
operator|::
name|getDenominator
argument_list|()
condition|)
return|return;
end_if

begin_expr_stmt
unit|}    if
operator|(
name|Sum
operator|==
literal|0
operator|)
block|{
name|BranchProbability
name|BP
argument_list|(
literal|1
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
argument_list|)
block|;
name|std
operator|::
name|fill
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|BP
argument_list|)
block|;
return|return;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|I
init|=
name|Begin
init|;
name|I
operator|!=
name|End
condition|;
operator|++
name|I
control|)
name|I
operator|->
name|N
operator|=
operator|(
name|I
operator|->
name|N
operator|*
name|uint64_t
argument_list|(
name|D
argument_list|)
operator|+
name|Sum
operator|/
literal|2
operator|)
operator|/
name|Sum
expr_stmt|;
end_for

begin_endif
unit|}  }
endif|#
directive|endif
end_endif

end_unit

