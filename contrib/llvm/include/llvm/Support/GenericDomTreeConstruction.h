begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GenericDomTreeConstruction.h - Dominator Calculation ------*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Generic dominator tree construction - This file provides routines to
end_comment

begin_comment
comment|/// construct immediate dominator information for a flow-graph based on the
end_comment

begin_comment
comment|/// algorithm described in this document:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   A Fast Algorithm for Finding Dominators in a Flowgraph
end_comment

begin_comment
comment|///   T. Lengauer& R. Tarjan, ACM TOPLAS July 1979, pgs 121-141.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This implements the O(n*log(n)) versions of EVAL and LINK, because it turns
end_comment

begin_comment
comment|/// out that the theoretically slower O(n*log(n)) implementation is actually
end_comment

begin_comment
comment|/// faster than the almost-linear O(n*alpha(n)) version, even for large CFGs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GENERIC_DOM_TREE_CONSTRUCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GENERIC_DOM_TREE_CONSTRUCTION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/GenericDomTree.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|GraphT
operator|>
name|unsigned
name|DFSPass
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType* V
argument_list|,
argument|unsigned N
argument_list|)
block|{
comment|// This is more understandable as a recursive algorithm, but we can't use the
comment|// recursive algorithm due to stack depth issues.  Keep it here for
comment|// documentation purposes.
if|#
directive|if
literal|0
block|InfoRec&VInfo = DT.Info[DT.Roots[i]];   VInfo.DFSNum = VInfo.Semi = ++N;   VInfo.Label = V;    Vertex.push_back(V);
comment|// Vertex[n] = V;
block|for (succ_iterator SI = succ_begin(V), E = succ_end(V); SI != E; ++SI) {     InfoRec&SuccVInfo = DT.Info[*SI];     if (SuccVInfo.Semi == 0) {       SuccVInfo.Parent = V;       N = DTDFSPass(DT, *SI, N);     }   }
else|#
directive|else
name|bool
name|IsChildOfArtificialExit
operator|=
operator|(
name|N
operator|!=
literal|0
operator|)
block|;
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
block|,
name|typename
name|GraphT
operator|::
name|ChildIteratorType
operator|>
block|,
literal|32
operator|>
name|Worklist
block|;
name|Worklist
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|V
argument_list|,
name|GraphT
operator|::
name|child_begin
argument_list|(
name|V
argument_list|)
argument_list|)
argument_list|)
block|;
while|while
condition|(
operator|!
name|Worklist
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|BB
operator|=
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|first
expr_stmt|;
name|typename
name|GraphT
operator|::
name|ChildIteratorType
name|NextSucc
operator|=
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|BB
index|]
expr_stmt|;
comment|// First time we visited this BB?
if|if
condition|(
name|NextSucc
operator|==
name|GraphT
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
condition|)
block|{
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
if|if
condition|(
name|IsChildOfArtificialExit
condition|)
name|BBInfo
operator|.
name|Parent
operator|=
literal|1
expr_stmt|;
name|IsChildOfArtificialExit
operator|=
name|false
expr_stmt|;
block|}
comment|// store the DFS number of the current BB - the reference to BBInfo might
comment|// get invalidated when processing the successors.
name|unsigned
name|BBDFSNum
init|=
name|BBInfo
operator|.
name|DFSNum
decl_stmt|;
comment|// If we are done with this block, remove it from the worklist.
if|if
condition|(
name|NextSucc
operator|==
name|GraphT
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
condition|)
block|{
name|Worklist
operator|.
name|pop_back
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Increment the successor number for the next time we get to it.
operator|++
name|Worklist
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
comment|// Visit the successor next, if it isn't already visited.
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Succ
operator|=
operator|*
name|NextSucc
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|SuccVInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|Succ
index|]
expr_stmt|;
if|if
condition|(
name|SuccVInfo
operator|.
name|Semi
operator|==
literal|0
condition|)
block|{
name|SuccVInfo
operator|.
name|Parent
operator|=
name|BBDFSNum
expr_stmt|;
name|Worklist
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Succ
argument_list|,
name|GraphT
operator|::
name|child_begin
argument_list|(
name|Succ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|N
return|;
block|}
name|template
operator|<
name|class
name|GraphT
operator|>
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Eval
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType *VIn
argument_list|,
argument|unsigned LastLinked
argument_list|)
block|{
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VInInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|VIn
index|]
block|;
if|if
condition|(
name|VInInfo
operator|.
name|DFSNum
operator|<
name|LastLinked
condition|)
return|return
name|VIn
return|;
name|SmallVector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|,
literal|32
operator|>
name|Work
expr_stmt|;
name|SmallPtrSet
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|,
literal|32
operator|>
name|Visited
expr_stmt|;
if|if
condition|(
name|VInInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
name|Work
operator|.
name|push_back
argument_list|(
name|VIn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Work
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|V
operator|=
name|Work
operator|.
name|back
argument_list|()
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|V
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VAncestor
operator|=
name|DT
operator|.
name|Vertex
index|[
name|VInfo
operator|.
name|Parent
index|]
expr_stmt|;
comment|// Process Ancestor first
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|VAncestor
argument_list|)
operator|&&
name|VInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
block|{
name|Work
operator|.
name|push_back
argument_list|(
name|VAncestor
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Work
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Update VInfo based on Ancestor info
if|if
condition|(
name|VInfo
operator|.
name|Parent
operator|<
name|LastLinked
condition|)
continue|continue;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|VAInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|VAncestor
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VAncestorLabel
operator|=
name|VAInfo
operator|.
name|Label
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|VLabel
operator|=
name|VInfo
operator|.
name|Label
expr_stmt|;
if|if
condition|(
name|DT
operator|.
name|Info
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|<
name|DT
operator|.
name|Info
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
name|VInfo
operator|.
name|Label
operator|=
name|VAncestorLabel
expr_stmt|;
name|VInfo
operator|.
name|Parent
operator|=
name|VAInfo
operator|.
name|Parent
expr_stmt|;
block|}
return|return
name|VInInfo
operator|.
name|Label
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|NodeT
operator|>
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBase<typename GraphTraits<NodeT>::NodeType>& DT
argument_list|,
argument|FuncT& F
argument_list|)
block|{
typedef|typedef
name|GraphTraits
operator|<
name|NodeT
operator|>
name|GraphT
expr_stmt|;
name|unsigned
name|N
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|MultipleRoots
init|=
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|MultipleRoots
condition|)
block|{
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|BBInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|nullptr
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|N
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|nullptr
expr_stmt|;
name|DT
operator|.
name|Vertex
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
comment|// Vertex[n] = V;
block|}
end_if

begin_comment
comment|// Step #1: Number blocks in depth-first order and initialize variables used
end_comment

begin_comment
comment|// in later stages of the algorithm.
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|N
operator|=
name|DFSPass
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|DT
operator|.
name|Roots
index|[
name|i
index|]
operator|,
name|N
operator|)
expr_stmt|;
end_for

begin_comment
comment|// it might be that some blocks did not get a DFS number (e.g., blocks of
end_comment

begin_comment
comment|// infinite loops). In these cases an artificial exit node is required.
end_comment

begin_expr_stmt
name|MultipleRoots
operator||=
operator|(
name|DT
operator|.
name|isPostDominator
argument_list|()
operator|&&
name|N
operator|!=
name|GraphTraits
operator|<
name|FuncT
operator|*
operator|>
operator|::
name|size
argument_list|(
operator|&
name|F
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// When naively implemented, the Lengauer-Tarjan algorithm requires a separate
end_comment

begin_comment
comment|// bucket for each vertex. However, this is unnecessary, because each vertex
end_comment

begin_comment
comment|// is only placed into a single bucket (that of its semidominator), and each
end_comment

begin_comment
comment|// vertex's bucket is processed before it is added to any bucket itself.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Instead of using a bucket per vertex, we use a single array Buckets that
end_comment

begin_comment
comment|// has two purposes. Before the vertex V with preorder number i is processed,
end_comment

begin_comment
comment|// Buckets[i] stores the index of the first element in V's bucket. After V's
end_comment

begin_comment
comment|// bucket is processed, Buckets[i] stores the index of the next element in the
end_comment

begin_comment
comment|// bucket containing V, if any.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|unsigned
operator|,
literal|32
operator|>
name|Buckets
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Buckets
operator|.
name|resize
argument_list|(
name|N
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
name|Buckets
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
end_for

begin_for
for|for
control|(
name|unsigned
name|i
init|=
name|N
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|typename
name|DominatorTreeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|::
name|InfoRec
operator|&
name|WInfo
operator|=
name|DT
operator|.
name|Info
index|[
name|W
index|]
expr_stmt|;
comment|// Step #2: Implicitly define the immediate dominator of vertices
for|for
control|(
name|unsigned
name|j
init|=
name|i
init|;
name|Buckets
index|[
name|j
index|]
operator|!=
name|i
condition|;
name|j
operator|=
name|Buckets
index|[
name|j
index|]
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|V
operator|=
name|DT
operator|.
name|Vertex
index|[
name|Buckets
index|[
name|j
index|]
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|U
operator|=
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
operator|,
name|V
operator|,
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|DT
operator|.
name|IDoms
index|[
name|V
index|]
operator|=
name|DT
operator|.
name|Info
index|[
name|U
index|]
operator|.
name|Semi
operator|<
name|i
condition|?
name|U
else|:
name|W
expr_stmt|;
block|}
comment|// Step #3: Calculate the semidominators of all vertices
comment|// initialize the semi dominator to point to the parent node
name|WInfo
operator|.
name|Semi
operator|=
name|WInfo
operator|.
name|Parent
expr_stmt|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|>
expr|>
name|InvTraits
expr_stmt|;
for|for
control|(
name|typename
name|InvTraits
operator|::
name|ChildIteratorType
name|CI
operator|=
name|InvTraits
operator|::
name|child_begin
argument_list|(
name|W
argument_list|)
operator|,
name|E
operator|=
name|InvTraits
operator|::
name|child_end
argument_list|(
name|W
argument_list|)
init|;
name|CI
operator|!=
name|E
condition|;
operator|++
name|CI
control|)
block|{
name|typename
name|InvTraits
operator|::
name|NodeType
operator|*
name|N
operator|=
operator|*
name|CI
expr_stmt|;
if|if
condition|(
name|DT
operator|.
name|Info
operator|.
name|count
argument_list|(
name|N
argument_list|)
condition|)
block|{
comment|// Only if this predecessor is reachable!
name|unsigned
name|SemiU
init|=
name|DT
operator|.
name|Info
index|[
name|Eval
operator|<
name|GraphT
operator|>
operator|(
name|DT
expr|,
name|N
expr|,
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|Semi
decl_stmt|;
if|if
condition|(
name|SemiU
operator|<
name|WInfo
operator|.
name|Semi
condition|)
name|WInfo
operator|.
name|Semi
operator|=
name|SemiU
expr_stmt|;
block|}
block|}
comment|// If V is a non-root vertex and sdom(V) = parent(V), then idom(V) is
comment|// necessarily parent(V). In this case, set idom(V) here and avoid placing
comment|// V into a bucket.
if|if
condition|(
name|WInfo
operator|.
name|Semi
operator|==
name|WInfo
operator|.
name|Parent
condition|)
block|{
name|DT
operator|.
name|IDoms
index|[
name|W
index|]
operator|=
name|DT
operator|.
name|Vertex
index|[
name|WInfo
operator|.
name|Parent
index|]
expr_stmt|;
block|}
else|else
block|{
name|Buckets
index|[
name|i
index|]
operator|=
name|Buckets
index|[
name|WInfo
operator|.
name|Semi
index|]
expr_stmt|;
name|Buckets
index|[
name|WInfo
operator|.
name|Semi
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|N
operator|>=
literal|1
condition|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Root
operator|=
name|DT
operator|.
name|Vertex
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|Buckets
index|[
name|j
index|]
operator|!=
literal|1
condition|;
name|j
operator|=
name|Buckets
index|[
name|j
index|]
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|V
operator|=
name|DT
operator|.
name|Vertex
index|[
name|Buckets
index|[
name|j
index|]
index|]
expr_stmt|;
name|DT
operator|.
name|IDoms
index|[
name|V
index|]
operator|=
name|Root
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// Step #4: Explicitly define the immediate dominator of each vertex
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|&
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|W
index|]
expr_stmt|;
if|if
condition|(
name|WIDom
operator|!=
name|DT
operator|.
name|Vertex
index|[
name|DT
operator|.
name|Info
index|[
name|W
index|]
operator|.
name|Semi
index|]
condition|)
name|WIDom
operator|=
name|DT
operator|.
name|IDoms
index|[
name|WIDom
index|]
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|empty
argument_list|()
condition|)
return|return;
end_if

begin_comment
comment|// Add a node for the root.  This node might be the actual root, if there is
end_comment

begin_comment
comment|// one exit block, or it may be the virtual exit (denoted by (BasicBlock *)0)
end_comment

begin_comment
comment|// which postdominates all real exits if there are multiple exit blocks, or
end_comment

begin_comment
comment|// an infinite loop.
end_comment

begin_expr_stmt
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Root
operator|=
operator|!
name|MultipleRoots
condition|?
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
else|:
name|nullptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|DomTreeNodes
index|[
name|Root
index|]
operator|=
name|DT
operator|.
name|RootNode
operator|=
name|new
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|(
name|Root
operator|,
name|nullptr
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Loop over all of the reachable blocks in the function...
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|N
condition|;
operator|++
name|i
control|)
block|{
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|W
operator|=
name|DT
operator|.
name|Vertex
index|[
name|i
index|]
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|BBNode
operator|=
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
expr_stmt|;
if|if
condition|(
name|BBNode
condition|)
continue|continue;
comment|// Haven't calculated this node yet?
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|ImmDom
operator|=
name|DT
operator|.
name|getIDom
argument_list|(
name|W
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ImmDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
expr_stmt|;
comment|// Get or calculate the node for the immediate dominator
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|IDomNode
operator|=
name|DT
operator|.
name|getNodeForBlock
argument_list|(
name|ImmDom
argument_list|)
expr_stmt|;
comment|// Add a new tree node for this BasicBlock, and link it as a child of
comment|// IDomNode
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|*
name|C
operator|=
name|new
name|DomTreeNodeBase
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|>
operator|(
name|W
operator|,
name|IDomNode
operator|)
expr_stmt|;
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Free temporary memory used to construct idom's
end_comment

begin_expr_stmt
name|DT
operator|.
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|Info
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|>
operator|(
operator|)
operator|.
name|swap
argument_list|(
name|DT
operator|.
name|Vertex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DT
operator|.
name|updateDFSNumbers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
unit|}  }
endif|#
directive|endif
end_endif

end_unit

