begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- GenericDomTreeConstruction.h - Dominator Calculation ------*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Generic dominator tree construction - This file provides routines to
end_comment

begin_comment
comment|/// construct immediate dominator information for a flow-graph based on the
end_comment

begin_comment
comment|/// Semi-NCA algorithm described in this dissertation:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   Linear-Time Algorithms for Dominators and Related Problems
end_comment

begin_comment
comment|///   Loukas Georgiadis, Princeton University, November 2005, pp. 21-23:
end_comment

begin_comment
comment|///   ftp://ftp.cs.princeton.edu/reports/2005/737.pdf
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This implements the O(n*log(n)) versions of EVAL and LINK, because it turns
end_comment

begin_comment
comment|/// out that the theoretically slower O(n*log(n)) implementation is actually
end_comment

begin_comment
comment|/// faster than the almost-linear O(n*alpha(n)) version, even for large CFGs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The file uses the Depth Based Search algorithm to perform incremental
end_comment

begin_comment
comment|/// upates (insertion and deletions). The implemented algorithm is based on this
end_comment

begin_comment
comment|/// publication:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   An Experimental Study of Dynamic Dominators
end_comment

begin_comment
comment|///   Loukas Georgiadis, et al., April 12 2016, pp. 5-7, 9-10:
end_comment

begin_comment
comment|///   https://arxiv.org/pdf/1604.02711.pdf
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GENERICDOMTREECONSTRUCTION_H
end_define

begin_include
include|#
directive|include
file|<queue>
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/GenericDomTree.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_TYPE
value|"dom-tree-builder"
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|DomTreeBuilder
block|{
name|template
operator|<
name|typename
name|NodePtr
operator|,
name|bool
name|Inverse
operator|>
expr|struct
name|ChildrenGetter
block|{
specifier|static
name|auto
name|Get
argument_list|(
argument|NodePtr N
argument_list|)
operator|->
name|decltype
argument_list|(
argument|reverse(children<NodePtr>(N))
argument_list|)
block|{
return|return
name|reverse
argument_list|(
name|children
operator|<
name|NodePtr
operator|>
operator|(
name|N
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|NodePtr
operator|>
expr|struct
name|ChildrenGetter
operator|<
name|NodePtr
block|,
name|true
operator|>
block|{
specifier|static
name|auto
name|Get
argument_list|(
argument|NodePtr N
argument_list|)
operator|->
name|decltype
argument_list|(
argument|inverse_children<NodePtr>(N)
argument_list|)
block|{
return|return
name|inverse_children
operator|<
name|NodePtr
operator|>
operator|(
name|N
operator|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|DomTreeT
operator|>
expr|struct
name|SemiNCAInfo
block|{
name|using
name|NodePtr
operator|=
name|typename
name|DomTreeT
operator|::
name|NodePtr
block|;
name|using
name|NodeT
operator|=
name|typename
name|DomTreeT
operator|::
name|NodeType
block|;
name|using
name|TreeNodePtr
operator|=
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
block|;
specifier|static
name|constexpr
name|bool
name|IsPostDom
operator|=
name|DomTreeT
operator|::
name|IsPostDominator
block|;
comment|// Information record used by Semi-NCA during tree construction.
block|struct
name|InfoRec
block|{
name|unsigned
name|DFSNum
operator|=
literal|0
block|;
name|unsigned
name|Parent
operator|=
literal|0
block|;
name|unsigned
name|Semi
operator|=
literal|0
block|;
name|NodePtr
name|Label
operator|=
name|nullptr
block|;
name|NodePtr
name|IDom
operator|=
name|nullptr
block|;
name|SmallVector
operator|<
name|NodePtr
block|,
literal|2
operator|>
name|ReverseChildren
block|;   }
block|;
comment|// Number to node mapping is 1-based. Initialize the mapping to start with
comment|// a dummy element.
name|std
operator|::
name|vector
operator|<
name|NodePtr
operator|>
name|NumToNode
operator|=
block|{
name|nullptr
block|}
block|;
name|DenseMap
operator|<
name|NodePtr
block|,
name|InfoRec
operator|>
name|NodeToInfo
block|;
name|void
name|clear
argument_list|()
block|{
name|NumToNode
operator|=
block|{
name|nullptr
block|}
block|;
comment|// Restore to initial state with a dummy start node.
name|NodeToInfo
operator|.
name|clear
argument_list|()
block|;   }
name|NodePtr
name|getIDom
argument_list|(
argument|NodePtr BB
argument_list|)
specifier|const
block|{
name|auto
name|InfoIt
operator|=
name|NodeToInfo
operator|.
name|find
argument_list|(
name|BB
argument_list|)
block|;
if|if
condition|(
name|InfoIt
operator|==
name|NodeToInfo
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|InfoIt
operator|->
name|second
operator|.
name|IDom
return|;
block|}
name|TreeNodePtr
name|getNodeForBlock
argument_list|(
argument|NodePtr BB
argument_list|,
argument|DomTreeT&DT
argument_list|)
block|{
if|if
condition|(
name|TreeNodePtr
name|Node
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|Node
return|;
comment|// Haven't calculated this node yet?  Get or calculate the node for the
comment|// immediate dominator.
name|NodePtr
name|IDom
operator|=
name|getIDom
argument_list|(
name|BB
argument_list|)
block|;
name|assert
argument_list|(
name|IDom
operator|||
name|DT
operator|.
name|DomTreeNodes
index|[
name|nullptr
index|]
argument_list|)
block|;
name|TreeNodePtr
name|IDomNode
operator|=
name|getNodeForBlock
argument_list|(
name|IDom
argument_list|,
name|DT
argument_list|)
block|;
comment|// Add a new tree node for this NodeT, and link it as a child of
comment|// IDomNode
return|return
operator|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|BB
operator|,
name|IDomNode
operator|)
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|bool
name|AlwaysDescend
argument_list|(
argument|NodePtr
argument_list|,
argument|NodePtr
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|struct
name|BlockNamePrinter
block|{
name|NodePtr
name|N
block|;
name|BlockNamePrinter
argument_list|(
argument|NodePtr Block
argument_list|)
operator|:
name|N
argument_list|(
argument|Block
argument_list|)
block|{}
name|BlockNamePrinter
argument_list|(
argument|TreeNodePtr TN
argument_list|)
operator|:
name|N
argument_list|(
argument|TN ? TN->getBlock() : nullptr
argument_list|)
block|{}
name|friend
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
specifier|const
name|BlockNamePrinter
operator|&
name|BP
operator|)
block|{
if|if
condition|(
operator|!
name|BP
operator|.
name|N
condition|)
name|O
operator|<<
literal|"nullptr"
expr_stmt|;
else|else
name|BP
operator|.
name|N
operator|->
name|printAsOperand
argument_list|(
name|O
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|O
return|;
block|}
expr|}
block|;
comment|// Custom DFS implementation which can skip nodes based on a provided
comment|// predicate. It also collects ReverseChildren so that we don't have to spend
comment|// time getting predecessors in SemiNCA.
name|template
operator|<
name|bool
name|Inverse
block|,
name|typename
name|DescendCondition
operator|>
name|unsigned
name|runDFS
argument_list|(
argument|NodePtr V
argument_list|,
argument|unsigned LastNum
argument_list|,
argument|DescendCondition Condition
argument_list|,
argument|unsigned AttachToNum
argument_list|)
block|{
name|assert
argument_list|(
name|V
argument_list|)
block|;
name|SmallVector
operator|<
name|NodePtr
block|,
literal|64
operator|>
name|WorkList
operator|=
block|{
name|V
block|}
block|;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|V
argument_list|)
operator|!=
literal|0
condition|)
name|NodeToInfo
index|[
name|V
index|]
operator|.
name|Parent
operator|=
name|AttachToNum
expr_stmt|;
while|while
condition|(
operator|!
name|WorkList
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|NodePtr
name|BB
init|=
name|WorkList
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
name|auto
operator|&
name|BBInfo
operator|=
name|NodeToInfo
index|[
name|BB
index|]
expr_stmt|;
comment|// Visited nodes always have positive DFS numbers.
if|if
condition|(
name|BBInfo
operator|.
name|DFSNum
operator|!=
literal|0
condition|)
continue|continue;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|LastNum
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|BB
expr_stmt|;
name|NumToNode
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|NodePtr
name|Succ
range|:
name|ChildrenGetter
operator|<
name|NodePtr
init|,
name|Inverse
decl|>::
name|Get
argument_list|(
name|BB
argument_list|)
control|)
block|{
specifier|const
specifier|auto
name|SIT
init|=
name|NodeToInfo
operator|.
name|find
argument_list|(
name|Succ
argument_list|)
decl_stmt|;
comment|// Don't visit nodes more than once but remember to collect
comment|// RerverseChildren.
if|if
condition|(
name|SIT
operator|!=
name|NodeToInfo
operator|.
name|end
argument_list|()
operator|&&
name|SIT
operator|->
name|second
operator|.
name|DFSNum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Succ
operator|!=
name|BB
condition|)
name|SIT
operator|->
name|second
operator|.
name|ReverseChildren
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|Condition
argument_list|(
name|BB
argument_list|,
name|Succ
argument_list|)
condition|)
continue|continue;
comment|// It's fine to add Succ to the map, because we know that it will be
comment|// visited later.
name|auto
operator|&
name|SuccInfo
operator|=
name|NodeToInfo
index|[
name|Succ
index|]
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|Succ
argument_list|)
expr_stmt|;
name|SuccInfo
operator|.
name|Parent
operator|=
name|LastNum
expr_stmt|;
name|SuccInfo
operator|.
name|ReverseChildren
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|LastNum
return|;
block|}
name|NodePtr
name|eval
parameter_list|(
name|NodePtr
name|VIn
parameter_list|,
name|unsigned
name|LastLinked
parameter_list|)
block|{
name|auto
operator|&
name|VInInfo
operator|=
name|NodeToInfo
index|[
name|VIn
index|]
expr_stmt|;
if|if
condition|(
name|VInInfo
operator|.
name|DFSNum
operator|<
name|LastLinked
condition|)
return|return
name|VIn
return|;
name|SmallVector
operator|<
name|NodePtr
operator|,
literal|32
operator|>
name|Work
expr_stmt|;
name|SmallPtrSet
operator|<
name|NodePtr
operator|,
literal|32
operator|>
name|Visited
expr_stmt|;
if|if
condition|(
name|VInInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
name|Work
operator|.
name|push_back
argument_list|(
name|VIn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Work
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodePtr
name|V
init|=
name|Work
operator|.
name|back
argument_list|()
decl_stmt|;
name|auto
operator|&
name|VInfo
operator|=
name|NodeToInfo
index|[
name|V
index|]
expr_stmt|;
name|NodePtr
name|VAncestor
init|=
name|NumToNode
index|[
name|VInfo
operator|.
name|Parent
index|]
decl_stmt|;
comment|// Process Ancestor first
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|VAncestor
argument_list|)
operator|.
name|second
operator|&&
name|VInfo
operator|.
name|Parent
operator|>=
name|LastLinked
condition|)
block|{
name|Work
operator|.
name|push_back
argument_list|(
name|VAncestor
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Work
operator|.
name|pop_back
argument_list|()
expr_stmt|;
comment|// Update VInfo based on Ancestor info
if|if
condition|(
name|VInfo
operator|.
name|Parent
operator|<
name|LastLinked
condition|)
continue|continue;
name|auto
operator|&
name|VAInfo
operator|=
name|NodeToInfo
index|[
name|VAncestor
index|]
expr_stmt|;
name|NodePtr
name|VAncestorLabel
init|=
name|VAInfo
operator|.
name|Label
decl_stmt|;
name|NodePtr
name|VLabel
init|=
name|VInfo
operator|.
name|Label
decl_stmt|;
if|if
condition|(
name|NodeToInfo
index|[
name|VAncestorLabel
index|]
operator|.
name|Semi
operator|<
name|NodeToInfo
index|[
name|VLabel
index|]
operator|.
name|Semi
condition|)
name|VInfo
operator|.
name|Label
operator|=
name|VAncestorLabel
expr_stmt|;
name|VInfo
operator|.
name|Parent
operator|=
name|VAInfo
operator|.
name|Parent
expr_stmt|;
block|}
return|return
name|VInInfo
operator|.
name|Label
return|;
block|}
comment|// This function requires DFS to be run before calling it.
name|void
name|runSemiNCA
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|unsigned
name|MinLevel
init|=
literal|0
parameter_list|)
block|{
specifier|const
name|unsigned
name|NextDFSNum
argument_list|(
name|NumToNode
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Initialize IDoms to spanning tree parents.
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|NextDFSNum
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NodePtr
name|V
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|VInfo
operator|=
name|NodeToInfo
index|[
name|V
index|]
expr_stmt|;
name|VInfo
operator|.
name|IDom
operator|=
name|NumToNode
index|[
name|VInfo
operator|.
name|Parent
index|]
expr_stmt|;
block|}
comment|// Step #1: Calculate the semidominators of all vertices.
for|for
control|(
name|unsigned
name|i
init|=
name|NextDFSNum
operator|-
literal|1
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
block|{
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|WInfo
operator|=
name|NodeToInfo
index|[
name|W
index|]
expr_stmt|;
comment|// Initialize the semi dominator to point to the parent node.
name|WInfo
operator|.
name|Semi
operator|=
name|WInfo
operator|.
name|Parent
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|N
range|:
name|WInfo
operator|.
name|ReverseChildren
control|)
block|{
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|N
argument_list|)
operator|==
literal|0
condition|)
comment|// Skip unreachable predecessors.
continue|continue;
specifier|const
name|TreeNodePtr
name|TN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|N
argument_list|)
decl_stmt|;
comment|// Skip predecessors whose level is above the subtree we are processing.
if|if
condition|(
name|TN
operator|&&
name|TN
operator|->
name|getLevel
argument_list|()
operator|<
name|MinLevel
condition|)
continue|continue;
name|unsigned
name|SemiU
init|=
name|NodeToInfo
index|[
name|eval
argument_list|(
name|N
argument_list|,
name|i
operator|+
literal|1
argument_list|)
index|]
operator|.
name|Semi
decl_stmt|;
if|if
condition|(
name|SemiU
operator|<
name|WInfo
operator|.
name|Semi
condition|)
name|WInfo
operator|.
name|Semi
operator|=
name|SemiU
expr_stmt|;
block|}
block|}
comment|// Step #2: Explicitly define the immediate dominator of each vertex.
comment|//          IDom[i] = NCA(SDom[i], SpanningTreeParent(i)).
comment|// Note that the parents were stored in IDoms and later got invalidated
comment|// during path compression in Eval.
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<
name|NextDFSNum
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|auto
operator|&
name|WInfo
operator|=
name|NodeToInfo
index|[
name|W
index|]
expr_stmt|;
specifier|const
name|unsigned
name|SDomNum
init|=
name|NodeToInfo
index|[
name|NumToNode
index|[
name|WInfo
operator|.
name|Semi
index|]
index|]
operator|.
name|DFSNum
decl_stmt|;
name|NodePtr
name|WIDomCandidate
init|=
name|WInfo
operator|.
name|IDom
decl_stmt|;
while|while
condition|(
name|NodeToInfo
index|[
name|WIDomCandidate
index|]
operator|.
name|DFSNum
operator|>
name|SDomNum
condition|)
name|WIDomCandidate
operator|=
name|NodeToInfo
index|[
name|WIDomCandidate
index|]
operator|.
name|IDom
expr_stmt|;
name|WInfo
operator|.
name|IDom
operator|=
name|WIDomCandidate
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|DescendCondition
operator|>
name|unsigned
name|doFullDFSWalk
argument_list|(
argument|const DomTreeT&DT
argument_list|,
argument|DescendCondition DC
argument_list|)
block|{
name|unsigned
name|Num
operator|=
literal|0
block|;
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|auto
operator|&
name|BBInfo
operator|=
name|NodeToInfo
index|[
name|nullptr
index|]
expr_stmt|;
name|BBInfo
operator|.
name|DFSNum
operator|=
name|BBInfo
operator|.
name|Semi
operator|=
operator|++
name|Num
expr_stmt|;
name|BBInfo
operator|.
name|Label
operator|=
name|nullptr
expr_stmt|;
name|NumToNode
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
comment|// NumToNode[n] = V;
block|}
if|if
condition|(
name|DT
operator|.
name|isPostDominator
argument_list|()
condition|)
block|{
for|for
control|(
name|auto
operator|*
name|Root
operator|:
name|DT
operator|.
name|Roots
control|)
name|Num
operator|=
name|runDFS
operator|<
name|true
operator|>
operator|(
name|Root
operator|,
name|Num
operator|,
name|DC
operator|,
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Num
operator|=
name|runDFS
operator|<
name|false
operator|>
operator|(
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
operator|,
name|Num
operator|,
name|DC
operator|,
name|Num
operator|)
expr_stmt|;
block|}
return|return
name|Num
return|;
block|}
name|void
name|calculateFromScratch
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|unsigned
name|NumBlocks
parameter_list|)
block|{
comment|// Step #0: Number blocks in depth-first order and initialize variables used
comment|// in later stages of the algorithm.
specifier|const
name|unsigned
name|LastDFSNum
init|=
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
decl_stmt|;
name|runSemiNCA
argument_list|(
name|DT
argument_list|)
expr_stmt|;
if|if
condition|(
name|DT
operator|.
name|Roots
operator|.
name|empty
argument_list|()
condition|)
return|return;
comment|// Add a node for the root.  This node might be the actual root, if there is
comment|// one exit block, or it may be the virtual exit (denoted by
comment|// (BasicBlock *)0) which postdominates all real exits if there are multiple
comment|// exit blocks, or an infinite loop.
comment|// It might be that some blocks did not get a DFS number (e.g., blocks of
comment|// infinite loops). In these cases an artificial exit node is required.
specifier|const
name|bool
name|MultipleRoots
init|=
name|DT
operator|.
name|Roots
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
operator|(
name|DT
operator|.
name|isPostDominator
argument_list|()
operator|&&
name|LastDFSNum
operator|!=
name|NumBlocks
operator|)
decl_stmt|;
name|NodePtr
name|Root
init|=
operator|!
name|MultipleRoots
condition|?
name|DT
operator|.
name|Roots
index|[
literal|0
index|]
else|:
name|nullptr
decl_stmt|;
name|DT
operator|.
name|RootNode
operator|=
operator|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|Root
index|]
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|Root
operator|,
name|nullptr
operator|)
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|attachNewSubtree
argument_list|(
name|DT
argument_list|,
name|DT
operator|.
name|RootNode
argument_list|)
expr_stmt|;
block|}
name|void
name|attachNewSubtree
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|AttachTo
parameter_list|)
block|{
comment|// Attach the first unreachable block to AttachTo.
name|NodeToInfo
index|[
name|NumToNode
index|[
literal|1
index|]
index|]
operator|.
name|IDom
operator|=
name|AttachTo
operator|->
name|getBlock
argument_list|()
expr_stmt|;
comment|// Loop over all of the discovered blocks in the function...
for|for
control|(
name|size_t
name|i
init|=
literal|1
init|,
name|e
init|=
name|NumToNode
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|NodePtr
name|W
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tdiscovered a new reachable node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|W
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Don't replace this with 'count', the insertion side effect is important
if|if
condition|(
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
condition|)
continue|continue;
comment|// Haven't calculated this node yet?
name|NodePtr
name|ImmDom
init|=
name|getIDom
argument_list|(
name|W
argument_list|)
decl_stmt|;
comment|// Get or calculate the node for the immediate dominator
name|TreeNodePtr
name|IDomNode
init|=
name|getNodeForBlock
argument_list|(
name|ImmDom
argument_list|,
name|DT
argument_list|)
decl_stmt|;
comment|// Add a new tree node for this BasicBlock, and link it as a child of
comment|// IDomNode
name|DT
operator|.
name|DomTreeNodes
index|[
name|W
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>>
operator|(
name|W
operator|,
name|IDomNode
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|reattachExistingSubtree
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|AttachTo
parameter_list|)
block|{
name|NodeToInfo
index|[
name|NumToNode
index|[
literal|1
index|]
index|]
operator|.
name|IDom
operator|=
name|AttachTo
operator|->
name|getBlock
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|1
init|,
name|e
init|=
name|NumToNode
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NodePtr
name|N
init|=
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|TreeNodePtr
name|TN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|N
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|TN
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|NewIDom
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|NodeToInfo
index|[
name|N
index|]
operator|.
name|IDom
argument_list|)
decl_stmt|;
name|TN
operator|->
name|setIDom
argument_list|(
name|NewIDom
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Helper struct used during edge insertions.
struct|struct
name|InsertionInfo
block|{
name|using
name|BucketElementTy
init|=
name|std
operator|::
name|pair
operator|<
name|unsigned
decl_stmt|,
name|TreeNodePtr
decl|>
decl_stmt|;
struct|struct
name|DecreasingLevel
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|BucketElementTy
operator|&
name|First
operator|,
specifier|const
name|BucketElementTy
operator|&
name|Second
operator|)
specifier|const
block|{
return|return
name|First
operator|.
name|first
operator|>
name|Second
operator|.
name|first
return|;
block|}
block|}
struct|;
name|std
operator|::
name|priority_queue
operator|<
name|BucketElementTy
operator|,
name|SmallVector
operator|<
name|BucketElementTy
operator|,
literal|8
operator|>
operator|,
name|DecreasingLevel
operator|>
name|Bucket
expr_stmt|;
comment|// Queue of tree nodes sorted by level in descending order.
name|SmallDenseSet
operator|<
name|TreeNodePtr
operator|,
literal|8
operator|>
name|Affected
expr_stmt|;
name|SmallDenseSet
operator|<
name|TreeNodePtr
operator|,
literal|8
operator|>
name|Visited
expr_stmt|;
name|SmallVector
operator|<
name|TreeNodePtr
operator|,
literal|8
operator|>
name|AffectedQueue
expr_stmt|;
name|SmallVector
operator|<
name|TreeNodePtr
operator|,
literal|8
operator|>
name|VisitedNotAffectedQueue
expr_stmt|;
block|}
struct|;
specifier|static
name|void
name|InsertEdge
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|NodePtr
name|From
parameter_list|,
specifier|const
name|NodePtr
name|To
parameter_list|)
block|{
name|assert
argument_list|(
name|From
operator|&&
name|To
operator|&&
literal|"Cannot connect nullptrs"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Inserting edge "
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|FromTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|From
argument_list|)
decl_stmt|;
comment|// Ignore edges from unreachable nodes.
if|if
condition|(
operator|!
name|FromTN
condition|)
return|return;
name|DT
operator|.
name|DFSInfoValid
operator|=
name|false
expr_stmt|;
specifier|const
name|TreeNodePtr
name|ToTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ToTN
condition|)
name|InsertUnreachable
argument_list|(
name|DT
argument_list|,
name|FromTN
argument_list|,
name|To
argument_list|)
expr_stmt|;
else|else
name|InsertReachable
argument_list|(
name|DT
argument_list|,
name|FromTN
argument_list|,
name|ToTN
argument_list|)
expr_stmt|;
block|}
comment|// Handles insertion to a node already in the dominator tree.
specifier|static
name|void
name|InsertReachable
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|From
parameter_list|,
specifier|const
name|TreeNodePtr
name|To
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tReachable "
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
specifier|const
name|NodePtr
name|NCDBlock
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|From
operator|->
name|getBlock
argument_list|()
argument_list|,
name|To
operator|->
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|NCDBlock
operator|||
name|DT
operator|.
name|isPostDominator
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|NCD
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|NCDBlock
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|NCD
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\t\tNCA == "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|ToIDom
init|=
name|To
operator|->
name|getIDom
argument_list|()
decl_stmt|;
comment|// Nothing affected -- NCA property holds.
comment|// (Based on the lemma 2.5 from the second paper.)
if|if
condition|(
name|NCD
operator|==
name|To
operator|||
name|NCD
operator|==
name|ToIDom
condition|)
return|return;
comment|// Identify and collect affected nodes.
name|InsertionInfo
name|II
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Marking "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|" as affected\n"
argument_list|)
expr_stmt|;
name|II
operator|.
name|Affected
operator|.
name|insert
argument_list|(
name|To
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|ToLevel
init|=
name|To
operator|->
name|getLevel
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Putting "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|" into a Bucket\n"
argument_list|)
expr_stmt|;
name|II
operator|.
name|Bucket
operator|.
name|push
argument_list|(
block|{
name|ToLevel
block|,
name|To
block|}
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|II
operator|.
name|Bucket
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|TreeNodePtr
name|CurrentNode
init|=
name|II
operator|.
name|Bucket
operator|.
name|top
argument_list|()
operator|.
name|second
decl_stmt|;
name|II
operator|.
name|Bucket
operator|.
name|pop
argument_list|()
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tAdding to Visited and AffectedQueue: "
operator|<<
name|BlockNamePrinter
argument_list|(
name|CurrentNode
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|II
operator|.
name|Visited
operator|.
name|insert
argument_list|(
name|CurrentNode
argument_list|)
expr_stmt|;
name|II
operator|.
name|AffectedQueue
operator|.
name|push_back
argument_list|(
name|CurrentNode
argument_list|)
expr_stmt|;
comment|// Discover and collect affected successors of the current node.
name|VisitInsertion
argument_list|(
name|DT
argument_list|,
name|CurrentNode
argument_list|,
name|CurrentNode
operator|->
name|getLevel
argument_list|()
argument_list|,
name|NCD
argument_list|,
name|II
argument_list|)
expr_stmt|;
block|}
comment|// Finish by updating immediate dominators and levels.
name|UpdateInsertion
argument_list|(
name|DT
argument_list|,
name|NCD
argument_list|,
name|II
argument_list|)
expr_stmt|;
block|}
comment|// Visits an affected node and collect its affected successors.
specifier|static
name|void
name|VisitInsertion
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|TN
parameter_list|,
specifier|const
name|unsigned
name|RootLevel
parameter_list|,
specifier|const
name|TreeNodePtr
name|NCD
parameter_list|,
name|InsertionInfo
modifier|&
name|II
parameter_list|)
block|{
specifier|const
name|unsigned
name|NCDLevel
init|=
name|NCD
operator|->
name|getLevel
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Visiting "
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|NodePtr
name|Succ
range|:
name|ChildrenGetter
operator|<
name|NodePtr
init|,
name|IsPostDom
decl|>::
name|Get
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|)
control|)
block|{
specifier|const
name|TreeNodePtr
name|SuccTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|Succ
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|SuccTN
operator|&&
literal|"Unreachable successor found at reachable insertion"
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|SuccLevel
init|=
name|SuccTN
operator|->
name|getLevel
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tSuccessor "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Succ
argument_list|)
operator|<<
literal|", level = "
operator|<<
name|SuccLevel
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Succ dominated by subtree From -- not affected.
comment|// (Based on the lemma 2.5 from the second paper.)
if|if
condition|(
name|SuccLevel
operator|>
name|RootLevel
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\t\tDominated by subtree From\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|II
operator|.
name|Visited
operator|.
name|count
argument_list|(
name|SuccTN
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\t\tMarking visited not affected "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Succ
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|II
operator|.
name|Visited
operator|.
name|insert
argument_list|(
name|SuccTN
argument_list|)
expr_stmt|;
name|II
operator|.
name|VisitedNotAffectedQueue
operator|.
name|push_back
argument_list|(
name|SuccTN
argument_list|)
expr_stmt|;
name|VisitInsertion
argument_list|(
name|DT
argument_list|,
name|SuccTN
argument_list|,
name|RootLevel
argument_list|,
name|NCD
argument_list|,
name|II
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|SuccLevel
operator|>
name|NCDLevel
operator|+
literal|1
operator|)
operator|&&
name|II
operator|.
name|Affected
operator|.
name|count
argument_list|(
name|SuccTN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\t\tMarking affected and adding "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Succ
argument_list|)
operator|<<
literal|" to a Bucket\n"
argument_list|)
expr_stmt|;
name|II
operator|.
name|Affected
operator|.
name|insert
argument_list|(
name|SuccTN
argument_list|)
expr_stmt|;
name|II
operator|.
name|Bucket
operator|.
name|push
argument_list|(
block|{
name|SuccLevel
block|,
name|SuccTN
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Updates immediate dominators and levels after insertion.
specifier|static
name|void
name|UpdateInsertion
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|NCD
parameter_list|,
name|InsertionInfo
modifier|&
name|II
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Updating NCD = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|TN
range|:
name|II
operator|.
name|AffectedQueue
control|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tIDom("
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|") = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|TN
operator|->
name|setIDom
argument_list|(
name|NCD
argument_list|)
expr_stmt|;
block|}
name|UpdateLevelsAfterInsertion
argument_list|(
name|II
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|UpdateLevelsAfterInsertion
parameter_list|(
name|InsertionInfo
modifier|&
name|II
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Updating levels for visited but not affected nodes\n"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|TN
range|:
name|II
operator|.
name|VisitedNotAffectedQueue
control|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tlevel("
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|") = ("
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
operator|->
name|getIDom
argument_list|()
argument_list|)
operator|<<
literal|") "
operator|<<
name|TN
operator|->
name|getIDom
argument_list|()
operator|->
name|getLevel
argument_list|()
operator|<<
literal|" + 1\n"
argument_list|)
expr_stmt|;
name|TN
operator|->
name|UpdateLevel
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Handles insertion to previously unreachable nodes.
specifier|static
name|void
name|InsertUnreachable
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|From
parameter_list|,
specifier|const
name|NodePtr
name|To
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Inserting "
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
argument_list|)
operator|<<
literal|" -> (unreachable) "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Collect discovered edges to already reachable nodes.
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|NodePtr
operator|,
name|TreeNodePtr
operator|>
operator|,
literal|8
operator|>
name|DiscoveredEdgesToReachable
expr_stmt|;
comment|// Discover and connect nodes that became reachable with the insertion.
name|ComputeUnreachableDominators
argument_list|(
name|DT
argument_list|,
name|To
argument_list|,
name|From
argument_list|,
name|DiscoveredEdgesToReachable
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Inserted "
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
argument_list|)
operator|<<
literal|" -> (prev unreachable) "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DT
operator|.
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Used the discovered edges and inset discovered connecting (incoming)
comment|// edges.
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Edge
range|:
name|DiscoveredEdgesToReachable
control|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tInserting discovered connecting edge "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Edge
operator|.
name|first
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Edge
operator|.
name|second
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|InsertReachable
argument_list|(
name|DT
argument_list|,
name|DT
operator|.
name|getNode
argument_list|(
name|Edge
operator|.
name|first
argument_list|)
argument_list|,
name|Edge
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Connects nodes that become reachable with an insertion.
specifier|static
name|void
name|ComputeUnreachableDominators
argument_list|(
name|DomTreeT
operator|&
name|DT
argument_list|,
specifier|const
name|NodePtr
name|Root
argument_list|,
specifier|const
name|TreeNodePtr
name|Incoming
argument_list|,
name|SmallVectorImpl
operator|<
name|std
operator|::
name|pair
operator|<
name|NodePtr
argument_list|,
name|TreeNodePtr
operator|>>
operator|&
name|DiscoveredConnectingEdges
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|DT
operator|.
name|getNode
argument_list|(
name|Root
argument_list|)
operator|&&
literal|"Root must not be reachable"
argument_list|)
expr_stmt|;
comment|// Visit only previously unreachable nodes.
name|auto
name|UnreachableDescender
init|=
index|[
operator|&
name|DT
operator|,
operator|&
name|DiscoveredConnectingEdges
index|]
operator|(
name|NodePtr
name|From
expr|,
name|NodePtr
name|To
operator|)
block|{
specifier|const
name|TreeNodePtr
name|ToTN
operator|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
block|;
if|if
condition|(
operator|!
name|ToTN
condition|)
return|return
name|true
return|;
name|DiscoveredConnectingEdges
operator|.
name|push_back
argument_list|(
block|{
name|From
block|,
name|ToTN
block|}
argument_list|)
decl_stmt|;
return|return
name|false
return|;
block|}
empty_stmt|;
name|SemiNCAInfo
name|SNCA
decl_stmt|;
name|SNCA
operator|.
name|runDFS
operator|<
name|IsPostDom
operator|>
operator|(
name|Root
operator|,
literal|0
operator|,
name|UnreachableDescender
operator|,
literal|0
operator|)
expr_stmt|;
name|SNCA
operator|.
name|runSemiNCA
argument_list|(
name|DT
argument_list|)
expr_stmt|;
name|SNCA
operator|.
name|attachNewSubtree
argument_list|(
name|DT
argument_list|,
name|Incoming
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"After adding unreachable nodes\n"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DT
operator|.
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Checks if the tree contains all reachable nodes in the input graph.
name|bool
name|verifyReachability
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
comment|// Virtual root has a corresponding virtual CFG node.
if|if
condition|(
name|DT
operator|.
name|isVirtualRoot
argument_list|(
name|TN
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|BB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"DomTree node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" not found by DFS walk!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
for|for
control|(
specifier|const
name|NodePtr
name|N
range|:
name|NumToNode
control|)
block|{
if|if
condition|(
name|N
operator|&&
operator|!
name|DT
operator|.
name|getNode
argument_list|(
name|N
argument_list|)
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"CFG node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|N
argument_list|)
operator|<<
literal|" not found in the DomTree!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
specifier|static
name|void
name|DeleteEdge
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|NodePtr
name|From
parameter_list|,
specifier|const
name|NodePtr
name|To
parameter_list|)
block|{
name|assert
argument_list|(
name|From
operator|&&
name|To
operator|&&
literal|"Cannot disconnect nullptrs"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Deleting edge "
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Ensure that the edge was in fact deleted from the CFG before informing
comment|// the DomTree about it.
comment|// The check is O(N), so run it only in debug configuration.
name|auto
name|IsSuccessor
init|=
index|[]
operator|(
specifier|const
name|NodePtr
name|SuccCandidate
expr|,
specifier|const
name|NodePtr
name|Of
operator|)
block|{
name|auto
name|Successors
operator|=
name|ChildrenGetter
operator|<
name|NodePtr
block|,
name|IsPostDom
operator|>
operator|::
name|Get
argument_list|(
name|Of
argument_list|)
block|;
return|return
name|llvm
operator|::
name|find
argument_list|(
name|Successors
argument_list|,
name|SuccCandidate
argument_list|)
operator|!=
name|Successors
operator|.
name|end
argument_list|()
return|;
block|}
empty_stmt|;
operator|(
name|void
operator|)
name|IsSuccessor
expr_stmt|;
name|assert
argument_list|(
operator|!
name|IsSuccessor
argument_list|(
name|To
argument_list|,
name|From
argument_list|)
operator|&&
literal|"Deleted edge still exists in the CFG!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|TreeNodePtr
name|FromTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|From
argument_list|)
decl_stmt|;
comment|// Deletion in an unreachable subtree -- nothing to do.
if|if
condition|(
operator|!
name|FromTN
condition|)
return|return;
specifier|const
name|TreeNodePtr
name|ToTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ToTN
operator|&&
literal|"To already unreachable -- there is no edge to delete"
argument_list|)
expr_stmt|;
specifier|const
name|NodePtr
name|NCDBlock
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
decl_stmt|;
specifier|const
name|TreeNodePtr
name|NCD
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|NCDBlock
argument_list|)
decl_stmt|;
comment|// To dominates From -- nothing to do.
if|if
condition|(
name|ToTN
operator|==
name|NCD
condition|)
return|return;
specifier|const
name|TreeNodePtr
name|ToIDom
init|=
name|ToTN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tNCD "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|", ToIDom "
operator|<<
name|BlockNamePrinter
argument_list|(
name|ToIDom
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
comment|// To remains reachable after deletion.
comment|// (Based on the caption under Figure 4. from the second paper.)
if|if
condition|(
name|FromTN
operator|!=
name|ToIDom
operator|||
name|HasProperSupport
argument_list|(
name|DT
argument_list|,
name|ToTN
argument_list|)
condition|)
name|DeleteReachable
argument_list|(
name|DT
argument_list|,
name|FromTN
argument_list|,
name|ToTN
argument_list|)
expr_stmt|;
else|else
name|DeleteUnreachable
argument_list|(
name|DT
argument_list|,
name|ToTN
argument_list|)
expr_stmt|;
block|}
comment|// Handles deletions that leave destination nodes reachable.
specifier|static
name|void
name|DeleteReachable
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|FromTN
parameter_list|,
specifier|const
name|TreeNodePtr
name|ToTN
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Deleting reachable "
operator|<<
name|BlockNamePrinter
argument_list|(
name|FromTN
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|BlockNamePrinter
argument_list|(
name|ToTN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tRebuilding subtree\n"
argument_list|)
expr_stmt|;
comment|// Find the top of the subtree that needs to be rebuilt.
comment|// (Based on the lemma 2.6 from the second paper.)
specifier|const
name|NodePtr
name|ToIDom
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|FromTN
operator|->
name|getBlock
argument_list|()
argument_list|,
name|ToTN
operator|->
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ToIDom
operator|||
name|DT
operator|.
name|isPostDominator
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|ToIDomTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|ToIDom
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ToIDomTN
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|PrevIDomSubTree
init|=
name|ToIDomTN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
comment|// Top of the subtree to rebuild is the root node. Rebuild the tree from
comment|// scratch.
if|if
condition|(
operator|!
name|PrevIDomSubTree
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"The entire tree needs to be rebuilt\n"
argument_list|)
expr_stmt|;
name|DT
operator|.
name|recalculate
argument_list|(
operator|*
name|DT
operator|.
name|Parent
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Only visit nodes in the subtree starting at To.
specifier|const
name|unsigned
name|Level
init|=
name|ToIDomTN
operator|->
name|getLevel
argument_list|()
decl_stmt|;
name|auto
name|DescendBelow
init|=
index|[
name|Level
operator|,
operator|&
name|DT
index|]
operator|(
name|NodePtr
expr|,
name|NodePtr
name|To
operator|)
block|{
return|return
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
operator|->
name|getLevel
argument_list|()
operator|>
name|Level
return|;
block|}
empty_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tTop of subtree: "
operator|<<
name|BlockNamePrinter
argument_list|(
name|ToIDomTN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|SemiNCAInfo
name|SNCA
decl_stmt|;
name|SNCA
operator|.
name|runDFS
operator|<
name|IsPostDom
operator|>
operator|(
name|ToIDom
operator|,
literal|0
operator|,
name|DescendBelow
operator|,
literal|0
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tRunning Semi-NCA\n"
argument_list|)
expr_stmt|;
name|SNCA
operator|.
name|runSemiNCA
argument_list|(
name|DT
argument_list|,
name|Level
argument_list|)
expr_stmt|;
name|SNCA
operator|.
name|reattachExistingSubtree
argument_list|(
name|DT
argument_list|,
name|PrevIDomSubTree
argument_list|)
expr_stmt|;
block|}
comment|// Checks if a node has proper support, as defined on the page 3 and later
comment|// explained on the page 7 of the second paper.
specifier|static
name|bool
name|HasProperSupport
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|TN
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"IsReachableFromIDom "
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|NodePtr
name|Pred
range|:
name|ChildrenGetter
operator|<
name|NodePtr
init|, !
name|IsPostDom
decl|>::
name|Get
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|)
control|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tPred "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Pred
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DT
operator|.
name|getNode
argument_list|(
name|Pred
argument_list|)
condition|)
continue|continue;
specifier|const
name|NodePtr
name|Support
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|,
name|Pred
argument_list|)
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\tSupport "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Support
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Support
operator|!=
name|TN
operator|->
name|getBlock
argument_list|()
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"\t"
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|" is reachable from support "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Support
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|// Handle deletions that make destination node unreachable.
comment|// (Based on the lemma 2.7 from the second paper.)
specifier|static
name|void
name|DeleteUnreachable
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|ToTN
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Deleting unreachable subtree "
operator|<<
name|BlockNamePrinter
argument_list|(
name|ToTN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ToTN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ToTN
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|SmallVector
operator|<
name|NodePtr
operator|,
literal|16
operator|>
name|AffectedQueue
expr_stmt|;
specifier|const
name|unsigned
name|Level
init|=
name|ToTN
operator|->
name|getLevel
argument_list|()
decl_stmt|;
comment|// Traverse destination node's descendants with greater level in the tree
comment|// and collect visited nodes.
name|auto
name|DescendAndCollect
init|=
index|[
name|Level
operator|,
operator|&
name|AffectedQueue
operator|,
operator|&
name|DT
index|]
operator|(
name|NodePtr
expr|,
name|NodePtr
name|To
operator|)
block|{
specifier|const
name|TreeNodePtr
name|TN
operator|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
block|;
name|assert
argument_list|(
name|TN
argument_list|)
block|;
if|if
condition|(
name|TN
operator|->
name|getLevel
argument_list|()
operator|>
name|Level
condition|)
return|return
name|true
return|;
if|if
condition|(
name|llvm
operator|::
name|find
argument_list|(
name|AffectedQueue
argument_list|,
name|To
argument_list|)
operator|==
name|AffectedQueue
operator|.
name|end
argument_list|()
condition|)
name|AffectedQueue
operator|.
name|push_back
argument_list|(
name|To
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
empty_stmt|;
name|SemiNCAInfo
name|SNCA
decl_stmt|;
name|unsigned
name|LastDFSNum
init|=
name|SNCA
operator|.
name|runDFS
operator|<
name|IsPostDom
operator|>
operator|(
name|ToTN
operator|->
name|getBlock
argument_list|()
expr|,
literal|0
expr|,
name|DescendAndCollect
expr|,
literal|0
operator|)
decl_stmt|;
name|TreeNodePtr
name|MinNode
init|=
name|ToTN
decl_stmt|;
comment|// Identify the top of the subtree to rebuilt by finding the NCD of all
comment|// the affected nodes.
for|for
control|(
specifier|const
name|NodePtr
name|N
range|:
name|AffectedQueue
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|N
argument_list|)
decl_stmt|;
specifier|const
name|NodePtr
name|NCDBlock
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|,
name|ToTN
operator|->
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|NCDBlock
operator|||
name|DT
operator|.
name|isPostDominator
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|NCD
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|NCDBlock
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|NCD
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Processing affected node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|" with NCD = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|", MinNode ="
operator|<<
name|BlockNamePrinter
argument_list|(
name|MinNode
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCD
operator|!=
name|TN
operator|&&
name|NCD
operator|->
name|getLevel
argument_list|()
operator|<
name|MinNode
operator|->
name|getLevel
argument_list|()
condition|)
name|MinNode
operator|=
name|NCD
expr_stmt|;
block|}
comment|// Root reached, rebuild the whole tree from scratch.
if|if
condition|(
operator|!
name|MinNode
operator|->
name|getIDom
argument_list|()
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"The entire tree needs to be rebuilt\n"
argument_list|)
expr_stmt|;
name|DT
operator|.
name|recalculate
argument_list|(
operator|*
name|DT
operator|.
name|Parent
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Erase the unreachable subtree in reverse preorder to process all children
comment|// before deleting their parent.
for|for
control|(
name|unsigned
name|i
init|=
name|LastDFSNum
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|NodePtr
name|N
init|=
name|SNCA
operator|.
name|NumToNode
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|TreeNodePtr
name|TN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|N
argument_list|)
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Erasing node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|TN
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|EraseNode
argument_list|(
name|DT
argument_list|,
name|TN
argument_list|)
expr_stmt|;
block|}
comment|// The affected subtree start at the To node -- there's no extra work to do.
if|if
condition|(
name|MinNode
operator|==
name|ToTN
condition|)
return|return;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"DeleteUnreachable: running DFS with MinNode = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|MinNode
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|MinLevel
init|=
name|MinNode
operator|->
name|getLevel
argument_list|()
decl_stmt|;
specifier|const
name|TreeNodePtr
name|PrevIDom
init|=
name|MinNode
operator|->
name|getIDom
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|PrevIDom
argument_list|)
expr_stmt|;
name|SNCA
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Identify nodes that remain in the affected subtree.
name|auto
name|DescendBelow
init|=
index|[
name|MinLevel
operator|,
operator|&
name|DT
index|]
operator|(
name|NodePtr
expr|,
name|NodePtr
name|To
operator|)
block|{
specifier|const
name|TreeNodePtr
name|ToTN
operator|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
block|;
return|return
name|ToTN
operator|&&
name|ToTN
operator|->
name|getLevel
argument_list|()
operator|>
name|MinLevel
return|;
block|}
empty_stmt|;
name|SNCA
operator|.
name|runDFS
operator|<
name|IsPostDom
operator|>
operator|(
name|MinNode
operator|->
name|getBlock
argument_list|()
operator|,
literal|0
operator|,
name|DescendBelow
operator|,
literal|0
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Previous IDom(MinNode) = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|PrevIDom
argument_list|)
operator|<<
literal|"\nRunning Semi-NCA\n"
argument_list|)
expr_stmt|;
comment|// Rebuild the remaining part of affected subtree.
name|SNCA
operator|.
name|runSemiNCA
argument_list|(
name|DT
argument_list|,
name|MinLevel
argument_list|)
expr_stmt|;
name|SNCA
operator|.
name|reattachExistingSubtree
argument_list|(
name|DT
argument_list|,
name|PrevIDom
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Removes leaf tree nodes from the dominator tree.
end_comment

begin_function
specifier|static
name|void
name|EraseNode
parameter_list|(
name|DomTreeT
modifier|&
name|DT
parameter_list|,
specifier|const
name|TreeNodePtr
name|TN
parameter_list|)
block|{
name|assert
argument_list|(
name|TN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TN
operator|->
name|getNumChildren
argument_list|()
operator|==
literal|0
operator|&&
literal|"Not a tree leaf"
argument_list|)
expr_stmt|;
specifier|const
name|TreeNodePtr
name|IDom
init|=
name|TN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|IDom
argument_list|)
expr_stmt|;
name|auto
name|ChIt
init|=
name|llvm
operator|::
name|find
argument_list|(
name|IDom
operator|->
name|Children
argument_list|,
name|TN
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ChIt
operator|!=
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
operator|*
name|ChIt
argument_list|,
name|IDom
operator|->
name|Children
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|IDom
operator|->
name|Children
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|DT
operator|.
name|DomTreeNodes
operator|.
name|erase
argument_list|(
name|TN
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//~~
end_comment

begin_comment
comment|//===--------------- DomTree correctness verification ---------------------===
end_comment

begin_comment
comment|//~~
end_comment

begin_comment
comment|// Check if for every parent with a level L in the tree all of its children
end_comment

begin_comment
comment|// have level L + 1.
end_comment

begin_function
specifier|static
name|bool
name|VerifyLevels
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
condition|)
continue|continue;
specifier|const
name|TreeNodePtr
name|IDom
init|=
name|TN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|IDom
operator|&&
name|TN
operator|->
name|getLevel
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node without an IDom "
operator|<<
name|BlockNamePrinter
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" has a nonzero level "
operator|<<
name|TN
operator|->
name|getLevel
argument_list|()
operator|<<
literal|"!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|IDom
operator|&&
name|TN
operator|->
name|getLevel
argument_list|()
operator|!=
name|IDom
operator|->
name|getLevel
argument_list|()
operator|+
literal|1
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" has level "
operator|<<
name|TN
operator|->
name|getLevel
argument_list|()
operator|<<
literal|" while its IDom "
operator|<<
name|BlockNamePrinter
argument_list|(
name|IDom
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|<<
literal|" has level "
operator|<<
name|IDom
operator|->
name|getLevel
argument_list|()
operator|<<
literal|"!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Checks if for every edge From -> To in the graph
end_comment

begin_comment
comment|//     NCD(From, To) == IDom(To) or To.
end_comment

begin_function
name|bool
name|verifyNCD
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
name|AlwaysDescend
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|BlockToInfo
operator|:
name|NodeToInfo
control|)
block|{
name|auto
operator|&
name|Info
operator|=
name|BlockToInfo
operator|.
name|second
expr_stmt|;
specifier|const
name|NodePtr
name|From
init|=
name|NumToNode
index|[
name|Info
operator|.
name|Parent
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|From
condition|)
continue|continue;
specifier|const
name|NodePtr
name|To
init|=
name|BlockToInfo
operator|.
name|first
decl_stmt|;
specifier|const
name|TreeNodePtr
name|ToTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|To
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ToTN
argument_list|)
expr_stmt|;
specifier|const
name|NodePtr
name|NCD
init|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
decl_stmt|;
specifier|const
name|TreeNodePtr
name|NCDTN
init|=
name|DT
operator|.
name|getNode
argument_list|(
name|NCD
argument_list|)
decl_stmt|;
specifier|const
name|TreeNodePtr
name|ToIDom
init|=
name|ToTN
operator|->
name|getIDom
argument_list|()
decl_stmt|;
if|if
condition|(
name|NCDTN
operator|!=
name|ToTN
operator|&&
name|NCDTN
operator|!=
name|ToIDom
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"NearestCommonDominator verification failed:\n\tNCD(From:"
operator|<<
name|BlockNamePrinter
argument_list|(
name|From
argument_list|)
operator|<<
literal|", To:"
operator|<<
name|BlockNamePrinter
argument_list|(
name|To
argument_list|)
operator|<<
literal|") = "
operator|<<
name|BlockNamePrinter
argument_list|(
name|NCD
argument_list|)
operator|<<
literal|",\t (should be To or IDom[To]: "
operator|<<
name|BlockNamePrinter
argument_list|(
name|ToIDom
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// The below routines verify the correctness of the dominator tree relative to
end_comment

begin_comment
comment|// the CFG it's coming from.  A tree is a dominator tree iff it has two
end_comment

begin_comment
comment|// properties, called the parent property and the sibling property.  Tarjan
end_comment

begin_comment
comment|// and Lengauer prove (but don't explicitly name) the properties as part of
end_comment

begin_comment
comment|// the proofs in their 1972 paper, but the proofs are mostly part of proving
end_comment

begin_comment
comment|// things about semidominators and idoms, and some of them are simply asserted
end_comment

begin_comment
comment|// based on even earlier papers (see, e.g., lemma 2).  Some papers refer to
end_comment

begin_comment
comment|// these properties as "valid" and "co-valid".  See, e.g., "Dominators,
end_comment

begin_comment
comment|// directed bipolar orders, and independent spanning trees" by Loukas
end_comment

begin_comment
comment|// Georgiadis and Robert E. Tarjan, as well as "Dominator Tree Verification
end_comment

begin_comment
comment|// and Vertex-Disjoint Paths " by the same authors.
end_comment

begin_comment
comment|// A very simple and direct explanation of these properties can be found in
end_comment

begin_comment
comment|// "An Experimental Study of Dynamic Dominators", found at
end_comment

begin_comment
comment|// https://arxiv.org/abs/1604.02711
end_comment

begin_comment
comment|// The easiest way to think of the parent property is that it's a requirement
end_comment

begin_comment
comment|// of being a dominator.  Let's just take immediate dominators.  For PARENT to
end_comment

begin_comment
comment|// be an immediate dominator of CHILD, all paths in the CFG must go through
end_comment

begin_comment
comment|// PARENT before they hit CHILD.  This implies that if you were to cut PARENT
end_comment

begin_comment
comment|// out of the CFG, there should be no paths to CHILD that are reachable.  If
end_comment

begin_comment
comment|// there are, then you now have a path from PARENT to CHILD that goes around
end_comment

begin_comment
comment|// PARENT and still reaches CHILD, which by definition, means PARENT can't be
end_comment

begin_comment
comment|// a dominator of CHILD (let alone an immediate one).
end_comment

begin_comment
comment|// The sibling property is similar.  It says that for each pair of sibling
end_comment

begin_comment
comment|// nodes in the dominator tree (LEFT and RIGHT) , they must not dominate each
end_comment

begin_comment
comment|// other.  If sibling LEFT dominated sibling RIGHT, it means there are no
end_comment

begin_comment
comment|// paths in the CFG from sibling LEFT to sibling RIGHT that do not go through
end_comment

begin_comment
comment|// LEFT, and thus, LEFT is really an ancestor (in the dominator tree) of
end_comment

begin_comment
comment|// RIGHT, not a sibling.
end_comment

begin_comment
comment|// It is possible to verify the parent and sibling properties in
end_comment

begin_comment
comment|// linear time, but the algorithms are complex. Instead, we do it in a
end_comment

begin_comment
comment|// straightforward N^2 and N^3 way below, using direct path reachability.
end_comment

begin_comment
comment|// Checks if the tree has the parent property: if for all edges from V to W in
end_comment

begin_comment
comment|// the input graph, such that V is reachable, the parent of W in the tree is
end_comment

begin_comment
comment|// an ancestor of V in the tree.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This means that if a node gets disconnected from the graph, then all of
end_comment

begin_comment
comment|// the nodes it dominated previously will now become unreachable.
end_comment

begin_function
name|bool
name|verifyParentProperty
parameter_list|(
specifier|const
name|DomTreeT
modifier|&
name|DT
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
operator|||
name|TN
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
name|clear
argument_list|()
expr_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
index|[
name|BB
index|]
operator|(
name|NodePtr
name|From
operator|,
name|NodePtr
name|To
operator|)
block|{
return|return
name|From
operator|!=
name|BB
operator|&&
name|To
operator|!=
name|BB
return|;
block|}
block|)
empty_stmt|;
for|for
control|(
name|TreeNodePtr
name|Child
range|:
name|TN
operator|->
name|getChildren
argument_list|()
control|)
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|Child
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Child "
operator|<<
name|BlockNamePrinter
argument_list|(
name|Child
argument_list|)
operator|<<
literal|" reachable after its parent "
operator|<<
name|BlockNamePrinter
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" is removed!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_return
return|return
name|true
return|;
end_return

begin_comment
unit|}
comment|// Check if the tree has sibling property: if a node V does not dominate a
end_comment

begin_comment
comment|// node W for all siblings V and W in the tree.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This means that if a node gets disconnected from the graph, then all of its
end_comment

begin_comment
comment|// siblings will now still be reachable.
end_comment

begin_macro
unit|bool
name|verifySiblingProperty
argument_list|(
argument|const DomTreeT&DT
argument_list|)
end_macro

begin_block
block|{
for|for
control|(
name|auto
operator|&
name|NodeToTN
operator|:
name|DT
operator|.
name|DomTreeNodes
control|)
block|{
specifier|const
name|TreeNodePtr
name|TN
init|=
name|NodeToTN
operator|.
name|second
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|const
name|NodePtr
name|BB
init|=
name|TN
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BB
operator|||
name|TN
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
specifier|const
specifier|auto
modifier|&
name|Siblings
init|=
name|TN
operator|->
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|N
range|:
name|Siblings
control|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|NodePtr
name|BBN
init|=
name|N
operator|->
name|getBlock
argument_list|()
decl_stmt|;
name|doFullDFSWalk
argument_list|(
name|DT
argument_list|,
index|[
name|BBN
index|]
operator|(
name|NodePtr
name|From
operator|,
name|NodePtr
name|To
operator|)
block|{
return|return
name|From
operator|!=
name|BBN
operator|&&
name|To
operator|!=
name|BBN
return|;
block|}
block|)
empty_stmt|;
for|for
control|(
specifier|const
name|TreeNodePtr
name|S
range|:
name|Siblings
control|)
block|{
if|if
condition|(
name|S
operator|==
name|N
condition|)
continue|continue;
if|if
condition|(
name|NodeToInfo
operator|.
name|count
argument_list|(
name|S
operator|->
name|getBlock
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Node "
operator|<<
name|BlockNamePrinter
argument_list|(
name|S
argument_list|)
operator|<<
literal|" not reachable when its sibling "
operator|<<
name|BlockNamePrinter
argument_list|(
name|N
argument_list|)
operator|<<
literal|" is removed!\n"
expr_stmt|;
name|errs
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
block|}
end_block

begin_return
return|return
name|true
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|DomTreeT
operator|,
name|class
name|FuncT
operator|>
name|void
name|Calculate
argument_list|(
argument|DomTreeT&DT
argument_list|,
argument|FuncT&F
argument_list|)
block|{
name|SemiNCAInfo
operator|<
name|DomTreeT
operator|>
name|SNCA
block|;
name|SNCA
operator|.
name|calculateFromScratch
argument_list|(
name|DT
argument_list|,
name|GraphTraits
operator|<
name|FuncT
operator|*
operator|>
operator|::
name|size
argument_list|(
operator|&
name|F
argument_list|)
argument_list|)
block|; }
name|template
operator|<
name|class
name|DomTreeT
operator|>
name|void
name|InsertEdge
argument_list|(
argument|DomTreeT&DT
argument_list|,
argument|typename DomTreeT::NodePtr From
argument_list|,
argument|typename DomTreeT::NodePtr To
argument_list|)
block|{
if|if
condition|(
name|DT
operator|.
name|isPostDominator
argument_list|()
condition|)
name|std
operator|::
name|swap
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
name|SemiNCAInfo
operator|<
name|DomTreeT
operator|>
operator|::
name|InsertEdge
argument_list|(
name|DT
argument_list|,
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|DomTreeT
operator|>
name|void
name|DeleteEdge
argument_list|(
argument|DomTreeT&DT
argument_list|,
argument|typename DomTreeT::NodePtr From
argument_list|,
argument|typename DomTreeT::NodePtr To
argument_list|)
block|{
if|if
condition|(
name|DT
operator|.
name|isPostDominator
argument_list|()
condition|)
name|std
operator|::
name|swap
argument_list|(
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
name|SemiNCAInfo
operator|<
name|DomTreeT
operator|>
operator|::
name|DeleteEdge
argument_list|(
name|DT
argument_list|,
name|From
argument_list|,
name|To
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|DomTreeT
operator|>
name|bool
name|Verify
argument_list|(
argument|const DomTreeT&DT
argument_list|)
block|{
name|SemiNCAInfo
operator|<
name|DomTreeT
operator|>
name|SNCA
block|;
return|return
name|SNCA
operator|.
name|verifyReachability
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|VerifyLevels
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifyNCD
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifyParentProperty
argument_list|(
name|DT
argument_list|)
operator|&&
name|SNCA
operator|.
name|verifySiblingProperty
argument_list|(
name|DT
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace DomTreeBuilder
end_comment

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

