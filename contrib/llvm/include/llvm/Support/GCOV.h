begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/GCOV.h - LLVM coverage tool ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header provides the interface to read and write coverage files that
end_comment

begin_comment
comment|// use 'gcov' format.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_GCOV_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_GCOV_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|GCOVFunction
decl_stmt|;
name|class
name|GCOVBlock
decl_stmt|;
name|class
name|FileInfo
decl_stmt|;
name|namespace
name|GCOV
block|{
enum|enum
name|GCOVFormat
block|{
name|InvalidGCOV
block|,
name|GCNO_402
block|,
name|GCNO_404
block|,
name|GCDA_402
block|,
name|GCDA_404
block|}
enum|;
block|}
comment|// end GCOV namespace
comment|/// GCOVBuffer - A wrapper around MemoryBuffer to provide GCOV specific
comment|/// read operations.
name|class
name|GCOVBuffer
block|{
name|public
label|:
name|GCOVBuffer
argument_list|(
name|MemoryBuffer
operator|*
name|B
argument_list|)
operator|:
name|Buffer
argument_list|(
name|B
argument_list|)
operator|,
name|Cursor
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// readGCOVFormat - Read GCOV signature at the beginning of buffer.
name|GCOV
operator|::
name|GCOVFormat
name|readGCOVFormat
argument_list|()
block|{
name|StringRef
name|Magic
operator|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
block|;
name|Cursor
operator|=
literal|12
block|;
if|if
condition|(
name|Magic
operator|==
literal|"oncg*404MVLL"
condition|)
return|return
name|GCOV
operator|::
name|GCNO_404
return|;
elseif|else
if|if
condition|(
name|Magic
operator|==
literal|"oncg*204MVLL"
condition|)
return|return
name|GCOV
operator|::
name|GCNO_402
return|;
elseif|else
if|if
condition|(
name|Magic
operator|==
literal|"adcg*404MVLL"
condition|)
return|return
name|GCOV
operator|::
name|GCDA_404
return|;
elseif|else
if|if
condition|(
name|Magic
operator|==
literal|"adcg*204MVLL"
condition|)
return|return
name|GCOV
operator|::
name|GCDA_402
return|;
name|Cursor
operator|=
literal|0
expr_stmt|;
return|return
name|GCOV
operator|::
name|InvalidGCOV
return|;
block|}
comment|/// readFunctionTag - If cursor points to a function tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readFunctionTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readBlockTag - If cursor points to a block tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readBlockTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x41'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readEdgeTag - If cursor points to an edge tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readEdgeTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x43'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readLineTag - If cursor points to a line tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readLineTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\x45'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\x01'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readArcTag - If cursor points to an gcda arc tag then increment the
comment|/// cursor and return true otherwise return false.
name|bool
name|readArcTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\xa1'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readObjectTag - If cursor points to an object summary tag then increment
comment|/// the cursor and return true otherwise return false.
name|bool
name|readObjectTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\xa1'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/// readProgramTag - If cursor points to a program summary tag then increment
comment|/// the cursor and return true otherwise return false.
name|bool
name|readProgramTag
parameter_list|()
block|{
name|StringRef
name|Tag
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Tag
operator|.
name|empty
argument_list|()
operator|||
name|Tag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|||
name|Tag
index|[
literal|3
index|]
operator|!=
literal|'\xa3'
condition|)
block|{
return|return
name|false
return|;
block|}
name|Cursor
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readInt
parameter_list|(
name|uint32_t
modifier|&
name|Val
parameter_list|)
block|{
if|if
condition|(
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|Cursor
operator|+
literal|4
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected end of memory buffer: "
operator|<<
name|Cursor
operator|+
literal|4
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|StringRef
name|Str
init|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
literal|4
argument_list|)
decl_stmt|;
name|Cursor
operator|+=
literal|4
expr_stmt|;
name|Val
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|Str
operator|.
name|data
argument_list|()
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readInt64
parameter_list|(
name|uint64_t
modifier|&
name|Val
parameter_list|)
block|{
name|uint32_t
name|Lo
decl_stmt|,
name|Hi
decl_stmt|;
if|if
condition|(
operator|!
name|readInt
argument_list|(
name|Lo
argument_list|)
operator|||
operator|!
name|readInt
argument_list|(
name|Hi
argument_list|)
condition|)
return|return
name|false
return|;
name|Val
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|Hi
operator|<<
literal|32
operator|)
operator||
name|Lo
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|readString
parameter_list|(
name|StringRef
modifier|&
name|Str
parameter_list|)
block|{
name|uint32_t
name|Len
decl_stmt|;
if|if
condition|(
operator|!
name|readInt
argument_list|(
name|Len
argument_list|)
condition|)
return|return
name|false
return|;
name|Len
operator|*=
literal|4
expr_stmt|;
if|if
condition|(
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|Cursor
operator|+
name|Len
condition|)
block|{
name|errs
argument_list|()
operator|<<
literal|"Unexpected end of memory buffer: "
operator|<<
name|Cursor
operator|+
name|Len
operator|<<
literal|".\n"
expr_stmt|;
return|return
name|false
return|;
block|}
name|Str
operator|=
name|Buffer
operator|->
name|getBuffer
argument_list|()
operator|.
name|slice
argument_list|(
name|Cursor
argument_list|,
name|Cursor
operator|+
name|Len
argument_list|)
operator|.
name|split
argument_list|(
literal|'\0'
argument_list|)
operator|.
name|first
expr_stmt|;
name|Cursor
operator|+=
name|Len
expr_stmt|;
return|return
name|true
return|;
block|}
name|uint64_t
name|getCursor
argument_list|()
specifier|const
block|{
return|return
name|Cursor
return|;
block|}
name|void
name|advanceCursor
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
name|Cursor
operator|+=
name|n
operator|*
literal|4
expr_stmt|;
block|}
name|private
label|:
name|MemoryBuffer
modifier|*
name|Buffer
decl_stmt|;
name|uint64_t
name|Cursor
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVFile - Collects coverage information for one pair of coverage file
end_comment

begin_comment
comment|/// (.gcno and .gcda).
end_comment

begin_decl_stmt
name|class
name|GCOVFile
block|{
name|public
label|:
name|GCOVFile
argument_list|()
operator|:
name|Functions
argument_list|()
operator|,
name|RunCount
argument_list|(
literal|0
argument_list|)
operator|,
name|ProgramCount
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|GCOVFile
argument_list|()
expr_stmt|;
name|bool
name|read
parameter_list|(
name|GCOVBuffer
modifier|&
name|Buffer
parameter_list|)
function_decl|;
name|void
name|dump
parameter_list|()
function_decl|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|SmallVector
operator|<
name|GCOVFunction
operator|*
operator|,
literal|16
operator|>
name|Functions
expr_stmt|;
name|uint32_t
name|RunCount
decl_stmt|;
name|uint32_t
name|ProgramCount
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVFunction - Collects function information.
end_comment

begin_decl_stmt
name|class
name|GCOVFunction
block|{
name|public
label|:
name|GCOVFunction
argument_list|()
operator|:
name|Ident
argument_list|(
literal|0
argument_list|)
operator|,
name|LineNumber
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|GCOVFunction
argument_list|()
expr_stmt|;
name|bool
name|read
argument_list|(
name|GCOVBuffer
operator|&
name|Buffer
argument_list|,
name|GCOV
operator|::
name|GCOVFormat
name|Format
argument_list|)
decl_stmt|;
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|Filename
return|;
block|}
name|void
name|dump
parameter_list|()
function_decl|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|uint32_t
name|Ident
decl_stmt|;
name|uint32_t
name|LineNumber
decl_stmt|;
name|StringRef
name|Name
decl_stmt|;
name|StringRef
name|Filename
decl_stmt|;
name|SmallVector
operator|<
name|GCOVBlock
operator|*
operator|,
literal|16
operator|>
name|Blocks
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// GCOVBlock - Collects block information.
end_comment

begin_decl_stmt
name|class
name|GCOVBlock
block|{
name|public
label|:
name|GCOVBlock
argument_list|(
argument|GCOVFunction&P
argument_list|,
argument|uint32_t N
argument_list|)
block|:
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Number
argument_list|(
name|N
argument_list|)
operator|,
name|Counter
argument_list|(
literal|0
argument_list|)
operator|,
name|Edges
argument_list|()
operator|,
name|Lines
argument_list|()
block|{}
operator|~
name|GCOVBlock
argument_list|()
expr_stmt|;
name|void
name|addEdge
parameter_list|(
name|uint32_t
name|N
parameter_list|)
block|{
name|Edges
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|addLine
parameter_list|(
name|uint32_t
name|N
parameter_list|)
block|{
name|Lines
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|addCount
parameter_list|(
name|uint64_t
name|N
parameter_list|)
block|{
name|Counter
operator|+=
name|N
expr_stmt|;
block|}
name|size_t
name|getNumEdges
parameter_list|()
block|{
return|return
name|Edges
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|dump
parameter_list|()
function_decl|;
name|void
name|collectLineCounts
parameter_list|(
name|FileInfo
modifier|&
name|FI
parameter_list|)
function_decl|;
name|private
label|:
name|GCOVFunction
modifier|&
name|Parent
decl_stmt|;
name|uint32_t
name|Number
decl_stmt|;
name|uint64_t
name|Counter
decl_stmt|;
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|16
operator|>
name|Edges
expr_stmt|;
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|16
operator|>
name|Lines
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|uint32_t
operator|,
name|uint64_t
operator|>
name|LineCounts
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|FileInfo
block|{
name|public
label|:
name|void
name|addLineCount
parameter_list|(
name|StringRef
name|Filename
parameter_list|,
name|uint32_t
name|Line
parameter_list|,
name|uint64_t
name|Count
parameter_list|)
block|{
name|LineInfo
index|[
name|Filename
index|]
index|[
name|Line
operator|-
literal|1
index|]
operator|+=
name|Count
expr_stmt|;
block|}
name|void
name|setRunCount
parameter_list|(
name|uint32_t
name|Runs
parameter_list|)
block|{
name|RunCount
operator|=
name|Runs
expr_stmt|;
block|}
name|void
name|setProgramCount
parameter_list|(
name|uint32_t
name|Programs
parameter_list|)
block|{
name|ProgramCount
operator|=
name|Programs
expr_stmt|;
block|}
name|void
name|print
parameter_list|(
name|raw_fd_ostream
modifier|&
name|OS
parameter_list|,
name|StringRef
name|gcnoFile
parameter_list|,
name|StringRef
name|gcdaFile
parameter_list|)
function_decl|;
name|private
label|:
name|StringMap
operator|<
name|LineCounts
operator|>
name|LineInfo
expr_stmt|;
name|uint32_t
name|RunCount
decl_stmt|;
name|uint32_t
name|ProgramCount
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

