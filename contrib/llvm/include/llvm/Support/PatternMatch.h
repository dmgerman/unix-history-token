begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Support/PatternMatch.h - Match on the LLVM IR ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides a simple and efficient mechanism for performing general
end_comment

begin_comment
comment|// tree-based pattern matches on the LLVM IR.  The power of these routines is
end_comment

begin_comment
comment|// that it allows you to write concise patterns that are expressive and easy to
end_comment

begin_comment
comment|// understand.  The other major advantage of this is that it allows you to
end_comment

begin_comment
comment|// trivially capture/bind elements in the pattern to variables.  For example,
end_comment

begin_comment
comment|// you can do something like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Value *Exp = ...
end_comment

begin_comment
comment|//  Value *X, *Y;  ConstantInt *C1, *C2;      // (X& C1) | (Y& C2)
end_comment

begin_comment
comment|//  if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),
end_comment

begin_comment
comment|//                      m_And(m_Value(Y), m_ConstantInt(C2))))) {
end_comment

begin_comment
comment|//    ... Pattern is matched and variables are bound ...
end_comment

begin_comment
comment|//  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This is primarily useful to things like the instruction combiner, but can
end_comment

begin_comment
comment|// also be useful for static analysis tools or code generators.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_SUPPORT_PATTERNMATCH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_SUPPORT_PATTERNMATCH_H
end_define

begin_include
include|#
directive|include
file|"llvm/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Operator.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PatternMatch
block|{
name|template
operator|<
name|typename
name|Val
operator|,
name|typename
name|Pattern
operator|>
name|bool
name|match
argument_list|(
argument|Val *V
argument_list|,
argument|const Pattern&P
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|Pattern
operator|&
operator|>
operator|(
name|P
operator|)
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|SubPattern_t
operator|>
expr|struct
name|OneUse_match
block|{
name|SubPattern_t
name|SubPattern
block|;
name|OneUse_match
argument_list|(
specifier|const
name|SubPattern_t
operator|&
name|SP
argument_list|)
operator|:
name|SubPattern
argument_list|(
argument|SP
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
return|return
name|V
operator|->
name|hasOneUse
argument_list|()
operator|&&
name|SubPattern
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|OneUse_match
operator|<
name|T
operator|>
name|m_OneUse
argument_list|(
argument|const T&SubPattern
argument_list|)
block|{
return|return
name|SubPattern
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|class_match
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|isa
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
return|;
block|}
expr|}
block|;
comment|/// m_Value() - Match an arbitrary value and ignore it.
specifier|inline
name|class_match
operator|<
name|Value
operator|>
name|m_Value
argument_list|()
block|{
return|return
name|class_match
operator|<
name|Value
operator|>
operator|(
operator|)
return|;
block|}
comment|/// m_ConstantInt() - Match an arbitrary ConstantInt and ignore it.
specifier|inline
name|class_match
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|class_match
operator|<
name|ConstantInt
operator|>
operator|(
operator|)
return|;
block|}
comment|/// m_Undef() - Match an arbitrary undef constant.
specifier|inline
name|class_match
operator|<
name|UndefValue
operator|>
name|m_Undef
argument_list|()
block|{
return|return
name|class_match
operator|<
name|UndefValue
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|class_match
operator|<
name|Constant
operator|>
name|m_Constant
argument_list|()
block|{
return|return
name|class_match
operator|<
name|Constant
operator|>
operator|(
operator|)
return|;
block|}
expr|struct
name|match_zero
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Constant
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|Constant
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|->
name|isNullValue
argument_list|()
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_Zero() - Match an arbitrary zero/null constant.  This includes
comment|/// zero_initializer for vectors and ConstantPointerNull for pointers.
specifier|inline
name|match_zero
name|m_Zero
argument_list|()
block|{
return|return
name|match_zero
argument_list|()
return|;
block|}
expr|struct
name|apint_match
block|{
specifier|const
name|APInt
operator|*
operator|&
name|Res
block|;
name|apint_match
argument_list|(
specifier|const
name|APInt
operator|*
operator|&
name|R
argument_list|)
operator|:
name|Res
argument_list|(
argument|R
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// FIXME: Remove this.
if|if
condition|(
name|ConstantVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|ConstantDataVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantDataVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_APInt - Match a ConstantInt or splatted ConstantVector, binding the
comment|/// specified pointer to the contained APInt.
specifier|inline
name|apint_match
name|m_APInt
argument_list|(
argument|const APInt *&Res
argument_list|)
block|{
return|return
name|Res
return|;
block|}
name|template
operator|<
name|int64_t
name|Val
operator|>
expr|struct
name|constantint_match
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
block|{
specifier|const
name|APInt
modifier|&
name|CIV
init|=
name|CI
operator|->
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Val
operator|>=
literal|0
condition|)
return|return
name|CIV
operator|==
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|Val
operator|)
return|;
comment|// If Val is negative, and CI is shorter than it, truncate to the right
comment|// number of bits.  If it is larger, then we have to sign extend.  Just
comment|// compare their negated values.
return|return
operator|-
name|CIV
operator|==
operator|-
name|Val
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_ConstantInt<int64_t> - Match a ConstantInt with a specific value.
name|template
operator|<
name|int64_t
name|Val
operator|>
specifier|inline
name|constantint_match
operator|<
name|Val
operator|>
name|m_ConstantInt
argument_list|()
block|{
return|return
name|constantint_match
operator|<
name|Val
operator|>
operator|(
operator|)
return|;
block|}
comment|/// cst_pred_ty - This helper class is used to match scalar and vector constants
comment|/// that satisfy a specified predicate.
name|template
operator|<
name|typename
name|Predicate
operator|>
expr|struct
name|cst_pred_ty
operator|:
name|public
name|Predicate
block|{
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
comment|// FIXME: Remove this.
if|if
condition|(
specifier|const
name|ConstantVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
return|return
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
if|if
condition|(
specifier|const
name|ConstantDataVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantDataVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
return|return
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// api_pred_ty - This helper class is used to match scalar and vector constants
comment|/// that satisfy a specified predicate, and bind them to an APInt.
name|template
operator|<
name|typename
name|Predicate
operator|>
expr|struct
name|api_pred_ty
operator|:
name|public
name|Predicate
block|{
specifier|const
name|APInt
operator|*
operator|&
name|Res
block|;
name|api_pred_ty
argument_list|(
specifier|const
name|APInt
operator|*
operator|&
name|R
argument_list|)
operator|:
name|Res
argument_list|(
argument|R
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
specifier|const
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// FIXME: remove.
if|if
condition|(
specifier|const
name|ConstantVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
if|if
condition|(
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
specifier|const
name|ConstantDataVector
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantDataVector
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|ConstantInt
modifier|*
name|CI
init|=
name|dyn_cast_or_null
operator|<
name|ConstantInt
operator|>
operator|(
name|CV
operator|->
name|getSplatValue
argument_list|()
operator|)
condition|)
if|if
condition|(
name|this
operator|->
name|isValue
argument_list|(
name|CI
operator|->
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|Res
operator|=
operator|&
name|CI
operator|->
name|getValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;       struct
name|is_one
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|==
literal|1
return|;
block|}
expr|}
block|;
comment|/// m_One() - Match an integer 1 or a vector with all elements equal to 1.
specifier|inline
name|cst_pred_ty
operator|<
name|is_one
operator|>
name|m_One
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_one
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_one
operator|>
name|m_One
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_all_ones
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isAllOnesValue
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// m_AllOnes() - Match an integer or vector with all bits set to true.
specifier|inline
name|cst_pred_ty
operator|<
name|is_all_ones
operator|>
name|m_AllOnes
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_all_ones
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_all_ones
operator|>
name|m_AllOnes
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_sign_bit
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isSignBit
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// m_SignBit() - Match an integer or vector with only the sign bit(s) set.
specifier|inline
name|cst_pred_ty
operator|<
name|is_sign_bit
operator|>
name|m_SignBit
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_sign_bit
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_sign_bit
operator|>
name|m_SignBit
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|is_power2
block|{
name|bool
name|isValue
argument_list|(
argument|const APInt&C
argument_list|)
block|{
return|return
name|C
operator|.
name|isPowerOf2
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// m_Power2() - Match an integer or vector power of 2.
specifier|inline
name|cst_pred_ty
operator|<
name|is_power2
operator|>
name|m_Power2
argument_list|()
block|{
return|return
name|cst_pred_ty
operator|<
name|is_power2
operator|>
operator|(
operator|)
return|;
block|}
specifier|inline
name|api_pred_ty
operator|<
name|is_power2
operator|>
name|m_Power2
argument_list|(
argument|const APInt *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
name|template
operator|<
name|typename
name|Class
operator|>
expr|struct
name|bind_ty
block|{
name|Class
operator|*
operator|&
name|VR
block|;
name|bind_ty
argument_list|(
name|Class
operator|*
operator|&
name|V
argument_list|)
operator|:
name|VR
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
block|{
name|VR
operator|=
name|CV
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_Value - Match a value, capturing it if we match.
specifier|inline
name|bind_ty
operator|<
name|Value
operator|>
name|m_Value
argument_list|(
argument|Value *&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|/// m_ConstantInt - Match a ConstantInt, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|ConstantInt
operator|>
name|m_ConstantInt
argument_list|(
argument|ConstantInt *&CI
argument_list|)
block|{
return|return
name|CI
return|;
block|}
comment|/// m_Constant - Match a Constant, capturing the value if we match.
specifier|inline
name|bind_ty
operator|<
name|Constant
operator|>
name|m_Constant
argument_list|(
argument|Constant *&C
argument_list|)
block|{
return|return
name|C
return|;
block|}
comment|/// specificval_ty - Match a specified Value*.
expr|struct
name|specificval_ty
block|{
specifier|const
name|Value
operator|*
name|Val
block|;
name|specificval_ty
argument_list|(
specifier|const
name|Value
operator|*
name|V
argument_list|)
operator|:
name|Val
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
return|return
name|V
operator|==
name|Val
return|;
block|}
expr|}
block|;
comment|/// m_Specific - Match if we have a specific specified value.
specifier|inline
name|specificval_ty
name|m_Specific
argument_list|(
argument|const Value *V
argument_list|)
block|{
return|return
name|V
return|;
block|}
expr|struct
name|bind_const_intval_ty
block|{
name|uint64_t
operator|&
name|VR
block|;
name|bind_const_intval_ty
argument_list|(
name|uint64_t
operator|&
name|V
argument_list|)
operator|:
name|VR
argument_list|(
argument|V
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ITy
operator|>
name|bool
name|match
argument_list|(
argument|ITy *V
argument_list|)
block|{
if|if
condition|(
name|ConstantInt
modifier|*
name|CV
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|CV
operator|->
name|getBitWidth
argument_list|()
operator|<=
literal|64
condition|)
block|{
name|VR
operator|=
name|CV
operator|->
name|getZExtValue
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_ConstantInt - Match a ConstantInt and bind to its value.  This does not
comment|/// match ConstantInts wider than 64-bits.
specifier|inline
name|bind_const_intval_ty
name|m_ConstantInt
argument_list|(
argument|uint64_t&V
argument_list|)
block|{
return|return
name|V
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for specific binary operators.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opcode
operator|>
expr|struct
name|BinaryOp_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinaryOp_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opcode
condition|)
block|{
name|BinaryOperator
modifier|*
name|I
init|=
name|cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
decl_stmt|;
return|return
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Add
operator|>
name|m_Add
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Add
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FAdd
operator|>
name|m_FAdd
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FAdd
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Sub
operator|>
name|m_Sub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Sub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FSub
operator|>
name|m_FSub
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FSub
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Mul
operator|>
name|m_Mul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Mul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FMul
operator|>
name|m_FMul
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FMul
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|UDiv
operator|>
name|m_UDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|UDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SDiv
operator|>
name|m_SDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FDiv
operator|>
name|m_FDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|URem
operator|>
name|m_URem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|URem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SRem
operator|>
name|m_SRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|FRem
operator|>
name|m_FRem
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|FRem
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|And
operator|>
name|m_And
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|And
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Or
operator|>
name|m_Or
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Or
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Xor
operator|>
name|m_Xor
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Xor
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|Shl
operator|>
name|m_Shl
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|Shl
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
operator|>
name|m_LShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinaryOp_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|AShr
operator|>
name|m_AShr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinaryOp_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|AShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Class that matches two different binary ops.
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|unsigned
name|Opc1
block|,
name|unsigned
name|Opc2
operator|>
expr|struct
name|BinOp2_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|BinOp2_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opc1
operator|||
name|V
operator|->
name|getValueID
argument_list|()
operator|==
name|Value
operator|::
name|InstructionVal
operator|+
name|Opc2
condition|)
block|{
name|BinaryOperator
modifier|*
name|I
init|=
name|cast
operator|<
name|BinaryOperator
operator|>
operator|(
name|V
operator|)
decl_stmt|;
return|return
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|ConstantExpr
modifier|*
name|CE
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|V
operator|)
condition|)
return|return
operator|(
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opc1
operator|||
name|CE
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opc2
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|CE
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_Shr - Matches LShr or AShr.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
block|,
name|Instruction
operator|::
name|AShr
operator|>
name|m_Shr
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|,
name|Instruction
operator|::
name|AShr
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// m_LogicalShift - Matches LShr or Shl.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|LShr
block|,
name|Instruction
operator|::
name|Shl
operator|>
name|m_LogicalShift
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|LShr
operator|,
name|Instruction
operator|::
name|Shl
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// m_IDiv - Matches UDiv and SDiv.
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|BinOp2_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|Instruction
operator|::
name|SDiv
block|,
name|Instruction
operator|::
name|UDiv
operator|>
name|m_IDiv
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|BinOp2_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|Instruction
operator|::
name|SDiv
operator|,
name|Instruction
operator|::
name|UDiv
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Class that matches exact binary ops.
comment|//
name|template
operator|<
name|typename
name|SubPattern_t
operator|>
expr|struct
name|Exact_match
block|{
name|SubPattern_t
name|SubPattern
block|;
name|Exact_match
argument_list|(
specifier|const
name|SubPattern_t
operator|&
name|SP
argument_list|)
operator|:
name|SubPattern
argument_list|(
argument|SP
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|PossiblyExactOperator
modifier|*
name|PEO
init|=
name|dyn_cast
operator|<
name|PossiblyExactOperator
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|PEO
operator|->
name|isExact
argument_list|()
operator|&&
name|SubPattern
operator|.
name|match
argument_list|(
name|V
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|Exact_match
operator|<
name|T
operator|>
name|m_Exact
argument_list|(
argument|const T&SubPattern
argument_list|)
block|{
return|return
name|SubPattern
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CmpInst classes
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Class
block|,
name|typename
name|PredicateTy
operator|>
expr|struct
name|CmpClass_match
block|{
name|PredicateTy
operator|&
name|Predicate
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|CmpClass_match
argument_list|(
name|PredicateTy
operator|&
name|Pred
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|Predicate
argument_list|(
name|Pred
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Class
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|Class
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|Predicate
operator|=
name|I
operator|->
name|getPredicate
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|ICmpInst
block|,
name|ICmpInst
operator|::
name|Predicate
operator|>
name|m_ICmp
argument_list|(
argument|ICmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|ICmpInst
operator|,
name|ICmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|CmpClass_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|FCmpInst
block|,
name|FCmpInst
operator|::
name|Predicate
operator|>
name|m_FCmp
argument_list|(
argument|FCmpInst::Predicate&Pred
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|CmpClass_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|FCmpInst
operator|,
name|FCmpInst
operator|::
name|Predicate
operator|>
operator|(
name|Pred
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for SelectInst classes
comment|//
name|template
operator|<
name|typename
name|Cond_t
block|,
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
operator|>
expr|struct
name|SelectClass_match
block|{
name|Cond_t
name|C
block|;
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|SelectClass_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|Cond
argument_list|,
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|C
argument_list|(
name|Cond
argument_list|)
block|,
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|SelectInst
modifier|*
name|I
init|=
name|dyn_cast
operator|<
name|SelectInst
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|C
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|I
operator|->
name|getOperand
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Cond
block|,
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|LHS
block|,
name|RHS
operator|>
name|m_Select
argument_list|(
argument|const Cond&C
argument_list|,
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|SelectClass_match
operator|<
name|Cond
operator|,
name|LHS
operator|,
name|RHS
operator|>
operator|(
name|C
operator|,
name|L
operator|,
name|R
operator|)
return|;
block|}
comment|/// m_SelectCst - This matches a select of two constants, e.g.:
comment|///    m_SelectCst<-1, 0>(m_Value(V))
name|template
operator|<
name|int64_t
name|L
block|,
name|int64_t
name|R
block|,
name|typename
name|Cond
operator|>
specifier|inline
name|SelectClass_match
operator|<
name|Cond
block|,
name|constantint_match
operator|<
name|L
operator|>
block|,
name|constantint_match
operator|<
name|R
operator|>
expr|>
name|m_SelectCst
argument_list|(
argument|const Cond&C
argument_list|)
block|{
return|return
name|m_Select
argument_list|(
name|C
argument_list|,
name|m_ConstantInt
operator|<
name|L
operator|>
operator|(
operator|)
argument_list|,
name|m_ConstantInt
operator|<
name|R
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for CastInst classes
comment|//
name|template
operator|<
name|typename
name|Op_t
block|,
name|unsigned
name|Opcode
operator|>
expr|struct
name|CastClass_match
block|{
name|Op_t
name|Op
block|;
name|CastClass_match
argument_list|(
specifier|const
name|Op_t
operator|&
name|OpMatch
argument_list|)
operator|:
name|Op
argument_list|(
argument|OpMatch
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Operator
modifier|*
name|O
init|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
return|return
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Opcode
operator|&&
name|Op
operator|.
name|match
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_BitCast
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|BitCast
operator|>
name|m_BitCast
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|BitCast
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// m_PtrToInt
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|PtrToInt
operator|>
name|m_PtrToInt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|PtrToInt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// m_Trunc
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|Trunc
operator|>
name|m_Trunc
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|Trunc
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// m_SExt
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|SExt
operator|>
name|m_SExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|SExt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|/// m_ZExt
name|template
operator|<
name|typename
name|OpTy
operator|>
specifier|inline
name|CastClass_match
operator|<
name|OpTy
block|,
name|Instruction
operator|::
name|ZExt
operator|>
name|m_ZExt
argument_list|(
argument|const OpTy&Op
argument_list|)
block|{
return|return
name|CastClass_match
operator|<
name|OpTy
operator|,
name|Instruction
operator|::
name|ZExt
operator|>
operator|(
name|Op
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for unary operators
comment|//
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|not_match
block|{
name|LHS_t
name|L
block|;
name|not_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Operator
modifier|*
name|O
init|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Xor
condition|)
return|return
name|matchIfNot
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfNot
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
return|return
operator|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|RHS
operator|)
operator|||
name|isa
operator|<
name|ConstantDataVector
operator|>
operator|(
name|RHS
operator|)
operator|||
comment|// FIXME: Remove CV.
name|isa
operator|<
name|ConstantVector
operator|>
operator|(
name|RHS
operator|)
operator|)
operator|&&
name|cast
operator|<
name|Constant
operator|>
operator|(
name|RHS
operator|)
operator|->
name|isAllOnesValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|not_match
operator|<
name|LHS
operator|>
name|m_Not
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|neg_match
block|{
name|LHS_t
name|L
block|;
name|neg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Operator
modifier|*
name|O
init|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|Sub
condition|)
return|return
name|matchIfNeg
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfNeg
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
return|return
operator|(
operator|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|LHS
operator|)
operator|&&
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|LHS
operator|)
operator|->
name|isZero
argument_list|()
operator|)
operator|||
name|isa
operator|<
name|ConstantAggregateZero
operator|>
operator|(
name|LHS
operator|)
operator|)
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// m_Neg - Match an integer negate.
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|neg_match
operator|<
name|LHS
operator|>
name|m_Neg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
name|template
operator|<
name|typename
name|LHS_t
operator|>
expr|struct
name|fneg_match
block|{
name|LHS_t
name|L
block|;
name|fneg_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|)
operator|:
name|L
argument_list|(
argument|LHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|Operator
modifier|*
name|O
init|=
name|dyn_cast
operator|<
name|Operator
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|O
operator|->
name|getOpcode
argument_list|()
operator|==
name|Instruction
operator|::
name|FSub
condition|)
return|return
name|matchIfFNeg
argument_list|(
name|O
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|bool
name|matchIfFNeg
argument_list|(
argument|Value *LHS
argument_list|,
argument|Value *RHS
argument_list|)
block|{
if|if
condition|(
name|ConstantFP
modifier|*
name|C
init|=
name|dyn_cast
operator|<
name|ConstantFP
operator|>
operator|(
name|LHS
operator|)
condition|)
return|return
name|C
operator|->
name|isNegativeZeroValue
argument_list|()
operator|&&
name|L
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
return|return
name|false
return|;
block|}
expr|}
block|;
comment|/// m_FNeg - Match a floating point negate.
name|template
operator|<
name|typename
name|LHS
operator|>
specifier|inline
name|fneg_match
operator|<
name|LHS
operator|>
name|m_FNeg
argument_list|(
argument|const LHS&L
argument_list|)
block|{
return|return
name|L
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for control flow.
comment|//
name|template
operator|<
name|typename
name|Cond_t
operator|>
expr|struct
name|brc_match
block|{
name|Cond_t
name|Cond
block|;
name|BasicBlock
operator|*
operator|&
name|T
block|,
operator|*
operator|&
name|F
block|;
name|brc_match
argument_list|(
specifier|const
name|Cond_t
operator|&
name|C
argument_list|,
name|BasicBlock
operator|*
operator|&
name|t
argument_list|,
name|BasicBlock
operator|*
operator|&
name|f
argument_list|)
operator|:
name|Cond
argument_list|(
name|C
argument_list|)
block|,
name|T
argument_list|(
name|t
argument_list|)
block|,
name|F
argument_list|(
argument|f
argument_list|)
block|{   }
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
if|if
condition|(
name|BranchInst
modifier|*
name|BI
init|=
name|dyn_cast
operator|<
name|BranchInst
operator|>
operator|(
name|V
operator|)
condition|)
if|if
condition|(
name|BI
operator|->
name|isConditional
argument_list|()
operator|&&
name|Cond
operator|.
name|match
argument_list|(
name|BI
operator|->
name|getCondition
argument_list|()
argument_list|)
condition|)
block|{
name|T
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|F
operator|=
name|BI
operator|->
name|getSuccessor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|Cond_t
operator|>
specifier|inline
name|brc_match
operator|<
name|Cond_t
operator|>
name|m_Br
argument_list|(
argument|const Cond_t&C
argument_list|,
argument|BasicBlock *&T
argument_list|,
argument|BasicBlock *&F
argument_list|)
block|{
return|return
name|brc_match
operator|<
name|Cond_t
operator|>
operator|(
name|C
operator|,
name|T
operator|,
name|F
operator|)
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Matchers for max/min idioms, eg: "select (sgt x, y), x, y" -> smax(x,y).
comment|//
name|template
operator|<
name|typename
name|LHS_t
block|,
name|typename
name|RHS_t
block|,
name|typename
name|Pred_t
operator|>
expr|struct
name|MaxMin_match
block|{
name|LHS_t
name|L
block|;
name|RHS_t
name|R
block|;
name|MaxMin_match
argument_list|(
specifier|const
name|LHS_t
operator|&
name|LHS
argument_list|,
specifier|const
name|RHS_t
operator|&
name|RHS
argument_list|)
operator|:
name|L
argument_list|(
name|LHS
argument_list|)
block|,
name|R
argument_list|(
argument|RHS
argument_list|)
block|{}
name|template
operator|<
name|typename
name|OpTy
operator|>
name|bool
name|match
argument_list|(
argument|OpTy *V
argument_list|)
block|{
comment|// Look for "(x pred y) ? x : y" or "(x pred y) ? y : x".
name|SelectInst
operator|*
name|SI
operator|=
name|dyn_cast
operator|<
name|SelectInst
operator|>
operator|(
name|V
operator|)
block|;
if|if
condition|(
operator|!
name|SI
condition|)
return|return
name|false
return|;
name|ICmpInst
operator|*
name|Cmp
operator|=
name|dyn_cast
operator|<
name|ICmpInst
operator|>
operator|(
name|SI
operator|->
name|getCondition
argument_list|()
operator|)
block|;
if|if
condition|(
operator|!
name|Cmp
condition|)
return|return
name|false
return|;
comment|// At this point we have a select conditioned on a comparison.  Check that
comment|// it is the values returned by the select that are being compared.
name|Value
operator|*
name|TrueVal
operator|=
name|SI
operator|->
name|getTrueValue
argument_list|()
block|;
name|Value
operator|*
name|FalseVal
operator|=
name|SI
operator|->
name|getFalseValue
argument_list|()
block|;
name|Value
operator|*
name|LHS
operator|=
name|Cmp
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
block|;
name|Value
operator|*
name|RHS
operator|=
name|Cmp
operator|->
name|getOperand
argument_list|(
literal|1
argument_list|)
block|;
if|if
condition|(
operator|(
name|TrueVal
operator|!=
name|LHS
operator|||
name|FalseVal
operator|!=
name|RHS
operator|)
operator|&&
operator|(
name|TrueVal
operator|!=
name|RHS
operator|||
name|FalseVal
operator|!=
name|LHS
operator|)
condition|)
return|return
name|false
return|;
name|ICmpInst
operator|::
name|Predicate
name|Pred
operator|=
name|LHS
operator|==
name|TrueVal
condition|?
name|Cmp
operator|->
name|getPredicate
argument_list|()
else|:
name|Cmp
operator|->
name|getSwappedPredicate
argument_list|()
block|;
comment|// Does "(x pred y) ? x : y" represent the desired max/min operation?
if|if
condition|(
operator|!
name|Pred_t
operator|::
name|match
argument_list|(
name|Pred
argument_list|)
condition|)
return|return
name|false
return|;
comment|// It does!  Bind the operands.
return|return
name|L
operator|.
name|match
argument_list|(
name|LHS
argument_list|)
operator|&&
name|R
operator|.
name|match
argument_list|(
name|RHS
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// smax_pred_ty - Helper class for identifying signed max predicates.
block|struct
name|smax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SGE
return|;
block|}
expr|}
block|;
comment|/// smin_pred_ty - Helper class for identifying signed min predicates.
block|struct
name|smin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SLT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_SLE
return|;
block|}
expr|}
block|;
comment|/// umax_pred_ty - Helper class for identifying unsigned max predicates.
block|struct
name|umax_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_UGT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_UGE
return|;
block|}
expr|}
block|;
comment|/// umin_pred_ty - Helper class for identifying unsigned min predicates.
block|struct
name|umin_pred_ty
block|{
specifier|static
name|bool
name|match
argument_list|(
argument|ICmpInst::Predicate Pred
argument_list|)
block|{
return|return
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_ULT
operator|||
name|Pred
operator|==
name|CmpInst
operator|::
name|ICMP_ULE
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|smax_pred_ty
operator|>
name|m_SMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|smax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|smin_pred_ty
operator|>
name|m_SMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|smin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|umax_pred_ty
operator|>
name|m_UMax
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|umax_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|LHS
block|,
name|typename
name|RHS
operator|>
specifier|inline
name|MaxMin_match
operator|<
name|LHS
block|,
name|RHS
block|,
name|umin_pred_ty
operator|>
name|m_UMin
argument_list|(
argument|const LHS&L
argument_list|,
argument|const RHS&R
argument_list|)
block|{
return|return
name|MaxMin_match
operator|<
name|LHS
operator|,
name|RHS
operator|,
name|umin_pred_ty
operator|>
operator|(
name|L
operator|,
name|R
operator|)
return|;
block|}
expr|}
comment|// end namespace PatternMatch
expr|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

