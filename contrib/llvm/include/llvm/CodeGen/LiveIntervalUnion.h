begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- LiveIntervalUnion.h - Live interval union data struct ---*- C++ -*--===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// LiveIntervalUnion is a union of live segments across multiple live virtual
end_comment

begin_comment
comment|// registers. This may be used during coalescing to represent a congruence
end_comment

begin_comment
comment|// class, or during register allocation to model liveness of a physical
end_comment

begin_comment
comment|// register.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_LIVEINTERVALUNION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_LIVEINTERVALUNION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/IntervalMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/LiveInterval.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SlotIndexes.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|TargetRegisterInfo
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// forward declaration
name|template
operator|<
name|unsigned
name|Element
operator|>
name|class
name|SparseBitVector
expr_stmt|;
typedef|typedef
name|SparseBitVector
operator|<
literal|128
operator|>
name|LiveVirtRegBitSet
expr_stmt|;
endif|#
directive|endif
comment|/// Union of live intervals that are strong candidates for coalescing into a
comment|/// single register (either physical or virtual depending on the context).  We
comment|/// expect the constituent live intervals to be disjoint, although we may
comment|/// eventually make exceptions to handle value-based interference.
name|class
name|LiveIntervalUnion
block|{
comment|// A set of live virtual register segments that supports fast insertion,
comment|// intersection, and removal.
comment|// Mapping SlotIndex intervals to virtual register numbers.
typedef|typedef
name|IntervalMap
operator|<
name|SlotIndex
operator|,
name|LiveInterval
operator|*
operator|>
name|LiveSegments
expr_stmt|;
name|public
label|:
comment|// SegmentIter can advance to the next segment ordered by starting position
comment|// which may belong to a different live virtual register. We also must be able
comment|// to reach the current segment's containing virtual register.
typedef|typedef
name|LiveSegments
operator|::
name|iterator
name|SegmentIter
expr_stmt|;
comment|/// Const version of SegmentIter.
typedef|typedef
name|LiveSegments
operator|::
name|const_iterator
name|ConstSegmentIter
expr_stmt|;
comment|// LiveIntervalUnions share an external allocator.
typedef|typedef
name|LiveSegments
operator|::
name|Allocator
name|Allocator
expr_stmt|;
name|private
label|:
name|unsigned
name|Tag
init|=
literal|0
decl_stmt|;
comment|// unique tag for current contents.
name|LiveSegments
name|Segments
decl_stmt|;
comment|// union of virtual reg segments
name|public
label|:
name|explicit
name|LiveIntervalUnion
argument_list|(
name|Allocator
operator|&
name|a
argument_list|)
operator|:
name|Segments
argument_list|(
argument|a
argument_list|)
block|{}
comment|// Iterate over all segments in the union of live virtual registers ordered
comment|// by their starting position.
name|SegmentIter
name|begin
argument_list|()
block|{
return|return
name|Segments
operator|.
name|begin
argument_list|()
return|;
block|}
name|SegmentIter
name|end
parameter_list|()
block|{
return|return
name|Segments
operator|.
name|end
argument_list|()
return|;
block|}
name|SegmentIter
name|find
parameter_list|(
name|SlotIndex
name|x
parameter_list|)
block|{
return|return
name|Segments
operator|.
name|find
argument_list|(
name|x
argument_list|)
return|;
block|}
name|ConstSegmentIter
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Segments
operator|.
name|begin
argument_list|()
return|;
block|}
name|ConstSegmentIter
name|end
argument_list|()
specifier|const
block|{
return|return
name|Segments
operator|.
name|end
argument_list|()
return|;
block|}
name|ConstSegmentIter
name|find
argument_list|(
name|SlotIndex
name|x
argument_list|)
decl|const
block|{
return|return
name|Segments
operator|.
name|find
argument_list|(
name|x
argument_list|)
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Segments
operator|.
name|empty
argument_list|()
return|;
block|}
name|SlotIndex
name|startIndex
argument_list|()
specifier|const
block|{
return|return
name|Segments
operator|.
name|start
argument_list|()
return|;
block|}
comment|// Provide public access to the underlying map to allow overlap iteration.
typedef|typedef
name|LiveSegments
name|Map
typedef|;
specifier|const
name|Map
operator|&
name|getMap
argument_list|()
specifier|const
block|{
return|return
name|Segments
return|;
block|}
comment|/// getTag - Return an opaque tag representing the current state of the union.
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|Tag
return|;
block|}
comment|/// changedSince - Return true if the union change since getTag returned tag.
name|bool
name|changedSince
argument_list|(
name|unsigned
name|tag
argument_list|)
decl|const
block|{
return|return
name|tag
operator|!=
name|Tag
return|;
block|}
comment|// Add a live virtual register to this union and merge its segments.
name|void
name|unify
parameter_list|(
name|LiveInterval
modifier|&
name|VirtReg
parameter_list|,
specifier|const
name|LiveRange
modifier|&
name|Range
parameter_list|)
function_decl|;
comment|// Remove a live virtual register's segments from this union.
name|void
name|extract
parameter_list|(
name|LiveInterval
modifier|&
name|VirtReg
parameter_list|,
specifier|const
name|LiveRange
modifier|&
name|Range
parameter_list|)
function_decl|;
comment|// Remove all inserted virtual registers.
name|void
name|clear
parameter_list|()
block|{
name|Segments
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|++
name|Tag
expr_stmt|;
block|}
comment|// Print union, using TRI to translate register names
name|void
name|print
parameter_list|(
name|raw_ostream
modifier|&
name|OS
parameter_list|,
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
parameter_list|)
function|const;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Verify the live intervals in this union and add them to the visited set.
name|void
name|verify
parameter_list|(
name|LiveVirtRegBitSet
modifier|&
name|VisitedVRegs
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/// Query interferences between a single live virtual register and a live
comment|/// interval union.
name|class
name|Query
block|{
specifier|const
name|LiveIntervalUnion
modifier|*
name|LiveUnion
init|=
name|nullptr
decl_stmt|;
specifier|const
name|LiveRange
modifier|*
name|LR
init|=
name|nullptr
decl_stmt|;
name|LiveRange
operator|::
name|const_iterator
name|LRI
expr_stmt|;
comment|///< current position in LR
name|ConstSegmentIter
name|LiveUnionI
decl_stmt|;
comment|///< current position in LiveUnion
name|SmallVector
operator|<
name|LiveInterval
operator|*
operator|,
literal|4
operator|>
name|InterferingVRegs
expr_stmt|;
name|bool
name|CheckedFirstInterference
init|=
name|false
decl_stmt|;
name|bool
name|SeenAllInterferences
init|=
name|false
decl_stmt|;
name|unsigned
name|Tag
init|=
literal|0
decl_stmt|;
name|unsigned
name|UserTag
init|=
literal|0
decl_stmt|;
name|void
name|reset
parameter_list|(
name|unsigned
name|NewUserTag
parameter_list|,
specifier|const
name|LiveRange
modifier|&
name|NewLR
parameter_list|,
specifier|const
name|LiveIntervalUnion
modifier|&
name|NewLiveUnion
parameter_list|)
block|{
name|LiveUnion
operator|=
operator|&
name|NewLiveUnion
expr_stmt|;
name|LR
operator|=
operator|&
name|NewLR
expr_stmt|;
name|InterferingVRegs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|CheckedFirstInterference
operator|=
name|false
expr_stmt|;
name|SeenAllInterferences
operator|=
name|false
expr_stmt|;
name|Tag
operator|=
name|NewLiveUnion
operator|.
name|getTag
argument_list|()
expr_stmt|;
name|UserTag
operator|=
name|NewUserTag
expr_stmt|;
block|}
name|public
label|:
name|Query
argument_list|()
operator|=
expr|default
expr_stmt|;
name|Query
argument_list|(
specifier|const
name|LiveRange
operator|&
name|LR
argument_list|,
specifier|const
name|LiveIntervalUnion
operator|&
name|LIU
argument_list|)
operator|:
name|LiveUnion
argument_list|(
operator|&
name|LIU
argument_list|)
operator|,
name|LR
argument_list|(
argument|&LR
argument_list|)
block|{}
name|Query
argument_list|(
specifier|const
name|Query
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|Query
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Query
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|void
name|init
parameter_list|(
name|unsigned
name|NewUserTag
parameter_list|,
specifier|const
name|LiveRange
modifier|&
name|NewLR
parameter_list|,
specifier|const
name|LiveIntervalUnion
modifier|&
name|NewLiveUnion
parameter_list|)
block|{
if|if
condition|(
name|UserTag
operator|==
name|NewUserTag
operator|&&
name|LR
operator|==
operator|&
name|NewLR
operator|&&
name|LiveUnion
operator|==
operator|&
name|NewLiveUnion
operator|&&
operator|!
name|NewLiveUnion
operator|.
name|changedSince
argument_list|(
name|Tag
argument_list|)
condition|)
block|{
comment|// Retain cached results, e.g. firstInterference.
return|return;
block|}
name|reset
argument_list|(
name|NewUserTag
argument_list|,
name|NewLR
argument_list|,
name|NewLiveUnion
argument_list|)
expr_stmt|;
block|}
comment|// Does this live virtual register interfere with the union?
name|bool
name|checkInterference
parameter_list|()
block|{
return|return
name|collectInterferingVRegs
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|// Count the virtual registers in this union that interfere with this
comment|// query's live virtual register, up to maxInterferingRegs.
name|unsigned
name|collectInterferingVRegs
parameter_list|(
name|unsigned
name|MaxInterferingRegs
init|=
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
argument_list|()
parameter_list|)
function_decl|;
comment|// Was this virtual register visited during collectInterferingVRegs?
name|bool
name|isSeenInterference
argument_list|(
name|LiveInterval
operator|*
name|VReg
argument_list|)
decl|const
decl_stmt|;
comment|// Did collectInterferingVRegs collect all interferences?
name|bool
name|seenAllInterferences
argument_list|()
specifier|const
block|{
return|return
name|SeenAllInterferences
return|;
block|}
comment|// Vector generated by collectInterferingVRegs.
specifier|const
name|SmallVectorImpl
operator|<
name|LiveInterval
operator|*
operator|>
operator|&
name|interferingVRegs
argument_list|()
specifier|const
block|{
return|return
name|InterferingVRegs
return|;
block|}
block|}
empty_stmt|;
comment|// Array of LiveIntervalUnions.
name|class
name|Array
block|{
name|unsigned
name|Size
init|=
literal|0
decl_stmt|;
name|LiveIntervalUnion
modifier|*
name|LIUs
init|=
name|nullptr
decl_stmt|;
name|public
label|:
name|Array
argument_list|()
operator|=
expr|default
expr_stmt|;
operator|~
name|Array
argument_list|()
block|{
name|clear
argument_list|()
block|; }
comment|// Initialize the array to have Size entries.
comment|// Reuse an existing allocation if the size matches.
name|void
name|init
argument_list|(
argument|LiveIntervalUnion::Allocator&
argument_list|,
argument|unsigned Size
argument_list|)
expr_stmt|;
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|void
name|clear
parameter_list|()
function_decl|;
name|LiveIntervalUnion
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|idx
operator|<
name|Size
operator|&&
literal|"idx out of bounds"
argument_list|)
expr_stmt|;
return|return
name|LIUs
index|[
name|idx
index|]
return|;
block|}
specifier|const
name|LiveIntervalUnion
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|Size
operator|&&
literal|"Idx out of bounds"
argument_list|)
expr_stmt|;
return|return
name|LIUs
index|[
name|Idx
index|]
return|;
block|}
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_LIVEINTERVALUNION_H
end_comment

end_unit

