begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- RegisterPressure.h - Dynamic Register Pressure -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the RegisterPressure class which can be used to track
end_comment

begin_comment
comment|// MachineInstr level register pressure.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_REGISTERPRESSURE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_REGISTERPRESSURE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SparseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SlotIndexes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/LaneBitmask.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|LiveIntervals
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|RegisterClassInfo
decl_stmt|;
struct|struct
name|RegisterMaskPair
block|{
name|unsigned
name|RegUnit
decl_stmt|;
comment|///< Virtual register or register unit.
name|LaneBitmask
name|LaneMask
decl_stmt|;
name|RegisterMaskPair
argument_list|(
argument|unsigned RegUnit
argument_list|,
argument|LaneBitmask LaneMask
argument_list|)
block|:
name|RegUnit
argument_list|(
name|RegUnit
argument_list|)
operator|,
name|LaneMask
argument_list|(
argument|LaneMask
argument_list|)
block|{}
block|}
struct|;
comment|/// Base class for register pressure results.
struct|struct
name|RegisterPressure
block|{
comment|/// Map of max reg pressure indexed by pressure set ID, not class ID.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|MaxSetPressure
expr_stmt|;
comment|/// List of live in virtual registers or physical register units.
name|SmallVector
operator|<
name|RegisterMaskPair
operator|,
literal|8
operator|>
name|LiveInRegs
expr_stmt|;
name|SmallVector
operator|<
name|RegisterMaskPair
operator|,
literal|8
operator|>
name|LiveOutRegs
expr_stmt|;
name|void
name|dump
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
comment|/// RegisterPressure computed within a region of instructions delimited by
comment|/// TopIdx and BottomIdx.  During pressure computation, the maximum pressure per
comment|/// register pressure set is increased. Once pressure within a region is fully
comment|/// computed, the live-in and live-out sets are recorded.
comment|///
comment|/// This is preferable to RegionPressure when LiveIntervals are available,
comment|/// because delimiting regions by SlotIndex is more robust and convenient than
comment|/// holding block iterators. The block contents can change without invalidating
comment|/// the pressure result.
name|struct
name|IntervalPressure
range|:
name|RegisterPressure
block|{
comment|/// Record the boundary of the region being tracked.
name|SlotIndex
name|TopIdx
block|;
name|SlotIndex
name|BottomIdx
block|;
name|void
name|reset
argument_list|()
block|;
name|void
name|openTop
argument_list|(
argument|SlotIndex NextTop
argument_list|)
block|;
name|void
name|openBottom
argument_list|(
argument|SlotIndex PrevBottom
argument_list|)
block|; }
decl_stmt|;
comment|/// RegisterPressure computed within a region of instructions delimited by
comment|/// TopPos and BottomPos. This is a less precise version of IntervalPressure for
comment|/// use when LiveIntervals are unavailable.
name|struct
name|RegionPressure
range|:
name|RegisterPressure
block|{
comment|/// Record the boundary of the region being tracked.
name|MachineBasicBlock
operator|::
name|const_iterator
name|TopPos
block|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|BottomPos
block|;
name|void
name|reset
argument_list|()
block|;
name|void
name|openTop
argument_list|(
argument|MachineBasicBlock::const_iterator PrevTop
argument_list|)
block|;
name|void
name|openBottom
argument_list|(
argument|MachineBasicBlock::const_iterator PrevBottom
argument_list|)
block|; }
decl_stmt|;
comment|/// Capture a change in pressure for a single pressure set. UnitInc may be
comment|/// expressed in terms of upward or downward pressure depending on the client
comment|/// and will be dynamically adjusted for current liveness.
comment|///
comment|/// Pressure increments are tiny, typically 1-2 units, and this is only for
comment|/// heuristics, so we don't check UnitInc overflow. Instead, we may have a
comment|/// higher level assert that pressure is consistent within a region. We also
comment|/// effectively ignore dead defs which don't affect heuristics much.
name|class
name|PressureChange
block|{
name|uint16_t
name|PSetID
init|=
literal|0
decl_stmt|;
comment|// ID+1. 0=Invalid.
name|int16_t
name|UnitInc
init|=
literal|0
decl_stmt|;
name|public
label|:
name|PressureChange
argument_list|()
operator|=
expr|default
expr_stmt|;
name|PressureChange
argument_list|(
argument|unsigned id
argument_list|)
block|:
name|PSetID
argument_list|(
argument|id +
literal|1
argument_list|)
block|{
name|assert
argument_list|(
name|id
operator|<
name|std
operator|::
name|numeric_limits
operator|<
name|uint16_t
operator|>
operator|::
name|max
argument_list|()
operator|&&
literal|"PSetID overflow."
argument_list|)
expr_stmt|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|PSetID
operator|>
literal|0
return|;
block|}
name|unsigned
name|getPSet
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
operator|&&
literal|"invalid PressureChange"
argument_list|)
block|;
return|return
name|PSetID
operator|-
literal|1
return|;
block|}
comment|// If PSetID is invalid, return UINT16_MAX to give it lowest priority.
name|unsigned
name|getPSetOrMax
argument_list|()
specifier|const
block|{
return|return
operator|(
name|PSetID
operator|-
literal|1
operator|)
operator|&
name|std
operator|::
name|numeric_limits
operator|<
name|uint16_t
operator|>
operator|::
name|max
argument_list|()
return|;
block|}
name|int
name|getUnitInc
argument_list|()
specifier|const
block|{
return|return
name|UnitInc
return|;
block|}
name|void
name|setUnitInc
parameter_list|(
name|int
name|Inc
parameter_list|)
block|{
name|UnitInc
operator|=
name|Inc
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|PressureChange
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|PSetID
operator|==
name|RHS
operator|.
name|PSetID
operator|&&
name|UnitInc
operator|==
name|RHS
operator|.
name|UnitInc
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|PressureChange
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
comment|/// List of PressureChanges in order of increasing, unique PSetID.
comment|///
comment|/// Use a small fixed number, because we can fit more PressureChanges in an
comment|/// empty SmallVector than ever need to be tracked per register class. If more
comment|/// PSets are affected, then we only track the most constrained.
name|class
name|PressureDiff
block|{
comment|// The initial design was for MaxPSets=4, but that requires PSet partitions,
comment|// which are not yet implemented. (PSet partitions are equivalent PSets given
comment|// the register classes actually in use within the scheduling region.)
enum|enum
block|{
name|MaxPSets
init|=
literal|16
block|}
enum|;
name|PressureChange
name|PressureChanges
index|[
name|MaxPSets
index|]
decl_stmt|;
typedef|typedef
name|PressureChange
modifier|*
name|iterator
typedef|;
name|iterator
name|nonconst_begin
parameter_list|()
block|{
return|return
operator|&
name|PressureChanges
index|[
literal|0
index|]
return|;
block|}
name|iterator
name|nonconst_end
parameter_list|()
block|{
return|return
operator|&
name|PressureChanges
index|[
name|MaxPSets
index|]
return|;
block|}
name|public
label|:
typedef|typedef
specifier|const
name|PressureChange
modifier|*
name|const_iterator
typedef|;
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|&
name|PressureChanges
index|[
literal|0
index|]
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|&
name|PressureChanges
index|[
name|MaxPSets
index|]
return|;
block|}
name|void
name|addPressureChange
parameter_list|(
name|unsigned
name|RegUnit
parameter_list|,
name|bool
name|IsDec
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
parameter_list|)
function_decl|;
name|void
name|dump
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|&
name|TRI
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|/// List of registers defined and used by a machine instruction.
name|class
name|RegisterOperands
block|{
name|public
label|:
comment|/// List of virtual registers and register units read by the instruction.
name|SmallVector
operator|<
name|RegisterMaskPair
operator|,
literal|8
operator|>
name|Uses
expr_stmt|;
comment|/// \brief List of virtual registers and register units defined by the
comment|/// instruction which are not dead.
name|SmallVector
operator|<
name|RegisterMaskPair
operator|,
literal|8
operator|>
name|Defs
expr_stmt|;
comment|/// \brief List of virtual registers and register units defined by the
comment|/// instruction but dead.
name|SmallVector
operator|<
name|RegisterMaskPair
operator|,
literal|8
operator|>
name|DeadDefs
expr_stmt|;
comment|/// Analyze the given instruction \p MI and fill in the Uses, Defs and
comment|/// DeadDefs list based on the MachineOperand flags.
name|void
name|collect
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|,
specifier|const
name|TargetRegisterInfo
modifier|&
name|TRI
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|&
name|MRI
parameter_list|,
name|bool
name|TrackLaneMasks
parameter_list|,
name|bool
name|IgnoreDead
parameter_list|)
function_decl|;
comment|/// Use liveness information to find dead defs not marked with a dead flag
comment|/// and move them to the DeadDefs vector.
name|void
name|detectDeadDefs
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|,
specifier|const
name|LiveIntervals
modifier|&
name|LIS
parameter_list|)
function_decl|;
comment|/// Use liveness information to find out which uses/defs are partially
comment|/// undefined/dead and adjust the RegisterMaskPairs accordingly.
comment|/// If \p AddFlagsMI is given then missing read-undef and dead flags will be
comment|/// added to the instruction.
name|void
name|adjustLaneLiveness
parameter_list|(
specifier|const
name|LiveIntervals
modifier|&
name|LIS
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|&
name|MRI
parameter_list|,
name|SlotIndex
name|Pos
parameter_list|,
name|MachineInstr
modifier|*
name|AddFlagsMI
init|=
name|nullptr
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// Array of PressureDiffs.
name|class
name|PressureDiffs
block|{
name|PressureDiff
modifier|*
name|PDiffArray
init|=
name|nullptr
decl_stmt|;
name|unsigned
name|Size
init|=
literal|0
decl_stmt|;
name|unsigned
name|Max
init|=
literal|0
decl_stmt|;
name|public
label|:
name|PressureDiffs
argument_list|()
operator|=
expr|default
expr_stmt|;
operator|~
name|PressureDiffs
argument_list|()
block|{
name|free
argument_list|(
name|PDiffArray
argument_list|)
block|; }
name|void
name|clear
argument_list|()
block|{
name|Size
operator|=
literal|0
block|; }
name|void
name|init
argument_list|(
argument|unsigned N
argument_list|)
expr_stmt|;
name|PressureDiff
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|Size
operator|&&
literal|"PressureDiff index out of bounds"
argument_list|)
expr_stmt|;
return|return
name|PDiffArray
index|[
name|Idx
index|]
return|;
block|}
specifier|const
name|PressureDiff
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|PressureDiffs
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|operator
index|[]
operator|(
name|Idx
operator|)
return|;
block|}
comment|/// \brief Record pressure difference induced by the given operand list to
comment|/// node with index \p Idx.
name|void
name|addInstruction
parameter_list|(
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|RegisterOperands
modifier|&
name|RegOpers
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|&
name|MRI
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// Store the effects of a change in pressure on things that MI scheduler cares
comment|/// about.
comment|///
comment|/// Excess records the value of the largest difference in register units beyond
comment|/// the target's pressure limits across the affected pressure sets, where
comment|/// largest is defined as the absolute value of the difference. Negative
comment|/// ExcessUnits indicates a reduction in pressure that had already exceeded the
comment|/// target's limits.
comment|///
comment|/// CriticalMax records the largest increase in the tracker's max pressure that
comment|/// exceeds the critical limit for some pressure set determined by the client.
comment|///
comment|/// CurrentMax records the largest increase in the tracker's max pressure that
comment|/// exceeds the current limit for some pressure set determined by the client.
struct|struct
name|RegPressureDelta
block|{
name|PressureChange
name|Excess
decl_stmt|;
name|PressureChange
name|CriticalMax
decl_stmt|;
name|PressureChange
name|CurrentMax
decl_stmt|;
name|RegPressureDelta
argument_list|()
operator|=
expr|default
expr_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RegPressureDelta
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Excess
operator|==
name|RHS
operator|.
name|Excess
operator|&&
name|CriticalMax
operator|==
name|RHS
operator|.
name|CriticalMax
operator|&&
name|CurrentMax
operator|==
name|RHS
operator|.
name|CurrentMax
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|RegPressureDelta
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|RHS
operator|)
return|;
block|}
block|}
struct|;
comment|/// A set of live virtual registers and physical register units.
comment|///
comment|/// This is a wrapper around a SparseSet which deals with mapping register unit
comment|/// and virtual register indexes to an index usable by the sparse set.
name|class
name|LiveRegSet
block|{
name|private
label|:
struct|struct
name|IndexMaskPair
block|{
name|unsigned
name|Index
decl_stmt|;
name|LaneBitmask
name|LaneMask
decl_stmt|;
name|IndexMaskPair
argument_list|(
argument|unsigned Index
argument_list|,
argument|LaneBitmask LaneMask
argument_list|)
block|:
name|Index
argument_list|(
name|Index
argument_list|)
operator|,
name|LaneMask
argument_list|(
argument|LaneMask
argument_list|)
block|{}
name|unsigned
name|getSparseSetIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
block|}
struct|;
typedef|typedef
name|SparseSet
operator|<
name|IndexMaskPair
operator|>
name|RegSet
expr_stmt|;
name|RegSet
name|Regs
decl_stmt|;
name|unsigned
name|NumRegUnits
decl_stmt|;
name|unsigned
name|getSparseIndexFromReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
if|if
condition|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
name|TargetRegisterInfo
operator|::
name|virtReg2Index
argument_list|(
name|Reg
argument_list|)
operator|+
name|NumRegUnits
return|;
name|assert
argument_list|(
name|Reg
operator|<
name|NumRegUnits
argument_list|)
expr_stmt|;
return|return
name|Reg
return|;
block|}
name|unsigned
name|getRegFromSparseIndex
argument_list|(
name|unsigned
name|SparseIndex
argument_list|)
decl|const
block|{
if|if
condition|(
name|SparseIndex
operator|>=
name|NumRegUnits
condition|)
return|return
name|TargetRegisterInfo
operator|::
name|index2VirtReg
argument_list|(
name|SparseIndex
operator|-
name|NumRegUnits
argument_list|)
return|;
return|return
name|SparseIndex
return|;
block|}
name|public
label|:
name|void
name|clear
parameter_list|()
function_decl|;
name|void
name|init
parameter_list|(
specifier|const
name|MachineRegisterInfo
modifier|&
name|MRI
parameter_list|)
function_decl|;
name|LaneBitmask
name|contains
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
name|unsigned
name|SparseIndex
init|=
name|getSparseIndexFromReg
argument_list|(
name|Reg
argument_list|)
decl_stmt|;
name|RegSet
operator|::
name|const_iterator
name|I
operator|=
name|Regs
operator|.
name|find
argument_list|(
name|SparseIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|Regs
operator|.
name|end
argument_list|()
condition|)
return|return
name|LaneBitmask
operator|::
name|getNone
argument_list|()
return|;
return|return
name|I
operator|->
name|LaneMask
return|;
block|}
comment|/// Mark the \p Pair.LaneMask lanes of \p Pair.Reg as live.
comment|/// Returns the previously live lanes of \p Pair.Reg.
name|LaneBitmask
name|insert
parameter_list|(
name|RegisterMaskPair
name|Pair
parameter_list|)
block|{
name|unsigned
name|SparseIndex
init|=
name|getSparseIndexFromReg
argument_list|(
name|Pair
operator|.
name|RegUnit
argument_list|)
decl_stmt|;
name|auto
name|InsertRes
init|=
name|Regs
operator|.
name|insert
argument_list|(
name|IndexMaskPair
argument_list|(
name|SparseIndex
argument_list|,
name|Pair
operator|.
name|LaneMask
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|InsertRes
operator|.
name|second
condition|)
block|{
name|LaneBitmask
name|PrevMask
init|=
name|InsertRes
operator|.
name|first
operator|->
name|LaneMask
decl_stmt|;
name|InsertRes
operator|.
name|first
operator|->
name|LaneMask
operator||=
name|Pair
operator|.
name|LaneMask
expr_stmt|;
return|return
name|PrevMask
return|;
block|}
return|return
name|LaneBitmask
operator|::
name|getNone
argument_list|()
return|;
block|}
comment|/// Clears the \p Pair.LaneMask lanes of \p Pair.Reg (mark them as dead).
comment|/// Returns the previously live lanes of \p Pair.Reg.
name|LaneBitmask
name|erase
parameter_list|(
name|RegisterMaskPair
name|Pair
parameter_list|)
block|{
name|unsigned
name|SparseIndex
init|=
name|getSparseIndexFromReg
argument_list|(
name|Pair
operator|.
name|RegUnit
argument_list|)
decl_stmt|;
name|RegSet
operator|::
name|iterator
name|I
operator|=
name|Regs
operator|.
name|find
argument_list|(
name|SparseIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|Regs
operator|.
name|end
argument_list|()
condition|)
return|return
name|LaneBitmask
operator|::
name|getNone
argument_list|()
return|;
name|LaneBitmask
name|PrevMask
init|=
name|I
operator|->
name|LaneMask
decl_stmt|;
name|I
operator|->
name|LaneMask
operator|&=
operator|~
name|Pair
operator|.
name|LaneMask
expr_stmt|;
return|return
name|PrevMask
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Regs
operator|.
name|size
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|ContainerT
operator|>
name|void
name|appendTo
argument_list|(
argument|ContainerT&To
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|IndexMaskPair
modifier|&
name|P
range|:
name|Regs
control|)
block|{
name|unsigned
name|Reg
init|=
name|getRegFromSparseIndex
argument_list|(
name|P
operator|.
name|Index
argument_list|)
decl_stmt|;
if|if
condition|(
name|P
operator|.
name|LaneMask
operator|.
name|any
argument_list|()
condition|)
name|To
operator|.
name|push_back
argument_list|(
name|RegisterMaskPair
argument_list|(
name|Reg
argument_list|,
name|P
operator|.
name|LaneMask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
empty_stmt|;
comment|/// Track the current register pressure at some position in the instruction
comment|/// stream, and remember the high water mark within the region traversed. This
comment|/// does not automatically consider live-through ranges. The client may
comment|/// independently adjust for global liveness.
comment|///
comment|/// Each RegPressureTracker only works within a MachineBasicBlock. Pressure can
comment|/// be tracked across a larger region by storing a RegisterPressure result at
comment|/// each block boundary and explicitly adjusting pressure to account for block
comment|/// live-in and live-out register sets.
comment|///
comment|/// RegPressureTracker holds a reference to a RegisterPressure result that it
comment|/// computes incrementally. During downward tracking, P.BottomIdx or P.BottomPos
comment|/// is invalid until it reaches the end of the block or closeRegion() is
comment|/// explicitly called. Similarly, P.TopIdx is invalid during upward
comment|/// tracking. Changing direction has the side effect of closing region, and
comment|/// traversing past TopIdx or BottomIdx reopens it.
name|class
name|RegPressureTracker
block|{
specifier|const
name|MachineFunction
modifier|*
name|MF
init|=
name|nullptr
decl_stmt|;
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
init|=
name|nullptr
decl_stmt|;
specifier|const
name|RegisterClassInfo
modifier|*
name|RCI
init|=
name|nullptr
decl_stmt|;
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
decl_stmt|;
specifier|const
name|LiveIntervals
modifier|*
name|LIS
init|=
name|nullptr
decl_stmt|;
comment|/// We currently only allow pressure tracking within a block.
specifier|const
name|MachineBasicBlock
modifier|*
name|MBB
init|=
name|nullptr
decl_stmt|;
comment|/// Track the max pressure within the region traversed so far.
name|RegisterPressure
modifier|&
name|P
decl_stmt|;
comment|/// Run in two modes dependending on whether constructed with IntervalPressure
comment|/// or RegisterPressure. If requireIntervals is false, LIS are ignored.
name|bool
name|RequireIntervals
decl_stmt|;
comment|/// True if UntiedDefs will be populated.
name|bool
name|TrackUntiedDefs
init|=
name|false
decl_stmt|;
comment|/// True if lanemasks should be tracked.
name|bool
name|TrackLaneMasks
init|=
name|false
decl_stmt|;
comment|/// Register pressure corresponds to liveness before this instruction
comment|/// iterator. It may point to the end of the block or a DebugValue rather than
comment|/// an instruction.
name|MachineBasicBlock
operator|::
name|const_iterator
name|CurrPos
expr_stmt|;
comment|/// Pressure map indexed by pressure set ID, not class ID.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|CurrSetPressure
expr_stmt|;
comment|/// Set of live registers.
name|LiveRegSet
name|LiveRegs
decl_stmt|;
comment|/// Set of vreg defs that start a live range.
name|SparseSet
operator|<
name|unsigned
operator|,
name|VirtReg2IndexFunctor
operator|>
name|UntiedDefs
expr_stmt|;
comment|/// Live-through pressure.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LiveThruPressure
expr_stmt|;
name|public
label|:
name|RegPressureTracker
argument_list|(
name|IntervalPressure
operator|&
name|rp
argument_list|)
operator|:
name|P
argument_list|(
name|rp
argument_list|)
operator|,
name|RequireIntervals
argument_list|(
argument|true
argument_list|)
block|{}
name|RegPressureTracker
argument_list|(
name|RegionPressure
operator|&
name|rp
argument_list|)
operator|:
name|P
argument_list|(
name|rp
argument_list|)
operator|,
name|RequireIntervals
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|reset
argument_list|()
expr_stmt|;
name|void
name|init
argument_list|(
specifier|const
name|MachineFunction
operator|*
name|mf
argument_list|,
specifier|const
name|RegisterClassInfo
operator|*
name|rci
argument_list|,
specifier|const
name|LiveIntervals
operator|*
name|lis
argument_list|,
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|,
name|MachineBasicBlock
operator|::
name|const_iterator
name|pos
argument_list|,
name|bool
name|TrackLaneMasks
argument_list|,
name|bool
name|TrackUntiedDefs
argument_list|)
decl_stmt|;
comment|/// Force liveness of virtual registers or physical register
comment|/// units. Particularly useful to initialize the livein/out state of the
comment|/// tracker before the first call to advance/recede.
name|void
name|addLiveRegs
argument_list|(
name|ArrayRef
operator|<
name|RegisterMaskPair
operator|>
name|Regs
argument_list|)
decl_stmt|;
comment|/// Get the MI position corresponding to this register pressure.
name|MachineBasicBlock
operator|::
name|const_iterator
name|getPos
argument_list|()
specifier|const
block|{
return|return
name|CurrPos
return|;
block|}
comment|// Reset the MI position corresponding to the register pressure. This allows
comment|// schedulers to move instructions above the RegPressureTracker's
comment|// CurrPos. Since the pressure is computed before CurrPos, the iterator
comment|// position changes while pressure does not.
name|void
name|setPos
argument_list|(
name|MachineBasicBlock
operator|::
name|const_iterator
name|Pos
argument_list|)
block|{
name|CurrPos
operator|=
name|Pos
expr_stmt|;
block|}
comment|/// Recede across the previous instruction.
name|void
name|recede
argument_list|(
name|SmallVectorImpl
operator|<
name|RegisterMaskPair
operator|>
operator|*
name|LiveUses
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Recede across the previous instruction.
comment|/// This "low-level" variant assumes that recedeSkipDebugValues() was
comment|/// called previously and takes precomputed RegisterOperands for the
comment|/// instruction.
name|void
name|recede
argument_list|(
specifier|const
name|RegisterOperands
operator|&
name|RegOpers
argument_list|,
name|SmallVectorImpl
operator|<
name|RegisterMaskPair
operator|>
operator|*
name|LiveUses
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Recede until we find an instruction which is not a DebugValue.
name|void
name|recedeSkipDebugValues
parameter_list|()
function_decl|;
comment|/// Advance across the current instruction.
name|void
name|advance
parameter_list|()
function_decl|;
comment|/// Advance across the current instruction.
comment|/// This is a "low-level" variant of advance() which takes precomputed
comment|/// RegisterOperands of the instruction.
name|void
name|advance
parameter_list|(
specifier|const
name|RegisterOperands
modifier|&
name|RegOpers
parameter_list|)
function_decl|;
comment|/// Finalize the region boundaries and recored live ins and live outs.
name|void
name|closeRegion
parameter_list|()
function_decl|;
comment|/// Initialize the LiveThru pressure set based on the untied defs found in
comment|/// RPTracker.
name|void
name|initLiveThru
parameter_list|(
specifier|const
name|RegPressureTracker
modifier|&
name|RPTracker
parameter_list|)
function_decl|;
comment|/// Copy an existing live thru pressure result.
name|void
name|initLiveThru
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|PressureSet
argument_list|)
block|{
name|LiveThruPressure
operator|.
name|assign
argument_list|(
name|PressureSet
operator|.
name|begin
argument_list|()
argument_list|,
name|PressureSet
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArrayRef
operator|<
name|unsigned
operator|>
name|getLiveThru
argument_list|()
specifier|const
block|{
return|return
name|LiveThruPressure
return|;
block|}
comment|/// Get the resulting register pressure over the traversed region.
comment|/// This result is complete if closeRegion() was explicitly invoked.
name|RegisterPressure
modifier|&
name|getPressure
parameter_list|()
block|{
return|return
name|P
return|;
block|}
specifier|const
name|RegisterPressure
operator|&
name|getPressure
argument_list|()
specifier|const
block|{
return|return
name|P
return|;
block|}
comment|/// Get the register set pressure at the current position, which may be less
comment|/// than the pressure across the traversed region.
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getRegSetPressureAtPos
argument_list|()
specifier|const
block|{
return|return
name|CurrSetPressure
return|;
block|}
name|bool
name|isTopClosed
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isBottomClosed
argument_list|()
specifier|const
expr_stmt|;
name|void
name|closeTop
parameter_list|()
function_decl|;
name|void
name|closeBottom
parameter_list|()
function_decl|;
comment|/// Consider the pressure increase caused by traversing this instruction
comment|/// bottom-up. Find the pressure set with the most change beyond its pressure
comment|/// limit based on the tracker's current pressure, and record the number of
comment|/// excess register units of that pressure set introduced by this instruction.
name|void
name|getMaxUpwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|PressureDiff
operator|*
name|PDiff
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl_stmt|;
name|void
name|getUpwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
comment|/*const*/
name|PressureDiff
operator|&
name|PDiff
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl|const
decl_stmt|;
comment|/// Consider the pressure increase caused by traversing this instruction
comment|/// top-down. Find the pressure set with the most change beyond its pressure
comment|/// limit based on the tracker's current pressure, and record the number of
comment|/// excess register units of that pressure set introduced by this instruction.
name|void
name|getMaxDownwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl_stmt|;
comment|/// Find the pressure set with the most change beyond its pressure limit after
comment|/// traversing this instruction either upward or downward depending on the
comment|/// closed end of the current region.
name|void
name|getMaxPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
block|{
if|if
condition|(
name|isTopClosed
argument_list|()
condition|)
return|return
name|getMaxDownwardPressureDelta
argument_list|(
name|MI
argument_list|,
name|Delta
argument_list|,
name|CriticalPSets
argument_list|,
name|MaxPressureLimit
argument_list|)
return|;
name|assert
argument_list|(
name|isBottomClosed
argument_list|()
operator|&&
literal|"Uninitialized pressure tracker"
argument_list|)
expr_stmt|;
return|return
name|getMaxUpwardPressureDelta
argument_list|(
name|MI
argument_list|,
name|nullptr
argument_list|,
name|Delta
argument_list|,
name|CriticalPSets
argument_list|,
name|MaxPressureLimit
argument_list|)
return|;
block|}
comment|/// Get the pressure of each PSet after traversing this instruction bottom-up.
name|void
name|getUpwardPressure
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
decl_stmt|;
comment|/// Get the pressure of each PSet after traversing this instruction top-down.
name|void
name|getDownwardPressure
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
decl_stmt|;
name|void
name|getPressureAfterInst
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
block|{
if|if
condition|(
name|isTopClosed
argument_list|()
condition|)
return|return
name|getUpwardPressure
argument_list|(
name|MI
argument_list|,
name|PressureResult
argument_list|,
name|MaxPressureResult
argument_list|)
return|;
name|assert
argument_list|(
name|isBottomClosed
argument_list|()
operator|&&
literal|"Uninitialized pressure tracker"
argument_list|)
expr_stmt|;
return|return
name|getDownwardPressure
argument_list|(
name|MI
argument_list|,
name|PressureResult
argument_list|,
name|MaxPressureResult
argument_list|)
return|;
block|}
name|bool
name|hasUntiedDef
argument_list|(
name|unsigned
name|VirtReg
argument_list|)
decl|const
block|{
return|return
name|UntiedDefs
operator|.
name|count
argument_list|(
name|VirtReg
argument_list|)
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|protected
label|:
comment|/// Add Reg to the live out set and increase max pressure.
name|void
name|discoverLiveOut
parameter_list|(
name|RegisterMaskPair
name|Pair
parameter_list|)
function_decl|;
comment|/// Add Reg to the live in set and increase max pressure.
name|void
name|discoverLiveIn
parameter_list|(
name|RegisterMaskPair
name|Pair
parameter_list|)
function_decl|;
comment|/// \brief Get the SlotIndex for the first nondebug instruction including or
comment|/// after the current position.
name|SlotIndex
name|getCurrSlot
argument_list|()
specifier|const
expr_stmt|;
name|void
name|increaseRegPressure
parameter_list|(
name|unsigned
name|RegUnit
parameter_list|,
name|LaneBitmask
name|PreviousMask
parameter_list|,
name|LaneBitmask
name|NewMask
parameter_list|)
function_decl|;
name|void
name|decreaseRegPressure
parameter_list|(
name|unsigned
name|RegUnit
parameter_list|,
name|LaneBitmask
name|PreviousMask
parameter_list|,
name|LaneBitmask
name|NewMask
parameter_list|)
function_decl|;
name|void
name|bumpDeadDefs
argument_list|(
name|ArrayRef
operator|<
name|RegisterMaskPair
operator|>
name|DeadDefs
argument_list|)
decl_stmt|;
name|void
name|bumpUpwardPressure
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
name|void
name|bumpDownwardPressure
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
name|void
name|discoverLiveInOrOut
argument_list|(
name|RegisterMaskPair
name|Pair
argument_list|,
name|SmallVectorImpl
operator|<
name|RegisterMaskPair
operator|>
operator|&
name|LiveInOrOut
argument_list|)
decl_stmt|;
name|LaneBitmask
name|getLastUsedLanes
argument_list|(
name|unsigned
name|RegUnit
argument_list|,
name|SlotIndex
name|Pos
argument_list|)
decl|const
decl_stmt|;
name|LaneBitmask
name|getLiveLanesAt
argument_list|(
name|unsigned
name|RegUnit
argument_list|,
name|SlotIndex
name|Pos
argument_list|)
decl|const
decl_stmt|;
name|LaneBitmask
name|getLiveThroughAt
argument_list|(
name|unsigned
name|RegUnit
argument_list|,
name|SlotIndex
name|Pos
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
name|void
name|dumpRegSetPressure
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|SetPressure
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_REGISTERPRESSURE_H
end_comment

end_unit

