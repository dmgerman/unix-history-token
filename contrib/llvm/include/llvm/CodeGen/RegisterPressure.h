begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RegisterPressure.h - Dynamic Register Pressure -*- C++ -*-------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the RegisterPressure class which can be used to track
end_comment

begin_comment
comment|// MachineInstr level register pressure.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_REGISTERPRESSURE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_REGISTERPRESSURE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SparseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SlotIndexes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetRegisterInfo.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|LiveIntervals
decl_stmt|;
name|class
name|LiveRange
decl_stmt|;
name|class
name|RegisterClassInfo
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
comment|/// Base class for register pressure results.
struct|struct
name|RegisterPressure
block|{
comment|/// Map of max reg pressure indexed by pressure set ID, not class ID.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|MaxSetPressure
expr_stmt|;
comment|/// List of live in virtual registers or physical register units.
name|SmallVector
operator|<
name|unsigned
operator|,
literal|8
operator|>
name|LiveInRegs
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|8
operator|>
name|LiveOutRegs
expr_stmt|;
comment|/// Increase register pressure for each pressure set impacted by this register
comment|/// class. Normally called by RegPressureTracker, but may be called manually
comment|/// to account for live through (global liveness).
comment|///
comment|/// \param Reg is either a virtual register number or register unit number.
name|void
name|increase
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
parameter_list|)
function_decl|;
comment|/// Decrease register pressure for each pressure set impacted by this register
comment|/// class. This is only useful to account for spilling or rematerialization.
comment|///
comment|/// \param Reg is either a virtual register number or register unit number.
name|void
name|decrease
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
parameter_list|)
function_decl|;
name|void
name|dump
argument_list|(
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
comment|/// RegisterPressure computed within a region of instructions delimited by
comment|/// TopIdx and BottomIdx.  During pressure computation, the maximum pressure per
comment|/// register pressure set is increased. Once pressure within a region is fully
comment|/// computed, the live-in and live-out sets are recorded.
comment|///
comment|/// This is preferable to RegionPressure when LiveIntervals are available,
comment|/// because delimiting regions by SlotIndex is more robust and convenient than
comment|/// holding block iterators. The block contents can change without invalidating
comment|/// the pressure result.
name|struct
name|IntervalPressure
range|:
name|RegisterPressure
block|{
comment|/// Record the boundary of the region being tracked.
name|SlotIndex
name|TopIdx
block|;
name|SlotIndex
name|BottomIdx
block|;
name|void
name|reset
argument_list|()
block|;
name|void
name|openTop
argument_list|(
argument|SlotIndex NextTop
argument_list|)
block|;
name|void
name|openBottom
argument_list|(
argument|SlotIndex PrevBottom
argument_list|)
block|; }
decl_stmt|;
comment|/// RegisterPressure computed within a region of instructions delimited by
comment|/// TopPos and BottomPos. This is a less precise version of IntervalPressure for
comment|/// use when LiveIntervals are unavailable.
name|struct
name|RegionPressure
range|:
name|RegisterPressure
block|{
comment|/// Record the boundary of the region being tracked.
name|MachineBasicBlock
operator|::
name|const_iterator
name|TopPos
block|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|BottomPos
block|;
name|void
name|reset
argument_list|()
block|;
name|void
name|openTop
argument_list|(
argument|MachineBasicBlock::const_iterator PrevTop
argument_list|)
block|;
name|void
name|openBottom
argument_list|(
argument|MachineBasicBlock::const_iterator PrevBottom
argument_list|)
block|; }
decl_stmt|;
comment|/// Capture a change in pressure for a single pressure set. UnitInc may be
comment|/// expressed in terms of upward or downward pressure depending on the client
comment|/// and will be dynamically adjusted for current liveness.
comment|///
comment|/// Pressure increments are tiny, typically 1-2 units, and this is only for
comment|/// heuristics, so we don't check UnitInc overflow. Instead, we may have a
comment|/// higher level assert that pressure is consistent within a region. We also
comment|/// effectively ignore dead defs which don't affect heuristics much.
name|class
name|PressureChange
block|{
name|uint16_t
name|PSetID
decl_stmt|;
comment|// ID+1. 0=Invalid.
name|int16_t
name|UnitInc
decl_stmt|;
name|public
label|:
name|PressureChange
argument_list|()
operator|:
name|PSetID
argument_list|(
literal|0
argument_list|)
operator|,
name|UnitInc
argument_list|(
literal|0
argument_list|)
block|{}
name|PressureChange
argument_list|(
argument|unsigned id
argument_list|)
operator|:
name|PSetID
argument_list|(
name|id
operator|+
literal|1
argument_list|)
operator|,
name|UnitInc
argument_list|(
literal|0
argument_list|)
block|{
name|assert
argument_list|(
name|id
operator|<
name|UINT16_MAX
operator|&&
literal|"PSetID overflow."
argument_list|)
block|;   }
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|PSetID
operator|>
literal|0
return|;
block|}
name|unsigned
name|getPSet
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
operator|&&
literal|"invalid PressureChange"
argument_list|)
block|;
return|return
name|PSetID
operator|-
literal|1
return|;
block|}
comment|// If PSetID is invalid, return UINT16_MAX to give it lowest priority.
name|unsigned
name|getPSetOrMax
argument_list|()
specifier|const
block|{
return|return
operator|(
name|PSetID
operator|-
literal|1
operator|)
operator|&
name|UINT16_MAX
return|;
block|}
name|int
name|getUnitInc
argument_list|()
specifier|const
block|{
return|return
name|UnitInc
return|;
block|}
name|void
name|setUnitInc
parameter_list|(
name|int
name|Inc
parameter_list|)
block|{
name|UnitInc
operator|=
name|Inc
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|PressureChange
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|PSetID
operator|==
name|RHS
operator|.
name|PSetID
operator|&&
name|UnitInc
operator|==
name|RHS
operator|.
name|UnitInc
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|PressureChange
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
comment|/// List of PressureChanges in order of increasing, unique PSetID.
comment|///
comment|/// Use a small fixed number, because we can fit more PressureChanges in an
comment|/// empty SmallVector than ever need to be tracked per register class. If more
comment|/// PSets are affected, then we only track the most constrained.
name|class
name|PressureDiff
block|{
comment|// The initial design was for MaxPSets=4, but that requires PSet partitions,
comment|// which are not yet implemented. (PSet partitions are equivalent PSets given
comment|// the register classes actually in use within the scheduling region.)
enum|enum
block|{
name|MaxPSets
init|=
literal|16
block|}
enum|;
name|PressureChange
name|PressureChanges
index|[
name|MaxPSets
index|]
decl_stmt|;
name|public
label|:
typedef|typedef
name|PressureChange
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|PressureChange
modifier|*
name|const_iterator
typedef|;
name|iterator
name|begin
parameter_list|()
block|{
return|return
operator|&
name|PressureChanges
index|[
literal|0
index|]
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
operator|&
name|PressureChanges
index|[
name|MaxPSets
index|]
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|&
name|PressureChanges
index|[
literal|0
index|]
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|&
name|PressureChanges
index|[
name|MaxPSets
index|]
return|;
block|}
name|void
name|addPressureChange
parameter_list|(
name|unsigned
name|RegUnit
parameter_list|,
name|bool
name|IsDec
parameter_list|,
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// Array of PressureDiffs.
name|class
name|PressureDiffs
block|{
name|PressureDiff
modifier|*
name|PDiffArray
decl_stmt|;
name|unsigned
name|Size
decl_stmt|;
name|unsigned
name|Max
decl_stmt|;
name|public
label|:
name|PressureDiffs
argument_list|()
operator|:
name|PDiffArray
argument_list|(
literal|0
argument_list|)
operator|,
name|Size
argument_list|(
literal|0
argument_list|)
operator|,
name|Max
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|PressureDiffs
argument_list|()
block|{
name|free
argument_list|(
name|PDiffArray
argument_list|)
block|; }
name|void
name|clear
argument_list|()
block|{
name|Size
operator|=
literal|0
block|; }
name|void
name|init
argument_list|(
argument|unsigned N
argument_list|)
expr_stmt|;
name|PressureDiff
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|Size
operator|&&
literal|"PressureDiff index out of bounds"
argument_list|)
expr_stmt|;
return|return
name|PDiffArray
index|[
name|Idx
index|]
return|;
block|}
specifier|const
name|PressureDiff
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|PressureDiffs
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|operator
index|[]
operator|(
name|Idx
operator|)
return|;
block|}
block|}
empty_stmt|;
comment|/// Store the effects of a change in pressure on things that MI scheduler cares
comment|/// about.
comment|///
comment|/// Excess records the value of the largest difference in register units beyond
comment|/// the target's pressure limits across the affected pressure sets, where
comment|/// largest is defined as the absolute value of the difference. Negative
comment|/// ExcessUnits indicates a reduction in pressure that had already exceeded the
comment|/// target's limits.
comment|///
comment|/// CriticalMax records the largest increase in the tracker's max pressure that
comment|/// exceeds the critical limit for some pressure set determined by the client.
comment|///
comment|/// CurrentMax records the largest increase in the tracker's max pressure that
comment|/// exceeds the current limit for some pressure set determined by the client.
struct|struct
name|RegPressureDelta
block|{
name|PressureChange
name|Excess
decl_stmt|;
name|PressureChange
name|CriticalMax
decl_stmt|;
name|PressureChange
name|CurrentMax
decl_stmt|;
name|RegPressureDelta
argument_list|()
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RegPressureDelta
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Excess
operator|==
name|RHS
operator|.
name|Excess
operator|&&
name|CriticalMax
operator|==
name|RHS
operator|.
name|CriticalMax
operator|&&
name|CurrentMax
operator|==
name|RHS
operator|.
name|CurrentMax
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|RegPressureDelta
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|RHS
operator|)
return|;
block|}
block|}
struct|;
comment|/// \brief A set of live virtual registers and physical register units.
comment|///
comment|/// Virtual and physical register numbers require separate sparse sets, but most
comment|/// of the RegisterPressureTracker handles them uniformly.
struct|struct
name|LiveRegSet
block|{
name|SparseSet
operator|<
name|unsigned
operator|>
name|PhysRegs
expr_stmt|;
name|SparseSet
operator|<
name|unsigned
operator|,
name|VirtReg2IndexFunctor
operator|>
name|VirtRegs
expr_stmt|;
name|bool
name|contains
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
if|if
condition|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
name|VirtRegs
operator|.
name|count
argument_list|(
name|Reg
argument_list|)
return|;
return|return
name|PhysRegs
operator|.
name|count
argument_list|(
name|Reg
argument_list|)
return|;
block|}
name|bool
name|insert
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
if|if
condition|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
name|VirtRegs
operator|.
name|insert
argument_list|(
name|Reg
argument_list|)
operator|.
name|second
return|;
return|return
name|PhysRegs
operator|.
name|insert
argument_list|(
name|Reg
argument_list|)
operator|.
name|second
return|;
block|}
name|bool
name|erase
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
if|if
condition|(
name|TargetRegisterInfo
operator|::
name|isVirtualRegister
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
name|VirtRegs
operator|.
name|erase
argument_list|(
name|Reg
argument_list|)
return|;
return|return
name|PhysRegs
operator|.
name|erase
argument_list|(
name|Reg
argument_list|)
return|;
block|}
block|}
struct|;
comment|/// Track the current register pressure at some position in the instruction
comment|/// stream, and remember the high water mark within the region traversed. This
comment|/// does not automatically consider live-through ranges. The client may
comment|/// independently adjust for global liveness.
comment|///
comment|/// Each RegPressureTracker only works within a MachineBasicBlock. Pressure can
comment|/// be tracked across a larger region by storing a RegisterPressure result at
comment|/// each block boundary and explicitly adjusting pressure to account for block
comment|/// live-in and live-out register sets.
comment|///
comment|/// RegPressureTracker holds a reference to a RegisterPressure result that it
comment|/// computes incrementally. During downward tracking, P.BottomIdx or P.BottomPos
comment|/// is invalid until it reaches the end of the block or closeRegion() is
comment|/// explicitly called. Similarly, P.TopIdx is invalid during upward
comment|/// tracking. Changing direction has the side effect of closing region, and
comment|/// traversing past TopIdx or BottomIdx reopens it.
name|class
name|RegPressureTracker
block|{
specifier|const
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
specifier|const
name|TargetRegisterInfo
modifier|*
name|TRI
decl_stmt|;
specifier|const
name|RegisterClassInfo
modifier|*
name|RCI
decl_stmt|;
specifier|const
name|MachineRegisterInfo
modifier|*
name|MRI
decl_stmt|;
specifier|const
name|LiveIntervals
modifier|*
name|LIS
decl_stmt|;
comment|/// We currently only allow pressure tracking within a block.
specifier|const
name|MachineBasicBlock
modifier|*
name|MBB
decl_stmt|;
comment|/// Track the max pressure within the region traversed so far.
name|RegisterPressure
modifier|&
name|P
decl_stmt|;
comment|/// Run in two modes dependending on whether constructed with IntervalPressure
comment|/// or RegisterPressure. If requireIntervals is false, LIS are ignored.
name|bool
name|RequireIntervals
decl_stmt|;
comment|/// True if UntiedDefs will be populated.
name|bool
name|TrackUntiedDefs
decl_stmt|;
comment|/// Register pressure corresponds to liveness before this instruction
comment|/// iterator. It may point to the end of the block or a DebugValue rather than
comment|/// an instruction.
name|MachineBasicBlock
operator|::
name|const_iterator
name|CurrPos
expr_stmt|;
comment|/// Pressure map indexed by pressure set ID, not class ID.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|CurrSetPressure
expr_stmt|;
comment|/// Set of live registers.
name|LiveRegSet
name|LiveRegs
decl_stmt|;
comment|/// Set of vreg defs that start a live range.
name|SparseSet
operator|<
name|unsigned
operator|,
name|VirtReg2IndexFunctor
operator|>
name|UntiedDefs
expr_stmt|;
comment|/// Live-through pressure.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|LiveThruPressure
expr_stmt|;
name|public
label|:
name|RegPressureTracker
argument_list|(
name|IntervalPressure
operator|&
name|rp
argument_list|)
operator|:
name|MF
argument_list|(
literal|0
argument_list|)
operator|,
name|TRI
argument_list|(
literal|0
argument_list|)
operator|,
name|RCI
argument_list|(
literal|0
argument_list|)
operator|,
name|LIS
argument_list|(
literal|0
argument_list|)
operator|,
name|MBB
argument_list|(
literal|0
argument_list|)
operator|,
name|P
argument_list|(
name|rp
argument_list|)
operator|,
name|RequireIntervals
argument_list|(
name|true
argument_list|)
operator|,
name|TrackUntiedDefs
argument_list|(
argument|false
argument_list|)
block|{}
name|RegPressureTracker
argument_list|(
name|RegionPressure
operator|&
name|rp
argument_list|)
operator|:
name|MF
argument_list|(
literal|0
argument_list|)
operator|,
name|TRI
argument_list|(
literal|0
argument_list|)
operator|,
name|RCI
argument_list|(
literal|0
argument_list|)
operator|,
name|LIS
argument_list|(
literal|0
argument_list|)
operator|,
name|MBB
argument_list|(
literal|0
argument_list|)
operator|,
name|P
argument_list|(
name|rp
argument_list|)
operator|,
name|RequireIntervals
argument_list|(
name|false
argument_list|)
operator|,
name|TrackUntiedDefs
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|reset
argument_list|()
expr_stmt|;
name|void
name|init
argument_list|(
specifier|const
name|MachineFunction
operator|*
name|mf
argument_list|,
specifier|const
name|RegisterClassInfo
operator|*
name|rci
argument_list|,
specifier|const
name|LiveIntervals
operator|*
name|lis
argument_list|,
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|,
name|MachineBasicBlock
operator|::
name|const_iterator
name|pos
argument_list|,
name|bool
name|ShouldTrackUntiedDefs
operator|=
name|false
argument_list|)
decl_stmt|;
comment|/// Force liveness of virtual registers or physical register
comment|/// units. Particularly useful to initialize the livein/out state of the
comment|/// tracker before the first call to advance/recede.
name|void
name|addLiveRegs
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Regs
argument_list|)
decl_stmt|;
comment|/// Get the MI position corresponding to this register pressure.
name|MachineBasicBlock
operator|::
name|const_iterator
name|getPos
argument_list|()
specifier|const
block|{
return|return
name|CurrPos
return|;
block|}
comment|// Reset the MI position corresponding to the register pressure. This allows
comment|// schedulers to move instructions above the RegPressureTracker's
comment|// CurrPos. Since the pressure is computed before CurrPos, the iterator
comment|// position changes while pressure does not.
name|void
name|setPos
argument_list|(
name|MachineBasicBlock
operator|::
name|const_iterator
name|Pos
argument_list|)
block|{
name|CurrPos
operator|=
name|Pos
expr_stmt|;
block|}
comment|/// \brief Get the SlotIndex for the first nondebug instruction including or
comment|/// after the current position.
name|SlotIndex
name|getCurrSlot
argument_list|()
specifier|const
expr_stmt|;
comment|/// Recede across the previous instruction.
name|bool
name|recede
argument_list|(
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|*
name|LiveUses
operator|=
literal|0
argument_list|,
name|PressureDiff
operator|*
name|PDiff
operator|=
literal|0
argument_list|)
decl_stmt|;
comment|/// Advance across the current instruction.
name|bool
name|advance
parameter_list|()
function_decl|;
comment|/// Finalize the region boundaries and recored live ins and live outs.
name|void
name|closeRegion
parameter_list|()
function_decl|;
comment|/// Initialize the LiveThru pressure set based on the untied defs found in
comment|/// RPTracker.
name|void
name|initLiveThru
parameter_list|(
specifier|const
name|RegPressureTracker
modifier|&
name|RPTracker
parameter_list|)
function_decl|;
comment|/// Copy an existing live thru pressure result.
name|void
name|initLiveThru
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|PressureSet
argument_list|)
block|{
name|LiveThruPressure
operator|.
name|assign
argument_list|(
name|PressureSet
operator|.
name|begin
argument_list|()
argument_list|,
name|PressureSet
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArrayRef
operator|<
name|unsigned
operator|>
name|getLiveThru
argument_list|()
specifier|const
block|{
return|return
name|LiveThruPressure
return|;
block|}
comment|/// Get the resulting register pressure over the traversed region.
comment|/// This result is complete if either advance() or recede() has returned true,
comment|/// or if closeRegion() was explicitly invoked.
name|RegisterPressure
modifier|&
name|getPressure
parameter_list|()
block|{
return|return
name|P
return|;
block|}
specifier|const
name|RegisterPressure
operator|&
name|getPressure
argument_list|()
specifier|const
block|{
return|return
name|P
return|;
block|}
comment|/// Get the register set pressure at the current position, which may be less
comment|/// than the pressure across the traversed region.
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|getRegSetPressureAtPos
argument_list|()
block|{
return|return
name|CurrSetPressure
return|;
block|}
name|void
name|discoverLiveOut
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|void
name|discoverLiveIn
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|bool
name|isTopClosed
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isBottomClosed
argument_list|()
specifier|const
expr_stmt|;
name|void
name|closeTop
parameter_list|()
function_decl|;
name|void
name|closeBottom
parameter_list|()
function_decl|;
comment|/// Consider the pressure increase caused by traversing this instruction
comment|/// bottom-up. Find the pressure set with the most change beyond its pressure
comment|/// limit based on the tracker's current pressure, and record the number of
comment|/// excess register units of that pressure set introduced by this instruction.
name|void
name|getMaxUpwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|PressureDiff
operator|*
name|PDiff
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl_stmt|;
name|void
name|getUpwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
comment|/*const*/
name|PressureDiff
operator|&
name|PDiff
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl|const
decl_stmt|;
comment|/// Consider the pressure increase caused by traversing this instruction
comment|/// top-down. Find the pressure set with the most change beyond its pressure
comment|/// limit based on the tracker's current pressure, and record the number of
comment|/// excess register units of that pressure set introduced by this instruction.
name|void
name|getMaxDownwardPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
decl_stmt|;
comment|/// Find the pressure set with the most change beyond its pressure limit after
comment|/// traversing this instruction either upward or downward depending on the
comment|/// closed end of the current region.
name|void
name|getMaxPressureDelta
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|RegPressureDelta
operator|&
name|Delta
argument_list|,
name|ArrayRef
operator|<
name|PressureChange
operator|>
name|CriticalPSets
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|MaxPressureLimit
argument_list|)
block|{
if|if
condition|(
name|isTopClosed
argument_list|()
condition|)
return|return
name|getMaxDownwardPressureDelta
argument_list|(
name|MI
argument_list|,
name|Delta
argument_list|,
name|CriticalPSets
argument_list|,
name|MaxPressureLimit
argument_list|)
return|;
name|assert
argument_list|(
name|isBottomClosed
argument_list|()
operator|&&
literal|"Uninitialized pressure tracker"
argument_list|)
expr_stmt|;
return|return
name|getMaxUpwardPressureDelta
argument_list|(
name|MI
argument_list|,
literal|0
argument_list|,
name|Delta
argument_list|,
name|CriticalPSets
argument_list|,
name|MaxPressureLimit
argument_list|)
return|;
block|}
comment|/// Get the pressure of each PSet after traversing this instruction bottom-up.
name|void
name|getUpwardPressure
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
decl_stmt|;
comment|/// Get the pressure of each PSet after traversing this instruction top-down.
name|void
name|getDownwardPressure
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
decl_stmt|;
name|void
name|getPressureAfterInst
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|PressureResult
argument_list|,
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|MaxPressureResult
argument_list|)
block|{
if|if
condition|(
name|isTopClosed
argument_list|()
condition|)
return|return
name|getUpwardPressure
argument_list|(
name|MI
argument_list|,
name|PressureResult
argument_list|,
name|MaxPressureResult
argument_list|)
return|;
name|assert
argument_list|(
name|isBottomClosed
argument_list|()
operator|&&
literal|"Uninitialized pressure tracker"
argument_list|)
expr_stmt|;
return|return
name|getDownwardPressure
argument_list|(
name|MI
argument_list|,
name|PressureResult
argument_list|,
name|MaxPressureResult
argument_list|)
return|;
block|}
name|bool
name|hasUntiedDef
argument_list|(
name|unsigned
name|VirtReg
argument_list|)
decl|const
block|{
return|return
name|UntiedDefs
operator|.
name|count
argument_list|(
name|VirtReg
argument_list|)
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|protected
label|:
specifier|const
name|LiveRange
modifier|*
name|getLiveRange
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
name|void
name|increaseRegPressure
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Regs
argument_list|)
decl_stmt|;
name|void
name|decreaseRegPressure
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Regs
argument_list|)
decl_stmt|;
name|void
name|bumpUpwardPressure
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
name|void
name|bumpDownwardPressure
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
function_decl|;
block|}
empty_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|LLVM_ENABLE_DUMP
argument_list|)
name|void
name|dumpRegSetPressure
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|SetPressure
argument_list|,
specifier|const
name|TargetRegisterInfo
operator|*
name|TRI
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

