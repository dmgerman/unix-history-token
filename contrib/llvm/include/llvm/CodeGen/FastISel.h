begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- FastISel.h - Definition of the FastISel class ---*- C++ -*---------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file defines the FastISel class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_FASTISEL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_FASTISEL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallingConv.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IntrinsicInst.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MachineConstantPool
decl_stmt|;
comment|/// \brief This is a fast-path instruction selection class that generates poor
comment|/// code and doesn't support illegal types or non-trivial lowering, but runs
comment|/// quickly.
name|class
name|FastISel
block|{
name|public
label|:
struct|struct
name|ArgListEntry
block|{
name|Value
modifier|*
name|Val
decl_stmt|;
name|Type
modifier|*
name|Ty
decl_stmt|;
name|bool
name|IsSExt
range|:
literal|1
decl_stmt|;
name|bool
name|IsZExt
range|:
literal|1
decl_stmt|;
name|bool
name|IsInReg
range|:
literal|1
decl_stmt|;
name|bool
name|IsSRet
range|:
literal|1
decl_stmt|;
name|bool
name|IsNest
range|:
literal|1
decl_stmt|;
name|bool
name|IsByVal
range|:
literal|1
decl_stmt|;
name|bool
name|IsInAlloca
range|:
literal|1
decl_stmt|;
name|bool
name|IsReturned
range|:
literal|1
decl_stmt|;
name|bool
name|IsSwiftSelf
range|:
literal|1
decl_stmt|;
name|bool
name|IsSwiftError
range|:
literal|1
decl_stmt|;
name|uint16_t
name|Alignment
decl_stmt|;
name|ArgListEntry
argument_list|()
operator|:
name|Val
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Ty
argument_list|(
name|nullptr
argument_list|)
operator|,
name|IsSExt
argument_list|(
name|false
argument_list|)
operator|,
name|IsZExt
argument_list|(
name|false
argument_list|)
operator|,
name|IsInReg
argument_list|(
name|false
argument_list|)
operator|,
name|IsSRet
argument_list|(
name|false
argument_list|)
operator|,
name|IsNest
argument_list|(
name|false
argument_list|)
operator|,
name|IsByVal
argument_list|(
name|false
argument_list|)
operator|,
name|IsInAlloca
argument_list|(
name|false
argument_list|)
operator|,
name|IsReturned
argument_list|(
name|false
argument_list|)
operator|,
name|IsSwiftSelf
argument_list|(
name|false
argument_list|)
operator|,
name|IsSwiftError
argument_list|(
name|false
argument_list|)
operator|,
name|Alignment
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// \brief Set CallLoweringInfo attribute flags based on a call instruction
comment|/// and called function attributes.
name|void
name|setAttributes
argument_list|(
argument|ImmutableCallSite *CS
argument_list|,
argument|unsigned AttrIdx
argument_list|)
expr_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|ArgListEntry
operator|>
name|ArgListTy
expr_stmt|;
struct|struct
name|CallLoweringInfo
block|{
name|Type
modifier|*
name|RetTy
decl_stmt|;
name|bool
name|RetSExt
range|:
literal|1
decl_stmt|;
name|bool
name|RetZExt
range|:
literal|1
decl_stmt|;
name|bool
name|IsVarArg
range|:
literal|1
decl_stmt|;
name|bool
name|IsInReg
range|:
literal|1
decl_stmt|;
name|bool
name|DoesNotReturn
range|:
literal|1
decl_stmt|;
name|bool
name|IsReturnValueUsed
range|:
literal|1
decl_stmt|;
comment|// \brief IsTailCall Should be modified by implementations of FastLowerCall
comment|// that perform tail call conversions.
name|bool
name|IsTailCall
decl_stmt|;
name|unsigned
name|NumFixedArgs
decl_stmt|;
name|CallingConv
operator|::
name|ID
name|CallConv
expr_stmt|;
specifier|const
name|Value
modifier|*
name|Callee
decl_stmt|;
name|MCSymbol
modifier|*
name|Symbol
decl_stmt|;
name|ArgListTy
name|Args
decl_stmt|;
name|ImmutableCallSite
modifier|*
name|CS
decl_stmt|;
name|MachineInstr
modifier|*
name|Call
decl_stmt|;
name|unsigned
name|ResultReg
decl_stmt|;
name|unsigned
name|NumResultRegs
decl_stmt|;
name|bool
name|IsPatchPoint
decl_stmt|;
name|SmallVector
operator|<
name|Value
operator|*
operator|,
literal|16
operator|>
name|OutVals
expr_stmt|;
name|SmallVector
operator|<
name|ISD
operator|::
name|ArgFlagsTy
operator|,
literal|16
operator|>
name|OutFlags
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|16
operator|>
name|OutRegs
expr_stmt|;
name|SmallVector
operator|<
name|ISD
operator|::
name|InputArg
operator|,
literal|4
operator|>
name|Ins
expr_stmt|;
name|SmallVector
operator|<
name|unsigned
operator|,
literal|4
operator|>
name|InRegs
expr_stmt|;
name|CallLoweringInfo
argument_list|()
operator|:
name|RetTy
argument_list|(
name|nullptr
argument_list|)
operator|,
name|RetSExt
argument_list|(
name|false
argument_list|)
operator|,
name|RetZExt
argument_list|(
name|false
argument_list|)
operator|,
name|IsVarArg
argument_list|(
name|false
argument_list|)
operator|,
name|IsInReg
argument_list|(
name|false
argument_list|)
operator|,
name|DoesNotReturn
argument_list|(
name|false
argument_list|)
operator|,
name|IsReturnValueUsed
argument_list|(
name|true
argument_list|)
operator|,
name|IsTailCall
argument_list|(
name|false
argument_list|)
operator|,
name|NumFixedArgs
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|CallConv
argument_list|(
name|CallingConv
operator|::
name|C
argument_list|)
operator|,
name|Callee
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Symbol
argument_list|(
name|nullptr
argument_list|)
operator|,
name|CS
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Call
argument_list|(
name|nullptr
argument_list|)
operator|,
name|ResultReg
argument_list|(
literal|0
argument_list|)
operator|,
name|NumResultRegs
argument_list|(
literal|0
argument_list|)
operator|,
name|IsPatchPoint
argument_list|(
argument|false
argument_list|)
block|{}
name|CallLoweringInfo
operator|&
name|setCallee
argument_list|(
argument|Type *ResultTy
argument_list|,
argument|FunctionType *FuncTy
argument_list|,
argument|const Value *Target
argument_list|,
argument|ArgListTy&&ArgsList
argument_list|,
argument|ImmutableCallSite&Call
argument_list|)
block|{
name|RetTy
operator|=
name|ResultTy
block|;
name|Callee
operator|=
name|Target
block|;
name|IsInReg
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|InReg
argument_list|)
block|;
name|DoesNotReturn
operator|=
name|Call
operator|.
name|doesNotReturn
argument_list|()
block|;
name|IsVarArg
operator|=
name|FuncTy
operator|->
name|isVarArg
argument_list|()
block|;
name|IsReturnValueUsed
operator|=
operator|!
name|Call
operator|.
name|getInstruction
argument_list|()
operator|->
name|use_empty
argument_list|()
block|;
name|RetSExt
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|SExt
argument_list|)
block|;
name|RetZExt
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|ZExt
argument_list|)
block|;
name|CallConv
operator|=
name|Call
operator|.
name|getCallingConv
argument_list|()
block|;
name|Args
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgsList
argument_list|)
block|;
name|NumFixedArgs
operator|=
name|FuncTy
operator|->
name|getNumParams
argument_list|()
block|;
name|CS
operator|=
operator|&
name|Call
block|;
return|return
operator|*
name|this
return|;
block|}
name|CallLoweringInfo
modifier|&
name|setCallee
argument_list|(
name|Type
operator|*
name|ResultTy
argument_list|,
name|FunctionType
operator|*
name|FuncTy
argument_list|,
name|MCSymbol
operator|*
name|Target
argument_list|,
name|ArgListTy
operator|&&
name|ArgsList
argument_list|,
name|ImmutableCallSite
operator|&
name|Call
argument_list|,
name|unsigned
name|FixedArgs
operator|=
operator|~
literal|0U
argument_list|)
block|{
name|RetTy
operator|=
name|ResultTy
expr_stmt|;
name|Callee
operator|=
name|Call
operator|.
name|getCalledValue
argument_list|()
expr_stmt|;
name|Symbol
operator|=
name|Target
expr_stmt|;
name|IsInReg
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|InReg
argument_list|)
expr_stmt|;
name|DoesNotReturn
operator|=
name|Call
operator|.
name|doesNotReturn
argument_list|()
expr_stmt|;
name|IsVarArg
operator|=
name|FuncTy
operator|->
name|isVarArg
argument_list|()
expr_stmt|;
name|IsReturnValueUsed
operator|=
operator|!
name|Call
operator|.
name|getInstruction
argument_list|()
operator|->
name|use_empty
argument_list|()
expr_stmt|;
name|RetSExt
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|SExt
argument_list|)
expr_stmt|;
name|RetZExt
operator|=
name|Call
operator|.
name|paramHasAttr
argument_list|(
literal|0
argument_list|,
name|Attribute
operator|::
name|ZExt
argument_list|)
expr_stmt|;
name|CallConv
operator|=
name|Call
operator|.
name|getCallingConv
argument_list|()
expr_stmt|;
name|Args
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgsList
argument_list|)
expr_stmt|;
name|NumFixedArgs
operator|=
operator|(
name|FixedArgs
operator|==
operator|~
literal|0U
operator|)
condition|?
name|FuncTy
operator|->
name|getNumParams
argument_list|()
else|:
name|FixedArgs
expr_stmt|;
name|CS
operator|=
operator|&
name|Call
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CallLoweringInfo
modifier|&
name|setCallee
argument_list|(
name|CallingConv
operator|::
name|ID
name|CC
argument_list|,
name|Type
operator|*
name|ResultTy
argument_list|,
specifier|const
name|Value
operator|*
name|Target
argument_list|,
name|ArgListTy
operator|&&
name|ArgsList
argument_list|,
name|unsigned
name|FixedArgs
operator|=
operator|~
literal|0U
argument_list|)
block|{
name|RetTy
operator|=
name|ResultTy
expr_stmt|;
name|Callee
operator|=
name|Target
expr_stmt|;
name|CallConv
operator|=
name|CC
expr_stmt|;
name|Args
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgsList
argument_list|)
expr_stmt|;
name|NumFixedArgs
operator|=
operator|(
name|FixedArgs
operator|==
operator|~
literal|0U
operator|)
condition|?
name|Args
operator|.
name|size
argument_list|()
else|:
name|FixedArgs
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CallLoweringInfo
modifier|&
name|setCallee
argument_list|(
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|,
name|MCContext
operator|&
name|Ctx
argument_list|,
name|CallingConv
operator|::
name|ID
name|CC
argument_list|,
name|Type
operator|*
name|ResultTy
argument_list|,
specifier|const
name|char
operator|*
name|Target
argument_list|,
name|ArgListTy
operator|&&
name|ArgsList
argument_list|,
name|unsigned
name|FixedArgs
operator|=
operator|~
literal|0U
argument_list|)
decl_stmt|;
name|CallLoweringInfo
modifier|&
name|setCallee
argument_list|(
name|CallingConv
operator|::
name|ID
name|CC
argument_list|,
name|Type
operator|*
name|ResultTy
argument_list|,
name|MCSymbol
operator|*
name|Target
argument_list|,
name|ArgListTy
operator|&&
name|ArgsList
argument_list|,
name|unsigned
name|FixedArgs
operator|=
operator|~
literal|0U
argument_list|)
block|{
name|RetTy
operator|=
name|ResultTy
expr_stmt|;
name|Symbol
operator|=
name|Target
expr_stmt|;
name|CallConv
operator|=
name|CC
expr_stmt|;
name|Args
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgsList
argument_list|)
expr_stmt|;
name|NumFixedArgs
operator|=
operator|(
name|FixedArgs
operator|==
operator|~
literal|0U
operator|)
condition|?
name|Args
operator|.
name|size
argument_list|()
else|:
name|FixedArgs
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CallLoweringInfo
modifier|&
name|setTailCall
parameter_list|(
name|bool
name|Value
init|=
name|true
parameter_list|)
block|{
name|IsTailCall
operator|=
name|Value
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CallLoweringInfo
modifier|&
name|setIsPatchPoint
parameter_list|(
name|bool
name|Value
init|=
name|true
parameter_list|)
block|{
name|IsPatchPoint
operator|=
name|Value
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|ArgListTy
modifier|&
name|getArgs
parameter_list|()
block|{
return|return
name|Args
return|;
block|}
name|void
name|clearOuts
parameter_list|()
block|{
name|OutVals
operator|.
name|clear
argument_list|()
expr_stmt|;
name|OutFlags
operator|.
name|clear
argument_list|()
expr_stmt|;
name|OutRegs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|clearIns
parameter_list|()
block|{
name|Ins
operator|.
name|clear
argument_list|()
expr_stmt|;
name|InRegs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
name|protected
label|:
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|unsigned
operator|>
name|LocalValueMap
expr_stmt|;
name|FunctionLoweringInfo
modifier|&
name|FuncInfo
decl_stmt|;
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
name|MachineRegisterInfo
modifier|&
name|MRI
decl_stmt|;
name|MachineFrameInfo
modifier|&
name|MFI
decl_stmt|;
name|MachineConstantPool
modifier|&
name|MCP
decl_stmt|;
name|DebugLoc
name|DbgLoc
decl_stmt|;
specifier|const
name|TargetMachine
modifier|&
name|TM
decl_stmt|;
specifier|const
name|DataLayout
modifier|&
name|DL
decl_stmt|;
specifier|const
name|TargetInstrInfo
modifier|&
name|TII
decl_stmt|;
specifier|const
name|TargetLowering
modifier|&
name|TLI
decl_stmt|;
specifier|const
name|TargetRegisterInfo
modifier|&
name|TRI
decl_stmt|;
specifier|const
name|TargetLibraryInfo
modifier|*
name|LibInfo
decl_stmt|;
name|bool
name|SkipTargetIndependentISel
decl_stmt|;
comment|/// \brief The position of the last instruction for materializing constants
comment|/// for use in the current block. It resets to EmitStartPt when it makes sense
comment|/// (for example, it's usually profitable to avoid function calls between the
comment|/// definition and the use)
name|MachineInstr
modifier|*
name|LastLocalValue
decl_stmt|;
comment|/// \brief The top most instruction in the current block that is allowed for
comment|/// emitting local variables. LastLocalValue resets to EmitStartPt when it
comment|/// makes sense (for example, on function calls)
name|MachineInstr
modifier|*
name|EmitStartPt
decl_stmt|;
name|public
label|:
comment|/// \brief Return the position of the last instruction emitted for
comment|/// materializing constants for use in the current block.
name|MachineInstr
modifier|*
name|getLastLocalValue
parameter_list|()
block|{
return|return
name|LastLocalValue
return|;
block|}
comment|/// \brief Update the position of the last instruction emitted for
comment|/// materializing constants for use in the current block.
name|void
name|setLastLocalValue
parameter_list|(
name|MachineInstr
modifier|*
name|I
parameter_list|)
block|{
name|EmitStartPt
operator|=
name|I
expr_stmt|;
name|LastLocalValue
operator|=
name|I
expr_stmt|;
block|}
comment|/// \brief Set the current block to which generated machine instructions will
comment|/// be appended, and clear the local CSE map.
name|void
name|startNewBlock
parameter_list|()
function_decl|;
comment|/// \brief Return current debug location information.
name|DebugLoc
name|getCurDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|DbgLoc
return|;
block|}
comment|/// \brief Do "fast" instruction selection for function arguments and append
comment|/// the machine instructions to the current block. Returns true when
comment|/// successful.
name|bool
name|lowerArguments
parameter_list|()
function_decl|;
comment|/// \brief Do "fast" instruction selection for the given LLVM IR instruction
comment|/// and append the generated machine instructions to the current block.
comment|/// Returns true if selection was successful.
name|bool
name|selectInstruction
parameter_list|(
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
function_decl|;
comment|/// \brief Do "fast" instruction selection for the given LLVM IR operator
comment|/// (Instruction or ConstantExpr), and append generated machine instructions
comment|/// to the current block. Return true if selection was successful.
name|bool
name|selectOperator
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
comment|/// \brief Create a virtual register and arrange for it to be assigned the
comment|/// value for the given LLVM value.
name|unsigned
name|getRegForValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
comment|/// \brief Look up the value to see if its value is already cached in a
comment|/// register. It may be defined by instructions across blocks or defined
comment|/// locally.
name|unsigned
name|lookUpRegForValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
comment|/// \brief This is a wrapper around getRegForValue that also takes care of
comment|/// truncating or sign-extending the given getelementptr index value.
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
name|getRegForGEPIndex
argument_list|(
specifier|const
name|Value
operator|*
name|V
argument_list|)
expr_stmt|;
comment|/// \brief We're checking to see if we can fold \p LI into \p FoldInst. Note
comment|/// that we could have a sequence where multiple LLVM IR instructions are
comment|/// folded into the same machineinstr.  For example we could have:
comment|///
comment|///   A: x = load i32 *P
comment|///   B: y = icmp A, 42
comment|///   C: br y, ...
comment|///
comment|/// In this scenario, \p LI is "A", and \p FoldInst is "C".  We know about "B"
comment|/// (and any other folded instructions) because it is between A and C.
comment|///
comment|/// If we succeed folding, return true.
name|bool
name|tryToFoldLoad
parameter_list|(
specifier|const
name|LoadInst
modifier|*
name|LI
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|FoldInst
parameter_list|)
function_decl|;
comment|/// \brief The specified machine instr operand is a vreg, and that vreg is
comment|/// being provided by the specified load instruction.  If possible, try to
comment|/// fold the load as an operand to the instruction, returning true if
comment|/// possible.
comment|///
comment|/// This method should be implemented by targets.
name|virtual
name|bool
name|tryToFoldLoadIntoMI
parameter_list|(
name|MachineInstr
modifier|*
comment|/*MI*/
parameter_list|,
name|unsigned
comment|/*OpNo*/
parameter_list|,
specifier|const
name|LoadInst
modifier|*
comment|/*LI*/
parameter_list|)
block|{
return|return
name|false
return|;
block|}
comment|/// \brief Reset InsertPt to prepare for inserting instructions into the
comment|/// current block.
name|void
name|recomputeInsertPt
parameter_list|()
function_decl|;
comment|/// \brief Remove all dead instructions between the I and E.
name|void
name|removeDeadCode
argument_list|(
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|E
argument_list|)
decl_stmt|;
struct|struct
name|SavePoint
block|{
name|MachineBasicBlock
operator|::
name|iterator
name|InsertPt
expr_stmt|;
name|DebugLoc
name|DL
decl_stmt|;
block|}
struct|;
comment|/// \brief Prepare InsertPt to begin inserting instructions into the local
comment|/// value area and return the old insert position.
name|SavePoint
name|enterLocalValueArea
parameter_list|()
function_decl|;
comment|/// \brief Reset InsertPt to the given old insert position.
name|void
name|leaveLocalValueArea
parameter_list|(
name|SavePoint
name|Old
parameter_list|)
function_decl|;
name|virtual
operator|~
name|FastISel
argument_list|()
expr_stmt|;
name|protected
label|:
name|explicit
name|FastISel
parameter_list|(
name|FunctionLoweringInfo
modifier|&
name|FuncInfo
parameter_list|,
specifier|const
name|TargetLibraryInfo
modifier|*
name|LibInfo
parameter_list|,
name|bool
name|SkipTargetIndependentISel
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code when the normal
comment|/// FastISel process fails to select an instruction. This gives targets a
comment|/// chance to emit code for anything that doesn't fit into FastISel's
comment|/// framework. It returns true if it was successful.
name|virtual
name|bool
name|fastSelectInstruction
parameter_list|(
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// \brief This method is called by target-independent code to do target-
comment|/// specific argument lowering. It returns true if it was successful.
name|virtual
name|bool
name|fastLowerArguments
parameter_list|()
function_decl|;
comment|/// \brief This method is called by target-independent code to do target-
comment|/// specific call lowering. It returns true if it was successful.
name|virtual
name|bool
name|fastLowerCall
parameter_list|(
name|CallLoweringInfo
modifier|&
name|CLI
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to do target-
comment|/// specific intrinsic lowering. It returns true if it was successful.
name|virtual
name|bool
name|fastLowerIntrinsicCall
parameter_list|(
specifier|const
name|IntrinsicInst
modifier|*
name|II
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type and opcode be emitted.
name|virtual
name|unsigned
name|fastEmit_
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and register operand be emitted.
name|virtual
name|unsigned
name|fastEmit_r
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and register operands be emitted.
name|virtual
name|unsigned
name|fastEmit_rr
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|unsigned
name|Op1
parameter_list|,
name|bool
name|Op1IsKill
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and register and immediate
comment|// operands be emitted.
name|virtual
name|unsigned
name|fastEmit_ri
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and register and floating-point
comment|/// immediate operands be emitted.
name|virtual
name|unsigned
name|fastEmit_rf
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
specifier|const
name|ConstantFP
modifier|*
name|FPImm
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and register and immediate
comment|/// operands be emitted.
name|virtual
name|unsigned
name|fastEmit_rri
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|unsigned
name|Op1
parameter_list|,
name|bool
name|Op1IsKill
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief This method is a wrapper of fastEmit_ri.
comment|///
comment|/// It first tries to emit an instruction with an immediate operand using
comment|/// fastEmit_ri.  If that fails, it materializes the immediate into a register
comment|/// and try fastEmit_rr instead.
name|unsigned
name|fastEmit_ri_
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|uint64_t
name|Imm
parameter_list|,
name|MVT
name|ImmType
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and immediate operand be emitted.
name|virtual
name|unsigned
name|fastEmit_i
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief This method is called by target-independent code to request that an
comment|/// instruction with the given type, opcode, and floating-point immediate
comment|/// operand be emitted.
name|virtual
name|unsigned
name|fastEmit_f
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|ConstantFP
modifier|*
name|FPImm
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with no operands and a result register in the
comment|/// given register class.
name|unsigned
name|fastEmitInst_
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with one register operand and a result register
comment|/// in the given register class.
name|unsigned
name|fastEmitInst_r
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with two register operands and a result
comment|/// register in the given register class.
name|unsigned
name|fastEmitInst_rr
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|unsigned
name|Op1
parameter_list|,
name|bool
name|Op1IsKill
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with three register operands and a result
comment|/// register in the given register class.
name|unsigned
name|fastEmitInst_rrr
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|unsigned
name|Op1
parameter_list|,
name|bool
name|Op1IsKill
parameter_list|,
name|unsigned
name|Op2
parameter_list|,
name|bool
name|Op2IsKill
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with a register operand, an immediate, and a
comment|/// result register in the given register class.
name|unsigned
name|fastEmitInst_ri
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with one register operand and two immediate
comment|/// operands.
name|unsigned
name|fastEmitInst_rii
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|uint64_t
name|Imm1
parameter_list|,
name|uint64_t
name|Imm2
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with a floating point immediate, and a result
comment|/// register in the given register class.
name|unsigned
name|fastEmitInst_f
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
specifier|const
name|ConstantFP
modifier|*
name|FPImm
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with two register operands, an immediate, and a
comment|/// result register in the given register class.
name|unsigned
name|fastEmitInst_rri
parameter_list|(
name|unsigned
name|MachineInstOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|unsigned
name|Op1
parameter_list|,
name|bool
name|Op1IsKill
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr with a single immediate operand, and a result
comment|/// register in the given register class.
name|unsigned
name|fastEmitInst_i
parameter_list|(
name|unsigned
name|MachineInstrOpcode
parameter_list|,
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|,
name|uint64_t
name|Imm
parameter_list|)
function_decl|;
comment|/// \brief Emit a MachineInstr for an extract_subreg from a specified index of
comment|/// a superregister to a specified type.
name|unsigned
name|fastEmitInst_extractsubreg
parameter_list|(
name|MVT
name|RetVT
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|,
name|uint32_t
name|Idx
parameter_list|)
function_decl|;
comment|/// \brief Emit MachineInstrs to compute the value of Op with all but the
comment|/// least significant bit set to zero.
name|unsigned
name|fastEmitZExtFromI1
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|unsigned
name|Op0
parameter_list|,
name|bool
name|Op0IsKill
parameter_list|)
function_decl|;
comment|/// \brief Emit an unconditional branch to the given block, unless it is the
comment|/// immediate (fall-through) successor, and update the CFG.
name|void
name|fastEmitBranch
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|,
specifier|const
name|DebugLoc
modifier|&
name|DL
parameter_list|)
function_decl|;
comment|/// Emit an unconditional branch to \p FalseMBB, obtains the branch weight
comment|/// and adds TrueMBB and FalseMBB to the successor list.
name|void
name|finishCondBranch
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|BranchBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|TrueMBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|FalseMBB
parameter_list|)
function_decl|;
comment|/// \brief Update the value map to include the new mapping for this
comment|/// instruction, or insert an extra copy to get the result in a previous
comment|/// determined register.
comment|///
comment|/// NOTE: This is only necessary because we might select a block that uses a
comment|/// value before we select the block that defines the value. It might be
comment|/// possible to fix this by selecting blocks in reverse postorder.
name|void
name|updateValueMap
parameter_list|(
specifier|const
name|Value
modifier|*
name|I
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|unsigned
name|NumRegs
init|=
literal|1
parameter_list|)
function_decl|;
name|unsigned
name|createResultReg
parameter_list|(
specifier|const
name|TargetRegisterClass
modifier|*
name|RC
parameter_list|)
function_decl|;
comment|/// \brief Try to constrain Op so that it is usable by argument OpNum of the
comment|/// provided MCInstrDesc. If this fails, create a new virtual register in the
comment|/// correct class and COPY the value there.
name|unsigned
name|constrainOperandRegClass
parameter_list|(
specifier|const
name|MCInstrDesc
modifier|&
name|II
parameter_list|,
name|unsigned
name|Op
parameter_list|,
name|unsigned
name|OpNum
parameter_list|)
function_decl|;
comment|/// \brief Emit a constant in a register using target-specific logic, such as
comment|/// constant pool loads.
name|virtual
name|unsigned
name|fastMaterializeConstant
parameter_list|(
specifier|const
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Emit an alloca address in a register using target-specific logic.
name|virtual
name|unsigned
name|fastMaterializeAlloca
parameter_list|(
specifier|const
name|AllocaInst
modifier|*
name|C
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Emit the floating-point constant +0.0 in a register using target-
comment|/// specific logic.
name|virtual
name|unsigned
name|fastMaterializeFloatZero
parameter_list|(
specifier|const
name|ConstantFP
modifier|*
name|CF
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Check if \c Add is an add that can be safely folded into \c GEP.
comment|///
comment|/// \c Add can be folded into \c GEP if:
comment|/// - \c Add is an add,
comment|/// - \c Add's size matches \c GEP's,
comment|/// - \c Add is in the same basic block as \c GEP, and
comment|/// - \c Add has a constant operand.
name|bool
name|canFoldAddIntoGEP
parameter_list|(
specifier|const
name|User
modifier|*
name|GEP
parameter_list|,
specifier|const
name|Value
modifier|*
name|Add
parameter_list|)
function_decl|;
comment|/// \brief Test whether the given value has exactly one use.
name|bool
name|hasTrivialKill
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
comment|/// \brief Create a machine mem operand from the given instruction.
name|MachineMemOperand
modifier|*
name|createMachineMemOperandFor
argument_list|(
specifier|const
name|Instruction
operator|*
name|I
argument_list|)
decl|const
decl_stmt|;
name|CmpInst
operator|::
name|Predicate
name|optimizeCmpPredicate
argument_list|(
argument|const CmpInst *CI
argument_list|)
specifier|const
expr_stmt|;
name|bool
name|lowerCallTo
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|CI
parameter_list|,
name|MCSymbol
modifier|*
name|Symbol
parameter_list|,
name|unsigned
name|NumArgs
parameter_list|)
function_decl|;
name|bool
name|lowerCallTo
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|CI
parameter_list|,
specifier|const
name|char
modifier|*
name|SymbolName
parameter_list|,
name|unsigned
name|NumArgs
parameter_list|)
function_decl|;
name|bool
name|lowerCallTo
parameter_list|(
name|CallLoweringInfo
modifier|&
name|CLI
parameter_list|)
function_decl|;
name|bool
name|isCommutativeIntrinsic
parameter_list|(
name|IntrinsicInst
specifier|const
modifier|*
name|II
parameter_list|)
block|{
switch|switch
condition|(
name|II
operator|->
name|getIntrinsicID
argument_list|()
condition|)
block|{
case|case
name|Intrinsic
operator|::
name|sadd_with_overflow
case|:
case|case
name|Intrinsic
operator|::
name|uadd_with_overflow
case|:
case|case
name|Intrinsic
operator|::
name|smul_with_overflow
case|:
case|case
name|Intrinsic
operator|::
name|umul_with_overflow
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
name|bool
name|lowerCall
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|I
parameter_list|)
function_decl|;
comment|/// \brief Select and emit code for a binary operator instruction, which has
comment|/// an opcode which directly corresponds to the given ISD opcode.
name|bool
name|selectBinaryOp
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|,
name|unsigned
name|ISDOpcode
parameter_list|)
function_decl|;
name|bool
name|selectFNeg
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectGetElementPtr
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectStackmap
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectPatchpoint
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectCall
parameter_list|(
specifier|const
name|User
modifier|*
name|Call
parameter_list|)
function_decl|;
name|bool
name|selectIntrinsicCall
parameter_list|(
specifier|const
name|IntrinsicInst
modifier|*
name|II
parameter_list|)
function_decl|;
name|bool
name|selectBitCast
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectCast
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
name|bool
name|selectExtractValue
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|)
function_decl|;
name|bool
name|selectInsertValue
parameter_list|(
specifier|const
name|User
modifier|*
name|I
parameter_list|)
function_decl|;
name|private
label|:
comment|/// \brief Handle PHI nodes in successor blocks.
comment|///
comment|/// Emit code to ensure constants are copied into registers when needed.
comment|/// Remember the virtual registers that need to be added to the Machine PHI
comment|/// nodes as input.  We cannot just directly add them, because expansion might
comment|/// result in multiple MBB's for one BB.  As such, the start of the BB might
comment|/// correspond to a different MBB than the end.
name|bool
name|handlePHINodesInSuccessorBlocks
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|LLVMBB
parameter_list|)
function_decl|;
comment|/// \brief Helper for materializeRegForValue to materialize a constant in a
comment|/// target-independent way.
name|unsigned
name|materializeConstant
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|MVT
name|VT
parameter_list|)
function_decl|;
comment|/// \brief Helper for getRegForVale. This function is called when the value
comment|/// isn't already available in a register and must be materialized with new
comment|/// instructions.
name|unsigned
name|materializeRegForValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|MVT
name|VT
parameter_list|)
function_decl|;
comment|/// \brief Clears LocalValueMap and moves the area for the new local variables
comment|/// to the beginning of the block. It helps to avoid spilling cached variables
comment|/// across heavy instructions like calls.
name|void
name|flushLocalValueMap
parameter_list|()
function_decl|;
comment|/// \brief Removes dead local value instructions after SavedLastLocalvalue.
name|void
name|removeDeadLocalValueCode
parameter_list|(
name|MachineInstr
modifier|*
name|SavedLastLocalValue
parameter_list|)
function_decl|;
comment|/// \brief Insertion point before trying to select the current instruction.
name|MachineBasicBlock
operator|::
name|iterator
name|SavedInsertPt
expr_stmt|;
comment|/// \brief Add a stackmap or patchpoint intrinsic call's live variable
comment|/// operands to a stackmap or patchpoint machine instruction.
name|bool
name|addStackMapLiveVars
argument_list|(
name|SmallVectorImpl
operator|<
name|MachineOperand
operator|>
operator|&
name|Ops
argument_list|,
specifier|const
name|CallInst
operator|*
name|CI
argument_list|,
name|unsigned
name|StartIdx
argument_list|)
decl_stmt|;
name|bool
name|lowerCallOperands
parameter_list|(
specifier|const
name|CallInst
modifier|*
name|CI
parameter_list|,
name|unsigned
name|ArgIdx
parameter_list|,
name|unsigned
name|NumArgs
parameter_list|,
specifier|const
name|Value
modifier|*
name|Callee
parameter_list|,
name|bool
name|ForceRetVoidTy
parameter_list|,
name|CallLoweringInfo
modifier|&
name|CLI
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

