begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/GlobalISel/IRTranslator.h - IRTranslator ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file declares the IRTranslator pass.
end_comment

begin_comment
comment|/// This pass is responsible for translating LLVM IR into MachineInstr.
end_comment

begin_comment
comment|/// It uses target hooks to lower the ABI but aside from that, the pass
end_comment

begin_comment
comment|/// generated code is generic. This is the default translator used for
end_comment

begin_comment
comment|/// GlobalISel.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \todo Replace the comments with actual doxygen comments.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_GLOBALISEL_IRTRANSLATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_GLOBALISEL_IRTRANSLATOR_H
end_define

begin_include
include|#
directive|include
file|"Types.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SetVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|// Forward declarations.
name|class
name|BasicBlock
decl_stmt|;
name|class
name|CallLowering
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|OptimizationRemarkEmitter
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|TargetPassConfig
decl_stmt|;
comment|// Technically the pass should run on an hypothetical MachineModule,
comment|// since it should translate Global into some sort of MachineGlobal.
comment|// The MachineGlobal should ultimately just be a transfer of ownership of
comment|// the interesting bits that are relevant to represent a global value.
comment|// That being said, we could investigate what would it cost to just duplicate
comment|// the information from the LLVM IR.
comment|// The idea is that ultimately we would be able to free up the memory used
comment|// by the LLVM IR as soon as the translation is over.
name|class
name|IRTranslator
range|:
name|public
name|MachineFunctionPass
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|private
operator|:
comment|/// Interface used to lower the everything related to calls.
specifier|const
name|CallLowering
operator|*
name|CLI
block|;
comment|/// Mapping of the values of the current LLVM IR function
comment|/// to the related virtual registers.
name|ValueToVReg
name|ValToVReg
block|;
comment|// N.b. it's not completely obvious that this will be sufficient for every
comment|// LLVM IR construct (with "invoke" being the obvious candidate to mess up our
comment|// lives.
name|DenseMap
operator|<
specifier|const
name|BasicBlock
operator|*
block|,
name|MachineBasicBlock
operator|*
operator|>
name|BBToMBB
block|;
comment|// One BasicBlock can be translated to multiple MachineBasicBlocks.  For such
comment|// BasicBlocks translated to multiple MachineBasicBlocks, MachinePreds retains
comment|// a mapping between the edges arriving at the BasicBlock to the corresponding
comment|// created MachineBasicBlocks. Some BasicBlocks that get translated to a
comment|// single MachineBasicBlock may also end up in this Map.
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|BasicBlock
operator|*
operator|,
specifier|const
name|BasicBlock
operator|*
operator|>
name|CFGEdge
expr_stmt|;
name|DenseMap
operator|<
name|CFGEdge
block|,
name|SmallVector
operator|<
name|MachineBasicBlock
operator|*
block|,
literal|1
operator|>>
name|MachinePreds
decl_stmt|;
comment|// List of stubbed PHI instructions, for values and basic blocks to be filled
comment|// in once all MachineBasicBlocks have been created.
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|PHINode
operator|*
operator|,
name|MachineInstr
operator|*
operator|>
operator|,
literal|4
operator|>
name|PendingPHIs
expr_stmt|;
comment|/// Record of what frame index has been allocated to specified allocas for
comment|/// this function.
name|DenseMap
operator|<
specifier|const
name|AllocaInst
operator|*
operator|,
name|int
operator|>
name|FrameIndices
expr_stmt|;
comment|/// Methods for translating form LLVM IR to MachineInstr.
comment|/// \see ::translate for general information on the translate methods.
comment|/// @{
comment|/// Translate \p Inst into its corresponding MachineInstr instruction(s).
comment|/// Insert the newly translated instruction(s) right where the CurBuilder
comment|/// is set.
comment|///
comment|/// The general algorithm is:
comment|/// 1. Look for a virtual register for each operand or
comment|///    create one.
comment|/// 2 Update the ValToVReg accordingly.
comment|/// 2.alt. For constant arguments, if they are compile time constants,
comment|///   produce an immediate in the right operand and do not touch
comment|///   ValToReg. Actually we will go with a virtual register for each
comment|///   constants because it may be expensive to actually materialize the
comment|///   constant. Moreover, if the constant spans on several instructions,
comment|///   CSE may not catch them.
comment|///   => Update ValToVReg and remember that we saw a constant in Constants.
comment|///   We will materialize all the constants in finalize.
comment|/// Note: we would need to do something so that we can recognize such operand
comment|///       as constants.
comment|/// 3. Create the generic instruction.
comment|///
comment|/// \return true if the translation succeeded.
name|bool
name|translate
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|Inst
parameter_list|)
function_decl|;
comment|/// Materialize \p C into virtual-register \p Reg. The generic instructions
comment|/// performing this materialization will be inserted into the entry block of
comment|/// the function.
comment|///
comment|/// \return true if the materialization succeeded.
name|bool
name|translate
parameter_list|(
specifier|const
name|Constant
modifier|&
name|C
parameter_list|,
name|unsigned
name|Reg
parameter_list|)
function_decl|;
comment|/// Translate an LLVM bitcast into generic IR. Either a COPY or a G_BITCAST is
comment|/// emitted.
name|bool
name|translateBitCast
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate an LLVM load instruction into generic IR.
name|bool
name|translateLoad
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate an LLVM store instruction into generic IR.
name|bool
name|translateStore
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate an LLVM string intrinsic (memcpy, memset, ...).
name|bool
name|translateMemfunc
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|CI
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|,
name|unsigned
name|Intrinsic
parameter_list|)
function_decl|;
name|void
name|getStackGuard
parameter_list|(
name|unsigned
name|DstReg
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateOverflowIntrinsic
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|CI
parameter_list|,
name|unsigned
name|Op
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateKnownIntrinsic
argument_list|(
specifier|const
name|CallInst
operator|&
name|CI
argument_list|,
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|,
name|MachineIRBuilder
operator|&
name|MIRBuilder
argument_list|)
decl_stmt|;
name|bool
name|translateInlineAsm
parameter_list|(
specifier|const
name|CallInst
modifier|&
name|CI
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate call instruction.
comment|/// \pre \p U is a call instruction.
name|bool
name|translateCall
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateInvoke
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateLandingPad
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate one of LLVM's cast instructions into MachineInstrs, with the
comment|/// given generic Opcode.
name|bool
name|translateCast
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate a phi instruction.
name|bool
name|translatePHI
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate a comparison (icmp or fcmp) instruction or constant.
name|bool
name|translateCompare
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate an integer compare instruction (or constant).
name|bool
name|translateICmp
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCompare
argument_list|(
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
comment|/// Translate a floating-point compare instruction (or constant).
name|bool
name|translateFCmp
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCompare
argument_list|(
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
comment|/// Add remaining operands onto phis we've translated. Executed after all
comment|/// MachineBasicBlocks for the function have been created.
name|void
name|finishPendingPhis
parameter_list|()
function_decl|;
comment|/// Translate \p Inst into a binary operation \p Opcode.
comment|/// \pre \p U is a binary operation.
name|bool
name|translateBinaryOp
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate branch (br) instruction.
comment|/// \pre \p U is a branch instruction.
name|bool
name|translateBr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateSwitch
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateIndirectBr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateExtractValue
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateInsertValue
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateSelect
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateGetElementPtr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateAlloca
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|/// Translate return (ret) instruction.
comment|/// The target needs to implement CallLowering::lowerReturn for
comment|/// this to succeed.
comment|/// \pre \p U is a return instruction.
name|bool
name|translateRet
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateFSub
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateAdd
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_ADD
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateSub
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_SUB
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateAnd
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_AND
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateMul
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_MUL
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateOr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_OR
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateXor
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_XOR
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateUDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_UDIV
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateSDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_SDIV
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateURem
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_UREM
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateSRem
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_SREM
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateIntToPtr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_INTTOPTR
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translatePtrToInt
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_PTRTOINT
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateTrunc
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_TRUNC
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFPTrunc
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_FPTRUNC
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFPExt
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_FPEXT
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFPToUI
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_FPTOUI
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFPToSI
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_FPTOSI
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateUIToFP
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_UITOFP
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateSIToFP
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_SITOFP
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateUnreachable
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|bool
name|translateSExt
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_SEXT
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateZExt
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateCast
argument_list|(
name|TargetOpcode
operator|::
name|G_ZEXT
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateShl
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_SHL
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateLShr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_LSHR
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateAShr
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_ASHR
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFAdd
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_FADD
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFMul
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_FMUL
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFDiv
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_FDIV
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateFRem
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|translateBinaryOp
argument_list|(
name|TargetOpcode
operator|::
name|G_FREM
argument_list|,
name|U
argument_list|,
name|MIRBuilder
argument_list|)
return|;
block|}
name|bool
name|translateVAArg
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateInsertElement
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateExtractElement
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
name|bool
name|translateShuffleVector
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
function_decl|;
comment|// Stubs to keep the compiler happy while we implement the rest of the
comment|// translation.
name|bool
name|translateResume
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateCleanupRet
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateCatchRet
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateCatchSwitch
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateFence
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateAtomicCmpXchg
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateAtomicRMW
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateAddrSpaceCast
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateCleanupPad
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateCatchPad
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateUserOp1
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|translateUserOp2
parameter_list|(
specifier|const
name|User
modifier|&
name|U
parameter_list|,
name|MachineIRBuilder
modifier|&
name|MIRBuilder
parameter_list|)
block|{
return|return
name|false
return|;
block|}
comment|/// @}
comment|// Builder for machine instruction a la IRBuilder.
comment|// I.e., compared to regular MIBuilder, this one also inserts the instruction
comment|// in the current block, it can creates block, etc., basically a kind of
comment|// IRBuilder, but for Machine IR.
name|MachineIRBuilder
name|CurBuilder
decl_stmt|;
comment|// Builder set to the entry block (just after ABI lowering instructions). Used
comment|// as a convenient location for Constants.
name|MachineIRBuilder
name|EntryBuilder
decl_stmt|;
comment|// The MachineFunction currently being translated.
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
comment|/// MachineRegisterInfo used to create virtual registers.
name|MachineRegisterInfo
modifier|*
name|MRI
decl_stmt|;
specifier|const
name|DataLayout
modifier|*
name|DL
decl_stmt|;
comment|/// Current target configuration. Controls how the pass handles errors.
specifier|const
name|TargetPassConfig
modifier|*
name|TPC
decl_stmt|;
comment|/// Current optimization remark emitter. Used to report failures.
name|std
operator|::
name|unique_ptr
operator|<
name|OptimizationRemarkEmitter
operator|>
name|ORE
expr_stmt|;
comment|// * Insert all the code needed to materialize the constants
comment|// at the proper place. E.g., Entry block or dominator block
comment|// of each constant depending on how fancy we want to be.
comment|// * Clear the different maps.
name|void
name|finalizeFunction
parameter_list|()
function_decl|;
comment|/// Get the VReg that represents \p Val.
comment|/// If such VReg does not exist, it is created.
name|unsigned
name|getOrCreateVReg
parameter_list|(
specifier|const
name|Value
modifier|&
name|Val
parameter_list|)
function_decl|;
comment|/// Get the frame index that represents \p Val.
comment|/// If such VReg does not exist, it is created.
name|int
name|getOrCreateFrameIndex
parameter_list|(
specifier|const
name|AllocaInst
modifier|&
name|AI
parameter_list|)
function_decl|;
comment|/// Get the alignment of the given memory operation instruction. This will
comment|/// either be the explicitly specified value or the ABI-required alignment for
comment|/// the type being accessed (according to the Module's DataLayout).
name|unsigned
name|getMemOpAlignment
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
comment|/// Get the MachineBasicBlock that represents \p BB. Specifically, the block
comment|/// returned will be the head of the translated block (suitable for branch
comment|/// destinations).
name|MachineBasicBlock
modifier|&
name|getMBB
parameter_list|(
specifier|const
name|BasicBlock
modifier|&
name|BB
parameter_list|)
function_decl|;
comment|/// Record \p NewPred as a Machine predecessor to `Edge.second`, corresponding
comment|/// to `Edge.first` at the IR level. This is used when IRTranslation creates
comment|/// multiple MachineBasicBlocks for a given IR block and the CFG is no longer
comment|/// represented simply by the IR-level CFG.
name|void
name|addMachineCFGPred
parameter_list|(
name|CFGEdge
name|Edge
parameter_list|,
name|MachineBasicBlock
modifier|*
name|NewPred
parameter_list|)
function_decl|;
comment|/// Returns the Machine IR predecessors for the given IR CFG edge. Usually
comment|/// this is just the single MachineBasicBlock corresponding to the predecessor
comment|/// in the IR. More complex lowering can result in multiple MachineBasicBlocks
comment|/// preceding the original though (e.g. switch instructions).
name|SmallVector
operator|<
name|MachineBasicBlock
operator|*
operator|,
literal|1
operator|>
name|getMachinePredBBs
argument_list|(
argument|CFGEdge Edge
argument_list|)
block|{
name|auto
name|RemappedEdge
operator|=
name|MachinePreds
operator|.
name|find
argument_list|(
name|Edge
argument_list|)
block|;
if|if
condition|(
name|RemappedEdge
operator|!=
name|MachinePreds
operator|.
name|end
argument_list|()
condition|)
return|return
name|RemappedEdge
operator|->
name|second
return|;
return|return
name|SmallVector
operator|<
name|MachineBasicBlock
operator|*
operator|,
literal|4
operator|>
operator|(
literal|1
operator|,
operator|&
name|getMBB
argument_list|(
operator|*
name|Edge
operator|.
name|first
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// Ctor, nothing fancy.
end_comment

begin_expr_stmt
name|IRTranslator
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getPassName
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"IRTranslator"
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
name|override
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Algo:
end_comment

begin_comment
comment|//   CallLowering = MF.subtarget.getCallLowering()
end_comment

begin_comment
comment|//   F = MF.getParent()
end_comment

begin_comment
comment|//   MIRBuilder.reset(MF)
end_comment

begin_comment
comment|//   getMBB(F.getEntryBB())
end_comment

begin_comment
comment|//   CallLowering->translateArguments(MIRBuilder, F, ValToVReg)
end_comment

begin_comment
comment|//   for each bb in F
end_comment

begin_comment
comment|//     getMBB(bb)
end_comment

begin_comment
comment|//     for each inst in bb
end_comment

begin_comment
comment|//       if (!translate(MIRBuilder, inst, ValToVReg, ConstantToSequence))
end_comment

begin_comment
comment|//         report_fatal_error("Don't know how to translate input");
end_comment

begin_comment
comment|//   finalize()
end_comment

begin_decl_stmt
name|bool
name|runOnMachineFunction
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// End namespace llvm.
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

