begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==-- llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h ---------*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file This file declares the API for the instruction selector.
end_comment

begin_comment
comment|/// This class is responsible for selecting machine instructions.
end_comment

begin_comment
comment|/// It's implemented by the target. It's used by the InstructionSelect pass.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_GLOBALISEL_INSTRUCTIONSELECTORIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_GLOBALISEL_INSTRUCTIONSELECTORIMPL_H
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|TgtInstructionSelector
operator|,
name|class
name|PredicateBitset
operator|,
name|class
name|ComplexMatcherMemFn
operator|>
name|bool
name|InstructionSelector
operator|::
name|executeMatchTable
argument_list|(
argument|TgtInstructionSelector&ISel
argument_list|,
argument|NewMIVector&OutMIs
argument_list|,
argument|MatcherState&State
argument_list|,
argument|const MatcherInfoTy<PredicateBitset
argument_list|,
argument|ComplexMatcherMemFn>&MatcherInfo
argument_list|,
argument|const int64_t *MatchTable
argument_list|,
argument|const TargetInstrInfo&TII
argument_list|,
argument|MachineRegisterInfo&MRI
argument_list|,
argument|const TargetRegisterInfo&TRI
argument_list|,
argument|const RegisterBankInfo&RBI
argument_list|,
argument|const PredicateBitset&AvailableFeatures
argument_list|)
specifier|const
block|{
specifier|const
name|int64_t
operator|*
name|Command
operator|=
name|MatchTable
block|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
operator|*
name|Command
operator|++
condition|)
block|{
case|case
name|GIM_RecordInsn
case|:
block|{
name|int64_t
name|NewInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
comment|// As an optimisation we require that MIs[0] is always the root. Refuse
comment|// any attempt to modify it.
name|assert
argument_list|(
name|NewInsnID
operator|!=
literal|0
operator|&&
literal|"Refusing to modify MIs[0]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|NewInsnID
expr_stmt|;
name|MachineOperand
modifier|&
name|MO
init|=
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|MO
operator|.
name|isReg
argument_list|()
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Rejected (not a register)\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TRI
operator|.
name|isPhysicalRegister
argument_list|(
name|MO
operator|.
name|getReg
argument_list|()
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Rejected (is a physical register)\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|assert
argument_list|(
operator|(
name|size_t
operator|)
name|NewInsnID
operator|==
name|State
operator|.
name|MIs
operator|.
name|size
argument_list|()
operator|&&
literal|"Expected to store MIs in order"
argument_list|)
expr_stmt|;
name|State
operator|.
name|MIs
operator|.
name|push_back
argument_list|(
name|MRI
operator|.
name|getVRegDef
argument_list|(
name|MO
operator|.
name|getReg
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"MIs["
operator|<<
name|NewInsnID
operator|<<
literal|"] = GIM_RecordInsn("
operator|<<
name|InsnID
operator|<<
literal|", "
operator|<<
name|OpIdx
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIM_CheckFeatures
case|:
block|{
name|int64_t
name|ExpectedBitsetID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckFeatures(ExpectedBitsetID="
operator|<<
name|ExpectedBitsetID
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AvailableFeatures
operator|&
name|MatcherInfo
operator|.
name|FeatureBitsets
index|[
name|ExpectedBitsetID
index|]
operator|)
operator|!=
name|MatcherInfo
operator|.
name|FeatureBitsets
index|[
name|ExpectedBitsetID
index|]
condition|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Rejected\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
case|case
name|GIM_CheckOpcode
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Expected
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|unsigned
name|Opcode
init|=
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOpcode
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckOpcode(MIs["
operator|<<
name|InsnID
operator|<<
literal|"], ExpectedOpcode="
operator|<<
name|Expected
operator|<<
literal|") // Got="
operator|<<
name|Opcode
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Opcode
operator|!=
name|Expected
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckNumOperands
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Expected
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckNumOperands(MIs["
operator|<<
name|InsnID
operator|<<
literal|"], Expected="
operator|<<
name|Expected
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getNumOperands
argument_list|()
operator|!=
name|Expected
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckType
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|TypeID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckType(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), TypeID="
operator|<<
name|TypeID
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MRI
operator|.
name|getType
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|.
name|getReg
argument_list|()
argument_list|)
operator|!=
name|MatcherInfo
operator|.
name|TypeObjects
index|[
name|TypeID
index|]
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckRegBankForClass
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RCEnum
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckRegBankForClass(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), RCEnum="
operator|<<
name|RCEnum
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|RBI
operator|.
name|getRegBankFromRegClass
argument_list|(
operator|*
name|TRI
operator|.
name|getRegClass
argument_list|(
name|RCEnum
argument_list|)
argument_list|)
operator|!=
name|RBI
operator|.
name|getRegBank
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|.
name|getReg
argument_list|()
argument_list|,
name|MRI
argument_list|,
name|TRI
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckComplexPattern
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RendererID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|ComplexPredicateID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"State.Renderers["
operator|<<
name|RendererID
operator|<<
literal|"] = GIM_CheckComplexPattern(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), ComplexPredicateID="
operator|<<
name|ComplexPredicateID
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
comment|// FIXME: Use std::invoke() when it's available.
if|if
condition|(
operator|!
operator|(
name|State
operator|.
name|Renderers
index|[
name|RendererID
index|]
operator|=
operator|(
name|ISel
operator|.*
name|MatcherInfo
operator|.
name|ComplexPredicates
index|[
name|ComplexPredicateID
index|]
operator|)
operator|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckConstantInt
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Value
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckConstantInt(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), Value="
operator|<<
name|Value
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOperandImmEqual
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
argument_list|,
name|Value
argument_list|,
name|MRI
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckLiteralInt
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Value
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckLiteralInt(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), Value="
operator|<<
name|Value
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
name|MachineOperand
modifier|&
name|OM
init|=
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|OM
operator|.
name|isCImm
argument_list|()
operator|||
operator|!
name|OM
operator|.
name|getCImm
argument_list|()
operator|->
name|equalsInt
argument_list|(
name|Value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckIntrinsicID
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Value
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckIntrinsicID(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"), Value="
operator|<<
name|Value
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
name|MachineOperand
modifier|&
name|OM
init|=
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|OM
operator|.
name|isIntrinsicID
argument_list|()
operator|||
name|OM
operator|.
name|getIntrinsicID
argument_list|()
operator|!=
name|Value
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckIsMBB
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckIsMBB(MIs["
operator|<<
name|InsnID
operator|<<
literal|"]->getOperand("
operator|<<
name|OpIdx
operator|<<
literal|"))\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|.
name|isMBB
argument_list|()
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIM_CheckIsSafeToFold
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIM_CheckIsSafeToFold(MIs["
operator|<<
name|InsnID
operator|<<
literal|"])\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|!=
name|nullptr
operator|&&
literal|"Used insn before defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isObviouslySafeToFold
argument_list|(
operator|*
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
case|case
name|GIR_MutateOpcode
case|:
block|{
name|int64_t
name|OldInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|NewInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|NewOpcode
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size_t
operator|)
name|NewInsnID
operator|==
name|OutMIs
operator|.
name|size
argument_list|()
operator|&&
literal|"Expected to store MIs in order"
argument_list|)
expr_stmt|;
name|OutMIs
operator|.
name|push_back
argument_list|(
name|MachineInstrBuilder
argument_list|(
operator|*
name|State
operator|.
name|MIs
index|[
name|OldInsnID
index|]
operator|->
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
argument_list|,
name|State
operator|.
name|MIs
index|[
name|OldInsnID
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|NewInsnID
index|]
operator|->
name|setDesc
argument_list|(
name|TII
operator|.
name|get
argument_list|(
name|NewOpcode
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_MutateOpcode(OutMIs["
operator|<<
name|NewInsnID
operator|<<
literal|"], MIs["
operator|<<
name|OldInsnID
operator|<<
literal|"], "
operator|<<
name|NewOpcode
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_BuildMI
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Opcode
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size_t
operator|)
name|InsnID
operator|==
name|OutMIs
operator|.
name|size
argument_list|()
operator|&&
literal|"Expected to store MIs in order"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|InsnID
expr_stmt|;
name|OutMIs
operator|.
name|push_back
argument_list|(
name|BuildMI
argument_list|(
operator|*
name|State
operator|.
name|MIs
index|[
literal|0
index|]
operator|->
name|getParent
argument_list|()
argument_list|,
name|State
operator|.
name|MIs
index|[
literal|0
index|]
argument_list|,
name|State
operator|.
name|MIs
index|[
literal|0
index|]
operator|->
name|getDebugLoc
argument_list|()
argument_list|,
name|TII
operator|.
name|get
argument_list|(
name|Opcode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_BuildMI(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|Opcode
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_Copy
case|:
block|{
name|int64_t
name|NewInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OldInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|NewInsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|NewInsnID
index|]
operator|.
name|add
argument_list|(
name|State
operator|.
name|MIs
index|[
name|OldInsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_Copy(OutMIs["
operator|<<
name|NewInsnID
operator|<<
literal|"], MIs["
operator|<<
name|OldInsnID
operator|<<
literal|"], "
operator|<<
name|OpIdx
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_CopySubReg
case|:
block|{
name|int64_t
name|NewInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OldInsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|SubRegIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|NewInsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|NewInsnID
index|]
operator|.
name|addReg
argument_list|(
name|State
operator|.
name|MIs
index|[
name|OldInsnID
index|]
operator|->
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
operator|.
name|getReg
argument_list|()
argument_list|,
literal|0
argument_list|,
name|SubRegIdx
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_CopySubReg(OutMIs["
operator|<<
name|NewInsnID
operator|<<
literal|"], MIs["
operator|<<
name|OldInsnID
operator|<<
literal|"], "
operator|<<
name|OpIdx
operator|<<
literal|", "
operator|<<
name|SubRegIdx
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_AddImplicitDef
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RegNum
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|addDef
argument_list|(
name|RegNum
argument_list|,
name|RegState
operator|::
name|Implicit
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_AddImplicitDef(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|RegNum
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_AddImplicitUse
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RegNum
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|addUse
argument_list|(
name|RegNum
argument_list|,
name|RegState
operator|::
name|Implicit
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_AddImplicitUse(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|RegNum
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_AddRegister
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RegNum
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|addReg
argument_list|(
name|RegNum
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_AddRegister(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|RegNum
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_AddImm
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|Imm
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|addImm
argument_list|(
name|Imm
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_AddImm(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|Imm
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_ComplexRenderer
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RendererID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|State
operator|.
name|Renderers
index|[
name|RendererID
index|]
operator|(
name|OutMIs
index|[
name|InsnID
index|]
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_ComplexRenderer(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|RendererID
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_ConstrainOperandRC
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|OpIdx
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|int64_t
name|RCEnum
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|constrainOperandRegToRegClass
argument_list|(
operator|*
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|getInstr
argument_list|()
argument_list|,
name|OpIdx
argument_list|,
operator|*
name|TRI
operator|.
name|getRegClass
argument_list|(
name|RCEnum
argument_list|)
argument_list|,
name|TII
argument_list|,
name|TRI
argument_list|,
name|RBI
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_ConstrainOperandRC(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"], "
operator|<<
name|OpIdx
operator|<<
literal|", "
operator|<<
name|RCEnum
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_ConstrainSelectedInstOperands
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
name|constrainSelectedInstRegOperands
argument_list|(
operator|*
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|getInstr
argument_list|()
argument_list|,
name|TII
argument_list|,
name|TRI
argument_list|,
name|RBI
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_ConstrainSelectedInstOperands(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"])\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_MergeMemOperands
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|OutMIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to add to undefined instruction"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|FromMI
range|:
name|State
operator|.
name|MIs
control|)
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|MMO
range|:
name|FromMI
operator|->
name|memoperands
argument_list|()
control|)
name|OutMIs
index|[
name|InsnID
index|]
operator|.
name|addMemOperand
argument_list|(
name|MMO
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_MergeMemOperands(OutMIs["
operator|<<
name|InsnID
operator|<<
literal|"])\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_EraseFromParent
case|:
block|{
name|int64_t
name|InsnID
init|=
operator|*
name|Command
operator|++
decl_stmt|;
name|assert
argument_list|(
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|&&
literal|"Attempted to erase an undefined instruction"
argument_list|)
expr_stmt|;
name|State
operator|.
name|MIs
index|[
name|InsnID
index|]
operator|->
name|eraseFromParent
argument_list|()
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_EraseFromParent(MIs["
operator|<<
name|InsnID
operator|<<
literal|"])\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GIR_Done
case|:
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"GIR_Done"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unexpected command"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_GLOBALISEL_INSTRUCTIONSELECTORIMPL_H
end_comment

end_unit

