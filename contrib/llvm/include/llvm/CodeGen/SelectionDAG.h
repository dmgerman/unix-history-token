begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/SelectionDAG.h - InstSelection DAG ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the SelectionDAG class, and transitively defines the
end_comment

begin_comment
comment|// SDNode class and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SELECTIONDAG_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SELECTIONDAG_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/DAGCombine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGNodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/RecyclingAllocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetMachine.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AliasAnalysis
decl_stmt|;
name|class
name|MachineConstantPoolValue
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|SDDbgValue
decl_stmt|;
name|class
name|TargetLowering
decl_stmt|;
name|class
name|TargetSelectionDAGInfo
decl_stmt|;
name|class
name|TargetTransformInfo
decl_stmt|;
name|class
name|SDVTListNode
range|:
name|public
name|FoldingSetNode
block|{
name|friend
expr|struct
name|FoldingSetTrait
operator|<
name|SDVTListNode
operator|>
block|;
comment|/// FastID - A reference to an Interned FoldingSetNodeID for this node.
comment|/// The Allocator in SelectionDAG holds the data.
comment|/// SDVTList contains all types which are frequently accessed in SelectionDAG.
comment|/// The size of this list is not expected big so it won't introduce memory penalty.
name|FoldingSetNodeIDRef
name|FastID
block|;
specifier|const
name|EVT
operator|*
name|VTs
block|;
name|unsigned
name|int
name|NumVTs
block|;
comment|/// The hash value for SDVTList is fixed so cache it to avoid hash calculation
name|unsigned
name|HashValue
block|;
name|public
operator|:
name|SDVTListNode
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const EVT *VT
argument_list|,
argument|unsigned int Num
argument_list|)
operator|:
name|FastID
argument_list|(
name|ID
argument_list|)
block|,
name|VTs
argument_list|(
name|VT
argument_list|)
block|,
name|NumVTs
argument_list|(
argument|Num
argument_list|)
block|{
name|HashValue
operator|=
name|ID
operator|.
name|ComputeHash
argument_list|()
block|;   }
name|SDVTList
name|getSDVTList
argument_list|()
block|{
name|SDVTList
name|result
operator|=
block|{
name|VTs
block|,
name|NumVTs
block|}
block|;
return|return
name|result
return|;
block|}
expr|}
block|;
comment|// Specialize FoldingSetTrait for SDVTListNode
comment|// To avoid computing temp FoldingSetNodeID and hash value.
name|template
operator|<
operator|>
expr|struct
name|FoldingSetTrait
operator|<
name|SDVTListNode
operator|>
operator|:
name|DefaultFoldingSetTrait
operator|<
name|SDVTListNode
operator|>
block|{
specifier|static
name|void
name|Profile
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|FoldingSetNodeID& ID
argument_list|)
block|{
name|ID
operator|=
name|X
operator|.
name|FastID
block|;   }
specifier|static
name|bool
name|Equals
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|const FoldingSetNodeID&ID
argument_list|,
argument|unsigned IDHash
argument_list|,
argument|FoldingSetNodeID&TempID
argument_list|)
block|{
if|if
condition|(
name|X
operator|.
name|HashValue
operator|!=
name|IDHash
condition|)
return|return
name|false
return|;
return|return
name|ID
operator|==
name|X
operator|.
name|FastID
return|;
block|}
specifier|static
name|unsigned
name|ComputeHash
argument_list|(
argument|const SDVTListNode&X
argument_list|,
argument|FoldingSetNodeID&TempID
argument_list|)
block|{
return|return
name|X
operator|.
name|HashValue
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ilist_traits
operator|<
name|SDNode
operator|>
operator|:
name|public
name|ilist_default_traits
operator|<
name|SDNode
operator|>
block|{
name|private
operator|:
name|mutable
name|ilist_half_node
operator|<
name|SDNode
operator|>
name|Sentinel
block|;
name|public
operator|:
name|SDNode
operator|*
name|createSentinel
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|SDNode
operator|*
operator|>
operator|(
operator|&
name|Sentinel
operator|)
return|;
block|}
specifier|static
name|void
name|destroySentinel
argument_list|(
argument|SDNode *
argument_list|)
block|{}
name|SDNode
operator|*
name|provideInitialHead
argument_list|()
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
name|SDNode
operator|*
name|ensureHead
argument_list|(
argument|SDNode*
argument_list|)
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
specifier|static
name|void
name|noteHead
argument_list|(
argument|SDNode*
argument_list|,
argument|SDNode*
argument_list|)
block|{}
specifier|static
name|void
name|deleteNode
argument_list|(
argument|SDNode *
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"ilist_traits<SDNode> shouldn't see a deleteNode call!"
argument_list|)
block|;   }
name|private
operator|:
specifier|static
name|void
name|createNode
argument_list|(
specifier|const
name|SDNode
operator|&
argument_list|)
block|; }
block|;
comment|/// SDDbgInfo - Keeps track of dbg_value information through SDISel.  We do
comment|/// not build SDNodes for these so as not to perturb the generated code;
comment|/// instead the info is kept off to the side in this structure. Each SDNode may
comment|/// have one or more associated dbg_value entries. This information is kept in
comment|/// DbgValMap.
comment|/// Byval parameters are handled separately because they don't use alloca's,
comment|/// which busts the normal mechanism.  There is good reason for handling all
comment|/// parameters separately:  they may not have code generated for them, they
comment|/// should always go at the beginning of the function regardless of other code
comment|/// motion, and debug info for them is potentially useful even if the parameter
comment|/// is unused.  Right now only byval parameters are handled separately.
name|class
name|SDDbgInfo
block|{
name|SmallVector
operator|<
name|SDDbgValue
operator|*
block|,
literal|32
operator|>
name|DbgValues
block|;
name|SmallVector
operator|<
name|SDDbgValue
operator|*
block|,
literal|32
operator|>
name|ByvalParmDbgValues
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|SDNode
operator|*
operator|,
name|SmallVector
operator|<
name|SDDbgValue
operator|*
operator|,
literal|2
operator|>
expr|>
name|DbgValMapType
expr_stmt|;
name|DbgValMapType
name|DbgValMap
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|SDDbgInfo
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
block|;
name|SDDbgInfo
argument_list|(
argument|const SDDbgInfo&
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|public
operator|:
name|SDDbgInfo
argument_list|()
block|{}
name|void
name|add
argument_list|(
argument|SDDbgValue *V
argument_list|,
argument|const SDNode *Node
argument_list|,
argument|bool isParameter
argument_list|)
block|{
if|if
condition|(
name|isParameter
condition|)
block|{
name|ByvalParmDbgValues
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
else|else
name|DbgValues
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
if|if
condition|(
name|Node
condition|)
name|DbgValMap
index|[
name|Node
index|]
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Invalidate all DbgValues attached to the node and remove
comment|/// it from the Node-to-DbgValues map.
name|void
name|erase
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|Node
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
block|{
name|DbgValMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DbgValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ByvalParmDbgValues
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|DbgValues
operator|.
name|empty
argument_list|()
operator|&&
name|ByvalParmDbgValues
operator|.
name|empty
argument_list|()
return|;
block|}
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
name|getSDDbgValues
argument_list|(
argument|const SDNode *Node
argument_list|)
block|{
name|DbgValMapType
operator|::
name|iterator
name|I
operator|=
name|DbgValMap
operator|.
name|find
argument_list|(
name|Node
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|DbgValMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
return|;
return|return
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
name|SmallVectorImpl
operator|<
name|SDDbgValue
operator|*
operator|>
operator|::
name|iterator
name|DbgIterator
expr_stmt|;
end_typedef

begin_function
name|DbgIterator
name|DbgBegin
parameter_list|()
block|{
return|return
name|DbgValues
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|DbgEnd
parameter_list|()
block|{
return|return
name|DbgValues
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|ByvalParmDbgBegin
parameter_list|()
block|{
return|return
name|ByvalParmDbgValues
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|DbgIterator
name|ByvalParmDbgEnd
parameter_list|()
block|{
return|return
name|ByvalParmDbgValues
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|SelectionDAG
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|checkForCycles
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|checkForCycles
parameter_list|(
specifier|const
name|SelectionDAG
modifier|*
name|DAG
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// SelectionDAG class - This is used to represent a portion of an LLVM function
end_comment

begin_comment
comment|/// in a low-level Data Dependence DAG representation suitable for instruction
end_comment

begin_comment
comment|/// selection.  This DAG is constructed as the first step of instruction
end_comment

begin_comment
comment|/// selection in order to allow implementation of machine specific optimizations
end_comment

begin_comment
comment|/// and code simplifications.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The representation used by the SelectionDAG is a target-independent
end_comment

begin_comment
comment|/// representation, which has some similarities to the GCC RTL representation,
end_comment

begin_comment
comment|/// but is significantly more simple, powerful, and is a graph form instead of a
end_comment

begin_comment
comment|/// linear form.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|SelectionDAG
block|{
specifier|const
name|TargetMachine
modifier|&
name|TM
decl_stmt|;
specifier|const
name|TargetSelectionDAGInfo
modifier|&
name|TSI
decl_stmt|;
specifier|const
name|TargetTransformInfo
modifier|*
name|TTI
decl_stmt|;
specifier|const
name|TargetLowering
modifier|*
name|TLI
decl_stmt|;
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
name|LLVMContext
modifier|*
name|Context
decl_stmt|;
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
comment|/// EntryNode - The starting token.
name|SDNode
name|EntryNode
decl_stmt|;
comment|/// Root - The root of the entire DAG.
name|SDValue
name|Root
decl_stmt|;
comment|/// AllNodes - A linked list of nodes in the current DAG.
name|ilist
operator|<
name|SDNode
operator|>
name|AllNodes
expr_stmt|;
comment|/// NodeAllocatorType - The AllocatorType for allocating SDNodes. We use
comment|/// pool allocation with recycling.
typedef|typedef
name|RecyclingAllocator
operator|<
name|BumpPtrAllocator
operator|,
name|SDNode
operator|,
sizeof|sizeof
argument_list|(
name|LargestSDNode
argument_list|)
operator|,
name|AlignOf
operator|<
name|MostAlignedSDNode
operator|>
operator|::
name|Alignment
operator|>
name|NodeAllocatorType
expr_stmt|;
comment|/// NodeAllocator - Pool allocation for nodes.
name|NodeAllocatorType
name|NodeAllocator
decl_stmt|;
comment|/// CSEMap - This structure is used to memoize nodes, automatically performing
comment|/// CSE with existing nodes when a duplicate is requested.
name|FoldingSet
operator|<
name|SDNode
operator|>
name|CSEMap
expr_stmt|;
comment|/// OperandAllocator - Pool allocation for machine-opcode SDNode operands.
name|BumpPtrAllocator
name|OperandAllocator
decl_stmt|;
comment|/// Allocator - Pool allocation for misc. objects that are created once per
comment|/// SelectionDAG.
name|BumpPtrAllocator
name|Allocator
decl_stmt|;
comment|/// DbgInfo - Tracks dbg_value information through SDISel.
name|SDDbgInfo
modifier|*
name|DbgInfo
decl_stmt|;
name|public
label|:
comment|/// DAGUpdateListener - Clients of various APIs that cause global effects on
comment|/// the DAG can optionally implement this interface.  This allows the clients
comment|/// to handle the various sorts of updates that happen.
comment|///
comment|/// A DAGUpdateListener automatically registers itself with DAG when it is
comment|/// constructed, and removes itself when destroyed in RAII fashion.
struct|struct
name|DAGUpdateListener
block|{
name|DAGUpdateListener
modifier|*
specifier|const
name|Next
decl_stmt|;
name|SelectionDAG
modifier|&
name|DAG
decl_stmt|;
name|explicit
name|DAGUpdateListener
argument_list|(
name|SelectionDAG
operator|&
name|D
argument_list|)
operator|:
name|Next
argument_list|(
name|D
operator|.
name|UpdateListeners
argument_list|)
operator|,
name|DAG
argument_list|(
argument|D
argument_list|)
block|{
name|DAG
operator|.
name|UpdateListeners
operator|=
name|this
block|;     }
name|virtual
operator|~
name|DAGUpdateListener
argument_list|()
block|{
name|assert
argument_list|(
name|DAG
operator|.
name|UpdateListeners
operator|==
name|this
operator|&&
literal|"DAGUpdateListeners must be destroyed in LIFO order"
argument_list|)
block|;
name|DAG
operator|.
name|UpdateListeners
operator|=
name|Next
block|;     }
comment|/// NodeDeleted - The node N that was deleted and, if E is not null, an
comment|/// equivalent node E that replaced it.
name|virtual
name|void
name|NodeDeleted
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|SDNode
operator|*
name|E
argument_list|)
expr_stmt|;
comment|/// NodeUpdated - The node N that was updated.
name|virtual
name|void
name|NodeUpdated
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
block|}
struct|;
comment|/// NewNodesMustHaveLegalTypes - When true, additional steps are taken to
comment|/// ensure that getConstant() and similar functions return DAG nodes that
comment|/// have legal types. This is important after type legalization since
comment|/// any illegally typed nodes generated after this point will not experience
comment|/// type legalization.
name|bool
name|NewNodesMustHaveLegalTypes
decl_stmt|;
name|private
label|:
comment|/// DAGUpdateListener is a friend so it can manipulate the listener stack.
name|friend
struct_decl|struct
name|DAGUpdateListener
struct_decl|;
comment|/// UpdateListeners - Linked list of registered DAGUpdateListener instances.
comment|/// This stack is maintained by DAGUpdateListener RAII.
name|DAGUpdateListener
modifier|*
name|UpdateListeners
decl_stmt|;
comment|/// setGraphColorHelper - Implementation of setSubgraphColor.
comment|/// Return whether we had to truncate the search.
comment|///
name|bool
name|setSubgraphColorHelper
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
specifier|const
name|char
operator|*
name|Color
argument_list|,
name|DenseSet
operator|<
name|SDNode
operator|*
operator|>
operator|&
name|visited
argument_list|,
name|int
name|level
argument_list|,
name|bool
operator|&
name|printed
argument_list|)
decl_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|SelectionDAG
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|SelectionDAG
argument_list|(
argument|const SelectionDAG&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|public
label|:
name|explicit
name|SelectionDAG
argument_list|(
specifier|const
name|TargetMachine
operator|&
name|TM
argument_list|,
name|llvm
operator|::
name|CodeGenOpt
operator|::
name|Level
argument_list|)
decl_stmt|;
operator|~
name|SelectionDAG
argument_list|()
expr_stmt|;
comment|/// init - Prepare this SelectionDAG to process code in the given
comment|/// MachineFunction.
comment|///
name|void
name|init
parameter_list|(
name|MachineFunction
modifier|&
name|mf
parameter_list|,
specifier|const
name|TargetTransformInfo
modifier|*
name|TTI
parameter_list|,
specifier|const
name|TargetLowering
modifier|*
name|TLI
parameter_list|)
function_decl|;
comment|/// clear - Clear state and free memory necessary to make this
comment|/// SelectionDAG ready to process a new block.
comment|///
name|void
name|clear
parameter_list|()
function_decl|;
name|MachineFunction
operator|&
name|getMachineFunction
argument_list|()
specifier|const
block|{
return|return
operator|*
name|MF
return|;
block|}
specifier|const
name|TargetMachine
operator|&
name|getTarget
argument_list|()
specifier|const
block|{
return|return
name|TM
return|;
block|}
specifier|const
name|TargetLowering
operator|&
name|getTargetLoweringInfo
argument_list|()
specifier|const
block|{
return|return
operator|*
name|TLI
return|;
block|}
specifier|const
name|TargetSelectionDAGInfo
operator|&
name|getSelectionDAGInfo
argument_list|()
specifier|const
block|{
return|return
name|TSI
return|;
block|}
specifier|const
name|TargetTransformInfo
operator|*
name|getTargetTransformInfo
argument_list|()
specifier|const
block|{
return|return
name|TTI
return|;
block|}
name|LLVMContext
operator|*
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// viewGraph - Pop up a GraphViz/gv window with the DAG rendered using 'dot'.
comment|///
name|void
name|viewGraph
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Title
argument_list|)
decl_stmt|;
name|void
name|viewGraph
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|NDEBUG
name|std
operator|::
name|map
operator|<
specifier|const
name|SDNode
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|NodeGraphAttrs
expr_stmt|;
endif|#
directive|endif
comment|/// clearGraphAttrs - Clear all previously defined node graph attributes.
comment|/// Intended to be used from a debugging tool (eg. gdb).
name|void
name|clearGraphAttrs
parameter_list|()
function_decl|;
comment|/// setGraphAttrs - Set graph attributes for a node. (eg. "color=red".)
comment|///
name|void
name|setGraphAttrs
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Attrs
parameter_list|)
function_decl|;
comment|/// getGraphAttrs - Get graph attributes for a node. (eg. "color=red".)
comment|/// Used from getNodeAttributes.
specifier|const
name|std
operator|::
name|string
name|getGraphAttrs
argument_list|(
argument|const SDNode *N
argument_list|)
specifier|const
expr_stmt|;
comment|/// setGraphColor - Convenience for setting node color attribute.
comment|///
name|void
name|setGraphColor
parameter_list|(
specifier|const
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Color
parameter_list|)
function_decl|;
comment|/// setGraphColor - Convenience for setting subgraph color attribute.
comment|///
name|void
name|setSubgraphColor
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|Color
parameter_list|)
function_decl|;
typedef|typedef
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|const_iterator
name|allnodes_const_iterator
expr_stmt|;
name|allnodes_const_iterator
name|allnodes_begin
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|begin
argument_list|()
return|;
block|}
name|allnodes_const_iterator
name|allnodes_end
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|end
argument_list|()
return|;
block|}
typedef|typedef
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|iterator
name|allnodes_iterator
expr_stmt|;
name|allnodes_iterator
name|allnodes_begin
parameter_list|()
block|{
return|return
name|AllNodes
operator|.
name|begin
argument_list|()
return|;
block|}
name|allnodes_iterator
name|allnodes_end
parameter_list|()
block|{
return|return
name|AllNodes
operator|.
name|end
argument_list|()
return|;
block|}
name|ilist
operator|<
name|SDNode
operator|>
operator|::
name|size_type
name|allnodes_size
argument_list|()
specifier|const
block|{
return|return
name|AllNodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// getRoot - Return the root tag of the SelectionDAG.
comment|///
specifier|const
name|SDValue
operator|&
name|getRoot
argument_list|()
specifier|const
block|{
return|return
name|Root
return|;
block|}
comment|/// getEntryNode - Return the token chain corresponding to the entry of the
comment|/// function.
name|SDValue
name|getEntryNode
argument_list|()
specifier|const
block|{
return|return
name|SDValue
argument_list|(
name|const_cast
operator|<
name|SDNode
operator|*
operator|>
operator|(
operator|&
name|EntryNode
operator|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// setRoot - Set the current root tag of the SelectionDAG.
comment|///
specifier|const
name|SDValue
modifier|&
name|setRoot
parameter_list|(
name|SDValue
name|N
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|N
operator|.
name|getNode
argument_list|()
operator|||
name|N
operator|.
name|getValueType
argument_list|()
operator|==
name|MVT
operator|::
name|Other
operator|)
operator|&&
literal|"DAG root value is not a chain!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|N
operator|.
name|getNode
argument_list|()
condition|)
name|checkForCycles
argument_list|(
name|N
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
name|Root
operator|=
name|N
expr_stmt|;
if|if
condition|(
name|N
operator|.
name|getNode
argument_list|()
condition|)
name|checkForCycles
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Root
return|;
block|}
comment|/// Combine - This iterates over the nodes in the SelectionDAG, folding
comment|/// certain types of nodes together, or eliminating superfluous nodes.  The
comment|/// Level argument controls whether Combine is allowed to produce nodes and
comment|/// types that are illegal on the target.
name|void
name|Combine
argument_list|(
name|CombineLevel
name|Level
argument_list|,
name|AliasAnalysis
operator|&
name|AA
argument_list|,
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
argument_list|)
decl_stmt|;
comment|/// LegalizeTypes - This transforms the SelectionDAG into a SelectionDAG that
comment|/// only uses types natively supported by the target.  Returns "true" if it
comment|/// made any changes.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|bool
name|LegalizeTypes
parameter_list|()
function_decl|;
comment|/// Legalize - This transforms the SelectionDAG into a SelectionDAG that is
comment|/// compatible with the target instruction selector, as indicated by the
comment|/// TargetLowering object.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|void
name|Legalize
parameter_list|()
function_decl|;
comment|/// LegalizeVectors - This transforms the SelectionDAG into a SelectionDAG
comment|/// that only uses vector math operations supported by the target.  This is
comment|/// necessary as a separate step from Legalize because unrolling a vector
comment|/// operation can introduce illegal types, which requires running
comment|/// LegalizeTypes again.
comment|///
comment|/// This returns true if it made any changes; in that case, LegalizeTypes
comment|/// is called again before Legalize.
comment|///
comment|/// Note that this is an involved process that may invalidate pointers into
comment|/// the graph.
name|bool
name|LegalizeVectors
parameter_list|()
function_decl|;
comment|/// RemoveDeadNodes - This method deletes all unreachable nodes in the
comment|/// SelectionDAG.
name|void
name|RemoveDeadNodes
parameter_list|()
function_decl|;
comment|/// DeleteNode - Remove the specified node from the system.  This node must
comment|/// have no referrers.
name|void
name|DeleteNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// getVTList - Return an SDVTList that represents the list of values
comment|/// specified.
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|EVT
name|VT4
parameter_list|)
function_decl|;
name|SDVTList
name|getVTList
parameter_list|(
specifier|const
name|EVT
modifier|*
name|VTs
parameter_list|,
name|unsigned
name|NumVTs
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Node creation methods.
comment|//
name|SDValue
name|getConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstant
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstant
parameter_list|(
specifier|const
name|ConstantInt
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getIntPtrConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstant
parameter_list|(
name|uint64_t
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstant
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstant
parameter_list|(
specifier|const
name|ConstantInt
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstant
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|// The forms below that take a double should only be used for simple
comment|// constants that can be exactly represented in VT.  No checks are made.
name|SDValue
name|getConstantFP
parameter_list|(
name|double
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstantFP
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getConstantFP
parameter_list|(
specifier|const
name|ConstantFP
modifier|&
name|CF
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantFP
parameter_list|(
name|double
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstantFP
parameter_list|(
specifier|const
name|APFloat
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getTargetConstantFP
parameter_list|(
specifier|const
name|ConstantFP
modifier|&
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getConstantFP
argument_list|(
name|Val
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getGlobalAddress
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|GV
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|offset
init|=
literal|0
parameter_list|,
name|bool
name|isTargetGA
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetGlobalAddress
parameter_list|(
specifier|const
name|GlobalValue
modifier|*
name|GV
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getGlobalAddress
argument_list|(
name|GV
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getFrameIndex
parameter_list|(
name|int
name|FI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|)
function_decl|;
name|SDValue
name|getTargetFrameIndex
parameter_list|(
name|int
name|FI
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getFrameIndex
argument_list|(
name|FI
argument_list|,
name|VT
argument_list|,
name|true
argument_list|)
return|;
block|}
name|SDValue
name|getJumpTable
parameter_list|(
name|int
name|JTI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetJumpTable
parameter_list|(
name|int
name|JTI
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getJumpTable
argument_list|(
name|JTI
argument_list|,
name|VT
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getConstantPool
parameter_list|(
specifier|const
name|Constant
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offs
init|=
literal|0
parameter_list|,
name|bool
name|isT
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantPool
parameter_list|(
specifier|const
name|Constant
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getConstantPool
argument_list|(
name|C
argument_list|,
name|VT
argument_list|,
name|Align
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getConstantPool
parameter_list|(
name|MachineConstantPoolValue
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offs
init|=
literal|0
parameter_list|,
name|bool
name|isT
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetConstantPool
parameter_list|(
name|MachineConstantPoolValue
modifier|*
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|int
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getConstantPool
argument_list|(
name|C
argument_list|,
name|VT
argument_list|,
name|Align
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getTargetIndex
parameter_list|(
name|int
name|Index
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
comment|// When generating a branch to a BB, we don't in general know enough
comment|// to provide debug info for the BB at that time, so keep this one around.
name|SDValue
name|getBasicBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|)
function_decl|;
name|SDValue
name|getBasicBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|,
name|SDLoc
name|dl
parameter_list|)
function_decl|;
name|SDValue
name|getExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getTargetExternalSymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|Sym
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getValueType
parameter_list|(
name|EVT
parameter_list|)
function_decl|;
name|SDValue
name|getRegister
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getRegisterMask
parameter_list|(
specifier|const
name|uint32_t
modifier|*
name|RegMask
parameter_list|)
function_decl|;
name|SDValue
name|getEHLabel
parameter_list|(
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Root
parameter_list|,
name|MCSymbol
modifier|*
name|Label
parameter_list|)
function_decl|;
name|SDValue
name|getBlockAddress
parameter_list|(
specifier|const
name|BlockAddress
modifier|*
name|BA
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|bool
name|isTarget
init|=
name|false
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTargetBlockAddress
parameter_list|(
specifier|const
name|BlockAddress
modifier|*
name|BA
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|,
name|unsigned
name|char
name|TargetFlags
init|=
literal|0
parameter_list|)
block|{
return|return
name|getBlockAddress
argument_list|(
name|BA
argument_list|,
name|VT
argument_list|,
name|Offset
argument_list|,
name|true
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|MVT
operator|::
name|Other
argument_list|,
name|Chain
argument_list|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
argument_list|,
name|N
argument_list|)
return|;
block|}
comment|// This version of the getCopyToReg method takes an extra operand, which
comment|// indicates that there is potentially an incoming glue value (if Glue is not
comment|// null) and that there should be a glue result.
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
block|,
name|N
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|4
else|:
literal|3
argument_list|)
return|;
block|}
comment|// Similar to last getCopyToReg() except parameter Reg is a SDValue
name|SDValue
name|getCopyToReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Reg
parameter_list|,
name|SDValue
name|N
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|Reg
block|,
name|N
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyToReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|4
else|:
literal|3
argument_list|)
return|;
block|}
name|SDValue
name|getCopyFromReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|VT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
argument|Reg
argument_list|,
argument|VT
argument_list|)
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyFromReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|// This version of the getCopyFromReg method takes an extra operand, which
comment|// indicates that there is potentially an incoming glue value (if Glue is not
comment|// null) and that there should be a glue result.
name|SDValue
name|getCopyFromReg
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Glue
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|VT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|getRegister
argument_list|(
name|Reg
argument_list|,
name|VT
argument_list|)
block|,
name|Glue
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CopyFromReg
argument_list|,
name|dl
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|,
name|Glue
operator|.
name|getNode
argument_list|()
condition|?
literal|3
else|:
literal|2
argument_list|)
return|;
block|}
name|SDValue
name|getCondCode
argument_list|(
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
decl_stmt|;
comment|/// Returns the ConvertRndSat Note: Avoid using this node because it may
comment|/// disappear in the future and most targets don't support it.
name|SDValue
name|getConvertRndSat
argument_list|(
name|EVT
name|VT
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
name|Val
argument_list|,
name|SDValue
name|DTy
argument_list|,
name|SDValue
name|STy
argument_list|,
name|SDValue
name|Rnd
argument_list|,
name|SDValue
name|Sat
argument_list|,
name|ISD
operator|::
name|CvtCode
name|Code
argument_list|)
decl_stmt|;
comment|/// getVectorShuffle - Return an ISD::VECTOR_SHUFFLE node.  The number of
comment|/// elements in VT, which must be a vector type, must match the number of
comment|/// mask elements NumElts.  A integer mask element equal to -1 is treated as
comment|/// undefined.
name|SDValue
name|getVectorShuffle
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
specifier|const
name|int
modifier|*
name|MaskElts
parameter_list|)
function_decl|;
comment|/// getAnyExtOrTrunc - Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either any-extending or truncating it.
name|SDValue
name|getAnyExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// getSExtOrTrunc - Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either sign-extending or truncating it.
name|SDValue
name|getSExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// getZExtOrTrunc - Convert Op, which must be of integer type, to the
comment|/// integer type VT, by either zero-extending or truncating it.
name|SDValue
name|getZExtOrTrunc
parameter_list|(
name|SDValue
name|Op
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// getZeroExtendInReg - Return the expression required to zero extend the Op
comment|/// value assuming it was the smaller SrcTy value.
name|SDValue
name|getZeroExtendInReg
parameter_list|(
name|SDValue
name|Op
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|SrcTy
parameter_list|)
function_decl|;
comment|/// getNOT - Create a bitwise NOT operation as (XOR Val, -1).
name|SDValue
name|getNOT
parameter_list|(
name|SDLoc
name|DL
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
comment|/// getCALLSEQ_START - Return a new CALLSEQ_START node, which always must have
comment|/// a glue result (to ensure it's not CSE'd).  CALLSEQ_START does not have a
comment|/// useful SDLoc.
name|SDValue
name|getCALLSEQ_START
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Op
parameter_list|,
name|SDLoc
name|DL
parameter_list|)
block|{
name|SDVTList
name|VTs
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SDValue
name|Ops
index|[]
init|=
block|{
name|Chain
block|,
name|Op
block|}
decl_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CALLSEQ_START
argument_list|,
name|DL
argument_list|,
name|VTs
argument_list|,
name|Ops
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/// getCALLSEQ_END - Return a new CALLSEQ_END node, which always must have a
comment|/// glue result (to ensure it's not CSE'd).  CALLSEQ_END does not have
comment|/// a useful SDLoc.
name|SDValue
name|getCALLSEQ_END
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|InGlue
parameter_list|,
name|SDLoc
name|DL
parameter_list|)
block|{
name|SDVTList
name|NodeTys
init|=
name|getVTList
argument_list|(
name|MVT
operator|::
name|Other
argument_list|,
name|MVT
operator|::
name|Glue
argument_list|)
decl_stmt|;
name|SmallVector
operator|<
name|SDValue
operator|,
literal|4
operator|>
name|Ops
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Chain
argument_list|)
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Op1
argument_list|)
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|Op2
argument_list|)
expr_stmt|;
name|Ops
operator|.
name|push_back
argument_list|(
name|InGlue
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|CALLSEQ_END
argument_list|,
name|DL
argument_list|,
name|NodeTys
argument_list|,
operator|&
name|Ops
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|Ops
operator|.
name|size
argument_list|()
operator|-
operator|(
name|InGlue
operator|.
name|getNode
argument_list|()
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
comment|/// getUNDEF - Return an UNDEF node.  UNDEF does not have a useful SDLoc.
name|SDValue
name|getUNDEF
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|UNDEF
argument_list|,
name|SDLoc
argument_list|()
argument_list|,
name|VT
argument_list|)
return|;
block|}
comment|/// getGLOBAL_OFFSET_TABLE - Return a GLOBAL_OFFSET_TABLE node.  This does
comment|/// not have a useful SDLoc.
name|SDValue
name|getGLOBAL_OFFSET_TABLE
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|GLOBAL_OFFSET_TABLE
argument_list|,
name|SDLoc
argument_list|()
argument_list|,
name|VT
argument_list|)
return|;
block|}
comment|/// getNode - Gets or creates the specified node.
comment|///
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|,
name|SDValue
name|N5
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDUse
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDValue
name|getNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|DL
argument_list|,
name|ArrayRef
operator|<
name|EVT
operator|>
name|ResultTys
argument_list|,
specifier|const
name|SDValue
operator|*
name|Ops
argument_list|,
name|unsigned
name|NumOps
argument_list|)
decl_stmt|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
specifier|const
name|EVT
modifier|*
name|VTs
parameter_list|,
name|unsigned
name|NumVTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|)
function_decl|;
name|SDValue
name|getNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
name|SDValue
name|N1
parameter_list|,
name|SDValue
name|N2
parameter_list|,
name|SDValue
name|N3
parameter_list|,
name|SDValue
name|N4
parameter_list|,
name|SDValue
name|N5
parameter_list|)
function_decl|;
comment|/// getStackArgumentTokenFactor - Compute a TokenFactor to force all
comment|/// the incoming stack arguments to be loaded from the stack. This is
comment|/// used in tail call lowering to protect stack arguments from being
comment|/// clobbered.
name|SDValue
name|getStackArgumentTokenFactor
parameter_list|(
name|SDValue
name|Chain
parameter_list|)
function_decl|;
name|SDValue
name|getMemcpy
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|bool
name|AlwaysInline
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|,
name|MachinePointerInfo
name|SrcPtrInfo
parameter_list|)
function_decl|;
name|SDValue
name|getMemmove
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|,
name|MachinePointerInfo
name|SrcPtrInfo
parameter_list|)
function_decl|;
name|SDValue
name|getMemset
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Dst
parameter_list|,
name|SDValue
name|Src
parameter_list|,
name|SDValue
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|bool
name|isVol
parameter_list|,
name|MachinePointerInfo
name|DstPtrInfo
parameter_list|)
function_decl|;
comment|/// getSetCC - Helper function to make it easier to build SetCC's if you just
comment|/// have an ISD::CondCode instead of an SDValue.
comment|///
name|SDValue
name|getSetCC
argument_list|(
name|SDLoc
name|DL
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|LHS
argument_list|,
name|SDValue
name|RHS
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
block|{
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|==
name|RHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot compare scalars to vectors"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|==
name|VT
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot compare scalars to vectors"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Cond
operator|!=
name|ISD
operator|::
name|SETCC_INVALID
operator|&&
literal|"Cannot create a setCC of an invalid node."
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|SETCC
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|getCondCode
argument_list|(
name|Cond
argument_list|)
argument_list|)
return|;
block|}
comment|// getSelect - Helper function to make it easier to build Select's if you just
comment|// have operands and don't want to check for vector.
name|SDValue
name|getSelect
parameter_list|(
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Cond
parameter_list|,
name|SDValue
name|LHS
parameter_list|,
name|SDValue
name|RHS
parameter_list|)
block|{
name|assert
argument_list|(
name|LHS
operator|.
name|getValueType
argument_list|()
operator|==
name|RHS
operator|.
name|getValueType
argument_list|()
operator|&&
literal|"Cannot use select on differing types"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|VT
operator|.
name|isVector
argument_list|()
operator|==
name|LHS
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
operator|&&
literal|"Cannot mix vectors and scalars"
argument_list|)
expr_stmt|;
return|return
name|getNode
argument_list|(
name|Cond
operator|.
name|getValueType
argument_list|()
operator|.
name|isVector
argument_list|()
condition|?
name|ISD
operator|::
name|VSELECT
else|:
name|ISD
operator|::
name|SELECT
argument_list|,
name|DL
argument_list|,
name|VT
argument_list|,
name|Cond
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|/// getSelectCC - Helper function to make it easier to build SelectCC's if you
comment|/// just have an ISD::CondCode instead of an SDValue.
comment|///
name|SDValue
name|getSelectCC
argument_list|(
name|SDLoc
name|DL
argument_list|,
name|SDValue
name|LHS
argument_list|,
name|SDValue
name|RHS
argument_list|,
name|SDValue
name|True
argument_list|,
name|SDValue
name|False
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|)
block|{
return|return
name|getNode
argument_list|(
name|ISD
operator|::
name|SELECT_CC
argument_list|,
name|DL
argument_list|,
name|True
operator|.
name|getValueType
argument_list|()
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|True
argument_list|,
name|False
argument_list|,
name|getCondCode
argument_list|(
name|Cond
argument_list|)
argument_list|)
return|;
block|}
comment|/// getVAArg - VAArg produces a result and token chain, and takes a pointer
comment|/// and a source value as input.
name|SDValue
name|getVAArg
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|SV
parameter_list|,
name|unsigned
name|Align
parameter_list|)
function_decl|;
comment|/// getAtomic - Gets a node for an atomic op, produces result and chain and
comment|/// takes 3 operands
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Cmp
parameter_list|,
name|SDValue
name|Swp
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Cmp
parameter_list|,
name|SDValue
name|Swp
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
comment|/// getAtomic - Gets a node for an atomic op, produces result (if relevant)
comment|/// and chain and takes 2 operands.
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Val
parameter_list|,
specifier|const
name|Value
modifier|*
name|PtrVal
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
comment|/// getAtomic - Gets a node for an atomic op, produces result and chain and
comment|/// takes 1 operand.
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
specifier|const
name|Value
modifier|*
name|PtrVal
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
comment|/// getAtomic - Gets a node for an atomic op, produces result and chain and
comment|/// takes N operands.
name|SDValue
name|getAtomic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|SDVTList
name|VTList
parameter_list|,
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|,
name|AtomicOrdering
name|Ordering
parameter_list|,
name|SynchronizationScope
name|SynchScope
parameter_list|)
function_decl|;
comment|/// getMemIntrinsicNode - Creates a MemIntrinsicNode that may produce a
comment|/// result and takes a list of operands. Opcode may be INTRINSIC_VOID,
comment|/// INTRINSIC_W_CHAIN, or a target-specific opcode with a value not
comment|/// less than FIRST_TARGET_MEMORY_OPCODE.
name|SDValue
name|getMemIntrinsicNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
specifier|const
name|EVT
modifier|*
name|VTs
parameter_list|,
name|unsigned
name|NumVTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|bool
name|Vol
init|=
name|false
parameter_list|,
name|bool
name|ReadMem
init|=
name|true
parameter_list|,
name|bool
name|WriteMem
init|=
name|true
parameter_list|)
function_decl|;
name|SDValue
name|getMemIntrinsicNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDVTList
name|VTList
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|unsigned
name|Align
init|=
literal|0
parameter_list|,
name|bool
name|Vol
init|=
name|false
parameter_list|,
name|bool
name|ReadMem
init|=
name|true
parameter_list|,
name|bool
name|WriteMem
init|=
name|true
parameter_list|)
function_decl|;
name|SDValue
name|getMemIntrinsicNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDVTList
name|VTList
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|EVT
name|MemVT
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
comment|/// getMergeValues - Create a MERGE_VALUES node from the given operands.
name|SDValue
name|getMergeValues
parameter_list|(
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|SDLoc
name|dl
parameter_list|)
function_decl|;
comment|/// getLoad - Loads are not normal binary operators: their result type is not
comment|/// determined by their operands, and they produce a value AND a token chain.
comment|///
name|SDValue
name|getLoad
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|bool
name|isVolatile
parameter_list|,
name|bool
name|isNonTemporal
parameter_list|,
name|bool
name|isInvariant
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|TBAAInfo
init|=
literal|0
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|Ranges
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getLoad
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Chain
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getExtLoad
argument_list|(
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|bool
name|isVolatile
argument_list|,
name|bool
name|isNonTemporal
argument_list|,
name|unsigned
name|Alignment
argument_list|,
specifier|const
name|MDNode
operator|*
name|TBAAInfo
operator|=
literal|0
argument_list|)
decl_stmt|;
name|SDValue
name|getExtLoad
argument_list|(
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
name|SDValue
name|getIndexedLoad
argument_list|(
name|SDValue
name|OrigLoad
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
name|Base
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|)
decl_stmt|;
name|SDValue
name|getLoad
argument_list|(
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|,
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|MachinePointerInfo
name|PtrInfo
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|bool
name|isVolatile
argument_list|,
name|bool
name|isNonTemporal
argument_list|,
name|bool
name|isInvariant
argument_list|,
name|unsigned
name|Alignment
argument_list|,
specifier|const
name|MDNode
operator|*
name|TBAAInfo
operator|=
literal|0
argument_list|,
specifier|const
name|MDNode
operator|*
name|Ranges
operator|=
literal|0
argument_list|)
decl_stmt|;
name|SDValue
name|getLoad
argument_list|(
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|,
name|ISD
operator|::
name|LoadExtType
name|ExtType
argument_list|,
name|EVT
name|VT
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
name|Chain
argument_list|,
name|SDValue
name|Ptr
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|EVT
name|MemVT
argument_list|,
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl_stmt|;
comment|/// getStore - Helper function to build ISD::STORE nodes.
comment|///
name|SDValue
name|getStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|bool
name|isVolatile
parameter_list|,
name|bool
name|isNonTemporal
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|TBAAInfo
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getTruncStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|MachinePointerInfo
name|PtrInfo
parameter_list|,
name|EVT
name|TVT
parameter_list|,
name|bool
name|isNonTemporal
parameter_list|,
name|bool
name|isVolatile
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|TBAAInfo
init|=
literal|0
parameter_list|)
function_decl|;
name|SDValue
name|getTruncStore
parameter_list|(
name|SDValue
name|Chain
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|SDValue
name|Val
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|EVT
name|TVT
parameter_list|,
name|MachineMemOperand
modifier|*
name|MMO
parameter_list|)
function_decl|;
name|SDValue
name|getIndexedStore
argument_list|(
name|SDValue
name|OrigStoe
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDValue
name|Base
argument_list|,
name|SDValue
name|Offset
argument_list|,
name|ISD
operator|::
name|MemIndexedMode
name|AM
argument_list|)
decl_stmt|;
comment|/// getSrcValue - Construct a node to track a Value* through the backend.
name|SDValue
name|getSrcValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/// getMDNode - Return an MDNodeSDNode which holds an MDNode.
name|SDValue
name|getMDNode
parameter_list|(
specifier|const
name|MDNode
modifier|*
name|MD
parameter_list|)
function_decl|;
comment|/// getAddrSpaceCast - Return an AddrSpaceCastSDNode.
name|SDValue
name|getAddrSpaceCast
parameter_list|(
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Ptr
parameter_list|,
name|unsigned
name|SrcAS
parameter_list|,
name|unsigned
name|DestAS
parameter_list|)
function_decl|;
comment|/// getShiftAmountOperand - Return the specified value casted to
comment|/// the target's desired shift amount type.
name|SDValue
name|getShiftAmountOperand
parameter_list|(
name|EVT
name|LHSTy
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
comment|/// UpdateNodeOperands - *Mutate* the specified node in-place to have the
comment|/// specified operands.  If the resultant node already exists in the DAG,
comment|/// this does not modify the specified node, instead it returns the node that
comment|/// already exists.  If the resultant node does not exist in the DAG, the
comment|/// input node is returned.  As a degenerate case, if you specify the same
comment|/// input operands as the node already has, the input node is returned.
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|,
name|SDValue
name|Op4
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|,
name|SDValue
name|Op4
parameter_list|,
name|SDValue
name|Op5
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdateNodeOperands
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
comment|/// SelectNodeTo - These are used for target selectors to *mutate* the
comment|/// specified node to have the specified return type, Target opcode, and
comment|/// operands.  Note that target opcodes are stored as
comment|/// ~TargetOpcode in the node opcode field.  The resultant node is returned.
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|MachineOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|EVT
name|VT4
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|SelectNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|TargetOpc
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
comment|/// MorphNodeTo - This *mutates* the specified node to have the specified
comment|/// return type, opcode, and operands.
name|SDNode
modifier|*
name|MorphNodeTo
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|Opc
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
comment|/// getMachineNode - These are used for target selectors to create a new node
comment|/// with specified return type(s), MachineInstr opcode, and operands.
comment|///
comment|/// Note that getMachineNode returns the resultant node.  If there is already
comment|/// a node of the specified opcode and operands, it returns that node instead
comment|/// of the current one.
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDLoc
name|dl
parameter_list|,
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|,
name|EVT
name|VT3
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|SDValue
name|Op3
parameter_list|)
function_decl|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|EVT
name|VT3
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|EVT
name|VT1
argument_list|,
name|EVT
name|VT2
argument_list|,
name|EVT
name|VT3
argument_list|,
name|EVT
name|VT4
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|ArrayRef
operator|<
name|EVT
operator|>
name|ResultTys
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
name|MachineSDNode
modifier|*
name|getMachineNode
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|SDLoc
name|dl
argument_list|,
name|SDVTList
name|VTs
argument_list|,
name|ArrayRef
operator|<
name|SDValue
operator|>
name|Ops
argument_list|)
decl_stmt|;
comment|/// getTargetExtractSubreg - A convenience function for creating
comment|/// TargetInstrInfo::EXTRACT_SUBREG nodes.
name|SDValue
name|getTargetExtractSubreg
parameter_list|(
name|int
name|SRIdx
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Operand
parameter_list|)
function_decl|;
comment|/// getTargetInsertSubreg - A convenience function for creating
comment|/// TargetInstrInfo::INSERT_SUBREG nodes.
name|SDValue
name|getTargetInsertSubreg
parameter_list|(
name|int
name|SRIdx
parameter_list|,
name|SDLoc
name|DL
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDValue
name|Operand
parameter_list|,
name|SDValue
name|Subreg
parameter_list|)
function_decl|;
comment|/// getNodeIfExists - Get the specified node if it's already available, or
comment|/// else return NULL.
name|SDNode
modifier|*
name|getNodeIfExists
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|SDVTList
name|VTs
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|)
function_decl|;
comment|/// getDbgValue - Creates a SDDbgValue node.
comment|///
name|SDDbgValue
modifier|*
name|getDbgValue
parameter_list|(
name|MDNode
modifier|*
name|MDPtr
parameter_list|,
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|R
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
name|SDDbgValue
modifier|*
name|getDbgValue
parameter_list|(
name|MDNode
modifier|*
name|MDPtr
parameter_list|,
specifier|const
name|Value
modifier|*
name|C
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
name|SDDbgValue
modifier|*
name|getDbgValue
parameter_list|(
name|MDNode
modifier|*
name|MDPtr
parameter_list|,
name|unsigned
name|FI
parameter_list|,
name|uint64_t
name|Off
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
name|unsigned
name|O
parameter_list|)
function_decl|;
comment|/// RemoveDeadNode - Remove the specified node from the system. If any of its
comment|/// operands then becomes dead, remove them as well. Inform UpdateListener
comment|/// for each node deleted.
name|void
name|RemoveDeadNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// RemoveDeadNodes - This method deletes the unreachable nodes in the
comment|/// given list, and any nodes that become unreachable as a result.
name|void
name|RemoveDeadNodes
argument_list|(
name|SmallVectorImpl
operator|<
name|SDNode
operator|*
operator|>
operator|&
name|DeadNodes
argument_list|)
decl_stmt|;
comment|/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.
comment|/// This can cause recursive merging of nodes in the DAG.  Use the first
comment|/// version if 'From' is known to have a single result, use the second
comment|/// if you have two nodes with identical results (or if 'To' has a superset
comment|/// of the results of 'From'), use the third otherwise.
comment|///
comment|/// These methods all take an optional UpdateListener, which (if not null) is
comment|/// informed about nodes that are deleted and modified due to recursive
comment|/// changes in the dag.
comment|///
comment|/// These functions only replace all existing uses. It's possible that as
comment|/// these replacements are being performed, CSE may cause the From node
comment|/// to be given new uses. These new uses of From are left in place, and
comment|/// not automatically transferred to To.
comment|///
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|Op
parameter_list|)
function_decl|;
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDNode
modifier|*
name|From
parameter_list|,
name|SDNode
modifier|*
name|To
parameter_list|)
function_decl|;
name|void
name|ReplaceAllUsesWith
parameter_list|(
name|SDNode
modifier|*
name|From
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|To
parameter_list|)
function_decl|;
comment|/// ReplaceAllUsesOfValueWith - Replace any uses of From with To, leaving
comment|/// uses of other values produced by From.Val alone.
name|void
name|ReplaceAllUsesOfValueWith
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|To
parameter_list|)
function_decl|;
comment|/// ReplaceAllUsesOfValuesWith - Like ReplaceAllUsesOfValueWith, but
comment|/// for multiple values at once. This correctly handles the case where
comment|/// there is an overlap between the From values and the To values.
name|void
name|ReplaceAllUsesOfValuesWith
parameter_list|(
specifier|const
name|SDValue
modifier|*
name|From
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|To
parameter_list|,
name|unsigned
name|Num
parameter_list|)
function_decl|;
comment|/// AssignTopologicalOrder - Topological-sort the AllNodes list and a
comment|/// assign a unique node id for each node in the DAG based on their
comment|/// topological order. Returns the number of nodes.
name|unsigned
name|AssignTopologicalOrder
parameter_list|()
function_decl|;
comment|/// RepositionNode - Move node N in the AllNodes list to be immediately
comment|/// before the given iterator Position. This may be used to update the
comment|/// topological ordering when the list of nodes is modified.
name|void
name|RepositionNode
parameter_list|(
name|allnodes_iterator
name|Position
parameter_list|,
name|SDNode
modifier|*
name|N
parameter_list|)
block|{
name|AllNodes
operator|.
name|insert
argument_list|(
name|Position
argument_list|,
name|AllNodes
operator|.
name|remove
argument_list|(
name|N
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// isCommutativeBinOp - Returns true if the opcode is a commutative binary
comment|/// operation.
specifier|static
name|bool
name|isCommutativeBinOp
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
comment|// FIXME: This should get its info from the td file, so that we can include
comment|// target info.
switch|switch
condition|(
name|Opcode
condition|)
block|{
case|case
name|ISD
operator|::
name|ADD
case|:
case|case
name|ISD
operator|::
name|MUL
case|:
case|case
name|ISD
operator|::
name|MULHU
case|:
case|case
name|ISD
operator|::
name|MULHS
case|:
case|case
name|ISD
operator|::
name|SMUL_LOHI
case|:
case|case
name|ISD
operator|::
name|UMUL_LOHI
case|:
case|case
name|ISD
operator|::
name|FADD
case|:
case|case
name|ISD
operator|::
name|FMUL
case|:
case|case
name|ISD
operator|::
name|AND
case|:
case|case
name|ISD
operator|::
name|OR
case|:
case|case
name|ISD
operator|::
name|XOR
case|:
case|case
name|ISD
operator|::
name|SADDO
case|:
case|case
name|ISD
operator|::
name|UADDO
case|:
case|case
name|ISD
operator|::
name|ADDC
case|:
case|case
name|ISD
operator|::
name|ADDE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Returns an APFloat semantics tag appropriate for the given type. If VT is
comment|/// a vector type, the element semantics are returned.
specifier|static
specifier|const
name|fltSemantics
modifier|&
name|EVTToAPFloatSemantics
parameter_list|(
name|EVT
name|VT
parameter_list|)
block|{
switch|switch
condition|(
name|VT
operator|.
name|getScalarType
argument_list|()
operator|.
name|getSimpleVT
argument_list|()
operator|.
name|SimpleTy
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown FP format"
argument_list|)
expr_stmt|;
case|case
name|MVT
operator|::
name|f16
case|:
return|return
name|APFloat
operator|::
name|IEEEhalf
return|;
case|case
name|MVT
operator|::
name|f32
case|:
return|return
name|APFloat
operator|::
name|IEEEsingle
return|;
case|case
name|MVT
operator|::
name|f64
case|:
return|return
name|APFloat
operator|::
name|IEEEdouble
return|;
case|case
name|MVT
operator|::
name|f80
case|:
return|return
name|APFloat
operator|::
name|x87DoubleExtended
return|;
case|case
name|MVT
operator|::
name|f128
case|:
return|return
name|APFloat
operator|::
name|IEEEquad
return|;
case|case
name|MVT
operator|::
name|ppcf128
case|:
return|return
name|APFloat
operator|::
name|PPCDoubleDouble
return|;
block|}
block|}
comment|/// AddDbgValue - Add a dbg_value SDNode. If SD is non-null that means the
comment|/// value is produced by SD.
name|void
name|AddDbgValue
parameter_list|(
name|SDDbgValue
modifier|*
name|DB
parameter_list|,
name|SDNode
modifier|*
name|SD
parameter_list|,
name|bool
name|isParameter
parameter_list|)
function_decl|;
comment|/// GetDbgValues - Get the debug values which reference the given SDNode.
name|ArrayRef
operator|<
name|SDDbgValue
operator|*
operator|>
name|GetDbgValues
argument_list|(
argument|const SDNode* SD
argument_list|)
block|{
return|return
name|DbgInfo
operator|->
name|getSDDbgValues
argument_list|(
name|SD
argument_list|)
return|;
block|}
comment|/// TransferDbgValues - Transfer SDDbgValues.
name|void
name|TransferDbgValues
parameter_list|(
name|SDValue
name|From
parameter_list|,
name|SDValue
name|To
parameter_list|)
function_decl|;
comment|/// hasDebugValues - Return true if there are any SDDbgValue nodes associated
comment|/// with this SelectionDAG.
name|bool
name|hasDebugValues
argument_list|()
specifier|const
block|{
return|return
operator|!
name|DbgInfo
operator|->
name|empty
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|DbgBegin
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|DbgBegin
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|DbgEnd
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|DbgEnd
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|ByvalParmDbgBegin
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|ByvalParmDbgBegin
argument_list|()
return|;
block|}
name|SDDbgInfo
operator|::
name|DbgIterator
name|ByvalParmDbgEnd
argument_list|()
block|{
return|return
name|DbgInfo
operator|->
name|ByvalParmDbgEnd
argument_list|()
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// CreateStackTemporary - Create a stack temporary, suitable for holding the
comment|/// specified value type.  If minAlign is specified, the slot size will have
comment|/// at least that alignment.
name|SDValue
name|CreateStackTemporary
parameter_list|(
name|EVT
name|VT
parameter_list|,
name|unsigned
name|minAlign
init|=
literal|1
parameter_list|)
function_decl|;
comment|/// CreateStackTemporary - Create a stack temporary suitable for holding
comment|/// either of the specified value types.
name|SDValue
name|CreateStackTemporary
parameter_list|(
name|EVT
name|VT1
parameter_list|,
name|EVT
name|VT2
parameter_list|)
function_decl|;
comment|/// FoldConstantArithmetic -
name|SDValue
name|FoldConstantArithmetic
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|SDNode
modifier|*
name|Cst1
parameter_list|,
name|SDNode
modifier|*
name|Cst2
parameter_list|)
function_decl|;
comment|/// FoldSetCC - Constant fold a setcc to true or false.
name|SDValue
name|FoldSetCC
argument_list|(
name|EVT
name|VT
argument_list|,
name|SDValue
name|N1
argument_list|,
name|SDValue
name|N2
argument_list|,
name|ISD
operator|::
name|CondCode
name|Cond
argument_list|,
name|SDLoc
name|dl
argument_list|)
decl_stmt|;
comment|/// SignBitIsZero - Return true if the sign bit of Op is known to be zero.  We
comment|/// use this predicate to simplify operations downstream.
name|bool
name|SignBitIsZero
argument_list|(
name|SDValue
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// MaskedValueIsZero - Return true if 'Op& Mask' is known to be zero.  We
comment|/// use this predicate to simplify operations downstream.  Op and Mask are
comment|/// known to be the same type.
name|bool
name|MaskedValueIsZero
argument_list|(
name|SDValue
name|Op
argument_list|,
specifier|const
name|APInt
operator|&
name|Mask
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// ComputeMaskedBits - Determine which of the bits specified in Mask are
comment|/// known to be either zero or one and return them in the KnownZero/KnownOne
comment|/// bitsets.  This code only analyzes bits in Mask, in order to short-circuit
comment|/// processing.  Targets can implement the computeMaskedBitsForTargetNode
comment|/// method in the TargetLowering class to allow target nodes to be understood.
name|void
name|ComputeMaskedBits
argument_list|(
name|SDValue
name|Op
argument_list|,
name|APInt
operator|&
name|KnownZero
argument_list|,
name|APInt
operator|&
name|KnownOne
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// ComputeNumSignBits - Return the number of times the sign bit of the
comment|/// register is replicated into the other bits.  We know that at least 1 bit
comment|/// is always equal to the sign bit (itself), but other cases can give us
comment|/// information.  For example, immediately after an "SRA X, 2", we know that
comment|/// the top 3 bits are all equal to each other, so we return 3.  Targets can
comment|/// implement the ComputeNumSignBitsForTarget method in the TargetLowering
comment|/// class to allow target nodes to be understood.
name|unsigned
name|ComputeNumSignBits
argument_list|(
name|SDValue
name|Op
argument_list|,
name|unsigned
name|Depth
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// isBaseWithConstantOffset - Return true if the specified operand is an
comment|/// ISD::ADD with a ConstantSDNode on the right-hand side, or if it is an
comment|/// ISD::OR with a ConstantSDNode that is guaranteed to have the same
comment|/// semantics as an ADD.  This handles the equivalence:
comment|///     X|Cst == X+Cst iff X&Cst = 0.
name|bool
name|isBaseWithConstantOffset
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// isKnownNeverNan - Test whether the given SDValue is known to never be NaN.
name|bool
name|isKnownNeverNaN
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// isKnownNeverZero - Test whether the given SDValue is known to never be
comment|/// positive or negative Zero.
name|bool
name|isKnownNeverZero
argument_list|(
name|SDValue
name|Op
argument_list|)
decl|const
decl_stmt|;
comment|/// isEqualTo - Test whether two SDValues are known to compare equal. This
comment|/// is true if they are the same value, or if one is negative zero and the
comment|/// other positive zero.
name|bool
name|isEqualTo
argument_list|(
name|SDValue
name|A
argument_list|,
name|SDValue
name|B
argument_list|)
decl|const
decl_stmt|;
comment|/// UnrollVectorOp - Utility function used by legalize and lowering to
comment|/// "unroll" a vector operation by splitting out the scalars and operating
comment|/// on each element individually.  If the ResNE is 0, fully unroll the vector
comment|/// op. If ResNE is less than the width of the vector op, unroll up to ResNE.
comment|/// If the  ResNE is greater than the width of the vector op, unroll the
comment|/// vector op and fill the end of the resulting vector with UNDEFS.
name|SDValue
name|UnrollVectorOp
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|ResNE
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// isConsecutiveLoad - Return true if LD is loading 'Bytes' bytes from a
comment|/// location that is 'Dist' units away from the location that the 'Base' load
comment|/// is loading from.
name|bool
name|isConsecutiveLoad
argument_list|(
name|LoadSDNode
operator|*
name|LD
argument_list|,
name|LoadSDNode
operator|*
name|Base
argument_list|,
name|unsigned
name|Bytes
argument_list|,
name|int
name|Dist
argument_list|)
decl|const
decl_stmt|;
comment|/// InferPtrAlignment - Infer alignment of a load / store address. Return 0 if
comment|/// it cannot be inferred.
name|unsigned
name|InferPtrAlignment
argument_list|(
name|SDValue
name|Ptr
argument_list|)
decl|const
decl_stmt|;
comment|/// GetSplitDestVTs - Compute the VTs needed for the low/hi parts of a type
comment|/// which is split (or expanded) into two not necessarily identical pieces.
name|std
operator|::
name|pair
operator|<
name|EVT
operator|,
name|EVT
operator|>
name|GetSplitDestVTs
argument_list|(
argument|const EVT&VT
argument_list|)
specifier|const
expr_stmt|;
comment|/// SplitVector - Split the vector with EXTRACT_SUBVECTOR using the provides
comment|/// VTs and return the low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVector
argument_list|(
specifier|const
name|SDValue
operator|&
name|N
argument_list|,
specifier|const
name|SDLoc
operator|&
name|DL
argument_list|,
specifier|const
name|EVT
operator|&
name|LoVT
argument_list|,
specifier|const
name|EVT
operator|&
name|HiVT
argument_list|)
expr_stmt|;
comment|/// SplitVector - Split the vector with EXTRACT_SUBVECTOR and return the
comment|/// low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVector
argument_list|(
argument|const SDValue&N
argument_list|,
argument|const SDLoc&DL
argument_list|)
block|{
name|EVT
name|LoVT
block|,
name|HiVT
block|;
name|llvm
operator|::
name|tie
argument_list|(
name|LoVT
argument_list|,
name|HiVT
argument_list|)
operator|=
name|GetSplitDestVTs
argument_list|(
name|N
operator|.
name|getValueType
argument_list|()
argument_list|)
block|;
return|return
name|SplitVector
argument_list|(
name|N
argument_list|,
name|DL
argument_list|,
name|LoVT
argument_list|,
name|HiVT
argument_list|)
return|;
block|}
comment|/// SplitVectorOperand - Split the node's operand with EXTRACT_SUBVECTOR and
comment|/// return the low/high part.
name|std
operator|::
name|pair
operator|<
name|SDValue
operator|,
name|SDValue
operator|>
name|SplitVectorOperand
argument_list|(
argument|const SDNode *N
argument_list|,
argument|unsigned OpNo
argument_list|)
block|{
return|return
name|SplitVector
argument_list|(
name|N
operator|->
name|getOperand
argument_list|(
name|OpNo
argument_list|)
argument_list|,
name|SDLoc
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
name|private
label|:
name|bool
name|RemoveNodeFromCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|AddModifiedNodeToCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDValue
name|Op1
parameter_list|,
name|SDValue
name|Op2
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|FindModifiedNodeSlot
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
specifier|const
name|SDValue
modifier|*
name|Ops
parameter_list|,
name|unsigned
name|NumOps
parameter_list|,
name|void
modifier|*
modifier|&
name|InsertPos
parameter_list|)
function_decl|;
name|SDNode
modifier|*
name|UpdadeSDLocOnMergedSDNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|SDLoc
name|loc
parameter_list|)
function_decl|;
name|void
name|DeleteNodeNotInCSEMaps
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|void
name|DeallocateNode
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|unsigned
name|getEVTAlignment
argument_list|(
name|EVT
name|MemoryVT
argument_list|)
decl|const
decl_stmt|;
name|void
name|allnodes_clear
parameter_list|()
function_decl|;
comment|/// VTList - List of non-single value types.
name|FoldingSet
operator|<
name|SDVTListNode
operator|>
name|VTListMap
expr_stmt|;
comment|/// CondCodeNodes - Maps to auto-CSE operations.
name|std
operator|::
name|vector
operator|<
name|CondCodeSDNode
operator|*
operator|>
name|CondCodeNodes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SDNode
operator|*
operator|>
name|ValueTypeNodes
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|EVT
operator|,
name|SDNode
operator|*
operator|,
name|EVT
operator|::
name|compareRawBits
operator|>
name|ExtendedValueTypeNodes
expr_stmt|;
name|StringMap
operator|<
name|SDNode
operator|*
operator|>
name|ExternalSymbols
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|pair
operator|<
name|std
operator|::
name|string
operator|,
name|unsigned
name|char
operator|>
operator|,
name|SDNode
operator|*
operator|>
name|TargetExternalSymbols
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|SelectionDAG
operator|*
operator|>
operator|:
name|public
name|GraphTraits
operator|<
name|SDNode
operator|*
operator|>
block|{
typedef|typedef
name|SelectionDAG
operator|::
name|allnodes_iterator
name|nodes_iterator
expr_stmt|;
specifier|static
name|nodes_iterator
name|nodes_begin
argument_list|(
argument|SelectionDAG *G
argument_list|)
block|{
return|return
name|G
operator|->
name|allnodes_begin
argument_list|()
return|;
block|}
specifier|static
name|nodes_iterator
name|nodes_end
argument_list|(
argument|SelectionDAG *G
argument_list|)
block|{
return|return
name|G
operator|->
name|allnodes_end
argument_list|()
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

