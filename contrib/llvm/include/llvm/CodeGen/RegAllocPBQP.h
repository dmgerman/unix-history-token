begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- RegAllocPBQP.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the PBQPBuilder interface, for classes which build PBQP
end_comment

begin_comment
comment|// instances to represent register allocation problems, and the RegAllocPBQP
end_comment

begin_comment
comment|// interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_REGALLOCPBQP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_REGALLOCPBQP_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/PBQP/CostAllocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/PBQP/Graph.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/PBQP/Math.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/PBQP/ReductionRules.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/PBQP/Solution.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|FunctionPass
decl_stmt|;
name|class
name|LiveIntervals
decl_stmt|;
name|class
name|MachineBlockFrequencyInfo
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|namespace
name|PBQP
block|{
name|namespace
name|RegAlloc
block|{
comment|/// @brief Spill option index.
specifier|inline
name|unsigned
name|getSpillOptionIdx
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Metadata to speed allocatability test.
comment|///
comment|/// Keeps track of the number of infinities in each row and column.
name|class
name|MatrixMetadata
block|{
name|public
label|:
name|MatrixMetadata
argument_list|(
specifier|const
name|Matrix
operator|&
name|M
argument_list|)
operator|:
name|UnsafeRows
argument_list|(
argument|new bool[M.getRows() -
literal|1
argument|]()
argument_list|)
operator|,
name|UnsafeCols
argument_list|(
argument|new bool[M.getCols() -
literal|1
argument|]()
argument_list|)
block|{
name|unsigned
operator|*
name|ColCounts
operator|=
name|new
name|unsigned
index|[
name|M
operator|.
name|getCols
argument_list|()
operator|-
literal|1
index|]
operator|(
operator|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|M
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|RowCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|M
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|M
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
operator|++
name|RowCount
expr_stmt|;
operator|++
name|ColCounts
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|UnsafeRows
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|true
expr_stmt|;
name|UnsafeCols
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|true
expr_stmt|;
block|}
block|}
name|WorstRow
operator|=
name|std
operator|::
name|max
argument_list|(
name|WorstRow
argument_list|,
name|RowCount
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|WorstColCountForCurRow
init|=
operator|*
name|std
operator|::
name|max_element
argument_list|(
name|ColCounts
argument_list|,
name|ColCounts
operator|+
name|M
operator|.
name|getCols
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|WorstCol
operator|=
name|std
operator|::
name|max
argument_list|(
name|WorstCol
argument_list|,
name|WorstColCountForCurRow
argument_list|)
expr_stmt|;
name|delete
index|[]
name|ColCounts
decl_stmt|;
block|}
name|MatrixMetadata
argument_list|(
specifier|const
name|MatrixMetadata
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MatrixMetadata
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MatrixMetadata
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|unsigned
name|getWorstRow
argument_list|()
specifier|const
block|{
return|return
name|WorstRow
return|;
block|}
name|unsigned
name|getWorstCol
argument_list|()
specifier|const
block|{
return|return
name|WorstCol
return|;
block|}
specifier|const
name|bool
operator|*
name|getUnsafeRows
argument_list|()
specifier|const
block|{
return|return
name|UnsafeRows
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|bool
operator|*
name|getUnsafeCols
argument_list|()
specifier|const
block|{
return|return
name|UnsafeCols
operator|.
name|get
argument_list|()
return|;
block|}
name|private
label|:
name|unsigned
name|WorstRow
init|=
literal|0
decl_stmt|;
name|unsigned
name|WorstCol
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|bool
index|[]
operator|>
name|UnsafeRows
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|bool
index|[]
operator|>
name|UnsafeCols
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief Holds a vector of the allowed physical regs for a vreg.
name|class
name|AllowedRegVector
block|{
name|friend
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|AllowedRegVector
modifier|&
parameter_list|)
function_decl|;
name|public
label|:
name|AllowedRegVector
argument_list|()
operator|=
expr|default
expr_stmt|;
name|AllowedRegVector
argument_list|(
name|AllowedRegVector
operator|&&
argument_list|)
operator|=
expr|default
expr_stmt|;
name|AllowedRegVector
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|OptVec
argument_list|)
operator|:
name|NumOpts
argument_list|(
name|OptVec
operator|.
name|size
argument_list|()
argument_list|)
operator|,
name|Opts
argument_list|(
argument|new unsigned[NumOpts]
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|OptVec
operator|.
name|begin
argument_list|()
argument_list|,
name|OptVec
operator|.
name|end
argument_list|()
argument_list|,
name|Opts
operator|.
name|get
argument_list|()
argument_list|)
block|;   }
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|NumOpts
return|;
block|}
name|unsigned
name|operator
index|[]
argument_list|(
name|size_t
name|I
argument_list|)
decl|const
block|{
return|return
name|Opts
index|[
name|I
index|]
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|AllowedRegVector
operator|&
name|Other
operator|)
specifier|const
block|{
if|if
condition|(
name|NumOpts
operator|!=
name|Other
operator|.
name|NumOpts
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Opts
operator|.
name|get
argument_list|()
argument_list|,
name|Opts
operator|.
name|get
argument_list|()
operator|+
name|NumOpts
argument_list|,
name|Other
operator|.
name|Opts
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|AllowedRegVector
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|Other
operator|)
return|;
block|}
name|private
label|:
name|unsigned
name|NumOpts
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|unsigned
index|[]
operator|>
name|Opts
expr_stmt|;
block|}
empty_stmt|;
specifier|inline
name|hash_code
name|hash_value
parameter_list|(
specifier|const
name|AllowedRegVector
modifier|&
name|OptRegs
parameter_list|)
block|{
name|unsigned
modifier|*
name|OStart
init|=
name|OptRegs
operator|.
name|Opts
operator|.
name|get
argument_list|()
decl_stmt|;
name|unsigned
modifier|*
name|OEnd
init|=
name|OptRegs
operator|.
name|Opts
operator|.
name|get
argument_list|()
operator|+
name|OptRegs
operator|.
name|NumOpts
decl_stmt|;
return|return
name|hash_combine
argument_list|(
name|OptRegs
operator|.
name|NumOpts
argument_list|,
name|hash_combine_range
argument_list|(
name|OStart
argument_list|,
name|OEnd
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Holds graph-level metadata relevant to PBQP RA problems.
name|class
name|GraphMetadata
block|{
name|private
label|:
name|using
name|AllowedRegVecPool
init|=
name|ValuePool
operator|<
name|AllowedRegVector
operator|>
decl_stmt|;
name|public
label|:
name|using
name|AllowedRegVecRef
init|=
name|AllowedRegVecPool
operator|::
name|PoolRef
decl_stmt|;
name|GraphMetadata
argument_list|(
name|MachineFunction
operator|&
name|MF
argument_list|,
name|LiveIntervals
operator|&
name|LIS
argument_list|,
name|MachineBlockFrequencyInfo
operator|&
name|MBFI
argument_list|)
operator|:
name|MF
argument_list|(
name|MF
argument_list|)
operator|,
name|LIS
argument_list|(
name|LIS
argument_list|)
operator|,
name|MBFI
argument_list|(
argument|MBFI
argument_list|)
block|{}
name|MachineFunction
operator|&
name|MF
expr_stmt|;
name|LiveIntervals
modifier|&
name|LIS
decl_stmt|;
name|MachineBlockFrequencyInfo
modifier|&
name|MBFI
decl_stmt|;
name|void
name|setNodeIdForVReg
argument_list|(
name|unsigned
name|VReg
argument_list|,
name|GraphBase
operator|::
name|NodeId
name|NId
argument_list|)
block|{
name|VRegToNodeId
index|[
name|VReg
index|]
operator|=
name|NId
expr_stmt|;
block|}
name|GraphBase
operator|::
name|NodeId
name|getNodeIdForVReg
argument_list|(
argument|unsigned VReg
argument_list|)
specifier|const
block|{
name|auto
name|VRegItr
operator|=
name|VRegToNodeId
operator|.
name|find
argument_list|(
name|VReg
argument_list|)
block|;
if|if
condition|(
name|VRegItr
operator|==
name|VRegToNodeId
operator|.
name|end
argument_list|()
condition|)
return|return
name|GraphBase
operator|::
name|invalidNodeId
argument_list|()
return|;
return|return
name|VRegItr
operator|->
name|second
return|;
block|}
name|AllowedRegVecRef
name|getAllowedRegs
parameter_list|(
name|AllowedRegVector
name|Allowed
parameter_list|)
block|{
return|return
name|AllowedRegVecs
operator|.
name|getValue
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Allowed
argument_list|)
argument_list|)
return|;
block|}
name|private
label|:
name|DenseMap
operator|<
name|unsigned
operator|,
name|GraphBase
operator|::
name|NodeId
operator|>
name|VRegToNodeId
expr_stmt|;
name|AllowedRegVecPool
name|AllowedRegVecs
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Holds solver state and other metadata relevant to each PBQP RA node.
end_comment

begin_decl_stmt
name|class
name|NodeMetadata
block|{
name|public
label|:
name|using
name|AllowedRegVector
init|=
name|RegAlloc
operator|::
name|AllowedRegVector
decl_stmt|;
comment|// The node's reduction state. The order in this enum is important,
comment|// as it is assumed nodes can only progress up (i.e. towards being
comment|// optimally reducible) when reducing the graph.
name|using
name|ReductionState
init|= enum
block|{
name|Unprocessed
block|,
name|NotProvablyAllocatable
block|,
name|ConservativelyAllocatable
block|,
name|OptimallyReducible
block|}
decl_stmt|;
name|NodeMetadata
argument_list|()
operator|=
expr|default
expr_stmt|;
name|NodeMetadata
argument_list|(
specifier|const
name|NodeMetadata
operator|&
name|Other
argument_list|)
operator|:
name|RS
argument_list|(
name|Other
operator|.
name|RS
argument_list|)
operator|,
name|NumOpts
argument_list|(
name|Other
operator|.
name|NumOpts
argument_list|)
operator|,
name|DeniedOpts
argument_list|(
name|Other
operator|.
name|DeniedOpts
argument_list|)
operator|,
name|OptUnsafeEdges
argument_list|(
argument|new unsigned[NumOpts]
argument_list|)
operator|,
name|VReg
argument_list|(
name|Other
operator|.
name|VReg
argument_list|)
operator|,
name|AllowedRegs
argument_list|(
name|Other
operator|.
name|AllowedRegs
argument_list|)
ifndef|#
directive|ifndef
name|NDEBUG
operator|,
name|everConservativelyAllocatable
argument_list|(
argument|Other.everConservativelyAllocatable
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|NumOpts
operator|>
literal|0
condition|)
block|{
name|std
operator|::
name|copy
argument_list|(
operator|&
name|Other
operator|.
name|OptUnsafeEdges
index|[
literal|0
index|]
argument_list|,
operator|&
name|Other
operator|.
name|OptUnsafeEdges
index|[
name|NumOpts
index|]
argument_list|,
operator|&
name|OptUnsafeEdges
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|NodeMetadata
argument_list|(
name|NodeMetadata
operator|&&
argument_list|)
operator|=
expr|default
expr_stmt|;
name|NodeMetadata
modifier|&
name|operator
init|=
operator|(
name|NodeMetadata
operator|&&
operator|)
operator|=
expr|default
decl_stmt|;
name|void
name|setVReg
parameter_list|(
name|unsigned
name|VReg
parameter_list|)
block|{
name|this
operator|->
name|VReg
operator|=
name|VReg
expr_stmt|;
block|}
name|unsigned
name|getVReg
argument_list|()
specifier|const
block|{
return|return
name|VReg
return|;
block|}
name|void
name|setAllowedRegs
argument_list|(
name|GraphMetadata
operator|::
name|AllowedRegVecRef
name|AllowedRegs
argument_list|)
block|{
name|this
operator|->
name|AllowedRegs
operator|=
name|std
operator|::
name|move
argument_list|(
name|AllowedRegs
argument_list|)
expr_stmt|;
block|}
specifier|const
name|AllowedRegVector
operator|&
name|getAllowedRegs
argument_list|()
specifier|const
block|{
return|return
operator|*
name|AllowedRegs
return|;
block|}
name|void
name|setup
parameter_list|(
specifier|const
name|Vector
modifier|&
name|Costs
parameter_list|)
block|{
name|NumOpts
operator|=
name|Costs
operator|.
name|getLength
argument_list|()
operator|-
literal|1
expr_stmt|;
name|OptUnsafeEdges
operator|=
name|std
operator|::
name|unique_ptr
operator|<
name|unsigned
index|[]
operator|>
operator|(
name|new
name|unsigned
index|[
name|NumOpts
index|]
operator|(
operator|)
operator|)
expr_stmt|;
block|}
name|ReductionState
name|getReductionState
argument_list|()
specifier|const
block|{
return|return
name|RS
return|;
block|}
name|void
name|setReductionState
parameter_list|(
name|ReductionState
name|RS
parameter_list|)
block|{
name|assert
argument_list|(
name|RS
operator|>=
name|this
operator|->
name|RS
operator|&&
literal|"A node's reduction state can not be downgraded"
argument_list|)
expr_stmt|;
name|this
operator|->
name|RS
operator|=
name|RS
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Remember this state to assert later that a non-infinite register
comment|// option was available.
if|if
condition|(
name|RS
operator|==
name|ConservativelyAllocatable
condition|)
name|everConservativelyAllocatable
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|handleAddEdge
parameter_list|(
specifier|const
name|MatrixMetadata
modifier|&
name|MD
parameter_list|,
name|bool
name|Transpose
parameter_list|)
block|{
name|DeniedOpts
operator|+=
name|Transpose
condition|?
name|MD
operator|.
name|getWorstRow
argument_list|()
else|:
name|MD
operator|.
name|getWorstCol
argument_list|()
expr_stmt|;
specifier|const
name|bool
modifier|*
name|UnsafeOpts
init|=
name|Transpose
condition|?
name|MD
operator|.
name|getUnsafeCols
argument_list|()
else|:
name|MD
operator|.
name|getUnsafeRows
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumOpts
condition|;
operator|++
name|i
control|)
name|OptUnsafeEdges
index|[
name|i
index|]
operator|+=
name|UnsafeOpts
index|[
name|i
index|]
expr_stmt|;
block|}
name|void
name|handleRemoveEdge
parameter_list|(
specifier|const
name|MatrixMetadata
modifier|&
name|MD
parameter_list|,
name|bool
name|Transpose
parameter_list|)
block|{
name|DeniedOpts
operator|-=
name|Transpose
condition|?
name|MD
operator|.
name|getWorstRow
argument_list|()
else|:
name|MD
operator|.
name|getWorstCol
argument_list|()
expr_stmt|;
specifier|const
name|bool
modifier|*
name|UnsafeOpts
init|=
name|Transpose
condition|?
name|MD
operator|.
name|getUnsafeCols
argument_list|()
else|:
name|MD
operator|.
name|getUnsafeRows
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumOpts
condition|;
operator|++
name|i
control|)
name|OptUnsafeEdges
index|[
name|i
index|]
operator|-=
name|UnsafeOpts
index|[
name|i
index|]
expr_stmt|;
block|}
name|bool
name|isConservativelyAllocatable
argument_list|()
specifier|const
block|{
return|return
operator|(
name|DeniedOpts
operator|<
name|NumOpts
operator|)
operator|||
operator|(
name|std
operator|::
name|find
argument_list|(
operator|&
name|OptUnsafeEdges
index|[
literal|0
index|]
argument_list|,
operator|&
name|OptUnsafeEdges
index|[
name|NumOpts
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
operator|&
name|OptUnsafeEdges
index|[
name|NumOpts
index|]
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|bool
name|wasConservativelyAllocatable
argument_list|()
specifier|const
block|{
return|return
name|everConservativelyAllocatable
return|;
block|}
endif|#
directive|endif
name|private
label|:
name|ReductionState
name|RS
init|=
name|Unprocessed
decl_stmt|;
name|unsigned
name|NumOpts
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeniedOpts
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|unsigned
index|[]
operator|>
name|OptUnsafeEdges
expr_stmt|;
name|unsigned
name|VReg
init|=
literal|0
decl_stmt|;
name|GraphMetadata
operator|::
name|AllowedRegVecRef
name|AllowedRegs
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|bool
name|everConservativelyAllocatable
init|=
name|false
decl_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|RegAllocSolverImpl
block|{
name|private
label|:
name|using
name|RAMatrix
init|=
name|MDMatrix
operator|<
name|MatrixMetadata
operator|>
decl_stmt|;
name|public
label|:
name|using
name|RawVector
init|=
name|PBQP
operator|::
name|Vector
decl_stmt|;
name|using
name|RawMatrix
init|=
name|PBQP
operator|::
name|Matrix
decl_stmt|;
name|using
name|Vector
init|=
name|PBQP
operator|::
name|Vector
decl_stmt|;
name|using
name|Matrix
init|=
name|RAMatrix
decl_stmt|;
name|using
name|CostAllocator
init|=
name|PBQP
operator|::
name|PoolCostAllocator
operator|<
name|Vector
decl_stmt|,
name|Matrix
decl|>
decl_stmt|;
name|using
name|NodeId
init|=
name|GraphBase
operator|::
name|NodeId
decl_stmt|;
name|using
name|EdgeId
init|=
name|GraphBase
operator|::
name|EdgeId
decl_stmt|;
name|using
name|NodeMetadata
init|=
name|RegAlloc
operator|::
name|NodeMetadata
decl_stmt|;
struct|struct
name|EdgeMetadata
block|{}
struct|;
name|using
name|GraphMetadata
init|=
name|RegAlloc
operator|::
name|GraphMetadata
decl_stmt|;
name|using
name|Graph
init|=
name|PBQP
operator|::
name|Graph
operator|<
name|RegAllocSolverImpl
operator|>
decl_stmt|;
name|RegAllocSolverImpl
argument_list|(
name|Graph
operator|&
name|G
argument_list|)
operator|:
name|G
argument_list|(
argument|G
argument_list|)
block|{}
name|Solution
name|solve
argument_list|()
block|{
name|G
operator|.
name|setSolver
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|Solution
name|S
block|;
name|setup
argument_list|()
block|;
name|S
operator|=
name|backpropagate
argument_list|(
name|G
argument_list|,
name|reduce
argument_list|()
argument_list|)
block|;
name|G
operator|.
name|unsetSolver
argument_list|()
block|;
return|return
name|S
return|;
block|}
name|void
name|handleAddNode
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|assert
argument_list|(
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|>
literal|1
operator|&&
literal|"PBQP Graph should not contain single or zero-option nodes"
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setup
argument_list|(
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleRemoveNode
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{}
name|void
name|handleSetNodeCosts
parameter_list|(
name|NodeId
name|NId
parameter_list|,
specifier|const
name|Vector
modifier|&
name|newCosts
parameter_list|)
block|{}
name|void
name|handleAddEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|)
block|{
name|handleReconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
name|handleReconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleDisconnectEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
name|NodeId
name|NId
parameter_list|)
block|{
name|NodeMetadata
modifier|&
name|NMd
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
decl_stmt|;
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|NMd
operator|.
name|handleRemoveEdge
argument_list|(
name|MMd
argument_list|,
name|NId
operator|==
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
name|promote
argument_list|(
name|NId
argument_list|,
name|NMd
argument_list|)
expr_stmt|;
block|}
name|void
name|handleReconnectEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
name|NodeId
name|NId
parameter_list|)
block|{
name|NodeMetadata
modifier|&
name|NMd
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
decl_stmt|;
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|NMd
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
name|NId
operator|==
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleUpdateCosts
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
specifier|const
name|Matrix
modifier|&
name|NewCosts
parameter_list|)
block|{
name|NodeId
name|N1Id
init|=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|NodeId
name|N2Id
init|=
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|NodeMetadata
modifier|&
name|N1Md
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|N1Id
argument_list|)
decl_stmt|;
name|NodeMetadata
modifier|&
name|N2Md
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|N2Id
argument_list|)
decl_stmt|;
name|bool
name|Transpose
init|=
name|N1Id
operator|!=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
comment|// Metadata are computed incrementally. First, update them
comment|// by removing the old cost.
specifier|const
name|MatrixMetadata
modifier|&
name|OldMMd
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|N1Md
operator|.
name|handleRemoveEdge
argument_list|(
name|OldMMd
argument_list|,
name|Transpose
argument_list|)
expr_stmt|;
name|N2Md
operator|.
name|handleRemoveEdge
argument_list|(
name|OldMMd
argument_list|,
operator|!
name|Transpose
argument_list|)
expr_stmt|;
comment|// And update now the metadata with the new cost.
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|NewCosts
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|N1Md
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
name|Transpose
argument_list|)
expr_stmt|;
name|N2Md
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
operator|!
name|Transpose
argument_list|)
expr_stmt|;
comment|// As the metadata may have changed with the update, the nodes may have
comment|// become ConservativelyAllocatable or OptimallyReducible.
name|promote
argument_list|(
name|N1Id
argument_list|,
name|N1Md
argument_list|)
expr_stmt|;
name|promote
argument_list|(
name|N2Id
argument_list|,
name|N2Md
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|void
name|promote
parameter_list|(
name|NodeId
name|NId
parameter_list|,
name|NodeMetadata
modifier|&
name|NMd
parameter_list|)
block|{
if|if
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|==
literal|3
condition|)
block|{
comment|// This node is becoming optimally reducible.
name|moveToOptimallyReducibleNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMd
operator|.
name|getReductionState
argument_list|()
operator|==
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
operator|&&
name|NMd
operator|.
name|isConservativelyAllocatable
argument_list|()
condition|)
block|{
comment|// This node just became conservatively allocatable.
name|moveToConservativelyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|removeFromCurrentSet
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
switch|switch
condition|(
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|getReductionState
argument_list|()
condition|)
block|{
case|case
name|NodeMetadata
operator|::
name|Unprocessed
case|:
break|break;
case|case
name|NodeMetadata
operator|::
name|OptimallyReducible
case|:
name|assert
argument_list|(
name|OptimallyReducibleNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|OptimallyReducibleNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in optimally reducible set."
argument_list|)
expr_stmt|;
name|OptimallyReducibleNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
name|NodeMetadata
operator|::
name|ConservativelyAllocatable
case|:
name|assert
argument_list|(
name|ConservativelyAllocatableNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|ConservativelyAllocatableNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in conservatively allocatable set."
argument_list|)
expr_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
case|:
name|assert
argument_list|(
name|NotProvablyAllocatableNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|NotProvablyAllocatableNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in not-provably-allocatable set."
argument_list|)
expr_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|void
name|moveToOptimallyReducibleNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|OptimallyReducibleNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|OptimallyReducible
argument_list|)
expr_stmt|;
block|}
name|void
name|moveToConservativelyAllocatableNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|ConservativelyAllocatable
argument_list|)
expr_stmt|;
block|}
name|void
name|moveToNotProvablyAllocatableNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
argument_list|)
expr_stmt|;
block|}
name|void
name|setup
parameter_list|()
block|{
comment|// Set up worklists.
for|for
control|(
name|auto
name|NId
range|:
name|G
operator|.
name|nodeIds
argument_list|()
control|)
block|{
if|if
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|<
literal|3
condition|)
name|moveToOptimallyReducibleNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|isConservativelyAllocatable
argument_list|()
condition|)
name|moveToConservativelyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
else|else
name|moveToNotProvablyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compute a reduction order for the graph by iteratively applying PBQP
comment|// reduction rules. Locally optimal rules are applied whenever possible (R0,
comment|// R1, R2). If no locally-optimal rules apply then any conservatively
comment|// allocatable node is reduced. Finally, if no conservatively allocatable
comment|// node exists then the node with the lowest spill-cost:degree ratio is
comment|// selected.
name|std
operator|::
name|vector
operator|<
name|GraphBase
operator|::
name|NodeId
operator|>
name|reduce
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|G
operator|.
name|empty
argument_list|()
operator|&&
literal|"Cannot reduce empty graph."
argument_list|)
block|;
name|using
name|NodeId
operator|=
name|GraphBase
operator|::
name|NodeId
block|;
name|std
operator|::
name|vector
operator|<
name|NodeId
operator|>
name|NodeStack
block|;
comment|// Consume worklists.
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
operator|!
name|OptimallyReducibleNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|OptimallyReducibleNodes
operator|.
name|begin
argument_list|()
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|OptimallyReducibleNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|applyR1
argument_list|(
name|G
argument_list|,
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|applyR2
argument_list|(
name|G
argument_list|,
name|NId
argument_list|)
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Not an optimally reducible node."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ConservativelyAllocatableNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Conservatively allocatable nodes will never spill. For now just
comment|// take the first node in the set and push it on the stack. When we
comment|// start optimizing more heavily for register preferencing, it may
comment|// would be better to push nodes with lower 'expected' or worst-case
comment|// register costs first (since early nodes are the most
comment|// constrained).
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|ConservativelyAllocatableNodes
operator|.
name|begin
argument_list|()
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectAllNeighborsFromNode
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NotProvablyAllocatableNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|std
operator|::
name|min_element
argument_list|(
name|NotProvablyAllocatableNodes
operator|.
name|begin
argument_list|()
argument_list|,
name|NotProvablyAllocatableNodes
operator|.
name|end
argument_list|()
argument_list|,
name|SpillCostComparator
argument_list|(
name|G
argument_list|)
argument_list|)
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectAllNeighborsFromNode
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|NodeStack
return|;
block|}
name|class
name|SpillCostComparator
block|{
name|public
label|:
name|SpillCostComparator
argument_list|(
specifier|const
name|Graph
operator|&
name|G
argument_list|)
operator|:
name|G
argument_list|(
argument|G
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
name|NodeId
name|N1Id
operator|,
name|NodeId
name|N2Id
operator|)
block|{
name|PBQPNum
name|N1SC
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|N1Id
argument_list|)
index|[
literal|0
index|]
block|;
name|PBQPNum
name|N2SC
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|N2Id
argument_list|)
index|[
literal|0
index|]
block|;
if|if
condition|(
name|N1SC
operator|==
name|N2SC
condition|)
return|return
name|G
operator|.
name|getNodeDegree
argument_list|(
name|N1Id
argument_list|)
operator|<
name|G
operator|.
name|getNodeDegree
argument_list|(
name|N2Id
argument_list|)
return|;
return|return
name|N1SC
operator|<
name|N2SC
return|;
block|}
name|private
label|:
specifier|const
name|Graph
modifier|&
name|G
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|Graph
modifier|&
name|G
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|using
name|NodeSet
init|=
name|std
operator|::
name|set
operator|<
name|NodeId
operator|>
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeSet
name|OptimallyReducibleNodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeSet
name|ConservativelyAllocatableNodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeSet
name|NotProvablyAllocatableNodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|PBQPRAGraph
range|:
name|public
name|PBQP
operator|::
name|Graph
operator|<
name|RegAllocSolverImpl
operator|>
block|{
name|private
operator|:
name|using
name|BaseT
operator|=
name|PBQP
operator|::
name|Graph
operator|<
name|RegAllocSolverImpl
operator|>
block|;
name|public
operator|:
name|PBQPRAGraph
argument_list|(
argument|GraphMetadata Metadata
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|std::move(Metadata)
argument_list|)
block|{}
comment|/// @brief Dump this graph to dbgs().
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// @brief Dump this graph to an output stream.
comment|/// @param OS Output stream to print on.
name|void
name|dump
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// @brief Print a representation of this graph in DOT format.
comment|/// @param OS Output stream to print on.
name|void
name|printDot
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_function
specifier|inline
name|Solution
name|solve
parameter_list|(
name|PBQPRAGraph
modifier|&
name|G
parameter_list|)
block|{
if|if
condition|(
name|G
operator|.
name|empty
argument_list|()
condition|)
return|return
name|Solution
argument_list|()
return|;
name|RegAllocSolverImpl
name|RegAllocSolver
argument_list|(
name|G
argument_list|)
decl_stmt|;
return|return
name|RegAllocSolver
operator|.
name|solve
argument_list|()
return|;
block|}
end_function

begin_comment
unit|}
comment|// end namespace RegAlloc
end_comment

begin_comment
unit|}
comment|// end namespace PBQP
end_comment

begin_comment
comment|/// @brief Create a PBQP register allocator instance.
end_comment

begin_function_decl
name|FunctionPass
modifier|*
name|createPBQPRegisterAllocator
parameter_list|(
name|char
modifier|*
name|customPassID
init|=
name|nullptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_REGALLOCPBQP_H
end_comment

end_unit

