begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RegAllocSolver.h - Heuristic PBQP Solver for reg alloc --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Heuristic PBQP solver for register allocation problems. This solver uses a
end_comment

begin_comment
comment|// graph reduction approach. Nodes of degree 0, 1 and 2 are eliminated with
end_comment

begin_comment
comment|// optimality-preserving rules (see ReductionRules.h). When no low-degree (<3)
end_comment

begin_comment
comment|// nodes are present, a heuristic derived from Brigg's graph coloring approach
end_comment

begin_comment
comment|// is used.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_REGALLOCSOLVER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_REGALLOCSOLVER_H
end_define

begin_include
include|#
directive|include
file|"CostAllocator.h"
end_include

begin_include
include|#
directive|include
file|"Graph.h"
end_include

begin_include
include|#
directive|include
file|"ReductionRules.h"
end_include

begin_include
include|#
directive|include
file|"Solution.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
name|namespace
name|RegAlloc
block|{
comment|/// \brief Metadata to speed allocatability test.
comment|///
comment|/// Keeps track of the number of infinities in each row and column.
name|class
name|MatrixMetadata
block|{
name|private
label|:
name|MatrixMetadata
argument_list|(
specifier|const
name|MatrixMetadata
operator|&
argument_list|)
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|MatrixMetadata
operator|&
operator|)
decl_stmt|;
name|public
label|:
name|MatrixMetadata
argument_list|(
specifier|const
name|PBQP
operator|::
name|Matrix
operator|&
name|M
argument_list|)
operator|:
name|WorstRow
argument_list|(
literal|0
argument_list|)
operator|,
name|WorstCol
argument_list|(
literal|0
argument_list|)
operator|,
name|UnsafeRows
argument_list|(
argument|new bool[M.getRows() -
literal|1
argument|]()
argument_list|)
operator|,
name|UnsafeCols
argument_list|(
argument|new bool[M.getCols() -
literal|1
argument|]()
argument_list|)
block|{
name|unsigned
operator|*
name|ColCounts
operator|=
name|new
name|unsigned
index|[
name|M
operator|.
name|getCols
argument_list|()
operator|-
literal|1
index|]
operator|(
operator|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|M
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|RowCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|M
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|M
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|PBQP
operator|::
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
operator|++
name|RowCount
expr_stmt|;
operator|++
name|ColCounts
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|UnsafeRows
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|true
expr_stmt|;
name|UnsafeCols
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|true
expr_stmt|;
block|}
block|}
name|WorstRow
operator|=
name|std
operator|::
name|max
argument_list|(
name|WorstRow
argument_list|,
name|RowCount
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|WorstColCountForCurRow
init|=
operator|*
name|std
operator|::
name|max_element
argument_list|(
name|ColCounts
argument_list|,
name|ColCounts
operator|+
name|M
operator|.
name|getCols
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|WorstCol
operator|=
name|std
operator|::
name|max
argument_list|(
name|WorstCol
argument_list|,
name|WorstColCountForCurRow
argument_list|)
expr_stmt|;
name|delete
index|[]
name|ColCounts
decl_stmt|;
block|}
operator|~
name|MatrixMetadata
argument_list|()
block|{
name|delete
index|[]
name|UnsafeRows
block|;
name|delete
index|[]
name|UnsafeCols
block|;       }
name|unsigned
name|getWorstRow
argument_list|()
specifier|const
block|{
return|return
name|WorstRow
return|;
block|}
name|unsigned
name|getWorstCol
argument_list|()
specifier|const
block|{
return|return
name|WorstCol
return|;
block|}
specifier|const
name|bool
operator|*
name|getUnsafeRows
argument_list|()
specifier|const
block|{
return|return
name|UnsafeRows
return|;
block|}
specifier|const
name|bool
operator|*
name|getUnsafeCols
argument_list|()
specifier|const
block|{
return|return
name|UnsafeCols
return|;
block|}
name|private
label|:
name|unsigned
name|WorstRow
decl_stmt|,
name|WorstCol
decl_stmt|;
name|bool
modifier|*
name|UnsafeRows
decl_stmt|;
name|bool
modifier|*
name|UnsafeCols
decl_stmt|;
block|}
empty_stmt|;
name|class
name|NodeMetadata
block|{
name|public
label|:
typedef|typedef
enum|enum
block|{
name|Unprocessed
block|,
name|OptimallyReducible
block|,
name|ConservativelyAllocatable
block|,
name|NotProvablyAllocatable
block|}
name|ReductionState
typedef|;
name|NodeMetadata
argument_list|()
operator|:
name|RS
argument_list|(
name|Unprocessed
argument_list|)
operator|,
name|DeniedOpts
argument_list|(
literal|0
argument_list|)
operator|,
name|OptUnsafeEdges
argument_list|(
argument|nullptr
argument_list|)
block|{}
operator|~
name|NodeMetadata
argument_list|()
block|{
name|delete
index|[]
name|OptUnsafeEdges
block|; }
name|void
name|setup
argument_list|(
argument|const Vector& Costs
argument_list|)
block|{
name|NumOpts
operator|=
name|Costs
operator|.
name|getLength
argument_list|()
operator|-
literal|1
block|;
name|OptUnsafeEdges
operator|=
name|new
name|unsigned
index|[
name|NumOpts
index|]
operator|(
operator|)
block|;       }
name|ReductionState
name|getReductionState
argument_list|()
specifier|const
block|{
return|return
name|RS
return|;
block|}
name|void
name|setReductionState
parameter_list|(
name|ReductionState
name|RS
parameter_list|)
block|{
name|this
operator|->
name|RS
operator|=
name|RS
expr_stmt|;
block|}
name|void
name|handleAddEdge
parameter_list|(
specifier|const
name|MatrixMetadata
modifier|&
name|MD
parameter_list|,
name|bool
name|Transpose
parameter_list|)
block|{
name|DeniedOpts
operator|+=
name|Transpose
condition|?
name|MD
operator|.
name|getWorstCol
argument_list|()
else|:
name|MD
operator|.
name|getWorstRow
argument_list|()
expr_stmt|;
specifier|const
name|bool
modifier|*
name|UnsafeOpts
init|=
name|Transpose
condition|?
name|MD
operator|.
name|getUnsafeCols
argument_list|()
else|:
name|MD
operator|.
name|getUnsafeRows
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumOpts
condition|;
operator|++
name|i
control|)
name|OptUnsafeEdges
index|[
name|i
index|]
operator|+=
name|UnsafeOpts
index|[
name|i
index|]
expr_stmt|;
block|}
name|void
name|handleRemoveEdge
parameter_list|(
specifier|const
name|MatrixMetadata
modifier|&
name|MD
parameter_list|,
name|bool
name|Transpose
parameter_list|)
block|{
name|DeniedOpts
operator|-=
name|Transpose
condition|?
name|MD
operator|.
name|getWorstCol
argument_list|()
else|:
name|MD
operator|.
name|getWorstRow
argument_list|()
expr_stmt|;
specifier|const
name|bool
modifier|*
name|UnsafeOpts
init|=
name|Transpose
condition|?
name|MD
operator|.
name|getUnsafeCols
argument_list|()
else|:
name|MD
operator|.
name|getUnsafeRows
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumOpts
condition|;
operator|++
name|i
control|)
name|OptUnsafeEdges
index|[
name|i
index|]
operator|-=
name|UnsafeOpts
index|[
name|i
index|]
expr_stmt|;
block|}
name|bool
name|isConservativelyAllocatable
argument_list|()
specifier|const
block|{
return|return
operator|(
name|DeniedOpts
operator|<
name|NumOpts
operator|)
operator|||
operator|(
name|std
operator|::
name|find
argument_list|(
name|OptUnsafeEdges
argument_list|,
name|OptUnsafeEdges
operator|+
name|NumOpts
argument_list|,
literal|0
argument_list|)
operator|!=
name|OptUnsafeEdges
operator|+
name|NumOpts
operator|)
return|;
block|}
name|private
label|:
name|ReductionState
name|RS
decl_stmt|;
name|unsigned
name|NumOpts
decl_stmt|;
name|unsigned
name|DeniedOpts
decl_stmt|;
name|unsigned
modifier|*
name|OptUnsafeEdges
decl_stmt|;
block|}
empty_stmt|;
name|class
name|RegAllocSolverImpl
block|{
name|private
label|:
typedef|typedef
name|PBQP
operator|::
name|MDMatrix
operator|<
name|MatrixMetadata
operator|>
name|RAMatrix
expr_stmt|;
name|public
label|:
typedef|typedef
name|PBQP
operator|::
name|Vector
name|RawVector
expr_stmt|;
typedef|typedef
name|PBQP
operator|::
name|Matrix
name|RawMatrix
expr_stmt|;
typedef|typedef
name|PBQP
operator|::
name|Vector
name|Vector
expr_stmt|;
typedef|typedef
name|RAMatrix
name|Matrix
typedef|;
typedef|typedef
name|PBQP
operator|::
name|PoolCostAllocator
operator|<
name|Vector
operator|,
name|PBQP
operator|::
name|VectorComparator
operator|,
name|Matrix
operator|,
name|PBQP
operator|::
name|MatrixComparator
operator|>
name|CostAllocator
expr_stmt|;
typedef|typedef
name|PBQP
operator|::
name|GraphBase
operator|::
name|NodeId
name|NodeId
expr_stmt|;
typedef|typedef
name|PBQP
operator|::
name|GraphBase
operator|::
name|EdgeId
name|EdgeId
expr_stmt|;
typedef|typedef
name|RegAlloc
operator|::
name|NodeMetadata
name|NodeMetadata
expr_stmt|;
struct|struct
name|EdgeMetadata
block|{ }
struct|;
typedef|typedef
name|PBQP
operator|::
name|Graph
operator|<
name|RegAllocSolverImpl
operator|>
name|Graph
expr_stmt|;
name|RegAllocSolverImpl
argument_list|(
name|Graph
operator|&
name|G
argument_list|)
operator|:
name|G
argument_list|(
argument|G
argument_list|)
block|{}
name|Solution
name|solve
argument_list|()
block|{
name|G
operator|.
name|setSolver
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|Solution
name|S
block|;
name|setup
argument_list|()
block|;
name|S
operator|=
name|backpropagate
argument_list|(
name|G
argument_list|,
name|reduce
argument_list|()
argument_list|)
block|;
name|G
operator|.
name|unsetSolver
argument_list|()
block|;
return|return
name|S
return|;
block|}
name|void
name|handleAddNode
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setup
argument_list|(
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleRemoveNode
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{}
name|void
name|handleSetNodeCosts
parameter_list|(
name|NodeId
name|NId
parameter_list|,
specifier|const
name|Vector
modifier|&
name|newCosts
parameter_list|)
block|{}
name|void
name|handleAddEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|)
block|{
name|handleReconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
name|handleReconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleRemoveEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|)
block|{
name|handleDisconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
name|handleDisconnectEdge
argument_list|(
name|EId
argument_list|,
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleDisconnectEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
name|NodeId
name|NId
parameter_list|)
block|{
name|NodeMetadata
modifier|&
name|NMd
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
decl_stmt|;
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|NMd
operator|.
name|handleRemoveEdge
argument_list|(
name|MMd
argument_list|,
name|NId
operator|==
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|==
literal|3
condition|)
block|{
comment|// This node is becoming optimally reducible.
name|moveToOptimallyReducibleNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMd
operator|.
name|getReductionState
argument_list|()
operator|==
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
operator|&&
name|NMd
operator|.
name|isConservativelyAllocatable
argument_list|()
condition|)
block|{
comment|// This node just became conservatively allocatable.
name|moveToConservativelyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|handleReconnectEdge
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
name|NodeId
name|NId
parameter_list|)
block|{
name|NodeMetadata
modifier|&
name|NMd
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
decl_stmt|;
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|NMd
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
name|NId
operator|==
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|handleSetEdgeCosts
parameter_list|(
name|EdgeId
name|EId
parameter_list|,
specifier|const
name|Matrix
modifier|&
name|NewCosts
parameter_list|)
block|{
name|handleRemoveEdge
argument_list|(
name|EId
argument_list|)
expr_stmt|;
name|NodeId
name|N1Id
init|=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|NodeId
name|N2Id
init|=
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|NodeMetadata
modifier|&
name|N1Md
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|N1Id
argument_list|)
decl_stmt|;
name|NodeMetadata
modifier|&
name|N2Md
init|=
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|N2Id
argument_list|)
decl_stmt|;
specifier|const
name|MatrixMetadata
modifier|&
name|MMd
init|=
name|NewCosts
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|N1Md
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
name|N1Id
operator|!=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
name|N2Md
operator|.
name|handleAddEdge
argument_list|(
name|MMd
argument_list|,
name|N2Id
operator|!=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|void
name|removeFromCurrentSet
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
switch|switch
condition|(
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|getReductionState
argument_list|()
condition|)
block|{
case|case
name|NodeMetadata
operator|::
name|Unprocessed
case|:
break|break;
case|case
name|NodeMetadata
operator|::
name|OptimallyReducible
case|:
name|assert
argument_list|(
name|OptimallyReducibleNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|OptimallyReducibleNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in optimally reducible set."
argument_list|)
expr_stmt|;
name|OptimallyReducibleNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
name|NodeMetadata
operator|::
name|ConservativelyAllocatable
case|:
name|assert
argument_list|(
name|ConservativelyAllocatableNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|ConservativelyAllocatableNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in conservatively allocatable set."
argument_list|)
expr_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
case|:
name|assert
argument_list|(
name|NotProvablyAllocatableNodes
operator|.
name|find
argument_list|(
name|NId
argument_list|)
operator|!=
name|NotProvablyAllocatableNodes
operator|.
name|end
argument_list|()
operator|&&
literal|"Node not in not-provably-allocatable set."
argument_list|)
expr_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NId
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|void
name|moveToOptimallyReducibleNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|OptimallyReducibleNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|OptimallyReducible
argument_list|)
expr_stmt|;
block|}
name|void
name|moveToConservativelyAllocatableNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|ConservativelyAllocatable
argument_list|)
expr_stmt|;
block|}
name|void
name|moveToNotProvablyAllocatableNodes
parameter_list|(
name|NodeId
name|NId
parameter_list|)
block|{
name|removeFromCurrentSet
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|insert
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|setReductionState
argument_list|(
name|NodeMetadata
operator|::
name|NotProvablyAllocatable
argument_list|)
expr_stmt|;
block|}
name|void
name|setup
parameter_list|()
block|{
comment|// Set up worklists.
for|for
control|(
name|auto
name|NId
range|:
name|G
operator|.
name|nodeIds
argument_list|()
control|)
block|{
if|if
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|<
literal|3
condition|)
name|moveToOptimallyReducibleNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|isConservativelyAllocatable
argument_list|()
condition|)
name|moveToConservativelyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
else|else
name|moveToNotProvablyAllocatableNodes
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compute a reduction order for the graph by iteratively applying PBQP
comment|// reduction rules. Locally optimal rules are applied whenever possible (R0,
comment|// R1, R2). If no locally-optimal rules apply then any conservatively
comment|// allocatable node is reduced. Finally, if no conservatively allocatable
comment|// node exists then the node with the lowest spill-cost:degree ratio is
comment|// selected.
name|std
operator|::
name|vector
operator|<
name|GraphBase
operator|::
name|NodeId
operator|>
name|reduce
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|G
operator|.
name|empty
argument_list|()
operator|&&
literal|"Cannot reduce empty graph."
argument_list|)
block|;
typedef|typedef
name|GraphBase
operator|::
name|NodeId
name|NodeId
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|NodeId
operator|>
name|NodeStack
expr_stmt|;
comment|// Consume worklists.
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
operator|!
name|OptimallyReducibleNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|OptimallyReducibleNodes
operator|.
name|begin
argument_list|()
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|OptimallyReducibleNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|applyR1
argument_list|(
name|G
argument_list|,
name|NId
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|applyR2
argument_list|(
name|G
argument_list|,
name|NId
argument_list|)
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Not an optimally reducible node."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ConservativelyAllocatableNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Conservatively allocatable nodes will never spill. For now just
comment|// take the first node in the set and push it on the stack. When we
comment|// start optimizing more heavily for register preferencing, it may
comment|// would be better to push nodes with lower 'expected' or worst-case
comment|// register costs first (since early nodes are the most
comment|// constrained).
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|ConservativelyAllocatableNodes
operator|.
name|begin
argument_list|()
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|ConservativelyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectAllNeighborsFromNode
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NotProvablyAllocatableNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodeSet
operator|::
name|iterator
name|NItr
operator|=
name|std
operator|::
name|min_element
argument_list|(
name|NotProvablyAllocatableNodes
operator|.
name|begin
argument_list|()
argument_list|,
name|NotProvablyAllocatableNodes
operator|.
name|end
argument_list|()
argument_list|,
name|SpillCostComparator
argument_list|(
name|G
argument_list|)
argument_list|)
expr_stmt|;
name|NodeId
name|NId
init|=
operator|*
name|NItr
decl_stmt|;
name|NotProvablyAllocatableNodes
operator|.
name|erase
argument_list|(
name|NItr
argument_list|)
expr_stmt|;
name|NodeStack
operator|.
name|push_back
argument_list|(
name|NId
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectAllNeighborsFromNode
argument_list|(
name|NId
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|NodeStack
return|;
block|}
name|class
name|SpillCostComparator
block|{
name|public
label|:
name|SpillCostComparator
argument_list|(
specifier|const
name|Graph
operator|&
name|G
argument_list|)
operator|:
name|G
argument_list|(
argument|G
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
name|NodeId
name|N1Id
operator|,
name|NodeId
name|N2Id
operator|)
block|{
name|PBQPNum
name|N1SC
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|N1Id
argument_list|)
index|[
literal|0
index|]
operator|/
name|G
operator|.
name|getNodeDegree
argument_list|(
name|N1Id
argument_list|)
block|;
name|PBQPNum
name|N2SC
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|N2Id
argument_list|)
index|[
literal|0
index|]
operator|/
name|G
operator|.
name|getNodeDegree
argument_list|(
name|N2Id
argument_list|)
block|;
return|return
name|N1SC
operator|<
name|N2SC
return|;
block|}
name|private
label|:
specifier|const
name|Graph
modifier|&
name|G
decl_stmt|;
block|}
empty_stmt|;
name|Graph
modifier|&
name|G
decl_stmt|;
typedef|typedef
name|std
operator|::
name|set
operator|<
name|NodeId
operator|>
name|NodeSet
expr_stmt|;
name|NodeSet
name|OptimallyReducibleNodes
decl_stmt|;
name|NodeSet
name|ConservativelyAllocatableNodes
decl_stmt|;
name|NodeSet
name|NotProvablyAllocatableNodes
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|Graph
operator|<
name|RegAllocSolverImpl
operator|>
name|Graph
expr_stmt|;
end_typedef

begin_function
specifier|inline
name|Solution
name|solve
parameter_list|(
name|Graph
modifier|&
name|G
parameter_list|)
block|{
if|if
condition|(
name|G
operator|.
name|empty
argument_list|()
condition|)
return|return
name|Solution
argument_list|()
return|;
name|RegAllocSolverImpl
name|RegAllocSolver
argument_list|(
name|G
argument_list|)
decl_stmt|;
return|return
name|RegAllocSolver
operator|.
name|solve
argument_list|()
return|;
block|}
end_function

begin_endif
unit|} }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_REGALLOCSOLVER_H
end_comment

end_unit

