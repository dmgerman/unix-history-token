begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ReductionRules.h - Reduction Rules -----------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Reduction Rules.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_REDUCTIONRULES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_REDUCTIONRULES_H
end_define

begin_include
include|#
directive|include
file|"Graph.h"
end_include

begin_include
include|#
directive|include
file|"Math.h"
end_include

begin_include
include|#
directive|include
file|"Solution.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PBQP
block|{
comment|/// \brief Reduce a node of degree one.
comment|///
comment|/// Propagate costs from the given node, which must be of degree one, to its
comment|/// neighbor. Notify the problem domain.
name|template
operator|<
name|typename
name|GraphT
operator|>
name|void
name|applyR1
argument_list|(
argument|GraphT&G
argument_list|,
argument|typename GraphT::NodeId NId
argument_list|)
block|{
name|using
name|NodeId
operator|=
name|typename
name|GraphT
operator|::
name|NodeId
block|;
name|using
name|EdgeId
operator|=
name|typename
name|GraphT
operator|::
name|EdgeId
block|;
name|using
name|Vector
operator|=
name|typename
name|GraphT
operator|::
name|Vector
block|;
name|using
name|Matrix
operator|=
name|typename
name|GraphT
operator|::
name|Matrix
block|;
name|using
name|RawVector
operator|=
name|typename
name|GraphT
operator|::
name|RawVector
block|;
name|assert
argument_list|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|==
literal|1
operator|&&
literal|"R1 applied to node with degree != 1."
argument_list|)
block|;
name|EdgeId
name|EId
operator|=
operator|*
name|G
operator|.
name|adjEdgeIds
argument_list|(
name|NId
argument_list|)
operator|.
name|begin
argument_list|()
block|;
name|NodeId
name|MId
operator|=
name|G
operator|.
name|getEdgeOtherNodeId
argument_list|(
name|EId
argument_list|,
name|NId
argument_list|)
block|;
specifier|const
name|Matrix
operator|&
name|ECosts
operator|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
block|;
specifier|const
name|Vector
operator|&
name|XCosts
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
block|;
name|RawVector
name|YCosts
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|MId
argument_list|)
block|;
comment|// Duplicate a little to avoid transposing matrices.
if|if
condition|(
name|NId
operator|==
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
condition|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|YCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|Min
init|=
name|ECosts
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|XCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|XCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|C
init|=
name|ECosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|XCosts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|C
operator|<
name|Min
condition|)
name|Min
operator|=
name|C
expr_stmt|;
block|}
name|YCosts
index|[
name|j
index|]
operator|+=
name|Min
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|YCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|Min
init|=
name|ECosts
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
name|XCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|XCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|C
init|=
name|ECosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|XCosts
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|C
operator|<
name|Min
condition|)
name|Min
operator|=
name|C
expr_stmt|;
block|}
name|YCosts
index|[
name|i
index|]
operator|+=
name|Min
expr_stmt|;
block|}
block|}
name|G
operator|.
name|setNodeCosts
argument_list|(
name|MId
argument_list|,
name|YCosts
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectEdge
argument_list|(
name|EId
argument_list|,
name|MId
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|GraphT
operator|>
name|void
name|applyR2
argument_list|(
argument|GraphT&G
argument_list|,
argument|typename GraphT::NodeId NId
argument_list|)
block|{
name|using
name|NodeId
operator|=
name|typename
name|GraphT
operator|::
name|NodeId
block|;
name|using
name|EdgeId
operator|=
name|typename
name|GraphT
operator|::
name|EdgeId
block|;
name|using
name|Vector
operator|=
name|typename
name|GraphT
operator|::
name|Vector
block|;
name|using
name|Matrix
operator|=
name|typename
name|GraphT
operator|::
name|Matrix
block|;
name|using
name|RawMatrix
operator|=
name|typename
name|GraphT
operator|::
name|RawMatrix
block|;
name|assert
argument_list|(
name|G
operator|.
name|getNodeDegree
argument_list|(
name|NId
argument_list|)
operator|==
literal|2
operator|&&
literal|"R2 applied to node with degree != 2."
argument_list|)
block|;
specifier|const
name|Vector
operator|&
name|XCosts
operator|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
block|;
name|typename
name|GraphT
operator|::
name|AdjEdgeItr
name|AEItr
operator|=
name|G
operator|.
name|adjEdgeIds
argument_list|(
name|NId
argument_list|)
operator|.
name|begin
argument_list|()
block|;
name|EdgeId
name|YXEId
operator|=
operator|*
name|AEItr
block|,
name|ZXEId
operator|=
operator|*
operator|(
operator|++
name|AEItr
operator|)
block|;
name|NodeId
name|YNId
operator|=
name|G
operator|.
name|getEdgeOtherNodeId
argument_list|(
name|YXEId
argument_list|,
name|NId
argument_list|)
block|,
name|ZNId
operator|=
name|G
operator|.
name|getEdgeOtherNodeId
argument_list|(
name|ZXEId
argument_list|,
name|NId
argument_list|)
block|;
name|bool
name|FlipEdge1
operator|=
operator|(
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|YXEId
argument_list|)
operator|==
name|NId
operator|)
block|,
name|FlipEdge2
operator|=
operator|(
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|ZXEId
argument_list|)
operator|==
name|NId
operator|)
block|;
specifier|const
name|Matrix
operator|*
name|YXECosts
operator|=
name|FlipEdge1
condition|?
name|new
name|Matrix
argument_list|(
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|YXEId
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|YXEId
argument_list|)
block|;
specifier|const
name|Matrix
operator|*
name|ZXECosts
operator|=
name|FlipEdge2
condition|?
name|new
name|Matrix
argument_list|(
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|ZXEId
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|ZXEId
argument_list|)
block|;
name|unsigned
name|XLen
operator|=
name|XCosts
operator|.
name|getLength
argument_list|()
block|,
name|YLen
operator|=
name|YXECosts
operator|->
name|getRows
argument_list|()
block|,
name|ZLen
operator|=
name|ZXECosts
operator|->
name|getRows
argument_list|()
block|;
name|RawMatrix
name|Delta
argument_list|(
name|YLen
argument_list|,
name|ZLen
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|YLen
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ZLen
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|Min
init|=
operator|(
operator|*
name|YXECosts
operator|)
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
operator|(
operator|*
name|ZXECosts
operator|)
index|[
name|j
index|]
index|[
literal|0
index|]
operator|+
name|XCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|k
init|=
literal|1
init|;
name|k
operator|<
name|XLen
condition|;
operator|++
name|k
control|)
block|{
name|PBQPNum
name|C
init|=
operator|(
operator|*
name|YXECosts
operator|)
index|[
name|i
index|]
index|[
name|k
index|]
operator|+
operator|(
operator|*
name|ZXECosts
operator|)
index|[
name|j
index|]
index|[
name|k
index|]
operator|+
name|XCosts
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|C
operator|<
name|Min
condition|)
block|{
name|Min
operator|=
name|C
expr_stmt|;
block|}
block|}
name|Delta
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|Min
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FlipEdge1
condition|)
name|delete
name|YXECosts
decl_stmt|;
if|if
condition|(
name|FlipEdge2
condition|)
name|delete
name|ZXECosts
decl_stmt|;
name|EdgeId
name|YZEId
init|=
name|G
operator|.
name|findEdge
argument_list|(
name|YNId
argument_list|,
name|ZNId
argument_list|)
decl_stmt|;
if|if
condition|(
name|YZEId
operator|==
name|G
operator|.
name|invalidEdgeId
argument_list|()
condition|)
block|{
name|YZEId
operator|=
name|G
operator|.
name|addEdge
argument_list|(
name|YNId
argument_list|,
name|ZNId
argument_list|,
name|Delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|Matrix
modifier|&
name|YZECosts
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|YZEId
argument_list|)
decl_stmt|;
if|if
condition|(
name|YNId
operator|==
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|YZEId
argument_list|)
condition|)
block|{
name|G
operator|.
name|updateEdgeCosts
argument_list|(
name|YZEId
argument_list|,
name|Delta
operator|+
name|YZECosts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G
operator|.
name|updateEdgeCosts
argument_list|(
name|YZEId
argument_list|,
name|Delta
operator|.
name|transpose
argument_list|()
operator|+
name|YZECosts
argument_list|)
expr_stmt|;
block|}
block|}
name|G
operator|.
name|disconnectEdge
argument_list|(
name|YXEId
argument_list|,
name|YNId
argument_list|)
expr_stmt|;
name|G
operator|.
name|disconnectEdge
argument_list|(
name|ZXEId
argument_list|,
name|ZNId
argument_list|)
expr_stmt|;
comment|// TODO: Try to normalize newly added/modified edge.
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|// Does this Cost vector have any register options ?
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|VectorT
operator|>
name|bool
name|hasRegisterOptions
argument_list|(
argument|const VectorT&V
argument_list|)
block|{
name|unsigned
name|VL
operator|=
name|V
operator|.
name|getLength
argument_list|()
block|;
comment|// An empty or spill only cost vector does not provide any register option.
if|if
condition|(
name|VL
operator|<=
literal|1
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_comment
comment|// If there are registers in the cost vector, but all of them have infinite
end_comment

begin_comment
comment|// costs, then ... there is no available register.
end_comment

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|VL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|V
index|[
name|i
index|]
operator|!=
name|std
operator|::
name|numeric_limits
operator|<
name|PBQP
operator|::
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
return|return
name|true
return|;
end_for

begin_return
return|return
name|false
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// \brief Find a solution to a fully reduced graph by backpropagation.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Given a graph and a reduction order, pop each node from the reduction
end_comment

begin_comment
comment|// order and greedily compute a minimum solution based on the node costs, and
end_comment

begin_comment
comment|// the dependent costs due to previously solved nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note - This does not return the graph to its original (pre-reduction)
end_comment

begin_comment
comment|//        state: the existing solvers destructively alter the node and edge
end_comment

begin_comment
comment|//        costs. Given that, the backpropagate function doesn't attempt to
end_comment

begin_comment
comment|//        replace the edges either, but leaves the graph in its reduced
end_comment

begin_comment
comment|//        state.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|GraphT
operator|,
name|typename
name|StackT
operator|>
name|Solution
name|backpropagate
argument_list|(
argument|GraphT& G
argument_list|,
argument|StackT stack
argument_list|)
block|{
name|using
name|NodeId
operator|=
name|GraphBase
operator|::
name|NodeId
block|;
name|using
name|Matrix
operator|=
name|typename
name|GraphT
operator|::
name|Matrix
block|;
name|using
name|RawVector
operator|=
name|typename
name|GraphT
operator|::
name|RawVector
block|;
name|Solution
name|s
block|;
while|while
condition|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NodeId
name|NId
init|=
name|stack
operator|.
name|back
argument_list|()
decl_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|RawVector
name|v
init|=
name|G
operator|.
name|getNodeCosts
argument_list|(
name|NId
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Although a conservatively allocatable node can be allocated to a register,
comment|// spilling it may provide a lower cost solution. Assert here that spilling
comment|// is done by choice, not because there were no register available.
if|if
condition|(
name|G
operator|.
name|getNodeMetadata
argument_list|(
name|NId
argument_list|)
operator|.
name|wasConservativelyAllocatable
argument_list|()
condition|)
name|assert
argument_list|(
name|hasRegisterOptions
argument_list|(
name|v
argument_list|)
operator|&&
literal|"A conservatively allocatable node "
literal|"must have available register options"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|auto
name|EId
range|:
name|G
operator|.
name|adjEdgeIds
argument_list|(
name|NId
argument_list|)
control|)
block|{
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|G
operator|.
name|getEdgeCosts
argument_list|(
name|EId
argument_list|)
decl_stmt|;
if|if
condition|(
name|NId
operator|==
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
condition|)
block|{
name|NodeId
name|mId
init|=
name|G
operator|.
name|getEdgeNode2Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getColAsVector
argument_list|(
name|s
operator|.
name|getSelection
argument_list|(
name|mId
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|NodeId
name|mId
init|=
name|G
operator|.
name|getEdgeNode1Id
argument_list|(
name|EId
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|s
operator|.
name|getSelection
argument_list|(
name|mId
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}        s
operator|.
name|setSelection
argument_list|(
name|NId
argument_list|,
name|v
operator|.
name|minIndex
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}      return
name|s
expr_stmt|;
end_expr_stmt

begin_comment
unit|}  }
comment|// end namespace PBQP
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_REDUCTIONRULES_H
end_comment

end_unit

