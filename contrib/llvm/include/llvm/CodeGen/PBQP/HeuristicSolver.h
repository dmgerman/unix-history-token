begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- HeuristicSolver.h - Heuristic PBQP Solver --------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Heuristic PBQP solver. This solver is able to perform optimal reductions for
end_comment

begin_comment
comment|// nodes of degree 0, 1 or 2. For nodes of degree>2 a plugable heuristic is
end_comment

begin_comment
comment|// used to select a node for reduction.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_define

begin_include
include|#
directive|include
file|"Graph.h"
end_include

begin_include
include|#
directive|include
file|"Solution.h"
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|/// \brief Heuristic PBQP solver implementation.
comment|///
comment|/// This class should usually be created (and destroyed) indirectly via a call
comment|/// to HeuristicSolver<HImpl>::solve(Graph&).
comment|/// See the comments for HeuristicSolver.
comment|///
comment|/// HeuristicSolverImpl provides the R0, R1 and R2 reduction rules,
comment|/// backpropagation phase, and maintains the internal copy of the graph on
comment|/// which the reduction is carried out (the original being kept to facilitate
comment|/// backpropagation).
name|template
operator|<
name|typename
name|HImpl
operator|>
name|class
name|HeuristicSolverImpl
block|{
name|private
operator|:
typedef|typedef
name|typename
name|HImpl
operator|::
name|NodeData
name|HeuristicNodeData
expr_stmt|;
typedef|typedef
name|typename
name|HImpl
operator|::
name|EdgeData
name|HeuristicEdgeData
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|Graph
operator|::
name|EdgeId
operator|>
name|SolverEdges
expr_stmt|;
name|public
label|:
comment|/// \brief Iterator type for edges in the solver graph.
typedef|typedef
name|SolverEdges
operator|::
name|iterator
name|SolverEdgeItr
expr_stmt|;
name|private
label|:
name|class
name|NodeData
block|{
name|public
label|:
name|NodeData
argument_list|()
operator|:
name|solverDegree
argument_list|(
literal|0
argument_list|)
block|{}
name|HeuristicNodeData
operator|&
name|getHeuristicData
argument_list|()
block|{
return|return
name|hData
return|;
block|}
name|SolverEdgeItr
name|addSolverEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
operator|++
name|solverDegree
expr_stmt|;
return|return
name|solverEdges
operator|.
name|insert
argument_list|(
name|solverEdges
operator|.
name|end
argument_list|()
argument_list|,
name|eId
argument_list|)
return|;
block|}
name|void
name|removeSolverEdge
parameter_list|(
name|SolverEdgeItr
name|seItr
parameter_list|)
block|{
operator|--
name|solverDegree
expr_stmt|;
name|solverEdges
operator|.
name|erase
argument_list|(
name|seItr
argument_list|)
expr_stmt|;
block|}
name|SolverEdgeItr
name|solverEdgesBegin
parameter_list|()
block|{
return|return
name|solverEdges
operator|.
name|begin
argument_list|()
return|;
block|}
name|SolverEdgeItr
name|solverEdgesEnd
parameter_list|()
block|{
return|return
name|solverEdges
operator|.
name|end
argument_list|()
return|;
block|}
name|unsigned
name|getSolverDegree
argument_list|()
specifier|const
block|{
return|return
name|solverDegree
return|;
block|}
name|void
name|clearSolverEdges
parameter_list|()
block|{
name|solverDegree
operator|=
literal|0
expr_stmt|;
name|solverEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|private
label|:
name|HeuristicNodeData
name|hData
decl_stmt|;
name|unsigned
name|solverDegree
decl_stmt|;
name|SolverEdges
name|solverEdges
decl_stmt|;
block|}
empty_stmt|;
name|class
name|EdgeData
block|{
name|public
label|:
name|HeuristicEdgeData
modifier|&
name|getHeuristicData
parameter_list|()
block|{
return|return
name|hData
return|;
block|}
name|void
name|setN1SolverEdgeItr
parameter_list|(
name|SolverEdgeItr
name|n1SolverEdgeItr
parameter_list|)
block|{
name|this
operator|->
name|n1SolverEdgeItr
operator|=
name|n1SolverEdgeItr
expr_stmt|;
block|}
name|SolverEdgeItr
name|getN1SolverEdgeItr
parameter_list|()
block|{
return|return
name|n1SolverEdgeItr
return|;
block|}
name|void
name|setN2SolverEdgeItr
parameter_list|(
name|SolverEdgeItr
name|n2SolverEdgeItr
parameter_list|)
block|{
name|this
operator|->
name|n2SolverEdgeItr
operator|=
name|n2SolverEdgeItr
expr_stmt|;
block|}
name|SolverEdgeItr
name|getN2SolverEdgeItr
parameter_list|()
block|{
return|return
name|n2SolverEdgeItr
return|;
block|}
name|private
label|:
name|HeuristicEdgeData
name|hData
decl_stmt|;
name|SolverEdgeItr
name|n1SolverEdgeItr
decl_stmt|,
name|n2SolverEdgeItr
decl_stmt|;
block|}
empty_stmt|;
name|Graph
modifier|&
name|g
decl_stmt|;
name|HImpl
name|h
decl_stmt|;
name|Solution
name|s
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|Graph
operator|::
name|NodeId
operator|>
name|stack
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|NodeData
operator|>
name|NodeDataList
expr_stmt|;
name|NodeDataList
name|nodeDataList
decl_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|EdgeData
operator|>
name|EdgeDataList
expr_stmt|;
name|EdgeDataList
name|edgeDataList
decl_stmt|;
name|public
label|:
comment|/// \brief Construct a heuristic solver implementation to solve the given
comment|///        graph.
comment|/// @param g The graph representing the problem instance to be solved.
name|HeuristicSolverImpl
argument_list|(
name|Graph
operator|&
name|g
argument_list|)
operator|:
name|g
argument_list|(
name|g
argument_list|)
operator|,
name|h
argument_list|(
argument|*this
argument_list|)
block|{}
comment|/// \brief Get the graph being solved by this solver.
comment|/// @return The graph representing the problem instance being solved by this
comment|///         solver.
name|Graph
operator|&
name|getGraph
argument_list|()
block|{
return|return
name|g
return|;
block|}
comment|/// \brief Get the heuristic data attached to the given node.
comment|/// @param nId Node id.
comment|/// @return The heuristic data attached to the given node.
name|HeuristicNodeData
modifier|&
name|getHeuristicNodeData
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
return|;
block|}
comment|/// \brief Get the heuristic data attached to the given edge.
comment|/// @param eId Edge id.
comment|/// @return The heuristic data attached to the given node.
name|HeuristicEdgeData
modifier|&
name|getHeuristicEdgeData
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
return|return
name|getSolverEdgeData
argument_list|(
name|eId
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
return|;
block|}
comment|/// \brief Begin iterator for the set of edges adjacent to the given node in
comment|///        the solver graph.
comment|/// @param nId Node id.
comment|/// @return Begin iterator for the set of edges adjacent to the given node
comment|///         in the solver graph.
name|SolverEdgeItr
name|solverEdgesBegin
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|solverEdgesBegin
argument_list|()
return|;
block|}
comment|/// \brief End iterator for the set of edges adjacent to the given node in
comment|///        the solver graph.
comment|/// @param nId Node id.
comment|/// @return End iterator for the set of edges adjacent to the given node in
comment|///         the solver graph.
name|SolverEdgeItr
name|solverEdgesEnd
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|solverEdgesEnd
argument_list|()
return|;
block|}
comment|/// \brief Remove a node from the solver graph.
comment|/// @param eId Edge id for edge to be removed.
comment|///
comment|/// Does<i>not</i> notify the heuristic of the removal. That should be
comment|/// done manually if necessary.
name|void
name|removeSolverEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
name|EdgeData
modifier|&
name|eData
init|=
name|getSolverEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|NodeData
modifier|&
name|n1Data
init|=
name|getSolverNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|n2Data
init|=
name|getSolverNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|;
name|n1Data
operator|.
name|removeSolverEdge
argument_list|(
name|eData
operator|.
name|getN1SolverEdgeItr
argument_list|()
argument_list|)
expr_stmt|;
name|n2Data
operator|.
name|removeSolverEdge
argument_list|(
name|eData
operator|.
name|getN2SolverEdgeItr
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Compute a solution to the PBQP problem instance with which this
comment|///        heuristic solver was constructed.
comment|/// @return A solution to the PBQP problem.
comment|///
comment|/// Performs the full PBQP heuristic solver algorithm, including setup,
comment|/// calls to the heuristic (which will call back to the reduction rules in
comment|/// this class), and cleanup.
name|Solution
name|computeSolution
parameter_list|()
block|{
name|setup
argument_list|()
expr_stmt|;
name|h
operator|.
name|setup
argument_list|()
expr_stmt|;
name|h
operator|.
name|reduce
argument_list|()
expr_stmt|;
name|backpropagate
argument_list|()
expr_stmt|;
name|h
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/// \brief Add to the end of the stack.
comment|/// @param nId Node id to add to the reduction stack.
name|void
name|pushToStack
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|clearSolverEdges
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push_back
argument_list|(
name|nId
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Returns the solver degree of the given node.
comment|/// @param nId Node id for which degree is requested.
comment|/// @return Node degree in the<i>solver</i> graph (not the original graph).
name|unsigned
name|getSolverDegree
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|getSolverDegree
argument_list|()
return|;
block|}
comment|/// \brief Set the solution of the given node.
comment|/// @param nId Node id to set solution for.
comment|/// @param selection Selection for node.
name|void
name|setSolution
argument_list|(
specifier|const
name|Graph
operator|::
name|NodeId
operator|&
name|nId
argument_list|,
name|unsigned
name|selection
argument_list|)
block|{
name|s
operator|.
name|setSelection
argument_list|(
name|nId
argument_list|,
name|selection
argument_list|)
expr_stmt|;
for|for
control|(
name|Graph
operator|::
name|AdjEdgeItr
name|aeItr
operator|=
name|g
operator|.
name|adjEdgesBegin
argument_list|(
name|nId
argument_list|)
operator|,
name|aeEnd
operator|=
name|g
operator|.
name|adjEdgesEnd
argument_list|(
name|nId
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|(
operator|*
name|aeItr
argument_list|)
expr_stmt|;
name|Graph
operator|::
name|NodeId
name|anId
argument_list|(
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|eId
argument_list|,
name|nId
argument_list|)
argument_list|)
expr_stmt|;
name|getSolverNodeData
argument_list|(
name|anId
argument_list|)
operator|.
name|addSolverEdge
argument_list|(
name|eId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// \brief Apply rule R0.
comment|/// @param nId Node id for node to apply R0 to.
comment|///
comment|/// Node will be automatically pushed to the solver stack.
name|void
name|applyR0
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|assert
argument_list|(
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
operator|.
name|getSolverDegree
argument_list|()
operator|==
literal|0
operator|&&
literal|"R0 applied to node with degree != 0."
argument_list|)
expr_stmt|;
comment|// Nothing to do. Just push the node onto the reduction stack.
name|pushToStack
argument_list|(
name|nId
argument_list|)
expr_stmt|;
name|s
operator|.
name|recordR0
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Apply rule R1.
comment|/// @param xnId Node id for node to apply R1 to.
comment|///
comment|/// Node will be automatically pushed to the solver stack.
name|void
name|applyR1
argument_list|(
name|Graph
operator|::
name|NodeId
name|xnId
argument_list|)
block|{
name|NodeData
modifier|&
name|nd
init|=
name|getSolverNodeData
argument_list|(
name|xnId
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|nd
operator|.
name|getSolverDegree
argument_list|()
operator|==
literal|1
operator|&&
literal|"R1 applied to node with degree != 1."
argument_list|)
expr_stmt|;
name|Graph
operator|::
name|EdgeId
name|eId
operator|=
operator|*
name|nd
operator|.
name|solverEdgesBegin
argument_list|()
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|eCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
decl_stmt|;
specifier|const
name|Vector
modifier|&
name|xCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|xnId
argument_list|)
decl_stmt|;
comment|// Duplicate a little to avoid transposing matrices.
if|if
condition|(
name|xnId
operator|==
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
condition|)
block|{
name|Graph
operator|::
name|NodeId
name|ynId
operator|=
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|Vector
modifier|&
name|yCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|ynId
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|yCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|min
init|=
name|eCosts
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|xCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|c
init|=
name|eCosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
name|min
operator|=
name|c
expr_stmt|;
block|}
name|yCosts
index|[
name|j
index|]
operator|+=
name|min
expr_stmt|;
block|}
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|eId
argument_list|,
name|ynId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Graph
operator|::
name|NodeId
name|ynId
operator|=
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|Vector
modifier|&
name|yCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|ynId
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|yCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|min
init|=
name|eCosts
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|xCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|c
init|=
name|eCosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
name|min
operator|=
name|c
expr_stmt|;
block|}
name|yCosts
index|[
name|i
index|]
operator|+=
name|min
expr_stmt|;
block|}
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|eId
argument_list|,
name|ynId
argument_list|)
expr_stmt|;
block|}
name|removeSolverEdge
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nd
operator|.
name|getSolverDegree
argument_list|()
operator|==
literal|0
operator|&&
literal|"Degree 1 with edge removed should be 0."
argument_list|)
expr_stmt|;
name|pushToStack
argument_list|(
name|xnId
argument_list|)
expr_stmt|;
name|s
operator|.
name|recordR1
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Apply rule R2.
comment|/// @param xnId Node id for node to apply R2 to.
comment|///
comment|/// Node will be automatically pushed to the solver stack.
name|void
name|applyR2
argument_list|(
name|Graph
operator|::
name|NodeId
name|xnId
argument_list|)
block|{
name|assert
argument_list|(
name|getSolverNodeData
argument_list|(
name|xnId
argument_list|)
operator|.
name|getSolverDegree
argument_list|()
operator|==
literal|2
operator|&&
literal|"R2 applied to node with degree != 2."
argument_list|)
expr_stmt|;
name|NodeData
modifier|&
name|nd
init|=
name|getSolverNodeData
argument_list|(
name|xnId
argument_list|)
decl_stmt|;
specifier|const
name|Vector
modifier|&
name|xCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|xnId
argument_list|)
decl_stmt|;
name|SolverEdgeItr
name|aeItr
init|=
name|nd
operator|.
name|solverEdgesBegin
argument_list|()
decl_stmt|;
name|Graph
operator|::
name|EdgeId
name|yxeId
operator|=
operator|*
name|aeItr
operator|,
name|zxeId
operator|=
operator|*
operator|(
operator|++
name|aeItr
operator|)
expr_stmt|;
name|Graph
operator|::
name|NodeId
name|ynId
operator|=
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|yxeId
argument_list|,
name|xnId
argument_list|)
operator|,
name|znId
operator|=
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|zxeId
argument_list|,
name|xnId
argument_list|)
expr_stmt|;
name|bool
name|flipEdge1
init|=
operator|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|yxeId
argument_list|)
operator|==
name|xnId
operator|)
decl_stmt|,
name|flipEdge2
init|=
operator|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|zxeId
argument_list|)
operator|==
name|xnId
operator|)
decl_stmt|;
specifier|const
name|Matrix
modifier|*
name|yxeCosts
init|=
name|flipEdge1
condition|?
name|new
name|Matrix
argument_list|(
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yxeId
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yxeId
argument_list|)
decl_stmt|;
specifier|const
name|Matrix
modifier|*
name|zxeCosts
init|=
name|flipEdge2
condition|?
name|new
name|Matrix
argument_list|(
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|zxeId
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|zxeId
argument_list|)
decl_stmt|;
name|unsigned
name|xLen
init|=
name|xCosts
operator|.
name|getLength
argument_list|()
decl_stmt|,
name|yLen
init|=
name|yxeCosts
operator|->
name|getRows
argument_list|()
decl_stmt|,
name|zLen
init|=
name|zxeCosts
operator|->
name|getRows
argument_list|()
decl_stmt|;
name|Matrix
name|delta
parameter_list|(
name|yLen
parameter_list|,
name|zLen
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|yLen
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|zLen
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|min
init|=
operator|(
operator|*
name|yxeCosts
operator|)
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
operator|(
operator|*
name|zxeCosts
operator|)
index|[
name|j
index|]
index|[
literal|0
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|k
init|=
literal|1
init|;
name|k
operator|<
name|xLen
condition|;
operator|++
name|k
control|)
block|{
name|PBQPNum
name|c
init|=
operator|(
operator|*
name|yxeCosts
operator|)
index|[
name|i
index|]
index|[
name|k
index|]
operator|+
operator|(
operator|*
name|zxeCosts
operator|)
index|[
name|j
index|]
index|[
name|k
index|]
operator|+
name|xCosts
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|c
expr_stmt|;
block|}
block|}
name|delta
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|min
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flipEdge1
condition|)
name|delete
name|yxeCosts
decl_stmt|;
if|if
condition|(
name|flipEdge2
condition|)
name|delete
name|zxeCosts
decl_stmt|;
name|Graph
operator|::
name|EdgeId
name|yzeId
operator|=
name|g
operator|.
name|findEdge
argument_list|(
name|ynId
argument_list|,
name|znId
argument_list|)
expr_stmt|;
name|bool
name|addedEdge
init|=
name|false
decl_stmt|;
if|if
condition|(
name|yzeId
operator|==
name|g
operator|.
name|invalidEdgeId
argument_list|()
condition|)
block|{
name|yzeId
operator|=
name|g
operator|.
name|addEdge
argument_list|(
name|ynId
argument_list|,
name|znId
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|addedEdge
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|Matrix
modifier|&
name|yzeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yzeId
argument_list|)
decl_stmt|;
name|h
operator|.
name|preUpdateEdgeCosts
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|ynId
operator|==
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|yzeId
argument_list|)
condition|)
block|{
name|yzeCosts
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|yzeCosts
operator|+=
name|delta
operator|.
name|transpose
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|nullCostEdge
init|=
name|tryNormaliseEdgeMatrix
argument_list|(
name|yzeId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedEdge
condition|)
block|{
comment|// If we modified the edge costs let the heuristic know.
name|h
operator|.
name|postUpdateEdgeCosts
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullCostEdge
condition|)
block|{
comment|// If this edge ended up null remove it.
if|if
condition|(
operator|!
name|addedEdge
condition|)
block|{
comment|// We didn't just add it, so we need to notify the heuristic
comment|// and remove it from the solver.
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|yzeId
argument_list|,
name|ynId
argument_list|)
expr_stmt|;
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|yzeId
argument_list|,
name|znId
argument_list|)
expr_stmt|;
name|removeSolverEdge
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|removeEdge
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addedEdge
condition|)
block|{
comment|// If the edge was added, and non-null, finish setting it up, add it to
comment|// the solver& notify heuristic.
name|edgeDataList
operator|.
name|push_back
argument_list|(
name|EdgeData
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|setEdgeData
argument_list|(
name|yzeId
argument_list|,
operator|&
name|edgeDataList
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|addSolverEdge
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
name|h
operator|.
name|handleAddEdge
argument_list|(
name|yzeId
argument_list|)
expr_stmt|;
block|}
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|yxeId
argument_list|,
name|ynId
argument_list|)
expr_stmt|;
name|removeSolverEdge
argument_list|(
name|yxeId
argument_list|)
expr_stmt|;
name|h
operator|.
name|handleRemoveEdge
argument_list|(
name|zxeId
argument_list|,
name|znId
argument_list|)
expr_stmt|;
name|removeSolverEdge
argument_list|(
name|zxeId
argument_list|)
expr_stmt|;
name|pushToStack
argument_list|(
name|xnId
argument_list|)
expr_stmt|;
name|s
operator|.
name|recordR2
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Record an application of the RN rule.
comment|///
comment|/// For use by the HeuristicBase.
name|void
name|recordRN
parameter_list|()
block|{
name|s
operator|.
name|recordRN
argument_list|()
expr_stmt|;
block|}
name|private
label|:
name|NodeData
modifier|&
name|getSolverNodeData
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
operator|*
name|static_cast
operator|<
name|NodeData
operator|*
operator|>
operator|(
name|g
operator|.
name|getNodeData
argument_list|(
name|nId
argument_list|)
operator|)
return|;
block|}
name|EdgeData
modifier|&
name|getSolverEdgeData
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
return|return
operator|*
name|static_cast
operator|<
name|EdgeData
operator|*
operator|>
operator|(
name|g
operator|.
name|getEdgeData
argument_list|(
name|eId
argument_list|)
operator|)
return|;
block|}
name|void
name|addSolverEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
name|EdgeData
modifier|&
name|eData
init|=
name|getSolverEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|NodeData
modifier|&
name|n1Data
init|=
name|getSolverNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|n2Data
init|=
name|getSolverNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|;
name|eData
operator|.
name|setN1SolverEdgeItr
argument_list|(
name|n1Data
operator|.
name|addSolverEdge
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
name|eData
operator|.
name|setN2SolverEdgeItr
argument_list|(
name|n2Data
operator|.
name|addSolverEdge
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|setup
parameter_list|()
block|{
if|if
condition|(
name|h
operator|.
name|solverRunSimplify
argument_list|()
condition|)
block|{
name|simplify
argument_list|()
expr_stmt|;
block|}
comment|// Create node data objects.
for|for
control|(
name|Graph
operator|::
name|NodeItr
name|nItr
operator|=
name|g
operator|.
name|nodesBegin
argument_list|()
operator|,
name|nEnd
operator|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nItr
operator|!=
name|nEnd
condition|;
operator|++
name|nItr
control|)
block|{
name|nodeDataList
operator|.
name|push_back
argument_list|(
name|NodeData
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|setNodeData
argument_list|(
operator|*
name|nItr
argument_list|,
operator|&
name|nodeDataList
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Create edge data objects.
for|for
control|(
name|Graph
operator|::
name|EdgeItr
name|eItr
operator|=
name|g
operator|.
name|edgesBegin
argument_list|()
operator|,
name|eEnd
operator|=
name|g
operator|.
name|edgesEnd
argument_list|()
init|;
name|eItr
operator|!=
name|eEnd
condition|;
operator|++
name|eItr
control|)
block|{
name|edgeDataList
operator|.
name|push_back
argument_list|(
name|EdgeData
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|setEdgeData
argument_list|(
operator|*
name|eItr
argument_list|,
operator|&
name|edgeDataList
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|addSolverEdge
argument_list|(
operator|*
name|eItr
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|simplify
parameter_list|()
block|{
name|disconnectTrivialNodes
argument_list|()
expr_stmt|;
name|eliminateIndependentEdges
argument_list|()
expr_stmt|;
block|}
comment|// Eliminate trivial nodes.
name|void
name|disconnectTrivialNodes
parameter_list|()
block|{
name|unsigned
name|numDisconnected
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Graph
operator|::
name|NodeItr
name|nItr
operator|=
name|g
operator|.
name|nodesBegin
argument_list|()
operator|,
name|nEnd
operator|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nItr
operator|!=
name|nEnd
condition|;
operator|++
name|nItr
control|)
block|{
name|Graph
operator|::
name|NodeId
name|nId
operator|=
operator|*
name|nItr
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
literal|1
condition|)
block|{
name|std
operator|::
name|vector
operator|<
name|Graph
operator|::
name|EdgeId
operator|>
name|edgesToRemove
expr_stmt|;
for|for
control|(
name|Graph
operator|::
name|AdjEdgeItr
name|aeItr
operator|=
name|g
operator|.
name|adjEdgesBegin
argument_list|(
name|nId
argument_list|)
operator|,
name|aeEnd
operator|=
name|g
operator|.
name|adjEdgesEnd
argument_list|(
name|nId
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
name|Graph
operator|::
name|EdgeId
name|eId
operator|=
operator|*
name|aeItr
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
operator|==
name|nId
condition|)
block|{
name|Graph
operator|::
name|NodeId
name|otherNodeId
operator|=
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|g
operator|.
name|getNodeCosts
argument_list|(
name|otherNodeId
argument_list|)
operator|+=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
operator|.
name|getRowAsVector
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Graph
operator|::
name|NodeId
name|otherNodeId
operator|=
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|g
operator|.
name|getNodeCosts
argument_list|(
name|otherNodeId
argument_list|)
operator|+=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
operator|.
name|getColAsVector
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|edgesToRemove
operator|.
name|push_back
argument_list|(
name|eId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edgesToRemove
operator|.
name|empty
argument_list|()
condition|)
operator|++
name|numDisconnected
expr_stmt|;
while|while
condition|(
operator|!
name|edgesToRemove
operator|.
name|empty
argument_list|()
condition|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|edgesToRemove
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|edgesToRemove
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|void
name|eliminateIndependentEdges
parameter_list|()
block|{
name|std
operator|::
name|vector
operator|<
name|Graph
operator|::
name|EdgeId
operator|>
name|edgesToProcess
expr_stmt|;
name|unsigned
name|numEliminated
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Graph
operator|::
name|EdgeItr
name|eItr
operator|=
name|g
operator|.
name|edgesBegin
argument_list|()
operator|,
name|eEnd
operator|=
name|g
operator|.
name|edgesEnd
argument_list|()
init|;
name|eItr
operator|!=
name|eEnd
condition|;
operator|++
name|eItr
control|)
block|{
name|edgesToProcess
operator|.
name|push_back
argument_list|(
operator|*
name|eItr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|edgesToProcess
operator|.
name|empty
argument_list|()
condition|)
block|{
if|if
condition|(
name|tryToEliminateEdge
argument_list|(
name|edgesToProcess
operator|.
name|back
argument_list|()
argument_list|)
condition|)
operator|++
name|numEliminated
expr_stmt|;
name|edgesToProcess
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|tryToEliminateEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
if|if
condition|(
name|tryNormaliseEdgeMatrix
argument_list|(
name|eId
argument_list|)
condition|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|eId
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|tryNormaliseEdgeMatrix
argument_list|(
name|Graph
operator|::
name|EdgeId
operator|&
name|eId
argument_list|)
block|{
specifier|const
name|PBQPNum
name|infinity
init|=
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
decl_stmt|;
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|Vector
modifier|&
name|uCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|vCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|r
control|)
block|{
name|PBQPNum
name|rowMin
init|=
name|infinity
decl_stmt|;
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|edgeCosts
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|vCosts
index|[
name|c
index|]
operator|!=
name|infinity
operator|&&
name|edgeCosts
index|[
name|r
index|]
index|[
name|c
index|]
operator|<
name|rowMin
condition|)
name|rowMin
operator|=
name|edgeCosts
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
block|}
name|uCosts
index|[
name|r
index|]
operator|+=
name|rowMin
expr_stmt|;
if|if
condition|(
name|rowMin
operator|!=
name|infinity
condition|)
block|{
name|edgeCosts
operator|.
name|subFromRow
argument_list|(
name|r
argument_list|,
name|rowMin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edgeCosts
operator|.
name|setRow
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|edgeCosts
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
name|PBQPNum
name|colMin
init|=
name|infinity
decl_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|uCosts
index|[
name|r
index|]
operator|!=
name|infinity
operator|&&
name|edgeCosts
index|[
name|r
index|]
index|[
name|c
index|]
operator|<
name|colMin
condition|)
name|colMin
operator|=
name|edgeCosts
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
block|}
name|vCosts
index|[
name|c
index|]
operator|+=
name|colMin
expr_stmt|;
if|if
condition|(
name|colMin
operator|!=
name|infinity
condition|)
block|{
name|edgeCosts
operator|.
name|subFromCol
argument_list|(
name|c
argument_list|,
name|colMin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edgeCosts
operator|.
name|setCol
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|edgeCosts
operator|.
name|isZero
argument_list|()
return|;
block|}
name|void
name|backpropagate
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|computeSolution
argument_list|(
name|stack
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|computeSolution
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|getSolverNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
name|Vector
name|v
argument_list|(
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
argument_list|)
decl_stmt|;
comment|// Solve based on existing solved edges.
for|for
control|(
name|SolverEdgeItr
name|solvedEdgeItr
init|=
name|nodeData
operator|.
name|solverEdgesBegin
argument_list|()
init|,
name|solvedEdgeEnd
init|=
name|nodeData
operator|.
name|solverEdgesEnd
argument_list|()
init|;
name|solvedEdgeItr
operator|!=
name|solvedEdgeEnd
condition|;
operator|++
name|solvedEdgeItr
control|)
block|{
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|(
operator|*
name|solvedEdgeItr
argument_list|)
expr_stmt|;
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
decl_stmt|;
if|if
condition|(
name|nId
operator|==
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
condition|)
block|{
name|Graph
operator|::
name|NodeId
name|adjNode
argument_list|(
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|adjSolution
init|=
name|s
operator|.
name|getSelection
argument_list|(
name|adjNode
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getColAsVector
argument_list|(
name|adjSolution
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Graph
operator|::
name|NodeId
name|adjNode
argument_list|(
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|adjSolution
init|=
name|s
operator|.
name|getSelection
argument_list|(
name|adjNode
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|adjSolution
argument_list|)
expr_stmt|;
block|}
block|}
name|setSolution
argument_list|(
name|nId
argument_list|,
name|v
operator|.
name|minIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|cleanup
parameter_list|()
block|{
name|h
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|nodeDataList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|edgeDataList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief PBQP heuristic solver class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Given a PBQP Graph g representing a PBQP problem, you can find a solution
end_comment

begin_comment
comment|/// by calling
end_comment

begin_comment
comment|///<tt>Solution s = HeuristicSolver<H>::solve(g);</tt>
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The choice of heuristic for the H parameter will affect both the solver
end_comment

begin_comment
comment|/// speed and solution quality. The heuristic should be chosen based on the
end_comment

begin_comment
comment|/// nature of the problem being solved.
end_comment

begin_comment
comment|/// Currently the only solver included with LLVM is the Briggs heuristic for
end_comment

begin_comment
comment|/// register allocation.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|HImpl
operator|>
name|class
name|HeuristicSolver
block|{
name|public
operator|:
specifier|static
name|Solution
name|solve
argument_list|(
argument|Graph&g
argument_list|)
block|{
name|HeuristicSolverImpl
operator|<
name|HImpl
operator|>
name|hs
argument_list|(
name|g
argument_list|)
block|;
return|return
name|hs
operator|.
name|computeSolution
argument_list|()
return|;
block|}
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_comment

end_unit

