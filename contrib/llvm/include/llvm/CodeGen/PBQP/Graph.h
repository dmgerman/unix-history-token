begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-------------------- Graph.h - PBQP Graph ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// PBQP Graph class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_GRAPH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_GRAPH_H
end_define

begin_include
include|#
directive|include
file|"Math.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist_node.h"
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|/// PBQP Graph class.
comment|/// Instances of this class describe PBQP problems.
name|class
name|Graph
block|{
name|public
label|:
typedef|typedef
name|unsigned
name|NodeId
typedef|;
typedef|typedef
name|unsigned
name|EdgeId
typedef|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|set
operator|<
name|NodeId
operator|>
name|AdjEdgeList
expr_stmt|;
name|public
label|:
typedef|typedef
name|AdjEdgeList
operator|::
name|iterator
name|AdjEdgeItr
expr_stmt|;
name|private
label|:
name|class
name|NodeEntry
block|{
name|private
label|:
name|Vector
name|costs
decl_stmt|;
name|AdjEdgeList
name|adjEdges
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|NodeEntry
argument_list|()
operator|:
name|costs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{}
name|public
operator|:
name|NodeEntry
argument_list|(
specifier|const
name|Vector
operator|&
name|costs
argument_list|)
operator|:
name|costs
argument_list|(
name|costs
argument_list|)
operator|,
name|data
argument_list|(
literal|0
argument_list|)
block|{}
name|Vector
operator|&
name|getCosts
argument_list|()
block|{
return|return
name|costs
return|;
block|}
specifier|const
name|Vector
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
name|unsigned
name|getDegree
argument_list|()
specifier|const
block|{
return|return
name|adjEdges
operator|.
name|size
argument_list|()
return|;
block|}
name|AdjEdgeItr
name|edgesBegin
parameter_list|()
block|{
return|return
name|adjEdges
operator|.
name|begin
argument_list|()
return|;
block|}
name|AdjEdgeItr
name|edgesEnd
parameter_list|()
block|{
return|return
name|adjEdges
operator|.
name|end
argument_list|()
return|;
block|}
name|AdjEdgeItr
name|addEdge
parameter_list|(
name|EdgeId
name|e
parameter_list|)
block|{
return|return
name|adjEdges
operator|.
name|insert
argument_list|(
name|adjEdges
operator|.
name|end
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
name|void
name|removeEdge
parameter_list|(
name|AdjEdgeItr
name|ae
parameter_list|)
block|{
name|adjEdges
operator|.
name|erase
argument_list|(
name|ae
argument_list|)
expr_stmt|;
block|}
name|void
name|setData
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|this
operator|->
name|data
operator|=
name|data
expr_stmt|;
block|}
name|void
modifier|*
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
block|}
empty_stmt|;
name|class
name|EdgeEntry
block|{
name|private
label|:
name|NodeId
name|node1
decl_stmt|,
name|node2
decl_stmt|;
name|Matrix
name|costs
decl_stmt|;
name|AdjEdgeItr
name|node1AEItr
decl_stmt|,
name|node2AEItr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|EdgeEntry
argument_list|()
operator|:
name|costs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|,
name|data
argument_list|(
literal|0
argument_list|)
block|{}
name|public
operator|:
name|EdgeEntry
argument_list|(
argument|NodeId node1
argument_list|,
argument|NodeId node2
argument_list|,
argument|const Matrix&costs
argument_list|)
operator|:
name|node1
argument_list|(
name|node1
argument_list|)
operator|,
name|node2
argument_list|(
name|node2
argument_list|)
operator|,
name|costs
argument_list|(
argument|costs
argument_list|)
block|{}
name|NodeId
name|getNode1
argument_list|()
specifier|const
block|{
return|return
name|node1
return|;
block|}
name|NodeId
name|getNode2
argument_list|()
specifier|const
block|{
return|return
name|node2
return|;
block|}
name|Matrix
modifier|&
name|getCosts
parameter_list|()
block|{
return|return
name|costs
return|;
block|}
specifier|const
name|Matrix
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
name|void
name|setNode1AEItr
parameter_list|(
name|AdjEdgeItr
name|ae
parameter_list|)
block|{
name|node1AEItr
operator|=
name|ae
expr_stmt|;
block|}
name|AdjEdgeItr
name|getNode1AEItr
parameter_list|()
block|{
return|return
name|node1AEItr
return|;
block|}
name|void
name|setNode2AEItr
parameter_list|(
name|AdjEdgeItr
name|ae
parameter_list|)
block|{
name|node2AEItr
operator|=
name|ae
expr_stmt|;
block|}
name|AdjEdgeItr
name|getNode2AEItr
parameter_list|()
block|{
return|return
name|node2AEItr
return|;
block|}
name|void
name|setData
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|this
operator|->
name|data
operator|=
name|data
expr_stmt|;
block|}
name|void
modifier|*
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
block|}
empty_stmt|;
comment|// ----- MEMBERS -----
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|NodeEntry
operator|>
name|NodeVector
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|NodeId
operator|>
name|FreeNodeVector
expr_stmt|;
name|NodeVector
name|nodes
decl_stmt|;
name|FreeNodeVector
name|freeNodes
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|EdgeEntry
operator|>
name|EdgeVector
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|EdgeId
operator|>
name|FreeEdgeVector
expr_stmt|;
name|EdgeVector
name|edges
decl_stmt|;
name|FreeEdgeVector
name|freeEdges
decl_stmt|;
comment|// ----- INTERNAL METHODS -----
name|NodeEntry
modifier|&
name|getNode
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|nodes
index|[
name|nId
index|]
return|;
block|}
specifier|const
name|NodeEntry
modifier|&
name|getNode
argument_list|(
name|NodeId
name|nId
argument_list|)
decl|const
block|{
return|return
name|nodes
index|[
name|nId
index|]
return|;
block|}
name|EdgeEntry
modifier|&
name|getEdge
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
return|return
name|edges
index|[
name|eId
index|]
return|;
block|}
specifier|const
name|EdgeEntry
modifier|&
name|getEdge
argument_list|(
name|EdgeId
name|eId
argument_list|)
decl|const
block|{
return|return
name|edges
index|[
name|eId
index|]
return|;
block|}
name|NodeId
name|addConstructedNode
parameter_list|(
specifier|const
name|NodeEntry
modifier|&
name|n
parameter_list|)
block|{
name|NodeId
name|nodeId
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|freeNodes
operator|.
name|empty
argument_list|()
condition|)
block|{
name|nodeId
operator|=
name|freeNodes
operator|.
name|back
argument_list|()
expr_stmt|;
name|freeNodes
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|nodes
index|[
name|nodeId
index|]
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|nodeId
operator|=
name|nodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|push_back
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeId
return|;
block|}
name|EdgeId
name|addConstructedEdge
parameter_list|(
specifier|const
name|EdgeEntry
modifier|&
name|e
parameter_list|)
block|{
name|assert
argument_list|(
name|findEdge
argument_list|(
name|e
operator|.
name|getNode1
argument_list|()
argument_list|,
name|e
operator|.
name|getNode2
argument_list|()
argument_list|)
operator|==
name|invalidEdgeId
argument_list|()
operator|&&
literal|"Attempt to add duplicate edge."
argument_list|)
expr_stmt|;
name|EdgeId
name|edgeId
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|freeEdges
operator|.
name|empty
argument_list|()
condition|)
block|{
name|edgeId
operator|=
name|freeEdges
operator|.
name|back
argument_list|()
expr_stmt|;
name|freeEdges
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|edges
index|[
name|edgeId
index|]
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|edgeId
operator|=
name|edges
operator|.
name|size
argument_list|()
expr_stmt|;
name|edges
operator|.
name|push_back
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|EdgeEntry
modifier|&
name|ne
init|=
name|getEdge
argument_list|(
name|edgeId
argument_list|)
decl_stmt|;
name|NodeEntry
modifier|&
name|n1
init|=
name|getNode
argument_list|(
name|ne
operator|.
name|getNode1
argument_list|()
argument_list|)
decl_stmt|;
name|NodeEntry
modifier|&
name|n2
init|=
name|getNode
argument_list|(
name|ne
operator|.
name|getNode2
argument_list|()
argument_list|)
decl_stmt|;
comment|// Sanity check on matrix dimensions:
name|assert
argument_list|(
operator|(
name|n1
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|ne
operator|.
name|getCosts
argument_list|()
operator|.
name|getRows
argument_list|()
operator|)
operator|&&
operator|(
name|n2
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|ne
operator|.
name|getCosts
argument_list|()
operator|.
name|getCols
argument_list|()
operator|)
operator|&&
literal|"Edge cost dimensions do not match node costs dimensions."
argument_list|)
expr_stmt|;
name|ne
operator|.
name|setNode1AEItr
argument_list|(
name|n1
operator|.
name|addEdge
argument_list|(
name|edgeId
argument_list|)
argument_list|)
expr_stmt|;
name|ne
operator|.
name|setNode2AEItr
argument_list|(
name|n2
operator|.
name|addEdge
argument_list|(
name|edgeId
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|edgeId
return|;
block|}
name|Graph
argument_list|(
argument|const Graph&other
argument_list|)
block|{}
name|void
name|operator
init|=
operator|(
specifier|const
name|Graph
operator|&
name|other
operator|)
block|{}
name|public
operator|:
name|class
name|NodeItr
block|{
name|public
operator|:
name|NodeItr
argument_list|(
argument|NodeId nodeId
argument_list|,
argument|const Graph&g
argument_list|)
operator|:
name|nodeId
argument_list|(
name|nodeId
argument_list|)
block|,
name|endNodeId
argument_list|(
name|g
operator|.
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
block|,
name|freeNodes
argument_list|(
argument|g.freeNodes
argument_list|)
block|{
name|this
operator|->
name|nodeId
operator|=
name|findNextInUse
argument_list|(
name|nodeId
argument_list|)
block|;
comment|// Move to the first in-use nodeId
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|NodeItr
operator|&
name|n
operator|)
specifier|const
block|{
return|return
name|nodeId
operator|==
name|n
operator|.
name|nodeId
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|NodeItr
operator|&
name|n
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|n
operator|)
return|;
block|}
name|NodeItr
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|nodeId
operator|=
name|findNextInUse
argument_list|(
operator|++
name|nodeId
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|NodeId
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|nodeId
return|;
block|}
name|private
operator|:
name|NodeId
name|findNextInUse
argument_list|(
argument|NodeId n
argument_list|)
specifier|const
block|{
while|while
condition|(
name|n
operator|<
name|endNodeId
operator|&&
name|std
operator|::
name|find
argument_list|(
name|freeNodes
operator|.
name|begin
argument_list|()
argument_list|,
name|freeNodes
operator|.
name|end
argument_list|()
argument_list|,
name|n
argument_list|)
operator|!=
name|freeNodes
operator|.
name|end
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
name|NodeId
name|nodeId
block|,
name|endNodeId
block|;
specifier|const
name|FreeNodeVector
operator|&
name|freeNodes
block|;     }
decl_stmt|;
name|class
name|EdgeItr
block|{
name|public
label|:
name|EdgeItr
argument_list|(
argument|EdgeId edgeId
argument_list|,
argument|const Graph&g
argument_list|)
block|:
name|edgeId
argument_list|(
name|edgeId
argument_list|)
operator|,
name|endEdgeId
argument_list|(
name|g
operator|.
name|edges
operator|.
name|size
argument_list|()
argument_list|)
operator|,
name|freeEdges
argument_list|(
argument|g.freeEdges
argument_list|)
block|{
name|this
operator|->
name|edgeId
operator|=
name|findNextInUse
argument_list|(
name|edgeId
argument_list|)
block|;
comment|// Move to the first in-use edgeId
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|EdgeItr
operator|&
name|n
operator|)
specifier|const
block|{
return|return
name|edgeId
operator|==
name|n
operator|.
name|edgeId
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|EdgeItr
operator|&
name|n
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|n
operator|)
return|;
block|}
name|EdgeItr
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|edgeId
operator|=
name|findNextInUse
argument_list|(
operator|++
name|edgeId
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|EdgeId
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|edgeId
return|;
block|}
name|private
label|:
name|EdgeId
name|findNextInUse
argument_list|(
name|EdgeId
name|n
argument_list|)
decl|const
block|{
while|while
condition|(
name|n
operator|<
name|endEdgeId
operator|&&
name|std
operator|::
name|find
argument_list|(
name|freeEdges
operator|.
name|begin
argument_list|()
argument_list|,
name|freeEdges
operator|.
name|end
argument_list|()
argument_list|,
name|n
argument_list|)
operator|!=
name|freeEdges
operator|.
name|end
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
name|EdgeId
name|edgeId
decl_stmt|,
name|endEdgeId
decl_stmt|;
specifier|const
name|FreeEdgeVector
modifier|&
name|freeEdges
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief Construct an empty PBQP graph.
name|Graph
argument_list|()
block|{}
comment|/// \brief Add a node with the given costs.
comment|/// @param costs Cost vector for the new node.
comment|/// @return Node iterator for the added node.
name|NodeId
name|addNode
parameter_list|(
specifier|const
name|Vector
modifier|&
name|costs
parameter_list|)
block|{
return|return
name|addConstructedNode
argument_list|(
name|NodeEntry
argument_list|(
name|costs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Add an edge between the given nodes with the given costs.
comment|/// @param n1Id First node.
comment|/// @param n2Id Second node.
comment|/// @return Edge iterator for the added edge.
name|EdgeId
name|addEdge
parameter_list|(
name|NodeId
name|n1Id
parameter_list|,
name|NodeId
name|n2Id
parameter_list|,
specifier|const
name|Matrix
modifier|&
name|costs
parameter_list|)
block|{
name|assert
argument_list|(
name|getNodeCosts
argument_list|(
name|n1Id
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
name|costs
operator|.
name|getRows
argument_list|()
operator|&&
name|getNodeCosts
argument_list|(
name|n2Id
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
name|costs
operator|.
name|getCols
argument_list|()
operator|&&
literal|"Matrix dimensions mismatch."
argument_list|)
expr_stmt|;
return|return
name|addConstructedEdge
argument_list|(
name|EdgeEntry
argument_list|(
name|n1Id
argument_list|,
name|n2Id
argument_list|,
name|costs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Get the number of nodes in the graph.
comment|/// @return Number of nodes in the graph.
name|unsigned
name|getNumNodes
argument_list|()
specifier|const
block|{
return|return
name|nodes
operator|.
name|size
argument_list|()
operator|-
name|freeNodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// \brief Get the number of edges in the graph.
comment|/// @return Number of edges in the graph.
name|unsigned
name|getNumEdges
argument_list|()
specifier|const
block|{
return|return
name|edges
operator|.
name|size
argument_list|()
operator|-
name|freeEdges
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// \brief Get a node's cost vector.
comment|/// @param nId Node id.
comment|/// @return Node cost vector.
name|Vector
modifier|&
name|getNodeCosts
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Get a node's cost vector (const version).
comment|/// @param nId Node id.
comment|/// @return Node cost vector.
specifier|const
name|Vector
modifier|&
name|getNodeCosts
argument_list|(
name|NodeId
name|nId
argument_list|)
decl|const
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Set a node's data pointer.
comment|/// @param nId Node id.
comment|/// @param data Pointer to node data.
comment|///
comment|/// Typically used by a PBQP solver to attach data to aid in solution.
name|void
name|setNodeData
parameter_list|(
name|NodeId
name|nId
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Get the node's data pointer.
comment|/// @param nId Node id.
comment|/// @return Pointer to node data.
name|void
modifier|*
name|getNodeData
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|getData
argument_list|()
return|;
block|}
comment|/// \brief Get an edge's cost matrix.
comment|/// @param eId Edge id.
comment|/// @return Edge cost matrix.
name|Matrix
modifier|&
name|getEdgeCosts
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Get an edge's cost matrix (const version).
comment|/// @param eId Edge id.
comment|/// @return Edge cost matrix.
specifier|const
name|Matrix
modifier|&
name|getEdgeCosts
argument_list|(
name|EdgeId
name|eId
argument_list|)
decl|const
block|{
return|return
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
comment|/// \brief Set an edge's data pointer.
comment|/// @param eId Edge id.
comment|/// @param data Pointer to edge data.
comment|///
comment|/// Typically used by a PBQP solver to attach data to aid in solution.
name|void
name|setEdgeData
parameter_list|(
name|EdgeId
name|eId
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Get an edge's data pointer.
comment|/// @param eId Edge id.
comment|/// @return Pointer to edge data.
name|void
modifier|*
name|getEdgeData
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|getData
argument_list|()
return|;
block|}
comment|/// \brief Get a node's degree.
comment|/// @param nId Node id.
comment|/// @return The degree of the node.
name|unsigned
name|getNodeDegree
argument_list|(
name|NodeId
name|nId
argument_list|)
decl|const
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|getDegree
argument_list|()
return|;
block|}
comment|/// \brief Begin iterator for node set.
name|NodeItr
name|nodesBegin
argument_list|()
specifier|const
block|{
return|return
name|NodeItr
argument_list|(
literal|0
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief End iterator for node set.
name|NodeItr
name|nodesEnd
argument_list|()
specifier|const
block|{
return|return
name|NodeItr
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief Begin iterator for edge set.
name|EdgeItr
name|edgesBegin
argument_list|()
specifier|const
block|{
return|return
name|EdgeItr
argument_list|(
literal|0
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief End iterator for edge set.
name|EdgeItr
name|edgesEnd
argument_list|()
specifier|const
block|{
return|return
name|EdgeItr
argument_list|(
name|edges
operator|.
name|size
argument_list|()
argument_list|,
operator|*
name|this
argument_list|)
return|;
block|}
comment|/// \brief Get begin iterator for adjacent edge set.
comment|/// @param nId Node id.
comment|/// @return Begin iterator for the set of edges connected to the given node.
name|AdjEdgeItr
name|adjEdgesBegin
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|edgesBegin
argument_list|()
return|;
block|}
comment|/// \brief Get end iterator for adjacent edge set.
comment|/// @param nId Node id.
comment|/// @return End iterator for the set of edges connected to the given node.
name|AdjEdgeItr
name|adjEdgesEnd
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|nId
argument_list|)
operator|.
name|edgesEnd
argument_list|()
return|;
block|}
comment|/// \brief Get the first node connected to this edge.
comment|/// @param eId Edge id.
comment|/// @return The first node connected to the given edge.
name|NodeId
name|getEdgeNode1
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|getNode1
argument_list|()
return|;
block|}
comment|/// \brief Get the second node connected to this edge.
comment|/// @param eId Edge id.
comment|/// @return The second node connected to the given edge.
name|NodeId
name|getEdgeNode2
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
return|return
name|getEdge
argument_list|(
name|eId
argument_list|)
operator|.
name|getNode2
argument_list|()
return|;
block|}
comment|/// \brief Get the "other" node connected to this edge.
comment|/// @param eId Edge id.
comment|/// @param nId Node id for the "given" node.
comment|/// @return The iterator for the "other" node connected to this edge.
name|NodeId
name|getEdgeOtherNode
parameter_list|(
name|EdgeId
name|eId
parameter_list|,
name|NodeId
name|nId
parameter_list|)
block|{
name|EdgeEntry
modifier|&
name|e
init|=
name|getEdge
argument_list|(
name|eId
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getNode1
argument_list|()
operator|==
name|nId
condition|)
block|{
return|return
name|e
operator|.
name|getNode2
argument_list|()
return|;
block|}
comment|// else
return|return
name|e
operator|.
name|getNode1
argument_list|()
return|;
block|}
name|EdgeId
name|invalidEdgeId
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|numeric_limits
operator|<
name|EdgeId
operator|>
operator|::
name|max
argument_list|()
return|;
block|}
comment|/// \brief Get the edge connecting two nodes.
comment|/// @param n1Id First node id.
comment|/// @param n2Id Second node id.
comment|/// @return An id for edge (n1Id, n2Id) if such an edge exists,
comment|///         otherwise returns an invalid edge id.
name|EdgeId
name|findEdge
parameter_list|(
name|NodeId
name|n1Id
parameter_list|,
name|NodeId
name|n2Id
parameter_list|)
block|{
for|for
control|(
name|AdjEdgeItr
name|aeItr
init|=
name|adjEdgesBegin
argument_list|(
name|n1Id
argument_list|)
init|,
name|aeEnd
init|=
name|adjEdgesEnd
argument_list|(
name|n1Id
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
if|if
condition|(
operator|(
name|getEdgeNode1
argument_list|(
operator|*
name|aeItr
argument_list|)
operator|==
name|n2Id
operator|)
operator|||
operator|(
name|getEdgeNode2
argument_list|(
operator|*
name|aeItr
argument_list|)
operator|==
name|n2Id
operator|)
condition|)
block|{
return|return
operator|*
name|aeItr
return|;
block|}
block|}
return|return
name|invalidEdgeId
argument_list|()
return|;
block|}
comment|/// \brief Remove a node from the graph.
comment|/// @param nId Node id.
name|void
name|removeNode
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
name|NodeEntry
modifier|&
name|n
init|=
name|getNode
argument_list|(
name|nId
argument_list|)
decl_stmt|;
for|for
control|(
name|AdjEdgeItr
name|itr
init|=
name|n
operator|.
name|edgesBegin
argument_list|()
init|,
name|end
init|=
name|n
operator|.
name|edgesEnd
argument_list|()
init|;
name|itr
operator|!=
name|end
condition|;
operator|++
name|itr
control|)
block|{
name|EdgeId
name|eId
init|=
operator|*
name|itr
decl_stmt|;
name|removeEdge
argument_list|(
name|eId
argument_list|)
expr_stmt|;
block|}
name|freeNodes
operator|.
name|push_back
argument_list|(
name|nId
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Remove an edge from the graph.
comment|/// @param eId Edge id.
name|void
name|removeEdge
parameter_list|(
name|EdgeId
name|eId
parameter_list|)
block|{
name|EdgeEntry
modifier|&
name|e
init|=
name|getEdge
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|NodeEntry
modifier|&
name|n1
init|=
name|getNode
argument_list|(
name|e
operator|.
name|getNode1
argument_list|()
argument_list|)
decl_stmt|;
name|NodeEntry
modifier|&
name|n2
init|=
name|getNode
argument_list|(
name|e
operator|.
name|getNode2
argument_list|()
argument_list|)
decl_stmt|;
name|n1
operator|.
name|removeEdge
argument_list|(
name|e
operator|.
name|getNode1AEItr
argument_list|()
argument_list|)
expr_stmt|;
name|n2
operator|.
name|removeEdge
argument_list|(
name|e
operator|.
name|getNode2AEItr
argument_list|()
argument_list|)
expr_stmt|;
name|freeEdges
operator|.
name|push_back
argument_list|(
name|eId
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Remove all nodes and edges from the graph.
name|void
name|clear
parameter_list|()
block|{
name|nodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|freeNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|edges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|freeEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// \brief Dump a graph to an output stream.
name|template
operator|<
name|typename
name|OStream
operator|>
name|void
name|dump
argument_list|(
argument|OStream&os
argument_list|)
block|{
name|os
operator|<<
name|getNumNodes
argument_list|()
operator|<<
literal|" "
operator|<<
name|getNumEdges
argument_list|()
operator|<<
literal|"\n"
block|;
for|for
control|(
name|NodeItr
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
specifier|const
name|Vector
modifier|&
name|v
init|=
name|getNodeCosts
argument_list|(
operator|*
name|nodeItr
argument_list|)
decl_stmt|;
name|os
operator|<<
literal|"\n"
operator|<<
name|v
operator|.
name|getLength
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
name|assert
argument_list|(
name|v
operator|.
name|getLength
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Empty vector in graph."
argument_list|)
expr_stmt|;
name|os
operator|<<
name|v
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|v
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
literal|" "
operator|<<
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
name|os
operator|<<
literal|"\n"
expr_stmt|;
block|}
for|for
control|(
name|EdgeItr
name|edgeItr
init|=
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|NodeId
name|n1
init|=
name|getEdgeNode1
argument_list|(
operator|*
name|edgeItr
argument_list|)
decl_stmt|;
name|NodeId
name|n2
init|=
name|getEdgeNode2
argument_list|(
operator|*
name|edgeItr
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n1
operator|!=
name|n2
operator|&&
literal|"PBQP graphs shound not have self-edges."
argument_list|)
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|m
init|=
name|getEdgeCosts
argument_list|(
operator|*
name|edgeItr
argument_list|)
decl_stmt|;
name|os
operator|<<
literal|"\n"
operator|<<
name|n1
operator|<<
literal|" "
operator|<<
name|n2
operator|<<
literal|"\n"
operator|<<
name|m
operator|.
name|getRows
argument_list|()
operator|<<
literal|" "
operator|<<
name|m
operator|.
name|getCols
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
name|assert
argument_list|(
name|m
operator|.
name|getRows
argument_list|()
operator|!=
literal|0
operator|&&
literal|"No rows in matrix."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|.
name|getCols
argument_list|()
operator|!=
literal|0
operator|&&
literal|"No cols in matrix."
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
name|m
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|m
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|os
operator|<<
literal|" "
operator|<<
name|m
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|os
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
block|}
comment|/// \brief Print a representation of this graph in DOT format.
comment|/// @param os Output stream to print on.
name|template
operator|<
name|typename
name|OStream
operator|>
name|void
name|printDot
argument_list|(
argument|OStream&os
argument_list|)
block|{
name|os
operator|<<
literal|"graph {\n"
block|;
for|for
control|(
name|NodeItr
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|nodeItr
operator|<<
literal|" [ label=\""
operator|<<
name|nodeItr
operator|<<
literal|": "
operator|<<
name|getNodeCosts
argument_list|(
operator|*
name|nodeItr
argument_list|)
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"  edge [ len="
operator|<<
name|getNumNodes
argument_list|()
operator|<<
literal|" ]\n"
expr_stmt|;
for|for
control|(
name|EdgeItr
name|edgeItr
init|=
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|getEdgeNode1
argument_list|(
operator|*
name|edgeItr
argument_list|)
operator|<<
literal|" -- node"
operator|<<
name|getEdgeNode2
argument_list|(
operator|*
name|edgeItr
argument_list|)
operator|<<
literal|" [ label=\""
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|getEdgeCosts
argument_list|(
operator|*
name|edgeItr
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|i
argument_list|)
operator|<<
literal|"\\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"}\n"
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//  void Graph::copyFrom(const Graph&other) {
end_comment

begin_comment
comment|//     std::map<Graph::ConstNodeItr, Graph::NodeItr,
end_comment

begin_comment
comment|//              NodeItrComparator> nodeMap;
end_comment

begin_comment
comment|//      for (Graph::ConstNodeItr nItr = other.nodesBegin(),
end_comment

begin_comment
comment|//                              nEnd = other.nodesEnd();
end_comment

begin_comment
comment|//          nItr != nEnd; ++nItr) {
end_comment

begin_comment
comment|//       nodeMap[nItr] = addNode(other.getNodeCosts(nItr));
end_comment

begin_comment
comment|//     }
end_comment

begin_comment
comment|//  }
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_GRAPH_HPP
end_comment

end_unit

