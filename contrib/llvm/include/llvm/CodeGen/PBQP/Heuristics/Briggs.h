begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Briggs.h --- Briggs Heuristic for PBQP ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements the Briggs test for "allocability" of nodes in a
end_comment

begin_comment
comment|// PBQP graph representing a register allocation problem. Nodes which can be
end_comment

begin_comment
comment|// proven allocable (by a safe and relatively accurate test) are removed from
end_comment

begin_comment
comment|// the PBQP graph first. If no provably allocable node is present in the graph
end_comment

begin_comment
comment|// then the node with the minimal spill-cost to degree ratio is removed.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_define

begin_include
include|#
directive|include
file|"../HeuristicBase.h"
end_include

begin_include
include|#
directive|include
file|"../HeuristicSolver.h"
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
name|namespace
name|Heuristics
block|{
comment|/// \brief PBQP Heuristic which applies an allocability test based on
comment|///        Briggs.
comment|///
comment|/// This heuristic assumes that the elements of cost vectors in the PBQP
comment|/// problem represent storage options, with the first being the spill
comment|/// option and subsequent elements representing legal registers for the
comment|/// corresponding node. Edge cost matrices are likewise assumed to represent
comment|/// register constraints.
comment|/// If one or more nodes can be proven allocable by this heuristic (by
comment|/// inspection of their constraint matrices) then the allocable node of
comment|/// highest degree is selected for the next reduction and pushed to the
comment|/// solver stack. If no nodes can be proven allocable then the node with
comment|/// the lowest estimated spill cost is selected and push to the solver stack
comment|/// instead.
comment|///
comment|/// This implementation is built on top of HeuristicBase.
name|class
name|Briggs
range|:
name|public
name|HeuristicBase
operator|<
name|Briggs
operator|>
block|{
name|private
operator|:
name|class
name|LinkDegreeComparator
block|{
name|public
operator|:
name|LinkDegreeComparator
argument_list|(
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|&
name|s
argument_list|)
operator|:
name|s
argument_list|(
argument|&s
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|NodeId
name|n1Id
expr|,
name|Graph
operator|::
name|NodeId
name|n2Id
operator|)
specifier|const
block|{
if|if
condition|(
name|s
operator|->
name|getSolverDegree
argument_list|(
name|n1Id
argument_list|)
operator|>
name|s
operator|->
name|getSolverDegree
argument_list|(
name|n2Id
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|private
operator|:
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|*
name|s
block|;       }
decl_stmt|;
name|class
name|SpillCostComparator
block|{
name|public
label|:
name|SpillCostComparator
argument_list|(
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|&
name|s
argument_list|)
operator|:
name|s
argument_list|(
operator|&
name|s
argument_list|)
operator|,
name|g
argument_list|(
argument|&s.getGraph()
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
name|Graph
operator|::
name|NodeId
name|n1Id
operator|,
name|Graph
operator|::
name|NodeId
name|n2Id
operator|)
specifier|const
block|{
specifier|const
name|PBQP
operator|::
name|Vector
operator|&
name|cv1
operator|=
name|g
operator|->
name|getNodeCosts
argument_list|(
name|n1Id
argument_list|)
block|;
specifier|const
name|PBQP
operator|::
name|Vector
operator|&
name|cv2
operator|=
name|g
operator|->
name|getNodeCosts
argument_list|(
name|n2Id
argument_list|)
block|;
name|PBQPNum
name|cost1
operator|=
name|cv1
index|[
literal|0
index|]
operator|/
name|s
operator|->
name|getSolverDegree
argument_list|(
name|n1Id
argument_list|)
block|;
name|PBQPNum
name|cost2
operator|=
name|cv2
index|[
literal|0
index|]
operator|/
name|s
operator|->
name|getSolverDegree
argument_list|(
name|n2Id
argument_list|)
block|;
if|if
condition|(
name|cost1
operator|<
name|cost2
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|private
label|:
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|*
name|s
expr_stmt|;
name|Graph
modifier|*
name|g
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|Graph
operator|::
name|NodeId
operator|>
name|RNAllocableList
expr_stmt|;
typedef|typedef
name|RNAllocableList
operator|::
name|iterator
name|RNAllocableListItr
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|Graph
operator|::
name|NodeId
operator|>
name|RNUnallocableList
expr_stmt|;
typedef|typedef
name|RNUnallocableList
operator|::
name|iterator
name|RNUnallocableListItr
expr_stmt|;
name|public
label|:
struct|struct
name|NodeData
block|{
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|UnsafeDegreesArray
expr_stmt|;
name|bool
name|isHeuristic
decl_stmt|,
name|isAllocable
decl_stmt|,
name|isInitialized
decl_stmt|;
name|unsigned
name|numDenied
decl_stmt|,
name|numSafe
decl_stmt|;
name|UnsafeDegreesArray
name|unsafeDegrees
decl_stmt|;
name|RNAllocableListItr
name|rnaItr
decl_stmt|;
name|RNUnallocableListItr
name|rnuItr
decl_stmt|;
name|NodeData
argument_list|()
operator|:
name|isHeuristic
argument_list|(
name|false
argument_list|)
operator|,
name|isAllocable
argument_list|(
name|false
argument_list|)
operator|,
name|isInitialized
argument_list|(
name|false
argument_list|)
operator|,
name|numDenied
argument_list|(
literal|0
argument_list|)
operator|,
name|numSafe
argument_list|(
literal|0
argument_list|)
block|{ }
block|}
struct|;
struct|struct
name|EdgeData
block|{
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|UnsafeArray
expr_stmt|;
name|unsigned
name|worst
decl_stmt|,
name|reverseWorst
decl_stmt|;
name|UnsafeArray
name|unsafe
decl_stmt|,
name|reverseUnsafe
decl_stmt|;
name|bool
name|isUpToDate
decl_stmt|;
name|EdgeData
argument_list|()
operator|:
name|worst
argument_list|(
literal|0
argument_list|)
operator|,
name|reverseWorst
argument_list|(
literal|0
argument_list|)
operator|,
name|isUpToDate
argument_list|(
argument|false
argument_list|)
block|{}
block|}
struct|;
comment|/// \brief Construct an instance of the Briggs heuristic.
comment|/// @param solver A reference to the solver which is using this heuristic.
name|Briggs
argument_list|(
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|&
name|solver
argument_list|)
operator|:
name|HeuristicBase
operator|<
name|Briggs
operator|>
operator|(
name|solver
operator|)
block|{}
comment|/// \brief Determine whether a node should be reduced using optimal
comment|///        reduction.
comment|/// @param nId Node id to be considered.
comment|/// @return True if the given node should be optimally reduced, false
comment|///         otherwise.
comment|///
comment|/// Selects nodes of degree 0, 1 or 2 for optimal reduction, with one
comment|/// exception. Nodes whose spill cost (element 0 of their cost vector) is
comment|/// infinite are checked for allocability first. Allocable nodes may be
comment|/// optimally reduced, but nodes whose allocability cannot be proven are
comment|/// selected for heuristic reduction instead.
name|bool
name|shouldOptimallyReduce
argument_list|(
argument|Graph::NodeId nId
argument_list|)
block|{
if|if
condition|(
name|getSolver
argument_list|()
operator|.
name|getSolverDegree
argument_list|(
name|nId
argument_list|)
operator|<
literal|3
condition|)
block|{
return|return
name|true
return|;
block|}
comment|// else
return|return
name|false
return|;
block|}
comment|/// \brief Add a node to the heuristic reduce list.
comment|/// @param nId Node id to add to the heuristic reduce list.
name|void
name|addToHeuristicReduceList
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
name|initializeNode
argument_list|(
name|nId
argument_list|)
expr_stmt|;
name|nd
operator|.
name|isHeuristic
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|isAllocable
condition|)
block|{
name|nd
operator|.
name|rnaItr
operator|=
name|rnAllocableList
operator|.
name|insert
argument_list|(
name|rnAllocableList
operator|.
name|end
argument_list|()
argument_list|,
name|nId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|.
name|rnuItr
operator|=
name|rnUnallocableList
operator|.
name|insert
argument_list|(
name|rnUnallocableList
operator|.
name|end
argument_list|()
argument_list|,
name|nId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// \brief Heuristically reduce one of the nodes in the heuristic
comment|///        reduce list.
comment|/// @return True if a reduction takes place, false if the heuristic reduce
comment|///         list is empty.
comment|///
comment|/// If the list of allocable nodes is non-empty a node is selected
comment|/// from it and pushed to the stack. Otherwise if the non-allocable list
comment|/// is non-empty a node is selected from it and pushed to the stack.
comment|/// If both lists are empty the method simply returns false with no action
comment|/// taken.
name|bool
name|heuristicReduce
parameter_list|()
block|{
if|if
condition|(
operator|!
name|rnAllocableList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|RNAllocableListItr
name|rnaItr
init|=
name|min_element
argument_list|(
name|rnAllocableList
operator|.
name|begin
argument_list|()
argument_list|,
name|rnAllocableList
operator|.
name|end
argument_list|()
argument_list|,
name|LinkDegreeComparator
argument_list|(
name|getSolver
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Graph
operator|::
name|NodeId
name|nId
operator|=
operator|*
name|rnaItr
expr_stmt|;
name|rnAllocableList
operator|.
name|erase
argument_list|(
name|rnaItr
argument_list|)
expr_stmt|;
name|handleRemoveNode
argument_list|(
name|nId
argument_list|)
expr_stmt|;
name|getSolver
argument_list|()
operator|.
name|pushToStack
argument_list|(
name|nId
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rnUnallocableList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|RNUnallocableListItr
name|rnuItr
init|=
name|min_element
argument_list|(
name|rnUnallocableList
operator|.
name|begin
argument_list|()
argument_list|,
name|rnUnallocableList
operator|.
name|end
argument_list|()
argument_list|,
name|SpillCostComparator
argument_list|(
name|getSolver
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Graph
operator|::
name|NodeId
name|nId
operator|=
operator|*
name|rnuItr
expr_stmt|;
name|rnUnallocableList
operator|.
name|erase
argument_list|(
name|rnuItr
argument_list|)
expr_stmt|;
name|handleRemoveNode
argument_list|(
name|nId
argument_list|)
expr_stmt|;
name|getSolver
argument_list|()
operator|.
name|pushToStack
argument_list|(
name|nId
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// else
return|return
name|false
return|;
block|}
comment|/// \brief Prepare a change in the costs on the given edge.
comment|/// @param eId Edge id.
name|void
name|preUpdateEdgeCosts
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
name|Graph
modifier|&
name|g
init|=
name|getGraph
argument_list|()
decl_stmt|;
name|Graph
operator|::
name|NodeId
name|n1Id
operator|=
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
operator|,
name|n2Id
operator|=
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|NodeData
modifier|&
name|n1
init|=
name|getHeuristicNodeData
argument_list|(
name|n1Id
argument_list|)
decl_stmt|,
modifier|&
name|n2
init|=
name|getHeuristicNodeData
argument_list|(
name|n2Id
argument_list|)
decl_stmt|;
if|if
condition|(
name|n1
operator|.
name|isHeuristic
condition|)
name|subtractEdgeContributions
argument_list|(
name|eId
argument_list|,
name|getGraph
argument_list|()
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2
operator|.
name|isHeuristic
condition|)
name|subtractEdgeContributions
argument_list|(
name|eId
argument_list|,
name|getGraph
argument_list|()
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
argument_list|)
expr_stmt|;
name|EdgeData
modifier|&
name|ed
init|=
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|ed
operator|.
name|isUpToDate
operator|=
name|false
expr_stmt|;
block|}
comment|/// \brief Handle the change in the costs on the given edge.
comment|/// @param eId Edge id.
name|void
name|postUpdateEdgeCosts
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
comment|// This is effectively the same as adding a new edge now, since
comment|// we've factored out the costs of the old one.
name|handleAddEdge
argument_list|(
name|eId
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Handle the addition of a new edge into the PBQP graph.
comment|/// @param eId Edge id for the added edge.
comment|///
comment|/// Updates allocability of any nodes connected by this edge which are
comment|/// being managed by the heuristic. If allocability changes they are
comment|/// moved to the appropriate list.
name|void
name|handleAddEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
name|Graph
modifier|&
name|g
init|=
name|getGraph
argument_list|()
decl_stmt|;
name|Graph
operator|::
name|NodeId
name|n1Id
operator|=
name|g
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
operator|,
name|n2Id
operator|=
name|g
operator|.
name|getEdgeNode2
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|NodeData
modifier|&
name|n1
init|=
name|getHeuristicNodeData
argument_list|(
name|n1Id
argument_list|)
decl_stmt|,
modifier|&
name|n2
init|=
name|getHeuristicNodeData
argument_list|(
name|n2Id
argument_list|)
decl_stmt|;
comment|// If neither node is managed by the heuristic there's nothing to be
comment|// done.
if|if
condition|(
operator|!
name|n1
operator|.
name|isHeuristic
operator|&&
operator|!
name|n2
operator|.
name|isHeuristic
condition|)
return|return;
comment|// Ok - we need to update at least one node.
name|computeEdgeContributions
argument_list|(
name|eId
argument_list|)
expr_stmt|;
comment|// Update node 1 if it's managed by the heuristic.
if|if
condition|(
name|n1
operator|.
name|isHeuristic
condition|)
block|{
name|bool
name|n1WasAllocable
init|=
name|n1
operator|.
name|isAllocable
decl_stmt|;
name|addEdgeContributions
argument_list|(
name|eId
argument_list|,
name|n1Id
argument_list|)
expr_stmt|;
name|updateAllocability
argument_list|(
name|n1Id
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1WasAllocable
operator|&&
operator|!
name|n1
operator|.
name|isAllocable
condition|)
block|{
name|rnAllocableList
operator|.
name|erase
argument_list|(
name|n1
operator|.
name|rnaItr
argument_list|)
expr_stmt|;
name|n1
operator|.
name|rnuItr
operator|=
name|rnUnallocableList
operator|.
name|insert
argument_list|(
name|rnUnallocableList
operator|.
name|end
argument_list|()
argument_list|,
name|n1Id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Likewise for node 2.
if|if
condition|(
name|n2
operator|.
name|isHeuristic
condition|)
block|{
name|bool
name|n2WasAllocable
init|=
name|n2
operator|.
name|isAllocable
decl_stmt|;
name|addEdgeContributions
argument_list|(
name|eId
argument_list|,
name|n2Id
argument_list|)
expr_stmt|;
name|updateAllocability
argument_list|(
name|n2Id
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2WasAllocable
operator|&&
operator|!
name|n2
operator|.
name|isAllocable
condition|)
block|{
name|rnAllocableList
operator|.
name|erase
argument_list|(
name|n2
operator|.
name|rnaItr
argument_list|)
expr_stmt|;
name|n2
operator|.
name|rnuItr
operator|=
name|rnUnallocableList
operator|.
name|insert
argument_list|(
name|rnUnallocableList
operator|.
name|end
argument_list|()
argument_list|,
name|n2Id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/// \brief Handle disconnection of an edge from a node.
comment|/// @param eId Edge id for edge being disconnected.
comment|/// @param nId Node id for the node being disconnected from.
comment|///
comment|/// Updates allocability of the given node and, if appropriate, moves the
comment|/// node to a new list.
name|void
name|handleRemoveEdge
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|,
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
comment|// If the node is not managed by the heuristic there's nothing to be
comment|// done.
if|if
condition|(
operator|!
name|nd
operator|.
name|isHeuristic
condition|)
return|return;
name|EdgeData
modifier|&
name|ed
init|=
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ed
expr_stmt|;
name|assert
argument_list|(
name|ed
operator|.
name|isUpToDate
operator|&&
literal|"Edge data is not up to date."
argument_list|)
expr_stmt|;
comment|// Update node.
name|bool
name|ndWasAllocable
init|=
name|nd
operator|.
name|isAllocable
decl_stmt|;
name|subtractEdgeContributions
argument_list|(
name|eId
argument_list|,
name|nId
argument_list|)
expr_stmt|;
name|updateAllocability
argument_list|(
name|nId
argument_list|)
expr_stmt|;
comment|// If the node has gone optimal...
if|if
condition|(
name|shouldOptimallyReduce
argument_list|(
name|nId
argument_list|)
condition|)
block|{
name|nd
operator|.
name|isHeuristic
operator|=
name|false
expr_stmt|;
name|addToOptimalReduceList
argument_list|(
name|nId
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndWasAllocable
condition|)
block|{
name|rnAllocableList
operator|.
name|erase
argument_list|(
name|nd
operator|.
name|rnaItr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rnUnallocableList
operator|.
name|erase
argument_list|(
name|nd
operator|.
name|rnuItr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Node didn't go optimal, but we might have to move it
comment|// from "unallocable" to "allocable".
if|if
condition|(
operator|!
name|ndWasAllocable
operator|&&
name|nd
operator|.
name|isAllocable
condition|)
block|{
name|rnUnallocableList
operator|.
name|erase
argument_list|(
name|nd
operator|.
name|rnuItr
argument_list|)
expr_stmt|;
name|nd
operator|.
name|rnaItr
operator|=
name|rnAllocableList
operator|.
name|insert
argument_list|(
name|rnAllocableList
operator|.
name|end
argument_list|()
argument_list|,
name|nId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|private
label|:
name|NodeData
modifier|&
name|getHeuristicNodeData
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
return|return
name|getSolver
argument_list|()
operator|.
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
return|;
block|}
name|EdgeData
modifier|&
name|getHeuristicEdgeData
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
return|return
name|getSolver
argument_list|()
operator|.
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
return|;
block|}
comment|// Work out what this edge will contribute to the allocability of the
comment|// nodes connected to it.
name|void
name|computeEdgeContributions
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|)
block|{
name|EdgeData
modifier|&
name|ed
init|=
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
if|if
condition|(
name|ed
operator|.
name|isUpToDate
condition|)
return|return;
comment|// Edge data is already up to date.
name|Matrix
modifier|&
name|eCosts
init|=
name|getGraph
argument_list|()
operator|.
name|getEdgeCosts
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|unsigned
name|numRegs
init|=
name|eCosts
operator|.
name|getRows
argument_list|()
operator|-
literal|1
decl_stmt|,
name|numReverseRegs
init|=
name|eCosts
operator|.
name|getCols
argument_list|()
operator|-
literal|1
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|rowInfCounts
argument_list|(
name|numRegs
argument_list|,
literal|0
argument_list|)
operator|,
name|colInfCounts
argument_list|(
name|numReverseRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ed
operator|.
name|worst
operator|=
literal|0
expr_stmt|;
name|ed
operator|.
name|reverseWorst
operator|=
literal|0
expr_stmt|;
name|ed
operator|.
name|unsafe
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ed
operator|.
name|unsafe
operator|.
name|resize
argument_list|(
name|numRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ed
operator|.
name|reverseUnsafe
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ed
operator|.
name|reverseUnsafe
operator|.
name|resize
argument_list|(
name|numReverseRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegs
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numReverseRegs
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|eCosts
index|[
name|i
operator|+
literal|1
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
name|ed
operator|.
name|unsafe
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|ed
operator|.
name|reverseUnsafe
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|rowInfCounts
index|[
name|i
index|]
expr_stmt|;
operator|++
name|colInfCounts
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|colInfCounts
index|[
name|j
index|]
operator|>
name|ed
operator|.
name|worst
condition|)
block|{
name|ed
operator|.
name|worst
operator|=
name|colInfCounts
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rowInfCounts
index|[
name|i
index|]
operator|>
name|ed
operator|.
name|reverseWorst
condition|)
block|{
name|ed
operator|.
name|reverseWorst
operator|=
name|rowInfCounts
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|ed
operator|.
name|isUpToDate
operator|=
name|true
expr_stmt|;
block|}
comment|// Add the contributions of the given edge to the given node's
comment|// numDenied and safe members. No action is taken other than to update
comment|// these member values. Once updated these numbers can be used by clients
comment|// to update the node's allocability.
name|void
name|addEdgeContributions
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|,
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|EdgeData
modifier|&
name|ed
init|=
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ed
operator|.
name|isUpToDate
operator|&&
literal|"Using out-of-date edge numbers."
argument_list|)
expr_stmt|;
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
name|unsigned
name|numRegs
init|=
name|getGraph
argument_list|()
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
decl_stmt|;
name|bool
name|nIsNode1
init|=
name|nId
operator|==
name|getGraph
argument_list|()
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|EdgeData
operator|::
name|UnsafeArray
operator|&
name|unsafe
operator|=
name|nIsNode1
condition|?
name|ed
operator|.
name|unsafe
else|:
name|ed
operator|.
name|reverseUnsafe
expr_stmt|;
name|nd
operator|.
name|numDenied
operator|+=
name|nIsNode1
condition|?
name|ed
operator|.
name|worst
else|:
name|ed
operator|.
name|reverseWorst
expr_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|numRegs
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|unsafe
index|[
name|r
index|]
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|unsafeDegrees
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
operator|--
name|nd
operator|.
name|numSafe
expr_stmt|;
block|}
operator|++
name|nd
operator|.
name|unsafeDegrees
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
block|}
comment|// Subtract the contributions of the given edge to the given node's
comment|// numDenied and safe members. No action is taken other than to update
comment|// these member values. Once updated these numbers can be used by clients
comment|// to update the node's allocability.
name|void
name|subtractEdgeContributions
argument_list|(
name|Graph
operator|::
name|EdgeId
name|eId
argument_list|,
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|EdgeData
modifier|&
name|ed
init|=
name|getHeuristicEdgeData
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ed
operator|.
name|isUpToDate
operator|&&
literal|"Using out-of-date edge numbers."
argument_list|)
expr_stmt|;
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
name|unsigned
name|numRegs
init|=
name|getGraph
argument_list|()
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
decl_stmt|;
name|bool
name|nIsNode1
init|=
name|nId
operator|==
name|getGraph
argument_list|()
operator|.
name|getEdgeNode1
argument_list|(
name|eId
argument_list|)
decl_stmt|;
name|EdgeData
operator|::
name|UnsafeArray
operator|&
name|unsafe
operator|=
name|nIsNode1
condition|?
name|ed
operator|.
name|unsafe
else|:
name|ed
operator|.
name|reverseUnsafe
expr_stmt|;
name|nd
operator|.
name|numDenied
operator|-=
name|nIsNode1
condition|?
name|ed
operator|.
name|worst
else|:
name|ed
operator|.
name|reverseWorst
expr_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|numRegs
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|unsafe
index|[
name|r
index|]
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|unsafeDegrees
index|[
name|r
index|]
operator|==
literal|1
condition|)
block|{
operator|++
name|nd
operator|.
name|numSafe
expr_stmt|;
block|}
operator|--
name|nd
operator|.
name|unsafeDegrees
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
block|}
name|void
name|updateAllocability
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
name|unsigned
name|numRegs
init|=
name|getGraph
argument_list|()
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
decl_stmt|;
name|nd
operator|.
name|isAllocable
operator|=
name|nd
operator|.
name|numDenied
operator|<
name|numRegs
operator|||
name|nd
operator|.
name|numSafe
operator|>
literal|0
expr_stmt|;
block|}
name|void
name|initializeNode
argument_list|(
name|Graph
operator|::
name|NodeId
name|nId
argument_list|)
block|{
name|NodeData
modifier|&
name|nd
init|=
name|getHeuristicNodeData
argument_list|(
name|nId
argument_list|)
decl_stmt|;
if|if
condition|(
name|nd
operator|.
name|isInitialized
condition|)
return|return;
comment|// Node data is already up to date.
name|unsigned
name|numRegs
init|=
name|getGraph
argument_list|()
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
decl_stmt|;
name|nd
operator|.
name|numDenied
operator|=
literal|0
expr_stmt|;
specifier|const
name|Vector
modifier|&
name|nCosts
init|=
name|getGraph
argument_list|()
operator|.
name|getNodeCosts
argument_list|(
name|nId
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nCosts
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nCosts
index|[
name|i
index|]
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
operator|++
name|nd
operator|.
name|numDenied
expr_stmt|;
block|}
name|nd
operator|.
name|numSafe
operator|=
name|numRegs
expr_stmt|;
name|nd
operator|.
name|unsafeDegrees
operator|.
name|resize
argument_list|(
name|numRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
typedef|typedef
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|::
name|SolverEdgeItr
name|SolverEdgeItr
expr_stmt|;
for|for
control|(
name|SolverEdgeItr
name|aeItr
init|=
name|getSolver
argument_list|()
operator|.
name|solverEdgesBegin
argument_list|(
name|nId
argument_list|)
init|,
name|aeEnd
init|=
name|getSolver
argument_list|()
operator|.
name|solverEdgesEnd
argument_list|(
name|nId
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
name|Graph
operator|::
name|EdgeId
name|eId
operator|=
operator|*
name|aeItr
expr_stmt|;
name|computeEdgeContributions
argument_list|(
name|eId
argument_list|)
expr_stmt|;
name|addEdgeContributions
argument_list|(
name|eId
argument_list|,
name|nId
argument_list|)
expr_stmt|;
block|}
name|updateAllocability
argument_list|(
name|nId
argument_list|)
expr_stmt|;
name|nd
operator|.
name|isInitialized
operator|=
name|true
expr_stmt|;
block|}
name|void
name|handleRemoveNode
argument_list|(
name|Graph
operator|::
name|NodeId
name|xnId
argument_list|)
block|{
typedef|typedef
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
operator|::
name|SolverEdgeItr
name|SolverEdgeItr
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Graph
operator|::
name|EdgeId
operator|>
name|edgesToRemove
expr_stmt|;
for|for
control|(
name|SolverEdgeItr
name|aeItr
init|=
name|getSolver
argument_list|()
operator|.
name|solverEdgesBegin
argument_list|(
name|xnId
argument_list|)
init|,
name|aeEnd
init|=
name|getSolver
argument_list|()
operator|.
name|solverEdgesEnd
argument_list|(
name|xnId
argument_list|)
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
name|Graph
operator|::
name|NodeId
name|ynId
operator|=
name|getGraph
argument_list|()
operator|.
name|getEdgeOtherNode
argument_list|(
operator|*
name|aeItr
argument_list|,
name|xnId
argument_list|)
expr_stmt|;
name|handleRemoveEdge
argument_list|(
operator|*
name|aeItr
argument_list|,
name|ynId
argument_list|)
expr_stmt|;
name|edgesToRemove
operator|.
name|push_back
argument_list|(
operator|*
name|aeItr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|edgesToRemove
operator|.
name|empty
argument_list|()
condition|)
block|{
name|getSolver
argument_list|()
operator|.
name|removeSolverEdge
argument_list|(
name|edgesToRemove
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|edgesToRemove
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|RNAllocableList
name|rnAllocableList
decl_stmt|;
name|RNUnallocableList
name|rnUnallocableList
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|} }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_comment

end_unit

