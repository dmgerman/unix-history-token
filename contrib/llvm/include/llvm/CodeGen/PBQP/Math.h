begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------ Math.h - PBQP Vector and Matrix classes -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_MATH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_MATH_H
end_define

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
typedef|typedef
name|float
name|PBQPNum
typedef|;
comment|/// \brief PBQP Vector class.
name|class
name|Vector
block|{
name|friend
name|class
name|VectorComparator
decl_stmt|;
name|public
label|:
comment|/// \brief Construct a PBQP vector of the given size.
name|explicit
name|Vector
argument_list|(
argument|unsigned Length
argument_list|)
block|:
name|Length
argument_list|(
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Length]
argument_list|)
block|{
comment|// llvm::dbgs()<< "Constructing PBQP::Vector "
comment|//<< this<< " (length "<< Length<< ")\n";
block|}
comment|/// \brief Construct a PBQP vector with initializer.
name|Vector
argument_list|(
argument|unsigned Length
argument_list|,
argument|PBQPNum InitVal
argument_list|)
operator|:
name|Length
argument_list|(
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Length]
argument_list|)
block|{
comment|// llvm::dbgs()<< "Constructing PBQP::Vector "
comment|//<< this<< " (length "<< Length<< ", fill "
comment|//<< InitVal<< ")\n";
name|std
operator|::
name|fill
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
name|Length
argument_list|,
name|InitVal
argument_list|)
block|;   }
comment|/// \brief Copy construct a PBQP vector.
name|Vector
argument_list|(
specifier|const
name|Vector
operator|&
name|V
argument_list|)
operator|:
name|Length
argument_list|(
name|V
operator|.
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Length]
argument_list|)
block|{
comment|// llvm::dbgs()<< "Copy-constructing PBQP::Vector "<< this
comment|//<< " from PBQP::Vector "<<&V<< "\n";
name|std
operator|::
name|copy
argument_list|(
name|V
operator|.
name|Data
argument_list|,
name|V
operator|.
name|Data
operator|+
name|Length
argument_list|,
name|Data
argument_list|)
block|;   }
comment|/// \brief Move construct a PBQP vector.
name|Vector
argument_list|(
name|Vector
operator|&&
name|V
argument_list|)
operator|:
name|Length
argument_list|(
name|V
operator|.
name|Length
argument_list|)
operator|,
name|Data
argument_list|(
argument|V.Data
argument_list|)
block|{
name|V
operator|.
name|Length
operator|=
literal|0
block|;
name|V
operator|.
name|Data
operator|=
name|nullptr
block|;   }
comment|/// \brief Destroy this vector, return its memory.
operator|~
name|Vector
argument_list|()
block|{
comment|// llvm::dbgs()<< "Deleting PBQP::Vector "<< this<< "\n";
name|delete
index|[]
name|Data
block|;   }
comment|/// \brief Copy-assignment operator.
name|Vector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
comment|// llvm::dbgs()<< "Assigning to PBQP::Vector "<< this
comment|//<< " from PBQP::Vector "<<&V<< "\n";
name|delete
index|[]
name|Data
block|;
name|Length
operator|=
name|V
operator|.
name|Length
block|;
name|Data
operator|=
name|new
name|PBQPNum
index|[
name|Length
index|]
block|;
name|std
operator|::
name|copy
argument_list|(
name|V
operator|.
name|Data
argument_list|,
name|V
operator|.
name|Data
operator|+
name|Length
argument_list|,
name|Data
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Move-assignment operator.
name|Vector
modifier|&
name|operator
init|=
operator|(
name|Vector
operator|&&
name|V
operator|)
block|{
name|delete
index|[]
name|Data
block|;
name|Length
operator|=
name|V
operator|.
name|Length
block|;
name|Data
operator|=
name|V
operator|.
name|Data
block|;
name|V
operator|.
name|Length
operator|=
literal|0
block|;
name|V
operator|.
name|Data
operator|=
name|nullptr
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Comparison operator.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
if|if
condition|(
name|Length
operator|!=
name|V
operator|.
name|Length
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
name|Length
argument_list|,
name|V
operator|.
name|Data
argument_list|)
return|;
block|}
comment|/// \brief Return the length of the vector
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
return|return
name|Length
return|;
block|}
comment|/// \brief Element access.
name|PBQPNum
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|Index
parameter_list|)
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Index
operator|<
name|Length
operator|&&
literal|"Vector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
index|[
name|Index
index|]
return|;
block|}
comment|/// \brief Const element access.
specifier|const
name|PBQPNum
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|Index
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Index
operator|<
name|Length
operator|&&
literal|"Vector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
index|[
name|Index
index|]
return|;
block|}
comment|/// \brief Add another vector to this one.
name|Vector
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
name|assert
argument_list|(
name|Length
operator|==
name|V
operator|.
name|Length
operator|&&
literal|"Vector length mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
name|Length
argument_list|,
name|V
operator|.
name|Data
argument_list|,
name|Data
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Subtract another vector from this one.
name|Vector
operator|&
name|operator
operator|-=
operator|(
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
name|assert
argument_list|(
name|Length
operator|==
name|V
operator|.
name|Length
operator|&&
literal|"Vector length mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
name|Length
argument_list|,
name|V
operator|.
name|Data
argument_list|,
name|Data
argument_list|,
name|std
operator|::
name|minus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Returns the index of the minimum value in this vector
name|unsigned
name|minIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Length
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid vector"
argument_list|)
block|;
return|return
name|std
operator|::
name|min_element
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
name|Length
argument_list|)
operator|-
name|Data
return|;
block|}
name|private
label|:
name|unsigned
name|Length
decl_stmt|;
name|PBQPNum
modifier|*
name|Data
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|VectorComparator
block|{
name|public
label|:
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Vector
operator|&
name|A
operator|,
specifier|const
name|Vector
operator|&
name|B
operator|)
block|{
if|if
condition|(
name|A
operator|.
name|Length
operator|<
name|B
operator|.
name|Length
condition|)
return|return
name|true
return|;
if|if
condition|(
name|B
operator|.
name|Length
operator|<
name|A
operator|.
name|Length
condition|)
return|return
name|false
return|;
name|char
modifier|*
name|AData
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|A
operator|.
name|Data
operator|)
decl_stmt|;
name|char
modifier|*
name|BData
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|B
operator|.
name|Data
operator|)
decl_stmt|;
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|AData
argument_list|,
name|AData
operator|+
name|A
operator|.
name|Length
operator|*
sizeof|sizeof
argument_list|(
name|PBQPNum
argument_list|)
argument_list|,
name|BData
argument_list|,
name|BData
operator|+
name|A
operator|.
name|Length
operator|*
sizeof|sizeof
argument_list|(
name|PBQPNum
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|/// \brief Output a textual representation of the given vector on the given
end_comment

begin_comment
comment|///        output stream.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|OStream
operator|>
name|OStream
operator|&
name|operator
operator|<<
operator|(
name|OStream
operator|&
name|OS
operator|,
specifier|const
name|Vector
operator|&
name|V
operator|)
block|{
name|assert
argument_list|(
operator|(
name|V
operator|.
name|getLength
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
literal|"Zero-length vector badness."
argument_list|)
block|;
name|OS
operator|<<
literal|"[ "
operator|<<
name|V
index|[
literal|0
index|]
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|V
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
literal|", "
operator|<<
name|V
index|[
name|i
index|]
expr_stmt|;
name|OS
operator|<<
literal|" ]"
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|OS
return|;
end_return

begin_comment
unit|}
comment|/// \brief PBQP Matrix class
end_comment

begin_macro
unit|class
name|Matrix
end_macro

begin_block
block|{
name|private
label|:
name|friend
name|class
name|MatrixComparator
decl_stmt|;
name|public
label|:
comment|/// \brief Construct a PBQP Matrix with the given dimensions.
name|Matrix
argument_list|(
argument|unsigned Rows
argument_list|,
argument|unsigned Cols
argument_list|)
block|:
name|Rows
argument_list|(
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Rows * Cols]
argument_list|)
block|{   }
comment|/// \brief Construct a PBQP Matrix with the given dimensions and initial
comment|/// value.
name|Matrix
argument_list|(
argument|unsigned Rows
argument_list|,
argument|unsigned Cols
argument_list|,
argument|PBQPNum InitVal
argument_list|)
operator|:
name|Rows
argument_list|(
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Rows * Cols]
argument_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|InitVal
argument_list|)
block|;   }
comment|/// \brief Copy construct a PBQP matrix.
name|Matrix
argument_list|(
specifier|const
name|Matrix
operator|&
name|M
argument_list|)
operator|:
name|Rows
argument_list|(
name|M
operator|.
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|M
operator|.
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|new PBQPNum[Rows * Cols]
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|M
operator|.
name|Data
argument_list|,
name|M
operator|.
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|Data
argument_list|)
block|;   }
comment|/// \brief Move construct a PBQP matrix.
name|Matrix
argument_list|(
name|Matrix
operator|&&
name|M
argument_list|)
operator|:
name|Rows
argument_list|(
name|M
operator|.
name|Rows
argument_list|)
operator|,
name|Cols
argument_list|(
name|M
operator|.
name|Cols
argument_list|)
operator|,
name|Data
argument_list|(
argument|M.Data
argument_list|)
block|{
name|M
operator|.
name|Rows
operator|=
name|M
operator|.
name|Cols
operator|=
literal|0
block|;
name|M
operator|.
name|Data
operator|=
name|nullptr
block|;   }
comment|/// \brief Destroy this matrix, return its memory.
operator|~
name|Matrix
argument_list|()
block|{
name|delete
index|[]
name|Data
block|; }
comment|/// \brief Copy-assignment operator.
name|Matrix
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|delete
index|[]
name|Data
block|;
name|Rows
operator|=
name|M
operator|.
name|Rows
block|;
name|Cols
operator|=
name|M
operator|.
name|Cols
block|;
name|Data
operator|=
name|new
name|PBQPNum
index|[
name|Rows
operator|*
name|Cols
index|]
block|;
name|std
operator|::
name|copy
argument_list|(
name|M
operator|.
name|Data
argument_list|,
name|M
operator|.
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|Data
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Move-assignment operator.
name|Matrix
modifier|&
name|operator
init|=
operator|(
name|Matrix
operator|&&
name|M
operator|)
block|{
name|delete
index|[]
name|Data
block|;
name|Rows
operator|=
name|M
operator|.
name|Rows
block|;
name|Cols
operator|=
name|M
operator|.
name|Cols
block|;
name|Data
operator|=
name|M
operator|.
name|Data
block|;
name|M
operator|.
name|Rows
operator|=
name|M
operator|.
name|Cols
operator|=
literal|0
block|;
name|M
operator|.
name|Data
operator|=
name|nullptr
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Comparison operator.
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
if|if
condition|(
name|Rows
operator|!=
name|M
operator|.
name|Rows
operator|||
name|Cols
operator|!=
name|M
operator|.
name|Cols
condition|)
return|return
name|false
return|;
return|return
name|std
operator|::
name|equal
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|M
operator|.
name|Data
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/// \brief Return the number of rows in this matrix.
end_comment

begin_expr_stmt
name|unsigned
name|getRows
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
return|return
name|Rows
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return the number of cols in this matrix.
end_comment

begin_expr_stmt
name|unsigned
name|getCols
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
return|return
name|Cols
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Matrix element access.
end_comment

begin_function
name|PBQPNum
modifier|*
name|operator
function|[]
parameter_list|(
name|unsigned
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Matrix element access.
end_comment

begin_decl_stmt
specifier|const
name|PBQPNum
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the given row as a vector.
end_comment

begin_decl_stmt
name|Vector
name|getRowAsVector
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|Vector
name|V
parameter_list|(
name|Cols
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|C
init|=
literal|0
init|;
name|C
operator|<
name|Cols
condition|;
operator|++
name|C
control|)
name|V
index|[
name|C
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
expr_stmt|;
return|return
name|V
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the given column as a vector.
end_comment

begin_decl_stmt
name|Vector
name|getColAsVector
argument_list|(
name|unsigned
name|C
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|Vector
name|V
parameter_list|(
name|Rows
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|R
init|=
literal|0
init|;
name|R
operator|<
name|Rows
condition|;
operator|++
name|R
control|)
name|V
index|[
name|R
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
expr_stmt|;
return|return
name|V
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Reset the matrix to the given value.
end_comment

begin_function
name|Matrix
modifier|&
name|reset
parameter_list|(
name|PBQPNum
name|Val
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|Val
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// \brief Set a single row of this matrix to the given value.
end_comment

begin_function
name|Matrix
modifier|&
name|setRow
parameter_list|(
name|unsigned
name|R
parameter_list|,
name|PBQPNum
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill
argument_list|(
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
argument_list|,
name|Data
operator|+
operator|(
operator|(
name|R
operator|+
literal|1
operator|)
operator|*
name|Cols
operator|)
argument_list|,
name|Val
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// \brief Set a single column of this matrix to the given value.
end_comment

begin_function
name|Matrix
modifier|&
name|setCol
parameter_list|(
name|unsigned
name|C
parameter_list|,
name|PBQPNum
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|C
operator|<
name|Cols
operator|&&
literal|"Column out of bounds."
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|R
init|=
literal|0
init|;
name|R
operator|<
name|Rows
condition|;
operator|++
name|R
control|)
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
operator|=
name|Val
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// \brief Matrix transpose.
end_comment

begin_expr_stmt
name|Matrix
name|transpose
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|Matrix
name|M
argument_list|(
name|Cols
argument_list|,
name|Rows
argument_list|)
block|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|Rows
condition|;
operator|++
name|r
control|)
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|Cols
condition|;
operator|++
name|c
control|)
name|M
index|[
name|c
index|]
index|[
name|r
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|M
return|;
end_return

begin_comment
unit|}
comment|/// \brief Returns the diagonal of the matrix as a vector.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Matrix must be square.
end_comment

begin_macro
unit|Vector
name|diagonalize
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|assert
argument_list|(
name|Rows
operator|==
name|Cols
operator|&&
literal|"Attempt to diagonalize non-square matrix."
argument_list|)
block|;
name|Vector
name|V
argument_list|(
name|Rows
argument_list|)
block|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|Rows
condition|;
operator|++
name|r
control|)
name|V
index|[
name|r
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|r
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|V
return|;
end_return

begin_comment
unit|}
comment|/// \brief Add the given matrix to this one.
end_comment

begin_expr_stmt
unit|Matrix
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|assert
argument_list|(
name|Rows
operator|==
name|M
operator|.
name|Rows
operator|&&
name|Cols
operator|==
name|M
operator|.
name|Cols
operator|&&
literal|"Matrix dimensions mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|M
operator|.
name|Data
argument_list|,
name|Data
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Matrix
name|operator
operator|+
operator|(
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
name|Matrix
name|Tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|Tmp
operator|+=
name|M
block|;
return|return
name|Tmp
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Returns the minimum of the given row
end_comment

begin_decl_stmt
name|PBQPNum
name|getRowMin
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds"
argument_list|)
expr_stmt|;
return|return
operator|*
name|std
operator|::
name|min_element
argument_list|(
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
argument_list|,
name|Data
operator|+
operator|(
operator|(
name|R
operator|+
literal|1
operator|)
operator|*
name|Cols
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the minimum of the given column
end_comment

begin_decl_stmt
name|PBQPNum
name|getColMin
argument_list|(
name|unsigned
name|C
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|PBQPNum
name|MinElem
init|=
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
index|[
name|C
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|R
init|=
literal|1
init|;
name|R
operator|<
name|Rows
condition|;
operator|++
name|R
control|)
if|if
condition|(
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
operator|<
name|MinElem
condition|)
name|MinElem
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
expr_stmt|;
return|return
name|MinElem
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Subtracts the given scalar from the elements of the given row.
end_comment

begin_function
name|Matrix
modifier|&
name|subFromRow
parameter_list|(
name|unsigned
name|R
parameter_list|,
name|PBQPNum
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|R
operator|<
name|Rows
operator|&&
literal|"Row out of bounds"
argument_list|)
expr_stmt|;
name|std
operator|::
name|transform
argument_list|(
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
argument_list|,
name|Data
operator|+
operator|(
operator|(
name|R
operator|+
literal|1
operator|)
operator|*
name|Cols
operator|)
argument_list|,
name|Data
operator|+
operator|(
name|R
operator|*
name|Cols
operator|)
argument_list|,
name|std
operator|::
name|bind2nd
argument_list|(
name|std
operator|::
name|minus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|,
name|Val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// \brief Subtracts the given scalar from the elements of the given column.
end_comment

begin_function
name|Matrix
modifier|&
name|subFromCol
parameter_list|(
name|unsigned
name|C
parameter_list|,
name|PBQPNum
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|R
init|=
literal|0
init|;
name|R
operator|<
name|Rows
condition|;
operator|++
name|R
control|)
operator|(
operator|*
name|this
operator|)
index|[
name|R
index|]
index|[
name|C
index|]
operator|-=
name|Val
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// \brief Returns true if this is a zero matrix.
end_comment

begin_expr_stmt
name|bool
name|isZero
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Rows
operator|!=
literal|0
operator|&&
name|Cols
operator|!=
literal|0
operator|&&
name|Data
operator|!=
name|nullptr
operator|&&
literal|"Invalid matrix"
argument_list|)
block|;
return|return
name|find_if
argument_list|(
name|Data
argument_list|,
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
argument_list|,
name|std
operator|::
name|bind2nd
argument_list|(
name|std
operator|::
name|not_equal_to
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|Data
operator|+
operator|(
name|Rows
operator|*
name|Cols
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|unsigned
name|Rows
decl_stmt|,
name|Cols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PBQPNum
modifier|*
name|Data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|MatrixComparator
block|{
name|public
label|:
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Matrix
operator|&
name|A
operator|,
specifier|const
name|Matrix
operator|&
name|B
operator|)
block|{
if|if
condition|(
name|A
operator|.
name|Rows
operator|<
name|B
operator|.
name|Rows
condition|)
return|return
name|true
return|;
if|if
condition|(
name|B
operator|.
name|Rows
operator|<
name|A
operator|.
name|Rows
condition|)
return|return
name|false
return|;
if|if
condition|(
name|A
operator|.
name|Cols
operator|<
name|B
operator|.
name|Cols
condition|)
return|return
name|true
return|;
if|if
condition|(
name|B
operator|.
name|Cols
operator|<
name|A
operator|.
name|Cols
condition|)
return|return
name|false
return|;
name|char
modifier|*
name|AData
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|A
operator|.
name|Data
operator|)
decl_stmt|;
name|char
modifier|*
name|BData
init|=
name|reinterpret_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|B
operator|.
name|Data
operator|)
decl_stmt|;
return|return
name|std
operator|::
name|lexicographical_compare
argument_list|(
name|AData
argument_list|,
name|AData
operator|+
operator|(
name|A
operator|.
name|Rows
operator|*
name|A
operator|.
name|Cols
operator|*
sizeof|sizeof
argument_list|(
name|PBQPNum
argument_list|)
operator|)
argument_list|,
name|BData
argument_list|,
name|BData
operator|+
operator|(
name|A
operator|.
name|Rows
operator|*
name|A
operator|.
name|Cols
operator|*
sizeof|sizeof
argument_list|(
name|PBQPNum
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|/// \brief Output a textual representation of the given matrix on the given
end_comment

begin_comment
comment|///        output stream.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|OStream
operator|>
name|OStream
operator|&
name|operator
operator|<<
operator|(
name|OStream
operator|&
name|OS
operator|,
specifier|const
name|Matrix
operator|&
name|M
operator|)
block|{
name|assert
argument_list|(
operator|(
name|M
operator|.
name|getRows
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
literal|"Zero-row matrix badness."
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|M
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
name|M
operator|.
name|getRowAsVector
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|OS
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Metadata
operator|>
name|class
name|MDVector
operator|:
name|public
name|Vector
block|{
name|public
operator|:
name|MDVector
argument_list|(
specifier|const
name|Vector
operator|&
name|v
argument_list|)
operator|:
name|Vector
argument_list|(
name|v
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
name|MDVector
argument_list|(
name|Vector
operator|&&
name|v
argument_list|)
operator|:
name|Vector
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|v
argument_list|)
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
specifier|const
name|Metadata
operator|&
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|md
return|;
block|}
name|private
operator|:
name|Metadata
name|md
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Metadata
operator|>
name|class
name|MDMatrix
operator|:
name|public
name|Matrix
block|{
name|public
operator|:
name|MDMatrix
argument_list|(
specifier|const
name|Matrix
operator|&
name|m
argument_list|)
operator|:
name|Matrix
argument_list|(
name|m
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
name|MDMatrix
argument_list|(
name|Matrix
operator|&&
name|m
argument_list|)
operator|:
name|Matrix
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|m
argument_list|)
argument_list|)
block|,
name|md
argument_list|(
argument|*this
argument_list|)
block|{ }
specifier|const
name|Metadata
operator|&
name|getMetadata
argument_list|()
specifier|const
block|{
return|return
name|md
return|;
block|}
name|private
operator|:
name|Metadata
name|md
expr_stmt|;
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_MATH_H
end_comment

end_unit

