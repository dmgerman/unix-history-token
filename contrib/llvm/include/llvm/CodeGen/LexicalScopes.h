begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- LexicalScopes.cpp - Collecting lexical scope info --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements LexicalScopes analysis.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This pass collects lexical scope information and maps machine instructions
end_comment

begin_comment
comment|// to respective lexical scopes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_LEXICALSCOPES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_LEXICALSCOPES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DebugInfoMetadata.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// InsnRange - This is used to track range of instructions with identical
comment|/// lexical scope.
comment|///
name|using
name|InsnRange
init|=
name|std
operator|::
name|pair
operator|<
specifier|const
name|MachineInstr
operator|*
decl_stmt|, const
name|MachineInstr
modifier|*
decl|>
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// LexicalScope - This class is used to track scope information.
comment|///
name|class
name|LexicalScope
block|{
name|public
label|:
name|LexicalScope
argument_list|(
argument|LexicalScope *P
argument_list|,
argument|const DILocalScope *D
argument_list|,
argument|const DILocation *I
argument_list|,
argument|bool A
argument_list|)
block|:
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Desc
argument_list|(
name|D
argument_list|)
operator|,
name|InlinedAtLocation
argument_list|(
name|I
argument_list|)
operator|,
name|AbstractScope
argument_list|(
argument|A
argument_list|)
block|{
name|assert
argument_list|(
name|D
argument_list|)
block|;
name|assert
argument_list|(
name|D
operator|->
name|getSubprogram
argument_list|()
operator|->
name|getUnit
argument_list|()
operator|->
name|getEmissionKind
argument_list|()
operator|!=
name|DICompileUnit
operator|::
name|NoDebug
operator|&&
literal|"Don't build lexical scopes for non-debug locations"
argument_list|)
block|;
name|assert
argument_list|(
name|D
operator|->
name|isResolved
argument_list|()
operator|&&
literal|"Expected resolved node"
argument_list|)
block|;
name|assert
argument_list|(
operator|(
operator|!
name|I
operator|||
name|I
operator|->
name|isResolved
argument_list|()
operator|)
operator|&&
literal|"Expected resolved node"
argument_list|)
block|;
if|if
condition|(
name|Parent
condition|)
name|Parent
operator|->
name|addChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Accessors.
name|LexicalScope
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
specifier|const
name|MDNode
operator|*
name|getDesc
argument_list|()
specifier|const
block|{
return|return
name|Desc
return|;
block|}
specifier|const
name|DILocation
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|{
return|return
name|InlinedAtLocation
return|;
block|}
specifier|const
name|DILocalScope
operator|*
name|getScopeNode
argument_list|()
specifier|const
block|{
return|return
name|Desc
return|;
block|}
name|bool
name|isAbstractScope
argument_list|()
specifier|const
block|{
return|return
name|AbstractScope
return|;
block|}
name|SmallVectorImpl
operator|<
name|LexicalScope
operator|*
operator|>
operator|&
name|getChildren
argument_list|()
block|{
return|return
name|Children
return|;
block|}
name|SmallVectorImpl
operator|<
name|InsnRange
operator|>
operator|&
name|getRanges
argument_list|()
block|{
return|return
name|Ranges
return|;
block|}
comment|/// addChild - Add a child scope.
name|void
name|addChild
parameter_list|(
name|LexicalScope
modifier|*
name|S
parameter_list|)
block|{
name|Children
operator|.
name|push_back
argument_list|(
name|S
argument_list|)
expr_stmt|;
block|}
comment|/// openInsnRange - This scope covers instruction range starting from MI.
name|void
name|openInsnRange
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
if|if
condition|(
operator|!
name|FirstInsn
condition|)
name|FirstInsn
operator|=
name|MI
expr_stmt|;
if|if
condition|(
name|Parent
condition|)
name|Parent
operator|->
name|openInsnRange
argument_list|(
name|MI
argument_list|)
expr_stmt|;
block|}
comment|/// extendInsnRange - Extend the current instruction range covered by
comment|/// this scope.
name|void
name|extendInsnRange
parameter_list|(
specifier|const
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
name|assert
argument_list|(
name|FirstInsn
operator|&&
literal|"MI Range is not open!"
argument_list|)
expr_stmt|;
name|LastInsn
operator|=
name|MI
expr_stmt|;
if|if
condition|(
name|Parent
condition|)
name|Parent
operator|->
name|extendInsnRange
argument_list|(
name|MI
argument_list|)
expr_stmt|;
block|}
comment|/// closeInsnRange - Create a range based on FirstInsn and LastInsn collected
comment|/// until now. This is used when a new scope is encountered while walking
comment|/// machine instructions.
name|void
name|closeInsnRange
parameter_list|(
name|LexicalScope
modifier|*
name|NewScope
init|=
name|nullptr
parameter_list|)
block|{
name|assert
argument_list|(
name|LastInsn
operator|&&
literal|"Last insn missing!"
argument_list|)
expr_stmt|;
name|Ranges
operator|.
name|push_back
argument_list|(
name|InsnRange
argument_list|(
name|FirstInsn
argument_list|,
name|LastInsn
argument_list|)
argument_list|)
expr_stmt|;
name|FirstInsn
operator|=
name|nullptr
expr_stmt|;
name|LastInsn
operator|=
name|nullptr
expr_stmt|;
comment|// If Parent dominates NewScope then do not close Parent's instruction
comment|// range.
if|if
condition|(
name|Parent
operator|&&
operator|(
operator|!
name|NewScope
operator|||
operator|!
name|Parent
operator|->
name|dominates
argument_list|(
name|NewScope
argument_list|)
operator|)
condition|)
name|Parent
operator|->
name|closeInsnRange
argument_list|(
name|NewScope
argument_list|)
expr_stmt|;
block|}
comment|/// dominates - Return true if current scope dominates given lexical scope.
name|bool
name|dominates
argument_list|(
specifier|const
name|LexicalScope
operator|*
name|S
argument_list|)
decl|const
block|{
if|if
condition|(
name|S
operator|==
name|this
condition|)
return|return
name|true
return|;
if|if
condition|(
name|DFSIn
operator|<
name|S
operator|->
name|getDFSIn
argument_list|()
operator|&&
name|DFSOut
operator|>
name|S
operator|->
name|getDFSOut
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
comment|// Depth First Search support to walk and manipulate LexicalScope hierarchy.
name|unsigned
name|getDFSOut
argument_list|()
specifier|const
block|{
return|return
name|DFSOut
return|;
block|}
name|void
name|setDFSOut
parameter_list|(
name|unsigned
name|O
parameter_list|)
block|{
name|DFSOut
operator|=
name|O
expr_stmt|;
block|}
name|unsigned
name|getDFSIn
argument_list|()
specifier|const
block|{
return|return
name|DFSIn
return|;
block|}
name|void
name|setDFSIn
parameter_list|(
name|unsigned
name|I
parameter_list|)
block|{
name|DFSIn
operator|=
name|I
expr_stmt|;
block|}
comment|/// dump - print lexical scope.
name|void
name|dump
argument_list|(
name|unsigned
name|Indent
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
name|LexicalScope
modifier|*
name|Parent
decl_stmt|;
comment|// Parent to this scope.
specifier|const
name|DILocalScope
modifier|*
name|Desc
decl_stmt|;
comment|// Debug info descriptor.
specifier|const
name|DILocation
modifier|*
name|InlinedAtLocation
decl_stmt|;
comment|// Location at which this
comment|// scope is inlined.
name|bool
name|AbstractScope
decl_stmt|;
comment|// Abstract Scope
name|SmallVector
operator|<
name|LexicalScope
operator|*
operator|,
literal|4
operator|>
name|Children
expr_stmt|;
comment|// Scopes defined in scope.
comment|// Contents not owned.
name|SmallVector
operator|<
name|InsnRange
operator|,
literal|4
operator|>
name|Ranges
expr_stmt|;
specifier|const
name|MachineInstr
modifier|*
name|LastInsn
init|=
name|nullptr
decl_stmt|;
comment|// Last instruction of this scope.
specifier|const
name|MachineInstr
modifier|*
name|FirstInsn
init|=
name|nullptr
decl_stmt|;
comment|// First instruction of this scope.
name|unsigned
name|DFSIn
init|=
literal|0
decl_stmt|;
comment|// In& Out Depth use to determine scope nesting.
name|unsigned
name|DFSOut
init|=
literal|0
decl_stmt|;
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// LexicalScopes -  This class provides interface to collect and use lexical
comment|/// scoping information from machine instruction.
comment|///
name|class
name|LexicalScopes
block|{
name|public
label|:
name|LexicalScopes
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// initialize - Scan machine function and constuct lexical scope nest, resets
comment|/// the instance if necessary.
name|void
name|initialize
parameter_list|(
specifier|const
name|MachineFunction
modifier|&
parameter_list|)
function_decl|;
comment|/// releaseMemory - release memory.
name|void
name|reset
parameter_list|()
function_decl|;
comment|/// empty - Return true if there is any lexical scope information available.
name|bool
name|empty
parameter_list|()
block|{
return|return
name|CurrentFnLexicalScope
operator|==
name|nullptr
return|;
block|}
comment|/// getCurrentFunctionScope - Return lexical scope for the current function.
name|LexicalScope
operator|*
name|getCurrentFunctionScope
argument_list|()
specifier|const
block|{
return|return
name|CurrentFnLexicalScope
return|;
block|}
comment|/// getMachineBasicBlocks - Populate given set using machine basic blocks
comment|/// which have machine instructions that belong to lexical scope identified by
comment|/// DebugLoc.
name|void
name|getMachineBasicBlocks
argument_list|(
specifier|const
name|DILocation
operator|*
name|DL
argument_list|,
name|SmallPtrSetImpl
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|MBBs
argument_list|)
decl_stmt|;
comment|/// dominates - Return true if DebugLoc's lexical scope dominates at least one
comment|/// machine instruction's lexical scope in a given machine basic block.
name|bool
name|dominates
parameter_list|(
specifier|const
name|DILocation
modifier|*
name|DL
parameter_list|,
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|)
function_decl|;
comment|/// findLexicalScope - Find lexical scope, either regular or inlined, for the
comment|/// given DebugLoc. Return NULL if not found.
name|LexicalScope
modifier|*
name|findLexicalScope
parameter_list|(
specifier|const
name|DILocation
modifier|*
name|DL
parameter_list|)
function_decl|;
comment|/// getAbstractScopesList - Return a reference to list of abstract scopes.
name|ArrayRef
operator|<
name|LexicalScope
operator|*
operator|>
name|getAbstractScopesList
argument_list|()
specifier|const
block|{
return|return
name|AbstractScopesList
return|;
block|}
comment|/// findAbstractScope - Find an abstract scope or return null.
name|LexicalScope
modifier|*
name|findAbstractScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|N
parameter_list|)
block|{
name|auto
name|I
init|=
name|AbstractScopeMap
operator|.
name|find
argument_list|(
name|N
argument_list|)
decl_stmt|;
return|return
name|I
operator|!=
name|AbstractScopeMap
operator|.
name|end
argument_list|()
condition|?
operator|&
name|I
operator|->
name|second
else|:
name|nullptr
return|;
block|}
comment|/// findInlinedScope - Find an inlined scope for the given scope/inlined-at.
name|LexicalScope
modifier|*
name|findInlinedScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|N
parameter_list|,
specifier|const
name|DILocation
modifier|*
name|IA
parameter_list|)
block|{
name|auto
name|I
init|=
name|InlinedLexicalScopeMap
operator|.
name|find
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|N
argument_list|,
name|IA
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|I
operator|!=
name|InlinedLexicalScopeMap
operator|.
name|end
argument_list|()
condition|?
operator|&
name|I
operator|->
name|second
else|:
name|nullptr
return|;
block|}
comment|/// findLexicalScope - Find regular lexical scope or return null.
name|LexicalScope
modifier|*
name|findLexicalScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|N
parameter_list|)
block|{
name|auto
name|I
init|=
name|LexicalScopeMap
operator|.
name|find
argument_list|(
name|N
argument_list|)
decl_stmt|;
return|return
name|I
operator|!=
name|LexicalScopeMap
operator|.
name|end
argument_list|()
condition|?
operator|&
name|I
operator|->
name|second
else|:
name|nullptr
return|;
block|}
comment|/// dump - Print data structures to dbgs().
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// getOrCreateAbstractScope - Find or create an abstract lexical scope.
name|LexicalScope
modifier|*
name|getOrCreateAbstractScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|Scope
parameter_list|)
function_decl|;
name|private
label|:
comment|/// getOrCreateLexicalScope - Find lexical scope for the given Scope/IA. If
comment|/// not available then create new lexical scope.
name|LexicalScope
modifier|*
name|getOrCreateLexicalScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|Scope
parameter_list|,
specifier|const
name|DILocation
modifier|*
name|IA
init|=
name|nullptr
parameter_list|)
function_decl|;
name|LexicalScope
modifier|*
name|getOrCreateLexicalScope
parameter_list|(
specifier|const
name|DILocation
modifier|*
name|DL
parameter_list|)
block|{
return|return
name|DL
condition|?
name|getOrCreateLexicalScope
argument_list|(
name|DL
operator|->
name|getScope
argument_list|()
argument_list|,
name|DL
operator|->
name|getInlinedAt
argument_list|()
argument_list|)
else|:
name|nullptr
return|;
block|}
comment|/// getOrCreateRegularScope - Find or create a regular lexical scope.
name|LexicalScope
modifier|*
name|getOrCreateRegularScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|Scope
parameter_list|)
function_decl|;
comment|/// getOrCreateInlinedScope - Find or create an inlined lexical scope.
name|LexicalScope
modifier|*
name|getOrCreateInlinedScope
parameter_list|(
specifier|const
name|DILocalScope
modifier|*
name|Scope
parameter_list|,
specifier|const
name|DILocation
modifier|*
name|InlinedAt
parameter_list|)
function_decl|;
comment|/// extractLexicalScopes - Extract instruction ranges for each lexical scopes
comment|/// for the given machine function.
name|void
name|extractLexicalScopes
argument_list|(
name|SmallVectorImpl
operator|<
name|InsnRange
operator|>
operator|&
name|MIRanges
argument_list|,
name|DenseMap
operator|<
specifier|const
name|MachineInstr
operator|*
argument_list|,
name|LexicalScope
operator|*
operator|>
operator|&
name|M
argument_list|)
decl_stmt|;
name|void
name|constructScopeNest
parameter_list|(
name|LexicalScope
modifier|*
name|Scope
parameter_list|)
function_decl|;
name|void
name|assignInstructionRanges
argument_list|(
name|SmallVectorImpl
operator|<
name|InsnRange
operator|>
operator|&
name|MIRanges
argument_list|,
name|DenseMap
operator|<
specifier|const
name|MachineInstr
operator|*
argument_list|,
name|LexicalScope
operator|*
operator|>
operator|&
name|M
argument_list|)
decl_stmt|;
specifier|const
name|MachineFunction
modifier|*
name|MF
init|=
name|nullptr
decl_stmt|;
comment|/// LexicalScopeMap - Tracks the scopes in the current function.
comment|// Use an unordered_map to ensure value pointer validity over insertion.
name|std
operator|::
name|unordered_map
operator|<
specifier|const
name|DILocalScope
operator|*
operator|,
name|LexicalScope
operator|>
name|LexicalScopeMap
expr_stmt|;
comment|/// InlinedLexicalScopeMap - Tracks inlined function scopes in current
comment|/// function.
name|std
operator|::
name|unordered_map
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|DILocalScope
operator|*
operator|,
specifier|const
name|DILocation
operator|*
operator|>
operator|,
name|LexicalScope
operator|,
name|pair_hash
operator|<
specifier|const
name|DILocalScope
operator|*
operator|,
specifier|const
name|DILocation
operator|*
operator|>>
name|InlinedLexicalScopeMap
expr_stmt|;
comment|/// AbstractScopeMap - These scopes are  not included LexicalScopeMap.
comment|// Use an unordered_map to ensure value pointer validity over insertion.
name|std
operator|::
name|unordered_map
operator|<
specifier|const
name|DILocalScope
operator|*
operator|,
name|LexicalScope
operator|>
name|AbstractScopeMap
expr_stmt|;
comment|/// AbstractScopesList - Tracks abstract scopes constructed while processing
comment|/// a function.
name|SmallVector
operator|<
name|LexicalScope
operator|*
operator|,
literal|4
operator|>
name|AbstractScopesList
expr_stmt|;
comment|/// CurrentFnLexicalScope - Top level scope for the current function.
comment|///
name|LexicalScope
modifier|*
name|CurrentFnLexicalScope
init|=
name|nullptr
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_LEXICALSCOPES_H
end_comment

end_unit

