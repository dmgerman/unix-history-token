begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file provides a helper that implements much of the TTI interface in
end_comment

begin_comment
comment|/// terms of the target-independent code generator and TargetLowering
end_comment

begin_comment
comment|/// interfaces.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_BASICTTIIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_BASICTTIIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/LoopInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetTransformInfoImpl.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CommandLine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetSubtargetInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetLibraryInfo.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
extern|extern cl::opt<unsigned> PartialUnrollingThreshold;
comment|/// \brief Base class which can be used to help build a TTI implementation.
comment|///
comment|/// This class provides as much implementation of the TTI interface as is
comment|/// possible using the target independent parts of the code generator.
comment|///
comment|/// In order to subclass it, your class must implement a getST() method to
comment|/// return the subtarget, and a getTLI() method to return the target lowering.
comment|/// We need these methods implemented in the derived class so that this class
comment|/// doesn't have to duplicate storage for them.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|BasicTTIImplBase
operator|:
name|public
name|TargetTransformInfoImplCRTPBase
operator|<
name|T
operator|>
block|{
name|private
operator|:
typedef|typedef
name|TargetTransformInfoImplCRTPBase
operator|<
name|T
operator|>
name|BaseT
expr_stmt|;
typedef|typedef
name|TargetTransformInfo
name|TTI
typedef|;
comment|/// Estimate the overhead of scalarizing an instruction. Insert and Extract
comment|/// are set if the result needs to be inserted and/or extracted from vectors.
name|unsigned
name|getScalarizationOverhead
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|Insert
parameter_list|,
name|bool
name|Extract
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Can only scalarize vectors"
argument_list|)
expr_stmt|;
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|e
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Insert
condition|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|Extract
condition|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// Estimate the cost overhead of SK_Alternate shuffle.
name|unsigned
name|getAltShuffleOverhead
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Can only shuffle vectors"
argument_list|)
expr_stmt|;
name|unsigned
name|Cost
init|=
literal|0
decl_stmt|;
comment|// Shuffle cost is equal to the cost of extracting element from its argument
comment|// plus the cost of inserting them onto the result vector.
comment|// e.g.<4 x float> has a mask of<0,5,2,7> i.e we need to extract from
comment|// index 0 of first vector, index 1 of second vector,index 2 of first
comment|// vector and finally index 3 of second vector and insert them at index
comment|//<0,1,2,3> of result vector.
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|e
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|Ty
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// \brief Local query method delegates up to T which *must* implement this!
specifier|const
name|TargetSubtargetInfo
operator|*
name|getST
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getST
argument_list|()
return|;
block|}
comment|/// \brief Local query method delegates up to T which *must* implement this!
specifier|const
name|TargetLoweringBase
operator|*
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getTLI
argument_list|()
return|;
block|}
name|protected
label|:
name|explicit
name|BasicTTIImplBase
argument_list|(
specifier|const
name|TargetMachine
operator|*
name|TM
argument_list|,
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|DL
argument_list|)
block|{}
name|using
name|TargetTransformInfoImplBase
operator|::
name|DL
expr_stmt|;
name|public
label|:
comment|// Provide value semantics. MSVC requires that we spell all of these out.
name|BasicTTIImplBase
argument_list|(
specifier|const
name|BasicTTIImplBase
operator|&
name|Arg
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|static_cast<const BaseT&>(Arg)
argument_list|)
block|{}
name|BasicTTIImplBase
argument_list|(
name|BasicTTIImplBase
operator|&&
name|Arg
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|std::move(static_cast<BaseT&>(Arg))
argument_list|)
block|{}
comment|/// \name Scalar TTI Implementations
comment|/// @{
name|bool
name|hasBranchDivergence
argument_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|isSourceOfDivergence
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalAddImmediate
parameter_list|(
name|int64_t
name|imm
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalAddImmediate
argument_list|(
name|imm
argument_list|)
return|;
block|}
name|bool
name|isLegalICmpImmediate
parameter_list|(
name|int64_t
name|imm
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalICmpImmediate
argument_list|(
name|imm
argument_list|)
return|;
block|}
name|bool
name|isLegalAddressingMode
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
name|TargetLoweringBase
operator|::
name|AddrMode
name|AM
expr_stmt|;
name|AM
operator|.
name|BaseGV
operator|=
name|BaseGV
expr_stmt|;
name|AM
operator|.
name|BaseOffs
operator|=
name|BaseOffset
expr_stmt|;
name|AM
operator|.
name|HasBaseReg
operator|=
name|HasBaseReg
expr_stmt|;
name|AM
operator|.
name|Scale
operator|=
name|Scale
expr_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|isLegalAddressingMode
argument_list|(
name|DL
argument_list|,
name|AM
argument_list|,
name|Ty
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
name|int
name|getScalingFactorCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
name|TargetLoweringBase
operator|::
name|AddrMode
name|AM
expr_stmt|;
name|AM
operator|.
name|BaseGV
operator|=
name|BaseGV
expr_stmt|;
name|AM
operator|.
name|BaseOffs
operator|=
name|BaseOffset
expr_stmt|;
name|AM
operator|.
name|HasBaseReg
operator|=
name|HasBaseReg
expr_stmt|;
name|AM
operator|.
name|Scale
operator|=
name|Scale
expr_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|getScalingFactorCost
argument_list|(
name|DL
argument_list|,
name|AM
argument_list|,
name|Ty
argument_list|,
name|AddrSpace
argument_list|)
return|;
block|}
name|bool
name|isTruncateFree
parameter_list|(
name|Type
modifier|*
name|Ty1
parameter_list|,
name|Type
modifier|*
name|Ty2
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isTruncateFree
argument_list|(
name|Ty1
argument_list|,
name|Ty2
argument_list|)
return|;
block|}
name|bool
name|isProfitableToHoist
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|isProfitableToHoist
argument_list|(
name|I
argument_list|)
return|;
block|}
name|bool
name|isTypeLegal
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
name|EVT
name|VT
init|=
name|getTLI
argument_list|()
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
return|return
name|getTLI
argument_list|()
operator|->
name|isTypeLegal
argument_list|(
name|VT
argument_list|)
return|;
block|}
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Arguments
argument_list|)
block|{
return|return
name|BaseT
operator|::
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|Arguments
argument_list|)
return|;
block|}
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|ParamTys
argument_list|)
block|{
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|cttz
condition|)
block|{
if|if
condition|(
name|getTLI
argument_list|()
operator|->
name|isCheapToSpeculateCttz
argument_list|()
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Expensive
return|;
block|}
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|ctlz
condition|)
block|{
if|if
condition|(
name|getTLI
argument_list|()
operator|->
name|isCheapToSpeculateCtlz
argument_list|()
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Expensive
return|;
block|}
return|return
name|BaseT
operator|::
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|ParamTys
argument_list|)
return|;
block|}
name|unsigned
name|getJumpBufAlignment
parameter_list|()
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|getJumpBufAlignment
argument_list|()
return|;
block|}
name|unsigned
name|getJumpBufSize
parameter_list|()
block|{
return|return
name|getTLI
argument_list|()
operator|->
name|getJumpBufSize
argument_list|()
return|;
block|}
name|bool
name|shouldBuildLookupTables
parameter_list|()
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
return|return
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|BR_JT
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
operator|||
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|BRIND
argument_list|,
name|MVT
operator|::
name|Other
argument_list|)
return|;
block|}
name|bool
name|haveFastSqrt
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|EVT
name|VT
init|=
name|TLI
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
return|return
name|TLI
operator|->
name|isTypeLegal
argument_list|(
name|VT
argument_list|)
operator|&&
name|TLI
operator|->
name|isOperationLegalOrCustom
argument_list|(
name|ISD
operator|::
name|FSQRT
argument_list|,
name|VT
argument_list|)
return|;
block|}
name|unsigned
name|getFPOpCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
comment|// By default, FP instructions are no more expensive since they are
comment|// implemented in HW.  Target specific TTI can override this.
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
name|unsigned
name|getOperationCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|Type
modifier|*
name|OpTy
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
break|break;
case|case
name|Instruction
operator|::
name|Trunc
case|:
block|{
if|if
condition|(
name|TLI
operator|->
name|isTruncateFree
argument_list|(
name|OpTy
argument_list|,
name|Ty
argument_list|)
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Free
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
case|case
name|Instruction
operator|::
name|ZExt
case|:
block|{
if|if
condition|(
name|TLI
operator|->
name|isZExtFree
argument_list|(
name|OpTy
argument_list|,
name|Ty
argument_list|)
condition|)
return|return
name|TargetTransformInfo
operator|::
name|TCC_Free
return|;
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
block|}
return|return
name|BaseT
operator|::
name|getOperationCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
argument_list|,
name|OpTy
argument_list|)
return|;
block|}
name|void
name|getUnrollingPreferences
argument_list|(
name|Loop
operator|*
name|L
argument_list|,
name|TTI
operator|::
name|UnrollingPreferences
operator|&
name|UP
argument_list|)
block|{
comment|// This unrolling functionality is target independent, but to provide some
comment|// motivation for its intended use, for x86:
comment|// According to the Intel 64 and IA-32 Architectures Optimization Reference
comment|// Manual, Intel Core models and later have a loop stream detector (and
comment|// associated uop queue) that can benefit from partial unrolling.
comment|// The relevant requirements are:
comment|//  - The loop must have no more than 4 (8 for Nehalem and later) branches
comment|//    taken, and none of them may be calls.
comment|//  - The loop can have no more than 18 (28 for Nehalem and later) uops.
comment|// According to the Software Optimization Guide for AMD Family 15h
comment|// Processors, models 30h-4fh (Steamroller and later) have a loop predictor
comment|// and loop buffer which can benefit from partial unrolling.
comment|// The relevant requirements are:
comment|//  - The loop must have fewer than 16 branches
comment|//  - The loop must have less than 40 uops in all executed loop branches
comment|// The number of taken branches in a loop is hard to estimate here, and
comment|// benchmarking has revealed that it is better not to be conservative when
comment|// estimating the branch count. As a result, we'll ignore the branch limits
comment|// until someone finds a case where it matters in practice.
name|unsigned
name|MaxOps
decl_stmt|;
specifier|const
name|TargetSubtargetInfo
modifier|*
name|ST
init|=
name|getST
argument_list|()
decl_stmt|;
if|if
condition|(
name|PartialUnrollingThreshold
operator|.
name|getNumOccurrences
argument_list|()
operator|>
literal|0
condition|)
name|MaxOps
operator|=
name|PartialUnrollingThreshold
expr_stmt|;
elseif|else
if|if
condition|(
name|ST
operator|->
name|getSchedModel
argument_list|()
operator|.
name|LoopMicroOpBufferSize
operator|>
literal|0
condition|)
name|MaxOps
operator|=
name|ST
operator|->
name|getSchedModel
argument_list|()
operator|.
name|LoopMicroOpBufferSize
expr_stmt|;
else|else
return|return;
comment|// Scan the loop: don't unroll loops with calls.
for|for
control|(
name|Loop
operator|::
name|block_iterator
name|I
operator|=
name|L
operator|->
name|block_begin
argument_list|()
operator|,
name|E
operator|=
name|L
operator|->
name|block_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BasicBlock
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
for|for
control|(
name|BasicBlock
operator|::
name|iterator
name|J
operator|=
name|BB
operator|->
name|begin
argument_list|()
operator|,
name|JE
operator|=
name|BB
operator|->
name|end
argument_list|()
init|;
name|J
operator|!=
name|JE
condition|;
operator|++
name|J
control|)
if|if
condition|(
name|isa
operator|<
name|CallInst
operator|>
operator|(
name|J
operator|)
operator|||
name|isa
operator|<
name|InvokeInst
operator|>
operator|(
name|J
operator|)
condition|)
block|{
name|ImmutableCallSite
name|CS
argument_list|(
operator|&
operator|*
name|J
argument_list|)
decl_stmt|;
if|if
condition|(
specifier|const
name|Function
modifier|*
name|F
init|=
name|CS
operator|.
name|getCalledFunction
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|isLoweredToCall
argument_list|(
name|F
argument_list|)
condition|)
continue|continue;
block|}
return|return;
block|}
block|}
comment|// Enable runtime and partial unrolling up to the specified size.
name|UP
operator|.
name|Partial
operator|=
name|UP
operator|.
name|Runtime
operator|=
name|true
expr_stmt|;
name|UP
operator|.
name|PartialThreshold
operator|=
name|UP
operator|.
name|PartialOptSizeThreshold
operator|=
name|MaxOps
expr_stmt|;
block|}
comment|/// @}
comment|/// \name Vector TTI Implementations
comment|/// @{
name|unsigned
name|getNumberOfRegisters
parameter_list|(
name|bool
name|Vector
parameter_list|)
block|{
return|return
name|Vector
condition|?
literal|0
else|:
literal|1
return|;
block|}
name|unsigned
name|getRegisterBitWidth
parameter_list|(
name|bool
name|Vector
parameter_list|)
block|{
return|return
literal|32
return|;
block|}
name|unsigned
name|getMaxInterleaveFactor
parameter_list|(
name|unsigned
name|VF
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getArithmeticInstrCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd1Info
operator|=
name|TTI
operator|::
name|OK_AnyValue
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd2Info
operator|=
name|TTI
operator|::
name|OK_AnyValue
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd1PropInfo
operator|=
name|TTI
operator|::
name|OP_None
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd2PropInfo
operator|=
name|TTI
operator|::
name|OP_None
argument_list|)
block|{
comment|// Check if any of the operands are vector operands.
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|bool
name|IsFloat
init|=
name|Ty
operator|->
name|getScalarType
argument_list|()
operator|->
name|isFloatingPointTy
argument_list|()
decl_stmt|;
comment|// Assume that floating point arithmetic operations cost twice as much as
comment|// integer operations.
name|unsigned
name|OpCost
init|=
operator|(
name|IsFloat
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// The operation is legal. Assume it costs 1.
comment|// TODO: Once we have extract/insert subvector cost we need to use them.
return|return
name|LT
operator|.
name|first
operator|*
name|OpCost
return|;
block|}
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// If the operation is custom lowered then assume
comment|// thare the code is twice as expensive.
return|return
name|LT
operator|.
name|first
operator|*
literal|2
operator|*
name|OpCost
return|;
block|}
comment|// Else, assume that we need to scalarize this op.
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|Num
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
operator|->
name|getScalarType
argument_list|()
argument_list|)
decl_stmt|;
comment|// return the cost of multiple scalar invocation plus the cost of
comment|// inserting
comment|// and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// We don't know anything about this scalar instruction.
return|return
name|OpCost
return|;
block|}
name|unsigned
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|ShuffleKind
name|Kind
argument_list|,
name|Type
operator|*
name|Tp
argument_list|,
name|int
name|Index
argument_list|,
name|Type
operator|*
name|SubTp
argument_list|)
block|{
if|if
condition|(
name|Kind
operator|==
name|TTI
operator|::
name|SK_Alternate
condition|)
block|{
return|return
name|getAltShuffleOverhead
argument_list|(
name|Tp
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
name|unsigned
name|getCastInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Dst
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|SrcLT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|DstLT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Dst
argument_list|)
expr_stmt|;
comment|// Check for NOOP conversions.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|SrcLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
operator|==
name|DstLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// Bitcast between types that are legalized to the same type are free.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
operator|||
name|Opcode
operator|==
name|Instruction
operator|::
name|Trunc
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Trunc
operator|&&
name|TLI
operator|->
name|isTruncateFree
argument_list|(
name|SrcLT
operator|.
name|second
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
operator|&&
name|TLI
operator|->
name|isZExtFree
argument_list|(
name|SrcLT
operator|.
name|second
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// If the cast is marked as legal (or promote) then assume low cost.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|1
return|;
comment|// Handle scalar conversions.
if|if
condition|(
operator|!
name|Src
operator|->
name|isVectorTy
argument_list|()
operator|&&
operator|!
name|Dst
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
comment|// Scalar bitcasts are usually free.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
condition|)
return|return
literal|0
return|;
comment|// Just check the op cost. If the operation is legal then assume it costs
comment|// 1.
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
literal|1
return|;
comment|// Assume that illegal scalar instruction are expensive.
return|return
literal|4
return|;
block|}
comment|// Check vector-to-vector casts.
if|if
condition|(
name|Dst
operator|->
name|isVectorTy
argument_list|()
operator|&&
name|Src
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
comment|// If the cast is between same-sized registers, then the check is simple.
if|if
condition|(
name|SrcLT
operator|.
name|first
operator|==
name|DstLT
operator|.
name|first
operator|&&
name|SrcLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
operator|==
name|DstLT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// Assume that Zext is done using AND.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|ZExt
condition|)
return|return
literal|1
return|;
comment|// Assume that sext is done using SHL and SRA.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|SExt
condition|)
return|return
literal|2
return|;
comment|// Just check the op cost. If the operation is legal then assume it
comment|// costs
comment|// 1 and multiply by the type-legalization overhead.
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|DstLT
operator|.
name|second
argument_list|)
condition|)
return|return
name|SrcLT
operator|.
name|first
operator|*
literal|1
return|;
block|}
comment|// If we are converting vectors and the operation is illegal, or
comment|// if the vectors are legalized to different types, estimate the
comment|// scalarization costs.
name|unsigned
name|Num
init|=
name|Dst
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCastInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Dst
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|Src
operator|->
name|getScalarType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Return the cost of multiple scalar invocation plus the cost of
comment|// inserting and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|Dst
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// We already handled vector-to-vector and scalar-to-scalar conversions.
comment|// This
comment|// is where we handle bitcast between vectors and scalars. We need to assume
comment|//  that the conversion is scalarized in one way or another.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|BitCast
condition|)
comment|// Illegal bitcasts are done by storing and loading from a stack slot.
return|return
operator|(
name|Src
operator|->
name|isVectorTy
argument_list|()
condition|?
name|getScalarizationOverhead
argument_list|(
name|Src
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|Dst
operator|->
name|isVectorTy
argument_list|()
condition|?
name|getScalarizationOverhead
argument_list|(
name|Dst
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
else|:
literal|0
operator|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Unhandled cast"
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|getCFInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
comment|// Branches are assumed to be predicted.
return|return
literal|0
return|;
block|}
name|unsigned
name|getCmpSelInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|ValTy
parameter_list|,
name|Type
modifier|*
name|CondTy
parameter_list|)
block|{
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|int
name|ISD
init|=
name|TLI
operator|->
name|InstructionOpcodeToISD
argument_list|(
name|Opcode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ISD
operator|&&
literal|"Invalid opcode"
argument_list|)
expr_stmt|;
comment|// Selects on vectors are actually vector selects.
if|if
condition|(
name|ISD
operator|==
name|ISD
operator|::
name|SELECT
condition|)
block|{
name|assert
argument_list|(
name|CondTy
operator|&&
literal|"CondTy must exist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CondTy
operator|->
name|isVectorTy
argument_list|()
condition|)
name|ISD
operator|=
name|ISD
operator|::
name|VSELECT
expr_stmt|;
block|}
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|ValTy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ValTy
operator|->
name|isVectorTy
argument_list|()
operator|&&
operator|!
name|LT
operator|.
name|second
operator|.
name|isVector
argument_list|()
operator|)
operator|&&
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// The operation is legal. Assume it costs 1. Multiply
comment|// by the type-legalization overhead.
return|return
name|LT
operator|.
name|first
operator|*
literal|1
return|;
block|}
comment|// Otherwise, assume that the cast is scalarized.
if|if
condition|(
name|ValTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|Num
init|=
name|ValTy
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
if|if
condition|(
name|CondTy
condition|)
name|CondTy
operator|=
name|CondTy
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCmpSelInstrCost
argument_list|(
name|Opcode
argument_list|,
name|ValTy
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|CondTy
argument_list|)
decl_stmt|;
comment|// Return the cost of multiple scalar invocation plus the cost of
comment|// inserting
comment|// and extracting the values.
return|return
name|getScalarizationOverhead
argument_list|(
name|ValTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|+
name|Num
operator|*
name|Cost
return|;
block|}
comment|// Unknown scalar opcode.
return|return
literal|1
return|;
block|}
name|unsigned
name|getVectorInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Val
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Val
operator|->
name|getScalarType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|LT
operator|.
name|first
return|;
block|}
name|unsigned
name|getMemoryOpCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|unsigned
name|AddressSpace
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|Src
operator|->
name|isVoidTy
argument_list|()
operator|&&
literal|"Invalid type"
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
expr_stmt|;
comment|// Assuming that all loads of legal types cost 1.
name|unsigned
name|Cost
init|=
name|LT
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|Src
operator|->
name|isVectorTy
argument_list|()
operator|&&
name|Src
operator|->
name|getPrimitiveSizeInBits
argument_list|()
operator|<
name|LT
operator|.
name|second
operator|.
name|getSizeInBits
argument_list|()
condition|)
block|{
comment|// This is a vector load that legalizes to a larger type than the vector
comment|// itself. Unless the corresponding extending load or truncating store is
comment|// legal, then this will scalarize.
name|TargetLowering
operator|::
name|LegalizeAction
name|LA
operator|=
name|TargetLowering
operator|::
name|Expand
expr_stmt|;
name|EVT
name|MemVT
init|=
name|getTLI
argument_list|()
operator|->
name|getValueType
argument_list|(
name|DL
argument_list|,
name|Src
argument_list|)
decl_stmt|;
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Store
condition|)
name|LA
operator|=
name|getTLI
argument_list|()
operator|->
name|getTruncStoreAction
argument_list|(
name|LT
operator|.
name|second
argument_list|,
name|MemVT
argument_list|)
expr_stmt|;
else|else
name|LA
operator|=
name|getTLI
argument_list|()
operator|->
name|getLoadExtAction
argument_list|(
name|ISD
operator|::
name|EXTLOAD
argument_list|,
name|LT
operator|.
name|second
argument_list|,
name|MemVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LA
operator|!=
name|TargetLowering
operator|::
name|Legal
operator|&&
name|LA
operator|!=
name|TargetLowering
operator|::
name|Custom
condition|)
block|{
comment|// This is a vector load/store for some illegal type that is scalarized.
comment|// We must account for the cost of building or decomposing the vector.
name|Cost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Src
argument_list|,
name|Opcode
operator|!=
name|Instruction
operator|::
name|Store
argument_list|,
name|Opcode
operator|==
name|Instruction
operator|::
name|Store
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Cost
return|;
block|}
name|unsigned
name|getInterleavedMemoryOpCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|VecTy
argument_list|,
name|unsigned
name|Factor
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Indices
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|unsigned
name|AddressSpace
argument_list|)
block|{
name|VectorType
modifier|*
name|VT
init|=
name|dyn_cast
operator|<
name|VectorType
operator|>
operator|(
name|VecTy
operator|)
decl_stmt|;
name|assert
argument_list|(
name|VT
operator|&&
literal|"Expect a vector type for interleaved memory op"
argument_list|)
expr_stmt|;
name|unsigned
name|NumElts
init|=
name|VT
operator|->
name|getNumElements
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|Factor
operator|>
literal|1
operator|&&
name|NumElts
operator|%
name|Factor
operator|==
literal|0
operator|&&
literal|"Invalid interleave factor"
argument_list|)
expr_stmt|;
name|unsigned
name|NumSubElts
init|=
name|NumElts
operator|/
name|Factor
decl_stmt|;
name|VectorType
modifier|*
name|SubVT
init|=
name|VectorType
operator|::
name|get
argument_list|(
name|VT
operator|->
name|getElementType
argument_list|()
argument_list|,
name|NumSubElts
argument_list|)
decl_stmt|;
comment|// Firstly, the cost of load/store operation.
name|unsigned
name|Cost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMemoryOpCost
argument_list|(
name|Opcode
argument_list|,
name|VecTy
argument_list|,
name|Alignment
argument_list|,
name|AddressSpace
argument_list|)
decl_stmt|;
comment|// Then plus the cost of interleave operation.
if|if
condition|(
name|Opcode
operator|==
name|Instruction
operator|::
name|Load
condition|)
block|{
comment|// The interleave cost is similar to extract sub vectors' elements
comment|// from the wide vector, and insert them into sub vectors.
comment|//
comment|// E.g. An interleaved load of factor 2 (with one member of index 0):
comment|//      %vec = load<8 x i32>,<8 x i32>* %ptr
comment|//      %v0 = shuffle %vec, undef,<0, 2, 4, 6>         ; Index 0
comment|// The cost is estimated as extract elements at 0, 2, 4, 6 from the
comment|//<8 x i32> vector and insert them into a<4 x i32> vector.
name|assert
argument_list|(
name|Indices
operator|.
name|size
argument_list|()
operator|<=
name|Factor
operator|&&
literal|"Interleaved memory op has too many members"
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|Index
range|:
name|Indices
control|)
block|{
name|assert
argument_list|(
name|Index
operator|<
name|Factor
operator|&&
literal|"Invalid index for interleaved memory op"
argument_list|)
expr_stmt|;
comment|// Extract elements from loaded vector for each sub vector.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|VT
argument_list|,
name|Index
operator|+
name|i
operator|*
name|Factor
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|InsSubCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|InsSubCost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|SubVT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|Indices
operator|.
name|size
argument_list|()
operator|*
name|InsSubCost
expr_stmt|;
block|}
else|else
block|{
comment|// The interleave cost is extract all elements from sub vectors, and
comment|// insert them into the wide vector.
comment|//
comment|// E.g. An interleaved store of factor 2:
comment|//      %v0_v1 = shuffle %v0, %v1,<0, 4, 1, 5, 2, 6, 3, 7>
comment|//      store<8 x i32> %interleaved.vec,<8 x i32>* %ptr
comment|// The cost is estimated as extract all elements from both<4 x i32>
comment|// vectors and insert into the<8 x i32> vector.
name|unsigned
name|ExtSubCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumSubElts
condition|;
name|i
operator|++
control|)
name|ExtSubCost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|ExtractElement
argument_list|,
name|SubVT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Cost
operator|+=
name|ExtSubCost
operator|*
name|Factor
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumElts
condition|;
name|i
operator|++
control|)
name|Cost
operator|+=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getVectorInstrCost
argument_list|(
name|Instruction
operator|::
name|InsertElement
argument_list|,
name|VT
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|Cost
return|;
block|}
comment|/// Get intrinsic cost based on arguments
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|)
block|{
switch|switch
condition|(
name|IID
condition|)
block|{
default|default:
block|{
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|Types
expr_stmt|;
for|for
control|(
name|Value
modifier|*
name|Op
range|:
name|Args
control|)
name|Types
operator|.
name|push_back
argument_list|(
name|Op
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|Types
argument_list|)
return|;
block|}
case|case
name|Intrinsic
operator|::
name|masked_scatter
case|:
block|{
name|Value
modifier|*
name|Mask
init|=
name|Args
index|[
literal|3
index|]
decl_stmt|;
name|bool
name|VarMask
init|=
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Mask
operator|)
decl_stmt|;
name|unsigned
name|Alignment
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Args
index|[
literal|2
index|]
operator|)
operator|->
name|getZExtValue
argument_list|()
decl_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getGatherScatterOpCost
argument_list|(
name|Instruction
operator|::
name|Store
argument_list|,
name|Args
index|[
literal|0
index|]
operator|->
name|getType
argument_list|()
argument_list|,
name|Args
index|[
literal|1
index|]
argument_list|,
name|VarMask
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
case|case
name|Intrinsic
operator|::
name|masked_gather
case|:
block|{
name|Value
modifier|*
name|Mask
init|=
name|Args
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|VarMask
init|=
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Mask
operator|)
decl_stmt|;
name|unsigned
name|Alignment
init|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Args
index|[
literal|1
index|]
operator|)
operator|->
name|getZExtValue
argument_list|()
decl_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getGatherScatterOpCost
argument_list|(
name|Instruction
operator|::
name|Load
argument_list|,
name|RetTy
argument_list|,
name|Args
index|[
literal|0
index|]
argument_list|,
name|VarMask
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
block|}
block|}
comment|/// Get intrinsic cost based on argument types
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|)
block|{
name|unsigned
name|ISD
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|IID
condition|)
block|{
default|default:
block|{
comment|// Assume that we need to scalarize this intrinsic.
name|unsigned
name|ScalarizationCost
init|=
literal|0
decl_stmt|;
name|unsigned
name|ScalarCalls
init|=
literal|1
decl_stmt|;
name|Type
modifier|*
name|ScalarRetTy
init|=
name|RetTy
decl_stmt|;
if|if
condition|(
name|RetTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|ScalarizationCost
operator|=
name|getScalarizationOverhead
argument_list|(
name|RetTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|RetTy
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
name|ScalarRetTy
operator|=
name|RetTy
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
block|}
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|ScalarTys
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
name|Type
modifier|*
name|Ty
init|=
name|Tys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|ScalarizationCost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|Ty
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
block|}
name|ScalarTys
operator|.
name|push_back
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ScalarCalls
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|// Return cost of a scalar intrinsic. Assume it to be cheap.
name|unsigned
name|ScalarCost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|ScalarRetTy
argument_list|,
name|ScalarTys
argument_list|)
decl_stmt|;
return|return
name|ScalarCalls
operator|*
name|ScalarCost
operator|+
name|ScalarizationCost
return|;
block|}
comment|// Look for intrinsics that can be lowered directly or turned into a scalar
comment|// intrinsic call.
case|case
name|Intrinsic
operator|::
name|sqrt
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FSQRT
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|sin
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FSIN
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|cos
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FCOS
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|exp
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FEXP
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|exp2
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FEXP2
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FLOG
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log10
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FLOG10
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|log2
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FLOG2
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fabs
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FABS
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|minnum
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FMINNUM
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|maxnum
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FMAXNUM
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|copysign
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FCOPYSIGN
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|floor
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FFLOOR
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|ceil
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FCEIL
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|trunc
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FTRUNC
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|nearbyint
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FNEARBYINT
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|rint
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FRINT
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|round
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FROUND
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|pow
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FPOW
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fma
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FMA
expr_stmt|;
break|break;
case|case
name|Intrinsic
operator|::
name|fmuladd
case|:
name|ISD
operator|=
name|ISD
operator|::
name|FMA
expr_stmt|;
break|break;
comment|// FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.
case|case
name|Intrinsic
operator|::
name|lifetime_start
case|:
case|case
name|Intrinsic
operator|::
name|lifetime_end
case|:
return|return
literal|0
return|;
case|case
name|Intrinsic
operator|::
name|masked_store
case|:
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMaskedMemoryOpCost
argument_list|(
name|Instruction
operator|::
name|Store
argument_list|,
name|Tys
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|Intrinsic
operator|::
name|masked_load
case|:
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getMaskedMemoryOpCost
argument_list|(
name|Instruction
operator|::
name|Load
argument_list|,
name|RetTy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
init|=
name|getTLI
argument_list|()
decl_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|TLI
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|RetTy
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLI
operator|->
name|isOperationLegalOrPromote
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// The operation is legal. Assume it costs 1.
comment|// If the type is split to multiple registers, assume that there is some
comment|// overhead to this.
comment|// TODO: Once we have extract/insert subvector cost we need to use them.
if|if
condition|(
name|LT
operator|.
name|first
operator|>
literal|1
condition|)
return|return
name|LT
operator|.
name|first
operator|*
literal|2
return|;
return|return
name|LT
operator|.
name|first
operator|*
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|TLI
operator|->
name|isOperationExpand
argument_list|(
name|ISD
argument_list|,
name|LT
operator|.
name|second
argument_list|)
condition|)
block|{
comment|// If the operation is custom lowered then assume
comment|// thare the code is twice as expensive.
return|return
name|LT
operator|.
name|first
operator|*
literal|2
return|;
block|}
comment|// If we can't lower fmuladd into an FMA estimate the cost as a floating
comment|// point mul followed by an add.
if|if
condition|(
name|IID
operator|==
name|Intrinsic
operator|::
name|fmuladd
condition|)
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|BinaryOperator
operator|::
name|FMul
argument_list|,
name|RetTy
argument_list|)
operator|+
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|BinaryOperator
operator|::
name|FAdd
argument_list|,
name|RetTy
argument_list|)
return|;
comment|// Else, assume that we need to scalarize this intrinsic. For math builtins
comment|// this will emit a costly libcall, adding call overhead and spills. Make it
comment|// very expensive.
if|if
condition|(
name|RetTy
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|unsigned
name|ScalarizationCost
init|=
name|getScalarizationOverhead
argument_list|(
name|RetTy
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|unsigned
name|ScalarCalls
init|=
name|RetTy
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|4
operator|>
name|ScalarTys
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
name|Type
modifier|*
name|Ty
init|=
name|Tys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
condition|)
name|Ty
operator|=
name|Ty
operator|->
name|getScalarType
argument_list|()
expr_stmt|;
name|ScalarTys
operator|.
name|push_back
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|ScalarCost
init|=
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicInstrCost
argument_list|(
name|IID
argument_list|,
name|RetTy
operator|->
name|getScalarType
argument_list|()
argument_list|,
name|ScalarTys
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|ie
init|=
name|Tys
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|ie
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Tys
index|[
name|i
index|]
operator|->
name|isVectorTy
argument_list|()
condition|)
block|{
name|ScalarizationCost
operator|+=
name|getScalarizationOverhead
argument_list|(
name|Tys
index|[
name|i
index|]
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ScalarCalls
operator|=
name|std
operator|::
name|max
argument_list|(
name|ScalarCalls
argument_list|,
name|Tys
index|[
name|i
index|]
operator|->
name|getVectorNumElements
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ScalarCalls
operator|*
name|ScalarCost
operator|+
name|ScalarizationCost
return|;
block|}
comment|// This is going to be turned into a library call, make it expensive.
return|return
literal|10
return|;
block|}
comment|/// \brief Compute a cost of the given call instruction.
comment|///
comment|/// Compute the cost of calling function F with return type RetTy and
comment|/// argument types Tys. F might be nullptr, in this case the cost of an
comment|/// arbitrary call with the specified signature will be returned.
comment|/// This is used, for instance,  when we estimate call of a vector
comment|/// counterpart of the given function.
comment|/// \param F Called function, might be nullptr.
comment|/// \param RetTy Return value types.
comment|/// \param Tys Argument types.
comment|/// \returns The cost of Call instruction.
name|unsigned
name|getCallInstrCost
argument_list|(
name|Function
operator|*
name|F
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|)
block|{
return|return
literal|10
return|;
block|}
name|unsigned
name|getNumberOfParts
parameter_list|(
name|Type
modifier|*
name|Tp
parameter_list|)
block|{
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MVT
operator|>
name|LT
operator|=
name|getTLI
argument_list|()
operator|->
name|getTypeLegalizationCost
argument_list|(
name|DL
argument_list|,
name|Tp
argument_list|)
expr_stmt|;
return|return
name|LT
operator|.
name|first
return|;
block|}
name|unsigned
name|getAddressComputationCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|IsComplex
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getReductionCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|IsPairwise
parameter_list|)
block|{
name|assert
argument_list|(
name|Ty
operator|->
name|isVectorTy
argument_list|()
operator|&&
literal|"Expect a vector type"
argument_list|)
expr_stmt|;
name|unsigned
name|NumVecElts
init|=
name|Ty
operator|->
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|NumReduxLevels
init|=
name|Log2_32
argument_list|(
name|NumVecElts
argument_list|)
decl_stmt|;
name|unsigned
name|ArithCost
init|=
name|NumReduxLevels
operator|*
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getArithmeticInstrCost
argument_list|(
name|Opcode
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
comment|// Assume the pairwise shuffles add a cost.
name|unsigned
name|ShuffleCost
init|=
name|NumReduxLevels
operator|*
operator|(
name|IsPairwise
operator|+
literal|1
operator|)
operator|*
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|SK_ExtractSubvector
argument_list|,
name|Ty
argument_list|,
name|NumVecElts
operator|/
literal|2
argument_list|,
name|Ty
argument_list|)
decl_stmt|;
return|return
name|ShuffleCost
operator|+
name|ArithCost
operator|+
name|getScalarizationOverhead
argument_list|(
name|Ty
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/// @}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Concrete BasicTTIImpl that can be used if no further customization
end_comment

begin_comment
comment|/// is needed.
end_comment

begin_decl_stmt
name|class
name|BasicTTIImpl
range|:
name|public
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
block|{
typedef|typedef
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
name|BaseT
expr_stmt|;
name|friend
name|class
name|BasicTTIImplBase
operator|<
name|BasicTTIImpl
operator|>
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|TargetSubtargetInfo
modifier|*
name|ST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|TargetLoweringBase
modifier|*
name|TLI
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|TargetSubtargetInfo
operator|*
name|getST
argument_list|()
specifier|const
block|{
return|return
name|ST
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|TargetLoweringBase
operator|*
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function_decl
name|explicit
name|BasicTTIImpl
parameter_list|(
specifier|const
name|TargetMachine
modifier|*
name|ST
parameter_list|,
specifier|const
name|Function
modifier|&
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Provide value semantics. MSVC requires that we spell all of these out.
end_comment

begin_expr_stmt
name|BasicTTIImpl
argument_list|(
specifier|const
name|BasicTTIImpl
operator|&
name|Arg
argument_list|)
operator|:
name|BaseT
argument_list|(
name|static_cast
operator|<
specifier|const
name|BaseT
operator|&
operator|>
operator|(
name|Arg
operator|)
argument_list|)
operator|,
name|ST
argument_list|(
name|Arg
operator|.
name|ST
argument_list|)
operator|,
name|TLI
argument_list|(
argument|Arg.TLI
argument_list|)
block|{}
name|BasicTTIImpl
argument_list|(
name|BasicTTIImpl
operator|&&
name|Arg
argument_list|)
operator|:
name|BaseT
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|static_cast
operator|<
name|BaseT
operator|&
operator|>
operator|(
name|Arg
operator|)
argument_list|)
argument_list|)
operator|,
name|ST
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|ST
argument_list|)
argument_list|)
operator|,
name|TLI
argument_list|(
argument|std::move(Arg.TLI)
argument_list|)
block|{}
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

end_unit

