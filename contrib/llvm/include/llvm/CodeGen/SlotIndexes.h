begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements SlotIndex and related classes. The purpose of SlotIndex
end_comment

begin_comment
comment|// is to describe a position at which a register can become live, or cease to
end_comment

begin_comment
comment|// be live.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which
end_comment

begin_comment
comment|// is held is LiveIntervals and provides the real numbering. This allows
end_comment

begin_comment
comment|// LiveIntervals to perform largely transparent renumbering.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SLOTINDEXES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SLOTINDEXES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/IntervalMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstrBundle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
comment|/// This class represents an entry in the slot index list held in the
comment|/// SlotIndexes pass. It should not be used directly. See the
comment|/// SlotIndex& SlotIndexes classes for the public interface to this
comment|/// information.
name|class
name|IndexListEntry
range|:
name|public
name|ilist_node
operator|<
name|IndexListEntry
operator|>
block|{
name|MachineInstr
operator|*
name|mi
block|;
name|unsigned
name|index
block|;
name|public
operator|:
name|IndexListEntry
argument_list|(
argument|MachineInstr *mi
argument_list|,
argument|unsigned index
argument_list|)
operator|:
name|mi
argument_list|(
name|mi
argument_list|)
block|,
name|index
argument_list|(
argument|index
argument_list|)
block|{}
name|MachineInstr
operator|*
name|getInstr
argument_list|()
specifier|const
block|{
return|return
name|mi
return|;
block|}
name|void
name|setInstr
argument_list|(
argument|MachineInstr *mi
argument_list|)
block|{
name|this
operator|->
name|mi
operator|=
name|mi
block|;     }
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|index
return|;
block|}
name|void
name|setIndex
argument_list|(
argument|unsigned index
argument_list|)
block|{
name|this
operator|->
name|index
operator|=
name|index
block|;     }
ifdef|#
directive|ifdef
name|EXPENSIVE_CHECKS
comment|// When EXPENSIVE_CHECKS is defined, "erased" index list entries will
comment|// actually be moved to a "graveyard" list, and have their pointers
comment|// poisoned, so that dangling SlotIndex access can be reliably detected.
name|void
name|setPoison
argument_list|()
block|{
name|intptr_t
name|tmp
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|mi
operator|)
block|;
name|assert
argument_list|(
operator|(
operator|(
name|tmp
operator|&
literal|0x1
operator|)
operator|==
literal|0x0
operator|)
operator|&&
literal|"Pointer already poisoned?"
argument_list|)
block|;
name|tmp
operator||=
literal|0x1
block|;
name|mi
operator|=
name|reinterpret_cast
operator|<
name|MachineInstr
operator|*
operator|>
operator|(
name|tmp
operator|)
block|;     }
name|bool
name|isPoisoned
argument_list|()
specifier|const
block|{
return|return
operator|(
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|mi
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|0x1
return|;
block|}
endif|#
directive|endif
comment|// EXPENSIVE_CHECKS
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ilist_alloc_traits
operator|<
name|IndexListEntry
operator|>
operator|:
name|public
name|ilist_noalloc_traits
operator|<
name|IndexListEntry
operator|>
block|{}
block|;
comment|/// SlotIndex - An opaque wrapper around machine indexes.
name|class
name|SlotIndex
block|{
name|friend
name|class
name|SlotIndexes
block|;      enum
name|Slot
block|{
comment|/// Basic block boundary.  Used for live ranges entering and leaving a
comment|/// block without being live in the layout neighbor.  Also used as the
comment|/// def slot of PHI-defs.
name|Slot_Block
block|,
comment|/// Early-clobber register use/def slot.  A live range defined at
comment|/// Slot_EarlyClobber interferes with normal live ranges killed at
comment|/// Slot_Register.  Also used as the kill slot for live ranges tied to an
comment|/// early-clobber def.
name|Slot_EarlyClobber
block|,
comment|/// Normal register use/def slot.  Normal instructions kill and define
comment|/// register live ranges at this slot.
name|Slot_Register
block|,
comment|/// Dead def kill point.  Kill slot for a live range that is defined by
comment|/// the same instruction (Slot_Register or Slot_EarlyClobber), but isn't
comment|/// used anywhere.
name|Slot_Dead
block|,
name|Slot_Count
block|}
block|;
name|PointerIntPair
operator|<
name|IndexListEntry
operator|*
block|,
literal|2
block|,
name|unsigned
operator|>
name|lie
block|;
name|SlotIndex
argument_list|(
argument|IndexListEntry *entry
argument_list|,
argument|unsigned slot
argument_list|)
operator|:
name|lie
argument_list|(
argument|entry
argument_list|,
argument|slot
argument_list|)
block|{}
name|IndexListEntry
operator|*
name|listEntry
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
operator|&&
literal|"Attempt to compare reserved index."
argument_list|)
block|;
ifdef|#
directive|ifdef
name|EXPENSIVE_CHECKS
name|assert
argument_list|(
operator|!
name|lie
operator|.
name|getPointer
argument_list|()
operator|->
name|isPoisoned
argument_list|()
operator|&&
literal|"Attempt to access deleted list-entry."
argument_list|)
block|;
endif|#
directive|endif
comment|// EXPENSIVE_CHECKS
return|return
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator||
name|getSlot
argument_list|()
return|;
block|}
comment|/// Returns the slot for this SlotIndex.
name|Slot
name|getSlot
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Slot
operator|>
operator|(
name|lie
operator|.
name|getInt
argument_list|()
operator|)
return|;
block|}
name|public
operator|:
expr|enum
block|{
comment|/// The default distance between instructions as returned by distance().
comment|/// This may vary as instructions are inserted and removed.
name|InstrDist
operator|=
literal|4
operator|*
name|Slot_Count
block|}
block|;
comment|/// Construct an invalid index.
name|SlotIndex
argument_list|()
operator|:
name|lie
argument_list|(
argument|nullptr
argument_list|,
literal|0
argument_list|)
block|{}
comment|// Construct a new slot index from the given one, and set the slot.
name|SlotIndex
argument_list|(
argument|const SlotIndex&li
argument_list|,
argument|Slot s
argument_list|)
operator|:
name|lie
argument_list|(
argument|li.listEntry()
argument_list|,
argument|unsigned(s)
argument_list|)
block|{
name|assert
argument_list|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|!=
name|nullptr
operator|&&
literal|"Attempt to construct index with 0 pointer."
argument_list|)
block|;     }
comment|/// Returns true if this is a valid index. Invalid indices do
comment|/// not point into an index table, and cannot be compared.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// Return true for a valid index.
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|isValid
argument_list|()
return|;
block|}
comment|/// Print this index to the given raw_ostream.
name|void
name|print
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
comment|/// Dump this index to stderr.
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// Compare two SlotIndex objects for equality.
name|bool
name|operator
operator|==
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|lie
operator|==
name|other
operator|.
name|lie
return|;
block|}
comment|/// Compare two SlotIndex objects for inequality.
name|bool
name|operator
operator|!=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|lie
operator|!=
name|other
operator|.
name|lie
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is strictly lower than the second.
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is lower than, or equal to, the second.
name|bool
name|operator
operator|<=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than the second.
name|bool
name|operator
operator|>
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than, or equal to, the second.
name|bool
name|operator
operator|>=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// isSameInstr - Return true if A and B refer to the same instruction.
specifier|static
name|bool
name|isSameInstr
argument_list|(
argument|SlotIndex A
argument_list|,
argument|SlotIndex B
argument_list|)
block|{
return|return
name|A
operator|.
name|lie
operator|.
name|getPointer
argument_list|()
operator|==
name|B
operator|.
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// isEarlierInstr - Return true if A refers to an instruction earlier than
comment|/// B. This is equivalent to A< B&& !isSameInstr(A, B).
specifier|static
name|bool
name|isEarlierInstr
argument_list|(
argument|SlotIndex A
argument_list|,
argument|SlotIndex B
argument_list|)
block|{
return|return
name|A
operator|.
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|<
name|B
operator|.
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
return|;
block|}
comment|/// Return true if A refers to the same instruction as B or an earlier one.
comment|/// This is equivalent to !isEarlierInstr(B, A).
specifier|static
name|bool
name|isEarlierEqualInstr
argument_list|(
argument|SlotIndex A
argument_list|,
argument|SlotIndex B
argument_list|)
block|{
return|return
operator|!
name|isEarlierInstr
argument_list|(
name|B
argument_list|,
name|A
argument_list|)
return|;
block|}
comment|/// Return the distance from this index to the given one.
name|int
name|distance
argument_list|(
argument|SlotIndex other
argument_list|)
specifier|const
block|{
return|return
name|other
operator|.
name|getIndex
argument_list|()
operator|-
name|getIndex
argument_list|()
return|;
block|}
comment|/// Return the scaled distance from this index to the given one, where all
comment|/// slots on the same instruction have zero distance.
name|int
name|getInstrDistance
argument_list|(
argument|SlotIndex other
argument_list|)
specifier|const
block|{
return|return
operator|(
name|other
operator|.
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|-
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|)
operator|/
name|Slot_Count
return|;
block|}
comment|/// isBlock - Returns true if this is a block boundary slot.
name|bool
name|isBlock
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Block
return|;
block|}
comment|/// isEarlyClobber - Returns true if this is an early-clobber slot.
name|bool
name|isEarlyClobber
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_EarlyClobber
return|;
block|}
comment|/// isRegister - Returns true if this is a normal register use/def slot.
comment|/// Note that early-clobber slots may also be used for uses and defs.
name|bool
name|isRegister
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Register
return|;
block|}
comment|/// isDead - Returns true if this is a dead def kill slot.
name|bool
name|isDead
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Dead
return|;
block|}
comment|/// Returns the base index for associated with this index. The base index
comment|/// is the one associated with the Slot_Block slot for the instruction
comment|/// pointed to by this index.
name|SlotIndex
name|getBaseIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Block
argument_list|)
return|;
block|}
comment|/// Returns the boundary index for associated with this index. The boundary
comment|/// index is the one associated with the Slot_Block slot for the instruction
comment|/// pointed to by this index.
name|SlotIndex
name|getBoundaryIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
comment|/// Returns the register use/def slot in the current instruction for a
comment|/// normal or early-clobber def.
name|SlotIndex
name|getRegSlot
argument_list|(
argument|bool EC = false
argument_list|)
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|EC
operator|?
name|Slot_EarlyClobber
operator|:
name|Slot_Register
argument_list|)
return|;
block|}
comment|/// Returns the dead def kill slot for the current instruction.
name|SlotIndex
name|getDeadSlot
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
comment|/// Returns the next slot in the index list. This could be either the
comment|/// next slot for the instruction pointed to by this index or, if this
comment|/// index is a STORE, the first slot for the next instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getNextSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|Slot_Dead
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
operator|*
operator|++
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
argument_list|,
name|Slot_Block
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|s
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the next index. This is the index corresponding to the this
comment|/// index's slot, but for the next instruction.
name|SlotIndex
name|getNextIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
operator|*
operator|++
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
comment|/// Returns the previous slot in the index list. This could be either the
comment|/// previous slot for the instruction pointed to by this index or, if this
comment|/// index is a Slot_Block, the last slot for the previous instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getPrevSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|Slot_Block
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
operator|*
operator|--
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|s
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the previous index. This is the index corresponding to this
comment|/// index's slot, but for the previous instruction.
name|SlotIndex
name|getPrevIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
operator|*
operator|--
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|SlotIndex
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|os
expr|,
name|SlotIndex
name|li
operator|)
block|{
name|li
operator|.
name|print
argument_list|(
name|os
argument_list|)
block|;
return|return
name|os
return|;
block|}
name|using
name|IdxMBBPair
operator|=
name|std
operator|::
name|pair
operator|<
name|SlotIndex
block|,
name|MachineBasicBlock
operator|*
operator|>
block|;
specifier|inline
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|V
expr|,
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|)
block|{
return|return
name|V
operator|<
name|IM
operator|.
name|first
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|IM
expr|,
name|SlotIndex
name|V
operator|)
block|{
return|return
name|IM
operator|.
name|first
operator|<
name|V
return|;
block|}
expr|struct
name|Idx2MBBCompare
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|LHS
expr|,
specifier|const
name|IdxMBBPair
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
operator|.
name|first
return|;
block|}
expr|}
block|;
comment|/// SlotIndexes pass.
comment|///
comment|/// This pass assigns indexes to each instruction.
name|class
name|SlotIndexes
operator|:
name|public
name|MachineFunctionPass
block|{
name|private
operator|:
comment|// IndexListEntry allocator.
name|BumpPtrAllocator
name|ileAllocator
block|;
name|using
name|IndexList
operator|=
name|ilist
operator|<
name|IndexListEntry
operator|>
block|;
name|IndexList
name|indexList
block|;
ifdef|#
directive|ifdef
name|EXPENSIVE_CHECKS
name|IndexList
name|graveyardList
block|;
endif|#
directive|endif
comment|// EXPENSIVE_CHECKS
name|MachineFunction
operator|*
name|mf
block|;
name|using
name|Mi2IndexMap
operator|=
name|DenseMap
operator|<
specifier|const
name|MachineInstr
operator|*
block|,
name|SlotIndex
operator|>
block|;
name|Mi2IndexMap
name|mi2iMap
block|;
comment|/// MBBRanges - Map MBB number to (start, stop) indexes.
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|SlotIndex
block|,
name|SlotIndex
operator|>
block|,
literal|8
operator|>
name|MBBRanges
block|;
comment|/// Idx2MBBMap - Sorted list of pairs of index of first instruction
comment|/// and MBB id.
name|SmallVector
operator|<
name|IdxMBBPair
block|,
literal|8
operator|>
name|idx2MBBMap
block|;
name|IndexListEntry
operator|*
name|createEntry
argument_list|(
argument|MachineInstr *mi
argument_list|,
argument|unsigned index
argument_list|)
block|{
name|IndexListEntry
operator|*
name|entry
operator|=
name|static_cast
operator|<
name|IndexListEntry
operator|*
operator|>
operator|(
name|ileAllocator
operator|.
name|Allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|IndexListEntry
argument_list|)
argument_list|,
name|alignof
argument_list|(
name|IndexListEntry
argument_list|)
argument_list|)
operator|)
block|;
name|new
argument_list|(
argument|entry
argument_list|)
name|IndexListEntry
argument_list|(
name|mi
argument_list|,
name|index
argument_list|)
block|;
return|return
name|entry
return|;
block|}
comment|/// Renumber locally after inserting curItr.
name|void
name|renumberIndexes
argument_list|(
argument|IndexList::iterator curItr
argument_list|)
block|;
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|SlotIndexes
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
argument|ID
argument_list|)
block|{
name|initializeSlotIndexesPass
argument_list|(
operator|*
name|PassRegistry
operator|::
name|getPassRegistry
argument_list|()
argument_list|)
block|;     }
operator|~
name|SlotIndexes
argument_list|()
name|override
block|{
comment|// The indexList's nodes are all allocated in the BumpPtrAllocator.
name|indexList
operator|.
name|clearAndLeakNodesUnsafely
argument_list|()
block|;     }
name|void
name|getAnalysisUsage
argument_list|(
argument|AnalysisUsage&au
argument_list|)
specifier|const
name|override
block|;
name|void
name|releaseMemory
argument_list|()
name|override
block|;
name|bool
name|runOnMachineFunction
argument_list|(
argument|MachineFunction&fn
argument_list|)
name|override
block|;
comment|/// Dump the indexes.
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// Renumber the index list, providing space for new instructions.
name|void
name|renumberIndexes
argument_list|()
block|;
comment|/// Repair indexes after adding and removing instructions.
name|void
name|repairIndexesInRange
argument_list|(
argument|MachineBasicBlock *MBB
argument_list|,
argument|MachineBasicBlock::iterator Begin
argument_list|,
argument|MachineBasicBlock::iterator End
argument_list|)
block|;
comment|/// Returns the zero index for this analysis.
name|SlotIndex
name|getZeroIndex
argument_list|()
block|{
name|assert
argument_list|(
name|indexList
operator|.
name|front
argument_list|()
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
literal|"First index is not 0?"
argument_list|)
block|;
return|return
name|SlotIndex
argument_list|(
operator|&
name|indexList
operator|.
name|front
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Returns the base index of the last slot in this analysis.
name|SlotIndex
name|getLastIndex
argument_list|()
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|indexList
operator|.
name|back
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Returns true if the given machine instr is mapped to an index,
comment|/// otherwise returns false.
name|bool
name|hasIndex
argument_list|(
argument|const MachineInstr&instr
argument_list|)
specifier|const
block|{
return|return
name|mi2iMap
operator|.
name|count
argument_list|(
operator|&
name|instr
argument_list|)
return|;
block|}
comment|/// Returns the base index for the given instruction.
name|SlotIndex
name|getInstructionIndex
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|{
comment|// Instructions inside a bundle have the same number as the bundle itself.
specifier|const
name|MachineInstr
operator|&
name|BundleStart
operator|=
operator|*
name|getBundleStart
argument_list|(
name|MI
operator|.
name|getIterator
argument_list|()
argument_list|)
block|;
name|Mi2IndexMap
operator|::
name|const_iterator
name|itr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
operator|&
name|BundleStart
argument_list|)
block|;
name|assert
argument_list|(
name|itr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instruction not found in maps."
argument_list|)
block|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|/// Returns the instruction for the given index, or null if the given
comment|/// index has no instruction associated with it.
name|MachineInstr
operator|*
name|getInstructionFromIndex
argument_list|(
argument|SlotIndex index
argument_list|)
specifier|const
block|{
return|return
name|index
operator|.
name|isValid
argument_list|()
operator|?
name|index
operator|.
name|listEntry
argument_list|()
operator|->
name|getInstr
argument_list|()
operator|:
name|nullptr
return|;
block|}
comment|/// Returns the next non-null index, if one exists.
comment|/// Otherwise returns getLastIndex().
name|SlotIndex
name|getNextNonNullIndex
argument_list|(
argument|SlotIndex Index
argument_list|)
block|{
name|IndexList
operator|::
name|iterator
name|I
operator|=
name|Index
operator|.
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
block|;
name|IndexList
operator|::
name|iterator
name|E
operator|=
name|indexList
operator|.
name|end
argument_list|()
block|;
while|while
condition|(
operator|++
name|I
operator|!=
name|E
condition|)
if|if
condition|(
name|I
operator|->
name|getInstr
argument_list|()
condition|)
return|return
name|SlotIndex
argument_list|(
operator|&
operator|*
name|I
argument_list|,
name|Index
operator|.
name|getSlot
argument_list|()
argument_list|)
return|;
comment|// We reached the end of the function.
return|return
name|getLastIndex
argument_list|()
return|;
block|}
comment|/// getIndexBefore - Returns the index of the last indexed instruction
comment|/// before MI, or the start index of its basic block.
comment|/// MI is not required to have an index.
name|SlotIndex
name|getIndexBefore
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|{
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
operator|=
name|MI
operator|.
name|getParent
argument_list|()
block|;
name|assert
argument_list|(
name|MBB
operator|&&
literal|"MI must be inserted inna basic block"
argument_list|)
block|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|I
operator|=
name|MI
block|,
name|B
operator|=
name|MBB
operator|->
name|begin
argument_list|()
block|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|I
operator|==
name|B
condition|)
return|return
name|getMBBStartIdx
argument_list|(
name|MBB
argument_list|)
return|;
operator|--
name|I
expr_stmt|;
name|Mi2IndexMap
operator|::
name|const_iterator
name|MapItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
operator|&
operator|*
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|MapItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|MapItr
operator|->
name|second
return|;
block|}
block|}
comment|/// getIndexAfter - Returns the index of the first indexed instruction
comment|/// after MI, or the end index of its basic block.
comment|/// MI is not required to have an index.
name|SlotIndex
name|getIndexAfter
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|{
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
operator|=
name|MI
operator|.
name|getParent
argument_list|()
block|;
name|assert
argument_list|(
name|MBB
operator|&&
literal|"MI must be inserted inna basic block"
argument_list|)
block|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|I
operator|=
name|MI
block|,
name|E
operator|=
name|MBB
operator|->
name|end
argument_list|()
block|;
while|while
condition|(
name|true
condition|)
block|{
operator|++
name|I
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|E
condition|)
return|return
name|getMBBEndIdx
argument_list|(
name|MBB
argument_list|)
return|;
name|Mi2IndexMap
operator|::
name|const_iterator
name|MapItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
operator|&
operator|*
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|MapItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|MapItr
operator|->
name|second
return|;
block|}
block|}
comment|/// Return the (start,end) range of the given basic block number.
specifier|const
name|std
operator|::
name|pair
operator|<
name|SlotIndex
block|,
name|SlotIndex
operator|>
operator|&
name|getMBBRange
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
return|return
name|MBBRanges
index|[
name|Num
index|]
return|;
block|}
comment|/// Return the (start,end) range of the given basic block.
specifier|const
name|std
operator|::
name|pair
operator|<
name|SlotIndex
block|,
name|SlotIndex
operator|>
operator|&
name|getMBBRange
argument_list|(
argument|const MachineBasicBlock *MBB
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|MBB
operator|->
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
comment|/// Returns the first index in the given basic block number.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|Num
argument_list|)
operator|.
name|first
return|;
block|}
comment|/// Returns the first index in the given basic block.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
argument|const MachineBasicBlock *mbb
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|mbb
argument_list|)
operator|.
name|first
return|;
block|}
comment|/// Returns the last index in the given basic block number.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|Num
argument_list|)
operator|.
name|second
return|;
block|}
comment|/// Returns the last index in the given basic block.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
argument|const MachineBasicBlock *mbb
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|mbb
argument_list|)
operator|.
name|second
return|;
block|}
comment|/// Iterator over the idx2MBBMap (sorted pairs of slot index of basic block
comment|/// begin and basic block)
name|using
name|MBBIndexIterator
operator|=
name|SmallVectorImpl
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
block|;
comment|/// Move iterator to the next IdxMBBPair where the SlotIndex is greater or
comment|/// equal to \p To.
name|MBBIndexIterator
name|advanceMBBIndex
argument_list|(
argument|MBBIndexIterator I
argument_list|,
argument|SlotIndex To
argument_list|)
specifier|const
block|{
return|return
name|std
operator|::
name|lower_bound
argument_list|(
name|I
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|To
argument_list|)
return|;
block|}
comment|/// Get an iterator pointing to the IdxMBBPair with the biggest SlotIndex
comment|/// that is greater or equal to \p Idx.
name|MBBIndexIterator
name|findMBBIndex
argument_list|(
argument|SlotIndex Idx
argument_list|)
specifier|const
block|{
return|return
name|advanceMBBIndex
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|Idx
argument_list|)
return|;
block|}
comment|/// Returns an iterator for the begin of the idx2MBBMap.
name|MBBIndexIterator
name|MBBIndexBegin
argument_list|()
specifier|const
block|{
return|return
name|idx2MBBMap
operator|.
name|begin
argument_list|()
return|;
block|}
comment|/// Return an iterator for the end of the idx2MBBMap.
name|MBBIndexIterator
name|MBBIndexEnd
argument_list|()
specifier|const
block|{
return|return
name|idx2MBBMap
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// Returns the basic block which the given index falls in.
name|MachineBasicBlock
operator|*
name|getMBBFromIndex
argument_list|(
argument|SlotIndex index
argument_list|)
specifier|const
block|{
if|if
condition|(
name|MachineInstr
modifier|*
name|MI
init|=
name|getInstructionFromIndex
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|MI
operator|->
name|getParent
argument_list|()
return|;
name|MBBIndexIterator
name|I
operator|=
name|findMBBIndex
argument_list|(
name|index
argument_list|)
block|;
comment|// Take the pair containing the index
name|MBBIndexIterator
name|J
operator|=
operator|(
operator|(
name|I
operator|!=
name|MBBIndexEnd
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|>
name|index
operator|)
operator|||
operator|(
name|I
operator|==
name|MBBIndexEnd
argument_list|()
operator|&&
operator|!
name|idx2MBBMap
operator|.
name|empty
argument_list|()
operator|)
operator|)
condition|?
name|std
operator|::
name|prev
argument_list|(
name|I
argument_list|)
else|:
name|I
block|;
name|assert
argument_list|(
name|J
operator|!=
name|MBBIndexEnd
argument_list|()
operator|&&
name|J
operator|->
name|first
operator|<=
name|index
operator|&&
name|index
operator|<
name|getMBBEndIdx
argument_list|(
name|J
operator|->
name|second
argument_list|)
operator|&&
literal|"index does not correspond to an MBB"
argument_list|)
block|;
return|return
name|J
operator|->
name|second
return|;
block|}
comment|/// Returns the MBB covering the given range, or null if the range covers
comment|/// more than one basic block.
name|MachineBasicBlock
operator|*
name|getMBBCoveringRange
argument_list|(
argument|SlotIndex start
argument_list|,
argument|SlotIndex end
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|start
operator|<
name|end
operator|&&
literal|"Backwards ranges not allowed."
argument_list|)
block|;
name|MBBIndexIterator
name|itr
operator|=
name|findMBBIndex
argument_list|(
name|start
argument_list|)
block|;
if|if
condition|(
name|itr
operator|==
name|MBBIndexEnd
argument_list|()
condition|)
block|{
name|itr
operator|=
name|std
operator|::
name|prev
argument_list|(
name|itr
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|// Check that we don't cross the boundary into this block.
if|if
condition|(
name|itr
operator|->
name|first
operator|<
name|end
condition|)
return|return
name|nullptr
return|;
name|itr
operator|=
name|std
operator|::
name|prev
argument_list|(
name|itr
argument_list|)
block|;
if|if
condition|(
name|itr
operator|->
name|first
operator|<=
name|start
condition|)
return|return
name|itr
operator|->
name|second
return|;
return|return
name|nullptr
return|;
block|}
comment|/// Insert the given machine instruction into the mapping. Returns the
comment|/// assigned index.
comment|/// If Late is set and there are null indexes between mi's neighboring
comment|/// instructions, create the new index after the null indexes instead of
comment|/// before them.
name|SlotIndex
name|insertMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|&
name|MI
parameter_list|,
name|bool
name|Late
init|=
name|false
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|MI
operator|.
name|isInsideBundle
argument_list|()
operator|&&
literal|"Instructions inside bundles should use bundle start's slot."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mi2iMap
operator|.
name|find
argument_list|(
operator|&
name|MI
argument_list|)
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instr already indexed."
argument_list|)
expr_stmt|;
comment|// Numbering DBG_VALUE instructions could cause code generation to be
comment|// affected by debug information.
name|assert
argument_list|(
operator|!
name|MI
operator|.
name|isDebugValue
argument_list|()
operator|&&
literal|"Cannot number DBG_VALUE instructions."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|MI
operator|.
name|getParent
argument_list|()
operator|!=
name|nullptr
operator|&&
literal|"Instr must be added to function."
argument_list|)
expr_stmt|;
comment|// Get the entries where MI should be inserted.
name|IndexList
operator|::
name|iterator
name|prevItr
operator|,
name|nextItr
expr_stmt|;
if|if
condition|(
name|Late
condition|)
block|{
comment|// Insert MI's index immediately before the following instruction.
name|nextItr
operator|=
name|getIndexAfter
argument_list|(
name|MI
argument_list|)
operator|.
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
expr_stmt|;
name|prevItr
operator|=
name|std
operator|::
name|prev
argument_list|(
name|nextItr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert MI's index immediately after the preceding instruction.
name|prevItr
operator|=
name|getIndexBefore
argument_list|(
name|MI
argument_list|)
operator|.
name|listEntry
argument_list|()
operator|->
name|getIterator
argument_list|()
expr_stmt|;
name|nextItr
operator|=
name|std
operator|::
name|next
argument_list|(
name|prevItr
argument_list|)
expr_stmt|;
block|}
comment|// Get a number for the new instr, or 0 if there's no room currently.
comment|// In the latter case we'll force a renumber later.
name|unsigned
name|dist
init|=
operator|(
operator|(
name|nextItr
operator|->
name|getIndex
argument_list|()
operator|-
name|prevItr
operator|->
name|getIndex
argument_list|()
operator|)
operator|/
literal|2
operator|)
operator|&
operator|~
literal|3u
decl_stmt|;
name|unsigned
name|newNumber
init|=
name|prevItr
operator|->
name|getIndex
argument_list|()
operator|+
name|dist
decl_stmt|;
comment|// Insert a new list entry for MI.
name|IndexList
operator|::
name|iterator
name|newItr
operator|=
name|indexList
operator|.
name|insert
argument_list|(
name|nextItr
argument_list|,
name|createEntry
argument_list|(
operator|&
name|MI
argument_list|,
name|newNumber
argument_list|)
argument_list|)
expr_stmt|;
comment|// Renumber locally if we need to.
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
name|renumberIndexes
argument_list|(
name|newItr
argument_list|)
expr_stmt|;
name|SlotIndex
name|newIndex
argument_list|(
operator|&
operator|*
name|newItr
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
name|MI
argument_list|,
name|newIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
comment|/// Removes machine instruction (bundle) \p MI from the mapping.
comment|/// This should be called before MachineInstr::eraseFromParent() is used to
comment|/// remove a whole bundle or an unbundled instruction.
name|void
name|removeMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|&
name|MI
parameter_list|)
function_decl|;
comment|/// Removes a single machine instruction \p MI from the mapping.
comment|/// This should be called before MachineInstr::eraseFromBundle() is used to
comment|/// remove a single instruction (out of a bundle).
name|void
name|removeSingleMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|&
name|MI
parameter_list|)
function_decl|;
comment|/// ReplaceMachineInstrInMaps - Replacing a machine instr with a new one in
comment|/// maps used by register allocator. \returns the index where the new
comment|/// instruction was inserted.
name|SlotIndex
name|replaceMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|&
name|MI
parameter_list|,
name|MachineInstr
modifier|&
name|NewMI
parameter_list|)
block|{
name|Mi2IndexMap
operator|::
name|iterator
name|mi2iItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
operator|&
name|MI
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2iItr
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|SlotIndex
argument_list|()
return|;
name|SlotIndex
name|replaceBaseIndex
init|=
name|mi2iItr
operator|->
name|second
decl_stmt|;
name|IndexListEntry
modifier|*
name|miEntry
argument_list|(
name|replaceBaseIndex
operator|.
name|listEntry
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|miEntry
operator|->
name|getInstr
argument_list|()
operator|==
operator|&
name|MI
operator|&&
literal|"Mismatched instruction in index tables."
argument_list|)
expr_stmt|;
name|miEntry
operator|->
name|setInstr
argument_list|(
operator|&
name|NewMI
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|erase
argument_list|(
name|mi2iItr
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
name|NewMI
argument_list|,
name|replaceBaseIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|replaceBaseIndex
return|;
block|}
comment|/// Add the given MachineBasicBlock into the maps.
name|void
name|insertMBBInMaps
parameter_list|(
name|MachineBasicBlock
modifier|*
name|mbb
parameter_list|)
block|{
name|MachineFunction
operator|::
name|iterator
name|nextMBB
operator|=
name|std
operator|::
name|next
argument_list|(
name|MachineFunction
operator|::
name|iterator
argument_list|(
name|mbb
argument_list|)
argument_list|)
expr_stmt|;
name|IndexListEntry
modifier|*
name|startEntry
init|=
name|nullptr
decl_stmt|;
name|IndexListEntry
modifier|*
name|endEntry
init|=
name|nullptr
decl_stmt|;
name|IndexList
operator|::
name|iterator
name|newItr
expr_stmt|;
if|if
condition|(
name|nextMBB
operator|==
name|mbb
operator|->
name|getParent
argument_list|()
operator|->
name|end
argument_list|()
condition|)
block|{
name|startEntry
operator|=
operator|&
name|indexList
operator|.
name|back
argument_list|()
expr_stmt|;
name|endEntry
operator|=
name|createEntry
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newItr
operator|=
name|indexList
operator|.
name|insertAfter
argument_list|(
name|startEntry
operator|->
name|getIterator
argument_list|()
argument_list|,
name|endEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|startEntry
operator|=
name|createEntry
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|endEntry
operator|=
name|getMBBStartIdx
argument_list|(
operator|&
operator|*
name|nextMBB
argument_list|)
operator|.
name|listEntry
argument_list|()
expr_stmt|;
name|newItr
operator|=
name|indexList
operator|.
name|insert
argument_list|(
name|endEntry
operator|->
name|getIterator
argument_list|()
argument_list|,
name|startEntry
argument_list|)
expr_stmt|;
block|}
name|SlotIndex
name|startIdx
argument_list|(
name|startEntry
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|SlotIndex
name|endIdx
argument_list|(
name|endEntry
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|MachineFunction
operator|::
name|iterator
name|prevMBB
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prevMBB
operator|!=
name|mbb
operator|->
name|getParent
argument_list|()
operator|->
name|end
argument_list|()
operator|&&
literal|"Can't insert a new block at the beginning of a function."
argument_list|)
expr_stmt|;
operator|--
name|prevMBB
expr_stmt|;
name|MBBRanges
index|[
name|prevMBB
operator|->
name|getNumber
argument_list|()
index|]
operator|.
name|second
operator|=
name|startIdx
expr_stmt|;
name|assert
argument_list|(
name|unsigned
argument_list|(
name|mbb
operator|->
name|getNumber
argument_list|()
argument_list|)
operator|==
name|MBBRanges
operator|.
name|size
argument_list|()
operator|&&
literal|"Blocks must be added in order"
argument_list|)
expr_stmt|;
name|MBBRanges
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|startIdx
argument_list|,
name|endIdx
argument_list|)
argument_list|)
expr_stmt|;
name|idx2MBBMap
operator|.
name|push_back
argument_list|(
name|IdxMBBPair
argument_list|(
name|startIdx
argument_list|,
name|mbb
argument_list|)
argument_list|)
expr_stmt|;
name|renumberIndexes
argument_list|(
name|newItr
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|Idx2MBBCompare
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Free the resources that were required to maintain a SlotIndex.
comment|///
comment|/// Once an index is no longer needed (for instance because the instruction
comment|/// at that index has been moved), the resources required to maintain the
comment|/// index can be relinquished to reduce memory use and improve renumbering
comment|/// performance. Any remaining SlotIndex objects that point to the same
comment|/// index are left 'dangling' (much the same as a dangling pointer to a
comment|/// freed object) and should not be accessed, except to destruct them.
comment|///
comment|/// Like dangling pointers, access to dangling SlotIndexes can cause
comment|/// painful-to-track-down bugs, especially if the memory for the index
comment|/// previously pointed to has been re-used. To detect dangling SlotIndex
comment|/// bugs, build with EXPENSIVE_CHECKS=1. This will cause "erased" indexes to
comment|/// be retained in a graveyard instead of being freed. Operations on indexes
comment|/// in the graveyard will trigger an assertion.
name|void
name|eraseIndex
parameter_list|(
name|SlotIndex
name|index
parameter_list|)
block|{
name|IndexListEntry
modifier|*
name|entry
init|=
name|index
operator|.
name|listEntry
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|EXPENSIVE_CHECKS
name|indexList
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|graveyardList
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|setPoison
argument_list|()
expr_stmt|;
else|#
directive|else
name|indexList
operator|.
name|erase
argument_list|(
name|entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Specialize IntervalMapInfo for half-open slot index intervals.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IntervalMapInfo
operator|<
name|SlotIndex
operator|>
operator|:
name|IntervalMapHalfOpenInfo
operator|<
name|SlotIndex
operator|>
block|{   }
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_SLOTINDEXES_H
end_comment

end_unit

