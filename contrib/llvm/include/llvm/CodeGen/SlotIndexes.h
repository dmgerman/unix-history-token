begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements SlotIndex and related classes. The purpose of SlotIndex
end_comment

begin_comment
comment|// is to describe a position at which a register can become live, or cease to
end_comment

begin_comment
comment|// be live.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which
end_comment

begin_comment
comment|// is held is LiveIntervals and provides the real numbering. This allows
end_comment

begin_comment
comment|// LiveIntervals to perform largely transparent renumbering.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_SLOTINDEXES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_SLOTINDEXES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/IntervalMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunctionPass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstrBundle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This class represents an entry in the slot index list held in the
comment|/// SlotIndexes pass. It should not be used directly. See the
comment|/// SlotIndex& SlotIndexes classes for the public interface to this
comment|/// information.
name|class
name|IndexListEntry
range|:
name|public
name|ilist_node
operator|<
name|IndexListEntry
operator|>
block|{
name|MachineInstr
operator|*
name|mi
block|;
name|unsigned
name|index
block|;
name|public
operator|:
name|IndexListEntry
argument_list|(
argument|MachineInstr *mi
argument_list|,
argument|unsigned index
argument_list|)
operator|:
name|mi
argument_list|(
name|mi
argument_list|)
block|,
name|index
argument_list|(
argument|index
argument_list|)
block|{}
name|MachineInstr
operator|*
name|getInstr
argument_list|()
specifier|const
block|{
return|return
name|mi
return|;
block|}
name|void
name|setInstr
argument_list|(
argument|MachineInstr *mi
argument_list|)
block|{
name|this
operator|->
name|mi
operator|=
name|mi
block|;     }
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|index
return|;
block|}
name|void
name|setIndex
argument_list|(
argument|unsigned index
argument_list|)
block|{
name|this
operator|->
name|index
operator|=
name|index
block|;     }
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ilist_traits
operator|<
name|IndexListEntry
operator|>
operator|:
name|public
name|ilist_default_traits
operator|<
name|IndexListEntry
operator|>
block|{
name|private
operator|:
name|mutable
name|ilist_half_node
operator|<
name|IndexListEntry
operator|>
name|Sentinel
block|;
name|public
operator|:
name|IndexListEntry
operator|*
name|createSentinel
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|IndexListEntry
operator|*
operator|>
operator|(
operator|&
name|Sentinel
operator|)
return|;
block|}
name|void
name|destroySentinel
argument_list|(
argument|IndexListEntry *
argument_list|)
specifier|const
block|{}
name|IndexListEntry
operator|*
name|provideInitialHead
argument_list|()
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
name|IndexListEntry
operator|*
name|ensureHead
argument_list|(
argument|IndexListEntry*
argument_list|)
specifier|const
block|{
return|return
name|createSentinel
argument_list|()
return|;
block|}
specifier|static
name|void
name|noteHead
argument_list|(
argument|IndexListEntry*
argument_list|,
argument|IndexListEntry*
argument_list|)
block|{}
name|void
name|deleteNode
argument_list|(
argument|IndexListEntry *N
argument_list|)
block|{}
name|private
operator|:
name|void
name|createNode
argument_list|(
specifier|const
name|IndexListEntry
operator|&
argument_list|)
block|;   }
block|;
comment|/// SlotIndex - An opaque wrapper around machine indexes.
name|class
name|SlotIndex
block|{
name|friend
name|class
name|SlotIndexes
block|;      enum
name|Slot
block|{
comment|/// Basic block boundary.  Used for live ranges entering and leaving a
comment|/// block without being live in the layout neighbor.  Also used as the
comment|/// def slot of PHI-defs.
name|Slot_Block
block|,
comment|/// Early-clobber register use/def slot.  A live range defined at
comment|/// Slot_EarlyCLobber interferes with normal live ranges killed at
comment|/// Slot_Register.  Also used as the kill slot for live ranges tied to an
comment|/// early-clobber def.
name|Slot_EarlyClobber
block|,
comment|/// Normal register use/def slot.  Normal instructions kill and define
comment|/// register live ranges at this slot.
name|Slot_Register
block|,
comment|/// Dead def kill point.  Kill slot for a live range that is defined by
comment|/// the same instruction (Slot_Register or Slot_EarlyClobber), but isn't
comment|/// used anywhere.
name|Slot_Dead
block|,
name|Slot_Count
block|}
block|;
name|PointerIntPair
operator|<
name|IndexListEntry
operator|*
block|,
literal|2
block|,
name|unsigned
operator|>
name|lie
block|;
name|SlotIndex
argument_list|(
argument|IndexListEntry *entry
argument_list|,
argument|unsigned slot
argument_list|)
operator|:
name|lie
argument_list|(
argument|entry
argument_list|,
argument|slot
argument_list|)
block|{}
name|IndexListEntry
operator|*
name|listEntry
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
operator|&&
literal|"Attempt to compare reserved index."
argument_list|)
block|;
return|return
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator||
name|getSlot
argument_list|()
return|;
block|}
comment|/// Returns the slot for this SlotIndex.
name|Slot
name|getSlot
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Slot
operator|>
operator|(
name|lie
operator|.
name|getInt
argument_list|()
operator|)
return|;
block|}
name|public
operator|:
expr|enum
block|{
comment|/// The default distance between instructions as returned by distance().
comment|/// This may vary as instructions are inserted and removed.
name|InstrDist
operator|=
literal|4
operator|*
name|Slot_Count
block|}
block|;
comment|/// Construct an invalid index.
name|SlotIndex
argument_list|()
operator|:
name|lie
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|{}
comment|// Construct a new slot index from the given one, and set the slot.
name|SlotIndex
argument_list|(
argument|const SlotIndex&li
argument_list|,
argument|Slot s
argument_list|)
operator|:
name|lie
argument_list|(
argument|li.listEntry()
argument_list|,
argument|unsigned(s)
argument_list|)
block|{
name|assert
argument_list|(
name|lie
operator|.
name|getPointer
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Attempt to construct index with 0 pointer."
argument_list|)
block|;     }
comment|/// Returns true if this is a valid index. Invalid indicies do
comment|/// not point into an index table, and cannot be compared.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// Return true for a valid index.
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|isValid
argument_list|()
return|;
block|}
comment|/// Print this index to the given raw_ostream.
name|void
name|print
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
comment|/// Dump this index to stderr.
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// Compare two SlotIndex objects for equality.
name|bool
name|operator
operator|==
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|lie
operator|==
name|other
operator|.
name|lie
return|;
block|}
comment|/// Compare two SlotIndex objects for inequality.
name|bool
name|operator
operator|!=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|lie
operator|!=
name|other
operator|.
name|lie
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is strictly lower than the second.
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is lower than, or equal to, the second.
name|bool
name|operator
operator|<=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|<=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than the second.
name|bool
name|operator
operator|>
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// Compare two SlotIndex objects. Return true if the first index
comment|/// is greater than, or equal to, the second.
name|bool
name|operator
operator|>=
operator|(
name|SlotIndex
name|other
operator|)
specifier|const
block|{
return|return
name|getIndex
argument_list|()
operator|>=
name|other
operator|.
name|getIndex
argument_list|()
return|;
block|}
comment|/// isSameInstr - Return true if A and B refer to the same instruction.
specifier|static
name|bool
name|isSameInstr
argument_list|(
argument|SlotIndex A
argument_list|,
argument|SlotIndex B
argument_list|)
block|{
return|return
name|A
operator|.
name|lie
operator|.
name|getPointer
argument_list|()
operator|==
name|B
operator|.
name|lie
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// isEarlierInstr - Return true if A refers to an instruction earlier than
comment|/// B. This is equivalent to A< B&& !isSameInstr(A, B).
specifier|static
name|bool
name|isEarlierInstr
argument_list|(
argument|SlotIndex A
argument_list|,
argument|SlotIndex B
argument_list|)
block|{
return|return
name|A
operator|.
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
operator|<
name|B
operator|.
name|listEntry
argument_list|()
operator|->
name|getIndex
argument_list|()
return|;
block|}
comment|/// Return the distance from this index to the given one.
name|int
name|distance
argument_list|(
argument|SlotIndex other
argument_list|)
specifier|const
block|{
return|return
name|other
operator|.
name|getIndex
argument_list|()
operator|-
name|getIndex
argument_list|()
return|;
block|}
comment|/// isBlock - Returns true if this is a block boundary slot.
name|bool
name|isBlock
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Block
return|;
block|}
comment|/// isEarlyClobber - Returns true if this is an early-clobber slot.
name|bool
name|isEarlyClobber
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_EarlyClobber
return|;
block|}
comment|/// isRegister - Returns true if this is a normal register use/def slot.
comment|/// Note that early-clobber slots may also be used for uses and defs.
name|bool
name|isRegister
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Register
return|;
block|}
comment|/// isDead - Returns true if this is a dead def kill slot.
name|bool
name|isDead
argument_list|()
specifier|const
block|{
return|return
name|getSlot
argument_list|()
operator|==
name|Slot_Dead
return|;
block|}
comment|/// Returns the base index for associated with this index. The base index
comment|/// is the one associated with the Slot_Block slot for the instruction
comment|/// pointed to by this index.
name|SlotIndex
name|getBaseIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Block
argument_list|)
return|;
block|}
comment|/// Returns the boundary index for associated with this index. The boundary
comment|/// index is the one associated with the Slot_Block slot for the instruction
comment|/// pointed to by this index.
name|SlotIndex
name|getBoundaryIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
comment|/// Returns the register use/def slot in the current instruction for a
comment|/// normal or early-clobber def.
name|SlotIndex
name|getRegSlot
argument_list|(
argument|bool EC = false
argument_list|)
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|EC
operator|?
name|Slot_EarlyClobber
operator|:
name|Slot_Register
argument_list|)
return|;
block|}
comment|/// Returns the dead def kill slot for the current instruction.
name|SlotIndex
name|getDeadSlot
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
comment|/// Returns the next slot in the index list. This could be either the
comment|/// next slot for the instruction pointed to by this index or, if this
comment|/// index is a STORE, the first slot for the next instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getNextSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|Slot_Dead
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
operator|->
name|getNextNode
argument_list|()
argument_list|,
name|Slot_Block
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|s
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the next index. This is the index corresponding to the this
comment|/// index's slot, but for the next instruction.
name|SlotIndex
name|getNextIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
operator|->
name|getNextNode
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
comment|/// Returns the previous slot in the index list. This could be either the
comment|/// previous slot for the instruction pointed to by this index or, if this
comment|/// index is a Slot_Block, the last slot for the previous instruction.
comment|/// WARNING: This method is considerably more expensive than the methods
comment|/// that return specific slots (getUseIndex(), etc). If you can - please
comment|/// use one of those methods.
name|SlotIndex
name|getPrevSlot
argument_list|()
specifier|const
block|{
name|Slot
name|s
operator|=
name|getSlot
argument_list|()
block|;
if|if
condition|(
name|s
operator|==
name|Slot_Block
condition|)
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
operator|->
name|getPrevNode
argument_list|()
argument_list|,
name|Slot_Dead
argument_list|)
return|;
block|}
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
argument_list|,
name|s
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// Returns the previous index. This is the index corresponding to this
comment|/// index's slot, but for the previous instruction.
name|SlotIndex
name|getPrevIndex
argument_list|()
specifier|const
block|{
return|return
name|SlotIndex
argument_list|(
name|listEntry
argument_list|()
operator|->
name|getPrevNode
argument_list|()
argument_list|,
name|getSlot
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|SlotIndex
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|os
expr|,
name|SlotIndex
name|li
operator|)
block|{
name|li
operator|.
name|print
argument_list|(
name|os
argument_list|)
block|;
return|return
name|os
return|;
block|}
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|SlotIndex
operator|,
name|MachineBasicBlock
operator|*
operator|>
name|IdxMBBPair
expr_stmt|;
specifier|inline
name|bool
name|operator
operator|<
operator|(
name|SlotIndex
name|V
block|,
specifier|const
name|IdxMBBPair
operator|&
name|IM
operator|)
block|{
return|return
name|V
operator|<
name|IM
operator|.
name|first
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|IM
expr|,
name|SlotIndex
name|V
operator|)
block|{
return|return
name|IM
operator|.
name|first
operator|<
name|V
return|;
block|}
expr|struct
name|Idx2MBBCompare
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|IdxMBBPair
operator|&
name|LHS
expr|,
specifier|const
name|IdxMBBPair
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
operator|.
name|first
return|;
block|}
expr|}
block|;
comment|/// SlotIndexes pass.
comment|///
comment|/// This pass assigns indexes to each instruction.
name|class
name|SlotIndexes
operator|:
name|public
name|MachineFunctionPass
block|{
name|private
operator|:
typedef|typedef
name|ilist
operator|<
name|IndexListEntry
operator|>
name|IndexList
expr_stmt|;
name|IndexList
name|indexList
block|;
name|MachineFunction
operator|*
name|mf
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|MachineInstr
operator|*
operator|,
name|SlotIndex
operator|>
name|Mi2IndexMap
expr_stmt|;
name|Mi2IndexMap
name|mi2iMap
block|;
comment|/// MBBRanges - Map MBB number to (start, stop) indexes.
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|SlotIndex
block|,
name|SlotIndex
operator|>
block|,
literal|8
operator|>
name|MBBRanges
block|;
comment|/// Idx2MBBMap - Sorted list of pairs of index of first instruction
comment|/// and MBB id.
name|SmallVector
operator|<
name|IdxMBBPair
block|,
literal|8
operator|>
name|idx2MBBMap
block|;
comment|// IndexListEntry allocator.
name|BumpPtrAllocator
name|ileAllocator
block|;
name|IndexListEntry
operator|*
name|createEntry
argument_list|(
argument|MachineInstr *mi
argument_list|,
argument|unsigned index
argument_list|)
block|{
name|IndexListEntry
operator|*
name|entry
operator|=
name|static_cast
operator|<
name|IndexListEntry
operator|*
operator|>
operator|(
name|ileAllocator
operator|.
name|Allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|IndexListEntry
argument_list|)
argument_list|,
name|alignOf
operator|<
name|IndexListEntry
operator|>
operator|(
operator|)
argument_list|)
operator|)
block|;
name|new
argument_list|(
argument|entry
argument_list|)
name|IndexListEntry
argument_list|(
name|mi
argument_list|,
name|index
argument_list|)
block|;
return|return
name|entry
return|;
block|}
comment|/// Renumber locally after inserting curItr.
name|void
name|renumberIndexes
argument_list|(
argument|IndexList::iterator curItr
argument_list|)
block|;
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|SlotIndexes
argument_list|()
operator|:
name|MachineFunctionPass
argument_list|(
argument|ID
argument_list|)
block|{
name|initializeSlotIndexesPass
argument_list|(
operator|*
name|PassRegistry
operator|::
name|getPassRegistry
argument_list|()
argument_list|)
block|;     }
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
argument|AnalysisUsage&au
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|releaseMemory
argument_list|()
block|;
name|virtual
name|bool
name|runOnMachineFunction
argument_list|(
name|MachineFunction
operator|&
name|fn
argument_list|)
block|;
comment|/// Dump the indexes.
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// Renumber the index list, providing space for new instructions.
name|void
name|renumberIndexes
argument_list|()
block|;
comment|/// Repair indexes after adding and removing instructions.
name|void
name|repairIndexesInRange
argument_list|(
argument|MachineBasicBlock *MBB
argument_list|,
argument|MachineBasicBlock::iterator Begin
argument_list|,
argument|MachineBasicBlock::iterator End
argument_list|)
block|;
comment|/// Returns the zero index for this analysis.
name|SlotIndex
name|getZeroIndex
argument_list|()
block|{
name|assert
argument_list|(
name|indexList
operator|.
name|front
argument_list|()
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
literal|"First index is not 0?"
argument_list|)
block|;
return|return
name|SlotIndex
argument_list|(
operator|&
name|indexList
operator|.
name|front
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Returns the base index of the last slot in this analysis.
name|SlotIndex
name|getLastIndex
argument_list|()
block|{
return|return
name|SlotIndex
argument_list|(
operator|&
name|indexList
operator|.
name|back
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/// Returns true if the given machine instr is mapped to an index,
comment|/// otherwise returns false.
name|bool
name|hasIndex
argument_list|(
argument|const MachineInstr *instr
argument_list|)
specifier|const
block|{
return|return
name|mi2iMap
operator|.
name|count
argument_list|(
name|instr
argument_list|)
return|;
block|}
comment|/// Returns the base index for the given instruction.
name|SlotIndex
name|getInstructionIndex
argument_list|(
argument|const MachineInstr *MI
argument_list|)
specifier|const
block|{
comment|// Instructions inside a bundle have the same number as the bundle itself.
name|Mi2IndexMap
operator|::
name|const_iterator
name|itr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|getBundleStart
argument_list|(
name|MI
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|itr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instruction not found in maps."
argument_list|)
block|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|/// Returns the instruction for the given index, or null if the given
comment|/// index has no instruction associated with it.
name|MachineInstr
operator|*
name|getInstructionFromIndex
argument_list|(
argument|SlotIndex index
argument_list|)
specifier|const
block|{
return|return
name|index
operator|.
name|isValid
argument_list|()
operator|?
name|index
operator|.
name|listEntry
argument_list|()
operator|->
name|getInstr
argument_list|()
operator|:
literal|0
return|;
block|}
comment|/// Returns the next non-null index, if one exists.
comment|/// Otherwise returns getLastIndex().
name|SlotIndex
name|getNextNonNullIndex
argument_list|(
argument|SlotIndex Index
argument_list|)
block|{
name|IndexList
operator|::
name|iterator
name|I
operator|=
name|Index
operator|.
name|listEntry
argument_list|()
block|;
name|IndexList
operator|::
name|iterator
name|E
operator|=
name|indexList
operator|.
name|end
argument_list|()
block|;
while|while
condition|(
operator|++
name|I
operator|!=
name|E
condition|)
if|if
condition|(
name|I
operator|->
name|getInstr
argument_list|()
condition|)
return|return
name|SlotIndex
argument_list|(
name|I
argument_list|,
name|Index
operator|.
name|getSlot
argument_list|()
argument_list|)
return|;
comment|// We reached the end of the function.
return|return
name|getLastIndex
argument_list|()
return|;
block|}
comment|/// getIndexBefore - Returns the index of the last indexed instruction
comment|/// before MI, or the start index of its basic block.
comment|/// MI is not required to have an index.
name|SlotIndex
name|getIndexBefore
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|)
decl|const
block|{
specifier|const
name|MachineBasicBlock
modifier|*
name|MBB
init|=
name|MI
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|MBB
operator|&&
literal|"MI must be inserted inna basic block"
argument_list|)
expr_stmt|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|I
operator|=
name|MI
operator|,
name|B
operator|=
name|MBB
operator|->
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|I
operator|==
name|B
condition|)
return|return
name|getMBBStartIdx
argument_list|(
name|MBB
argument_list|)
return|;
operator|--
name|I
expr_stmt|;
name|Mi2IndexMap
operator|::
name|const_iterator
name|MapItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|MapItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|MapItr
operator|->
name|second
return|;
block|}
block|}
comment|/// getIndexAfter - Returns the index of the first indexed instruction
comment|/// after MI, or the end index of its basic block.
comment|/// MI is not required to have an index.
name|SlotIndex
name|getIndexAfter
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|MI
argument_list|)
decl|const
block|{
specifier|const
name|MachineBasicBlock
modifier|*
name|MBB
init|=
name|MI
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|MBB
operator|&&
literal|"MI must be inserted inna basic block"
argument_list|)
expr_stmt|;
name|MachineBasicBlock
operator|::
name|const_iterator
name|I
operator|=
name|MI
operator|,
name|E
operator|=
name|MBB
operator|->
name|end
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|++
name|I
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|E
condition|)
return|return
name|getMBBEndIdx
argument_list|(
name|MBB
argument_list|)
return|;
name|Mi2IndexMap
operator|::
name|const_iterator
name|MapItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|MapItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|MapItr
operator|->
name|second
return|;
block|}
block|}
comment|/// Return the (start,end) range of the given basic block number.
specifier|const
name|std
operator|::
name|pair
operator|<
name|SlotIndex
operator|,
name|SlotIndex
operator|>
operator|&
name|getMBBRange
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
return|return
name|MBBRanges
index|[
name|Num
index|]
return|;
block|}
comment|/// Return the (start,end) range of the given basic block.
specifier|const
name|std
operator|::
name|pair
operator|<
name|SlotIndex
operator|,
name|SlotIndex
operator|>
operator|&
name|getMBBRange
argument_list|(
argument|const MachineBasicBlock *MBB
argument_list|)
specifier|const
block|{
return|return
name|getMBBRange
argument_list|(
name|MBB
operator|->
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
comment|/// Returns the first index in the given basic block number.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
name|unsigned
name|Num
argument_list|)
decl|const
block|{
return|return
name|getMBBRange
argument_list|(
name|Num
argument_list|)
operator|.
name|first
return|;
block|}
comment|/// Returns the first index in the given basic block.
name|SlotIndex
name|getMBBStartIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
return|return
name|getMBBRange
argument_list|(
name|mbb
argument_list|)
operator|.
name|first
return|;
block|}
comment|/// Returns the last index in the given basic block number.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
name|unsigned
name|Num
argument_list|)
decl|const
block|{
return|return
name|getMBBRange
argument_list|(
name|Num
argument_list|)
operator|.
name|second
return|;
block|}
comment|/// Returns the last index in the given basic block.
name|SlotIndex
name|getMBBEndIdx
argument_list|(
specifier|const
name|MachineBasicBlock
operator|*
name|mbb
argument_list|)
decl|const
block|{
return|return
name|getMBBRange
argument_list|(
name|mbb
argument_list|)
operator|.
name|second
return|;
block|}
comment|/// Returns the basic block which the given index falls in.
name|MachineBasicBlock
modifier|*
name|getMBBFromIndex
argument_list|(
name|SlotIndex
name|index
argument_list|)
decl|const
block|{
if|if
condition|(
name|MachineInstr
modifier|*
name|MI
init|=
name|getInstructionFromIndex
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|MI
operator|->
name|getParent
argument_list|()
return|;
name|SmallVectorImpl
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// Take the pair containing the index
name|SmallVectorImpl
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|J
operator|=
operator|(
operator|(
name|I
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|>
name|index
operator|)
operator|||
operator|(
name|I
operator|==
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|idx2MBBMap
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|)
condition|?
operator|(
name|I
operator|-
literal|1
operator|)
else|:
name|I
expr_stmt|;
name|assert
argument_list|(
name|J
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
operator|&&
name|J
operator|->
name|first
operator|<=
name|index
operator|&&
name|index
operator|<
name|getMBBEndIdx
argument_list|(
name|J
operator|->
name|second
argument_list|)
operator|&&
literal|"index does not correspond to an MBB"
argument_list|)
expr_stmt|;
return|return
name|J
operator|->
name|second
return|;
block|}
name|bool
name|findLiveInMBBs
argument_list|(
name|SlotIndex
name|start
argument_list|,
name|SlotIndex
name|end
argument_list|,
name|SmallVectorImpl
operator|<
name|MachineBasicBlock
operator|*
operator|>
operator|&
name|mbbs
argument_list|)
decl|const
block|{
name|SmallVectorImpl
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|itr
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|bool
name|resVal
init|=
name|false
decl_stmt|;
while|while
condition|(
name|itr
operator|!=
name|idx2MBBMap
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|itr
operator|->
name|first
operator|>=
name|end
condition|)
break|break;
name|mbbs
operator|.
name|push_back
argument_list|(
name|itr
operator|->
name|second
argument_list|)
expr_stmt|;
name|resVal
operator|=
name|true
expr_stmt|;
operator|++
name|itr
expr_stmt|;
block|}
return|return
name|resVal
return|;
block|}
comment|/// Returns the MBB covering the given range, or null if the range covers
comment|/// more than one basic block.
name|MachineBasicBlock
modifier|*
name|getMBBCoveringRange
argument_list|(
name|SlotIndex
name|start
argument_list|,
name|SlotIndex
name|end
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|start
operator|<
name|end
operator|&&
literal|"Backwards ranges not allowed."
argument_list|)
expr_stmt|;
name|SmallVectorImpl
operator|<
name|IdxMBBPair
operator|>
operator|::
name|const_iterator
name|itr
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|itr
operator|==
name|idx2MBBMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|itr
operator|=
name|prior
argument_list|(
name|itr
argument_list|)
expr_stmt|;
return|return
name|itr
operator|->
name|second
return|;
block|}
comment|// Check that we don't cross the boundary into this block.
if|if
condition|(
name|itr
operator|->
name|first
operator|<
name|end
condition|)
return|return
literal|0
return|;
name|itr
operator|=
name|prior
argument_list|(
name|itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|itr
operator|->
name|first
operator|<=
name|start
condition|)
return|return
name|itr
operator|->
name|second
return|;
return|return
literal|0
return|;
block|}
comment|/// Insert the given machine instruction into the mapping. Returns the
comment|/// assigned index.
comment|/// If Late is set and there are null indexes between mi's neighboring
comment|/// instructions, create the new index after the null indexes instead of
comment|/// before them.
name|SlotIndex
name|insertMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|,
name|bool
name|Late
init|=
name|false
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|mi
operator|->
name|isInsideBundle
argument_list|()
operator|&&
literal|"Instructions inside bundles should use bundle start's slot."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
operator|&&
literal|"Instr already indexed."
argument_list|)
expr_stmt|;
comment|// Numbering DBG_VALUE instructions could cause code generation to be
comment|// affected by debug information.
name|assert
argument_list|(
operator|!
name|mi
operator|->
name|isDebugValue
argument_list|()
operator|&&
literal|"Cannot number DBG_VALUE instructions."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mi
operator|->
name|getParent
argument_list|()
operator|!=
literal|0
operator|&&
literal|"Instr must be added to function."
argument_list|)
expr_stmt|;
comment|// Get the entries where mi should be inserted.
name|IndexList
operator|::
name|iterator
name|prevItr
operator|,
name|nextItr
expr_stmt|;
if|if
condition|(
name|Late
condition|)
block|{
comment|// Insert mi's index immediately before the following instruction.
name|nextItr
operator|=
name|getIndexAfter
argument_list|(
name|mi
argument_list|)
operator|.
name|listEntry
argument_list|()
expr_stmt|;
name|prevItr
operator|=
name|prior
argument_list|(
name|nextItr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert mi's index immediately after the preceding instruction.
name|prevItr
operator|=
name|getIndexBefore
argument_list|(
name|mi
argument_list|)
operator|.
name|listEntry
argument_list|()
expr_stmt|;
name|nextItr
operator|=
name|llvm
operator|::
name|next
argument_list|(
name|prevItr
argument_list|)
expr_stmt|;
block|}
comment|// Get a number for the new instr, or 0 if there's no room currently.
comment|// In the latter case we'll force a renumber later.
name|unsigned
name|dist
init|=
operator|(
operator|(
name|nextItr
operator|->
name|getIndex
argument_list|()
operator|-
name|prevItr
operator|->
name|getIndex
argument_list|()
operator|)
operator|/
literal|2
operator|)
operator|&
operator|~
literal|3u
decl_stmt|;
name|unsigned
name|newNumber
init|=
name|prevItr
operator|->
name|getIndex
argument_list|()
operator|+
name|dist
decl_stmt|;
comment|// Insert a new list entry for mi.
name|IndexList
operator|::
name|iterator
name|newItr
operator|=
name|indexList
operator|.
name|insert
argument_list|(
name|nextItr
argument_list|,
name|createEntry
argument_list|(
name|mi
argument_list|,
name|newNumber
argument_list|)
argument_list|)
expr_stmt|;
comment|// Renumber locally if we need to.
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
name|renumberIndexes
argument_list|(
name|newItr
argument_list|)
expr_stmt|;
name|SlotIndex
name|newIndex
argument_list|(
operator|&
operator|*
name|newItr
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|mi
argument_list|,
name|newIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
comment|/// Remove the given machine instruction from the mapping.
name|void
name|removeMachineInstrFromMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|)
block|{
comment|// remove index -> MachineInstr and
comment|// MachineInstr -> index mappings
name|Mi2IndexMap
operator|::
name|iterator
name|mi2iItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2iItr
operator|!=
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|IndexListEntry
modifier|*
name|miEntry
argument_list|(
name|mi2iItr
operator|->
name|second
operator|.
name|listEntry
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|miEntry
operator|->
name|getInstr
argument_list|()
operator|==
name|mi
operator|&&
literal|"Instruction indexes broken."
argument_list|)
expr_stmt|;
comment|// FIXME: Eventually we want to actually delete these indexes.
name|miEntry
operator|->
name|setInstr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|erase
argument_list|(
name|mi2iItr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// ReplaceMachineInstrInMaps - Replacing a machine instr with a new one in
comment|/// maps used by register allocator.
name|void
name|replaceMachineInstrInMaps
parameter_list|(
name|MachineInstr
modifier|*
name|mi
parameter_list|,
name|MachineInstr
modifier|*
name|newMI
parameter_list|)
block|{
name|Mi2IndexMap
operator|::
name|iterator
name|mi2iItr
operator|=
name|mi2iMap
operator|.
name|find
argument_list|(
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi2iItr
operator|==
name|mi2iMap
operator|.
name|end
argument_list|()
condition|)
return|return;
name|SlotIndex
name|replaceBaseIndex
init|=
name|mi2iItr
operator|->
name|second
decl_stmt|;
name|IndexListEntry
modifier|*
name|miEntry
argument_list|(
name|replaceBaseIndex
operator|.
name|listEntry
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|miEntry
operator|->
name|getInstr
argument_list|()
operator|==
name|mi
operator|&&
literal|"Mismatched instruction in index tables."
argument_list|)
expr_stmt|;
name|miEntry
operator|->
name|setInstr
argument_list|(
name|newMI
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|erase
argument_list|(
name|mi2iItr
argument_list|)
expr_stmt|;
name|mi2iMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|newMI
argument_list|,
name|replaceBaseIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Add the given MachineBasicBlock into the maps.
name|void
name|insertMBBInMaps
parameter_list|(
name|MachineBasicBlock
modifier|*
name|mbb
parameter_list|)
block|{
name|MachineFunction
operator|::
name|iterator
name|nextMBB
operator|=
name|llvm
operator|::
name|next
argument_list|(
name|MachineFunction
operator|::
name|iterator
argument_list|(
name|mbb
argument_list|)
argument_list|)
expr_stmt|;
name|IndexListEntry
modifier|*
name|startEntry
init|=
literal|0
decl_stmt|;
name|IndexListEntry
modifier|*
name|endEntry
init|=
literal|0
decl_stmt|;
name|IndexList
operator|::
name|iterator
name|newItr
expr_stmt|;
if|if
condition|(
name|nextMBB
operator|==
name|mbb
operator|->
name|getParent
argument_list|()
operator|->
name|end
argument_list|()
condition|)
block|{
name|startEntry
operator|=
operator|&
name|indexList
operator|.
name|back
argument_list|()
expr_stmt|;
name|endEntry
operator|=
name|createEntry
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newItr
operator|=
name|indexList
operator|.
name|insertAfter
argument_list|(
name|startEntry
argument_list|,
name|endEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|startEntry
operator|=
name|createEntry
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|endEntry
operator|=
name|getMBBStartIdx
argument_list|(
name|nextMBB
argument_list|)
operator|.
name|listEntry
argument_list|()
expr_stmt|;
name|newItr
operator|=
name|indexList
operator|.
name|insert
argument_list|(
name|endEntry
argument_list|,
name|startEntry
argument_list|)
expr_stmt|;
block|}
name|SlotIndex
name|startIdx
argument_list|(
name|startEntry
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|SlotIndex
name|endIdx
argument_list|(
name|endEntry
argument_list|,
name|SlotIndex
operator|::
name|Slot_Block
argument_list|)
decl_stmt|;
name|MachineFunction
operator|::
name|iterator
name|prevMBB
argument_list|(
name|mbb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prevMBB
operator|!=
name|mbb
operator|->
name|getParent
argument_list|()
operator|->
name|end
argument_list|()
operator|&&
literal|"Can't insert a new block at the beginning of a function."
argument_list|)
expr_stmt|;
operator|--
name|prevMBB
expr_stmt|;
name|MBBRanges
index|[
name|prevMBB
operator|->
name|getNumber
argument_list|()
index|]
operator|.
name|second
operator|=
name|startIdx
expr_stmt|;
name|assert
argument_list|(
name|unsigned
argument_list|(
name|mbb
operator|->
name|getNumber
argument_list|()
argument_list|)
operator|==
name|MBBRanges
operator|.
name|size
argument_list|()
operator|&&
literal|"Blocks must be added in order"
argument_list|)
expr_stmt|;
name|MBBRanges
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|startIdx
argument_list|,
name|endIdx
argument_list|)
argument_list|)
expr_stmt|;
name|idx2MBBMap
operator|.
name|push_back
argument_list|(
name|IdxMBBPair
argument_list|(
name|startIdx
argument_list|,
name|mbb
argument_list|)
argument_list|)
expr_stmt|;
name|renumberIndexes
argument_list|(
name|newItr
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|idx2MBBMap
operator|.
name|begin
argument_list|()
argument_list|,
name|idx2MBBMap
operator|.
name|end
argument_list|()
argument_list|,
name|Idx2MBBCompare
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Specialize IntervalMapInfo for half-open slot index intervals.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IntervalMapInfo
operator|<
name|SlotIndex
operator|>
operator|:
name|IntervalMapHalfOpenInfo
operator|<
name|SlotIndex
operator|>
block|{   }
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_SLOTINDEXES_H
end_comment

end_unit

