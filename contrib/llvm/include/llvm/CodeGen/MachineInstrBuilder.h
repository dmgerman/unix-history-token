begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CodeGen/MachineInstBuilder.h - Simplify creation of MIs -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file exposes a function named BuildMI, which is useful for dramatically
end_comment

begin_comment
comment|// simplifying how MachineInstr's are created.  It allows use of code like this:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   M = BuildMI(X86::ADDrr8, 2).addReg(argVal1).addReg(argVal2);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_MACHINEINSTRBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_MACHINEINSTRBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineInstrBundle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCInstrDesc
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|namespace
name|RegState
block|{
enum|enum
block|{
name|Define
init|=
literal|0x2
block|,
name|Implicit
init|=
literal|0x4
block|,
name|Kill
init|=
literal|0x8
block|,
name|Dead
init|=
literal|0x10
block|,
name|Undef
init|=
literal|0x20
block|,
name|EarlyClobber
init|=
literal|0x40
block|,
name|Debug
init|=
literal|0x80
block|,
name|InternalRead
init|=
literal|0x100
block|,
name|DefineNoRead
init|=
name|Define
operator||
name|Undef
block|,
name|ImplicitDefine
init|=
name|Implicit
operator||
name|Define
block|,
name|ImplicitKill
init|=
name|Implicit
operator||
name|Kill
block|}
enum|;
block|}
name|class
name|MachineInstrBuilder
block|{
name|MachineFunction
modifier|*
name|MF
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
decl_stmt|;
name|public
label|:
name|MachineInstrBuilder
argument_list|()
operator|:
name|MF
argument_list|(
name|nullptr
argument_list|)
operator|,
name|MI
argument_list|(
argument|nullptr
argument_list|)
block|{}
comment|/// Create a MachineInstrBuilder for manipulating an existing instruction.
comment|/// F must be the machine function that was used to allocate I.
name|MachineInstrBuilder
argument_list|(
name|MachineFunction
operator|&
name|F
argument_list|,
name|MachineInstr
operator|*
name|I
argument_list|)
operator|:
name|MF
argument_list|(
operator|&
name|F
argument_list|)
operator|,
name|MI
argument_list|(
argument|I
argument_list|)
block|{}
comment|/// Allow automatic conversion to the machine instruction we are working on.
name|operator
name|MachineInstr
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|MI
return|;
block|}
name|MachineInstr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|MI
return|;
block|}
name|operator
name|MachineBasicBlock
operator|::
name|iterator
argument_list|()
specifier|const
block|{
return|return
name|MI
return|;
block|}
comment|/// If conversion operators fail, use this method to get the MachineInstr
comment|/// explicitly.
name|MachineInstr
operator|*
name|getInstr
argument_list|()
specifier|const
block|{
return|return
name|MI
return|;
block|}
comment|/// Add a new virtual register operand.
specifier|const
name|MachineInstrBuilder
modifier|&
name|addReg
argument_list|(
name|unsigned
name|RegNo
argument_list|,
name|unsigned
name|flags
operator|=
literal|0
argument_list|,
name|unsigned
name|SubReg
operator|=
literal|0
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|(
name|flags
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
literal|"Passing in 'true' to addReg is forbidden! Use enums instead."
argument_list|)
expr_stmt|;
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateReg
argument_list|(
name|RegNo
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Define
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Implicit
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Kill
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Dead
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Undef
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|EarlyClobber
argument_list|,
name|SubReg
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|Debug
argument_list|,
name|flags
operator|&
name|RegState
operator|::
name|InternalRead
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Add a new immediate operand.
specifier|const
name|MachineInstrBuilder
modifier|&
name|addImm
argument_list|(
name|int64_t
name|Val
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateImm
argument_list|(
name|Val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addCImm
argument_list|(
specifier|const
name|ConstantInt
operator|*
name|Val
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateCImm
argument_list|(
name|Val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addFPImm
argument_list|(
specifier|const
name|ConstantFP
operator|*
name|Val
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateFPImm
argument_list|(
name|Val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addMBB
argument_list|(
name|MachineBasicBlock
operator|*
name|MBB
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateMBB
argument_list|(
name|MBB
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addFrameIndex
argument_list|(
name|int
name|Idx
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateFI
argument_list|(
name|Idx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addConstantPoolIndex
argument_list|(
name|unsigned
name|Idx
argument_list|,
name|int
name|Offset
operator|=
literal|0
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateCPI
argument_list|(
name|Idx
argument_list|,
name|Offset
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addTargetIndex
argument_list|(
name|unsigned
name|Idx
argument_list|,
name|int64_t
name|Offset
operator|=
literal|0
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateTargetIndex
argument_list|(
name|Idx
argument_list|,
name|Offset
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addJumpTableIndex
argument_list|(
name|unsigned
name|Idx
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateJTI
argument_list|(
name|Idx
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addGlobalAddress
argument_list|(
specifier|const
name|GlobalValue
operator|*
name|GV
argument_list|,
name|int64_t
name|Offset
operator|=
literal|0
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateGA
argument_list|(
name|GV
argument_list|,
name|Offset
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addExternalSymbol
argument_list|(
specifier|const
name|char
operator|*
name|FnName
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateES
argument_list|(
name|FnName
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addBlockAddress
argument_list|(
specifier|const
name|BlockAddress
operator|*
name|BA
argument_list|,
name|int64_t
name|Offset
operator|=
literal|0
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateBA
argument_list|(
name|BA
argument_list|,
name|Offset
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addRegMask
argument_list|(
specifier|const
name|uint32_t
operator|*
name|Mask
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateRegMask
argument_list|(
name|Mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addMemOperand
argument_list|(
name|MachineMemOperand
operator|*
name|MMO
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addMemOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MMO
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|setMemRefs
argument_list|(
name|MachineInstr
operator|::
name|mmo_iterator
name|b
argument_list|,
name|MachineInstr
operator|::
name|mmo_iterator
name|e
argument_list|)
decl|const
block|{
name|MI
operator|->
name|setMemRefs
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|setMemRefs
argument_list|(
name|std
operator|::
name|pair
operator|<
name|MachineInstr
operator|::
name|mmo_iterator
argument_list|,
name|unsigned
operator|>
name|MemOperandsRef
argument_list|)
decl|const
block|{
name|MI
operator|->
name|setMemRefs
argument_list|(
name|MemOperandsRef
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addOperand
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MO
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addMetadata
argument_list|(
specifier|const
name|MDNode
operator|*
name|MD
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateMetadata
argument_list|(
name|MD
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|MI
operator|->
name|isDebugValue
argument_list|()
condition|?
name|static_cast
operator|<
name|bool
operator|>
operator|(
name|MI
operator|->
name|getDebugVariable
argument_list|()
operator|)
else|:
name|true
operator|)
operator|&&
literal|"first MDNode argument of a DBG_VALUE not a variable"
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addCFIIndex
argument_list|(
name|unsigned
name|CFIIndex
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateCFIIndex
argument_list|(
name|CFIIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|addSym
argument_list|(
name|MCSymbol
operator|*
name|Sym
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
name|MI
operator|->
name|addOperand
argument_list|(
operator|*
name|MF
argument_list|,
name|MachineOperand
operator|::
name|CreateMCSymbol
argument_list|(
name|Sym
argument_list|,
name|TargetFlags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|setMIFlags
argument_list|(
name|unsigned
name|Flags
argument_list|)
decl|const
block|{
name|MI
operator|->
name|setFlags
argument_list|(
name|Flags
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|MachineInstrBuilder
modifier|&
name|setMIFlag
argument_list|(
name|MachineInstr
operator|::
name|MIFlag
name|Flag
argument_list|)
decl|const
block|{
name|MI
operator|->
name|setFlag
argument_list|(
name|Flag
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|// Add a displacement from an existing MachineOperand with an added offset.
specifier|const
name|MachineInstrBuilder
modifier|&
name|addDisp
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|Disp
argument_list|,
name|int64_t
name|off
argument_list|,
name|unsigned
name|char
name|TargetFlags
operator|=
literal|0
argument_list|)
decl|const
block|{
comment|// If caller specifies new TargetFlags then use it, otherwise the
comment|// default behavior is to copy the target flags from the existing
comment|// MachineOperand. This means if the caller wants to clear the
comment|// target flags it needs to do so explicitly.
if|if
condition|(
literal|0
operator|==
name|TargetFlags
condition|)
name|TargetFlags
operator|=
name|Disp
operator|.
name|getTargetFlags
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|Disp
operator|.
name|getType
argument_list|()
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unhandled operand type in addDisp()"
argument_list|)
expr_stmt|;
case|case
name|MachineOperand
operator|::
name|MO_Immediate
case|:
return|return
name|addImm
argument_list|(
name|Disp
operator|.
name|getImm
argument_list|()
operator|+
name|off
argument_list|)
return|;
case|case
name|MachineOperand
operator|::
name|MO_ConstantPoolIndex
case|:
return|return
name|addConstantPoolIndex
argument_list|(
name|Disp
operator|.
name|getIndex
argument_list|()
argument_list|,
name|Disp
operator|.
name|getOffset
argument_list|()
operator|+
name|off
argument_list|,
name|TargetFlags
argument_list|)
return|;
case|case
name|MachineOperand
operator|::
name|MO_GlobalAddress
case|:
return|return
name|addGlobalAddress
argument_list|(
name|Disp
operator|.
name|getGlobal
argument_list|()
argument_list|,
name|Disp
operator|.
name|getOffset
argument_list|()
operator|+
name|off
argument_list|,
name|TargetFlags
argument_list|)
return|;
block|}
block|}
comment|/// Copy all the implicit operands from OtherMI onto this one.
specifier|const
name|MachineInstrBuilder
modifier|&
name|copyImplicitOps
argument_list|(
specifier|const
name|MachineInstr
operator|*
name|OtherMI
argument_list|)
decl|const
block|{
name|MI
operator|->
name|copyImplicitOps
argument_list|(
operator|*
name|MF
argument_list|,
name|OtherMI
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Builder interface. Specify how to create the initial instruction itself.
end_comment

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineFunction
modifier|&
name|MF
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|)
block|{
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder sets up the first operand as a
end_comment

begin_comment
comment|/// destination virtual register.
end_comment

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineFunction
modifier|&
name|MF
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|,
name|unsigned
name|DestReg
parameter_list|)
block|{
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
argument_list|)
operator|.
name|addReg
argument_list|(
name|DestReg
argument_list|,
name|RegState
operator|::
name|Define
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder inserts the newly-built instruction before
end_comment

begin_comment
comment|/// the given position in the given MachineBasicBlock, and sets up the first
end_comment

begin_comment
comment|/// operand as a destination virtual register.
end_comment

begin_decl_stmt
specifier|inline
name|MachineInstrBuilder
name|BuildMI
argument_list|(
name|MachineBasicBlock
operator|&
name|BB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
name|DebugLoc
name|DL
argument_list|,
specifier|const
name|MCInstrDesc
operator|&
name|MCID
argument_list|,
name|unsigned
name|DestReg
argument_list|)
block|{
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|BB
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
init|=
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
decl_stmt|;
name|BB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MI
argument_list|)
operator|.
name|addReg
argument_list|(
name|DestReg
argument_list|,
name|RegState
operator|::
name|Define
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|inline
name|MachineInstrBuilder
name|BuildMI
argument_list|(
name|MachineBasicBlock
operator|&
name|BB
argument_list|,
name|MachineBasicBlock
operator|::
name|instr_iterator
name|I
argument_list|,
name|DebugLoc
name|DL
argument_list|,
specifier|const
name|MCInstrDesc
operator|&
name|MCID
argument_list|,
name|unsigned
name|DestReg
argument_list|)
block|{
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|BB
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
init|=
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
decl_stmt|;
name|BB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MI
argument_list|)
operator|.
name|addReg
argument_list|(
name|DestReg
argument_list|,
name|RegState
operator|::
name|Define
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineBasicBlock
modifier|&
name|BB
parameter_list|,
name|MachineInstr
modifier|*
name|I
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|,
name|unsigned
name|DestReg
parameter_list|)
block|{
if|if
condition|(
name|I
operator|->
name|isInsideBundle
argument_list|()
condition|)
block|{
name|MachineBasicBlock
operator|::
name|instr_iterator
name|MII
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return
name|BuildMI
argument_list|(
name|BB
argument_list|,
name|MII
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|,
name|DestReg
argument_list|)
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|MII
operator|=
name|I
expr_stmt|;
return|return
name|BuildMI
argument_list|(
name|BB
argument_list|,
name|MII
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|,
name|DestReg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder inserts the newly-built instruction before the
end_comment

begin_comment
comment|/// given position in the given MachineBasicBlock, and does NOT take a
end_comment

begin_comment
comment|/// destination register.
end_comment

begin_decl_stmt
specifier|inline
name|MachineInstrBuilder
name|BuildMI
argument_list|(
name|MachineBasicBlock
operator|&
name|BB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
name|DebugLoc
name|DL
argument_list|,
specifier|const
name|MCInstrDesc
operator|&
name|MCID
argument_list|)
block|{
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|BB
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
init|=
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
decl_stmt|;
name|BB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MI
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|inline
name|MachineInstrBuilder
name|BuildMI
argument_list|(
name|MachineBasicBlock
operator|&
name|BB
argument_list|,
name|MachineBasicBlock
operator|::
name|instr_iterator
name|I
argument_list|,
name|DebugLoc
name|DL
argument_list|,
specifier|const
name|MCInstrDesc
operator|&
name|MCID
argument_list|)
block|{
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|BB
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
init|=
name|MF
operator|.
name|CreateMachineInstr
argument_list|(
name|MCID
argument_list|,
name|DL
argument_list|)
decl_stmt|;
name|BB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MI
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineBasicBlock
modifier|&
name|BB
parameter_list|,
name|MachineInstr
modifier|*
name|I
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|)
block|{
if|if
condition|(
name|I
operator|->
name|isInsideBundle
argument_list|()
condition|)
block|{
name|MachineBasicBlock
operator|::
name|instr_iterator
name|MII
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return
name|BuildMI
argument_list|(
name|BB
argument_list|,
name|MII
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|)
return|;
block|}
name|MachineBasicBlock
operator|::
name|iterator
name|MII
operator|=
name|I
expr_stmt|;
return|return
name|BuildMI
argument_list|(
name|BB
argument_list|,
name|MII
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder inserts the newly-built instruction at the end
end_comment

begin_comment
comment|/// of the given MachineBasicBlock, and does NOT take a destination register.
end_comment

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineBasicBlock
modifier|*
name|BB
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|)
block|{
return|return
name|BuildMI
argument_list|(
operator|*
name|BB
argument_list|,
name|BB
operator|->
name|end
argument_list|()
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder inserts the newly-built instruction at the
end_comment

begin_comment
comment|/// end of the given MachineBasicBlock, and sets up the first operand as a
end_comment

begin_comment
comment|/// destination virtual register.
end_comment

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineBasicBlock
modifier|*
name|BB
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|,
name|unsigned
name|DestReg
parameter_list|)
block|{
return|return
name|BuildMI
argument_list|(
operator|*
name|BB
argument_list|,
name|BB
operator|->
name|end
argument_list|()
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|,
name|DestReg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// This version of the builder builds a DBG_VALUE intrinsic
end_comment

begin_comment
comment|/// for either a value in a register or a register-indirect+offset
end_comment

begin_comment
comment|/// address.  The convention is that a DBG_VALUE is indirect iff the
end_comment

begin_comment
comment|/// second operand is an immediate.
end_comment

begin_function
specifier|inline
name|MachineInstrBuilder
name|BuildMI
parameter_list|(
name|MachineFunction
modifier|&
name|MF
parameter_list|,
name|DebugLoc
name|DL
parameter_list|,
specifier|const
name|MCInstrDesc
modifier|&
name|MCID
parameter_list|,
name|bool
name|IsIndirect
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|unsigned
name|Offset
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|Variable
parameter_list|,
specifier|const
name|MDNode
modifier|*
name|Expr
parameter_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|DILocalVariable
operator|>
operator|(
name|Variable
operator|)
operator|&&
literal|"not a variable"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cast
operator|<
name|DIExpression
operator|>
operator|(
name|Expr
operator|)
operator|->
name|isValid
argument_list|()
operator|&&
literal|"not an expression"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cast
operator|<
name|DILocalVariable
operator|>
operator|(
name|Variable
operator|)
operator|->
name|isValidLocationForIntrinsic
argument_list|(
name|DL
argument_list|)
operator|&&
literal|"Expected inlined-at fields to agree"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsIndirect
condition|)
return|return
name|BuildMI
argument_list|(
name|MF
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|)
operator|.
name|addReg
argument_list|(
name|Reg
argument_list|,
name|RegState
operator|::
name|Debug
argument_list|)
operator|.
name|addImm
argument_list|(
name|Offset
argument_list|)
operator|.
name|addMetadata
argument_list|(
name|Variable
argument_list|)
operator|.
name|addMetadata
argument_list|(
name|Expr
argument_list|)
return|;
else|else
block|{
name|assert
argument_list|(
name|Offset
operator|==
literal|0
operator|&&
literal|"A direct address cannot have an offset."
argument_list|)
expr_stmt|;
return|return
name|BuildMI
argument_list|(
name|MF
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|)
operator|.
name|addReg
argument_list|(
name|Reg
argument_list|,
name|RegState
operator|::
name|Debug
argument_list|)
operator|.
name|addReg
argument_list|(
literal|0U
argument_list|,
name|RegState
operator|::
name|Debug
argument_list|)
operator|.
name|addMetadata
argument_list|(
name|Variable
argument_list|)
operator|.
name|addMetadata
argument_list|(
name|Expr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/// This version of the builder builds a DBG_VALUE intrinsic
end_comment

begin_comment
comment|/// for either a value in a register or a register-indirect+offset
end_comment

begin_comment
comment|/// address and inserts it at position I.
end_comment

begin_decl_stmt
specifier|inline
name|MachineInstrBuilder
name|BuildMI
argument_list|(
name|MachineBasicBlock
operator|&
name|BB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
name|DebugLoc
name|DL
argument_list|,
specifier|const
name|MCInstrDesc
operator|&
name|MCID
argument_list|,
name|bool
name|IsIndirect
argument_list|,
name|unsigned
name|Reg
argument_list|,
name|unsigned
name|Offset
argument_list|,
specifier|const
name|MDNode
operator|*
name|Variable
argument_list|,
specifier|const
name|MDNode
operator|*
name|Expr
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|DILocalVariable
operator|>
operator|(
name|Variable
operator|)
operator|&&
literal|"not a variable"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cast
operator|<
name|DIExpression
operator|>
operator|(
name|Expr
operator|)
operator|->
name|isValid
argument_list|()
operator|&&
literal|"not an expression"
argument_list|)
expr_stmt|;
name|MachineFunction
modifier|&
name|MF
init|=
operator|*
name|BB
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|MachineInstr
modifier|*
name|MI
init|=
name|BuildMI
argument_list|(
name|MF
argument_list|,
name|DL
argument_list|,
name|MCID
argument_list|,
name|IsIndirect
argument_list|,
name|Reg
argument_list|,
name|Offset
argument_list|,
name|Variable
argument_list|,
name|Expr
argument_list|)
decl_stmt|;
name|BB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
return|return
name|MachineInstrBuilder
argument_list|(
name|MF
argument_list|,
name|MI
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|inline
name|unsigned
name|getDefRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Define
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getImplRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Implicit
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getKillRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Kill
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getDeadRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Dead
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getUndefRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Undef
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getInternalReadRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|InternalRead
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|unsigned
name|getDebugRegState
parameter_list|(
name|bool
name|B
parameter_list|)
block|{
return|return
name|B
condition|?
name|RegState
operator|::
name|Debug
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/// Helper class for constructing bundles of MachineInstrs.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// MIBundleBuilder can create a bundle from scratch by inserting new
end_comment

begin_comment
comment|/// MachineInstrs one at a time, or it can create a bundle from a sequence of
end_comment

begin_comment
comment|/// existing MachineInstrs in a basic block.
end_comment

begin_decl_stmt
name|class
name|MIBundleBuilder
block|{
name|MachineBasicBlock
modifier|&
name|MBB
decl_stmt|;
name|MachineBasicBlock
operator|::
name|instr_iterator
name|Begin
expr_stmt|;
name|MachineBasicBlock
operator|::
name|instr_iterator
name|End
expr_stmt|;
name|public
label|:
comment|/// Create an MIBundleBuilder that inserts instructions into a new bundle in
comment|/// BB above the bundle or instruction at Pos.
name|MIBundleBuilder
argument_list|(
argument|MachineBasicBlock&BB
argument_list|,
argument|MachineBasicBlock::iterator Pos
argument_list|)
block|:
name|MBB
argument_list|(
name|BB
argument_list|)
operator|,
name|Begin
argument_list|(
name|Pos
operator|.
name|getInstrIterator
argument_list|()
argument_list|)
operator|,
name|End
argument_list|(
argument|Begin
argument_list|)
block|{}
comment|/// Create a bundle from the sequence of instructions between B and E.
name|MIBundleBuilder
argument_list|(
argument|MachineBasicBlock&BB
argument_list|,
argument|MachineBasicBlock::iterator B
argument_list|,
argument|MachineBasicBlock::iterator E
argument_list|)
operator|:
name|MBB
argument_list|(
name|BB
argument_list|)
operator|,
name|Begin
argument_list|(
name|B
operator|.
name|getInstrIterator
argument_list|()
argument_list|)
operator|,
name|End
argument_list|(
argument|E.getInstrIterator()
argument_list|)
block|{
name|assert
argument_list|(
name|B
operator|!=
name|E
operator|&&
literal|"No instructions to bundle"
argument_list|)
block|;
operator|++
name|B
block|;
while|while
condition|(
name|B
operator|!=
name|E
condition|)
block|{
name|MachineInstr
modifier|*
name|MI
init|=
name|B
decl_stmt|;
operator|++
name|B
expr_stmt|;
name|MI
operator|->
name|bundleWithPred
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// Create an MIBundleBuilder representing an existing instruction or bundle
comment|/// that has MI as its head.
name|explicit
name|MIBundleBuilder
argument_list|(
name|MachineInstr
operator|*
name|MI
argument_list|)
operator|:
name|MBB
argument_list|(
operator|*
name|MI
operator|->
name|getParent
argument_list|()
argument_list|)
operator|,
name|Begin
argument_list|(
name|MI
argument_list|)
operator|,
name|End
argument_list|(
argument|getBundleEnd(MI)
argument_list|)
block|{}
comment|/// Return a reference to the basic block containing this bundle.
name|MachineBasicBlock
operator|&
name|getMBB
argument_list|()
specifier|const
block|{
return|return
name|MBB
return|;
block|}
comment|/// Return true if no instructions have been inserted in this bundle yet.
comment|/// Empty bundles aren't representable in a MachineBasicBlock.
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Begin
operator|==
name|End
return|;
block|}
comment|/// Return an iterator to the first bundled instruction.
name|MachineBasicBlock
operator|::
name|instr_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Begin
return|;
block|}
comment|/// Return an iterator beyond the last bundled instruction.
name|MachineBasicBlock
operator|::
name|instr_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
comment|/// Insert MI into this bundle before I which must point to an instruction in
comment|/// the bundle, or end().
name|MIBundleBuilder
modifier|&
name|insert
argument_list|(
name|MachineBasicBlock
operator|::
name|instr_iterator
name|I
argument_list|,
name|MachineInstr
operator|*
name|MI
argument_list|)
block|{
name|MBB
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|MI
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|Begin
condition|)
block|{
if|if
condition|(
operator|!
name|empty
argument_list|()
condition|)
name|MI
operator|->
name|bundleWithSucc
argument_list|()
expr_stmt|;
name|Begin
operator|=
name|MI
operator|->
name|getIterator
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
if|if
condition|(
name|I
operator|==
name|End
condition|)
block|{
name|MI
operator|->
name|bundleWithPred
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|// MI was inserted in the middle of the bundle, so its neighbors' flags are
comment|// already fine. Update MI's bundle flags manually.
name|MI
operator|->
name|setFlag
argument_list|(
name|MachineInstr
operator|::
name|BundledPred
argument_list|)
expr_stmt|;
name|MI
operator|->
name|setFlag
argument_list|(
name|MachineInstr
operator|::
name|BundledSucc
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Insert MI into MBB by prepending it to the instructions in the bundle.
comment|/// MI will become the first instruction in the bundle.
name|MIBundleBuilder
modifier|&
name|prepend
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|begin
argument_list|()
argument_list|,
name|MI
argument_list|)
return|;
block|}
comment|/// Insert MI into MBB by appending it to the instructions in the bundle.
comment|/// MI will become the last instruction in the bundle.
name|MIBundleBuilder
modifier|&
name|append
parameter_list|(
name|MachineInstr
modifier|*
name|MI
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|end
argument_list|()
argument_list|,
name|MI
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

