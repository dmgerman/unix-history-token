begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGen/ValueTypes.h - Low-Level Target independ. types --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the set of low-level target independent types which various
end_comment

begin_comment
comment|// values in the code generator are.  This allows the target specific behavior
end_comment

begin_comment
comment|// of instructions to be described to target independent passes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_VALUETYPES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_VALUETYPES_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Type
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
struct_decl|struct
name|EVT
struct_decl|;
comment|/// MVT - Machine Value Type. Every type that is supported natively by some
comment|/// processor targeted by LLVM occurs here. This means that any legal value
comment|/// type can be represented by an MVT.
name|class
name|MVT
block|{
name|public
label|:
enum|enum
name|SimpleValueType
block|{
comment|// INVALID_SIMPLE_VALUE_TYPE - Simple value types less than zero are
comment|// considered extended value types.
name|INVALID_SIMPLE_VALUE_TYPE
init|=
operator|-
literal|1
block|,
comment|// If you change this numbering, you must change the values in
comment|// ValueTypes.td as well!
name|Other
init|=
literal|0
block|,
comment|// This is a non-standard value
name|i1
init|=
literal|1
block|,
comment|// This is a 1 bit integer value
name|i8
init|=
literal|2
block|,
comment|// This is an 8 bit integer value
name|i16
init|=
literal|3
block|,
comment|// This is a 16 bit integer value
name|i32
init|=
literal|4
block|,
comment|// This is a 32 bit integer value
name|i64
init|=
literal|5
block|,
comment|// This is a 64 bit integer value
name|i128
init|=
literal|6
block|,
comment|// This is a 128 bit integer value
name|FIRST_INTEGER_VALUETYPE
init|=
name|i1
block|,
name|LAST_INTEGER_VALUETYPE
init|=
name|i128
block|,
name|f16
init|=
literal|7
block|,
comment|// This is a 16 bit floating point value
name|f32
init|=
literal|8
block|,
comment|// This is a 32 bit floating point value
name|f64
init|=
literal|9
block|,
comment|// This is a 64 bit floating point value
name|f80
init|=
literal|10
block|,
comment|// This is a 80 bit floating point value
name|f128
init|=
literal|11
block|,
comment|// This is a 128 bit floating point value
name|ppcf128
init|=
literal|12
block|,
comment|// This is a PPC 128-bit floating point value
name|FIRST_FP_VALUETYPE
init|=
name|f16
block|,
name|LAST_FP_VALUETYPE
init|=
name|ppcf128
block|,
name|v2i1
init|=
literal|13
block|,
comment|//  2 x i1
name|v4i1
init|=
literal|14
block|,
comment|//  4 x i1
name|v8i1
init|=
literal|15
block|,
comment|//  8 x i1
name|v16i1
init|=
literal|16
block|,
comment|// 16 x i1
name|v32i1
init|=
literal|17
block|,
comment|// 32 x i1
name|v64i1
init|=
literal|18
block|,
comment|// 64 x i1
name|v1i8
init|=
literal|19
block|,
comment|//  1 x i8
name|v2i8
init|=
literal|20
block|,
comment|//  2 x i8
name|v4i8
init|=
literal|21
block|,
comment|//  4 x i8
name|v8i8
init|=
literal|22
block|,
comment|//  8 x i8
name|v16i8
init|=
literal|23
block|,
comment|// 16 x i8
name|v32i8
init|=
literal|24
block|,
comment|// 32 x i8
name|v64i8
init|=
literal|25
block|,
comment|// 64 x i8
name|v1i16
init|=
literal|26
block|,
comment|//  1 x i16
name|v2i16
init|=
literal|27
block|,
comment|//  2 x i16
name|v4i16
init|=
literal|28
block|,
comment|//  4 x i16
name|v8i16
init|=
literal|29
block|,
comment|//  8 x i16
name|v16i16
init|=
literal|30
block|,
comment|// 16 x i16
name|v32i16
init|=
literal|31
block|,
comment|// 32 x i16
name|v1i32
init|=
literal|32
block|,
comment|//  1 x i32
name|v2i32
init|=
literal|33
block|,
comment|//  2 x i32
name|v4i32
init|=
literal|34
block|,
comment|//  4 x i32
name|v8i32
init|=
literal|35
block|,
comment|//  8 x i32
name|v16i32
init|=
literal|36
block|,
comment|// 16 x i32
name|v1i64
init|=
literal|37
block|,
comment|//  1 x i64
name|v2i64
init|=
literal|38
block|,
comment|//  2 x i64
name|v4i64
init|=
literal|39
block|,
comment|//  4 x i64
name|v8i64
init|=
literal|40
block|,
comment|//  8 x i64
name|v16i64
init|=
literal|41
block|,
comment|// 16 x i64
name|FIRST_INTEGER_VECTOR_VALUETYPE
init|=
name|v2i1
block|,
name|LAST_INTEGER_VECTOR_VALUETYPE
init|=
name|v16i64
block|,
name|v2f16
init|=
literal|42
block|,
comment|//  2 x f16
name|v4f16
init|=
literal|43
block|,
comment|//  4 x f16
name|v8f16
init|=
literal|44
block|,
comment|//  8 x f16
name|v1f32
init|=
literal|45
block|,
comment|//  1 x f32
name|v2f32
init|=
literal|46
block|,
comment|//  2 x f32
name|v4f32
init|=
literal|47
block|,
comment|//  4 x f32
name|v8f32
init|=
literal|48
block|,
comment|//  8 x f32
name|v16f32
init|=
literal|49
block|,
comment|// 16 x f32
name|v1f64
init|=
literal|50
block|,
comment|//  1 x f64
name|v2f64
init|=
literal|51
block|,
comment|//  2 x f64
name|v4f64
init|=
literal|52
block|,
comment|//  4 x f64
name|v8f64
init|=
literal|53
block|,
comment|//  8 x f64
name|FIRST_FP_VECTOR_VALUETYPE
init|=
name|v2f16
block|,
name|LAST_FP_VECTOR_VALUETYPE
init|=
name|v8f64
block|,
name|FIRST_VECTOR_VALUETYPE
init|=
name|v2i1
block|,
name|LAST_VECTOR_VALUETYPE
init|=
name|v8f64
block|,
name|x86mmx
init|=
literal|54
block|,
comment|// This is an X86 MMX value
name|Glue
init|=
literal|55
block|,
comment|// This glues nodes together during pre-RA sched
name|isVoid
init|=
literal|56
block|,
comment|// This has no value
name|Untyped
init|=
literal|57
block|,
comment|// This value takes a register, but has
comment|// unspecified type.  The register class
comment|// will be determined by the opcode.
name|LAST_VALUETYPE
init|=
literal|58
block|,
comment|// This always remains at the end of the list.
comment|// This is the current maximum for LAST_VALUETYPE.
comment|// MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors
comment|// This value must be a multiple of 32.
name|MAX_ALLOWED_VALUETYPE
init|=
literal|64
block|,
comment|// Metadata - This is MDNode or MDString.
name|Metadata
init|=
literal|250
block|,
comment|// iPTRAny - An int value the size of the pointer of the current
comment|// target to any address space. This must only be used internal to
comment|// tblgen. Other than for overloading, we treat iPTRAny the same as iPTR.
name|iPTRAny
init|=
literal|251
block|,
comment|// vAny - A vector with any length and element size. This is used
comment|// for intrinsics that have overloadings based on vector types.
comment|// This is only for tblgen's consumption!
name|vAny
init|=
literal|252
block|,
comment|// fAny - Any floating-point or vector floating-point value. This is used
comment|// for intrinsics that have overloadings based on floating-point types.
comment|// This is only for tblgen's consumption!
name|fAny
init|=
literal|253
block|,
comment|// iAny - An integer or vector integer value of any bit width. This is
comment|// used for intrinsics that have overloadings based on integer bit widths.
comment|// This is only for tblgen's consumption!
name|iAny
init|=
literal|254
block|,
comment|// iPTR - An int value the size of the pointer of the current
comment|// target.  This should only be used internal to tblgen!
name|iPTR
init|=
literal|255
block|}
enum|;
name|SimpleValueType
name|SimpleTy
decl_stmt|;
name|MVT
argument_list|()
operator|:
name|SimpleTy
argument_list|(
argument|(SimpleValueType)(INVALID_SIMPLE_VALUE_TYPE)
argument_list|)
block|{}
name|MVT
argument_list|(
argument|SimpleValueType SVT
argument_list|)
operator|:
name|SimpleTy
argument_list|(
argument|SVT
argument_list|)
block|{ }
name|bool
name|operator
operator|>
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|>
name|S
operator|.
name|SimpleTy
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|<
name|S
operator|.
name|SimpleTy
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|==
name|S
operator|.
name|SimpleTy
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|!=
name|S
operator|.
name|SimpleTy
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|>=
name|S
operator|.
name|SimpleTy
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|MVT
operator|&
name|S
operator|)
specifier|const
block|{
return|return
name|SimpleTy
operator|<=
name|S
operator|.
name|SimpleTy
return|;
block|}
comment|/// isFloatingPoint - Return true if this is a FP, or a vector FP type.
name|bool
name|isFloatingPoint
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|(
name|SimpleTy
operator|>=
name|MVT
operator|::
name|FIRST_FP_VALUETYPE
operator|&&
name|SimpleTy
operator|<=
name|MVT
operator|::
name|LAST_FP_VALUETYPE
operator|)
operator|||
operator|(
name|SimpleTy
operator|>=
name|MVT
operator|::
name|FIRST_FP_VECTOR_VALUETYPE
operator|&&
name|SimpleTy
operator|<=
name|MVT
operator|::
name|LAST_FP_VECTOR_VALUETYPE
operator|)
operator|)
return|;
block|}
comment|/// isInteger - Return true if this is an integer, or a vector integer type.
name|bool
name|isInteger
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|(
name|SimpleTy
operator|>=
name|MVT
operator|::
name|FIRST_INTEGER_VALUETYPE
operator|&&
name|SimpleTy
operator|<=
name|MVT
operator|::
name|LAST_INTEGER_VALUETYPE
operator|)
operator|||
operator|(
name|SimpleTy
operator|>=
name|MVT
operator|::
name|FIRST_INTEGER_VECTOR_VALUETYPE
operator|&&
name|SimpleTy
operator|<=
name|MVT
operator|::
name|LAST_INTEGER_VECTOR_VALUETYPE
operator|)
operator|)
return|;
block|}
comment|/// isVector - Return true if this is a vector value type.
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|>=
name|MVT
operator|::
name|FIRST_VECTOR_VALUETYPE
operator|&&
name|SimpleTy
operator|<=
name|MVT
operator|::
name|LAST_VECTOR_VALUETYPE
operator|)
return|;
block|}
comment|/// is16BitVector - Return true if this is a 16-bit vector type.
name|bool
name|is16BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v1i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16i1
operator|)
return|;
block|}
comment|/// is32BitVector - Return true if this is a 32-bit vector type.
name|bool
name|is32BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v1i32
operator|)
return|;
block|}
comment|/// is64BitVector - Return true if this is a 64-bit vector type.
name|bool
name|is64BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2i32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v1i64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v1f64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2f32
operator|)
return|;
block|}
comment|/// is128BitVector - Return true if this is a 128-bit vector type.
name|bool
name|is128BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4i32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2i64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4f32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v2f64
operator|)
return|;
block|}
comment|/// is256BitVector - Return true if this is a 256-bit vector type.
name|bool
name|is256BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8f32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4f64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v32i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8i32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v4i64
operator|)
return|;
block|}
comment|/// is512BitVector - Return true if this is a 512-bit vector type.
name|bool
name|is512BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8f64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16f32
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v64i8
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v32i16
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v8i64
operator|||
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16i32
operator|)
return|;
block|}
comment|/// is1024BitVector - Return true if this is a 1024-bit vector type.
name|bool
name|is1024BitVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SimpleTy
operator|==
name|MVT
operator|::
name|v16i64
operator|)
return|;
block|}
comment|/// isPow2VectorType - Returns true if the given vector is a power of 2.
name|bool
name|isPow2VectorType
argument_list|()
specifier|const
block|{
name|unsigned
name|NElts
operator|=
name|getVectorNumElements
argument_list|()
block|;
return|return
operator|!
operator|(
name|NElts
operator|&
operator|(
name|NElts
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// getPow2VectorType - Widens the length of the given vector MVT up to
comment|/// the nearest power of 2 and returns that type.
name|MVT
name|getPow2VectorType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isPow2VectorType
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|unsigned
name|NElts
operator|=
name|getVectorNumElements
argument_list|()
expr_stmt|;
name|unsigned
name|Pow2NElts
init|=
literal|1
operator|<<
name|Log2_32_Ceil
argument_list|(
name|NElts
argument_list|)
decl_stmt|;
return|return
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|getVectorElementType
argument_list|()
argument_list|,
name|Pow2NElts
argument_list|)
return|;
block|}
comment|/// getScalarType - If this is a vector type, return the element type,
comment|/// otherwise return this.
name|MVT
name|getScalarType
argument_list|()
specifier|const
block|{
return|return
name|isVector
argument_list|()
operator|?
name|getVectorElementType
argument_list|()
operator|:
operator|*
name|this
return|;
block|}
name|MVT
name|getVectorElementType
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|SimpleTy
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Not a vector MVT!"
argument_list|)
expr_stmt|;
case|case
name|v2i1
case|:
case|case
name|v4i1
case|:
case|case
name|v8i1
case|:
case|case
name|v16i1
case|:
case|case
name|v32i1
case|:
case|case
name|v64i1
case|:
return|return
name|i1
return|;
case|case
name|v1i8
case|:
case|case
name|v2i8
case|:
case|case
name|v4i8
case|:
case|case
name|v8i8
case|:
case|case
name|v16i8
case|:
case|case
name|v32i8
case|:
case|case
name|v64i8
case|:
return|return
name|i8
return|;
case|case
name|v1i16
case|:
case|case
name|v2i16
case|:
case|case
name|v4i16
case|:
case|case
name|v8i16
case|:
case|case
name|v16i16
case|:
case|case
name|v32i16
case|:
return|return
name|i16
return|;
case|case
name|v1i32
case|:
case|case
name|v2i32
case|:
case|case
name|v4i32
case|:
case|case
name|v8i32
case|:
case|case
name|v16i32
case|:
return|return
name|i32
return|;
case|case
name|v1i64
case|:
case|case
name|v2i64
case|:
case|case
name|v4i64
case|:
case|case
name|v8i64
case|:
case|case
name|v16i64
case|:
return|return
name|i64
return|;
case|case
name|v2f16
case|:
case|case
name|v4f16
case|:
case|case
name|v8f16
case|:
return|return
name|f16
return|;
case|case
name|v1f32
case|:
case|case
name|v2f32
case|:
case|case
name|v4f32
case|:
case|case
name|v8f32
case|:
case|case
name|v16f32
case|:
return|return
name|f32
return|;
case|case
name|v1f64
case|:
case|case
name|v2f64
case|:
case|case
name|v4f64
case|:
case|case
name|v8f64
case|:
return|return
name|f64
return|;
block|}
block|}
name|unsigned
name|getVectorNumElements
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|SimpleTy
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Not a vector MVT!"
argument_list|)
expr_stmt|;
case|case
name|v32i1
case|:
case|case
name|v32i8
case|:
case|case
name|v32i16
case|:
return|return
literal|32
return|;
case|case
name|v64i1
case|:
case|case
name|v64i8
case|:
return|return
literal|64
return|;
case|case
name|v16i1
case|:
case|case
name|v16i8
case|:
case|case
name|v16i16
case|:
case|case
name|v16i32
case|:
case|case
name|v16i64
case|:
case|case
name|v16f32
case|:
return|return
literal|16
return|;
case|case
name|v8i1
case|:
case|case
name|v8i8
case|:
case|case
name|v8i16
case|:
case|case
name|v8i32
case|:
case|case
name|v8i64
case|:
case|case
name|v8f16
case|:
case|case
name|v8f32
case|:
case|case
name|v8f64
case|:
return|return
literal|8
return|;
case|case
name|v4i1
case|:
case|case
name|v4i8
case|:
case|case
name|v4i16
case|:
case|case
name|v4i32
case|:
case|case
name|v4i64
case|:
case|case
name|v4f16
case|:
case|case
name|v4f32
case|:
case|case
name|v4f64
case|:
return|return
literal|4
return|;
case|case
name|v2i1
case|:
case|case
name|v2i8
case|:
case|case
name|v2i16
case|:
case|case
name|v2i32
case|:
case|case
name|v2i64
case|:
case|case
name|v2f16
case|:
case|case
name|v2f32
case|:
case|case
name|v2f64
case|:
return|return
literal|2
return|;
case|case
name|v1i8
case|:
case|case
name|v1i16
case|:
case|case
name|v1i32
case|:
case|case
name|v1i64
case|:
case|case
name|v1f32
case|:
case|case
name|v1f64
case|:
return|return
literal|1
return|;
block|}
block|}
name|unsigned
name|getSizeInBits
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|SimpleTy
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"getSizeInBits called on extended MVT."
argument_list|)
expr_stmt|;
case|case
name|Other
case|:
name|llvm_unreachable
argument_list|(
literal|"Value type is non-standard value, Other."
argument_list|)
expr_stmt|;
case|case
name|iPTR
case|:
name|llvm_unreachable
argument_list|(
literal|"Value type size is target-dependent. Ask TLI."
argument_list|)
expr_stmt|;
case|case
name|iPTRAny
case|:
case|case
name|iAny
case|:
case|case
name|fAny
case|:
case|case
name|vAny
case|:
name|llvm_unreachable
argument_list|(
literal|"Value type is overloaded."
argument_list|)
expr_stmt|;
case|case
name|Metadata
case|:
name|llvm_unreachable
argument_list|(
literal|"Value type is metadata."
argument_list|)
expr_stmt|;
case|case
name|i1
case|:
return|return
literal|1
return|;
case|case
name|v2i1
case|:
return|return
literal|2
return|;
case|case
name|v4i1
case|:
return|return
literal|4
return|;
case|case
name|i8
case|:
case|case
name|v1i8
case|:
case|case
name|v8i1
case|:
return|return
literal|8
return|;
case|case
name|i16
case|:
case|case
name|f16
case|:
case|case
name|v16i1
case|:
case|case
name|v2i8
case|:
case|case
name|v1i16
case|:
return|return
literal|16
return|;
case|case
name|f32
case|:
case|case
name|i32
case|:
case|case
name|v32i1
case|:
case|case
name|v4i8
case|:
case|case
name|v2i16
case|:
case|case
name|v2f16
case|:
case|case
name|v1f32
case|:
case|case
name|v1i32
case|:
return|return
literal|32
return|;
case|case
name|x86mmx
case|:
case|case
name|f64
case|:
case|case
name|i64
case|:
case|case
name|v64i1
case|:
case|case
name|v8i8
case|:
case|case
name|v4i16
case|:
case|case
name|v2i32
case|:
case|case
name|v1i64
case|:
case|case
name|v4f16
case|:
case|case
name|v2f32
case|:
case|case
name|v1f64
case|:
return|return
literal|64
return|;
case|case
name|f80
case|:
return|return
literal|80
return|;
case|case
name|f128
case|:
case|case
name|ppcf128
case|:
case|case
name|i128
case|:
case|case
name|v16i8
case|:
case|case
name|v8i16
case|:
case|case
name|v4i32
case|:
case|case
name|v2i64
case|:
case|case
name|v8f16
case|:
case|case
name|v4f32
case|:
case|case
name|v2f64
case|:
return|return
literal|128
return|;
case|case
name|v32i8
case|:
case|case
name|v16i16
case|:
case|case
name|v8i32
case|:
case|case
name|v4i64
case|:
case|case
name|v8f32
case|:
case|case
name|v4f64
case|:
return|return
literal|256
return|;
case|case
name|v64i8
case|:
case|case
name|v32i16
case|:
case|case
name|v16i32
case|:
case|case
name|v8i64
case|:
case|case
name|v16f32
case|:
case|case
name|v8f64
case|:
return|return
literal|512
return|;
case|case
name|v16i64
case|:
return|return
literal|1024
return|;
block|}
block|}
comment|/// getStoreSize - Return the number of bytes overwritten by a store
comment|/// of the specified value type.
name|unsigned
name|getStoreSize
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getSizeInBits
argument_list|()
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
block|}
comment|/// getStoreSizeInBits - Return the number of bits overwritten by a store
comment|/// of the specified value type.
name|unsigned
name|getStoreSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|getStoreSize
argument_list|()
operator|*
literal|8
return|;
block|}
comment|/// Return true if this has more bits than VT.
name|bool
name|bitsGT
argument_list|(
name|MVT
name|VT
argument_list|)
decl|const
block|{
return|return
name|getSizeInBits
argument_list|()
operator|>
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has no less bits than VT.
name|bool
name|bitsGE
argument_list|(
name|MVT
name|VT
argument_list|)
decl|const
block|{
return|return
name|getSizeInBits
argument_list|()
operator|>=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has less bits than VT.
name|bool
name|bitsLT
argument_list|(
name|MVT
name|VT
argument_list|)
decl|const
block|{
return|return
name|getSizeInBits
argument_list|()
operator|<
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has no more bits than VT.
name|bool
name|bitsLE
argument_list|(
name|MVT
name|VT
argument_list|)
decl|const
block|{
return|return
name|getSizeInBits
argument_list|()
operator|<=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
specifier|static
name|MVT
name|getFloatingPointVT
parameter_list|(
name|unsigned
name|BitWidth
parameter_list|)
block|{
switch|switch
condition|(
name|BitWidth
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Bad bit width!"
argument_list|)
expr_stmt|;
case|case
literal|16
case|:
return|return
name|MVT
operator|::
name|f16
return|;
case|case
literal|32
case|:
return|return
name|MVT
operator|::
name|f32
return|;
case|case
literal|64
case|:
return|return
name|MVT
operator|::
name|f64
return|;
case|case
literal|80
case|:
return|return
name|MVT
operator|::
name|f80
return|;
case|case
literal|128
case|:
return|return
name|MVT
operator|::
name|f128
return|;
block|}
block|}
specifier|static
name|MVT
name|getIntegerVT
parameter_list|(
name|unsigned
name|BitWidth
parameter_list|)
block|{
switch|switch
condition|(
name|BitWidth
condition|)
block|{
default|default:
return|return
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
operator|(
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
operator|)
return|;
case|case
literal|1
case|:
return|return
name|MVT
operator|::
name|i1
return|;
case|case
literal|8
case|:
return|return
name|MVT
operator|::
name|i8
return|;
case|case
literal|16
case|:
return|return
name|MVT
operator|::
name|i16
return|;
case|case
literal|32
case|:
return|return
name|MVT
operator|::
name|i32
return|;
case|case
literal|64
case|:
return|return
name|MVT
operator|::
name|i64
return|;
case|case
literal|128
case|:
return|return
name|MVT
operator|::
name|i128
return|;
block|}
block|}
specifier|static
name|MVT
name|getVectorVT
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|unsigned
name|NumElements
parameter_list|)
block|{
switch|switch
condition|(
name|VT
operator|.
name|SimpleTy
condition|)
block|{
default|default:
break|break;
case|case
name|MVT
operator|::
name|i1
case|:
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2i1
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4i1
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8i1
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16i1
return|;
if|if
condition|(
name|NumElements
operator|==
literal|32
condition|)
return|return
name|MVT
operator|::
name|v32i1
return|;
if|if
condition|(
name|NumElements
operator|==
literal|64
condition|)
return|return
name|MVT
operator|::
name|v64i1
return|;
break|break;
case|case
name|MVT
operator|::
name|i8
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|32
condition|)
return|return
name|MVT
operator|::
name|v32i8
return|;
if|if
condition|(
name|NumElements
operator|==
literal|64
condition|)
return|return
name|MVT
operator|::
name|v64i8
return|;
break|break;
case|case
name|MVT
operator|::
name|i16
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1i16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2i16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4i16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8i16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16i16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|32
condition|)
return|return
name|MVT
operator|::
name|v32i16
return|;
break|break;
case|case
name|MVT
operator|::
name|i32
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1i32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2i32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4i32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8i32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16i32
return|;
break|break;
case|case
name|MVT
operator|::
name|i64
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1i64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2i64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4i64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8i64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16i64
return|;
break|break;
case|case
name|MVT
operator|::
name|f16
case|:
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2f16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4f16
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8f16
return|;
break|break;
case|case
name|MVT
operator|::
name|f32
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1f32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2f32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4f32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8f32
return|;
if|if
condition|(
name|NumElements
operator|==
literal|16
condition|)
return|return
name|MVT
operator|::
name|v16f32
return|;
break|break;
case|case
name|MVT
operator|::
name|f64
case|:
if|if
condition|(
name|NumElements
operator|==
literal|1
condition|)
return|return
name|MVT
operator|::
name|v1f64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|2
condition|)
return|return
name|MVT
operator|::
name|v2f64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|4
condition|)
return|return
name|MVT
operator|::
name|v4f64
return|;
if|if
condition|(
name|NumElements
operator|==
literal|8
condition|)
return|return
name|MVT
operator|::
name|v8f64
return|;
break|break;
block|}
return|return
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
operator|(
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
operator|)
return|;
block|}
comment|/// Return the value type corresponding to the specified type.  This returns
comment|/// all pointers as iPTR.  If HandleUnknown is true, unknown types are
comment|/// returned as Other, otherwise they are invalid.
specifier|static
name|MVT
name|getVT
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|HandleUnknown
init|=
name|false
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// EVT - Extended Value Type.  Capable of holding value types which are not
end_comment

begin_comment
comment|/// native for any processor (such as the i12345 type), as well as the types
end_comment

begin_comment
comment|/// a MVT can represent.
end_comment

begin_struct
struct|struct
name|EVT
block|{
name|private
label|:
name|MVT
name|V
decl_stmt|;
name|Type
modifier|*
name|LLVMTy
decl_stmt|;
name|public
label|:
name|EVT
argument_list|()
operator|:
name|V
argument_list|(
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
operator|(
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
operator|)
argument_list|)
operator|,
name|LLVMTy
argument_list|(
literal|0
argument_list|)
block|{}
name|EVT
argument_list|(
argument|MVT::SimpleValueType SVT
argument_list|)
operator|:
name|V
argument_list|(
name|SVT
argument_list|)
operator|,
name|LLVMTy
argument_list|(
literal|0
argument_list|)
block|{ }
name|EVT
argument_list|(
argument|MVT S
argument_list|)
operator|:
name|V
argument_list|(
name|S
argument_list|)
operator|,
name|LLVMTy
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
name|EVT
name|VT
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|!=
name|VT
operator|)
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|EVT
name|VT
operator|)
specifier|const
block|{
if|if
condition|(
name|V
operator|.
name|SimpleTy
operator|!=
name|VT
operator|.
name|V
operator|.
name|SimpleTy
condition|)
return|return
name|true
return|;
if|if
condition|(
name|V
operator|.
name|SimpleTy
operator|<
literal|0
condition|)
return|return
name|LLVMTy
operator|!=
name|VT
operator|.
name|LLVMTy
return|;
return|return
name|false
return|;
block|}
comment|/// getFloatingPointVT - Returns the EVT that represents a floating point
comment|/// type with the given number of bits.  There are two floating point types
comment|/// with 128 bits - this returns f128 rather than ppcf128.
decl|static
name|EVT
name|getFloatingPointVT
argument_list|(
name|unsigned
name|BitWidth
argument_list|)
block|{
return|return
name|MVT
operator|::
name|getFloatingPointVT
argument_list|(
name|BitWidth
argument_list|)
return|;
block|}
comment|/// getIntegerVT - Returns the EVT that represents an integer with the given
comment|/// number of bits.
decl|static
name|EVT
name|getIntegerVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|unsigned
name|BitWidth
argument_list|)
block|{
name|MVT
name|M
init|=
name|MVT
operator|::
name|getIntegerVT
argument_list|(
name|BitWidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|M
operator|.
name|SimpleTy
operator|>=
literal|0
condition|)
return|return
name|M
return|;
return|return
name|getExtendedIntegerVT
argument_list|(
name|Context
argument_list|,
name|BitWidth
argument_list|)
return|;
block|}
comment|/// getVectorVT - Returns the EVT that represents a vector NumElements in
comment|/// length, where each element is of type VT.
decl|static
name|EVT
name|getVectorVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|EVT
name|VT
argument_list|,
name|unsigned
name|NumElements
argument_list|)
block|{
name|MVT
name|M
init|=
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|VT
operator|.
name|V
argument_list|,
name|NumElements
argument_list|)
decl_stmt|;
if|if
condition|(
name|M
operator|.
name|SimpleTy
operator|>=
literal|0
condition|)
return|return
name|M
return|;
return|return
name|getExtendedVectorVT
argument_list|(
name|Context
argument_list|,
name|VT
argument_list|,
name|NumElements
argument_list|)
return|;
block|}
comment|/// changeVectorElementTypeToInteger - Return a vector with the same number
comment|/// of elements as this vector, but with the element type converted to an
comment|/// integer type with the same bitwidth.
name|EVT
name|changeVectorElementTypeToInteger
argument_list|()
decl|const
block|{
if|if
condition|(
operator|!
name|isSimple
argument_list|()
condition|)
return|return
name|changeExtendedVectorElementTypeToInteger
argument_list|()
return|;
name|MVT
name|EltTy
init|=
name|getSimpleVT
argument_list|()
operator|.
name|getVectorElementType
argument_list|()
decl_stmt|;
name|unsigned
name|BitWidth
init|=
name|EltTy
operator|.
name|getSizeInBits
argument_list|()
decl_stmt|;
name|MVT
name|IntTy
init|=
name|MVT
operator|::
name|getIntegerVT
argument_list|(
name|BitWidth
argument_list|)
decl_stmt|;
name|MVT
name|VecTy
init|=
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|IntTy
argument_list|,
name|getVectorNumElements
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|VecTy
operator|.
name|SimpleTy
operator|>=
literal|0
operator|&&
literal|"Simple vector VT not representable by simple integer vector VT!"
argument_list|)
expr_stmt|;
return|return
name|VecTy
return|;
block|}
comment|/// isSimple - Test if the given EVT is simple (as opposed to being
comment|/// extended).
name|bool
name|isSimple
argument_list|()
decl|const
block|{
return|return
name|V
operator|.
name|SimpleTy
operator|>=
literal|0
return|;
block|}
comment|/// isExtended - Test if the given EVT is extended (as opposed to
comment|/// being simple).
name|bool
name|isExtended
argument_list|()
decl|const
block|{
return|return
operator|!
name|isSimple
argument_list|()
return|;
block|}
comment|/// isFloatingPoint - Return true if this is a FP, or a vector FP type.
name|bool
name|isFloatingPoint
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isFloatingPoint
argument_list|()
else|:
name|isExtendedFloatingPoint
argument_list|()
return|;
block|}
comment|/// isInteger - Return true if this is an integer, or a vector integer type.
name|bool
name|isInteger
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isInteger
argument_list|()
else|:
name|isExtendedInteger
argument_list|()
return|;
block|}
comment|/// isVector - Return true if this is a vector value type.
name|bool
name|isVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isVector
argument_list|()
else|:
name|isExtendedVector
argument_list|()
return|;
block|}
comment|/// is16BitVector - Return true if this is a 16-bit vector type.
name|bool
name|is16BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is16BitVector
argument_list|()
else|:
name|isExtended16BitVector
argument_list|()
return|;
block|}
comment|/// is32BitVector - Return true if this is a 32-bit vector type.
name|bool
name|is32BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is32BitVector
argument_list|()
else|:
name|isExtended32BitVector
argument_list|()
return|;
block|}
comment|/// is64BitVector - Return true if this is a 64-bit vector type.
name|bool
name|is64BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is64BitVector
argument_list|()
else|:
name|isExtended64BitVector
argument_list|()
return|;
block|}
comment|/// is128BitVector - Return true if this is a 128-bit vector type.
name|bool
name|is128BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is128BitVector
argument_list|()
else|:
name|isExtended128BitVector
argument_list|()
return|;
block|}
comment|/// is256BitVector - Return true if this is a 256-bit vector type.
name|bool
name|is256BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is256BitVector
argument_list|()
else|:
name|isExtended256BitVector
argument_list|()
return|;
block|}
comment|/// is512BitVector - Return true if this is a 512-bit vector type.
name|bool
name|is512BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is512BitVector
argument_list|()
else|:
name|isExtended512BitVector
argument_list|()
return|;
block|}
comment|/// is1024BitVector - Return true if this is a 1024-bit vector type.
name|bool
name|is1024BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is1024BitVector
argument_list|()
else|:
name|isExtended1024BitVector
argument_list|()
return|;
block|}
comment|/// isOverloaded - Return true if this is an overloaded type for TableGen.
name|bool
name|isOverloaded
argument_list|()
decl|const
block|{
return|return
operator|(
name|V
operator|==
name|MVT
operator|::
name|iAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|fAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|vAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|iPTRAny
operator|)
return|;
block|}
comment|/// isByteSized - Return true if the bit size is a multiple of 8.
name|bool
name|isByteSized
argument_list|()
decl|const
block|{
return|return
operator|(
name|getSizeInBits
argument_list|()
operator|&
literal|7
operator|)
operator|==
literal|0
return|;
block|}
comment|/// isRound - Return true if the size is a power-of-two number of bytes.
name|bool
name|isRound
argument_list|()
decl|const
block|{
name|unsigned
name|BitSize
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
return|return
name|BitSize
operator|>=
literal|8
operator|&&
operator|!
operator|(
name|BitSize
operator|&
operator|(
name|BitSize
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// bitsEq - Return true if this has the same number of bits as VT.
name|bool
name|bitsEq
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|==
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// bitsGT - Return true if this has more bits than VT.
name|bool
name|bitsGT
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|false
return|;
return|return
name|getSizeInBits
argument_list|()
operator|>
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// bitsGE - Return true if this has no less bits than VT.
name|bool
name|bitsGE
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|>=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// bitsLT - Return true if this has less bits than VT.
name|bool
name|bitsLT
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|false
return|;
return|return
name|getSizeInBits
argument_list|()
operator|<
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// bitsLE - Return true if this has no more bits than VT.
name|bool
name|bitsLE
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|<=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// getSimpleVT - Return the SimpleValueType held in the specified
comment|/// simple EVT.
name|MVT
name|getSimpleVT
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isSimple
argument_list|()
operator|&&
literal|"Expected a SimpleValueType!"
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
comment|/// getScalarType - If this is a vector type, return the element type,
comment|/// otherwise return this.
name|EVT
name|getScalarType
argument_list|()
decl|const
block|{
return|return
name|isVector
argument_list|()
condition|?
name|getVectorElementType
argument_list|()
else|:
operator|*
name|this
return|;
block|}
comment|/// getVectorElementType - Given a vector type, return the type of
comment|/// each element.
name|EVT
name|getVectorElementType
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isVector
argument_list|()
operator|&&
literal|"Invalid vector type!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getVectorElementType
argument_list|()
return|;
return|return
name|getExtendedVectorElementType
argument_list|()
return|;
block|}
comment|/// getVectorNumElements - Given a vector type, return the number of
comment|/// elements it contains.
name|unsigned
name|getVectorNumElements
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isVector
argument_list|()
operator|&&
literal|"Invalid vector type!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getVectorNumElements
argument_list|()
return|;
return|return
name|getExtendedVectorNumElements
argument_list|()
return|;
block|}
comment|/// getSizeInBits - Return the size of the specified value type in bits.
name|unsigned
name|getSizeInBits
argument_list|()
decl|const
block|{
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getSizeInBits
argument_list|()
return|;
return|return
name|getExtendedSizeInBits
argument_list|()
return|;
block|}
comment|/// getStoreSize - Return the number of bytes overwritten by a store
comment|/// of the specified value type.
name|unsigned
name|getStoreSize
argument_list|()
decl|const
block|{
return|return
operator|(
name|getSizeInBits
argument_list|()
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
block|}
comment|/// getStoreSizeInBits - Return the number of bits overwritten by a store
comment|/// of the specified value type.
name|unsigned
name|getStoreSizeInBits
argument_list|()
decl|const
block|{
return|return
name|getStoreSize
argument_list|()
operator|*
literal|8
return|;
block|}
comment|/// getRoundIntegerType - Rounds the bit-width of the given integer EVT up
comment|/// to the nearest power of two (and at least to eight), and returns the
comment|/// integer EVT with that number of bits.
name|EVT
name|getRoundIntegerType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isInteger
argument_list|()
operator|&&
operator|!
name|isVector
argument_list|()
operator|&&
literal|"Invalid integer type!"
argument_list|)
expr_stmt|;
name|unsigned
name|BitWidth
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
if|if
condition|(
name|BitWidth
operator|<=
literal|8
condition|)
return|return
name|EVT
argument_list|(
name|MVT
operator|::
name|i8
argument_list|)
return|;
return|return
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
literal|1
operator|<<
name|Log2_32_Ceil
argument_list|(
name|BitWidth
argument_list|)
argument_list|)
return|;
block|}
comment|/// getHalfSizedIntegerVT - Finds the smallest simple value type that is
comment|/// greater than or equal to half the width of this EVT. If no simple
comment|/// value type can be found, an extended integer value type of half the
comment|/// size (rounded up) is returned.
name|EVT
name|getHalfSizedIntegerVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isInteger
argument_list|()
operator|&&
operator|!
name|isVector
argument_list|()
operator|&&
literal|"Invalid integer type!"
argument_list|)
expr_stmt|;
name|unsigned
name|EVTSize
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|IntVT
init|=
name|MVT
operator|::
name|FIRST_INTEGER_VALUETYPE
init|;
name|IntVT
operator|<=
name|MVT
operator|::
name|LAST_INTEGER_VALUETYPE
condition|;
operator|++
name|IntVT
control|)
block|{
name|EVT
name|HalfVT
init|=
name|EVT
argument_list|(
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|IntVT
argument_list|)
decl_stmt|;
if|if
condition|(
name|HalfVT
operator|.
name|getSizeInBits
argument_list|()
operator|*
literal|2
operator|>=
name|EVTSize
condition|)
return|return
name|HalfVT
return|;
block|}
return|return
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
operator|(
name|EVTSize
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
return|;
block|}
comment|/// isPow2VectorType - Returns true if the given vector is a power of 2.
name|bool
name|isPow2VectorType
argument_list|()
decl|const
block|{
name|unsigned
name|NElts
init|=
name|getVectorNumElements
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
name|NElts
operator|&
operator|(
name|NElts
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// getPow2VectorType - Widens the length of the given vector EVT up to
comment|/// the nearest power of 2 and returns that type.
name|EVT
name|getPow2VectorType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isPow2VectorType
argument_list|()
condition|)
block|{
name|unsigned
name|NElts
init|=
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Pow2NElts
init|=
literal|1
operator|<<
name|Log2_32_Ceil
argument_list|(
name|NElts
argument_list|)
decl_stmt|;
return|return
name|EVT
operator|::
name|getVectorVT
argument_list|(
name|Context
argument_list|,
name|getVectorElementType
argument_list|()
argument_list|,
name|Pow2NElts
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|*
name|this
return|;
block|}
block|}
comment|/// getEVTString - This function returns value type as a string,
comment|/// e.g. "i32".
name|std
decl|::
name|string
name|getEVTString
argument_list|()
decl|const
struct|;
end_struct

begin_comment
comment|/// getTypeForEVT - This method returns an LLVM type corresponding to the
end_comment

begin_comment
comment|/// specified EVT.  For integer types, this returns an unsigned type.  Note
end_comment

begin_comment
comment|/// that this will abort for types that cannot be represented.
end_comment

begin_decl_stmt
name|Type
modifier|*
name|getTypeForEVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// getEVT - Return the value type corresponding to the specified type.
end_comment

begin_comment
comment|/// This returns all pointers as iPTR.  If HandleUnknown is true, unknown
end_comment

begin_comment
comment|/// types are returned as Other, otherwise they are invalid.
end_comment

begin_function_decl
specifier|static
name|EVT
name|getEVT
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|HandleUnknown
init|=
name|false
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|intptr_t
name|getRawBits
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|SimpleTy
return|;
else|else
return|return
call|(
name|intptr_t
call|)
argument_list|(
name|LLVMTy
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// compareRawBits - A meaningless but well-behaved order, useful for
end_comment

begin_comment
comment|/// constructing containers.
end_comment

begin_struct
struct|struct
name|compareRawBits
block|{
name|bool
name|operator
argument_list|()
operator|(
name|EVT
name|L
operator|,
name|EVT
name|R
operator|)
specifier|const
block|{
if|if
condition|(
name|L
operator|.
name|V
operator|.
name|SimpleTy
operator|==
name|R
operator|.
name|V
operator|.
name|SimpleTy
condition|)
return|return
name|L
operator|.
name|LLVMTy
operator|<
name|R
operator|.
name|LLVMTy
return|;
else|else
return|return
name|L
operator|.
name|V
operator|.
name|SimpleTy
operator|<
name|R
operator|.
name|V
operator|.
name|SimpleTy
return|;
block|}
block|}
struct|;
end_struct

begin_label
name|private
label|:
end_label

begin_comment
comment|// Methods for handling the Extended-type case in functions above.
end_comment

begin_comment
comment|// These are all out-of-line to prevent users of this header file
end_comment

begin_comment
comment|// from having a dependency on Type.h.
end_comment

begin_expr_stmt
name|EVT
name|changeExtendedVectorElementTypeToInteger
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|EVT
name|getExtendedIntegerVT
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|BitWidth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EVT
name|getExtendedVectorVT
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|NumElements
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|bool
name|isExtendedFloatingPoint
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtendedInteger
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtendedVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended16BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended32BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended64BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended128BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended256BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended512BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isExtended1024BitVector
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EVT
name|getExtendedVectorElementType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getExtendedVectorNumElements
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getExtendedSizeInBits
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

