begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGen/ValueTypes.h - Low-Level Target independ. types --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the set of low-level target independent types which various
end_comment

begin_comment
comment|// values in the code generator are.  This allows the target specific behavior
end_comment

begin_comment
comment|// of instructions to be described to target independent passes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_VALUETYPES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_VALUETYPES_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineValueType.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|LLVMContext
decl_stmt|;
name|class
name|Type
decl_stmt|;
comment|/// Extended Value Type. Capable of holding value types which are not native
comment|/// for any processor (such as the i12345 type), as well as the types an MVT
comment|/// can represent.
struct|struct
name|EVT
block|{
name|private
label|:
name|MVT
name|V
decl_stmt|;
name|Type
modifier|*
name|LLVMTy
decl_stmt|;
name|public
label|:
name|constexpr
name|EVT
argument_list|()
operator|:
name|V
argument_list|(
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
argument_list|)
operator|,
name|LLVMTy
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|constexpr
name|EVT
argument_list|(
argument|MVT::SimpleValueType SVT
argument_list|)
operator|:
name|V
argument_list|(
name|SVT
argument_list|)
operator|,
name|LLVMTy
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|constexpr
name|EVT
argument_list|(
argument|MVT S
argument_list|)
operator|:
name|V
argument_list|(
name|S
argument_list|)
operator|,
name|LLVMTy
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
name|EVT
name|VT
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|!=
name|VT
operator|)
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|EVT
name|VT
operator|)
specifier|const
block|{
if|if
condition|(
name|V
operator|.
name|SimpleTy
operator|!=
name|VT
operator|.
name|V
operator|.
name|SimpleTy
condition|)
return|return
name|true
return|;
if|if
condition|(
name|V
operator|.
name|SimpleTy
operator|==
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
condition|)
return|return
name|LLVMTy
operator|!=
name|VT
operator|.
name|LLVMTy
return|;
return|return
name|false
return|;
block|}
comment|/// Returns the EVT that represents a floating-point type with the given
comment|/// number of bits. There are two floating-point types with 128 bits - this
comment|/// returns f128 rather than ppcf128.
decl|static
name|EVT
name|getFloatingPointVT
argument_list|(
name|unsigned
name|BitWidth
argument_list|)
block|{
return|return
name|MVT
operator|::
name|getFloatingPointVT
argument_list|(
name|BitWidth
argument_list|)
return|;
block|}
comment|/// Returns the EVT that represents an integer with the given number of
comment|/// bits.
decl|static
name|EVT
name|getIntegerVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|unsigned
name|BitWidth
argument_list|)
block|{
name|MVT
name|M
init|=
name|MVT
operator|::
name|getIntegerVT
argument_list|(
name|BitWidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|M
operator|.
name|SimpleTy
operator|!=
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
condition|)
return|return
name|M
return|;
return|return
name|getExtendedIntegerVT
argument_list|(
name|Context
argument_list|,
name|BitWidth
argument_list|)
return|;
block|}
comment|/// Returns the EVT that represents a vector NumElements in length, where
comment|/// each element is of type VT.
decl|static
name|EVT
name|getVectorVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|EVT
name|VT
argument_list|,
name|unsigned
name|NumElements
argument_list|,
name|bool
name|IsScalable
operator|=
name|false
argument_list|)
block|{
name|MVT
name|M
init|=
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|VT
operator|.
name|V
argument_list|,
name|NumElements
argument_list|,
name|IsScalable
argument_list|)
decl_stmt|;
if|if
condition|(
name|M
operator|.
name|SimpleTy
operator|!=
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
condition|)
return|return
name|M
return|;
name|assert
argument_list|(
operator|!
name|IsScalable
operator|&&
literal|"We don't support extended scalable types yet"
argument_list|)
expr_stmt|;
return|return
name|getExtendedVectorVT
argument_list|(
name|Context
argument_list|,
name|VT
argument_list|,
name|NumElements
argument_list|)
return|;
block|}
comment|/// Returns the EVT that represents a vector EC.Min elements in length,
comment|/// where each element is of type VT.
decl|static
name|EVT
name|getVectorVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|EVT
name|VT
argument_list|,
name|MVT
operator|::
name|ElementCount
name|EC
argument_list|)
block|{
name|MVT
name|M
init|=
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|VT
operator|.
name|V
argument_list|,
name|EC
argument_list|)
decl_stmt|;
if|if
condition|(
name|M
operator|.
name|SimpleTy
operator|!=
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
condition|)
return|return
name|M
return|;
name|assert
argument_list|(
operator|!
name|EC
operator|.
name|Scalable
operator|&&
literal|"We don't support extended scalable types yet"
argument_list|)
expr_stmt|;
return|return
name|getExtendedVectorVT
argument_list|(
name|Context
argument_list|,
name|VT
argument_list|,
name|EC
operator|.
name|Min
argument_list|)
return|;
block|}
comment|/// Return a vector with the same number of elements as this vector, but
comment|/// with the element type converted to an integer type with the same
comment|/// bitwidth.
name|EVT
name|changeVectorElementTypeToInteger
argument_list|()
decl|const
block|{
if|if
condition|(
operator|!
name|isSimple
argument_list|()
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isScalableVector
argument_list|()
operator|&&
literal|"We don't support extended scalable types yet"
argument_list|)
expr_stmt|;
return|return
name|changeExtendedVectorElementTypeToInteger
argument_list|()
return|;
block|}
name|MVT
name|EltTy
init|=
name|getSimpleVT
argument_list|()
operator|.
name|getVectorElementType
argument_list|()
decl_stmt|;
name|unsigned
name|BitWidth
init|=
name|EltTy
operator|.
name|getSizeInBits
argument_list|()
decl_stmt|;
name|MVT
name|IntTy
init|=
name|MVT
operator|::
name|getIntegerVT
argument_list|(
name|BitWidth
argument_list|)
decl_stmt|;
name|MVT
name|VecTy
init|=
name|MVT
operator|::
name|getVectorVT
argument_list|(
name|IntTy
argument_list|,
name|getVectorNumElements
argument_list|()
argument_list|,
name|isScalableVector
argument_list|()
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|VecTy
operator|.
name|SimpleTy
operator|!=
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
operator|&&
literal|"Simple vector VT not representable by simple integer vector VT!"
argument_list|)
expr_stmt|;
return|return
name|VecTy
return|;
block|}
comment|/// Return the type converted to an equivalently sized integer or vector
comment|/// with integer element type. Similar to changeVectorElementTypeToInteger,
comment|/// but also handles scalars.
name|EVT
name|changeTypeToInteger
argument_list|()
block|{
if|if
condition|(
name|isVector
argument_list|()
condition|)
return|return
name|changeVectorElementTypeToInteger
argument_list|()
return|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|MVT
operator|::
name|getIntegerVT
argument_list|(
name|getSizeInBits
argument_list|()
argument_list|)
return|;
return|return
name|changeExtendedTypeToInteger
argument_list|()
return|;
block|}
comment|/// Test if the given EVT is simple (as opposed to being extended).
name|bool
name|isSimple
argument_list|()
decl|const
block|{
return|return
name|V
operator|.
name|SimpleTy
operator|!=
name|MVT
operator|::
name|INVALID_SIMPLE_VALUE_TYPE
return|;
block|}
comment|/// Test if the given EVT is extended (as opposed to being simple).
name|bool
name|isExtended
argument_list|()
decl|const
block|{
return|return
operator|!
name|isSimple
argument_list|()
return|;
block|}
comment|/// Return true if this is a FP or a vector FP type.
name|bool
name|isFloatingPoint
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isFloatingPoint
argument_list|()
else|:
name|isExtendedFloatingPoint
argument_list|()
return|;
block|}
comment|/// Return true if this is an integer or a vector integer type.
name|bool
name|isInteger
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isInteger
argument_list|()
else|:
name|isExtendedInteger
argument_list|()
return|;
block|}
comment|/// Return true if this is an integer, but not a vector.
name|bool
name|isScalarInteger
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isScalarInteger
argument_list|()
else|:
name|isExtendedScalarInteger
argument_list|()
return|;
block|}
comment|/// Return true if this is a vector value type.
name|bool
name|isVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|isVector
argument_list|()
else|:
name|isExtendedVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a vector type where the runtime
comment|/// length is machine dependent
name|bool
name|isScalableVector
argument_list|()
decl|const
block|{
comment|// FIXME: We don't support extended scalable types yet, because the
comment|// matching IR type doesn't exist. Once it has been added, this can
comment|// be changed to call isExtendedScalableVector.
if|if
condition|(
operator|!
name|isSimple
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|V
operator|.
name|isScalableVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 16-bit vector type.
name|bool
name|is16BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is16BitVector
argument_list|()
else|:
name|isExtended16BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 32-bit vector type.
name|bool
name|is32BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is32BitVector
argument_list|()
else|:
name|isExtended32BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 64-bit vector type.
name|bool
name|is64BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is64BitVector
argument_list|()
else|:
name|isExtended64BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 128-bit vector type.
name|bool
name|is128BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is128BitVector
argument_list|()
else|:
name|isExtended128BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 256-bit vector type.
name|bool
name|is256BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is256BitVector
argument_list|()
else|:
name|isExtended256BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 512-bit vector type.
name|bool
name|is512BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is512BitVector
argument_list|()
else|:
name|isExtended512BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 1024-bit vector type.
name|bool
name|is1024BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is1024BitVector
argument_list|()
else|:
name|isExtended1024BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is a 2048-bit vector type.
name|bool
name|is2048BitVector
argument_list|()
decl|const
block|{
return|return
name|isSimple
argument_list|()
condition|?
name|V
operator|.
name|is2048BitVector
argument_list|()
else|:
name|isExtended2048BitVector
argument_list|()
return|;
block|}
comment|/// Return true if this is an overloaded type for TableGen.
name|bool
name|isOverloaded
argument_list|()
decl|const
block|{
return|return
operator|(
name|V
operator|==
name|MVT
operator|::
name|iAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|fAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|vAny
operator|||
name|V
operator|==
name|MVT
operator|::
name|iPTRAny
operator|)
return|;
block|}
comment|/// Return true if the bit size is a multiple of 8.
name|bool
name|isByteSized
argument_list|()
decl|const
block|{
return|return
operator|(
name|getSizeInBits
argument_list|()
operator|&
literal|7
operator|)
operator|==
literal|0
return|;
block|}
comment|/// Return true if the size is a power-of-two number of bytes.
name|bool
name|isRound
argument_list|()
decl|const
block|{
name|unsigned
name|BitSize
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
return|return
name|BitSize
operator|>=
literal|8
operator|&&
operator|!
operator|(
name|BitSize
operator|&
operator|(
name|BitSize
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// Return true if this has the same number of bits as VT.
name|bool
name|bitsEq
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|==
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has more bits than VT.
name|bool
name|bitsGT
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|false
return|;
return|return
name|getSizeInBits
argument_list|()
operator|>
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has no less bits than VT.
name|bool
name|bitsGE
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|>=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has less bits than VT.
name|bool
name|bitsLT
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|false
return|;
return|return
name|getSizeInBits
argument_list|()
operator|<
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return true if this has no more bits than VT.
name|bool
name|bitsLE
argument_list|(
name|EVT
name|VT
argument_list|)
decl|const
block|{
if|if
condition|(
name|EVT
operator|::
name|operator
operator|==
operator|(
name|VT
operator|)
condition|)
return|return
name|true
return|;
return|return
name|getSizeInBits
argument_list|()
operator|<=
name|VT
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return the SimpleValueType held in the specified simple EVT.
name|MVT
name|getSimpleVT
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isSimple
argument_list|()
operator|&&
literal|"Expected a SimpleValueType!"
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
comment|/// If this is a vector type, return the element type, otherwise return
comment|/// this.
name|EVT
name|getScalarType
argument_list|()
decl|const
block|{
return|return
name|isVector
argument_list|()
condition|?
name|getVectorElementType
argument_list|()
else|:
operator|*
name|this
return|;
block|}
comment|/// Given a vector type, return the type of each element.
name|EVT
name|getVectorElementType
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isVector
argument_list|()
operator|&&
literal|"Invalid vector type!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getVectorElementType
argument_list|()
return|;
return|return
name|getExtendedVectorElementType
argument_list|()
return|;
block|}
comment|/// Given a vector type, return the number of elements it contains.
name|unsigned
name|getVectorNumElements
argument_list|()
decl|const
block|{
name|assert
argument_list|(
name|isVector
argument_list|()
operator|&&
literal|"Invalid vector type!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getVectorNumElements
argument_list|()
return|;
return|return
name|getExtendedVectorNumElements
argument_list|()
return|;
block|}
comment|// Given a (possibly scalable) vector type, return the ElementCount
name|MVT
decl|::
name|ElementCount
name|getVectorElementCount
argument_list|()
decl|const
block|{
name|assert
argument_list|(
operator|(
name|isVector
argument_list|()
operator|)
operator|&&
literal|"Invalid vector type!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getVectorElementCount
argument_list|()
return|;
name|assert
argument_list|(
operator|!
name|isScalableVector
argument_list|()
operator|&&
literal|"We don't support extended scalable types yet"
argument_list|)
expr_stmt|;
return|return
block|{
name|getExtendedVectorNumElements
argument_list|()
block|,
name|false
block|}
return|;
block|}
comment|/// Return the size of the specified value type in bits.
name|unsigned
name|getSizeInBits
argument_list|()
decl|const
block|{
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|getSizeInBits
argument_list|()
return|;
return|return
name|getExtendedSizeInBits
argument_list|()
return|;
block|}
name|unsigned
name|getScalarSizeInBits
argument_list|()
decl|const
block|{
return|return
name|getScalarType
argument_list|()
operator|.
name|getSizeInBits
argument_list|()
return|;
block|}
comment|/// Return the number of bytes overwritten by a store of the specified value
comment|/// type.
name|unsigned
name|getStoreSize
argument_list|()
decl|const
block|{
return|return
operator|(
name|getSizeInBits
argument_list|()
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
block|}
comment|/// Return the number of bits overwritten by a store of the specified value
comment|/// type.
name|unsigned
name|getStoreSizeInBits
argument_list|()
decl|const
block|{
return|return
name|getStoreSize
argument_list|()
operator|*
literal|8
return|;
block|}
comment|/// Rounds the bit-width of the given integer EVT up to the nearest power of
comment|/// two (and at least to eight), and returns the integer EVT with that
comment|/// number of bits.
name|EVT
name|getRoundIntegerType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isInteger
argument_list|()
operator|&&
operator|!
name|isVector
argument_list|()
operator|&&
literal|"Invalid integer type!"
argument_list|)
expr_stmt|;
name|unsigned
name|BitWidth
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
if|if
condition|(
name|BitWidth
operator|<=
literal|8
condition|)
return|return
name|EVT
argument_list|(
name|MVT
operator|::
name|i8
argument_list|)
return|;
return|return
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
literal|1
operator|<<
name|Log2_32_Ceil
argument_list|(
name|BitWidth
argument_list|)
argument_list|)
return|;
block|}
comment|/// Finds the smallest simple value type that is greater than or equal to
comment|/// half the width of this EVT. If no simple value type can be found, an
comment|/// extended integer value type of half the size (rounded up) is returned.
name|EVT
name|getHalfSizedIntegerVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|isInteger
argument_list|()
operator|&&
operator|!
name|isVector
argument_list|()
operator|&&
literal|"Invalid integer type!"
argument_list|)
expr_stmt|;
name|unsigned
name|EVTSize
init|=
name|getSizeInBits
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|IntVT
init|=
name|MVT
operator|::
name|FIRST_INTEGER_VALUETYPE
init|;
name|IntVT
operator|<=
name|MVT
operator|::
name|LAST_INTEGER_VALUETYPE
condition|;
operator|++
name|IntVT
control|)
block|{
name|EVT
name|HalfVT
init|=
name|EVT
argument_list|(
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|IntVT
argument_list|)
decl_stmt|;
if|if
condition|(
name|HalfVT
operator|.
name|getSizeInBits
argument_list|()
operator|*
literal|2
operator|>=
name|EVTSize
condition|)
return|return
name|HalfVT
return|;
block|}
return|return
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
operator|(
name|EVTSize
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
return|;
block|}
comment|/// Return a VT for an integer vector type with the size of the
comment|/// elements doubled. The typed returned may be an extended type.
name|EVT
name|widenIntegerVectorElementType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|EVT
name|EltVT
init|=
name|getVectorElementType
argument_list|()
decl_stmt|;
name|EltVT
operator|=
name|EVT
operator|::
name|getIntegerVT
argument_list|(
name|Context
argument_list|,
literal|2
operator|*
name|EltVT
operator|.
name|getSizeInBits
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EVT
operator|::
name|getVectorVT
argument_list|(
name|Context
argument_list|,
name|EltVT
argument_list|,
name|getVectorElementCount
argument_list|()
argument_list|)
return|;
block|}
comment|// Return a VT for a vector type with the same element type but
comment|// half the number of elements. The type returned may be an
comment|// extended type.
name|EVT
name|getHalfNumVectorElementsVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
name|EVT
name|EltVT
init|=
name|getVectorElementType
argument_list|()
decl_stmt|;
name|auto
name|EltCnt
init|=
name|getVectorElementCount
argument_list|()
decl_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|EltCnt
operator|.
name|Min
operator|&
literal|1
operator|)
operator|&&
literal|"Splitting vector, but not in half!"
argument_list|)
expr_stmt|;
return|return
name|EVT
operator|::
name|getVectorVT
argument_list|(
name|Context
argument_list|,
name|EltVT
argument_list|,
name|EltCnt
operator|/
literal|2
argument_list|)
return|;
block|}
comment|/// Returns true if the given vector is a power of 2.
name|bool
name|isPow2VectorType
argument_list|()
decl|const
block|{
name|unsigned
name|NElts
init|=
name|getVectorNumElements
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
name|NElts
operator|&
operator|(
name|NElts
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/// Widens the length of the given vector EVT up to the nearest power of 2
comment|/// and returns that type.
name|EVT
name|getPow2VectorType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|isPow2VectorType
argument_list|()
condition|)
block|{
name|unsigned
name|NElts
init|=
name|getVectorNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|Pow2NElts
init|=
literal|1
operator|<<
name|Log2_32_Ceil
argument_list|(
name|NElts
argument_list|)
decl_stmt|;
return|return
name|EVT
operator|::
name|getVectorVT
argument_list|(
name|Context
argument_list|,
name|getVectorElementType
argument_list|()
argument_list|,
name|Pow2NElts
argument_list|,
name|isScalableVector
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|*
name|this
return|;
block|}
block|}
comment|/// This function returns value type as a string, e.g. "i32".
name|std
decl|::
name|string
name|getEVTString
argument_list|()
decl|const
struct|;
comment|/// This method returns an LLVM type corresponding to the specified EVT.
comment|/// For integer types, this returns an unsigned type. Note that this will
comment|/// abort for types that cannot be represented.
name|Type
modifier|*
name|getTypeForEVT
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the value type corresponding to the specified type.
comment|/// This returns all pointers as iPTR.  If HandleUnknown is true, unknown
comment|/// types are returned as Other, otherwise they are invalid.
specifier|static
name|EVT
name|getEVT
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|HandleUnknown
init|=
name|false
parameter_list|)
function_decl|;
name|intptr_t
name|getRawBits
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isSimple
argument_list|()
condition|)
return|return
name|V
operator|.
name|SimpleTy
return|;
else|else
return|return
call|(
name|intptr_t
call|)
argument_list|(
name|LLVMTy
argument_list|)
return|;
block|}
comment|/// A meaningless but well-behaved order, useful for constructing
comment|/// containers.
struct|struct
name|compareRawBits
block|{
name|bool
name|operator
argument_list|()
operator|(
name|EVT
name|L
operator|,
name|EVT
name|R
operator|)
specifier|const
block|{
if|if
condition|(
name|L
operator|.
name|V
operator|.
name|SimpleTy
operator|==
name|R
operator|.
name|V
operator|.
name|SimpleTy
condition|)
return|return
name|L
operator|.
name|LLVMTy
operator|<
name|R
operator|.
name|LLVMTy
return|;
else|else
return|return
name|L
operator|.
name|V
operator|.
name|SimpleTy
operator|<
name|R
operator|.
name|V
operator|.
name|SimpleTy
return|;
block|}
block|}
struct|;
name|private
label|:
comment|// Methods for handling the Extended-type case in functions above.
comment|// These are all out-of-line to prevent users of this header file
comment|// from having a dependency on Type.h.
name|EVT
name|changeExtendedTypeToInteger
argument_list|()
specifier|const
expr_stmt|;
name|EVT
name|changeExtendedVectorElementTypeToInteger
argument_list|()
specifier|const
expr_stmt|;
specifier|static
name|EVT
name|getExtendedIntegerVT
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|BitWidth
parameter_list|)
function_decl|;
specifier|static
name|EVT
name|getExtendedVectorVT
parameter_list|(
name|LLVMContext
modifier|&
name|C
parameter_list|,
name|EVT
name|VT
parameter_list|,
name|unsigned
name|NumElements
parameter_list|)
function_decl|;
name|bool
name|isExtendedFloatingPoint
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtendedInteger
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtendedScalarInteger
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtendedVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended16BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended32BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended64BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended128BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended256BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended512BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended1024BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|bool
name|isExtended2048BitVector
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|EVT
name|getExtendedVectorElementType
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|getExtendedVectorNumElements
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|unsigned
name|getExtendedSizeInBits
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

