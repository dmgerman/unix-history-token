begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CallingConvLower.h - Calling Conventions -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the CCState and CCValAssign classes, used for lowering
end_comment

begin_comment
comment|// and implementing calling conventions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_CALLINGCONVLOWER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_CALLINGCONVLOWER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFrameInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallingConv.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCRegisterInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetCallingConv.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CCState
decl_stmt|;
name|class
name|MVT
decl_stmt|;
name|class
name|TargetMachine
decl_stmt|;
name|class
name|TargetRegisterInfo
decl_stmt|;
comment|/// CCValAssign - Represent assignment of one arg/retval to a location.
name|class
name|CCValAssign
block|{
name|public
label|:
enum|enum
name|LocInfo
block|{
name|Full
block|,
comment|// The value fills the full location.
name|SExt
block|,
comment|// The value is sign extended in the location.
name|ZExt
block|,
comment|// The value is zero extended in the location.
name|AExt
block|,
comment|// The value is extended with undefined upper bits.
name|SExtUpper
block|,
comment|// The value is in the upper bits of the location and should be
comment|// sign extended when retrieved.
name|ZExtUpper
block|,
comment|// The value is in the upper bits of the location and should be
comment|// zero extended when retrieved.
name|AExtUpper
block|,
comment|// The value is in the upper bits of the location and should be
comment|// extended with undefined upper bits when retrieved.
name|BCvt
block|,
comment|// The value is bit-converted in the location.
name|VExt
block|,
comment|// The value is vector-widened in the location.
comment|// FIXME: Not implemented yet. Code that uses AExt to mean
comment|// vector-widen should be fixed to use VExt instead.
name|FPExt
block|,
comment|// The floating-point value is fp-extended in the location.
name|Indirect
comment|// The location contains pointer to the value.
comment|// TODO: a subset of the value is in the location.
block|}
enum|;
name|private
label|:
comment|/// ValNo - This is the value number begin assigned (e.g. an argument number).
name|unsigned
name|ValNo
decl_stmt|;
comment|/// Loc is either a stack offset or a register number.
name|unsigned
name|Loc
decl_stmt|;
comment|/// isMem - True if this is a memory loc, false if it is a register loc.
name|unsigned
name|isMem
range|:
literal|1
decl_stmt|;
comment|/// isCustom - True if this arg/retval requires special handling.
name|unsigned
name|isCustom
range|:
literal|1
decl_stmt|;
comment|/// Information about how the value is assigned.
name|LocInfo
name|HTP
range|:
literal|6
decl_stmt|;
comment|/// ValVT - The type of the value being assigned.
name|MVT
name|ValVT
decl_stmt|;
comment|/// LocVT - The type of the location being assigned to.
name|MVT
name|LocVT
decl_stmt|;
name|public
label|:
specifier|static
name|CCValAssign
name|getReg
parameter_list|(
name|unsigned
name|ValNo
parameter_list|,
name|MVT
name|ValVT
parameter_list|,
name|unsigned
name|RegNo
parameter_list|,
name|MVT
name|LocVT
parameter_list|,
name|LocInfo
name|HTP
parameter_list|)
block|{
name|CCValAssign
name|Ret
decl_stmt|;
name|Ret
operator|.
name|ValNo
operator|=
name|ValNo
expr_stmt|;
name|Ret
operator|.
name|Loc
operator|=
name|RegNo
expr_stmt|;
name|Ret
operator|.
name|isMem
operator|=
name|false
expr_stmt|;
name|Ret
operator|.
name|isCustom
operator|=
name|false
expr_stmt|;
name|Ret
operator|.
name|HTP
operator|=
name|HTP
expr_stmt|;
name|Ret
operator|.
name|ValVT
operator|=
name|ValVT
expr_stmt|;
name|Ret
operator|.
name|LocVT
operator|=
name|LocVT
expr_stmt|;
return|return
name|Ret
return|;
block|}
specifier|static
name|CCValAssign
name|getCustomReg
parameter_list|(
name|unsigned
name|ValNo
parameter_list|,
name|MVT
name|ValVT
parameter_list|,
name|unsigned
name|RegNo
parameter_list|,
name|MVT
name|LocVT
parameter_list|,
name|LocInfo
name|HTP
parameter_list|)
block|{
name|CCValAssign
name|Ret
decl_stmt|;
name|Ret
operator|=
name|getReg
argument_list|(
name|ValNo
argument_list|,
name|ValVT
argument_list|,
name|RegNo
argument_list|,
name|LocVT
argument_list|,
name|HTP
argument_list|)
expr_stmt|;
name|Ret
operator|.
name|isCustom
operator|=
name|true
expr_stmt|;
return|return
name|Ret
return|;
block|}
specifier|static
name|CCValAssign
name|getMem
parameter_list|(
name|unsigned
name|ValNo
parameter_list|,
name|MVT
name|ValVT
parameter_list|,
name|unsigned
name|Offset
parameter_list|,
name|MVT
name|LocVT
parameter_list|,
name|LocInfo
name|HTP
parameter_list|)
block|{
name|CCValAssign
name|Ret
decl_stmt|;
name|Ret
operator|.
name|ValNo
operator|=
name|ValNo
expr_stmt|;
name|Ret
operator|.
name|Loc
operator|=
name|Offset
expr_stmt|;
name|Ret
operator|.
name|isMem
operator|=
name|true
expr_stmt|;
name|Ret
operator|.
name|isCustom
operator|=
name|false
expr_stmt|;
name|Ret
operator|.
name|HTP
operator|=
name|HTP
expr_stmt|;
name|Ret
operator|.
name|ValVT
operator|=
name|ValVT
expr_stmt|;
name|Ret
operator|.
name|LocVT
operator|=
name|LocVT
expr_stmt|;
return|return
name|Ret
return|;
block|}
specifier|static
name|CCValAssign
name|getCustomMem
parameter_list|(
name|unsigned
name|ValNo
parameter_list|,
name|MVT
name|ValVT
parameter_list|,
name|unsigned
name|Offset
parameter_list|,
name|MVT
name|LocVT
parameter_list|,
name|LocInfo
name|HTP
parameter_list|)
block|{
name|CCValAssign
name|Ret
decl_stmt|;
name|Ret
operator|=
name|getMem
argument_list|(
name|ValNo
argument_list|,
name|ValVT
argument_list|,
name|Offset
argument_list|,
name|LocVT
argument_list|,
name|HTP
argument_list|)
expr_stmt|;
name|Ret
operator|.
name|isCustom
operator|=
name|true
expr_stmt|;
return|return
name|Ret
return|;
block|}
comment|// There is no need to differentiate between a pending CCValAssign and other
comment|// kinds, as they are stored in a different list.
specifier|static
name|CCValAssign
name|getPending
parameter_list|(
name|unsigned
name|ValNo
parameter_list|,
name|MVT
name|ValVT
parameter_list|,
name|MVT
name|LocVT
parameter_list|,
name|LocInfo
name|HTP
parameter_list|,
name|unsigned
name|ExtraInfo
init|=
literal|0
parameter_list|)
block|{
return|return
name|getReg
argument_list|(
name|ValNo
argument_list|,
name|ValVT
argument_list|,
name|ExtraInfo
argument_list|,
name|LocVT
argument_list|,
name|HTP
argument_list|)
return|;
block|}
name|void
name|convertToReg
parameter_list|(
name|unsigned
name|RegNo
parameter_list|)
block|{
name|Loc
operator|=
name|RegNo
expr_stmt|;
name|isMem
operator|=
name|false
expr_stmt|;
block|}
name|void
name|convertToMem
parameter_list|(
name|unsigned
name|Offset
parameter_list|)
block|{
name|Loc
operator|=
name|Offset
expr_stmt|;
name|isMem
operator|=
name|true
expr_stmt|;
block|}
name|unsigned
name|getValNo
argument_list|()
specifier|const
block|{
return|return
name|ValNo
return|;
block|}
name|MVT
name|getValVT
argument_list|()
specifier|const
block|{
return|return
name|ValVT
return|;
block|}
name|bool
name|isRegLoc
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isMem
return|;
block|}
name|bool
name|isMemLoc
argument_list|()
specifier|const
block|{
return|return
name|isMem
return|;
block|}
name|bool
name|needsCustom
argument_list|()
specifier|const
block|{
return|return
name|isCustom
return|;
block|}
name|unsigned
name|getLocReg
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isRegLoc
argument_list|()
argument_list|)
block|;
return|return
name|Loc
return|;
block|}
name|unsigned
name|getLocMemOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isMemLoc
argument_list|()
argument_list|)
block|;
return|return
name|Loc
return|;
block|}
name|unsigned
name|getExtraInfo
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|MVT
name|getLocVT
argument_list|()
specifier|const
block|{
return|return
name|LocVT
return|;
block|}
name|LocInfo
name|getLocInfo
argument_list|()
specifier|const
block|{
return|return
name|HTP
return|;
block|}
name|bool
name|isExtInLoc
argument_list|()
specifier|const
block|{
return|return
operator|(
name|HTP
operator|==
name|AExt
operator|||
name|HTP
operator|==
name|SExt
operator|||
name|HTP
operator|==
name|ZExt
operator|)
return|;
block|}
name|bool
name|isUpperBitsInLoc
argument_list|()
specifier|const
block|{
return|return
name|HTP
operator|==
name|AExtUpper
operator|||
name|HTP
operator|==
name|SExtUpper
operator|||
name|HTP
operator|==
name|ZExtUpper
return|;
block|}
block|}
empty_stmt|;
comment|/// Describes a register that needs to be forwarded from the prologue to a
comment|/// musttail call.
struct|struct
name|ForwardedRegister
block|{
name|ForwardedRegister
argument_list|(
argument|unsigned VReg
argument_list|,
argument|MCPhysReg PReg
argument_list|,
argument|MVT VT
argument_list|)
block|:
name|VReg
argument_list|(
name|VReg
argument_list|)
operator|,
name|PReg
argument_list|(
name|PReg
argument_list|)
operator|,
name|VT
argument_list|(
argument|VT
argument_list|)
block|{}
name|unsigned
name|VReg
expr_stmt|;
name|MCPhysReg
name|PReg
decl_stmt|;
name|MVT
name|VT
decl_stmt|;
block|}
struct|;
comment|/// CCAssignFn - This function assigns a location for Val, updating State to
comment|/// reflect the change.  It returns 'true' if it failed to handle Val.
typedef|typedef
name|bool
name|CCAssignFn
argument_list|(
name|unsigned
name|ValNo
argument_list|,
name|MVT
name|ValVT
argument_list|,
name|MVT
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
typedef|;
comment|/// CCCustomFn - This function assigns a location for Val, possibly updating
comment|/// all args to reflect changes and indicates if it handled it. It must set
comment|/// isCustom if it handles the arg and returns true.
typedef|typedef
name|bool
name|CCCustomFn
argument_list|(
name|unsigned
operator|&
name|ValNo
argument_list|,
name|MVT
operator|&
name|ValVT
argument_list|,
name|MVT
operator|&
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
operator|&
name|LocInfo
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
operator|&
name|ArgFlags
argument_list|,
name|CCState
operator|&
name|State
argument_list|)
typedef|;
comment|/// CCState - This class holds information needed while lowering arguments and
comment|/// return values.  It captures which registers are already assigned and which
comment|/// stack slots are used.  It provides accessors to allocate these values.
name|class
name|CCState
block|{
name|private
label|:
name|CallingConv
operator|::
name|ID
name|CallingConv
expr_stmt|;
name|bool
name|IsVarArg
decl_stmt|;
name|bool
name|AnalyzingMustTailForwardedRegs
init|=
name|false
decl_stmt|;
name|MachineFunction
modifier|&
name|MF
decl_stmt|;
specifier|const
name|TargetRegisterInfo
modifier|&
name|TRI
decl_stmt|;
name|SmallVectorImpl
operator|<
name|CCValAssign
operator|>
operator|&
name|Locs
expr_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|unsigned
name|StackOffset
decl_stmt|;
name|unsigned
name|MaxStackArgAlign
decl_stmt|;
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|16
operator|>
name|UsedRegs
expr_stmt|;
name|SmallVector
operator|<
name|CCValAssign
operator|,
literal|4
operator|>
name|PendingLocs
expr_stmt|;
comment|// ByValInfo and SmallVector<ByValInfo, 4> ByValRegs:
comment|//
comment|// Vector of ByValInfo instances (ByValRegs) is introduced for byval registers
comment|// tracking.
comment|// Or, in another words it tracks byval parameters that are stored in
comment|// general purpose registers.
comment|//
comment|// For 4 byte stack alignment,
comment|// instance index means byval parameter number in formal
comment|// arguments set. Assume, we have some "struct_type" with size = 4 bytes,
comment|// then, for function "foo":
comment|//
comment|// i32 foo(i32 %p, %struct_type* %r, i32 %s, %struct_type* %t)
comment|//
comment|// ByValRegs[0] describes how "%r" is stored (Begin == r1, End == r2)
comment|// ByValRegs[1] describes how "%t" is stored (Begin == r3, End == r4).
comment|//
comment|// In case of 8 bytes stack alignment,
comment|// ByValRegs may also contain information about wasted registers.
comment|// In function shown above, r3 would be wasted according to AAPCS rules.
comment|// And in that case ByValRegs[1].Waste would be "true".
comment|// ByValRegs vector size still would be 2,
comment|// while "%t" goes to the stack: it wouldn't be described in ByValRegs.
comment|//
comment|// Supposed use-case for this collection:
comment|// 1. Initially ByValRegs is empty, InRegsParamsProcessed is 0.
comment|// 2. HandleByVal fillups ByValRegs.
comment|// 3. Argument analysis (LowerFormatArguments, for example). After
comment|// some byval argument was analyzed, InRegsParamsProcessed is increased.
struct|struct
name|ByValInfo
block|{
name|ByValInfo
argument_list|(
argument|unsigned B
argument_list|,
argument|unsigned E
argument_list|,
argument|bool IsWaste = false
argument_list|)
block|:
name|Begin
argument_list|(
name|B
argument_list|)
operator|,
name|End
argument_list|(
name|E
argument_list|)
operator|,
name|Waste
argument_list|(
argument|IsWaste
argument_list|)
block|{}
comment|// First register allocated for current parameter.
name|unsigned
name|Begin
expr_stmt|;
comment|// First after last register allocated for current parameter.
name|unsigned
name|End
decl_stmt|;
comment|// Means that current range of registers doesn't belong to any
comment|// parameters. It was wasted due to stack alignment rules.
comment|// For more information see:
comment|// AAPCS, 5.5 Parameter Passing, Stage C, C.3.
name|bool
name|Waste
decl_stmt|;
block|}
struct|;
name|SmallVector
operator|<
name|ByValInfo
operator|,
literal|4
operator|>
name|ByValRegs
expr_stmt|;
comment|// InRegsParamsProcessed - shows how many instances of ByValRegs was proceed
comment|// during argument analysis.
name|unsigned
name|InRegsParamsProcessed
decl_stmt|;
name|public
label|:
name|CCState
argument_list|(
argument|CallingConv::ID CC
argument_list|,
argument|bool isVarArg
argument_list|,
argument|MachineFunction&MF
argument_list|,
argument|SmallVectorImpl<CCValAssign>&locs
argument_list|,
argument|LLVMContext&C
argument_list|)
empty_stmt|;
name|void
name|addLoc
parameter_list|(
specifier|const
name|CCValAssign
modifier|&
name|V
parameter_list|)
block|{
name|Locs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|LLVMContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
name|MachineFunction
operator|&
name|getMachineFunction
argument_list|()
specifier|const
block|{
return|return
name|MF
return|;
block|}
name|CallingConv
operator|::
name|ID
name|getCallingConv
argument_list|()
specifier|const
block|{
return|return
name|CallingConv
return|;
block|}
name|bool
name|isVarArg
argument_list|()
specifier|const
block|{
return|return
name|IsVarArg
return|;
block|}
comment|/// getNextStackOffset - Return the next stack offset such that all stack
comment|/// slots satisfy their alignment requirements.
name|unsigned
name|getNextStackOffset
argument_list|()
specifier|const
block|{
return|return
name|StackOffset
return|;
block|}
comment|/// getAlignedCallFrameSize - Return the size of the call frame needed to
comment|/// be able to store all arguments and such that the alignment requirement
comment|/// of each of the arguments is satisfied.
name|unsigned
name|getAlignedCallFrameSize
argument_list|()
specifier|const
block|{
return|return
name|alignTo
argument_list|(
name|StackOffset
argument_list|,
name|MaxStackArgAlign
argument_list|)
return|;
block|}
comment|/// isAllocated - Return true if the specified register (or an alias) is
comment|/// allocated.
name|bool
name|isAllocated
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
block|{
return|return
name|UsedRegs
index|[
name|Reg
operator|/
literal|32
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|Reg
operator|&
literal|31
operator|)
operator|)
return|;
block|}
comment|/// AnalyzeFormalArguments - Analyze an array of argument values,
comment|/// incorporating info about the formals into this state.
name|void
name|AnalyzeFormalArguments
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|InputArg
operator|>
operator|&
name|Ins
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// The function will invoke AnalyzeFormalArguments.
name|void
name|AnalyzeArguments
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|InputArg
operator|>
operator|&
name|Ins
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
block|{
name|AnalyzeFormalArguments
argument_list|(
name|Ins
argument_list|,
name|Fn
argument_list|)
expr_stmt|;
block|}
comment|/// AnalyzeReturn - Analyze the returned values of a return,
comment|/// incorporating info about the result values into this state.
name|void
name|AnalyzeReturn
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|OutputArg
operator|>
operator|&
name|Outs
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// CheckReturn - Analyze the return values of a function, returning
comment|/// true if the return can be performed without sret-demotion, and
comment|/// false otherwise.
name|bool
name|CheckReturn
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|OutputArg
operator|>
operator|&
name|ArgsFlags
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// AnalyzeCallOperands - Analyze the outgoing arguments to a call,
comment|/// incorporating info about the passed values into this state.
name|void
name|AnalyzeCallOperands
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|OutputArg
operator|>
operator|&
name|Outs
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// AnalyzeCallOperands - Same as above except it takes vectors of types
comment|/// and argument flags.
name|void
name|AnalyzeCallOperands
argument_list|(
name|SmallVectorImpl
operator|<
name|MVT
operator|>
operator|&
name|ArgVTs
argument_list|,
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|ArgFlagsTy
operator|>
operator|&
name|Flags
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// The function will invoke AnalyzeCallOperands.
name|void
name|AnalyzeArguments
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|OutputArg
operator|>
operator|&
name|Outs
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
block|{
name|AnalyzeCallOperands
argument_list|(
name|Outs
argument_list|,
name|Fn
argument_list|)
expr_stmt|;
block|}
comment|/// AnalyzeCallResult - Analyze the return values of a call,
comment|/// incorporating info about the passed values into this state.
name|void
name|AnalyzeCallResult
argument_list|(
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|InputArg
operator|>
operator|&
name|Ins
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// A shadow allocated register is a register that was allocated
comment|/// but wasn't added to the location list (Locs).
comment|/// \returns true if the register was allocated as shadow or false otherwise.
name|bool
name|IsShadowAllocatedReg
argument_list|(
name|unsigned
name|Reg
argument_list|)
decl|const
decl_stmt|;
comment|/// AnalyzeCallResult - Same as above except it's specialized for calls which
comment|/// produce a single value.
name|void
name|AnalyzeCallResult
parameter_list|(
name|MVT
name|VT
parameter_list|,
name|CCAssignFn
name|Fn
parameter_list|)
function_decl|;
comment|/// getFirstUnallocated - Return the index of the first unallocated register
comment|/// in the set, or Regs.size() if they are all allocated.
name|unsigned
name|getFirstUnallocated
argument_list|(
name|ArrayRef
operator|<
name|MCPhysReg
operator|>
name|Regs
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Regs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isAllocated
argument_list|(
name|Regs
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
return|return
name|Regs
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// AllocateReg - Attempt to allocate one register.  If it is not available,
comment|/// return zero.  Otherwise, return the register, marking it and any aliases
comment|/// as allocated.
name|unsigned
name|AllocateReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
if|if
condition|(
name|isAllocated
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
literal|0
return|;
name|MarkAllocated
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
return|return
name|Reg
return|;
block|}
comment|/// Version of AllocateReg with extra register to be shadowed.
name|unsigned
name|AllocateReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|,
name|unsigned
name|ShadowReg
parameter_list|)
block|{
if|if
condition|(
name|isAllocated
argument_list|(
name|Reg
argument_list|)
condition|)
return|return
literal|0
return|;
name|MarkAllocated
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
name|MarkAllocated
argument_list|(
name|ShadowReg
argument_list|)
expr_stmt|;
return|return
name|Reg
return|;
block|}
comment|/// AllocateReg - Attempt to allocate one of the specified registers.  If none
comment|/// are available, return zero.  Otherwise, return the first one available,
comment|/// marking it and any aliases as allocated.
name|unsigned
name|AllocateReg
argument_list|(
name|ArrayRef
operator|<
name|MCPhysReg
operator|>
name|Regs
argument_list|)
block|{
name|unsigned
name|FirstUnalloc
init|=
name|getFirstUnallocated
argument_list|(
name|Regs
argument_list|)
decl_stmt|;
if|if
condition|(
name|FirstUnalloc
operator|==
name|Regs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Didn't find the reg.
comment|// Mark the register and any aliases as allocated.
name|unsigned
name|Reg
init|=
name|Regs
index|[
name|FirstUnalloc
index|]
decl_stmt|;
name|MarkAllocated
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
return|return
name|Reg
return|;
block|}
comment|/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive
comment|/// registers. If this is not possible, return zero. Otherwise, return the first
comment|/// register of the block that were allocated, marking the entire block as allocated.
name|unsigned
name|AllocateRegBlock
argument_list|(
name|ArrayRef
operator|<
name|MCPhysReg
operator|>
name|Regs
argument_list|,
name|unsigned
name|RegsRequired
argument_list|)
block|{
if|if
condition|(
name|RegsRequired
operator|>
name|Regs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
for|for
control|(
name|unsigned
name|StartIdx
init|=
literal|0
init|;
name|StartIdx
operator|<=
name|Regs
operator|.
name|size
argument_list|()
operator|-
name|RegsRequired
condition|;
operator|++
name|StartIdx
control|)
block|{
name|bool
name|BlockAvailable
init|=
name|true
decl_stmt|;
comment|// Check for already-allocated regs in this block
for|for
control|(
name|unsigned
name|BlockIdx
init|=
literal|0
init|;
name|BlockIdx
operator|<
name|RegsRequired
condition|;
operator|++
name|BlockIdx
control|)
block|{
if|if
condition|(
name|isAllocated
argument_list|(
name|Regs
index|[
name|StartIdx
operator|+
name|BlockIdx
index|]
argument_list|)
condition|)
block|{
name|BlockAvailable
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|BlockAvailable
condition|)
block|{
comment|// Mark the entire block as allocated
for|for
control|(
name|unsigned
name|BlockIdx
init|=
literal|0
init|;
name|BlockIdx
operator|<
name|RegsRequired
condition|;
operator|++
name|BlockIdx
control|)
block|{
name|MarkAllocated
argument_list|(
name|Regs
index|[
name|StartIdx
operator|+
name|BlockIdx
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|Regs
index|[
name|StartIdx
index|]
return|;
block|}
block|}
comment|// No block was available
return|return
literal|0
return|;
block|}
comment|/// Version of AllocateReg with list of registers to be shadowed.
name|unsigned
name|AllocateReg
argument_list|(
name|ArrayRef
operator|<
name|MCPhysReg
operator|>
name|Regs
argument_list|,
specifier|const
name|MCPhysReg
operator|*
name|ShadowRegs
argument_list|)
block|{
name|unsigned
name|FirstUnalloc
init|=
name|getFirstUnallocated
argument_list|(
name|Regs
argument_list|)
decl_stmt|;
if|if
condition|(
name|FirstUnalloc
operator|==
name|Regs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Didn't find the reg.
comment|// Mark the register and any aliases as allocated.
name|unsigned
name|Reg
init|=
name|Regs
index|[
name|FirstUnalloc
index|]
decl_stmt|,
name|ShadowReg
init|=
name|ShadowRegs
index|[
name|FirstUnalloc
index|]
decl_stmt|;
name|MarkAllocated
argument_list|(
name|Reg
argument_list|)
expr_stmt|;
name|MarkAllocated
argument_list|(
name|ShadowReg
argument_list|)
expr_stmt|;
return|return
name|Reg
return|;
block|}
comment|/// AllocateStack - Allocate a chunk of stack space with the specified size
comment|/// and alignment.
name|unsigned
name|AllocateStack
parameter_list|(
name|unsigned
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|)
block|{
name|assert
argument_list|(
name|Align
operator|&&
operator|(
operator|(
name|Align
operator|-
literal|1
operator|)
operator|&
name|Align
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Align is power of 2.
name|StackOffset
operator|=
name|alignTo
argument_list|(
name|StackOffset
argument_list|,
name|Align
argument_list|)
expr_stmt|;
name|unsigned
name|Result
init|=
name|StackOffset
decl_stmt|;
name|StackOffset
operator|+=
name|Size
expr_stmt|;
name|MaxStackArgAlign
operator|=
name|std
operator|::
name|max
argument_list|(
name|Align
argument_list|,
name|MaxStackArgAlign
argument_list|)
expr_stmt|;
name|ensureMaxAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
name|void
name|ensureMaxAlignment
parameter_list|(
name|unsigned
name|Align
parameter_list|)
block|{
if|if
condition|(
operator|!
name|AnalyzingMustTailForwardedRegs
condition|)
name|MF
operator|.
name|getFrameInfo
argument_list|()
operator|.
name|ensureMaxAlignment
argument_list|(
name|Align
argument_list|)
expr_stmt|;
block|}
comment|/// Version of AllocateStack with extra register to be shadowed.
name|unsigned
name|AllocateStack
parameter_list|(
name|unsigned
name|Size
parameter_list|,
name|unsigned
name|Align
parameter_list|,
name|unsigned
name|ShadowReg
parameter_list|)
block|{
name|MarkAllocated
argument_list|(
name|ShadowReg
argument_list|)
expr_stmt|;
return|return
name|AllocateStack
argument_list|(
name|Size
argument_list|,
name|Align
argument_list|)
return|;
block|}
comment|/// Version of AllocateStack with list of extra registers to be shadowed.
comment|/// Note that, unlike AllocateReg, this shadows ALL of the shadow registers.
name|unsigned
name|AllocateStack
argument_list|(
name|unsigned
name|Size
argument_list|,
name|unsigned
name|Align
argument_list|,
name|ArrayRef
operator|<
name|MCPhysReg
operator|>
name|ShadowRegs
argument_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ShadowRegs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|MarkAllocated
argument_list|(
name|ShadowRegs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|AllocateStack
argument_list|(
name|Size
argument_list|,
name|Align
argument_list|)
return|;
block|}
comment|// HandleByVal - Allocate a stack slot large enough to pass an argument by
comment|// value. The size and alignment information of the argument is encoded in its
comment|// parameter attribute.
name|void
name|HandleByVal
argument_list|(
name|unsigned
name|ValNo
argument_list|,
name|MVT
name|ValVT
argument_list|,
name|MVT
name|LocVT
argument_list|,
name|CCValAssign
operator|::
name|LocInfo
name|LocInfo
argument_list|,
name|int
name|MinSize
argument_list|,
name|int
name|MinAlign
argument_list|,
name|ISD
operator|::
name|ArgFlagsTy
name|ArgFlags
argument_list|)
decl_stmt|;
comment|// Returns count of byval arguments that are to be stored (even partly)
comment|// in registers.
name|unsigned
name|getInRegsParamsCount
argument_list|()
specifier|const
block|{
return|return
name|ByValRegs
operator|.
name|size
argument_list|()
return|;
block|}
comment|// Returns count of byval in-regs arguments proceed.
name|unsigned
name|getInRegsParamsProcessed
argument_list|()
specifier|const
block|{
return|return
name|InRegsParamsProcessed
return|;
block|}
comment|// Get information about N-th byval parameter that is stored in registers.
comment|// Here "ByValParamIndex" is N.
name|void
name|getInRegsParamInfo
argument_list|(
name|unsigned
name|InRegsParamRecordIndex
argument_list|,
name|unsigned
operator|&
name|BeginReg
argument_list|,
name|unsigned
operator|&
name|EndReg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|InRegsParamRecordIndex
operator|<
name|ByValRegs
operator|.
name|size
argument_list|()
operator|&&
literal|"Wrong ByVal parameter index"
argument_list|)
expr_stmt|;
specifier|const
name|ByValInfo
modifier|&
name|info
init|=
name|ByValRegs
index|[
name|InRegsParamRecordIndex
index|]
decl_stmt|;
name|BeginReg
operator|=
name|info
operator|.
name|Begin
expr_stmt|;
name|EndReg
operator|=
name|info
operator|.
name|End
expr_stmt|;
block|}
comment|// Add information about parameter that is kept in registers.
name|void
name|addInRegsParamInfo
parameter_list|(
name|unsigned
name|RegBegin
parameter_list|,
name|unsigned
name|RegEnd
parameter_list|)
block|{
name|ByValRegs
operator|.
name|push_back
argument_list|(
name|ByValInfo
argument_list|(
name|RegBegin
argument_list|,
name|RegEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Goes either to next byval parameter (excluding "waste" record), or
comment|// to the end of collection.
comment|// Returns false, if end is reached.
name|bool
name|nextInRegsParam
parameter_list|()
block|{
name|unsigned
name|e
init|=
name|ByValRegs
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|InRegsParamsProcessed
operator|<
name|e
condition|)
operator|++
name|InRegsParamsProcessed
expr_stmt|;
return|return
name|InRegsParamsProcessed
operator|<
name|e
return|;
block|}
comment|// Clear byval registers tracking info.
name|void
name|clearByValRegsInfo
parameter_list|()
block|{
name|InRegsParamsProcessed
operator|=
literal|0
expr_stmt|;
name|ByValRegs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Rewind byval registers tracking info.
name|void
name|rewindByValRegsInfo
parameter_list|()
block|{
name|InRegsParamsProcessed
operator|=
literal|0
expr_stmt|;
block|}
comment|// Get list of pending assignments
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|CCValAssign
operator|>
operator|&
name|getPendingLocs
argument_list|()
block|{
return|return
name|PendingLocs
return|;
block|}
comment|/// Compute the remaining unused register parameters that would be used for
comment|/// the given value type. This is useful when varargs are passed in the
comment|/// registers that normal prototyped parameters would be passed in, or for
comment|/// implementing perfect forwarding.
name|void
name|getRemainingRegParmsForType
argument_list|(
name|SmallVectorImpl
operator|<
name|MCPhysReg
operator|>
operator|&
name|Regs
argument_list|,
name|MVT
name|VT
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// Compute the set of registers that need to be preserved and forwarded to
comment|/// any musttail calls.
name|void
name|analyzeMustTailForwardedRegisters
argument_list|(
name|SmallVectorImpl
operator|<
name|ForwardedRegister
operator|>
operator|&
name|Forwards
argument_list|,
name|ArrayRef
operator|<
name|MVT
operator|>
name|RegParmTypes
argument_list|,
name|CCAssignFn
name|Fn
argument_list|)
decl_stmt|;
comment|/// Returns true if the results of the two calling conventions are compatible.
comment|/// This is usually part of the check for tailcall eligibility.
specifier|static
name|bool
name|resultsCompatible
argument_list|(
name|CallingConv
operator|::
name|ID
name|CalleeCC
argument_list|,
name|CallingConv
operator|::
name|ID
name|CallerCC
argument_list|,
name|MachineFunction
operator|&
name|MF
argument_list|,
name|LLVMContext
operator|&
name|C
argument_list|,
specifier|const
name|SmallVectorImpl
operator|<
name|ISD
operator|::
name|InputArg
operator|>
operator|&
name|Ins
argument_list|,
name|CCAssignFn
name|CalleeFn
argument_list|,
name|CCAssignFn
name|CallerFn
argument_list|)
decl_stmt|;
comment|/// The function runs an additional analysis pass over function arguments.
comment|/// It will mark each argument with the attribute flag SecArgPass.
comment|/// After running, it will sort the locs list.
name|template
operator|<
name|class
name|T
operator|>
name|void
name|AnalyzeArgumentsSecondPass
argument_list|(
argument|const SmallVectorImpl<T>&Args
argument_list|,
argument|CCAssignFn Fn
argument_list|)
block|{
name|unsigned
name|NumFirstPassLocs
operator|=
name|Locs
operator|.
name|size
argument_list|()
block|;
comment|/// Creates similar argument list to \p Args in which each argument is
comment|/// marked using SecArgPass flag.
name|SmallVector
operator|<
name|T
block|,
literal|16
operator|>
name|SecPassArg
block|;
comment|// SmallVector<ISD::InputArg, 16> SecPassArg;
for|for
control|(
name|auto
name|Arg
range|:
name|Args
control|)
block|{
name|Arg
operator|.
name|Flags
operator|.
name|setSecArgPass
argument_list|()
expr_stmt|;
name|SecPassArg
operator|.
name|push_back
argument_list|(
name|Arg
argument_list|)
expr_stmt|;
block|}
comment|// Run the second argument pass
name|AnalyzeArguments
argument_list|(
name|SecPassArg
argument_list|,
name|Fn
argument_list|)
expr_stmt|;
comment|// Sort the locations of the arguments according to their original position.
name|SmallVector
operator|<
name|CCValAssign
operator|,
literal|16
operator|>
name|TmpArgLocs
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|TmpArgLocs
argument_list|,
name|Locs
argument_list|)
expr_stmt|;
name|auto
name|B
init|=
name|TmpArgLocs
operator|.
name|begin
argument_list|()
decl_stmt|,
name|E
init|=
name|TmpArgLocs
operator|.
name|end
argument_list|()
decl_stmt|;
name|std
operator|::
name|merge
argument_list|(
argument|B
argument_list|,
argument|B + NumFirstPassLocs
argument_list|,
argument|B + NumFirstPassLocs
argument_list|,
argument|E
argument_list|,
argument|std::back_inserter(Locs)
argument_list|,
argument|[](const CCValAssign&A, const CCValAssign&B) -> bool {                  return A.getValNo()< B.getValNo();                }
argument_list|)
expr_stmt|;
block|}
name|private
label|:
comment|/// MarkAllocated - Mark a register and all of its aliases as allocated.
name|void
name|MarkAllocated
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

