begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/CodeGen/GCStrategy.h - Garbage collection ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GCStrategy coordinates code generation algorithms and implements some itself
end_comment

begin_comment
comment|// in order to generate code compatible with a target code generator as
end_comment

begin_comment
comment|// specified in a function's 'gc' attribute. Algorithms are enabled by setting
end_comment

begin_comment
comment|// flags in a subclass's constructor, and some virtual methods can be
end_comment

begin_comment
comment|// overridden.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GCStrategy is relevant for implementations using either gc.root or
end_comment

begin_comment
comment|// gc.statepoint based lowering strategies, but is currently focused mostly on
end_comment

begin_comment
comment|// options for gc.root.  This will change over time.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When requested by a subclass of GCStrategy, the gc.root implementation will
end_comment

begin_comment
comment|// populate GCModuleInfo and GCFunctionInfo with that about each Function in
end_comment

begin_comment
comment|// the Module that opts in to garbage collection.  Specifically:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - Safe points
end_comment

begin_comment
comment|//   Garbage collection is generally only possible at certain points in code.
end_comment

begin_comment
comment|//   GCStrategy can request that the collector insert such points:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     - At and after any call to a subroutine
end_comment

begin_comment
comment|//     - Before returning from the current function
end_comment

begin_comment
comment|//     - Before backwards branches (loops)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// - Roots
end_comment

begin_comment
comment|//   When a reference to a GC-allocated object exists on the stack, it must be
end_comment

begin_comment
comment|//   stored in an alloca registered with llvm.gcoot.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This information can used to emit the metadata tables which are required by
end_comment

begin_comment
comment|// the target garbage collector runtime.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When used with gc.statepoint, information about safepoint and roots can be
end_comment

begin_comment
comment|// found in the binary StackMap section after code generation.  Safepoint
end_comment

begin_comment
comment|// placement is currently the responsibility of the frontend, though late
end_comment

begin_comment
comment|// insertion support is planned.  gc.statepoint does not currently support
end_comment

begin_comment
comment|// custom stack map formats; such can be generated by parsing the standard
end_comment

begin_comment
comment|// stack map section if desired.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The read and write barrier support can be used with either implementation.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_GCSTRATEGY_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_GCSTRATEGY_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/GCMetadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Registry.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// GCStrategy describes a garbage collector algorithm's code generation
comment|/// requirements, and provides overridable hooks for those needs which cannot
comment|/// be abstractly described.  GCStrategy objects currently must be looked up
comment|/// through the GCModuleInfo analysis pass.  They are owned by the analysis
comment|/// pass and recreated every time that pass is invalidated.
name|class
name|GCStrategy
block|{
name|private
label|:
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|friend
name|class
name|GCModuleInfo
decl_stmt|;
name|protected
label|:
name|bool
name|UseStatepoints
decl_stmt|;
comment|/// Uses gc.statepoints as opposed to gc.roots,
comment|/// if set, none of the other options can be
comment|/// anything but their default values.
name|unsigned
name|NeededSafePoints
decl_stmt|;
comment|///< Bitmask of required safe points.
name|bool
name|CustomReadBarriers
decl_stmt|;
comment|///< Default is to insert loads.
name|bool
name|CustomWriteBarriers
decl_stmt|;
comment|///< Default is to insert stores.
name|bool
name|CustomRoots
decl_stmt|;
comment|///< Default is to pass through to backend.
name|bool
name|CustomSafePoints
decl_stmt|;
comment|///< Default is to use NeededSafePoints
comment|///< to find safe points.
name|bool
name|InitRoots
decl_stmt|;
comment|///< If set, roots are nulled during lowering.
name|bool
name|UsesMetadata
decl_stmt|;
comment|///< If set, backend must emit metadata tables.
name|public
label|:
name|GCStrategy
argument_list|()
expr_stmt|;
name|virtual
operator|~
name|GCStrategy
argument_list|()
block|{}
comment|/// Return the name of the GC strategy.  This is the value of the collector
comment|/// name string specified on functions which use this strategy.
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
comment|/// By default, write barriers are replaced with simple store
comment|/// instructions. If true, then performCustomLowering must instead lower
comment|/// them.
name|bool
name|customWriteBarrier
argument_list|()
specifier|const
block|{
return|return
name|CustomWriteBarriers
return|;
block|}
comment|/// By default, read barriers are replaced with simple load
comment|/// instructions. If true, then performCustomLowering must instead lower
comment|/// them.
name|bool
name|customReadBarrier
argument_list|()
specifier|const
block|{
return|return
name|CustomReadBarriers
return|;
block|}
comment|/// Returns true if this strategy is expecting the use of gc.statepoints,
comment|/// and false otherwise.
name|bool
name|useStatepoints
argument_list|()
specifier|const
block|{
return|return
name|UseStatepoints
return|;
block|}
comment|/** @name Statepoint Specific Properties */
comment|///@{
comment|/// If the value specified can be reliably distinguished, returns true for
comment|/// pointers to GC managed locations and false for pointers to non-GC
comment|/// managed locations.  Note a GCStrategy can always return 'None' (i.e. an
comment|/// empty optional indicating it can't reliably distinguish.
name|virtual
name|Optional
operator|<
name|bool
operator|>
name|isGCManagedPointer
argument_list|(
argument|const Value *V
argument_list|)
specifier|const
block|{
return|return
name|None
return|;
block|}
comment|///@}
comment|/** @name GCRoot Specific Properties      * These properties and overrides only apply to collector strategies using      * GCRoot.       */
comment|///@{
comment|/// True if safe points of any kind are required. By default, none are
comment|/// recorded.
name|bool
name|needsSafePoints
argument_list|()
specifier|const
block|{
return|return
name|CustomSafePoints
operator|||
name|NeededSafePoints
operator|!=
literal|0
return|;
block|}
comment|/// True if the given kind of safe point is required. By default, none are
comment|/// recorded.
name|bool
name|needsSafePoint
argument_list|(
name|GC
operator|::
name|PointKind
name|Kind
argument_list|)
decl|const
block|{
return|return
operator|(
name|NeededSafePoints
operator|&
literal|1
operator|<<
name|Kind
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// By default, roots are left for the code generator so it can generate a
comment|/// stack map. If true, then performCustomLowering must delete them.
name|bool
name|customRoots
argument_list|()
specifier|const
block|{
return|return
name|CustomRoots
return|;
block|}
comment|/// By default, the GC analysis will find safe points according to
comment|/// NeededSafePoints. If true, then findCustomSafePoints must create them.
name|bool
name|customSafePoints
argument_list|()
specifier|const
block|{
return|return
name|CustomSafePoints
return|;
block|}
comment|/// If set, gcroot intrinsics should initialize their allocas to null
comment|/// before the first use. This is necessary for most GCs and is enabled by
comment|/// default.
name|bool
name|initializeRoots
argument_list|()
specifier|const
block|{
return|return
name|InitRoots
return|;
block|}
comment|/// If set, appropriate metadata tables must be emitted by the back-end
comment|/// (assembler, JIT, or otherwise). For statepoint, this method is
comment|/// currently unsupported.  The stackmap information can be found in the
comment|/// StackMap section as described in the documentation.
name|bool
name|usesMetadata
argument_list|()
specifier|const
block|{
return|return
name|UsesMetadata
return|;
block|}
comment|///@}
comment|/// initializeCustomLowering/performCustomLowering - If any of the actions
comment|/// are set to custom, performCustomLowering must be overriden to transform
comment|/// the corresponding actions to LLVM IR. initializeCustomLowering is
comment|/// optional to override. These are the only GCStrategy methods through
comment|/// which the LLVM IR can be modified.  These methods apply mostly to
comment|/// gc.root based implementations, but can be overriden to provide custom
comment|/// barrier lowerings with gc.statepoint as well.
comment|///@{
name|virtual
name|bool
name|initializeCustomLowering
parameter_list|(
name|Module
modifier|&
name|F
parameter_list|)
block|{
comment|// No changes made
return|return
name|false
return|;
block|}
name|virtual
name|bool
name|performCustomLowering
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"GCStrategy subclass specified a configuration which"
literal|"requires a custom lowering without providing one"
argument_list|)
expr_stmt|;
block|}
comment|///@}
comment|/// Called if customSafepoints returns true, used only by gc.root
comment|/// implementations.
name|virtual
name|bool
name|findCustomSafePoints
parameter_list|(
name|GCFunctionInfo
modifier|&
name|FI
parameter_list|,
name|MachineFunction
modifier|&
name|MF
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"GCStrategy subclass specified a configuration which"
literal|"requests custom safepoint identification without"
literal|"providing an implementation for such"
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// Subclasses of GCStrategy are made available for use during compilation by
comment|/// adding them to the global GCRegistry.  This can done either within the
comment|/// LLVM source tree or via a loadable plugin.  An example registeration
comment|/// would be:
comment|/// static GCRegistry::Add<CustomGC> X("custom-name",
comment|///        "my custom supper fancy gc strategy");
comment|///
comment|/// Note that to use a custom GCMetadataPrinter w/gc.roots, you must also
comment|/// register your GCMetadataPrinter subclass with the
comment|/// GCMetadataPrinterRegistery as well.
typedef|typedef
name|Registry
operator|<
name|GCStrategy
operator|>
name|GCRegistry
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

