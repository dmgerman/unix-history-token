begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------- RPCUTils.h - Utilities for building RPC APIs -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Utilities to support construction of simple RPC APIs.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The RPC utilities aim for ease of use (minimal conceptual overhead) for C++
end_comment

begin_comment
comment|// programmers, high performance, low memory overhead, and efficient use of the
end_comment

begin_comment
comment|// communications channel.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_EXECUTIONENGINE_ORC_RPCUTILS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_EXECUTIONENGINE_ORC_RPCUTILS_H
end_define

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<thread>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/OrcError.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/RPCSerialization.h"
end_include

begin_include
include|#
directive|include
file|<future>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|orc
block|{
name|namespace
name|rpc
block|{
comment|/// Base class of all fatal RPC errors (those that necessarily result in the
comment|/// termination of the RPC session).
name|class
name|RPCFatalError
range|:
name|public
name|ErrorInfo
operator|<
name|RPCFatalError
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|; }
decl_stmt|;
comment|/// RPCConnectionClosed is returned from RPC operations if the RPC connection
comment|/// has already been closed due to either an error or graceful disconnection.
name|class
name|ConnectionClosed
range|:
name|public
name|ErrorInfo
operator|<
name|ConnectionClosed
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|;
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// BadFunctionCall is returned from handleOne when the remote makes a call with
comment|/// an unrecognized function id.
comment|///
comment|/// This error is fatal because Orc RPC needs to know how to parse a function
comment|/// call to know where the next call starts, and if it doesn't recognize the
comment|/// function id it cannot parse the call.
name|template
operator|<
name|typename
name|FnIdT
operator|,
name|typename
name|SeqNoT
operator|>
name|class
name|BadFunctionCall
operator|:
name|public
name|ErrorInfo
operator|<
name|BadFunctionCall
operator|<
name|FnIdT
operator|,
name|SeqNoT
operator|>
operator|,
name|RPCFatalError
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|BadFunctionCall
argument_list|(
argument|FnIdT FnId
argument_list|,
argument|SeqNoT SeqNo
argument_list|)
operator|:
name|FnId
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|FnId
argument_list|)
argument_list|)
block|,
name|SeqNo
argument_list|(
argument|std::move(SeqNo)
argument_list|)
block|{}
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|{
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnexpectedRPCCall
argument_list|)
return|;
block|}
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|{
name|OS
operator|<<
literal|"Call to invalid RPC function id '"
operator|<<
name|FnId
operator|<<
literal|"' with "
literal|"sequence number "
operator|<<
name|SeqNo
block|;   }
name|private
operator|:
name|FnIdT
name|FnId
block|;
name|SeqNoT
name|SeqNo
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|FnIdT
operator|,
name|typename
name|SeqNoT
operator|>
name|char
name|BadFunctionCall
operator|<
name|FnIdT
operator|,
name|SeqNoT
operator|>
operator|::
name|ID
operator|=
literal|0
expr_stmt|;
comment|/// InvalidSequenceNumberForResponse is returned from handleOne when a response
comment|/// call arrives with a sequence number that doesn't correspond to any in-flight
comment|/// function call.
comment|///
comment|/// This error is fatal because Orc RPC needs to know how to parse the rest of
comment|/// the response call to know where the next call starts, and if it doesn't have
comment|/// a result parser for this sequence number it can't do that.
name|template
operator|<
name|typename
name|SeqNoT
operator|>
name|class
name|InvalidSequenceNumberForResponse
operator|:
name|public
name|ErrorInfo
operator|<
name|InvalidSequenceNumberForResponse
operator|<
name|SeqNoT
operator|>
operator|,
name|RPCFatalError
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|InvalidSequenceNumberForResponse
argument_list|(
argument|SeqNoT SeqNo
argument_list|)
operator|:
name|SeqNo
argument_list|(
argument|std::move(SeqNo)
argument_list|)
block|{}
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|{
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnexpectedRPCCall
argument_list|)
return|;
block|}
block|;
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|{
name|OS
operator|<<
literal|"Response has unknown sequence number "
operator|<<
name|SeqNo
block|;   }
name|private
operator|:
name|SeqNoT
name|SeqNo
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|SeqNoT
operator|>
name|char
name|InvalidSequenceNumberForResponse
operator|<
name|SeqNoT
operator|>
operator|::
name|ID
operator|=
literal|0
expr_stmt|;
comment|/// This non-fatal error will be passed to asynchronous result handlers in place
comment|/// of a result if the connection goes down before a result returns, or if the
comment|/// function to be called cannot be negotiated with the remote.
name|class
name|ResponseAbandoned
range|:
name|public
name|ErrorInfo
operator|<
name|ResponseAbandoned
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|;
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// This error is returned if the remote does not have a handler installed for
comment|/// the given RPC function.
name|class
name|CouldNotNegotiate
range|:
name|public
name|ErrorInfo
operator|<
name|CouldNotNegotiate
operator|>
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|CouldNotNegotiate
argument_list|(
argument|std::string Signature
argument_list|)
block|;
name|std
operator|::
name|error_code
name|convertToErrorCode
argument_list|()
specifier|const
name|override
block|;
name|void
name|log
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getSignature
argument_list|()
specifier|const
block|{
return|return
name|Signature
return|;
block|}
name|private
operator|:
name|std
operator|::
name|string
name|Signature
block|; }
decl_stmt|;
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|FnT
operator|>
name|class
name|Function
expr_stmt|;
comment|// RPC Function class.
comment|// DerivedFunc should be a user defined class with a static 'getName()' method
comment|// returning a const char* representing the function's name.
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
comment|/// User defined function type.
name|using
name|Type
operator|=
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
comment|/// Return type.
name|using
name|ReturnType
operator|=
name|RetT
block|;
comment|/// Returns the full function prototype as a string.
specifier|static
specifier|const
name|char
operator|*
name|getPrototype
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|NameMutex
argument_list|)
block|;
if|if
condition|(
name|Name
operator|.
name|empty
argument_list|()
condition|)
name|raw_string_ostream
argument_list|(
name|Name
argument_list|)
operator|<<
name|RPCTypeName
operator|<
name|RetT
operator|>
operator|::
name|getName
argument_list|()
operator|<<
literal|" "
operator|<<
name|DerivedFunc
operator|::
name|getName
argument_list|()
operator|<<
literal|"("
operator|<<
name|llvm
operator|::
name|orc
operator|::
name|rpc
operator|::
name|RPCTypeNameSequence
operator|<
name|ArgTs
operator|...
operator|>
operator|(
operator|)
operator|<<
literal|")"
expr_stmt|;
return|return
name|Name
operator|.
name|data
argument_list|()
return|;
block|}
name|private
label|:
specifier|static
name|std
operator|::
name|mutex
name|NameMutex
expr_stmt|;
specifier|static
name|std
operator|::
name|string
name|Name
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|std
operator|::
name|mutex
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|::
name|NameMutex
expr_stmt|;
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|std
operator|::
name|string
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|::
name|Name
expr_stmt|;
comment|/// Allocates RPC function ids during autonegotiation.
comment|/// Specializations of this class must provide four members:
comment|///
comment|/// static T getInvalidId():
comment|///   Should return a reserved id that will be used to represent missing
comment|/// functions during autonegotiation.
comment|///
comment|/// static T getResponseId():
comment|///   Should return a reserved id that will be used to send function responses
comment|/// (return values).
comment|///
comment|/// static T getNegotiateId():
comment|///   Should return a reserved id for the negotiate function, which will be used
comment|/// to negotiate ids for user defined functions.
comment|///
comment|/// template<typename Func> T allocate():
comment|///   Allocate a unique id for function Func.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|=
name|void
operator|>
name|class
name|RPCFunctionIdAllocator
expr_stmt|;
comment|/// This specialization of RPCFunctionIdAllocator provides a default
comment|/// implementation for integral types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|RPCFunctionIdAllocator
operator|<
name|T
operator|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_integral
operator|<
name|T
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
block|{
name|public
operator|:
specifier|static
name|T
name|getInvalidId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|static
name|T
name|getResponseId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|T
name|getNegotiateId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|Func
operator|>
name|T
name|allocate
argument_list|()
block|{
return|return
name|NextId
operator|++
return|;
block|}
name|private
operator|:
name|T
name|NextId
operator|=
literal|3
block|; }
expr_stmt|;
name|namespace
name|detail
block|{
comment|// FIXME: Remove MSVCPError/MSVCPExpected once MSVC's future implementation
comment|//        supports classes without default constructors.
ifdef|#
directive|ifdef
name|_MSC_VER
name|namespace
name|msvc_hacks
block|{
comment|// Work around MSVC's future implementation's use of default constructors:
comment|// A default constructed value in the promise will be overwritten when the
comment|// real error is set - so the default constructed Error has to be checked
comment|// already.
name|class
name|MSVCPError
range|:
name|public
name|Error
block|{
name|public
operator|:
name|MSVCPError
argument_list|()
block|{
operator|(
name|void
operator|)
operator|!
operator|!
operator|*
name|this
block|; }
name|MSVCPError
argument_list|(
name|MSVCPError
operator|&&
name|Other
argument_list|)
operator|:
name|Error
argument_list|(
argument|std::move(Other)
argument_list|)
block|{}
name|MSVCPError
operator|&
name|operator
operator|=
operator|(
name|MSVCPError
name|Other
operator|)
block|{
name|Error
operator|::
name|operator
operator|=
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|MSVCPError
argument_list|(
argument|Error Err
argument_list|)
operator|:
name|Error
argument_list|(
argument|std::move(Err)
argument_list|)
block|{}
expr|}
block|;
comment|// Work around MSVC's future implementation, similar to MSVCPError.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|MSVCPExpected
operator|:
name|public
name|Expected
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|MSVCPExpected
argument_list|()
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|make_error
operator|<
name|StringError
operator|>
operator|(
literal|""
expr|,
name|inconvertibleErrorCode
argument_list|()
operator|)
operator|)
block|{
name|consumeError
argument_list|(
name|this
operator|->
name|takeError
argument_list|()
argument_list|)
block|;   }
name|MSVCPExpected
argument_list|(
name|MSVCPExpected
operator|&&
name|Other
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
name|MSVCPExpected
operator|&
name|operator
operator|=
operator|(
name|MSVCPExpected
operator|&&
name|Other
operator|)
block|{
name|Expected
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|MSVCPExpected
argument_list|(
argument|Error Err
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
operator|)
block|{}
name|template
operator|<
name|typename
name|OtherT
operator|>
name|MSVCPExpected
argument_list|(
argument|OtherT&&Val
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
operator|)
block|{}
name|template
operator|<
name|class
name|OtherT
operator|>
name|MSVCPExpected
argument_list|(
argument|Expected<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
name|template
operator|<
name|class
name|OtherT
operator|>
name|explicit
name|MSVCPExpected
argument_list|(
argument|Expected<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<!std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
expr|}
block|;  }
comment|// end namespace msvc_hacks
endif|#
directive|endif
comment|// _MSC_VER
comment|/// Provides a typedef for a tuple containing the decayed argument types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|FunctionArgsTuple
block|;
name|template
operator|<
name|typename
name|RetT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|FunctionArgsTuple
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|std
operator|::
name|tuple
operator|<
name|typename
name|std
operator|::
name|decay
operator|<
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|ArgTs
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|...
operator|>
block|; }
block|;
comment|// ResultTraits provides typedefs and utilities specific to the return type
comment|// of functions.
name|template
operator|<
name|typename
name|RetT
operator|>
name|class
name|ResultTraits
block|{
name|public
operator|:
comment|// The return type wrapped in llvm::Expected.
name|using
name|ErrorReturnType
operator|=
name|Expected
operator|<
name|RetT
operator|>
block|;
ifdef|#
directive|ifdef
name|_MSC_VER
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|msvc_hacks
operator|::
name|MSVCPExpected
operator|<
name|RetT
operator|>>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|msvc_hacks
operator|::
name|MSVCPExpected
operator|<
name|RetT
operator|>>
block|;
else|#
directive|else
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|ErrorReturnType
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|ErrorReturnType
operator|>
block|;
endif|#
directive|endif
comment|// Create a 'blank' value of the ErrorReturnType, ready and safe to
comment|// overwrite.
specifier|static
name|ErrorReturnType
name|createBlankErrorReturnValue
argument_list|()
block|{
return|return
name|ErrorReturnType
argument_list|(
name|RetT
argument_list|()
argument_list|)
return|;
block|}
comment|// Consume an abandoned ErrorReturnType.
specifier|static
name|void
name|consumeAbandoned
argument_list|(
argument|ErrorReturnType RetOrErr
argument_list|)
block|{
name|consumeError
argument_list|(
name|RetOrErr
operator|.
name|takeError
argument_list|()
argument_list|)
block|;   }
expr|}
block|;
comment|// ResultTraits specialization for void functions.
name|template
operator|<
operator|>
name|class
name|ResultTraits
operator|<
name|void
operator|>
block|{
name|public
operator|:
comment|// For void functions, ErrorReturnType is llvm::Error.
name|using
name|ErrorReturnType
operator|=
name|Error
block|;
ifdef|#
directive|ifdef
name|_MSC_VER
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|msvc_hacks
operator|::
name|MSVCPError
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|msvc_hacks
operator|::
name|MSVCPError
operator|>
block|;
else|#
directive|else
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|ErrorReturnType
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|ErrorReturnType
operator|>
block|;
endif|#
directive|endif
comment|// Create a 'blank' value of the ErrorReturnType, ready and safe to
comment|// overwrite.
specifier|static
name|ErrorReturnType
name|createBlankErrorReturnValue
argument_list|()
block|{
return|return
name|ErrorReturnType
operator|::
name|success
argument_list|()
return|;
block|}
comment|// Consume an abandoned ErrorReturnType.
specifier|static
name|void
name|consumeAbandoned
argument_list|(
argument|ErrorReturnType Err
argument_list|)
block|{
name|consumeError
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
block|;   }
expr|}
block|;
comment|// ResultTraits<Error> is equivalent to ResultTraits<void>. This allows
comment|// handlers for void RPC functions to return either void (in which case they
comment|// implicitly succeed) or Error (in which case their error return is
comment|// propagated). See usage in HandlerTraits::runHandlerHelper.
name|template
operator|<
operator|>
name|class
name|ResultTraits
operator|<
name|Error
operator|>
operator|:
name|public
name|ResultTraits
operator|<
name|void
operator|>
block|{}
block|;
comment|// ResultTraits<Expected<T>> is equivalent to ResultTraits<T>. This allows
comment|// handlers for RPC functions returning a T to return either a T (in which
comment|// case they implicitly succeed) or Expected<T> (in which case their error
comment|// return is propagated). See usage in HandlerTraits::runHandlerHelper.
name|template
operator|<
name|typename
name|RetT
operator|>
name|class
name|ResultTraits
operator|<
name|Expected
operator|<
name|RetT
operator|>>
operator|:
name|public
name|ResultTraits
operator|<
name|RetT
operator|>
block|{}
block|;
comment|// Determines whether an RPC function's defined error return type supports
comment|// error return value.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SupportsErrorReturn
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|; }
block|;
name|template
operator|<
operator|>
name|class
name|SupportsErrorReturn
operator|<
name|Error
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
block|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SupportsErrorReturn
operator|<
name|Expected
operator|<
name|T
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
block|;
comment|// RespondHelper packages return values based on whether or not the declared
comment|// RPC function return type supports error returns.
name|template
operator|<
name|bool
name|FuncSupportsErrorReturn
operator|>
name|class
name|RespondHelper
block|;
comment|// RespondHelper specialization for functions that support error returns.
name|template
operator|<
operator|>
name|class
name|RespondHelper
operator|<
name|true
operator|>
block|{
name|public
operator|:
comment|// Send Expected<T>.
name|template
operator|<
name|typename
name|WireRetT
block|,
name|typename
name|HandlerRetT
block|,
name|typename
name|ChannelT
block|,
name|typename
name|FunctionIdT
block|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|sendResult
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Expected<HandlerRetT> ResultOrErr
argument_list|)
block|{
if|if
condition|(
operator|!
name|ResultOrErr
operator|&&
name|ResultOrErr
operator|.
name|template
name|errorIsA
operator|<
name|RPCFatalError
operator|>
operator|(
operator|)
condition|)
return|return
name|ResultOrErr
operator|.
name|takeError
argument_list|()
return|;
comment|// Open the response message.
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// Serialize the result.
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|WireRetT
condition|,
name|Expected
decl|<
name|HandlerRetT
decl|>>::
name|serialize
argument_list|(
name|C
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|ResultOrErr
argument_list|)
argument_list|)
condition|)       return Err;
comment|// Close the response message.
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|ChannelT
block|,
name|typename
name|FunctionIdT
block|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|sendResult
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Error Err
argument_list|)
block|{
if|if
condition|(
name|Err
operator|&&
name|Err
operator|.
name|isA
operator|<
name|RPCFatalError
operator|>
operator|(
operator|)
condition|)
return|return
name|Err
return|;
if|if
condition|(
name|auto
name|Err2
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err2
return|;
if|if
condition|(
name|auto
name|Err2
init|=
name|serializeSeq
argument_list|(
name|C
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
condition|)
return|return
name|Err2
return|;
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|// RespondHelper specialization for functions that do not support error returns.
name|template
operator|<
operator|>
name|class
name|RespondHelper
operator|<
name|false
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|WireRetT
block|,
name|typename
name|HandlerRetT
block|,
name|typename
name|ChannelT
block|,
name|typename
name|FunctionIdT
block|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|sendResult
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Expected<HandlerRetT> ResultOrErr
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|ResultOrErr
operator|.
name|takeError
argument_list|()
condition|)
return|return
name|Err
return|;
comment|// Open the response message.
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// Serialize the result.
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|WireRetT
condition|,
name|HandlerRetT
decl|>::
name|serialize
argument_list|(
name|C
argument_list|,
operator|*
name|ResultOrErr
argument_list|)
condition|)       return Err;
comment|// Close the response message.
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|sendResult
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Error Err
argument_list|)
block|{
if|if
condition|(
name|Err
condition|)
return|return
name|Err
return|;
if|if
condition|(
name|auto
name|Err2
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err2
return|;
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|// Send a response of the given wire return type (WireRetT) over the
end_comment

begin_comment
comment|// channel, with the given sequence number.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|WireRetT
operator|,
name|typename
name|HandlerRetT
operator|,
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
name|Error
name|respond
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Expected<HandlerRetT> ResultOrErr
argument_list|)
block|{
return|return
name|RespondHelper
operator|<
name|SupportsErrorReturn
operator|<
name|WireRetT
operator|>
operator|::
name|value
operator|>
operator|::
name|template
name|sendResult
operator|<
name|WireRetT
operator|>
operator|(
name|C
operator|,
name|ResponseId
operator|,
name|SeqNo
operator|,
name|std
operator|::
name|move
argument_list|(
name|ResultOrErr
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Send an empty response message on the given channel to indicate that
end_comment

begin_comment
comment|// the handler ran.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|WireRetT
operator|,
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
name|Error
name|respond
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Error Err
argument_list|)
block|{
return|return
name|RespondHelper
operator|<
name|SupportsErrorReturn
operator|<
name|WireRetT
operator|>
operator|::
name|value
operator|>
operator|::
name|sendResult
argument_list|(
name|C
argument_list|,
name|ResponseId
argument_list|,
name|SeqNo
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Converts a given type to the equivalent error return type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|WrappedHandlerReturn
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Expected
operator|<
name|T
operator|>
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|Expected
operator|<
name|T
operator|>>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Expected
operator|<
name|T
operator|>
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|void
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|Error
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|ErrorSuccess
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Traits class that strips the response function from the list of handler
end_comment

begin_comment
comment|// arguments.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|FnT
operator|>
name|class
name|AsyncHandlerTraits
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ResultT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|AsyncHandlerTraits
operator|<
name|Error
argument_list|(
name|std
operator|::
name|function
operator|<
name|Error
argument_list|(
name|Expected
operator|<
name|ResultT
operator|>
argument_list|)
operator|>
argument_list|,
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
name|using
name|ResultType
operator|=
name|Expected
operator|<
name|ResultT
operator|>
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|AsyncHandlerTraits
operator|<
name|Error
argument_list|(
name|std
operator|::
name|function
operator|<
name|Error
argument_list|(
name|Error
argument_list|)
operator|>
argument_list|,
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
name|using
name|ResultType
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ResponseHandlerT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|AsyncHandlerTraits
operator|<
name|Error
argument_list|(
name|ResponseHandlerT
argument_list|,
name|ArgTs
operator|...
argument_list|)
operator|>
operator|:
name|public
name|AsyncHandlerTraits
operator|<
name|Error
argument_list|(
argument|typename std::decay<ResponseHandlerT>::type
argument_list|,
argument|ArgTs...
argument_list|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// This template class provides utilities related to RPC function handlers.
end_comment

begin_comment
comment|// The base case applies to non-function types (the template class is
end_comment

begin_comment
comment|// specialized for function types) and inherits from the appropriate
end_comment

begin_comment
comment|// speciilization for the given non-function type's call operator.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|>
name|class
name|HandlerTraits
operator|:
name|public
name|HandlerTraits
operator|<
name|decltype
argument_list|(
operator|&
name|std
operator|::
name|remove_reference
operator|<
name|HandlerT
operator|>
operator|::
name|type
operator|::
name|operator
argument_list|()
argument_list|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Traits for handlers with a given function type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
comment|// Function type of the handler.
name|using
name|Type
operator|=
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
comment|// Return type of the handler.
name|using
name|ReturnType
operator|=
name|RetT
block|;
comment|// Call the given handler with the given arguments.
name|template
operator|<
name|typename
name|HandlerT
block|,
name|typename
operator|...
name|TArgTs
operator|>
specifier|static
name|typename
name|WrappedHandlerReturn
operator|<
name|RetT
operator|>
operator|::
name|Type
name|unpackAndRun
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|std::tuple<TArgTs...>&Args
argument_list|)
block|{
return|return
name|unpackAndRunHelper
argument_list|(
name|Handler
argument_list|,
name|Args
argument_list|,
name|llvm
operator|::
name|index_sequence_for
operator|<
name|TArgTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
comment|// Call the given handler with the given arguments.
name|template
operator|<
name|typename
name|HandlerT
operator|,
name|typename
name|ResponderT
operator|,
name|typename
operator|...
name|TArgTs
operator|>
specifier|static
name|Error
name|unpackAndRunAsync
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ResponderT&Responder
argument_list|,
argument|std::tuple<TArgTs...>&Args
argument_list|)
block|{
return|return
name|unpackAndRunAsyncHelper
argument_list|(
name|Handler
argument_list|,
name|Responder
argument_list|,
name|Args
argument_list|,
name|llvm
operator|::
name|index_sequence_for
operator|<
name|TArgTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Call the given handler with the given arguments.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_void
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|value
operator|,
name|Error
operator|>
operator|::
name|type
name|run
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgTs&&... Args
argument_list|)
block|{
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
argument_list|)
block|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|,
name|typename
operator|...
name|TArgTs
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_void
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|value
operator|,
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|type
name|run
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|TArgTs... Args
argument_list|)
block|{
return|return
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Serialize arguments to the channel.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
operator|...
name|CArgTs
operator|>
specifier|static
name|Error
name|serializeArgs
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const CArgTs... CArgs
argument_list|)
block|{
return|return
name|SequenceSerialization
operator|<
name|ChannelT
operator|,
name|ArgTs
operator|...
operator|>
operator|::
name|serialize
argument_list|(
name|C
argument_list|,
name|CArgs
operator|...
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Deserialize arguments from the channel.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
operator|...
name|CArgTs
operator|>
specifier|static
name|Error
name|deserializeArgs
argument_list|(
argument|ChannelT&C
argument_list|,
argument|std::tuple<CArgTs...>&Args
argument_list|)
block|{
return|return
name|deserializeArgsHelper
argument_list|(
name|C
argument_list|,
name|Args
argument_list|,
name|llvm
operator|::
name|index_sequence_for
operator|<
name|CArgTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
operator|...
name|CArgTs
operator|,
name|size_t
operator|...
name|Indexes
operator|>
specifier|static
name|Error
name|deserializeArgsHelper
argument_list|(
argument|ChannelT&C
argument_list|,
argument|std::tuple<CArgTs...>&Args
argument_list|,
argument|llvm::index_sequence<Indexes...> _
argument_list|)
block|{
return|return
name|SequenceSerialization
operator|<
name|ChannelT
operator|,
name|ArgTs
operator|...
operator|>
operator|::
name|deserialize
argument_list|(
name|C
argument_list|,
name|std
operator|::
name|get
operator|<
name|Indexes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|,
name|typename
name|ArgTuple
operator|,
name|size_t
operator|...
name|Indexes
operator|>
specifier|static
name|typename
name|WrappedHandlerReturn
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|Type
name|unpackAndRunHelper
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgTuple&Args
argument_list|,
argument|llvm::index_sequence<Indexes...>
argument_list|)
block|{
return|return
name|run
argument_list|(
name|Handler
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|std
operator|::
name|get
operator|<
name|Indexes
operator|>
operator|(
name|Args
operator|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|,
name|typename
name|ResponderT
operator|,
name|typename
name|ArgTuple
operator|,
name|size_t
operator|...
name|Indexes
operator|>
specifier|static
name|typename
name|WrappedHandlerReturn
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|Type
name|unpackAndRunAsyncHelper
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ResponderT&Responder
argument_list|,
argument|ArgTuple&Args
argument_list|,
argument|llvm::index_sequence<Indexes...>
argument_list|)
block|{
return|return
name|run
argument_list|(
name|Handler
argument_list|,
name|Responder
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|std
operator|::
name|get
operator|<
name|Indexes
operator|>
operator|(
name|Args
operator|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Handler traits for free functions.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|:
name|public
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Handler traits for class methods (especially call operators for lambdas).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Class
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|Class
operator|::
operator|*
argument_list|)
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|:
name|public
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Handler traits for const class methods (especially call operators for
end_comment

begin_comment
comment|// lambdas).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Class
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
argument|Class::*
argument_list|)
operator|(
name|ArgTs
operator|...
operator|)
specifier|const
operator|>
operator|:
name|public
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Utility to peel the Expected wrapper off a response handler error type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerArg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ArgT
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|Error
argument_list|(
name|Expected
operator|<
name|ArgT
operator|>
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Expected
operator|<
name|ArgT
operator|>
block|;
name|using
name|UnwrappedArgType
operator|=
name|ArgT
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ArgT
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|ErrorSuccess
argument_list|(
name|Expected
operator|<
name|ArgT
operator|>
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Expected
operator|<
name|ArgT
operator|>
block|;
name|using
name|UnwrappedArgType
operator|=
name|ArgT
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|Error
argument_list|(
name|Error
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|ErrorSuccess
argument_list|(
name|Error
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Error
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ResponseHandler represents a handler for a not-yet-received function call
end_comment

begin_comment
comment|// result.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|>
name|class
name|ResponseHandler
block|{
name|public
operator|:
name|virtual
operator|~
name|ResponseHandler
argument_list|()
block|{}
comment|// Reads the function result off the wire and acts on it. The meaning of
comment|// "act" will depend on how this method is implemented in any given
comment|// ResponseHandler subclass but could, for example, mean running a
comment|// user-specified handler or setting a promise value.
name|virtual
name|Error
name|handleResponse
argument_list|(
name|ChannelT
operator|&
name|C
argument_list|)
operator|=
literal|0
block|;
comment|// Abandons this outstanding result.
name|virtual
name|void
name|abandon
argument_list|()
operator|=
literal|0
block|;
comment|// Create an error instance representing an abandoned response.
specifier|static
name|Error
name|createAbandonedResponseError
argument_list|()
block|{
return|return
name|make_error
operator|<
name|ResponseAbandoned
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// ResponseHandler subclass for RPC functions with non-void returns.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FuncRetT
operator|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result by deserializing it from the channel then passing it
comment|// to the user defined handler.
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
name|using
name|UnwrappedArgType
operator|=
name|typename
name|ResponseHandlerArg
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|UnwrappedArgType
block|;
name|UnwrappedArgType
name|Result
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|FuncRetT
condition|,
name|UnwrappedArgType
decl|>::
name|deserialize
argument_list|(
name|C
argument_list|,
name|Result
argument_list|)
condition|)       return Err;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_expr_stmt

begin_return
return|return
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Abandon this response by calling the handler with an 'abandoned response'
end_comment

begin_comment
comment|// error.
end_comment

begin_macro
unit|void
name|abandon
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|HandlerT
name|Handler
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// ResponseHandler subclass for RPC functions with void returns.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|void
operator|,
name|HandlerT
operator|>
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result (no actual value, just a notification that the function
comment|// has completed on the remote end) by calling the user-defined handler with
comment|// Error::success().
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
return|return
name|Handler
argument_list|(
name|Error
operator|::
name|success
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Abandon this response by calling the handler with an 'abandoned response'
end_comment

begin_comment
comment|// error.
end_comment

begin_function
name|void
name|abandon
parameter_list|()
function|override
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|HandlerT
name|Handler
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FuncRetT
operator|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|Expected
operator|<
name|FuncRetT
operator|>
operator|,
name|HandlerT
operator|>
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result by deserializing it from the channel then passing it
comment|// to the user defined handler.
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
name|using
name|HandlerArgType
operator|=
name|typename
name|ResponseHandlerArg
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|ArgType
block|;
name|HandlerArgType
name|Result
argument_list|(
operator|(
name|typename
name|HandlerArgType
operator|::
name|value_type
argument_list|()
operator|)
argument_list|)
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|Expected
decl|<
name|FuncRetT
decl|>
condition|,
name|HandlerArgType
decl|>::
name|deserialize
argument_list|(
name|C
argument_list|,
name|Result
argument_list|)
condition|)       return Err;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_expr_stmt

begin_return
return|return
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Abandon this response by calling the handler with an 'abandoned response'
end_comment

begin_comment
comment|// error.
end_comment

begin_macro
unit|void
name|abandon
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|HandlerT
name|Handler
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|Error
operator|,
name|HandlerT
operator|>
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result by deserializing it from the channel then passing it
comment|// to the user defined handler.
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
name|Error
name|Result
operator|=
name|Error
operator|::
name|success
argument_list|()
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|Error
condition|,
name|Error
decl|>::
name|deserialize
argument_list|(
name|C
argument_list|,
name|Result
argument_list|)
condition|)       return Err;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_expr_stmt

begin_return
return|return
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Abandon this response by calling the handler with an 'abandoned response'
end_comment

begin_comment
comment|// error.
end_comment

begin_macro
unit|void
name|abandon
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|HandlerT
name|Handler
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Create a ResponseHandler from a given user handler.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FuncRetT
operator|,
name|typename
name|HandlerT
operator|>
name|std
operator|::
name|unique_ptr
operator|<
name|ResponseHandler
operator|<
name|ChannelT
operator|>>
name|createResponseHandler
argument_list|(
argument|HandlerT H
argument_list|)
block|{
return|return
name|llvm
operator|::
name|make_unique
operator|<
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|FuncRetT
operator|,
name|HandlerT
operator|>>
operator|(
name|std
operator|::
name|move
argument_list|(
name|H
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Helper for wrapping member functions up as functors. This is useful for
end_comment

begin_comment
comment|// installing methods as result handlers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|MemberFnWrapper
block|{
name|public
operator|:
name|using
name|MethodT
operator|=
name|RetT
argument_list|(
name|ClassT
operator|::
operator|*
argument_list|)
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
name|MemberFnWrapper
argument_list|(
argument|ClassT&Instance
argument_list|,
argument|MethodT Method
argument_list|)
operator|:
name|Instance
argument_list|(
name|Instance
argument_list|)
block|,
name|Method
argument_list|(
argument|Method
argument_list|)
block|{}
name|RetT
name|operator
argument_list|()
operator|(
name|ArgTs
operator|&&
operator|...
name|Args
operator|)
block|{
return|return
operator|(
name|Instance
operator|.*
name|Method
operator|)
operator|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
operator|)
return|;
block|}
name|private
operator|:
name|ClassT
operator|&
name|Instance
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MethodT
name|Method
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Helper that provides a Functor for deserializing arguments.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|ReadArgs
block|{
name|public
operator|:
name|Error
name|operator
argument_list|()
operator|(
operator|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|ArgT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|ReadArgs
operator|<
name|ArgT
operator|,
name|ArgTs
operator|...
operator|>
operator|:
name|public
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
block|{
name|public
operator|:
name|ReadArgs
argument_list|(
name|ArgT
operator|&
name|Arg
argument_list|,
name|ArgTs
operator|&
operator|...
name|Args
argument_list|)
operator|:
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|(
name|Args
operator|...
operator|)
block|,
name|Arg
argument_list|(
argument|Arg
argument_list|)
block|{}
name|Error
name|operator
argument_list|()
operator|(
name|ArgT
operator|&
name|ArgVal
operator|,
name|ArgTs
operator|&
operator|...
name|ArgVals
operator|)
block|{
name|this
operator|->
name|Arg
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgVal
argument_list|)
block|;
return|return
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|::
name|operator
argument_list|()
argument_list|(
name|ArgVals
operator|...
argument_list|)
return|;
block|}
name|private
operator|:
name|ArgT
operator|&
name|Arg
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Manage sequence numbers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|SequenceNumberT
operator|>
name|class
name|SequenceNumberManager
block|{
name|public
operator|:
comment|// Reset, making all sequence numbers available.
name|void
name|reset
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
block|;
name|NextSequenceNumber
operator|=
literal|0
block|;
name|FreeSequenceNumbers
operator|.
name|clear
argument_list|()
block|;   }
comment|// Get the next available sequence number. Will re-use numbers that have
comment|// been released.
name|SequenceNumberT
name|getSequenceNumber
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
block|;
if|if
condition|(
name|FreeSequenceNumbers
operator|.
name|empty
argument_list|()
condition|)
return|return
name|NextSequenceNumber
operator|++
return|;
name|auto
name|SequenceNumber
operator|=
name|FreeSequenceNumbers
operator|.
name|back
argument_list|()
block|;
name|FreeSequenceNumbers
operator|.
name|pop_back
argument_list|()
block|;
return|return
name|SequenceNumber
return|;
block|}
end_expr_stmt

begin_comment
comment|// Release a sequence number, making it available for re-use.
end_comment

begin_function
name|void
name|releaseSequenceNumber
parameter_list|(
name|SequenceNumberT
name|SequenceNumber
parameter_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
expr_stmt|;
name|FreeSequenceNumbers
operator|.
name|push_back
argument_list|(
name|SequenceNumber
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|mutex
name|SeqNoLock
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SequenceNumberT
name|NextSequenceNumber
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|SequenceNumberT
operator|>
name|FreeSequenceNumbers
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Checks that predicate P holds for each corresponding pair of type arguments
end_comment

begin_comment
comment|// from T1 and T2 tuple.
end_comment

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T1Tuple
operator|,
name|typename
name|T2Tuple
operator|>
name|class
name|RPCArgTypeCheckHelper
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|>
name|class
name|RPCArgTypeCheckHelper
operator|<
name|P
operator|,
name|std
operator|::
name|tuple
operator|<
operator|>
operator|,
name|std
operator|::
name|tuple
operator|<
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T
operator|,
name|typename
operator|...
name|Ts
operator|,
name|typename
name|U
operator|,
name|typename
operator|...
name|Us
operator|>
name|class
name|RPCArgTypeCheckHelper
operator|<
name|P
operator|,
name|std
operator|::
name|tuple
operator|<
name|T
operator|,
name|Ts
operator|...
operator|>
operator|,
name|std
operator|::
name|tuple
operator|<
name|U
operator|,
name|Us
operator|...
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|P
operator|<
name|T
block|,
name|U
operator|>
operator|::
name|value
operator|&&
name|RPCArgTypeCheckHelper
operator|<
name|P
block|,
name|std
operator|::
name|tuple
operator|<
name|Ts
operator|...
operator|>
block|,
name|std
operator|::
name|tuple
operator|<
name|Us
operator|...
operator|>>
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T1Sig
operator|,
name|typename
name|T2Sig
operator|>
name|class
name|RPCArgTypeCheck
block|{
name|public
operator|:
name|using
name|T1Tuple
operator|=
name|typename
name|FunctionArgsTuple
operator|<
name|T1Sig
operator|>
operator|::
name|Type
block|;
name|using
name|T2Tuple
operator|=
name|typename
name|FunctionArgsTuple
operator|<
name|T2Sig
operator|>
operator|::
name|Type
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|tuple_size
operator|<
name|T1Tuple
operator|>
operator|::
name|value
operator|>=
name|std
operator|::
name|tuple_size
operator|<
name|T2Tuple
operator|>
operator|::
name|value
argument_list|,
literal|"Too many arguments to RPC call"
argument_list|)
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|tuple_size
operator|<
name|T1Tuple
operator|>
operator|::
name|value
operator|<=
name|std
operator|::
name|tuple_size
operator|<
name|T2Tuple
operator|>
operator|::
name|value
argument_list|,
literal|"Too few arguments to RPC call"
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|value
operator|=
name|RPCArgTypeCheckHelper
operator|<
name|P
block|,
name|T1Tuple
block|,
name|T2Tuple
operator|>
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanSerialize
block|{
name|private
operator|:
name|using
name|S
operator|=
name|SerializationTraits
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|std
operator|::
name|true_type
name|check
argument_list|(
argument|typename std::enable_if<         std::is_same<decltype(T::serialize(std::declval<ChannelT&>(),                                            std::declval<const ConcreteT&>()))
argument_list|,
argument|Error>::value
argument_list|,
argument|void *>::type
argument_list|)
block|;
name|template
operator|<
name|typename
operator|>
specifier|static
name|std
operator|::
name|false_type
name|check
argument_list|(
operator|...
argument_list|)
block|;
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|decltype
argument_list|(
name|check
operator|<
name|S
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanDeserialize
block|{
name|private
operator|:
name|using
name|S
operator|=
name|SerializationTraits
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|std
operator|::
name|true_type
name|check
argument_list|(
argument|typename std::enable_if<         std::is_same<decltype(T::deserialize(std::declval<ChannelT&>(),                                              std::declval<ConcreteT&>()))
argument_list|,
argument|Error>::value
argument_list|,
argument|void *>::type
argument_list|)
block|;
name|template
operator|<
name|typename
operator|>
specifier|static
name|std
operator|::
name|false_type
name|check
argument_list|(
operator|...
argument_list|)
block|;
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|decltype
argument_list|(
name|check
operator|<
name|S
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|::
name|value
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Contains primitive utilities for defining, calling and handling calls to
end_comment

begin_comment
comment|/// remote procedures. ChannelT is a bidirectional stream conforming to the
end_comment

begin_comment
comment|/// RPCChannel interface (see RPCChannel.h), FunctionIdT is a procedure
end_comment

begin_comment
comment|/// identifier type that must be serializable on ChannelT, and SequenceNumberT
end_comment

begin_comment
comment|/// is an integral type that will be used to number in-flight function calls.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// These utilities support the construction of very primitive RPC utilities.
end_comment

begin_comment
comment|/// Their intent is to ensure correct serialization and deserialization of
end_comment

begin_comment
comment|/// procedure arguments, and to keep the client and server's view of the API in
end_comment

begin_comment
comment|/// sync.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ImplT
operator|,
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
name|class
name|RPCEndpointBase
block|{
name|protected
operator|:
name|class
name|OrcRPCInvalid
operator|:
name|public
name|Function
operator|<
name|OrcRPCInvalid
block|,
name|void
argument_list|()
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|char
operator|*
name|getName
argument_list|()
block|{
return|return
literal|"__orc_rpc$invalid"
return|;
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|class
name|OrcRPCResponse
range|:
name|public
name|Function
operator|<
name|OrcRPCResponse
decl_stmt|,
name|void
argument_list|()
decl|>
block|{
name|public
label|:
specifier|static
specifier|const
name|char
modifier|*
name|getName
parameter_list|()
block|{
return|return
literal|"__orc_rpc$response"
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|OrcRPCNegotiate
range|:
name|public
name|Function
operator|<
name|OrcRPCNegotiate
decl_stmt|,
name|FunctionIdT
argument_list|(
name|std
operator|::
name|string
argument_list|)
decl|>
block|{
name|public
label|:
specifier|static
specifier|const
name|char
modifier|*
name|getName
parameter_list|()
block|{
return|return
literal|"__orc_rpc$negotiate"
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Helper predicate for testing for the presence of SerializeTraits
end_comment

begin_comment
comment|// serializers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanSerializeCheck
operator|:
name|detail
operator|::
name|CanSerialize
operator|<
name|ChannelT
operator|,
name|WireT
operator|,
name|ConcreteT
operator|>
block|{
name|public
operator|:
name|using
name|detail
operator|::
name|CanSerialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
operator|::
name|value
block|;
name|static_assert
argument_list|(
name|value
argument_list|,
literal|"Missing serializer for argument (Can't serialize the "
literal|"first template type argument of CanSerializeCheck "
literal|"from the second)"
argument_list|)
block|;   }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Helper predicate for testing for the presence of SerializeTraits
end_comment

begin_comment
comment|// deserializers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanDeserializeCheck
operator|:
name|detail
operator|::
name|CanDeserialize
operator|<
name|ChannelT
operator|,
name|WireT
operator|,
name|ConcreteT
operator|>
block|{
name|public
operator|:
name|using
name|detail
operator|::
name|CanDeserialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
operator|::
name|value
block|;
name|static_assert
argument_list|(
name|value
argument_list|,
literal|"Missing deserializer for argument (Can't deserialize "
literal|"the second template type argument of "
literal|"CanDeserializeCheck from the first)"
argument_list|)
block|;   }
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|/// Construct an RPC instance on a channel.
end_comment

begin_macro
name|RPCEndpointBase
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|C
argument_list|(
name|C
argument_list|)
operator|,
name|LazyAutoNegotiation
argument_list|(
argument|LazyAutoNegotiation
argument_list|)
block|{
comment|// Hold ResponseId in a special variable, since we expect Response to be
comment|// called relatively frequently, and want to avoid the map lookup.
name|ResponseId
operator|=
name|FnIdAllocator
operator|.
name|getResponseId
argument_list|()
block|;
name|RemoteFunctionIds
index|[
name|OrcRPCResponse
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|ResponseId
block|;
comment|// Register the negotiate function id and handler.
name|auto
name|NegotiateId
operator|=
name|FnIdAllocator
operator|.
name|getNegotiateId
argument_list|()
block|;
name|RemoteFunctionIds
index|[
name|OrcRPCNegotiate
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|NegotiateId
block|;
name|Handlers
index|[
name|NegotiateId
index|]
operator|=
name|wrapHandler
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
index|[
name|this
index|]
operator|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
operator|)
block|{
return|return
name|handleNegotiate
argument_list|(
name|Name
argument_list|)
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/// Negotiate a function id for Func with the other end of the channel.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|>
name|Error
name|negotiateFunction
argument_list|(
argument|bool Retry = false
argument_list|)
block|{
return|return
name|getRemoteFunctionId
operator|<
name|Func
operator|>
operator|(
name|true
operator|,
name|Retry
operator|)
operator|.
name|takeError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Append a call Func, does not call send on the channel.
end_comment

begin_comment
comment|/// The first argument specifies a user-defined handler to be run when the
end_comment

begin_comment
comment|/// function returns. The handler should take an Expected<Func::ReturnType>,
end_comment

begin_comment
comment|/// or an Error (if Func::ReturnType is void). The handler will be called
end_comment

begin_comment
comment|/// with an error if the return value is abandoned due to a channel error.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|appendCallAsync
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
name|static_assert
argument_list|(
argument|detail::RPCArgTypeCheck<CanSerializeCheck
argument_list|,
argument|typename Func::Type
argument_list|,
argument|void(ArgTs...)>::value
argument_list|,
literal|""
argument_list|)
block|;
comment|// Look up the function ID.
name|FunctionIdT
name|FnId
block|;
if|if
condition|(
name|auto
name|FnIdOrErr
init|=
name|getRemoteFunctionId
operator|<
name|Func
operator|>
operator|(
name|LazyAutoNegotiation
expr|,
name|false
operator|)
condition|)
name|FnId
operator|=
operator|*
name|FnIdOrErr
expr_stmt|;
else|else
block|{
comment|// Negotiation failed. Notify the handler then return the negotiate-failed
comment|// error.
name|cantFail
argument_list|(
name|Handler
argument_list|(
name|make_error
operator|<
name|ResponseAbandoned
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FnIdOrErr
operator|.
name|takeError
argument_list|()
return|;
block|}
name|SequenceNumberT
name|SeqNo
expr_stmt|;
end_expr_stmt

begin_comment
comment|// initialized in locked scope below.
end_comment

begin_block
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
expr_stmt|;
comment|// Allocate a sequence number.
name|SeqNo
operator|=
name|SequenceNumberMgr
operator|.
name|getSequenceNumber
argument_list|()
expr_stmt|;
name|assert
argument_list|(
operator|!
name|PendingResponses
operator|.
name|count
argument_list|(
name|SeqNo
argument_list|)
operator|&&
literal|"Sequence number already allocated"
argument_list|)
expr_stmt|;
comment|// Install the user handler.
name|PendingResponses
index|[
name|SeqNo
index|]
operator|=
name|detail
operator|::
name|createResponseHandler
operator|<
name|ChannelT
operator|,
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|// Open the function call message.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|FnId
argument_list|,
name|SeqNo
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
end_if

begin_comment
comment|// Serialize the call arguments.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|typename
name|Func
operator|::
name|Type
operator|>
operator|::
name|serializeArgs
argument_list|(
name|C
argument_list|,
name|Args
operator|...
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
end_if

begin_comment
comment|// Close the function call messagee.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endSendMessage
argument_list|()
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
end_if

begin_return
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
end_return

begin_macro
unit|}    Error
name|sendAppendedCalls
argument_list|()
end_macro

begin_block
block|{
return|return
name|C
operator|.
name|send
argument_list|()
return|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|callAsync
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
expr|,
name|Args
operator|...
operator|)
condition|)
return|return
name|Err
return|;
end_expr_stmt

begin_return
return|return
name|C
operator|.
name|send
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// Handle one incoming call.
end_comment

begin_macro
unit|Error
name|handleOne
argument_list|()
end_macro

begin_block
block|{
name|FunctionIdT
name|FnId
decl_stmt|;
name|SequenceNumberT
name|SeqNo
decl_stmt|;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startReceiveMessage
argument_list|(
name|FnId
argument_list|,
name|SeqNo
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
if|if
condition|(
name|FnId
operator|==
name|ResponseId
condition|)
return|return
name|handleResponse
argument_list|(
name|SeqNo
argument_list|)
return|;
name|auto
name|I
init|=
name|Handlers
operator|.
name|find
argument_list|(
name|FnId
argument_list|)
decl_stmt|;
if|if
condition|(
name|I
operator|!=
name|Handlers
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
argument_list|(
name|C
argument_list|,
name|SeqNo
argument_list|)
return|;
comment|// else: No handler found. Report error to client?
return|return
name|make_error
operator|<
name|BadFunctionCall
operator|<
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>>
operator|(
name|FnId
operator|,
name|SeqNo
operator|)
return|;
block|}
end_block

begin_comment
comment|/// Helper for handling setter procedures - this method returns a functor that
end_comment

begin_comment
comment|/// sets the variables referred to by Args... to values deserialized from the
end_comment

begin_comment
comment|/// channel.
end_comment

begin_comment
comment|/// E.g.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   typedef Function<0, bool, int> Func1;
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///   ...
end_comment

begin_comment
comment|///   bool B;
end_comment

begin_comment
comment|///   int I;
end_comment

begin_comment
comment|///   if (auto Err = expect<Func1>(Channel, readArgs(B, I)))
end_comment

begin_comment
comment|///     /* Handle Args */ ;
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|ArgTs
operator|>
specifier|static
name|detail
operator|::
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
name|readArgs
argument_list|(
argument|ArgTs&... Args
argument_list|)
block|{
return|return
name|detail
operator|::
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|(
name|Args
operator|...
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Abandon all outstanding result handlers.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This will call all currently registered result handlers to receive an
end_comment

begin_comment
comment|/// "abandoned" error as their argument. This is used internally by the RPC
end_comment

begin_comment
comment|/// in error situations, but can also be called directly by clients who are
end_comment

begin_comment
comment|/// disconnecting from the remote and don't or can't expect responses to their
end_comment

begin_comment
comment|/// outstanding calls. (Especially for outstanding blocking calls, calling
end_comment

begin_comment
comment|/// this function may be necessary to avoid dead threads).
end_comment

begin_function
name|void
name|abandonPendingResponses
parameter_list|()
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|KV
operator|:
name|PendingResponses
control|)
name|KV
operator|.
name|second
operator|->
name|abandon
argument_list|()
expr_stmt|;
name|PendingResponses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SequenceNumberMgr
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Remove the handler for the given function.
end_comment

begin_comment
comment|/// A handler must currently be registered for this function.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|>
name|void
name|removeHandler
argument_list|()
block|{
name|auto
name|IdItr
operator|=
name|LocalFunctionIds
operator|.
name|find
argument_list|(
name|Func
operator|::
name|getPrototype
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|IdItr
operator|!=
name|LocalFunctionIds
operator|.
name|end
argument_list|()
operator|&&
literal|"Function does not have a registered handler"
argument_list|)
block|;
name|auto
name|HandlerItr
operator|=
name|Handlers
operator|.
name|find
argument_list|(
name|IdItr
operator|->
name|second
argument_list|)
block|;
name|assert
argument_list|(
name|HandlerItr
operator|!=
name|Handlers
operator|.
name|end
argument_list|()
operator|&&
literal|"Function does not have a registered handler"
argument_list|)
block|;
name|Handlers
operator|.
name|erase
argument_list|(
name|HandlerItr
argument_list|)
block|;   }
comment|/// Clear all handlers.
name|void
name|clearHandlers
argument_list|()
block|{
name|Handlers
operator|.
name|clear
argument_list|()
block|;   }
name|protected
operator|:
name|FunctionIdT
name|getInvalidFunctionId
argument_list|()
specifier|const
block|{
return|return
name|FnIdAllocator
operator|.
name|getInvalidId
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Add the given handler to the handler map and make it available for
end_comment

begin_comment
comment|/// autonegotiation and execution.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
name|static_assert
argument_list|(
argument|detail::RPCArgTypeCheck<                       CanDeserializeCheck
argument_list|,
argument|typename Func::Type
argument_list|,
argument|typename detail::HandlerTraits<HandlerT>::Type>::value
argument_list|,
literal|""
argument_list|)
block|;
name|FunctionIdT
name|NewFnId
operator|=
name|FnIdAllocator
operator|.
name|template
name|allocate
operator|<
name|Func
operator|>
operator|(
operator|)
block|;
name|LocalFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|NewFnId
block|;
name|Handlers
index|[
name|NewFnId
index|]
operator|=
name|wrapHandler
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
block|;   }
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|void
name|addAsyncHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
name|static_assert
argument_list|(
argument|detail::RPCArgTypeCheck<                       CanDeserializeCheck
argument_list|,
argument|typename Func::Type
argument_list|,
argument|typename detail::AsyncHandlerTraits<                         typename detail::HandlerTraits<HandlerT>::Type>::Type>::value
argument_list|,
literal|""
argument_list|)
block|;
name|FunctionIdT
name|NewFnId
operator|=
name|FnIdAllocator
operator|.
name|template
name|allocate
operator|<
name|Func
operator|>
operator|(
operator|)
block|;
name|LocalFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|NewFnId
block|;
name|Handlers
index|[
name|NewFnId
index|]
operator|=
name|wrapAsyncHandler
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
block|;   }
name|Error
name|handleResponse
argument_list|(
argument|SequenceNumberT SeqNo
argument_list|)
block|{
name|using
name|Handler
operator|=
name|typename
name|decltype
argument_list|(
name|PendingResponses
argument_list|)
operator|::
name|mapped_type
block|;
name|Handler
name|PRHandler
block|;
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
block|;
name|auto
name|I
operator|=
name|PendingResponses
operator|.
name|find
argument_list|(
name|SeqNo
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|PendingResponses
operator|.
name|end
argument_list|()
condition|)
block|{
name|PRHandler
operator|=
name|std
operator|::
name|move
argument_list|(
name|I
operator|->
name|second
argument_list|)
expr_stmt|;
name|PendingResponses
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|SequenceNumberMgr
operator|.
name|releaseSequenceNumber
argument_list|(
name|SeqNo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Unlock the pending results map to prevent recursive lock.
name|Lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|make_error
operator|<
name|InvalidSequenceNumberForResponse
operator|<
name|SequenceNumberT
operator|>>
operator|(
name|SeqNo
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}      assert
operator|(
name|PRHandler
operator|&&
literal|"If we didn't find a response handler we should have bailed out"
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|PRHandler
operator|->
name|handleResponse
argument_list|(
name|C
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
end_if

begin_return
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
end_return

begin_macro
unit|}    FunctionIdT
name|handleNegotiate
argument_list|(
argument|const std::string&Name
argument_list|)
end_macro

begin_block
block|{
name|auto
name|I
init|=
name|LocalFunctionIds
operator|.
name|find
argument_list|(
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|LocalFunctionIds
operator|.
name|end
argument_list|()
condition|)
return|return
name|getInvalidFunctionId
argument_list|()
return|;
return|return
name|I
operator|->
name|second
return|;
block|}
end_block

begin_comment
comment|// Find the remote FunctionId for the given function.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|>
name|Expected
operator|<
name|FunctionIdT
operator|>
name|getRemoteFunctionId
argument_list|(
argument|bool NegotiateIfNotInMap
argument_list|,
argument|bool NegotiateIfInvalid
argument_list|)
block|{
name|bool
name|DoNegotiate
block|;
comment|// Check if we already have a function id...
name|auto
name|I
operator|=
name|RemoteFunctionIds
operator|.
name|find
argument_list|(
name|Func
operator|::
name|getPrototype
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|RemoteFunctionIds
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// If it's valid there's nothing left to do.
if|if
condition|(
name|I
operator|->
name|second
operator|!=
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
return|;
name|DoNegotiate
operator|=
name|NegotiateIfInvalid
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|DoNegotiate
operator|=
name|NegotiateIfNotInMap
expr_stmt|;
end_else

begin_comment
comment|// We don't have a function id for Func yet, but we're allowed to try to
end_comment

begin_comment
comment|// negotiate one.
end_comment

begin_if
if|if
condition|(
name|DoNegotiate
condition|)
block|{
name|auto
operator|&
name|Impl
operator|=
name|static_cast
operator|<
name|ImplT
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
expr_stmt|;
if|if
condition|(
name|auto
name|RemoteIdOrErr
init|=
name|Impl
operator|.
name|template
name|callB
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
condition|)
block|{
name|RemoteFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
operator|*
name|RemoteIdOrErr
expr_stmt|;
if|if
condition|(
operator|*
name|RemoteIdOrErr
operator|==
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|make_error
operator|<
name|CouldNotNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
return|;
return|return
operator|*
name|RemoteIdOrErr
return|;
block|}
else|else
return|return
name|RemoteIdOrErr
operator|.
name|takeError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// No key was available in the map and we weren't allowed to try to
end_comment

begin_comment
comment|// negotiate one, so return an unknown function error.
end_comment

begin_return
return|return
name|make_error
operator|<
name|CouldNotNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
return|;
end_return

begin_expr_stmt
unit|}    using
name|WrappedHandlerFn
operator|=
name|std
operator|::
name|function
operator|<
name|Error
argument_list|(
name|ChannelT
operator|&
argument_list|,
name|SequenceNumberT
argument_list|)
operator|>
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Wrap the given user handler in the necessary argument-deserialization code,
end_comment

begin_comment
comment|// result-serialization code, and call to the launch policy (if present).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|WrappedHandlerFn
name|wrapHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
index|[
name|this
operator|,
name|Handler
index|]
operator|(
name|ChannelT
operator|&
name|Channel
operator|,
name|SequenceNumberT
name|SeqNo
operator|)
name|mutable
operator|->
name|Error
block|{
comment|// Start by deserializing the arguments.
name|using
name|ArgsTuple
operator|=
name|typename
name|detail
operator|::
name|FunctionArgsTuple
operator|<
name|typename
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|Type
block|;
name|auto
name|Args
operator|=
name|std
operator|::
name|make_shared
operator|<
name|ArgsTuple
operator|>
operator|(
operator|)
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|typename
name|Func
operator|::
name|Type
operator|>
operator|::
name|deserializeArgs
argument_list|(
name|Channel
argument_list|,
operator|*
name|Args
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// GCC 4.7 and 4.8 incorrectly issue a -Wunused-but-set-variable warning
comment|// for RPCArgs. Void cast RPCArgs to work around this for now.
comment|// FIXME: Remove this workaround once we can assume a working GCC version.
operator|(
name|void
operator|)
name|Args
return|;
end_expr_stmt

begin_comment
comment|// End receieve message, unlocking the channel for reading.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|Channel
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_if

begin_decl_stmt
name|using
name|HTraits
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|using
name|FuncReturn
init|=
name|typename
name|Func
operator|::
name|ReturnType
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|detail
operator|::
name|respond
operator|<
name|FuncReturn
operator|>
operator|(
name|Channel
operator|,
name|ResponseId
operator|,
name|SeqNo
operator|,
name|HTraits
operator|::
name|unpackAndRun
argument_list|(
name|Handler
argument_list|,
operator|*
name|Args
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|};   }
comment|// Wrap the given user handler in the necessary argument-deserialization code,
end_comment

begin_comment
comment|// result-serialization code, and call to the launch policy (if present).
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|WrappedHandlerFn
name|wrapAsyncHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
index|[
name|this
operator|,
name|Handler
index|]
operator|(
name|ChannelT
operator|&
name|Channel
operator|,
name|SequenceNumberT
name|SeqNo
operator|)
name|mutable
operator|->
name|Error
block|{
comment|// Start by deserializing the arguments.
name|using
name|AHTraits
operator|=
name|detail
operator|::
name|AsyncHandlerTraits
operator|<
name|typename
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
block|;
name|using
name|ArgsTuple
operator|=
name|typename
name|detail
operator|::
name|FunctionArgsTuple
operator|<
name|typename
name|AHTraits
operator|::
name|Type
operator|>
operator|::
name|Type
block|;
name|auto
name|Args
operator|=
name|std
operator|::
name|make_shared
operator|<
name|ArgsTuple
operator|>
operator|(
operator|)
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|typename
name|Func
operator|::
name|Type
operator|>
operator|::
name|deserializeArgs
argument_list|(
name|Channel
argument_list|,
operator|*
name|Args
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// GCC 4.7 and 4.8 incorrectly issue a -Wunused-but-set-variable warning
comment|// for RPCArgs. Void cast RPCArgs to work around this for now.
comment|// FIXME: Remove this workaround once we can assume a working GCC version.
operator|(
name|void
operator|)
name|Args
return|;
end_expr_stmt

begin_comment
comment|// End receieve message, unlocking the channel for reading.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|Channel
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_if

begin_decl_stmt
name|using
name|HTraits
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|using
name|FuncReturn
init|=
name|typename
name|Func
operator|::
name|ReturnType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|auto
name|Responder
init|=
index|[
name|this
operator|,
name|SeqNo
index|]
operator|(
name|typename
name|AHTraits
operator|::
name|ResultType
name|RetVal
operator|)
operator|->
name|Error
block|{
return|return
name|detail
operator|::
name|respond
operator|<
name|FuncReturn
operator|>
operator|(
name|C
expr|,
name|ResponseId
expr|,
name|SeqNo
expr|,
name|std
operator|::
name|move
argument_list|(
name|RetVal
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_return
return|return
name|HTraits
operator|::
name|unpackAndRunAsync
argument_list|(
name|Handler
argument_list|,
name|Responder
argument_list|,
operator|*
name|Args
argument_list|)
return|;
end_return

begin_expr_stmt
unit|};   }    ChannelT
operator|&
name|C
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|LazyAutoNegotiation
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RPCFunctionIdAllocator
operator|<
name|FunctionIdT
operator|>
name|FnIdAllocator
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FunctionIdT
name|ResponseId
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|FunctionIdT
operator|>
name|LocalFunctionIds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
specifier|const
name|char
operator|*
operator|,
name|FunctionIdT
operator|>
name|RemoteFunctionIds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|FunctionIdT
operator|,
name|WrappedHandlerFn
operator|>
name|Handlers
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|mutex
name|ResponsesMutex
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|detail
operator|::
name|SequenceNumberManager
operator|<
name|SequenceNumberT
operator|>
name|SequenceNumberMgr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|SequenceNumberT
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|detail
operator|::
name|ResponseHandler
operator|<
name|ChannelT
operator|>>>
name|PendingResponses
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace detail
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|=
name|uint32_t
operator|,
name|typename
name|SequenceNumberT
operator|=
name|uint32_t
operator|>
name|class
name|MultiThreadedRPCEndpoint
operator|:
name|public
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|MultiThreadedRPCEndpoint
operator|<
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
operator|,
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
block|{
name|private
operator|:
name|using
name|BaseClass
operator|=
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|MultiThreadedRPCEndpoint
operator|<
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|,
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|;
name|public
operator|:
name|MultiThreadedRPCEndpoint
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
operator|:
name|BaseClass
argument_list|(
argument|C
argument_list|,
argument|LazyAutoNegotiation
argument_list|)
block|{}
comment|/// Add a handler for the given RPC function.
comment|/// This installs the given handler functor for the given RPC Function, and
comment|/// makes the RPC function available for negotiation/calling from the remote.
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
return|;
block|}
comment|/// Add a class-method as a handler.
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|)
block|{
name|addHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|)
block|;   }
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|void
name|addAsyncHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addAsyncHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Add a class-method as a handler.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addAsyncHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|)
block|{
name|addAsyncHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|)
block|;   }
comment|/// Return type for non-blocking call primitives.
name|template
operator|<
name|typename
name|Func
operator|>
name|using
name|NonBlockingCallResult
operator|=
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|ReturnFutureType
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Call Func on Channel C. Does not block, does not call send. Returns a pair
end_comment

begin_comment
comment|/// of a future result and the sequence number assigned to the result.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This utility function is primarily used for single-threaded mode support,
end_comment

begin_comment
comment|/// where the sequence number can be used to wait for the corresponding
end_comment

begin_comment
comment|/// result. In multi-threaded mode the appendCallNB method, which does not
end_comment

begin_comment
comment|/// return the sequence numeber, should be preferred.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Expected
operator|<
name|NonBlockingCallResult
operator|<
name|Func
operator|>>
name|appendCallNB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|using
name|RTraits
operator|=
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
block|;
name|using
name|ErrorReturn
operator|=
name|typename
name|RTraits
operator|::
name|ErrorReturnType
block|;
name|using
name|ErrorReturnPromise
operator|=
name|typename
name|RTraits
operator|::
name|ReturnPromiseType
block|;
comment|// FIXME: Stack allocate and move this into the handler once LLVM builds
comment|//        with C++14.
name|auto
name|Promise
operator|=
name|std
operator|::
name|make_shared
operator|<
name|ErrorReturnPromise
operator|>
operator|(
operator|)
block|;
name|auto
name|FutureResult
operator|=
name|Promise
operator|->
name|get_future
argument_list|()
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
index|[
name|Promise
index|]
operator|(
name|ErrorReturn
name|RetOrErr
operator|)
block|{
name|Promise
operator|->
name|set_value
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RetOrErr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
operator|,
name|Args
operator|...
end_expr_stmt

begin_block
unit|))
block|{
name|RTraits
operator|::
name|consumeAbandoned
argument_list|(
name|FutureResult
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_block

begin_return
return|return
name|std
operator|::
name|move
argument_list|(
name|FutureResult
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// The same as appendCallNBWithSeq, except that it calls C.send() to
end_comment

begin_comment
comment|/// flush the channel after serializing the call.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Expected
operator|<
name|NonBlockingCallResult
operator|<
name|Func
operator|>>
name|callNB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|auto
name|Result
operator|=
name|appendCallNB
operator|<
name|Func
operator|>
operator|(
name|Args
operator|...
operator|)
block|;
if|if
condition|(
operator|!
name|Result
condition|)
return|return
name|Result
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|C
operator|.
name|send
argument_list|()
condition|)
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
operator|->
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_comment
unit|}
comment|/// Call Func on Channel C. Blocks waiting for a result. Returns an Error
end_comment

begin_comment
comment|/// for void functions or an Expected<T> for functions returning a T.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This function is for use in threaded code where another thread is
end_comment

begin_comment
comment|/// handling responses and incoming calls.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|,
name|typename
name|AltRetT
operator|=
name|typename
name|Func
operator|::
name|ReturnType
operator|>
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
name|callB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
if|if
condition|(
name|auto
name|FutureResOrErr
init|=
name|callNB
operator|<
name|Func
operator|>
operator|(
name|Args
operator|...
operator|)
condition|)
return|return
name|FutureResOrErr
operator|->
name|get
argument_list|()
return|;
else|else
return|return
name|FutureResOrErr
operator|.
name|takeError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Handle incoming RPC calls.
end_comment

begin_function
name|Error
name|handlerLoop
parameter_list|()
block|{
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|handleOne
argument_list|()
condition|)
return|return
name|Err
return|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|=
name|uint32_t
operator|,
name|typename
name|SequenceNumberT
operator|=
name|uint32_t
operator|>
name|class
name|SingleThreadedRPCEndpoint
operator|:
name|public
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|SingleThreadedRPCEndpoint
operator|<
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
operator|,
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
block|{
name|private
operator|:
name|using
name|BaseClass
operator|=
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|SingleThreadedRPCEndpoint
operator|<
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|,
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|;
name|public
operator|:
name|SingleThreadedRPCEndpoint
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
operator|:
name|BaseClass
argument_list|(
argument|C
argument_list|,
argument|LazyAutoNegotiation
argument_list|)
block|{}
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|)
block|{
name|addHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|)
block|;   }
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|void
name|addAsyncHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addAsyncHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Add a class-method as a handler.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addAsyncHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|)
block|{
name|addAsyncHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|)
block|;   }
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|,
name|typename
name|AltRetT
operator|=
name|typename
name|Func
operator|::
name|ReturnType
operator|>
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
name|callB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|bool
name|ReceivedResponse
operator|=
name|false
block|;
name|using
name|ResultType
operator|=
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
block|;
name|auto
name|Result
operator|=
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|createBlankErrorReturnValue
argument_list|()
block|;
comment|// We have to 'Check' result (which we know is in a success state at this
comment|// point) so that it can be overwritten in the async handler.
operator|(
name|void
operator|)
operator|!
operator|!
name|Result
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
index|[
operator|&
index|]
operator|(
name|ResultType
name|R
operator|)
block|{
name|Result
operator|=
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|ReceivedResponse
operator|=
name|true
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
operator|,
name|Args
operator|...
end_expr_stmt

begin_block
unit|))
block|{
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_block

begin_while
while|while
condition|(
operator|!
name|ReceivedResponse
condition|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|handleOne
argument_list|()
condition|)
block|{
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
block|}
end_while

begin_return
return|return
name|Result
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Asynchronous dispatch for a function on an RPC endpoint.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|RPCClass
operator|,
name|typename
name|Func
operator|>
name|class
name|RPCAsyncDispatch
block|{
name|public
operator|:
name|RPCAsyncDispatch
argument_list|(
name|RPCClass
operator|&
name|Endpoint
argument_list|)
operator|:
name|Endpoint
argument_list|(
argument|Endpoint
argument_list|)
block|{}
name|template
operator|<
name|typename
name|HandlerT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|operator
argument_list|()
operator|(
name|HandlerT
name|Handler
operator|,
specifier|const
name|ArgTs
operator|&
operator|...
name|Args
operator|)
specifier|const
block|{
return|return
name|Endpoint
operator|.
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|,
name|Args
operator|...
operator|)
return|;
block|}
name|private
operator|:
name|RPCClass
operator|&
name|Endpoint
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// Construct an asynchronous dispatcher from an RPC endpoint and a Func.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|RPCEndpointT
operator|>
name|RPCAsyncDispatch
operator|<
name|RPCEndpointT
operator|,
name|Func
operator|>
name|rpcAsyncDispatch
argument_list|(
argument|RPCEndpointT&Endpoint
argument_list|)
block|{
return|return
name|RPCAsyncDispatch
operator|<
name|RPCEndpointT
operator|,
name|Func
operator|>
operator|(
name|Endpoint
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Allows a set of asynchrounous calls to be dispatched, and then
end_comment

begin_comment
comment|///        waited on as a group.
end_comment

begin_decl_stmt
name|class
name|ParallelCallGroup
block|{
name|public
label|:
name|ParallelCallGroup
argument_list|()
operator|=
expr|default
expr_stmt|;
name|ParallelCallGroup
argument_list|(
specifier|const
name|ParallelCallGroup
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|ParallelCallGroup
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ParallelCallGroup
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
comment|/// \brief Make as asynchronous call.
name|template
operator|<
name|typename
name|AsyncDispatcher
operator|,
name|typename
name|HandlerT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|call
argument_list|(
argument|const AsyncDispatcher&AsyncDispatch
argument_list|,
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
comment|// Increment the count of outstanding calls. This has to happen before
comment|// we invoke the call, as the handler may (depending on scheduling)
comment|// be run immediately on another thread, and we don't want the decrement
comment|// in the wrapped handler below to run before the increment.
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
block|;
operator|++
name|NumOutstandingCalls
block|;     }
comment|// Wrap the user handler in a lambda that will decrement the
comment|// outstanding calls count, then poke the condition variable.
name|using
name|ArgType
operator|=
name|typename
name|detail
operator|::
name|ResponseHandlerArg
operator|<
name|typename
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|ArgType
block|;
comment|// FIXME: Move handler into wrapped handler once we have C++14.
name|auto
name|WrappedHandler
operator|=
index|[
name|this
operator|,
name|Handler
index|]
operator|(
name|ArgType
name|Arg
operator|)
block|{
name|auto
name|Err
operator|=
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
argument_list|)
argument_list|)
block|;
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
block|;
operator|--
name|NumOutstandingCalls
block|;
name|CV
operator|.
name|notify_all
argument_list|()
block|;
return|return
name|Err
return|;
block|}
block|;
return|return
name|AsyncDispatch
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|WrappedHandler
argument_list|)
argument_list|,
name|Args
operator|...
argument_list|)
return|;
block|}
comment|/// \brief Blocks until all calls have been completed and their return value
comment|///        handlers run.
name|void
name|wait
parameter_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
expr_stmt|;
while|while
condition|(
name|NumOutstandingCalls
operator|>
literal|0
condition|)
name|CV
operator|.
name|wait
argument_list|(
name|Lock
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|std
operator|::
name|mutex
name|M
expr_stmt|;
name|std
operator|::
name|condition_variable
name|CV
expr_stmt|;
name|uint32_t
name|NumOutstandingCalls
init|=
literal|0
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// @brief Convenience class for grouping RPC Functions into APIs that can be
end_comment

begin_comment
comment|///        negotiated as a block.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
block|{
name|public
operator|:
comment|/// @brief Test whether this API contains Function F.
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;   }
block|;
comment|/// @brief Negotiate all functions in this API.
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
operator|<
name|Func
operator|,
name|Funcs
operator|...
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_same
operator|<
name|F
block|,
name|Func
operator|>
operator|::
name|value
operator||
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
block|;   }
block|;
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|R
operator|.
name|template
name|negotiateFunction
operator|<
name|Func
operator|>
operator|(
operator|)
condition|)
return|return
name|Err
return|;
return|return
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
operator|...
name|InnerFuncs
operator|,
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
operator|<
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|,
name|Funcs
operator|...
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
operator||
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
block|;   }
block|;
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
condition|)
return|return
name|Err
return|;
return|return
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace rpc
end_comment

begin_comment
unit|}
comment|// end namespace orc
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

