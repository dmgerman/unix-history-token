begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------- RPCUTils.h - Utilities for building RPC APIs -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Utilities to support construction of simple RPC APIs.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The RPC utilities aim for ease of use (minimal conceptual overhead) for C++
end_comment

begin_comment
comment|// programmers, high performance, low memory overhead, and efficient use of the
end_comment

begin_comment
comment|// communications channel.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_EXECUTIONENGINE_ORC_RPCUTILS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_EXECUTIONENGINE_ORC_RPCUTILS_H
end_define

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<thread>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/OrcError.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/Orc/RPCSerialization.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|// concrt.h depends on eh.h for __uncaught_exception declaration
end_comment

begin_comment
comment|// even if we disable exceptions.
end_comment

begin_include
include|#
directive|include
file|<eh.h>
end_include

begin_comment
comment|// Disable warnings from ppltasks.h transitively included by<future>.
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4530
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4062
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<future>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|orc
block|{
name|namespace
name|rpc
block|{
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|FnT
operator|>
name|class
name|Function
expr_stmt|;
comment|// RPC Function class.
comment|// DerivedFunc should be a user defined class with a static 'getName()' method
comment|// returning a const char* representing the function's name.
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
comment|/// User defined function type.
name|using
name|Type
operator|=
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
comment|/// Return type.
name|using
name|ReturnType
operator|=
name|RetT
block|;
comment|/// Returns the full function prototype as a string.
specifier|static
specifier|const
name|char
operator|*
name|getPrototype
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|NameMutex
argument_list|)
block|;
if|if
condition|(
name|Name
operator|.
name|empty
argument_list|()
condition|)
name|raw_string_ostream
argument_list|(
name|Name
argument_list|)
operator|<<
name|RPCTypeName
operator|<
name|RetT
operator|>
operator|::
name|getName
argument_list|()
operator|<<
literal|" "
operator|<<
name|DerivedFunc
operator|::
name|getName
argument_list|()
operator|<<
literal|"("
operator|<<
name|llvm
operator|::
name|orc
operator|::
name|rpc
operator|::
name|RPCTypeNameSequence
operator|<
name|ArgTs
operator|...
operator|>
operator|(
operator|)
operator|<<
literal|")"
expr_stmt|;
return|return
name|Name
operator|.
name|data
argument_list|()
return|;
block|}
name|private
label|:
specifier|static
name|std
operator|::
name|mutex
name|NameMutex
expr_stmt|;
specifier|static
name|std
operator|::
name|string
name|Name
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|std
operator|::
name|mutex
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|::
name|NameMutex
expr_stmt|;
name|template
operator|<
name|typename
name|DerivedFunc
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|std
operator|::
name|string
name|Function
operator|<
name|DerivedFunc
operator|,
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|::
name|Name
expr_stmt|;
comment|/// Provides a typedef for a tuple containing the decayed argument types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|FunctionArgsTuple
expr_stmt|;
name|template
operator|<
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|FunctionArgsTuple
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|std
operator|::
name|tuple
operator|<
name|typename
name|std
operator|::
name|decay
operator|<
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|ArgTs
operator|>
operator|::
name|type
operator|>
operator|::
name|type
operator|...
operator|>
block|; }
expr_stmt|;
comment|/// Allocates RPC function ids during autonegotiation.
comment|/// Specializations of this class must provide four members:
comment|///
comment|/// static T getInvalidId():
comment|///   Should return a reserved id that will be used to represent missing
comment|/// functions during autonegotiation.
comment|///
comment|/// static T getResponseId():
comment|///   Should return a reserved id that will be used to send function responses
comment|/// (return values).
comment|///
comment|/// static T getNegotiateId():
comment|///   Should return a reserved id for the negotiate function, which will be used
comment|/// to negotiate ids for user defined functions.
comment|///
comment|/// template<typename Func> T allocate():
comment|///   Allocate a unique id for function Func.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
operator|=
name|void
operator|>
name|class
name|RPCFunctionIdAllocator
expr_stmt|;
comment|/// This specialization of RPCFunctionIdAllocator provides a default
comment|/// implementation for integral types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|RPCFunctionIdAllocator
operator|<
name|T
operator|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_integral
operator|<
name|T
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
block|{
name|public
operator|:
specifier|static
name|T
name|getInvalidId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|static
name|T
name|getResponseId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|static
name|T
name|getNegotiateId
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|Func
operator|>
name|T
name|allocate
argument_list|()
block|{
return|return
name|NextId
operator|++
return|;
block|}
name|private
operator|:
name|T
name|NextId
operator|=
literal|3
block|; }
expr_stmt|;
name|namespace
name|detail
block|{
comment|// FIXME: Remove MSVCPError/MSVCPExpected once MSVC's future implementation
comment|//        supports classes without default constructors.
ifdef|#
directive|ifdef
name|_MSC_VER
name|namespace
name|msvc_hacks
block|{
comment|// Work around MSVC's future implementation's use of default constructors:
comment|// A default constructed value in the promise will be overwritten when the
comment|// real error is set - so the default constructed Error has to be checked
comment|// already.
name|class
name|MSVCPError
range|:
name|public
name|Error
block|{
name|public
operator|:
name|MSVCPError
argument_list|()
block|{
operator|(
name|void
operator|)
operator|!
operator|!
operator|*
name|this
block|; }
name|MSVCPError
argument_list|(
name|MSVCPError
operator|&&
name|Other
argument_list|)
operator|:
name|Error
argument_list|(
argument|std::move(Other)
argument_list|)
block|{}
name|MSVCPError
operator|&
name|operator
operator|=
operator|(
name|MSVCPError
name|Other
operator|)
block|{
name|Error
operator|::
name|operator
operator|=
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|MSVCPError
argument_list|(
argument|Error Err
argument_list|)
operator|:
name|Error
argument_list|(
argument|std::move(Err)
argument_list|)
block|{}
expr|}
block|;
comment|// Work around MSVC's future implementation, similar to MSVCPError.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|MSVCPExpected
operator|:
name|public
name|Expected
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|MSVCPExpected
argument_list|()
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|make_error
operator|<
name|StringError
operator|>
operator|(
literal|""
expr|,
name|inconvertibleErrorCode
argument_list|()
operator|)
operator|)
block|{
name|consumeError
argument_list|(
name|this
operator|->
name|takeError
argument_list|()
argument_list|)
block|;   }
name|MSVCPExpected
argument_list|(
name|MSVCPExpected
operator|&&
name|Other
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
name|MSVCPExpected
operator|&
name|operator
operator|=
operator|(
name|MSVCPExpected
operator|&&
name|Other
operator|)
block|{
name|Expected
operator|<
name|T
operator|>
operator|::
name|operator
operator|=
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|MSVCPExpected
argument_list|(
argument|Error Err
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
operator|)
block|{}
name|template
operator|<
name|typename
name|OtherT
operator|>
name|MSVCPExpected
argument_list|(
argument|OtherT&&Val
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Val
argument_list|)
operator|)
block|{}
name|template
operator|<
name|class
name|OtherT
operator|>
name|MSVCPExpected
argument_list|(
argument|Expected<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
name|template
operator|<
name|class
name|OtherT
operator|>
name|explicit
name|MSVCPExpected
argument_list|(
argument|Expected<OtherT>&&Other
argument_list|,
argument|typename std::enable_if<!std::is_convertible<OtherT
argument_list|,
argument|T>::value>::type * =           nullptr
argument_list|)
operator|:
name|Expected
operator|<
name|T
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
operator|)
block|{}
expr|}
block|;  }
comment|// end namespace msvc_hacks
endif|#
directive|endif
comment|// _MSC_VER
comment|// ResultTraits provides typedefs and utilities specific to the return type
comment|// of functions.
name|template
operator|<
name|typename
name|RetT
operator|>
name|class
name|ResultTraits
block|{
name|public
operator|:
comment|// The return type wrapped in llvm::Expected.
name|using
name|ErrorReturnType
operator|=
name|Expected
operator|<
name|RetT
operator|>
block|;
ifdef|#
directive|ifdef
name|_MSC_VER
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|msvc_hacks
operator|::
name|MSVCPExpected
operator|<
name|RetT
operator|>>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|msvc_hacks
operator|::
name|MSVCPExpected
operator|<
name|RetT
operator|>>
block|;
else|#
directive|else
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|ErrorReturnType
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|ErrorReturnType
operator|>
block|;
endif|#
directive|endif
comment|// Create a 'blank' value of the ErrorReturnType, ready and safe to
comment|// overwrite.
specifier|static
name|ErrorReturnType
name|createBlankErrorReturnValue
argument_list|()
block|{
return|return
name|ErrorReturnType
argument_list|(
name|RetT
argument_list|()
argument_list|)
return|;
block|}
comment|// Consume an abandoned ErrorReturnType.
specifier|static
name|void
name|consumeAbandoned
argument_list|(
argument|ErrorReturnType RetOrErr
argument_list|)
block|{
name|consumeError
argument_list|(
name|RetOrErr
operator|.
name|takeError
argument_list|()
argument_list|)
block|;   }
expr|}
block|;
comment|// ResultTraits specialization for void functions.
name|template
operator|<
operator|>
name|class
name|ResultTraits
operator|<
name|void
operator|>
block|{
name|public
operator|:
comment|// For void functions, ErrorReturnType is llvm::Error.
name|using
name|ErrorReturnType
operator|=
name|Error
block|;
ifdef|#
directive|ifdef
name|_MSC_VER
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|msvc_hacks
operator|::
name|MSVCPError
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|msvc_hacks
operator|::
name|MSVCPError
operator|>
block|;
else|#
directive|else
comment|// The ErrorReturnType wrapped in a std::promise.
name|using
name|ReturnPromiseType
operator|=
name|std
operator|::
name|promise
operator|<
name|ErrorReturnType
operator|>
block|;
comment|// The ErrorReturnType wrapped in a std::future.
name|using
name|ReturnFutureType
operator|=
name|std
operator|::
name|future
operator|<
name|ErrorReturnType
operator|>
block|;
endif|#
directive|endif
comment|// Create a 'blank' value of the ErrorReturnType, ready and safe to
comment|// overwrite.
specifier|static
name|ErrorReturnType
name|createBlankErrorReturnValue
argument_list|()
block|{
return|return
name|ErrorReturnType
operator|::
name|success
argument_list|()
return|;
block|}
comment|// Consume an abandoned ErrorReturnType.
specifier|static
name|void
name|consumeAbandoned
argument_list|(
argument|ErrorReturnType Err
argument_list|)
block|{
name|consumeError
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
block|;   }
expr|}
block|;
comment|// ResultTraits<Error> is equivalent to ResultTraits<void>. This allows
comment|// handlers for void RPC functions to return either void (in which case they
comment|// implicitly succeed) or Error (in which case their error return is
comment|// propagated). See usage in HandlerTraits::runHandlerHelper.
name|template
operator|<
operator|>
name|class
name|ResultTraits
operator|<
name|Error
operator|>
operator|:
name|public
name|ResultTraits
operator|<
name|void
operator|>
block|{}
block|;
comment|// ResultTraits<Expected<T>> is equivalent to ResultTraits<T>. This allows
comment|// handlers for RPC functions returning a T to return either a T (in which
comment|// case they implicitly succeed) or Expected<T> (in which case their error
comment|// return is propagated). See usage in HandlerTraits::runHandlerHelper.
name|template
operator|<
name|typename
name|RetT
operator|>
name|class
name|ResultTraits
operator|<
name|Expected
operator|<
name|RetT
operator|>>
operator|:
name|public
name|ResultTraits
operator|<
name|RetT
operator|>
block|{}
block|;
comment|// Send a response of the given wire return type (WireRetT) over the
comment|// channel, with the given sequence number.
name|template
operator|<
name|typename
name|WireRetT
block|,
name|typename
name|HandlerRetT
block|,
name|typename
name|ChannelT
block|,
name|typename
name|FunctionIdT
block|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|respond
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Expected<HandlerRetT> ResultOrErr
argument_list|)
block|{
comment|// If this was an error bail out.
comment|// FIXME: Send an "error" message to the client if this is not a channel
comment|//        failure?
if|if
condition|(
name|auto
name|Err
init|=
name|ResultOrErr
operator|.
name|takeError
argument_list|()
condition|)
return|return
name|Err
return|;
comment|// Open the response message.
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// Serialize the result.
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|WireRetT
condition|,
name|HandlerRetT
decl|>::
name|serialize
argument_list|(
name|C
argument_list|,
operator|*
name|ResultOrErr
argument_list|)
condition|)     return Err;
comment|// Close the response message.
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
comment|// Send an empty response message on the given channel to indicate that
comment|// the handler ran.
name|template
operator|<
name|typename
name|WireRetT
operator|,
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
specifier|static
name|Error
name|respond
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const FunctionIdT&ResponseId
argument_list|,
argument|SequenceNumberT SeqNo
argument_list|,
argument|Error Err
argument_list|)
block|{
if|if
condition|(
name|Err
condition|)
return|return
name|Err
return|;
if|if
condition|(
name|auto
name|Err2
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|ResponseId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err2
return|;
return|return
name|C
operator|.
name|endSendMessage
argument_list|()
return|;
block|}
comment|// Converts a given type to the equivalent error return type.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|WrappedHandlerReturn
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Expected
operator|<
name|T
operator|>
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|Expected
operator|<
name|T
operator|>>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Expected
operator|<
name|T
operator|>
block|; }
expr_stmt|;
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|void
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|Error
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
name|template
operator|<
operator|>
name|class
name|WrappedHandlerReturn
operator|<
name|ErrorSuccess
operator|>
block|{
name|public
operator|:
name|using
name|Type
operator|=
name|Error
block|; }
expr_stmt|;
comment|// This template class provides utilities related to RPC function handlers.
comment|// The base case applies to non-function types (the template class is
comment|// specialized for function types) and inherits from the appropriate
comment|// speciilization for the given non-function type's call operator.
name|template
operator|<
name|typename
name|HandlerT
operator|>
name|class
name|HandlerTraits
operator|:
name|public
name|HandlerTraits
operator|<
name|decltype
argument_list|(
operator|&
name|std
operator|::
name|remove_reference
operator|<
name|HandlerT
operator|>
operator|::
name|type
operator|::
name|operator
argument_list|()
argument_list|)
operator|>
block|{ }
expr_stmt|;
comment|// Traits for handlers with a given function type.
name|template
operator|<
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{
name|public
operator|:
comment|// Function type of the handler.
name|using
name|Type
operator|=
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
comment|// Return type of the handler.
name|using
name|ReturnType
operator|=
name|RetT
block|;
comment|// A std::tuple wrapping the handler arguments.
name|using
name|ArgStorage
operator|=
name|typename
name|FunctionArgsTuple
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|::
name|Type
block|;
comment|// Call the given handler with the given arguments.
name|template
operator|<
name|typename
name|HandlerT
operator|>
specifier|static
name|typename
name|WrappedHandlerReturn
operator|<
name|RetT
operator|>
operator|::
name|Type
name|unpackAndRun
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgStorage&Args
argument_list|)
block|{
return|return
name|unpackAndRunHelper
argument_list|(
name|Handler
argument_list|,
name|Args
argument_list|,
name|llvm
operator|::
name|index_sequence_for
operator|<
name|ArgTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
comment|// Call the given handler with the given arguments.
name|template
operator|<
name|typename
name|HandlerT
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_void
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|value
block|,
name|Error
operator|>
operator|::
name|type
name|run
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgTs&&... Args
argument_list|)
block|{
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
argument_list|)
block|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|HandlerT
operator|>
specifier|static
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_void
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|value
block|,
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|type
name|run
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgTs... Args
argument_list|)
block|{
return|return
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
argument_list|)
return|;
block|}
comment|// Serialize arguments to the channel.
name|template
operator|<
name|typename
name|ChannelT
block|,
name|typename
operator|...
name|CArgTs
operator|>
specifier|static
name|Error
name|serializeArgs
argument_list|(
argument|ChannelT&C
argument_list|,
argument|const CArgTs... CArgs
argument_list|)
block|{
return|return
name|SequenceSerialization
operator|<
name|ChannelT
operator|,
name|ArgTs
operator|...
operator|>
operator|::
name|serialize
argument_list|(
name|C
argument_list|,
name|CArgs
operator|...
argument_list|)
return|;
block|}
comment|// Deserialize arguments from the channel.
name|template
operator|<
name|typename
name|ChannelT
block|,
name|typename
operator|...
name|CArgTs
operator|>
specifier|static
name|Error
name|deserializeArgs
argument_list|(
argument|ChannelT&C
argument_list|,
argument|std::tuple<CArgTs...>&Args
argument_list|)
block|{
return|return
name|deserializeArgsHelper
argument_list|(
name|C
argument_list|,
name|Args
argument_list|,
name|llvm
operator|::
name|index_sequence_for
operator|<
name|CArgTs
operator|...
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
name|private
operator|:
name|template
operator|<
name|typename
name|ChannelT
block|,
name|typename
operator|...
name|CArgTs
block|,
name|size_t
operator|...
name|Indexes
operator|>
specifier|static
name|Error
name|deserializeArgsHelper
argument_list|(
argument|ChannelT&C
argument_list|,
argument|std::tuple<CArgTs...>&Args
argument_list|,
argument|llvm::index_sequence<Indexes...> _
argument_list|)
block|{
return|return
name|SequenceSerialization
operator|<
name|ChannelT
operator|,
name|ArgTs
operator|...
operator|>
operator|::
name|deserialize
argument_list|(
name|C
argument_list|,
name|std
operator|::
name|get
operator|<
name|Indexes
operator|>
operator|(
name|Args
operator|)
operator|...
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|HandlerT
block|,
name|size_t
operator|...
name|Indexes
operator|>
specifier|static
name|typename
name|WrappedHandlerReturn
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ReturnType
operator|>
operator|::
name|Type
name|unpackAndRunHelper
argument_list|(
argument|HandlerT&Handler
argument_list|,
argument|ArgStorage&Args
argument_list|,
argument|llvm::index_sequence<Indexes...>
argument_list|)
block|{
return|return
name|run
argument_list|(
name|Handler
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|std
operator|::
name|get
operator|<
name|Indexes
operator|>
operator|(
name|Args
operator|)
argument_list|)
operator|...
argument_list|)
return|;
block|}
expr|}
block|;
comment|// Handler traits for class methods (especially call operators for lambdas).
name|template
operator|<
name|typename
name|Class
block|,
name|typename
name|RetT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|Class
operator|::
operator|*
argument_list|)
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
operator|:
name|public
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{}
block|;
comment|// Handler traits for const class methods (especially call operators for
comment|// lambdas).
name|template
operator|<
name|typename
name|Class
block|,
name|typename
name|RetT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|HandlerTraits
operator|<
name|RetT
argument_list|(
argument|Class::*
argument_list|)
operator|(
name|ArgTs
operator|...
operator|)
specifier|const
operator|>
operator|:
name|public
name|HandlerTraits
operator|<
name|RetT
argument_list|(
name|ArgTs
operator|...
argument_list|)
operator|>
block|{}
block|;
comment|// Utility to peel the Expected wrapper off a response handler error type.
name|template
operator|<
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerArg
block|;
name|template
operator|<
name|typename
name|ArgT
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|Error
argument_list|(
name|Expected
operator|<
name|ArgT
operator|>
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Expected
operator|<
name|ArgT
operator|>
block|;
name|using
name|UnwrappedArgType
operator|=
name|ArgT
block|; }
block|;
name|template
operator|<
name|typename
name|ArgT
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|ErrorSuccess
argument_list|(
name|Expected
operator|<
name|ArgT
operator|>
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Expected
operator|<
name|ArgT
operator|>
block|;
name|using
name|UnwrappedArgType
operator|=
name|ArgT
block|; }
block|;
name|template
operator|<
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|Error
argument_list|(
name|Error
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Error
block|; }
block|;
name|template
operator|<
operator|>
name|class
name|ResponseHandlerArg
operator|<
name|ErrorSuccess
argument_list|(
name|Error
argument_list|)
operator|>
block|{
name|public
operator|:
name|using
name|ArgType
operator|=
name|Error
block|; }
block|;
comment|// ResponseHandler represents a handler for a not-yet-received function call
comment|// result.
name|template
operator|<
name|typename
name|ChannelT
operator|>
name|class
name|ResponseHandler
block|{
name|public
operator|:
name|virtual
operator|~
name|ResponseHandler
argument_list|()
block|{}
comment|// Reads the function result off the wire and acts on it. The meaning of
comment|// "act" will depend on how this method is implemented in any given
comment|// ResponseHandler subclass but could, for example, mean running a
comment|// user-specified handler or setting a promise value.
name|virtual
name|Error
name|handleResponse
argument_list|(
name|ChannelT
operator|&
name|C
argument_list|)
operator|=
literal|0
block|;
comment|// Abandons this outstanding result.
name|virtual
name|void
name|abandon
argument_list|()
operator|=
literal|0
block|;
comment|// Create an error instance representing an abandoned response.
specifier|static
name|Error
name|createAbandonedResponseError
argument_list|()
block|{
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|RPCResponseAbandoned
argument_list|)
return|;
block|}
expr|}
block|;
comment|// ResponseHandler subclass for RPC functions with non-void returns.
name|template
operator|<
name|typename
name|ChannelT
block|,
name|typename
name|FuncRetT
block|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result by deserializing it from the channel then passing it
comment|// to the user defined handler.
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
name|using
name|UnwrappedArgType
operator|=
name|typename
name|ResponseHandlerArg
operator|<
name|typename
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|UnwrappedArgType
block|;
name|UnwrappedArgType
name|Result
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|SerializationTraits
operator|<
name|ChannelT
condition|,
name|FuncRetT
condition|,
name|UnwrappedArgType
decl|>::
name|deserialize
argument_list|(
name|C
argument_list|,
name|Result
argument_list|)
condition|)       return Err;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
return|return
name|Handler
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|// Abandon this response by calling the handler with an 'abandoned response'
comment|// error.
name|void
name|abandon
argument_list|()
name|override
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|private
operator|:
name|HandlerT
name|Handler
block|; }
expr_stmt|;
comment|// ResponseHandler subclass for RPC functions with void returns.
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|HandlerT
operator|>
name|class
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|void
operator|,
name|HandlerT
operator|>
operator|:
name|public
name|ResponseHandler
operator|<
name|ChannelT
operator|>
block|{
name|public
operator|:
name|ResponseHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|)
operator|:
name|Handler
argument_list|(
argument|std::move(Handler)
argument_list|)
block|{}
comment|// Handle the result (no actual value, just a notification that the function
comment|// has completed on the remote end) by calling the user-defined handler with
comment|// Error::success().
name|Error
name|handleResponse
argument_list|(
argument|ChannelT&C
argument_list|)
name|override
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
return|return
name|Handler
argument_list|(
name|Error
operator|::
name|success
argument_list|()
argument_list|)
return|;
block|}
comment|// Abandon this response by calling the handler with an 'abandoned response'
comment|// error.
name|void
name|abandon
parameter_list|()
function|override
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|this
operator|->
name|createAbandonedResponseError
argument_list|()
argument_list|)
condition|)
block|{
comment|// Handlers should not fail when passed an abandoned response error.
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|private
label|:
name|HandlerT
name|Handler
decl_stmt|;
block|}
empty_stmt|;
comment|// Create a ResponseHandler from a given user handler.
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FuncRetT
operator|,
name|typename
name|HandlerT
operator|>
name|std
operator|::
name|unique_ptr
operator|<
name|ResponseHandler
operator|<
name|ChannelT
operator|>>
name|createResponseHandler
argument_list|(
argument|HandlerT H
argument_list|)
block|{
return|return
name|llvm
operator|::
name|make_unique
operator|<
name|ResponseHandlerImpl
operator|<
name|ChannelT
operator|,
name|FuncRetT
operator|,
name|HandlerT
operator|>>
operator|(
name|std
operator|::
name|move
argument_list|(
name|H
argument_list|)
operator|)
return|;
block|}
comment|// Helper for wrapping member functions up as functors. This is useful for
comment|// installing methods as result handlers.
name|template
operator|<
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|MemberFnWrapper
block|{
name|public
operator|:
name|using
name|MethodT
operator|=
name|RetT
argument_list|(
name|ClassT
operator|::
operator|*
argument_list|)
argument_list|(
name|ArgTs
operator|...
argument_list|)
block|;
name|MemberFnWrapper
argument_list|(
argument|ClassT&Instance
argument_list|,
argument|MethodT Method
argument_list|)
operator|:
name|Instance
argument_list|(
name|Instance
argument_list|)
block|,
name|Method
argument_list|(
argument|Method
argument_list|)
block|{}
name|RetT
name|operator
argument_list|()
operator|(
name|ArgTs
operator|&&
operator|...
name|Args
operator|)
block|{
return|return
operator|(
name|Instance
operator|.*
name|Method
operator|)
operator|(
name|std
operator|::
name|move
argument_list|(
name|Args
argument_list|)
operator|...
operator|)
return|;
block|}
name|private
operator|:
name|ClassT
operator|&
name|Instance
block|;
name|MethodT
name|Method
block|; }
expr_stmt|;
comment|// Helper that provides a Functor for deserializing arguments.
name|template
operator|<
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|ReadArgs
block|{
name|public
operator|:
name|Error
name|operator
argument_list|()
operator|(
operator|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|ArgT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|class
name|ReadArgs
operator|<
name|ArgT
block|,
name|ArgTs
operator|...
operator|>
operator|:
name|public
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
block|{
name|public
operator|:
name|ReadArgs
argument_list|(
name|ArgT
operator|&
name|Arg
argument_list|,
name|ArgTs
operator|&
operator|...
name|Args
argument_list|)
operator|:
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|(
name|Args
operator|...
operator|)
block|,
name|Arg
argument_list|(
argument|Arg
argument_list|)
block|{}
name|Error
name|operator
argument_list|()
operator|(
name|ArgT
operator|&
name|ArgVal
operator|,
name|ArgTs
operator|&
operator|...
name|ArgVals
operator|)
block|{
name|this
operator|->
name|Arg
operator|=
name|std
operator|::
name|move
argument_list|(
name|ArgVal
argument_list|)
block|;
return|return
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|::
name|operator
argument_list|()
argument_list|(
name|ArgVals
operator|...
argument_list|)
return|;
block|}
name|private
operator|:
name|ArgT
operator|&
name|Arg
block|; }
block|;
comment|// Manage sequence numbers.
name|template
operator|<
name|typename
name|SequenceNumberT
operator|>
name|class
name|SequenceNumberManager
block|{
name|public
operator|:
comment|// Reset, making all sequence numbers available.
name|void
name|reset
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
block|;
name|NextSequenceNumber
operator|=
literal|0
block|;
name|FreeSequenceNumbers
operator|.
name|clear
argument_list|()
block|;   }
comment|// Get the next available sequence number. Will re-use numbers that have
comment|// been released.
name|SequenceNumberT
name|getSequenceNumber
argument_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
block|;
if|if
condition|(
name|FreeSequenceNumbers
operator|.
name|empty
argument_list|()
condition|)
return|return
name|NextSequenceNumber
operator|++
return|;
name|auto
name|SequenceNumber
operator|=
name|FreeSequenceNumbers
operator|.
name|back
argument_list|()
block|;
name|FreeSequenceNumbers
operator|.
name|pop_back
argument_list|()
block|;
return|return
name|SequenceNumber
return|;
block|}
comment|// Release a sequence number, making it available for re-use.
name|void
name|releaseSequenceNumber
argument_list|(
argument|SequenceNumberT SequenceNumber
argument_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|SeqNoLock
argument_list|)
block|;
name|FreeSequenceNumbers
operator|.
name|push_back
argument_list|(
name|SequenceNumber
argument_list|)
block|;   }
name|private
operator|:
name|std
operator|::
name|mutex
name|SeqNoLock
block|;
name|SequenceNumberT
name|NextSequenceNumber
operator|=
literal|0
block|;
name|std
operator|::
name|vector
operator|<
name|SequenceNumberT
operator|>
name|FreeSequenceNumbers
block|; }
expr_stmt|;
comment|// Checks that predicate P holds for each corresponding pair of type arguments
comment|// from T1 and T2 tuple.
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T1Tuple
operator|,
name|typename
name|T2Tuple
operator|>
name|class
name|RPCArgTypeCheckHelper
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|>
name|class
name|RPCArgTypeCheckHelper
operator|<
name|P
operator|,
name|std
operator|::
name|tuple
operator|<
operator|>
operator|,
name|std
operator|::
name|tuple
operator|<
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T
operator|,
name|typename
operator|...
name|Ts
operator|,
name|typename
name|U
operator|,
name|typename
operator|...
name|Us
operator|>
name|class
name|RPCArgTypeCheckHelper
operator|<
name|P
operator|,
name|std
operator|::
name|tuple
operator|<
name|T
operator|,
name|Ts
operator|...
operator|>
operator|,
name|std
operator|::
name|tuple
operator|<
name|U
operator|,
name|Us
operator|...
operator|>>
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|P
operator|<
name|T
block|,
name|U
operator|>
operator|::
name|value
operator|&&
name|RPCArgTypeCheckHelper
operator|<
name|P
block|,
name|std
operator|::
name|tuple
operator|<
name|Ts
operator|...
operator|>
block|,
name|std
operator|::
name|tuple
operator|<
name|Us
operator|...
operator|>>
operator|::
name|value
block|; }
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|class
name|P
operator|,
name|typename
name|T1Sig
operator|,
name|typename
name|T2Sig
operator|>
name|class
name|RPCArgTypeCheck
block|{
name|public
operator|:
name|using
name|T1Tuple
operator|=
name|typename
name|FunctionArgsTuple
operator|<
name|T1Sig
operator|>
operator|::
name|Type
block|;
name|using
name|T2Tuple
operator|=
name|typename
name|FunctionArgsTuple
operator|<
name|T2Sig
operator|>
operator|::
name|Type
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|tuple_size
operator|<
name|T1Tuple
operator|>
operator|::
name|value
operator|>=
name|std
operator|::
name|tuple_size
operator|<
name|T2Tuple
operator|>
operator|::
name|value
argument_list|,
literal|"Too many arguments to RPC call"
argument_list|)
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|tuple_size
operator|<
name|T1Tuple
operator|>
operator|::
name|value
operator|<=
name|std
operator|::
name|tuple_size
operator|<
name|T2Tuple
operator|>
operator|::
name|value
argument_list|,
literal|"Too few arguments to RPC call"
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|value
operator|=
name|RPCArgTypeCheckHelper
operator|<
name|P
block|,
name|T1Tuple
block|,
name|T2Tuple
operator|>
operator|::
name|value
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanSerialize
block|{
name|private
operator|:
name|using
name|S
operator|=
name|SerializationTraits
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|std
operator|::
name|true_type
name|check
argument_list|(
argument|typename std::enable_if<         std::is_same<decltype(T::serialize(std::declval<ChannelT&>(),                                            std::declval<const ConcreteT&>()))
argument_list|,
argument|Error>::value
argument_list|,
argument|void *>::type
argument_list|)
block|;
name|template
operator|<
name|typename
operator|>
specifier|static
name|std
operator|::
name|false_type
name|check
argument_list|(
operator|...
argument_list|)
block|;
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|decltype
argument_list|(
name|check
operator|<
name|S
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|::
name|value
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|WireT
operator|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanDeserialize
block|{
name|private
operator|:
name|using
name|S
operator|=
name|SerializationTraits
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|;
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|std
operator|::
name|true_type
name|check
argument_list|(
argument|typename std::enable_if<         std::is_same<decltype(T::deserialize(std::declval<ChannelT&>(),                                              std::declval<ConcreteT&>()))
argument_list|,
argument|Error>::value
argument_list|,
argument|void *>::type
argument_list|)
block|;
name|template
operator|<
name|typename
operator|>
specifier|static
name|std
operator|::
name|false_type
name|check
argument_list|(
operator|...
argument_list|)
block|;
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|decltype
argument_list|(
name|check
operator|<
name|S
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|::
name|value
block|; }
expr_stmt|;
comment|/// Contains primitive utilities for defining, calling and handling calls to
comment|/// remote procedures. ChannelT is a bidirectional stream conforming to the
comment|/// RPCChannel interface (see RPCChannel.h), FunctionIdT is a procedure
comment|/// identifier type that must be serializable on ChannelT, and SequenceNumberT
comment|/// is an integral type that will be used to number in-flight function calls.
comment|///
comment|/// These utilities support the construction of very primitive RPC utilities.
comment|/// Their intent is to ensure correct serialization and deserialization of
comment|/// procedure arguments, and to keep the client and server's view of the API in
comment|/// sync.
name|template
operator|<
name|typename
name|ImplT
operator|,
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|,
name|typename
name|SequenceNumberT
operator|>
name|class
name|RPCEndpointBase
block|{
name|protected
operator|:
name|class
name|OrcRPCInvalid
operator|:
name|public
name|Function
operator|<
name|OrcRPCInvalid
block|,
name|void
argument_list|()
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|char
operator|*
name|getName
argument_list|()
block|{
return|return
literal|"__orc_rpc$invalid"
return|;
block|}
expr|}
block|;
name|class
name|OrcRPCResponse
operator|:
name|public
name|Function
operator|<
name|OrcRPCResponse
block|,
name|void
argument_list|()
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|char
operator|*
name|getName
argument_list|()
block|{
return|return
literal|"__orc_rpc$response"
return|;
block|}
expr|}
block|;
name|class
name|OrcRPCNegotiate
operator|:
name|public
name|Function
operator|<
name|OrcRPCNegotiate
block|,
name|FunctionIdT
argument_list|(
name|std
operator|::
name|string
argument_list|)
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|char
operator|*
name|getName
argument_list|()
block|{
return|return
literal|"__orc_rpc$negotiate"
return|;
block|}
expr|}
block|;
comment|// Helper predicate for testing for the presence of SerializeTraits
comment|// serializers.
name|template
operator|<
name|typename
name|WireT
block|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanSerializeCheck
operator|:
name|detail
operator|::
name|CanSerialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|{
name|public
operator|:
name|using
name|detail
operator|::
name|CanSerialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
operator|::
name|value
block|;
name|static_assert
argument_list|(
name|value
argument_list|,
literal|"Missing serializer for argument (Can't serialize the "
literal|"first template type argument of CanSerializeCheck "
literal|"from the second)"
argument_list|)
block|;   }
block|;
comment|// Helper predicate for testing for the presence of SerializeTraits
comment|// deserializers.
name|template
operator|<
name|typename
name|WireT
block|,
name|typename
name|ConcreteT
operator|>
name|class
name|CanDeserializeCheck
operator|:
name|detail
operator|::
name|CanDeserialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
block|{
name|public
operator|:
name|using
name|detail
operator|::
name|CanDeserialize
operator|<
name|ChannelT
block|,
name|WireT
block|,
name|ConcreteT
operator|>
operator|::
name|value
block|;
name|static_assert
argument_list|(
name|value
argument_list|,
literal|"Missing deserializer for argument (Can't deserialize "
literal|"the second template type argument of "
literal|"CanDeserializeCheck from the first)"
argument_list|)
block|;   }
block|;
name|public
operator|:
comment|/// Construct an RPC instance on a channel.
name|RPCEndpointBase
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
operator|:
name|C
argument_list|(
name|C
argument_list|)
block|,
name|LazyAutoNegotiation
argument_list|(
argument|LazyAutoNegotiation
argument_list|)
block|{
comment|// Hold ResponseId in a special variable, since we expect Response to be
comment|// called relatively frequently, and want to avoid the map lookup.
name|ResponseId
operator|=
name|FnIdAllocator
operator|.
name|getResponseId
argument_list|()
block|;
name|RemoteFunctionIds
index|[
name|OrcRPCResponse
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|ResponseId
block|;
comment|// Register the negotiate function id and handler.
name|auto
name|NegotiateId
operator|=
name|FnIdAllocator
operator|.
name|getNegotiateId
argument_list|()
block|;
name|RemoteFunctionIds
index|[
name|OrcRPCNegotiate
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|NegotiateId
block|;
name|Handlers
index|[
name|NegotiateId
index|]
operator|=
name|wrapHandler
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
index|[
name|this
index|]
operator|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
operator|)
block|{
return|return
name|handleNegotiate
argument_list|(
name|Name
argument_list|)
return|;
block|}
operator|,
name|LaunchPolicy
argument_list|()
operator|)
block|;   }
comment|/// Append a call Func, does not call send on the channel.
comment|/// The first argument specifies a user-defined handler to be run when the
comment|/// function returns. The handler should take an Expected<Func::ReturnType>,
comment|/// or an Error (if Func::ReturnType is void). The handler will be called
comment|/// with an error if the return value is abandoned due to a channel error.
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|appendCallAsync
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
name|static_assert
argument_list|(
argument|detail::RPCArgTypeCheck<CanSerializeCheck
argument_list|,
argument|typename Func::Type
argument_list|,
argument|void(ArgTs...)>::value
argument_list|,
literal|""
argument_list|)
block|;
comment|// Look up the function ID.
name|FunctionIdT
name|FnId
block|;
if|if
condition|(
name|auto
name|FnIdOrErr
init|=
name|getRemoteFunctionId
operator|<
name|Func
operator|>
operator|(
operator|)
condition|)
name|FnId
operator|=
operator|*
name|FnIdOrErr
expr_stmt|;
else|else
block|{
comment|// This isn't a channel error so we don't want to abandon other pending
comment|// responses, but we still need to run the user handler with an error to
comment|// let them know the call failed.
if|if
condition|(
name|auto
name|Err
init|=
name|Handler
argument_list|(
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
argument_list|)
condition|)
name|report_fatal_error
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FnIdOrErr
operator|.
name|takeError
argument_list|()
return|;
block|}
name|SequenceNumberT
name|SeqNo
decl_stmt|;
comment|// initialized in locked scope below.
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
block|;
comment|// Allocate a sequence number.
name|SeqNo
operator|=
name|SequenceNumberMgr
operator|.
name|getSequenceNumber
argument_list|()
block|;
name|assert
argument_list|(
operator|!
name|PendingResponses
operator|.
name|count
argument_list|(
name|SeqNo
argument_list|)
operator|&&
literal|"Sequence number already allocated"
argument_list|)
block|;
comment|// Install the user handler.
name|PendingResponses
index|[
name|SeqNo
index|]
operator|=
name|detail
operator|::
name|createResponseHandler
operator|<
name|ChannelT
block|,
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|)
block|;     }
comment|// Open the function call message.
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startSendMessage
argument_list|(
name|FnId
argument_list|,
name|SeqNo
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|joinErrors
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|,
name|C
operator|.
name|endSendMessage
argument_list|()
argument_list|)
return|;
block|}
comment|// Serialize the call arguments.
if|if
condition|(
name|auto
name|Err
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|typename
name|Func
operator|::
name|Type
operator|>
operator|::
name|serializeArgs
argument_list|(
name|C
argument_list|,
name|Args
operator|...
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|joinErrors
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
argument_list|,
name|C
operator|.
name|endSendMessage
argument_list|()
argument_list|)
return|;
block|}
comment|// Close the function call messagee.
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|endSendMessage
argument_list|()
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
name|Error
name|sendAppendedCalls
argument_list|()
block|{
return|return
name|C
operator|.
name|send
argument_list|()
return|;
block|}
block|;
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|callAsync
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
expr|,
name|Args
operator|...
operator|)
condition|)
return|return
name|Err
return|;
return|return
name|C
operator|.
name|send
argument_list|()
return|;
block|}
comment|/// Handle one incoming call.
name|Error
name|handleOne
argument_list|()
block|{
name|FunctionIdT
name|FnId
block|;
name|SequenceNumberT
name|SeqNo
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|C
operator|.
name|startReceiveMessage
argument_list|(
name|FnId
argument_list|,
name|SeqNo
argument_list|)
condition|)
return|return
name|Err
return|;
if|if
condition|(
name|FnId
operator|==
name|ResponseId
condition|)
return|return
name|handleResponse
argument_list|(
name|SeqNo
argument_list|)
return|;
name|auto
name|I
operator|=
name|Handlers
operator|.
name|find
argument_list|(
name|FnId
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|Handlers
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
argument_list|(
name|C
argument_list|,
name|SeqNo
argument_list|)
return|;
comment|// else: No handler found. Report error to client?
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnexpectedRPCCall
argument_list|)
return|;
block|}
comment|/// Helper for handling setter procedures - this method returns a functor that
comment|/// sets the variables referred to by Args... to values deserialized from the
comment|/// channel.
comment|/// E.g.
comment|///
comment|///   typedef Function<0, bool, int> Func1;
comment|///
comment|///   ...
comment|///   bool B;
comment|///   int I;
comment|///   if (auto Err = expect<Func1>(Channel, readArgs(B, I)))
comment|///     /* Handle Args */ ;
comment|///
name|template
operator|<
name|typename
operator|...
name|ArgTs
operator|>
specifier|static
name|detail
operator|::
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
name|readArgs
argument_list|(
argument|ArgTs&... Args
argument_list|)
block|{
return|return
name|detail
operator|::
name|ReadArgs
operator|<
name|ArgTs
operator|...
operator|>
operator|(
name|Args
operator|...
operator|)
return|;
block|}
comment|/// Abandon all outstanding result handlers.
comment|///
comment|/// This will call all currently registered result handlers to receive an
comment|/// "abandoned" error as their argument. This is used internally by the RPC
comment|/// in error situations, but can also be called directly by clients who are
comment|/// disconnecting from the remote and don't or can't expect responses to their
comment|/// outstanding calls. (Especially for outstanding blocking calls, calling
comment|/// this function may be necessary to avoid dead threads).
name|void
name|abandonPendingResponses
parameter_list|()
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|KV
operator|:
name|PendingResponses
control|)
name|KV
operator|.
name|second
operator|->
name|abandon
argument_list|()
expr_stmt|;
name|PendingResponses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SequenceNumberMgr
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|protected
label|:
comment|// The LaunchPolicy type allows a launch policy to be specified when adding
comment|// a function handler. See addHandlerImpl.
name|using
name|LaunchPolicy
init|=
name|std
operator|::
name|function
operator|<
name|Error
argument_list|(
name|std
operator|::
name|function
operator|<
name|Error
argument_list|()
operator|>
argument_list|)
operator|>
decl_stmt|;
name|FunctionIdT
name|getInvalidFunctionId
argument_list|()
specifier|const
block|{
return|return
name|FnIdAllocator
operator|.
name|getInvalidId
argument_list|()
return|;
block|}
comment|/// Add the given handler to the handler map and make it available for
comment|/// autonegotiation and execution.
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandlerImpl
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|LaunchPolicy Launch
argument_list|)
block|{
name|static_assert
argument_list|(
argument|detail::RPCArgTypeCheck<                       CanDeserializeCheck
argument_list|,
argument|typename Func::Type
argument_list|,
argument|typename detail::HandlerTraits<HandlerT>::Type>::value
argument_list|,
literal|""
argument_list|)
block|;
name|FunctionIdT
name|NewFnId
operator|=
name|FnIdAllocator
operator|.
name|template
name|allocate
operator|<
name|Func
operator|>
operator|(
operator|)
block|;
name|LocalFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|NewFnId
block|;
name|Handlers
index|[
name|NewFnId
index|]
operator|=
name|wrapHandler
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|,
name|std
operator|::
name|move
argument_list|(
name|Launch
argument_list|)
operator|)
block|;   }
name|Error
name|handleResponse
argument_list|(
argument|SequenceNumberT SeqNo
argument_list|)
block|{
name|using
name|Handler
operator|=
name|typename
name|decltype
argument_list|(
name|PendingResponses
argument_list|)
operator|::
name|mapped_type
block|;
name|Handler
name|PRHandler
block|;
block|{
comment|// Lock the pending responses map and sequence number manager.
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|ResponsesMutex
argument_list|)
block|;
name|auto
name|I
operator|=
name|PendingResponses
operator|.
name|find
argument_list|(
name|SeqNo
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|PendingResponses
operator|.
name|end
argument_list|()
condition|)
block|{
name|PRHandler
operator|=
name|std
operator|::
name|move
argument_list|(
name|I
operator|->
name|second
argument_list|)
expr_stmt|;
name|PendingResponses
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|SequenceNumberMgr
operator|.
name|releaseSequenceNumber
argument_list|(
name|SeqNo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Unlock the pending results map to prevent recursive lock.
name|Lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnexpectedRPCResponse
argument_list|)
return|;
block|}
block|}
name|assert
argument_list|(
name|PRHandler
operator|&&
literal|"If we didn't find a response handler we should have bailed out"
argument_list|)
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|PRHandler
operator|->
name|handleResponse
argument_list|(
name|C
argument_list|)
condition|)
block|{
name|abandonPendingResponses
argument_list|()
expr_stmt|;
return|return
name|Err
return|;
block|}
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
name|FunctionIdT
name|handleNegotiate
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
block|{
name|auto
name|I
init|=
name|LocalFunctionIds
operator|.
name|find
argument_list|(
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|LocalFunctionIds
operator|.
name|end
argument_list|()
condition|)
return|return
name|getInvalidFunctionId
argument_list|()
return|;
return|return
name|I
operator|->
name|second
return|;
block|}
comment|// Find the remote FunctionId for the given function, which must be in the
comment|// RemoteFunctionIds map.
name|template
operator|<
name|typename
name|Func
operator|>
name|Expected
operator|<
name|FunctionIdT
operator|>
name|getRemoteFunctionId
argument_list|()
block|{
comment|// Try to find the id for the given function.
name|auto
name|I
operator|=
name|RemoteFunctionIds
operator|.
name|find
argument_list|(
name|Func
operator|::
name|getPrototype
argument_list|()
argument_list|)
block|;
comment|// If we have it in the map, return it.
if|if
condition|(
name|I
operator|!=
name|RemoteFunctionIds
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
return|;
comment|// Otherwise, if we have auto-negotiation enabled, try to negotiate it.
if|if
condition|(
name|LazyAutoNegotiation
condition|)
block|{
name|auto
operator|&
name|Impl
operator|=
name|static_cast
operator|<
name|ImplT
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
expr_stmt|;
if|if
condition|(
name|auto
name|RemoteIdOrErr
init|=
name|Impl
operator|.
name|template
name|callB
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
condition|)
block|{
name|auto
operator|&
name|RemoteId
operator|=
operator|*
name|RemoteIdOrErr
expr_stmt|;
comment|// If autonegotiation indicates that the remote end doesn't support this
comment|// function, return an unknown function error.
if|if
condition|(
name|RemoteId
operator|==
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
comment|// Autonegotiation succeeded and returned a valid id. Update the map and
comment|// return the id.
name|RemoteFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
name|RemoteId
expr_stmt|;
return|return
name|RemoteId
return|;
block|}
else|else
block|{
comment|// Autonegotiation failed. Return the error.
return|return
name|RemoteIdOrErr
operator|.
name|takeError
argument_list|()
return|;
block|}
block|}
comment|// No key was available in the map and autonegotiation wasn't enabled.
comment|// Return an unknown function error.
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|using
name|WrappedHandlerFn
init|=
name|std
operator|::
name|function
operator|<
name|Error
argument_list|(
name|ChannelT
operator|&
argument_list|,
name|SequenceNumberT
argument_list|)
operator|>
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Wrap the given user handler in the necessary argument-deserialization code,
end_comment

begin_comment
comment|// result-serialization code, and call to the launch policy (if present).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|>
name|WrappedHandlerFn
name|wrapHandler
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|LaunchPolicy Launch
argument_list|)
block|{
return|return
index|[
name|this
operator|,
name|Handler
operator|,
name|Launch
index|]
operator|(
name|ChannelT
operator|&
name|Channel
operator|,
name|SequenceNumberT
name|SeqNo
operator|)
name|mutable
operator|->
name|Error
block|{
comment|// Start by deserializing the arguments.
name|auto
name|Args
operator|=
name|std
operator|::
name|make_shared
operator|<
name|typename
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|ArgStorage
operator|>
operator|(
operator|)
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|typename
name|Func
operator|::
name|Type
operator|>
operator|::
name|deserializeArgs
argument_list|(
name|Channel
argument_list|,
operator|*
name|Args
argument_list|)
condition|)
return|return
name|Err
return|;
comment|// GCC 4.7 and 4.8 incorrectly issue a -Wunused-but-set-variable warning
comment|// for RPCArgs. Void cast RPCArgs to work around this for now.
comment|// FIXME: Remove this workaround once we can assume a working GCC version.
operator|(
name|void
operator|)
name|Args
return|;
end_expr_stmt

begin_comment
comment|// End receieve message, unlocking the channel for reading.
end_comment

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|Channel
operator|.
name|endReceiveMessage
argument_list|()
condition|)
return|return
name|Err
return|;
end_if

begin_comment
comment|// Build the handler/responder.
end_comment

begin_decl_stmt
name|auto
name|Responder
init|=
index|[
name|this
operator|,
name|Handler
operator|,
name|Args
operator|,
operator|&
name|Channel
operator|,
name|SeqNo
index|]
operator|(
operator|)
name|mutable
operator|->
name|Error
block|{
name|using
name|HTraits
operator|=
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
block|;
name|using
name|FuncReturn
operator|=
name|typename
name|Func
operator|::
name|ReturnType
block|;
return|return
name|detail
operator|::
name|respond
operator|<
name|FuncReturn
operator|>
operator|(
name|Channel
expr|,
name|ResponseId
expr|,
name|SeqNo
expr|,
name|HTraits
operator|::
name|unpackAndRun
argument_list|(
name|Handler
argument_list|,
operator|*
name|Args
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// If there is an explicit launch policy then use it to launch the
end_comment

begin_comment
comment|// handler.
end_comment

begin_if
if|if
condition|(
name|Launch
condition|)
return|return
name|Launch
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Responder
argument_list|)
argument_list|)
return|;
end_if

begin_comment
comment|// Otherwise run the handler on the listener thread.
end_comment

begin_return
return|return
name|Responder
argument_list|()
return|;
end_return

begin_expr_stmt
unit|};   }    ChannelT
operator|&
name|C
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|LazyAutoNegotiation
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RPCFunctionIdAllocator
operator|<
name|FunctionIdT
operator|>
name|FnIdAllocator
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FunctionIdT
name|ResponseId
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|FunctionIdT
operator|>
name|LocalFunctionIds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
specifier|const
name|char
operator|*
operator|,
name|FunctionIdT
operator|>
name|RemoteFunctionIds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|FunctionIdT
operator|,
name|WrappedHandlerFn
operator|>
name|Handlers
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|mutex
name|ResponsesMutex
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|detail
operator|::
name|SequenceNumberManager
operator|<
name|SequenceNumberT
operator|>
name|SequenceNumberMgr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|map
operator|<
name|SequenceNumberT
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|detail
operator|::
name|ResponseHandler
operator|<
name|ChannelT
operator|>>>
name|PendingResponses
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace detail
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|=
name|uint32_t
operator|,
name|typename
name|SequenceNumberT
operator|=
name|uint32_t
operator|>
name|class
name|MultiThreadedRPCEndpoint
operator|:
name|public
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|MultiThreadedRPCEndpoint
operator|<
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
operator|,
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
block|{
name|private
operator|:
name|using
name|BaseClass
operator|=
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|MultiThreadedRPCEndpoint
operator|<
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|,
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|;
name|public
operator|:
name|MultiThreadedRPCEndpoint
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
operator|:
name|BaseClass
argument_list|(
argument|C
argument_list|,
argument|LazyAutoNegotiation
argument_list|)
block|{}
comment|/// The LaunchPolicy type allows a launch policy to be specified when adding
comment|/// a function handler. See addHandler.
name|using
name|LaunchPolicy
operator|=
name|typename
name|BaseClass
operator|::
name|LaunchPolicy
block|;
comment|/// Add a handler for the given RPC function.
comment|/// This installs the given handler functor for the given RPC Function, and
comment|/// makes the RPC function available for negotiation/calling from the remote.
comment|///
comment|/// The optional LaunchPolicy argument can be used to control how the handler
comment|/// is run when called:
comment|///
comment|/// * If no LaunchPolicy is given, the handler code will be run on the RPC
comment|///   handler thread that is reading from the channel. This handler cannot
comment|///   make blocking RPC calls (since it would be blocking the thread used to
comment|///   get the result), but can make non-blocking calls.
comment|///
comment|/// * If a LaunchPolicy is given, the user's handler will be wrapped in a
comment|///   call to serialize and send the result, and the resulting functor (with
comment|///   type 'Error()' will be passed to the LaunchPolicy. The user can then
comment|///   choose to add the wrapped handler to a work queue, spawn a new thread,
comment|///   or anything else.
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandler
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|LaunchPolicy Launch = LaunchPolicy()
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|,
name|std
operator|::
name|move
argument_list|(
name|Launch
argument_list|)
operator|)
return|;
block|}
comment|/// Add a class-method as a handler.
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|,
argument|LaunchPolicy Launch = LaunchPolicy()
argument_list|)
block|{
name|addHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|,
name|Launch
operator|)
block|;   }
comment|/// Negotiate a function id for Func with the other end of the channel.
name|template
operator|<
name|typename
name|Func
operator|>
name|Error
name|negotiateFunction
argument_list|(
argument|bool Retry = false
argument_list|)
block|{
name|using
name|OrcRPCNegotiate
operator|=
name|typename
name|BaseClass
operator|::
name|OrcRPCNegotiate
block|;
comment|// Check if we already have a function id...
name|auto
name|I
operator|=
name|this
operator|->
name|RemoteFunctionIds
operator|.
name|find
argument_list|(
name|Func
operator|::
name|getPrototype
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|this
operator|->
name|RemoteFunctionIds
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// If it's valid there's nothing left to do.
if|if
condition|(
name|I
operator|->
name|second
operator|!=
name|this
operator|->
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
comment|// If it's invalid and we can't re-attempt negotiation, throw an error.
if|if
condition|(
operator|!
name|Retry
condition|)
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// We don't have a function id for Func yet, call the remote to try to
end_comment

begin_comment
comment|// negotiate one.
end_comment

begin_if
if|if
condition|(
name|auto
name|RemoteIdOrErr
init|=
name|callB
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
condition|)
block|{
name|this
operator|->
name|RemoteFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
operator|*
name|RemoteIdOrErr
expr_stmt|;
if|if
condition|(
operator|*
name|RemoteIdOrErr
operator|==
name|this
operator|->
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
else|else
return|return
name|RemoteIdOrErr
operator|.
name|takeError
argument_list|()
return|;
end_if

begin_comment
unit|}
comment|/// Return type for non-blocking call primitives.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|>
name|using
name|NonBlockingCallResult
operator|=
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|ReturnFutureType
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Call Func on Channel C. Does not block, does not call send. Returns a pair
end_comment

begin_comment
comment|/// of a future result and the sequence number assigned to the result.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This utility function is primarily used for single-threaded mode support,
end_comment

begin_comment
comment|/// where the sequence number can be used to wait for the corresponding
end_comment

begin_comment
comment|/// result. In multi-threaded mode the appendCallNB method, which does not
end_comment

begin_comment
comment|/// return the sequence numeber, should be preferred.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Expected
operator|<
name|NonBlockingCallResult
operator|<
name|Func
operator|>>
name|appendCallNB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|using
name|RTraits
operator|=
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
block|;
name|using
name|ErrorReturn
operator|=
name|typename
name|RTraits
operator|::
name|ErrorReturnType
block|;
name|using
name|ErrorReturnPromise
operator|=
name|typename
name|RTraits
operator|::
name|ReturnPromiseType
block|;
comment|// FIXME: Stack allocate and move this into the handler once LLVM builds
comment|//        with C++14.
name|auto
name|Promise
operator|=
name|std
operator|::
name|make_shared
operator|<
name|ErrorReturnPromise
operator|>
operator|(
operator|)
block|;
name|auto
name|FutureResult
operator|=
name|Promise
operator|->
name|get_future
argument_list|()
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
index|[
name|Promise
index|]
operator|(
name|ErrorReturn
name|RetOrErr
operator|)
block|{
name|Promise
operator|->
name|set_value
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RetOrErr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
operator|,
name|Args
operator|...
end_expr_stmt

begin_block
unit|))
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|RTraits
operator|::
name|consumeAbandoned
argument_list|(
name|FutureResult
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_block

begin_return
return|return
name|std
operator|::
name|move
argument_list|(
name|FutureResult
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// The same as appendCallNBWithSeq, except that it calls C.send() to
end_comment

begin_comment
comment|/// flush the channel after serializing the call.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Expected
operator|<
name|NonBlockingCallResult
operator|<
name|Func
operator|>>
name|callNB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|auto
name|Result
operator|=
name|appendCallNB
operator|<
name|Func
operator|>
operator|(
name|Args
operator|...
operator|)
block|;
if|if
condition|(
operator|!
name|Result
condition|)
return|return
name|Result
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|C
operator|.
name|send
argument_list|()
condition|)
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
operator|->
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_comment
unit|}
comment|/// Call Func on Channel C. Blocks waiting for a result. Returns an Error
end_comment

begin_comment
comment|/// for void functions or an Expected<T> for functions returning a T.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This function is for use in threaded code where another thread is
end_comment

begin_comment
comment|/// handling responses and incoming calls.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|,
name|typename
name|AltRetT
operator|=
name|typename
name|Func
operator|::
name|ReturnType
operator|>
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
name|callB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
if|if
condition|(
name|auto
name|FutureResOrErr
init|=
name|callNB
operator|<
name|Func
operator|>
operator|(
name|Args
operator|...
operator|)
condition|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|C
operator|.
name|send
argument_list|()
condition|)
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|FutureResOrErr
operator|->
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|FutureResOrErr
operator|->
name|get
argument_list|()
return|;
end_return

begin_return
unit|} else
return|return
name|FutureResOrErr
operator|.
name|takeError
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// Handle incoming RPC calls.
end_comment

begin_macro
unit|Error
name|handlerLoop
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|handleOne
argument_list|()
condition|)
return|return
name|Err
return|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_block

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|ChannelT
operator|,
name|typename
name|FunctionIdT
operator|=
name|uint32_t
operator|,
name|typename
name|SequenceNumberT
operator|=
name|uint32_t
operator|>
name|class
name|SingleThreadedRPCEndpoint
operator|:
name|public
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|SingleThreadedRPCEndpoint
operator|<
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
operator|,
name|ChannelT
operator|,
name|FunctionIdT
operator|,
name|SequenceNumberT
operator|>
block|{
name|private
operator|:
name|using
name|BaseClass
operator|=
name|detail
operator|::
name|RPCEndpointBase
operator|<
name|SingleThreadedRPCEndpoint
operator|<
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|,
name|ChannelT
block|,
name|FunctionIdT
block|,
name|SequenceNumberT
operator|>
block|;
name|using
name|LaunchPolicy
operator|=
name|typename
name|BaseClass
operator|::
name|LaunchPolicy
block|;
name|public
operator|:
name|SingleThreadedRPCEndpoint
argument_list|(
argument|ChannelT&C
argument_list|,
argument|bool LazyAutoNegotiation
argument_list|)
operator|:
name|BaseClass
argument_list|(
argument|C
argument_list|,
argument|LazyAutoNegotiation
argument_list|)
block|{}
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
operator|>
name|void
name|addHandler
argument_list|(
argument|HandlerT Handler
argument_list|)
block|{
return|return
name|this
operator|->
name|template
name|addHandlerImpl
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
operator|,
name|LaunchPolicy
argument_list|()
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|ClassT
operator|,
name|typename
name|RetT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|void
name|addHandler
argument_list|(
argument|ClassT&Object
argument_list|,
argument|RetT (ClassT::*Method)(ArgTs...)
argument_list|)
block|{
name|addHandler
operator|<
name|Func
operator|>
operator|(
name|detail
operator|::
name|MemberFnWrapper
operator|<
name|ClassT
operator|,
name|RetT
operator|,
name|ArgTs
operator|...
operator|>
operator|(
name|Object
operator|,
name|Method
operator|)
operator|)
block|;   }
comment|/// Negotiate a function id for Func with the other end of the channel.
name|template
operator|<
name|typename
name|Func
operator|>
name|Error
name|negotiateFunction
argument_list|(
argument|bool Retry = false
argument_list|)
block|{
name|using
name|OrcRPCNegotiate
operator|=
name|typename
name|BaseClass
operator|::
name|OrcRPCNegotiate
block|;
comment|// Check if we already have a function id...
name|auto
name|I
operator|=
name|this
operator|->
name|RemoteFunctionIds
operator|.
name|find
argument_list|(
name|Func
operator|::
name|getPrototype
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|this
operator|->
name|RemoteFunctionIds
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// If it's valid there's nothing left to do.
if|if
condition|(
name|I
operator|->
name|second
operator|!=
name|this
operator|->
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
comment|// If it's invalid and we can't re-attempt negotiation, throw an error.
if|if
condition|(
operator|!
name|Retry
condition|)
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// We don't have a function id for Func yet, call the remote to try to
end_comment

begin_comment
comment|// negotiate one.
end_comment

begin_if
if|if
condition|(
name|auto
name|RemoteIdOrErr
init|=
name|callB
operator|<
name|OrcRPCNegotiate
operator|>
operator|(
name|Func
operator|::
name|getPrototype
argument_list|()
operator|)
condition|)
block|{
name|this
operator|->
name|RemoteFunctionIds
index|[
name|Func
operator|::
name|getPrototype
argument_list|()
index|]
operator|=
operator|*
name|RemoteIdOrErr
expr_stmt|;
if|if
condition|(
operator|*
name|RemoteIdOrErr
operator|==
name|this
operator|->
name|getInvalidFunctionId
argument_list|()
condition|)
return|return
name|orcError
argument_list|(
name|OrcErrorCode
operator|::
name|UnknownRPCFunction
argument_list|)
return|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
else|else
return|return
name|RemoteIdOrErr
operator|.
name|takeError
argument_list|()
return|;
end_if

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|ArgTs
operator|,
name|typename
name|AltRetT
operator|=
name|typename
name|Func
operator|::
name|ReturnType
operator|>
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
name|callB
argument_list|(
argument|const ArgTs&... Args
argument_list|)
block|{
name|bool
name|ReceivedResponse
operator|=
name|false
block|;
name|using
name|ResultType
operator|=
name|typename
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|ErrorReturnType
block|;
name|auto
name|Result
operator|=
name|detail
operator|::
name|ResultTraits
operator|<
name|AltRetT
operator|>
operator|::
name|createBlankErrorReturnValue
argument_list|()
block|;
comment|// We have to 'Check' result (which we know is in a success state at this
comment|// point) so that it can be overwritten in the async handler.
operator|(
name|void
operator|)
operator|!
operator|!
name|Result
block|;
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
index|[
operator|&
index|]
operator|(
name|ResultType
name|R
operator|)
block|{
name|Result
operator|=
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|ReceivedResponse
operator|=
name|true
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
operator|,
name|Args
operator|...
end_expr_stmt

begin_block
unit|))
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
end_block

begin_while
while|while
condition|(
operator|!
name|ReceivedResponse
condition|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|this
operator|->
name|handleOne
argument_list|()
condition|)
block|{
name|this
operator|->
name|abandonPendingResponses
argument_list|()
expr_stmt|;
name|detail
operator|::
name|ResultTraits
operator|<
name|typename
name|Func
operator|::
name|ReturnType
operator|>
operator|::
name|consumeAbandoned
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|move
argument_list|(
name|Err
argument_list|)
return|;
block|}
block|}
end_while

begin_return
return|return
name|Result
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Allows a set of asynchrounous calls to be dispatched, and then
end_comment

begin_comment
comment|///        waited on as a group.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|RPCClass
operator|>
name|class
name|ParallelCallGroup
block|{
name|public
operator|:
comment|/// \brief Construct a parallel call group for the given RPC.
name|ParallelCallGroup
argument_list|(
name|RPCClass
operator|&
name|RPC
argument_list|)
operator|:
name|RPC
argument_list|(
name|RPC
argument_list|)
block|,
name|NumOutstandingCalls
argument_list|(
literal|0
argument_list|)
block|{}
name|ParallelCallGroup
argument_list|(
specifier|const
name|ParallelCallGroup
operator|&
argument_list|)
operator|=
name|delete
block|;
name|ParallelCallGroup
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ParallelCallGroup
operator|&
operator|)
operator|=
name|delete
block|;
comment|/// \brief Make as asynchronous call.
comment|///
comment|/// Does not issue a send call to the RPC's channel. The channel may use this
comment|/// to batch up subsequent calls. A send will automatically be sent when wait
comment|/// is called.
name|template
operator|<
name|typename
name|Func
block|,
name|typename
name|HandlerT
block|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|appendCall
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
comment|// Increment the count of outstanding calls. This has to happen before
comment|// we invoke the call, as the handler may (depending on scheduling)
comment|// be run immediately on another thread, and we don't want the decrement
comment|// in the wrapped handler below to run before the increment.
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
block|;
operator|++
name|NumOutstandingCalls
block|;     }
comment|// Wrap the user handler in a lambda that will decrement the
comment|// outstanding calls count, then poke the condition variable.
name|using
name|ArgType
operator|=
name|typename
name|detail
operator|::
name|ResponseHandlerArg
operator|<
name|typename
name|detail
operator|::
name|HandlerTraits
operator|<
name|HandlerT
operator|>
operator|::
name|Type
operator|>
operator|::
name|ArgType
block|;
comment|// FIXME: Move handler into wrapped handler once we have C++14.
name|auto
name|WrappedHandler
operator|=
index|[
name|this
operator|,
name|Handler
index|]
operator|(
name|ArgType
name|Arg
operator|)
block|{
name|auto
name|Err
operator|=
name|Handler
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
argument_list|)
argument_list|)
block|;
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
block|;
operator|--
name|NumOutstandingCalls
block|;
name|CV
operator|.
name|notify_all
argument_list|()
block|;
return|return
name|Err
return|;
block|}
block|;
return|return
name|RPC
operator|.
name|template
name|appendCallAsync
operator|<
name|Func
operator|>
operator|(
name|std
operator|::
name|move
argument_list|(
name|WrappedHandler
argument_list|)
operator|,
name|Args
operator|...
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Make an asynchronous call.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The same as appendCall, but also calls send on the channel immediately.
end_comment

begin_comment
comment|/// Prefer appendCall if you are about to issue a "wait" call shortly, as
end_comment

begin_comment
comment|/// this may allow the channel to better batch the calls.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
name|HandlerT
operator|,
name|typename
operator|...
name|ArgTs
operator|>
name|Error
name|call
argument_list|(
argument|HandlerT Handler
argument_list|,
argument|const ArgTs&... Args
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|appendCall
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Handler
argument_list|)
argument_list|,
name|Args
operator|...
argument_list|)
condition|)
return|return
name|Err
return|;
end_expr_stmt

begin_return
return|return
name|RPC
operator|.
name|sendAppendedCalls
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// \brief Blocks until all calls have been completed and their return value
end_comment

begin_comment
comment|///        handlers run.
end_comment

begin_macro
unit|Error
name|wait
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|RPC
operator|.
name|sendAppendedCalls
argument_list|()
condition|)
return|return
name|Err
return|;
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|Lock
argument_list|(
name|M
argument_list|)
expr_stmt|;
while|while
condition|(
name|NumOutstandingCalls
operator|>
literal|0
condition|)
name|CV
operator|.
name|wait
argument_list|(
name|Lock
argument_list|)
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|RPCClass
modifier|&
name|RPC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|mutex
name|M
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|condition_variable
name|CV
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint32_t
name|NumOutstandingCalls
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// @brief Convenience class for grouping RPC Functions into APIs that can be
end_comment

begin_comment
comment|///        negotiated as a block.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
block|{
name|public
operator|:
comment|/// @brief Test whether this API contains Function F.
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;   }
block|;
comment|/// @brief Negotiate all functions in this API.
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Func
operator|,
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
operator|<
name|Func
operator|,
name|Funcs
operator|...
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|std
operator|::
name|is_same
operator|<
name|F
block|,
name|Func
operator|>
operator|::
name|value
operator||
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
block|;   }
block|;
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|R
operator|.
name|template
name|negotiateFunction
operator|<
name|Func
operator|>
operator|(
operator|)
condition|)
return|return
name|Err
return|;
return|return
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
operator|...
name|InnerFuncs
operator|,
name|typename
operator|...
name|Funcs
operator|>
name|class
name|APICalls
operator|<
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|,
name|Funcs
operator|...
operator|>
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|Contains
block|{
name|public
operator|:
specifier|static
specifier|const
name|bool
name|value
operator|=
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
operator||
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|template
name|Contains
operator|<
name|F
operator|>
operator|::
name|value
block|;   }
block|;
name|template
operator|<
name|typename
name|RPCEndpoint
operator|>
specifier|static
name|Error
name|negotiate
argument_list|(
argument|RPCEndpoint&R
argument_list|)
block|{
if|if
condition|(
name|auto
name|Err
init|=
name|APICalls
operator|<
name|InnerFuncs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
condition|)
return|return
name|Err
return|;
return|return
name|APICalls
operator|<
name|Funcs
operator|...
operator|>
operator|::
name|negotiate
argument_list|(
name|R
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace rpc
end_comment

begin_comment
unit|}
comment|// end namespace orc
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

