begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=-- SampleProf.h - Sampling profiling format support --------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains common definitions used in the reading and writing of
end_comment

begin_comment
comment|// sample profile data.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_SAMPLEPROF_H_
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_SAMPLEPROF_H_
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorOr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
specifier|const
name|std
operator|::
name|error_category
operator|&
name|sampleprof_category
argument_list|()
expr_stmt|;
name|enum
name|class
name|sampleprof_error
block|{
name|success
operator|=
literal|0
operator|,
name|bad_magic
operator|,
name|unsupported_version
operator|,
name|too_large
operator|,
name|truncated
operator|,
name|malformed
operator|,
name|unrecognized_format
operator|,
name|unsupported_writing_format
operator|,
name|truncated_name_table
operator|,
name|not_implemented
operator|,
name|counter_overflow
block|}
empty_stmt|;
specifier|inline
name|std
operator|::
name|error_code
name|make_error_code
argument_list|(
argument|sampleprof_error E
argument_list|)
block|{
return|return
name|std
operator|::
name|error_code
argument_list|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|E
operator|)
argument_list|,
name|sampleprof_category
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|sampleprof_error
name|MergeResult
parameter_list|(
name|sampleprof_error
modifier|&
name|Accumulator
parameter_list|,
name|sampleprof_error
name|Result
parameter_list|)
block|{
comment|// Prefer first error encountered as later errors may be secondary effects of
comment|// the initial problem.
if|if
condition|(
name|Accumulator
operator|==
name|sampleprof_error
operator|::
name|success
operator|&&
name|Result
operator|!=
name|sampleprof_error
operator|::
name|success
condition|)
name|Accumulator
operator|=
name|Result
expr_stmt|;
return|return
name|Accumulator
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_decl_stmt
name|namespace
name|std
block|{
name|template
operator|<
operator|>
expr|struct
name|is_error_code_enum
operator|<
name|llvm
operator|::
name|sampleprof_error
operator|>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|sampleprof
block|{
specifier|static
specifier|inline
name|uint64_t
name|SPMagic
parameter_list|()
block|{
return|return
name|uint64_t
argument_list|(
literal|'S'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|8
operator|)
operator||
name|uint64_t
argument_list|(
literal|'P'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|16
operator|)
operator||
name|uint64_t
argument_list|(
literal|'R'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|24
operator|)
operator||
name|uint64_t
argument_list|(
literal|'O'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|32
operator|)
operator||
name|uint64_t
argument_list|(
literal|'F'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|40
operator|)
operator||
name|uint64_t
argument_list|(
literal|'4'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|48
operator|)
operator||
name|uint64_t
argument_list|(
literal|'2'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|56
operator|)
operator||
name|uint64_t
argument_list|(
literal|0xff
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|SPVersion
parameter_list|()
block|{
return|return
literal|102
return|;
block|}
comment|/// Represents the relative location of an instruction.
comment|///
comment|/// Instruction locations are specified by the line offset from the
comment|/// beginning of the function (marked by the line where the function
comment|/// header is) and the discriminator value within that line.
comment|///
comment|/// The discriminator value is useful to distinguish instructions
comment|/// that are on the same line but belong to different basic blocks
comment|/// (e.g., the two post-increment instructions in "if (p) x++; else y++;").
struct|struct
name|LineLocation
block|{
name|LineLocation
argument_list|(
argument|uint32_t L
argument_list|,
argument|uint32_t D
argument_list|)
block|:
name|LineOffset
argument_list|(
name|L
argument_list|)
operator|,
name|Discriminator
argument_list|(
argument|D
argument_list|)
block|{}
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|LineLocation
operator|&
name|O
operator|)
specifier|const
block|{
return|return
name|LineOffset
operator|<
name|O
operator|.
name|LineOffset
operator|||
operator|(
name|LineOffset
operator|==
name|O
operator|.
name|LineOffset
operator|&&
name|Discriminator
operator|<
name|O
operator|.
name|Discriminator
operator|)
return|;
block|}
name|uint32_t
name|LineOffset
decl_stmt|;
name|uint32_t
name|Discriminator
decl_stmt|;
block|}
struct|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|LineLocation
operator|&
name|Loc
operator|)
expr_stmt|;
comment|/// Represents the relative location of a callsite.
comment|///
comment|/// Callsite locations are specified by the line offset from the
comment|/// beginning of the function (marked by the line where the function
comment|/// head is), the discriminator value within that line, and the callee
comment|/// function name.
name|struct
name|CallsiteLocation
range|:
name|public
name|LineLocation
block|{
name|CallsiteLocation
argument_list|(
argument|uint32_t L
argument_list|,
argument|uint32_t D
argument_list|,
argument|StringRef N
argument_list|)
operator|:
name|LineLocation
argument_list|(
name|L
argument_list|,
name|D
argument_list|)
block|,
name|CalleeName
argument_list|(
argument|N
argument_list|)
block|{}
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
name|StringRef
name|CalleeName
block|; }
decl_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|CallsiteLocation
operator|&
name|Loc
operator|)
expr_stmt|;
comment|/// Representation of a single sample record.
comment|///
comment|/// A sample record is represented by a positive integer value, which
comment|/// indicates how frequently was the associated line location executed.
comment|///
comment|/// Additionally, if the associated location contains a function call,
comment|/// the record will hold a list of all the possible called targets. For
comment|/// direct calls, this will be the exact function being invoked. For
comment|/// indirect calls (function pointers, virtual table dispatch), this
comment|/// will be a list of one or more functions.
name|class
name|SampleRecord
block|{
name|public
label|:
typedef|typedef
name|StringMap
operator|<
name|uint64_t
operator|>
name|CallTargetMap
expr_stmt|;
name|SampleRecord
argument_list|()
operator|:
name|NumSamples
argument_list|(
literal|0
argument_list|)
operator|,
name|CallTargets
argument_list|()
block|{}
comment|/// Increment the number of samples for this record by \p S.
comment|/// Optionally scale sample count \p S by \p Weight.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|sampleprof_error
name|addSamples
argument_list|(
argument|uint64_t S
argument_list|,
argument|uint64_t Weight =
literal|1
argument_list|)
block|{
name|bool
name|Overflowed
block|;
name|NumSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|S
argument_list|,
name|Weight
argument_list|,
name|NumSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
block|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
comment|/// Add called function \p F with samples \p S.
comment|/// Optionally scale sample count \p S by \p Weight.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|sampleprof_error
name|addCalledTarget
parameter_list|(
name|StringRef
name|F
parameter_list|,
name|uint64_t
name|S
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|uint64_t
modifier|&
name|TargetSamples
init|=
name|CallTargets
index|[
name|F
index|]
decl_stmt|;
name|bool
name|Overflowed
decl_stmt|;
name|TargetSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|S
argument_list|,
name|Weight
argument_list|,
name|TargetSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
comment|/// Return true if this sample record contains function calls.
name|bool
name|hasCalls
argument_list|()
specifier|const
block|{
return|return
name|CallTargets
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
name|uint64_t
name|getSamples
argument_list|()
specifier|const
block|{
return|return
name|NumSamples
return|;
block|}
specifier|const
name|CallTargetMap
operator|&
name|getCallTargets
argument_list|()
specifier|const
block|{
return|return
name|CallTargets
return|;
block|}
comment|/// Merge the samples in \p Other into this record.
comment|/// Optionally scale sample counts by \p Weight.
name|sampleprof_error
name|merge
parameter_list|(
specifier|const
name|SampleRecord
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|sampleprof_error
name|Result
init|=
name|addSamples
argument_list|(
name|Other
operator|.
name|getSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getCallTargets
argument_list|()
control|)
block|{
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addCalledTarget
argument_list|(
name|I
operator|.
name|first
argument_list|()
argument_list|,
name|I
operator|.
name|second
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Result
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|Indent
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|uint64_t
name|NumSamples
decl_stmt|;
name|CallTargetMap
name|CallTargets
decl_stmt|;
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|SampleRecord
operator|&
name|Sample
operator|)
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|LineLocation
operator|,
name|SampleRecord
operator|>
name|BodySampleMap
expr_stmt|;
name|class
name|FunctionSamples
decl_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|CallsiteLocation
operator|,
name|FunctionSamples
operator|>
name|CallsiteSampleMap
expr_stmt|;
comment|/// Representation of the samples collected for a function.
comment|///
comment|/// This data structure contains all the collected samples for the body
comment|/// of a function. Each sample corresponds to a LineLocation instance
comment|/// within the body of the function.
name|class
name|FunctionSamples
block|{
name|public
label|:
name|FunctionSamples
argument_list|()
operator|:
name|TotalSamples
argument_list|(
literal|0
argument_list|)
operator|,
name|TotalHeadSamples
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|print
argument_list|(
argument|raw_ostream&OS = dbgs()
argument_list|,
argument|unsigned Indent =
literal|0
argument_list|)
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|sampleprof_error
name|addTotalSamples
parameter_list|(
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|bool
name|Overflowed
decl_stmt|;
name|TotalSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|,
name|TotalSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
name|sampleprof_error
name|addHeadSamples
parameter_list|(
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|bool
name|Overflowed
decl_stmt|;
name|TotalHeadSamples
operator|=
name|SaturatingMultiplyAdd
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|,
name|TotalHeadSamples
argument_list|,
operator|&
name|Overflowed
argument_list|)
expr_stmt|;
return|return
name|Overflowed
condition|?
name|sampleprof_error
operator|::
name|counter_overflow
else|:
name|sampleprof_error
operator|::
name|success
return|;
block|}
name|sampleprof_error
name|addBodySamples
parameter_list|(
name|uint32_t
name|LineOffset
parameter_list|,
name|uint32_t
name|Discriminator
parameter_list|,
name|uint64_t
name|Num
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
return|return
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addSamples
argument_list|(
name|Num
argument_list|,
name|Weight
argument_list|)
return|;
block|}
name|sampleprof_error
name|addCalledTargetSamples
argument_list|(
name|uint32_t
name|LineOffset
argument_list|,
name|uint32_t
name|Discriminator
argument_list|,
name|std
operator|::
name|string
name|FName
argument_list|,
name|uint64_t
name|Num
argument_list|,
name|uint64_t
name|Weight
operator|=
literal|1
argument_list|)
block|{
return|return
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addCalledTarget
argument_list|(
name|FName
argument_list|,
name|Num
argument_list|,
name|Weight
argument_list|)
return|;
block|}
comment|/// Return the number of samples collected at the given location.
comment|/// Each location is specified by \p LineOffset and \p Discriminator.
comment|/// If the location is not found in profile, return error.
name|ErrorOr
operator|<
name|uint64_t
operator|>
name|findSamplesAt
argument_list|(
argument|uint32_t LineOffset
argument_list|,
argument|uint32_t Discriminator
argument_list|)
specifier|const
block|{
specifier|const
name|auto
operator|&
name|ret
operator|=
name|BodySamples
operator|.
name|find
argument_list|(
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|ret
operator|==
name|BodySamples
operator|.
name|end
argument_list|()
condition|)
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
else|else
return|return
name|ret
operator|->
name|second
operator|.
name|getSamples
argument_list|()
return|;
block|}
comment|/// Return the function samples at the given callsite location.
name|FunctionSamples
modifier|&
name|functionSamplesAt
parameter_list|(
specifier|const
name|CallsiteLocation
modifier|&
name|Loc
parameter_list|)
block|{
return|return
name|CallsiteSamples
index|[
name|Loc
index|]
return|;
block|}
comment|/// Return a pointer to function samples at the given callsite location.
specifier|const
name|FunctionSamples
modifier|*
name|findFunctionSamplesAt
argument_list|(
specifier|const
name|CallsiteLocation
operator|&
name|Loc
argument_list|)
decl|const
block|{
name|auto
name|iter
init|=
name|CallsiteSamples
operator|.
name|find
argument_list|(
name|Loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|CallsiteSamples
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|nullptr
return|;
block|}
else|else
block|{
return|return
operator|&
name|iter
operator|->
name|second
return|;
block|}
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|TotalSamples
operator|==
literal|0
return|;
block|}
comment|/// Return the total number of samples collected inside the function.
name|uint64_t
name|getTotalSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalSamples
return|;
block|}
comment|/// Return the total number of samples collected at the head of the
comment|/// function.
name|uint64_t
name|getHeadSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalHeadSamples
return|;
block|}
comment|/// Return all the samples collected in the body of the function.
specifier|const
name|BodySampleMap
operator|&
name|getBodySamples
argument_list|()
specifier|const
block|{
return|return
name|BodySamples
return|;
block|}
comment|/// Return all the callsite samples collected in the body of the function.
specifier|const
name|CallsiteSampleMap
operator|&
name|getCallsiteSamples
argument_list|()
specifier|const
block|{
return|return
name|CallsiteSamples
return|;
block|}
comment|/// Merge the samples in \p Other into this one.
comment|/// Optionally scale samples by \p Weight.
name|sampleprof_error
name|merge
parameter_list|(
specifier|const
name|FunctionSamples
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
block|{
name|sampleprof_error
name|Result
init|=
name|sampleprof_error
operator|::
name|success
decl_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addTotalSamples
argument_list|(
name|Other
operator|.
name|getTotalSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|addHeadSamples
argument_list|(
name|Other
operator|.
name|getHeadSamples
argument_list|()
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getBodySamples
argument_list|()
control|)
block|{
specifier|const
name|LineLocation
modifier|&
name|Loc
init|=
name|I
operator|.
name|first
decl_stmt|;
specifier|const
name|SampleRecord
modifier|&
name|Rec
init|=
name|I
operator|.
name|second
decl_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|BodySamples
index|[
name|Loc
index|]
operator|.
name|merge
argument_list|(
name|Rec
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getCallsiteSamples
argument_list|()
control|)
block|{
specifier|const
name|CallsiteLocation
modifier|&
name|Loc
init|=
name|I
operator|.
name|first
decl_stmt|;
specifier|const
name|FunctionSamples
modifier|&
name|Rec
init|=
name|I
operator|.
name|second
decl_stmt|;
name|MergeResult
argument_list|(
name|Result
argument_list|,
name|functionSamplesAt
argument_list|(
name|Loc
argument_list|)
operator|.
name|merge
argument_list|(
name|Rec
argument_list|,
name|Weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Result
return|;
block|}
name|private
label|:
comment|/// Total number of samples collected inside this function.
comment|///
comment|/// Samples are cumulative, they include all the samples collected
comment|/// inside this function and all its inlined callees.
name|uint64_t
name|TotalSamples
decl_stmt|;
comment|/// Total number of samples collected at the head of the function.
comment|/// This is an approximation of the number of calls made to this function
comment|/// at runtime.
name|uint64_t
name|TotalHeadSamples
decl_stmt|;
comment|/// Map instruction locations to collected samples.
comment|///
comment|/// Each entry in this map contains the number of samples
comment|/// collected at the corresponding line offset. All line locations
comment|/// are an offset from the start of the function.
name|BodySampleMap
name|BodySamples
decl_stmt|;
comment|/// Map call sites to collected samples for the called function.
comment|///
comment|/// Each entry in this map corresponds to all the samples
comment|/// collected for the inlined function call at the given
comment|/// location. For example, given:
comment|///
comment|///     void foo() {
comment|///  1    bar();
comment|///  ...
comment|///  8    baz();
comment|///     }
comment|///
comment|/// If the bar() and baz() calls were inlined inside foo(), this
comment|/// map will contain two entries.  One for all the samples collected
comment|/// in the call to bar() at line offset 1, the other for all the samples
comment|/// collected in the call to baz() at line offset 8.
name|CallsiteSampleMap
name|CallsiteSamples
decl_stmt|;
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|FunctionSamples
operator|&
name|FS
operator|)
expr_stmt|;
comment|/// Sort a LocationT->SampleT map by LocationT.
comment|///
comment|/// It produces a sorted list of<LocationT, SampleT> records by ascending
comment|/// order of LocationT.
name|template
operator|<
name|class
name|LocationT
operator|,
name|class
name|SampleT
operator|>
name|class
name|SampleSorter
block|{
name|public
operator|:
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|LocationT
operator|,
name|SampleT
operator|>
name|SamplesWithLoc
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|SamplesWithLoc
operator|*
operator|,
literal|20
operator|>
name|SamplesWithLocList
expr_stmt|;
name|SampleSorter
argument_list|(
argument|const std::map<LocationT
argument_list|,
argument|SampleT>&Samples
argument_list|)
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Samples
control|)
name|V
operator|.
name|push_back
argument_list|(
operator|&
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|stable_sort
argument_list|(
name|V
operator|.
name|begin
argument_list|()
argument_list|,
name|V
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
specifier|const
name|SamplesWithLoc
operator|*
name|A
operator|,
specifier|const
name|SamplesWithLoc
operator|*
name|B
operator|)
block|{
return|return
name|A
operator|->
name|first
operator|<
name|B
operator|->
name|first
return|;
block|}
block|)
empty_stmt|;
block|}
specifier|const
name|SamplesWithLocList
operator|&
name|get
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|private
label|:
name|SamplesWithLocList
name|V
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace sampleprof
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_SAMPLEPROF_H_
end_comment

end_unit

