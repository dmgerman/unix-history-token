begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=-- SampleProf.h - Sampling profiling format support --------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains common definitions used in the reading and writing of
end_comment

begin_comment
comment|// sample profile data.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_SAMPLEPROF_H_
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_SAMPLEPROF_H_
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
specifier|const
name|std
operator|::
name|error_category
operator|&
name|sampleprof_category
argument_list|()
expr_stmt|;
name|enum
name|class
name|sampleprof_error
block|{
name|success
operator|=
literal|0
operator|,
name|bad_magic
operator|,
name|unsupported_version
operator|,
name|too_large
operator|,
name|truncated
operator|,
name|malformed
operator|,
name|unrecognized_format
block|}
empty_stmt|;
specifier|inline
name|std
operator|::
name|error_code
name|make_error_code
argument_list|(
argument|sampleprof_error E
argument_list|)
block|{
return|return
name|std
operator|::
name|error_code
argument_list|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|E
operator|)
argument_list|,
name|sampleprof_category
argument_list|()
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_decl_stmt
name|namespace
name|std
block|{
name|template
operator|<
operator|>
expr|struct
name|is_error_code_enum
operator|<
name|llvm
operator|::
name|sampleprof_error
operator|>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|sampleprof
block|{
specifier|static
specifier|inline
name|uint64_t
name|SPMagic
parameter_list|()
block|{
return|return
name|uint64_t
argument_list|(
literal|'S'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|8
operator|)
operator||
name|uint64_t
argument_list|(
literal|'P'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|16
operator|)
operator||
name|uint64_t
argument_list|(
literal|'R'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|24
operator|)
operator||
name|uint64_t
argument_list|(
literal|'O'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|32
operator|)
operator||
name|uint64_t
argument_list|(
literal|'F'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|40
operator|)
operator||
name|uint64_t
argument_list|(
literal|'4'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|48
operator|)
operator||
name|uint64_t
argument_list|(
literal|'2'
argument_list|)
operator|<<
operator|(
literal|64
operator|-
literal|56
operator|)
operator||
name|uint64_t
argument_list|(
literal|0xff
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|SPVersion
parameter_list|()
block|{
return|return
literal|100
return|;
block|}
comment|/// Represents the relative location of an instruction.
comment|///
comment|/// Instruction locations are specified by the line offset from the
comment|/// beginning of the function (marked by the line where the function
comment|/// header is) and the discriminator value within that line.
comment|///
comment|/// The discriminator value is useful to distinguish instructions
comment|/// that are on the same line but belong to different basic blocks
comment|/// (e.g., the two post-increment instructions in "if (p) x++; else y++;").
struct|struct
name|LineLocation
block|{
name|LineLocation
argument_list|(
argument|int L
argument_list|,
argument|unsigned D
argument_list|)
block|:
name|LineOffset
argument_list|(
name|L
argument_list|)
operator|,
name|Discriminator
argument_list|(
argument|D
argument_list|)
block|{}
name|int
name|LineOffset
expr_stmt|;
name|unsigned
name|Discriminator
decl_stmt|;
block|}
struct|;
block|}
comment|// End namespace sampleprof
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|sampleprof
operator|::
name|LineLocation
operator|>
block|{
typedef|typedef
name|DenseMapInfo
operator|<
name|int
operator|>
name|OffsetInfo
expr_stmt|;
typedef|typedef
name|DenseMapInfo
operator|<
name|unsigned
operator|>
name|DiscriminatorInfo
expr_stmt|;
specifier|static
specifier|inline
name|sampleprof
operator|::
name|LineLocation
name|getEmptyKey
argument_list|()
block|{
return|return
name|sampleprof
operator|::
name|LineLocation
argument_list|(
name|OffsetInfo
operator|::
name|getEmptyKey
argument_list|()
argument_list|,
name|DiscriminatorInfo
operator|::
name|getEmptyKey
argument_list|()
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|sampleprof
operator|::
name|LineLocation
name|getTombstoneKey
argument_list|()
block|{
return|return
name|sampleprof
operator|::
name|LineLocation
argument_list|(
name|OffsetInfo
operator|::
name|getTombstoneKey
argument_list|()
argument_list|,
name|DiscriminatorInfo
operator|::
name|getTombstoneKey
argument_list|()
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getHashValue
argument_list|(
name|sampleprof
operator|::
name|LineLocation
name|Val
argument_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|std
operator|::
name|pair
operator|<
name|int
operator|,
name|unsigned
operator|>>
operator|::
name|getHashValue
argument_list|(
name|std
operator|::
name|pair
operator|<
name|int
argument_list|,
name|unsigned
operator|>
operator|(
name|Val
operator|.
name|LineOffset
operator|,
name|Val
operator|.
name|Discriminator
operator|)
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isEqual
argument_list|(
name|sampleprof
operator|::
name|LineLocation
name|LHS
argument_list|,
name|sampleprof
operator|::
name|LineLocation
name|RHS
argument_list|)
block|{
return|return
name|LHS
operator|.
name|LineOffset
operator|==
name|RHS
operator|.
name|LineOffset
operator|&&
name|LHS
operator|.
name|Discriminator
operator|==
name|RHS
operator|.
name|Discriminator
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|namespace
name|sampleprof
block|{
comment|/// Representation of a single sample record.
comment|///
comment|/// A sample record is represented by a positive integer value, which
comment|/// indicates how frequently was the associated line location executed.
comment|///
comment|/// Additionally, if the associated location contains a function call,
comment|/// the record will hold a list of all the possible called targets. For
comment|/// direct calls, this will be the exact function being invoked. For
comment|/// indirect calls (function pointers, virtual table dispatch), this
comment|/// will be a list of one or more functions.
name|class
name|SampleRecord
block|{
name|public
label|:
typedef|typedef
name|StringMap
operator|<
name|unsigned
operator|>
name|CallTargetMap
expr_stmt|;
name|SampleRecord
argument_list|()
operator|:
name|NumSamples
argument_list|(
literal|0
argument_list|)
operator|,
name|CallTargets
argument_list|()
block|{}
comment|/// Increment the number of samples for this record by \p S.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|void
name|addSamples
argument_list|(
argument|unsigned S
argument_list|)
block|{
if|if
condition|(
name|NumSamples
operator|<=
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
argument_list|()
operator|-
name|S
condition|)
name|NumSamples
operator|+=
name|S
expr_stmt|;
else|else
name|NumSamples
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
comment|/// Add called function \p F with samples \p S.
comment|///
comment|/// Sample counts accumulate using saturating arithmetic, to avoid wrapping
comment|/// around unsigned integers.
name|void
name|addCalledTarget
parameter_list|(
name|StringRef
name|F
parameter_list|,
name|unsigned
name|S
parameter_list|)
block|{
name|unsigned
modifier|&
name|TargetSamples
init|=
name|CallTargets
index|[
name|F
index|]
decl_stmt|;
if|if
condition|(
name|TargetSamples
operator|<=
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
argument_list|()
operator|-
name|S
condition|)
name|TargetSamples
operator|+=
name|S
expr_stmt|;
else|else
name|TargetSamples
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
comment|/// Return true if this sample record contains function calls.
name|bool
name|hasCalls
argument_list|()
specifier|const
block|{
return|return
name|CallTargets
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
name|unsigned
name|getSamples
argument_list|()
specifier|const
block|{
return|return
name|NumSamples
return|;
block|}
specifier|const
name|CallTargetMap
operator|&
name|getCallTargets
argument_list|()
specifier|const
block|{
return|return
name|CallTargets
return|;
block|}
comment|/// Merge the samples in \p Other into this record.
name|void
name|merge
parameter_list|(
specifier|const
name|SampleRecord
modifier|&
name|Other
parameter_list|)
block|{
name|addSamples
argument_list|(
name|Other
operator|.
name|getSamples
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getCallTargets
argument_list|()
control|)
name|addCalledTarget
argument_list|(
name|I
operator|.
name|first
argument_list|()
argument_list|,
name|I
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|unsigned
name|NumSamples
decl_stmt|;
name|CallTargetMap
name|CallTargets
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|LineLocation
operator|,
name|SampleRecord
operator|>
name|BodySampleMap
expr_stmt|;
comment|/// Representation of the samples collected for a function.
comment|///
comment|/// This data structure contains all the collected samples for the body
comment|/// of a function. Each sample corresponds to a LineLocation instance
comment|/// within the body of the function.
name|class
name|FunctionSamples
block|{
name|public
label|:
name|FunctionSamples
argument_list|()
operator|:
name|TotalSamples
argument_list|(
literal|0
argument_list|)
operator|,
name|TotalHeadSamples
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
operator|=
name|dbgs
argument_list|()
argument_list|)
expr_stmt|;
name|void
name|addTotalSamples
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|TotalSamples
operator|+=
name|Num
expr_stmt|;
block|}
name|void
name|addHeadSamples
parameter_list|(
name|unsigned
name|Num
parameter_list|)
block|{
name|TotalHeadSamples
operator|+=
name|Num
expr_stmt|;
block|}
name|void
name|addBodySamples
parameter_list|(
name|int
name|LineOffset
parameter_list|,
name|unsigned
name|Discriminator
parameter_list|,
name|unsigned
name|Num
parameter_list|)
block|{
name|assert
argument_list|(
name|LineOffset
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// When dealing with instruction weights, we use the value
comment|// zero to indicate the absence of a sample. If we read an
comment|// actual zero from the profile file, use the value 1 to
comment|// avoid the confusion later on.
if|if
condition|(
name|Num
operator|==
literal|0
condition|)
name|Num
operator|=
literal|1
expr_stmt|;
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addSamples
argument_list|(
name|Num
argument_list|)
expr_stmt|;
block|}
name|void
name|addCalledTargetSamples
argument_list|(
name|int
name|LineOffset
argument_list|,
name|unsigned
name|Discriminator
argument_list|,
name|std
operator|::
name|string
name|FName
argument_list|,
name|unsigned
name|Num
argument_list|)
block|{
name|assert
argument_list|(
name|LineOffset
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|BodySamples
index|[
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
index|]
operator|.
name|addCalledTarget
argument_list|(
name|FName
argument_list|,
name|Num
argument_list|)
expr_stmt|;
block|}
comment|/// Return the sample record at the given location.
comment|/// Each location is specified by \p LineOffset and \p Discriminator.
name|SampleRecord
modifier|&
name|sampleRecordAt
parameter_list|(
specifier|const
name|LineLocation
modifier|&
name|Loc
parameter_list|)
block|{
return|return
name|BodySamples
index|[
name|Loc
index|]
return|;
block|}
comment|/// Return the number of samples collected at the given location.
comment|/// Each location is specified by \p LineOffset and \p Discriminator.
name|unsigned
name|samplesAt
parameter_list|(
name|int
name|LineOffset
parameter_list|,
name|unsigned
name|Discriminator
parameter_list|)
block|{
return|return
name|sampleRecordAt
argument_list|(
name|LineLocation
argument_list|(
name|LineOffset
argument_list|,
name|Discriminator
argument_list|)
argument_list|)
operator|.
name|getSamples
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|BodySamples
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// Return the total number of samples collected inside the function.
name|unsigned
name|getTotalSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalSamples
return|;
block|}
comment|/// Return the total number of samples collected at the head of the
comment|/// function.
name|unsigned
name|getHeadSamples
argument_list|()
specifier|const
block|{
return|return
name|TotalHeadSamples
return|;
block|}
comment|/// Return all the samples collected in the body of the function.
specifier|const
name|BodySampleMap
operator|&
name|getBodySamples
argument_list|()
specifier|const
block|{
return|return
name|BodySamples
return|;
block|}
comment|/// Merge the samples in \p Other into this one.
name|void
name|merge
parameter_list|(
specifier|const
name|FunctionSamples
modifier|&
name|Other
parameter_list|)
block|{
name|addTotalSamples
argument_list|(
name|Other
operator|.
name|getTotalSamples
argument_list|()
argument_list|)
expr_stmt|;
name|addHeadSamples
argument_list|(
name|Other
operator|.
name|getHeadSamples
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|I
range|:
name|Other
operator|.
name|getBodySamples
argument_list|()
control|)
block|{
specifier|const
name|LineLocation
modifier|&
name|Loc
init|=
name|I
operator|.
name|first
decl_stmt|;
specifier|const
name|SampleRecord
modifier|&
name|Rec
init|=
name|I
operator|.
name|second
decl_stmt|;
name|sampleRecordAt
argument_list|(
name|Loc
argument_list|)
operator|.
name|merge
argument_list|(
name|Rec
argument_list|)
expr_stmt|;
block|}
block|}
name|private
label|:
comment|/// Total number of samples collected inside this function.
comment|///
comment|/// Samples are cumulative, they include all the samples collected
comment|/// inside this function and all its inlined callees.
name|unsigned
name|TotalSamples
decl_stmt|;
comment|/// Total number of samples collected at the head of the function.
comment|/// This is an approximation of the number of calls made to this function
comment|/// at runtime.
name|unsigned
name|TotalHeadSamples
decl_stmt|;
comment|/// Map instruction locations to collected samples.
comment|///
comment|/// Each entry in this map contains the number of samples
comment|/// collected at the corresponding line offset. All line locations
comment|/// are an offset from the start of the function.
name|BodySampleMap
name|BodySamples
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End namespace sampleprof
end_comment

begin_comment
unit|}
comment|// End namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_SAMPLEPROF_H_
end_comment

end_unit

