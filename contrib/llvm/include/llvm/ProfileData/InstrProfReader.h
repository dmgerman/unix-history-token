begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- InstrProfReader.h - Instrumented profiling readers -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains support for reading profiling data for instrumentation
end_comment

begin_comment
comment|// based PGO and coverage.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_INSTRPROFREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_INSTRPROFREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ProfileSummary.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/LineIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/OnDiskHashTable.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SwapByteOrder.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|InstrProfReader
decl_stmt|;
comment|/// A file format agnostic iterator over profiling data.
name|class
name|InstrProfIterator
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|input_iterator_tag
decl_stmt|,
name|InstrProfRecord
decl|>
block|{
name|InstrProfReader
modifier|*
name|Reader
init|=
name|nullptr
decl_stmt|;
name|InstrProfRecord
name|Record
decl_stmt|;
name|void
name|Increment
parameter_list|()
function_decl|;
name|public
label|:
name|InstrProfIterator
argument_list|()
operator|=
expr|default
expr_stmt|;
name|InstrProfIterator
argument_list|(
name|InstrProfReader
operator|*
name|Reader
argument_list|)
operator|:
name|Reader
argument_list|(
argument|Reader
argument_list|)
block|{
name|Increment
argument_list|()
block|; }
name|InstrProfIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|Increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|InstrProfIterator
operator|&
name|RHS
operator|)
block|{
return|return
name|Reader
operator|==
name|RHS
operator|.
name|Reader
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|InstrProfIterator
operator|&
name|RHS
operator|)
block|{
return|return
name|Reader
operator|!=
name|RHS
operator|.
name|Reader
return|;
block|}
name|InstrProfRecord
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
name|Record
return|;
block|}
name|InstrProfRecord
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
operator|&
name|Record
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Base class and interface for reading profiling data of any known instrprof
end_comment

begin_comment
comment|/// format. Provides an iterator over InstrProfRecords.
end_comment

begin_decl_stmt
name|class
name|InstrProfReader
block|{
name|instrprof_error
name|LastError
init|=
name|instrprof_error
operator|::
name|success
decl_stmt|;
name|public
label|:
name|InstrProfReader
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
operator|~
name|InstrProfReader
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|/// Read the header.  Required before reading first record.
name|virtual
name|Error
name|readHeader
parameter_list|()
init|=
literal|0
function_decl|;
comment|/// Read a single record.
name|virtual
name|Error
name|readNextRecord
parameter_list|(
name|InstrProfRecord
modifier|&
name|Record
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// Iterator over profile data.
name|InstrProfIterator
name|begin
parameter_list|()
block|{
return|return
name|InstrProfIterator
argument_list|(
name|this
argument_list|)
return|;
block|}
name|InstrProfIterator
name|end
parameter_list|()
block|{
return|return
name|InstrProfIterator
argument_list|()
return|;
block|}
name|virtual
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// Return the PGO symtab. There are three different readers:
comment|/// Raw, Text, and Indexed profile readers. The first two types
comment|/// of readers are used only by llvm-profdata tool, while the indexed
comment|/// profile reader is also used by llvm-cov tool and the compiler (
comment|/// backend or frontend). Since creating PGO symtab can create
comment|/// significant runtime and memory overhead (as it touches data
comment|/// for the whole program), InstrProfSymtab for the indexed profile
comment|/// reader should be created on demand and it is recommended to be
comment|/// only used for dumping purpose with llvm-proftool, not with the
comment|/// compiler.
name|virtual
name|InstrProfSymtab
modifier|&
name|getSymtab
parameter_list|()
init|=
literal|0
function_decl|;
name|protected
label|:
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfSymtab
operator|>
name|Symtab
expr_stmt|;
comment|/// Set the current error and return same.
name|Error
name|error
parameter_list|(
name|instrprof_error
name|Err
parameter_list|)
block|{
name|LastError
operator|=
name|Err
expr_stmt|;
if|if
condition|(
name|Err
operator|==
name|instrprof_error
operator|::
name|success
condition|)
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
return|return
name|make_error
operator|<
name|InstrProfError
operator|>
operator|(
name|Err
operator|)
return|;
block|}
name|Error
name|error
parameter_list|(
name|Error
name|E
parameter_list|)
block|{
return|return
name|error
argument_list|(
name|InstrProfError
operator|::
name|take
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|E
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// Clear the current error and return a successful one.
name|Error
name|success
parameter_list|()
block|{
return|return
name|error
argument_list|(
name|instrprof_error
operator|::
name|success
argument_list|)
return|;
block|}
name|public
label|:
comment|/// Return true if the reader has finished reading the profile data.
name|bool
name|isEOF
parameter_list|()
block|{
return|return
name|LastError
operator|==
name|instrprof_error
operator|::
name|eof
return|;
block|}
comment|/// Return true if the reader encountered an error reading profiling data.
name|bool
name|hasError
parameter_list|()
block|{
return|return
name|LastError
operator|!=
name|instrprof_error
operator|::
name|success
operator|&&
operator|!
name|isEOF
argument_list|()
return|;
block|}
comment|/// Get the current error.
name|Error
name|getError
parameter_list|()
block|{
if|if
condition|(
name|hasError
argument_list|()
condition|)
return|return
name|make_error
operator|<
name|InstrProfError
operator|>
operator|(
name|LastError
operator|)
return|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
comment|/// Factory method to create an appropriately typed reader for the given
comment|/// instrprof file.
specifier|static
name|Expected
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReader
operator|>>
name|create
argument_list|(
specifier|const
name|Twine
operator|&
name|Path
argument_list|)
expr_stmt|;
specifier|static
name|Expected
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReader
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|Buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Reader for the simple text based instrprof format.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This format is a simple text format that's suitable for test data. Records
end_comment

begin_comment
comment|/// are separated by one or more blank lines, and record fields are separated by
end_comment

begin_comment
comment|/// new lines.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Each record consists of a function name, a function hash, a number of
end_comment

begin_comment
comment|/// counters, and then each counter value, in that order.
end_comment

begin_decl_stmt
name|class
name|TextInstrProfReader
range|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
comment|/// Iterator over the profile data.
name|line_iterator
name|Line
block|;
name|bool
name|IsIRLevelProfile
operator|=
name|false
block|;
name|Error
name|readValueProfileData
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
block|;
name|public
operator|:
name|TextInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer_
argument_list|)
operator|:
name|DataBuffer
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|DataBuffer_
argument_list|)
argument_list|)
block|,
name|Line
argument_list|(
argument|*DataBuffer
argument_list|,
argument|true
argument_list|,
literal|'#'
argument_list|)
block|{}
name|TextInstrProfReader
argument_list|(
specifier|const
name|TextInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|TextInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TextInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
comment|/// Return true if the given buffer is in text instrprof format.
specifier|static
name|bool
name|hasFormat
argument_list|(
specifier|const
name|MemoryBuffer
operator|&
name|Buffer
argument_list|)
block|;
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
name|override
block|{
return|return
name|IsIRLevelProfile
return|;
block|}
comment|/// Read the header.
name|Error
name|readHeader
argument_list|()
name|override
block|;
comment|/// Read a single record.
name|Error
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|;
name|InstrProfSymtab
operator|&
name|getSymtab
argument_list|()
name|override
block|{
name|assert
argument_list|(
name|Symtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|Symtab
operator|.
name|get
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// Reader for the raw instrprof binary format from runtime.
comment|///
comment|/// This format is a raw memory dump of the instrumentation-baed profiling data
comment|/// from the runtime.  It has no index.
comment|///
comment|/// Templated on the unsigned type whose size matches pointers on the platform
comment|/// that wrote the profile.
name|template
operator|<
name|class
name|IntPtrT
operator|>
name|class
name|RawInstrProfReader
operator|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
name|bool
name|ShouldSwapBytes
block|;
comment|// The value of the version field of the raw profile data header. The lower 56
comment|// bits specifies the format version and the most significant 8 bits specify
comment|// the variant types of the profile.
name|uint64_t
name|Version
block|;
name|uint64_t
name|CountersDelta
block|;
name|uint64_t
name|NamesDelta
block|;
specifier|const
name|RawInstrProf
operator|::
name|ProfileData
operator|<
name|IntPtrT
operator|>
operator|*
name|Data
block|;
specifier|const
name|RawInstrProf
operator|::
name|ProfileData
operator|<
name|IntPtrT
operator|>
operator|*
name|DataEnd
block|;
specifier|const
name|uint64_t
operator|*
name|CountersStart
block|;
specifier|const
name|char
operator|*
name|NamesStart
block|;
name|uint64_t
name|NamesSize
block|;
comment|// After value profile is all read, this pointer points to
comment|// the header of next profile data (if exists)
specifier|const
name|uint8_t
operator|*
name|ValueDataStart
block|;
name|uint32_t
name|ValueKindLast
block|;
name|uint32_t
name|CurValueDataSize
block|;
name|InstrProfRecord
operator|::
name|ValueMapType
name|FunctionPtrToNameMap
block|;
name|public
operator|:
name|RawInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
argument_list|)
operator|:
name|DataBuffer
argument_list|(
argument|std::move(DataBuffer)
argument_list|)
block|{ }
name|RawInstrProfReader
argument_list|(
specifier|const
name|RawInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|RawInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|RawInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|hasFormat
argument_list|(
specifier|const
name|MemoryBuffer
operator|&
name|DataBuffer
argument_list|)
block|;
name|Error
name|readHeader
argument_list|()
name|override
block|;
name|Error
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|;
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
name|override
block|{
return|return
operator|(
name|Version
operator|&
name|VARIANT_MASK_IR_PROF
operator|)
operator|!=
literal|0
return|;
block|}
name|InstrProfSymtab
operator|&
name|getSymtab
argument_list|()
name|override
block|{
name|assert
argument_list|(
name|Symtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|Symtab
operator|.
name|get
argument_list|()
return|;
block|}
name|private
operator|:
name|Error
name|createSymtab
argument_list|(
name|InstrProfSymtab
operator|&
name|Symtab
argument_list|)
block|;
name|Error
name|readNextHeader
argument_list|(
specifier|const
name|char
operator|*
name|CurrentPos
argument_list|)
block|;
name|Error
name|readHeader
argument_list|(
specifier|const
name|RawInstrProf
operator|::
name|Header
operator|&
name|Header
argument_list|)
block|;
name|template
operator|<
name|class
name|IntT
operator|>
name|IntT
name|swap
argument_list|(
argument|IntT Int
argument_list|)
specifier|const
block|{
return|return
name|ShouldSwapBytes
operator|?
name|sys
operator|::
name|getSwappedBytes
argument_list|(
name|Int
argument_list|)
operator|:
name|Int
return|;
block|}
name|support
operator|::
name|endianness
name|getDataEndianness
argument_list|()
specifier|const
block|{
name|support
operator|::
name|endianness
name|HostEndian
operator|=
name|getHostEndianness
argument_list|()
block|;
if|if
condition|(
operator|!
name|ShouldSwapBytes
condition|)
return|return
name|HostEndian
return|;
if|if
condition|(
name|HostEndian
operator|==
name|support
operator|::
name|little
condition|)
return|return
name|support
operator|::
name|big
return|;
else|else
return|return
name|support
operator|::
name|little
return|;
block|}
specifier|inline
name|uint8_t
name|getNumPaddingBytes
argument_list|(
argument|uint64_t SizeInBytes
argument_list|)
block|{
return|return
literal|7
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
name|SizeInBytes
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
return|;
block|}
name|Error
name|readName
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
block|;
name|Error
name|readFuncHash
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
block|;
name|Error
name|readRawCounts
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
block|;
name|Error
name|readValueProfilingData
argument_list|(
name|InstrProfRecord
operator|&
name|Record
argument_list|)
block|;
name|bool
name|atEnd
argument_list|()
specifier|const
block|{
return|return
name|Data
operator|==
name|DataEnd
return|;
block|}
name|void
name|advanceData
argument_list|()
block|{
name|Data
operator|++
block|;
name|ValueDataStart
operator|+=
name|CurValueDataSize
block|;   }
specifier|const
name|char
operator|*
name|getNextHeaderPos
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|atEnd
argument_list|()
argument_list|)
block|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|ValueDataStart
return|;
block|}
specifier|const
name|uint64_t
operator|*
name|getCounter
argument_list|(
argument|IntPtrT CounterPtr
argument_list|)
specifier|const
block|{
name|ptrdiff_t
name|Offset
operator|=
operator|(
name|swap
argument_list|(
name|CounterPtr
argument_list|)
operator|-
name|CountersDelta
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|;
return|return
name|CountersStart
operator|+
name|Offset
return|;
block|}
name|StringRef
name|getName
argument_list|(
argument|uint64_t NameRef
argument_list|)
specifier|const
block|{
return|return
name|Symtab
operator|->
name|getFuncName
argument_list|(
name|swap
argument_list|(
name|NameRef
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
typedef|typedef
name|RawInstrProfReader
operator|<
name|uint32_t
operator|>
name|RawInstrProfReader32
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|RawInstrProfReader
operator|<
name|uint64_t
operator|>
name|RawInstrProfReader64
expr_stmt|;
end_typedef

begin_decl_stmt
name|namespace
name|IndexedInstrProf
block|{
name|enum
name|class
name|HashT
range|:
name|uint32_t
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace IndexedInstrProf
end_comment

begin_comment
comment|/// Trait for lookups into the on-disk hash table for the binary instrprof
end_comment

begin_comment
comment|/// format.
end_comment

begin_decl_stmt
name|class
name|InstrProfLookupTrait
block|{
name|std
operator|::
name|vector
operator|<
name|InstrProfRecord
operator|>
name|DataBuffer
expr_stmt|;
name|IndexedInstrProf
operator|::
name|HashT
name|HashType
expr_stmt|;
name|unsigned
name|FormatVersion
decl_stmt|;
comment|// Endianness of the input value profile data.
comment|// It should be LE by default, but can be changed
comment|// for testing purpose.
name|support
operator|::
name|endianness
name|ValueProfDataEndianness
operator|=
name|support
operator|::
name|little
expr_stmt|;
name|public
label|:
name|InstrProfLookupTrait
argument_list|(
argument|IndexedInstrProf::HashT HashType
argument_list|,
argument|unsigned FormatVersion
argument_list|)
block|:
name|HashType
argument_list|(
name|HashType
argument_list|)
operator|,
name|FormatVersion
argument_list|(
argument|FormatVersion
argument_list|)
block|{}
typedef|typedef
name|ArrayRef
operator|<
name|InstrProfRecord
operator|>
name|data_type
expr_stmt|;
typedef|typedef
name|StringRef
name|internal_key_type
typedef|;
typedef|typedef
name|StringRef
name|external_key_type
typedef|;
typedef|typedef
name|uint64_t
name|hash_value_type
typedef|;
typedef|typedef
name|uint64_t
name|offset_type
typedef|;
specifier|static
name|bool
name|EqualKey
parameter_list|(
name|StringRef
name|A
parameter_list|,
name|StringRef
name|B
parameter_list|)
block|{
return|return
name|A
operator|==
name|B
return|;
block|}
specifier|static
name|StringRef
name|GetInternalKey
parameter_list|(
name|StringRef
name|K
parameter_list|)
block|{
return|return
name|K
return|;
block|}
specifier|static
name|StringRef
name|GetExternalKey
parameter_list|(
name|StringRef
name|K
parameter_list|)
block|{
return|return
name|K
return|;
block|}
name|hash_value_type
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
function_decl|;
specifier|static
name|std
operator|::
name|pair
operator|<
name|offset_type
operator|,
name|offset_type
operator|>
name|ReadKeyDataLength
argument_list|(
argument|const unsigned char *&D
argument_list|)
block|{
name|using
name|namespace
name|support
block|;
name|offset_type
name|KeyLen
operator|=
name|endian
operator|::
name|readNext
operator|<
name|offset_type
block|,
name|little
block|,
name|unaligned
operator|>
operator|(
name|D
operator|)
block|;
name|offset_type
name|DataLen
operator|=
name|endian
operator|::
name|readNext
operator|<
name|offset_type
block|,
name|little
block|,
name|unaligned
operator|>
operator|(
name|D
operator|)
block|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|KeyLen
argument_list|,
name|DataLen
argument_list|)
return|;
block|}
name|StringRef
name|ReadKey
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|D
parameter_list|,
name|offset_type
name|N
parameter_list|)
block|{
return|return
name|StringRef
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|D
argument_list|,
name|N
argument_list|)
return|;
block|}
name|bool
name|readValueProfilingData
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|&
name|D
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
specifier|const
name|End
parameter_list|)
function_decl|;
name|data_type
name|ReadData
parameter_list|(
name|StringRef
name|K
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|D
parameter_list|,
name|offset_type
name|N
parameter_list|)
function_decl|;
comment|// Used for testing purpose only.
name|void
name|setValueProfDataEndianness
argument_list|(
name|support
operator|::
name|endianness
name|Endianness
argument_list|)
block|{
name|ValueProfDataEndianness
operator|=
name|Endianness
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|InstrProfReaderIndexBase
block|{
name|virtual
operator|~
name|InstrProfReaderIndexBase
argument_list|()
operator|=
expr|default
expr_stmt|;
comment|// Read all the profile records with the same key pointed to the current
comment|// iterator.
name|virtual
name|Error
name|getRecords
argument_list|(
name|ArrayRef
operator|<
name|InstrProfRecord
operator|>
operator|&
name|Data
argument_list|)
init|=
literal|0
decl_stmt|;
comment|// Read all the profile records with the key equal to FuncName
name|virtual
name|Error
name|getRecords
argument_list|(
name|StringRef
name|FuncName
argument_list|,
name|ArrayRef
operator|<
name|InstrProfRecord
operator|>
operator|&
name|Data
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|advanceToNextKey
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|atEnd
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|void
name|setValueProfDataEndianness
argument_list|(
name|support
operator|::
name|endianness
name|Endianness
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|uint64_t
name|getVersion
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|void
name|populateSymtab
parameter_list|(
name|InstrProfSymtab
modifier|&
parameter_list|)
init|=
literal|0
function_decl|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|OnDiskIterableChainedHashTable
operator|<
name|InstrProfLookupTrait
operator|>
name|OnDiskHashTableImplV3
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|HashTableImpl
operator|>
name|class
name|InstrProfReaderIndex
operator|:
name|public
name|InstrProfReaderIndexBase
block|{
name|private
operator|:
name|std
operator|::
name|unique_ptr
operator|<
name|HashTableImpl
operator|>
name|HashTable
block|;
name|typename
name|HashTableImpl
operator|::
name|data_iterator
name|RecordIterator
block|;
name|uint64_t
name|FormatVersion
block|;
name|public
operator|:
name|InstrProfReaderIndex
argument_list|(
argument|const unsigned char *Buckets
argument_list|,
argument|const unsigned char *const Payload
argument_list|,
argument|const unsigned char *const Base
argument_list|,
argument|IndexedInstrProf::HashT HashType
argument_list|,
argument|uint64_t Version
argument_list|)
block|;
operator|~
name|InstrProfReaderIndex
argument_list|()
name|override
operator|=
expr|default
block|;
name|Error
name|getRecords
argument_list|(
argument|ArrayRef<InstrProfRecord>&Data
argument_list|)
name|override
block|;
name|Error
name|getRecords
argument_list|(
argument|StringRef FuncName
argument_list|,
argument|ArrayRef<InstrProfRecord>&Data
argument_list|)
name|override
block|;
name|void
name|advanceToNextKey
argument_list|()
name|override
block|{
name|RecordIterator
operator|++
block|; }
name|bool
name|atEnd
argument_list|()
specifier|const
name|override
block|{
return|return
name|RecordIterator
operator|==
name|HashTable
operator|->
name|data_end
argument_list|()
return|;
block|}
name|void
name|setValueProfDataEndianness
argument_list|(
argument|support::endianness Endianness
argument_list|)
name|override
block|{
name|HashTable
operator|->
name|getInfoObj
argument_list|()
operator|.
name|setValueProfDataEndianness
argument_list|(
name|Endianness
argument_list|)
block|;   }
name|uint64_t
name|getVersion
argument_list|()
specifier|const
name|override
block|{
return|return
name|GET_VERSION
argument_list|(
name|FormatVersion
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
name|override
block|{
return|return
operator|(
name|FormatVersion
operator|&
name|VARIANT_MASK_IR_PROF
operator|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_function
name|void
name|populateSymtab
parameter_list|(
name|InstrProfSymtab
modifier|&
name|Symtab
parameter_list|)
function|override
block|{
name|Symtab
operator|.
name|create
argument_list|(
name|HashTable
operator|->
name|keys
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Reader for the indexed binary instrprof format.
end_comment

begin_decl_stmt
name|class
name|IndexedInstrProfReader
range|:
name|public
name|InstrProfReader
block|{
name|private
operator|:
comment|/// The profile data file contents.
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
block|;
comment|/// The index into the profile data.
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfReaderIndexBase
operator|>
name|Index
block|;
comment|/// Profile summary data.
name|std
operator|::
name|unique_ptr
operator|<
name|ProfileSummary
operator|>
name|Summary
block|;
comment|// Read the profile summary. Return a pointer pointing to one byte past the
comment|// end of the summary data if it exists or the input \c Cur.
specifier|const
name|unsigned
name|char
operator|*
name|readSummary
argument_list|(
argument|IndexedInstrProf::ProfVersion Version
argument_list|,
argument|const unsigned char *Cur
argument_list|)
block|;
name|public
operator|:
name|IndexedInstrProfReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|DataBuffer
argument_list|)
operator|:
name|DataBuffer
argument_list|(
argument|std::move(DataBuffer)
argument_list|)
block|{}
name|IndexedInstrProfReader
argument_list|(
specifier|const
name|IndexedInstrProfReader
operator|&
argument_list|)
operator|=
name|delete
block|;
name|IndexedInstrProfReader
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IndexedInstrProfReader
operator|&
operator|)
operator|=
name|delete
block|;
comment|/// Return the profile version.
name|uint64_t
name|getVersion
argument_list|()
specifier|const
block|{
return|return
name|Index
operator|->
name|getVersion
argument_list|()
return|;
block|}
name|bool
name|isIRLevelProfile
argument_list|()
specifier|const
name|override
block|{
return|return
name|Index
operator|->
name|isIRLevelProfile
argument_list|()
return|;
block|}
comment|/// Return true if the given buffer is in an indexed instrprof format.
specifier|static
name|bool
name|hasFormat
argument_list|(
specifier|const
name|MemoryBuffer
operator|&
name|DataBuffer
argument_list|)
block|;
comment|/// Read the file header.
name|Error
name|readHeader
argument_list|()
name|override
block|;
comment|/// Read a single record.
name|Error
name|readNextRecord
argument_list|(
argument|InstrProfRecord&Record
argument_list|)
name|override
block|;
comment|/// Return the pointer to InstrProfRecord associated with FuncName
comment|/// and FuncHash
name|Expected
operator|<
name|InstrProfRecord
operator|>
name|getInstrProfRecord
argument_list|(
argument|StringRef FuncName
argument_list|,
argument|uint64_t FuncHash
argument_list|)
block|;
comment|/// Fill Counts with the profile data for the given function name.
name|Error
name|getFunctionCounts
argument_list|(
argument|StringRef FuncName
argument_list|,
argument|uint64_t FuncHash
argument_list|,
argument|std::vector<uint64_t>&Counts
argument_list|)
block|;
comment|/// Return the maximum of all known function counts.
name|uint64_t
name|getMaximumFunctionCount
argument_list|()
block|{
return|return
name|Summary
operator|->
name|getMaxFunctionCount
argument_list|()
return|;
block|}
comment|/// Factory method to create an indexed reader.
specifier|static
name|Expected
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|IndexedInstrProfReader
operator|>>
name|create
argument_list|(
specifier|const
name|Twine
operator|&
name|Path
argument_list|)
block|;
specifier|static
name|Expected
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|IndexedInstrProfReader
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|Buffer
argument_list|)
block|;
comment|// Used for testing purpose only.
name|void
name|setValueProfDataEndianness
argument_list|(
argument|support::endianness Endianness
argument_list|)
block|{
name|Index
operator|->
name|setValueProfDataEndianness
argument_list|(
name|Endianness
argument_list|)
block|;   }
comment|// See description in the base class. This interface is designed
comment|// to be used by llvm-profdata (for dumping). Avoid using this when
comment|// the client is the compiler.
name|InstrProfSymtab
operator|&
name|getSymtab
argument_list|()
name|override
block|;
name|ProfileSummary
operator|&
name|getSummary
argument_list|()
block|{
return|return
operator|*
operator|(
name|Summary
operator|.
name|get
argument_list|()
operator|)
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_INSTRPROFREADER_H
end_comment

end_unit

