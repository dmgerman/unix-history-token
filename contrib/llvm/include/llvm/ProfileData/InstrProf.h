begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=-- InstrProf.h - Instrumented profiling format support ---------*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Instrumentation-based profiling data is generated by instrumented
end_comment

begin_comment
comment|// binaries through library functions in compiler-rt, and read by the clang
end_comment

begin_comment
comment|// frontend to feed PGO.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_PROFILEDATA_INSTRPROF_H_
end_ifndef

begin_define
define|#
directive|define
name|LLVM_PROFILEDATA_INSTRPROF_H_
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorOr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MD5.h"
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<system_error>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Function
decl_stmt|;
name|class
name|GlobalVariable
decl_stmt|;
name|class
name|Module
decl_stmt|;
comment|/// Return the name of data section containing profile counter variables.
specifier|inline
name|StringRef
name|getInstrProfCountersSectionName
parameter_list|(
name|bool
name|AddSegment
parameter_list|)
block|{
return|return
name|AddSegment
condition|?
literal|"__DATA,"
name|INSTR_PROF_CNTS_SECT_NAME_STR
else|:
name|INSTR_PROF_CNTS_SECT_NAME_STR
return|;
block|}
comment|/// Return the name of data section containing names of instrumented
comment|/// functions.
specifier|inline
name|StringRef
name|getInstrProfNameSectionName
parameter_list|(
name|bool
name|AddSegment
parameter_list|)
block|{
return|return
name|AddSegment
condition|?
literal|"__DATA,"
name|INSTR_PROF_NAME_SECT_NAME_STR
else|:
name|INSTR_PROF_NAME_SECT_NAME_STR
return|;
block|}
comment|/// Return the name of the data section containing per-function control
comment|/// data.
specifier|inline
name|StringRef
name|getInstrProfDataSectionName
parameter_list|(
name|bool
name|AddSegment
parameter_list|)
block|{
return|return
name|AddSegment
condition|?
literal|"__DATA,"
name|INSTR_PROF_DATA_SECT_NAME_STR
else|:
name|INSTR_PROF_DATA_SECT_NAME_STR
return|;
block|}
comment|/// Return the name profile runtime entry point to do value profiling
comment|/// for a given site.
specifier|inline
name|StringRef
name|getInstrProfValueProfFuncName
parameter_list|()
block|{
return|return
name|INSTR_PROF_VALUE_PROF_FUNC_STR
return|;
block|}
comment|/// Return the name of the section containing function coverage mapping
comment|/// data.
specifier|inline
name|StringRef
name|getInstrProfCoverageSectionName
parameter_list|(
name|bool
name|AddSegment
parameter_list|)
block|{
return|return
name|AddSegment
condition|?
literal|"__DATA,"
name|INSTR_PROF_COVMAP_SECT_NAME_STR
else|:
name|INSTR_PROF_COVMAP_SECT_NAME_STR
return|;
block|}
comment|/// Return the name prefix of variables containing instrumented function names.
specifier|inline
name|StringRef
name|getInstrProfNameVarPrefix
parameter_list|()
block|{
return|return
literal|"__profn_"
return|;
block|}
comment|/// Return the name prefix of variables containing per-function control data.
specifier|inline
name|StringRef
name|getInstrProfDataVarPrefix
parameter_list|()
block|{
return|return
literal|"__profd_"
return|;
block|}
comment|/// Return the name prefix of profile counter variables.
specifier|inline
name|StringRef
name|getInstrProfCountersVarPrefix
parameter_list|()
block|{
return|return
literal|"__profc_"
return|;
block|}
comment|/// Return the name prefix of the COMDAT group for instrumentation variables
comment|/// associated with a COMDAT function.
specifier|inline
name|StringRef
name|getInstrProfComdatPrefix
parameter_list|()
block|{
return|return
literal|"__profv_"
return|;
block|}
comment|/// Return the name of a covarage mapping variable (internal linkage)
comment|/// for each instrumented source module. Such variables are allocated
comment|/// in the __llvm_covmap section.
specifier|inline
name|StringRef
name|getCoverageMappingVarName
parameter_list|()
block|{
return|return
literal|"__llvm_coverage_mapping"
return|;
block|}
comment|/// Return the name of the internal variable recording the array
comment|/// of PGO name vars referenced by the coverage mapping, The owning
comment|/// functions of those names are not emitted by FE (e.g, unused inline
comment|/// functions.)
specifier|inline
name|StringRef
name|getCoverageNamesVarName
parameter_list|()
block|{
return|return
literal|"__llvm_coverage_names"
return|;
block|}
comment|/// Return the name of function that registers all the per-function control
comment|/// data at program startup time by calling __llvm_register_function. This
comment|/// function has internal linkage and is called by  __llvm_profile_init
comment|/// runtime method. This function is not generated for these platforms:
comment|/// Darwin, Linux, and FreeBSD.
specifier|inline
name|StringRef
name|getInstrProfRegFuncsName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_register_functions"
return|;
block|}
comment|/// Return the name of the runtime interface that registers per-function control
comment|/// data for one instrumented function.
specifier|inline
name|StringRef
name|getInstrProfRegFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_register_function"
return|;
block|}
comment|/// Return the name of the runtime initialization method that is generated by
comment|/// the compiler. The function calls __llvm_profile_register_functions and
comment|/// __llvm_profile_override_default_filename functions if needed. This function
comment|/// has internal linkage and invoked at startup time via init_array.
specifier|inline
name|StringRef
name|getInstrProfInitFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_init"
return|;
block|}
comment|/// Return the name of the hook variable defined in profile runtime library.
comment|/// A reference to the variable causes the linker to link in the runtime
comment|/// initialization module (which defines the hook variable).
specifier|inline
name|StringRef
name|getInstrProfRuntimeHookVarName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_runtime"
return|;
block|}
comment|/// Return the name of the compiler generated function that references the
comment|/// runtime hook variable. The function is a weak global.
specifier|inline
name|StringRef
name|getInstrProfRuntimeHookVarUseFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_runtime_user"
return|;
block|}
comment|/// Return the name of the profile runtime interface that overrides the default
comment|/// profile data file name.
specifier|inline
name|StringRef
name|getInstrProfFileOverriderFuncName
parameter_list|()
block|{
return|return
literal|"__llvm_profile_override_default_filename"
return|;
block|}
comment|/// Return the modified name for function \c F suitable to be
comment|/// used the key for profile lookup.
name|std
operator|::
name|string
name|getPGOFuncName
argument_list|(
argument|const Function&F
argument_list|,
argument|uint64_t Version = INSTR_PROF_INDEX_VERSION
argument_list|)
expr_stmt|;
comment|/// Return the modified name for a function suitable to be
comment|/// used the key for profile lookup. The function's original
comment|/// name is \c RawFuncName and has linkage of type \c Linkage.
comment|/// The function is defined in module \c FileName.
name|std
operator|::
name|string
name|getPGOFuncName
argument_list|(
argument|StringRef RawFuncName
argument_list|,
argument|GlobalValue::LinkageTypes Linkage
argument_list|,
argument|StringRef FileName
argument_list|,
argument|uint64_t Version = INSTR_PROF_INDEX_VERSION
argument_list|)
expr_stmt|;
comment|/// Create and return the global variable for function name used in PGO
comment|/// instrumentation. \c FuncName is the name of the function returned
comment|/// by \c getPGOFuncName call.
name|GlobalVariable
modifier|*
name|createPGOFuncNameVar
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|,
name|StringRef
name|FuncName
parameter_list|)
function_decl|;
comment|/// Create and return the global variable for function name used in PGO
comment|/// instrumentation.  /// \c FuncName is the name of the function
comment|/// returned by \c getPGOFuncName call, \c M is the owning module,
comment|/// and \c Linkage is the linkage of the instrumented function.
name|GlobalVariable
modifier|*
name|createPGOFuncNameVar
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|GlobalValue
operator|::
name|LinkageTypes
name|Linkage
argument_list|,
name|StringRef
name|FuncName
argument_list|)
decl_stmt|;
comment|/// Return the initializer in string of the PGO name var \c NameVar.
name|StringRef
name|getPGOFuncNameVarInitializer
parameter_list|(
name|GlobalVariable
modifier|*
name|NameVar
parameter_list|)
function_decl|;
comment|/// Given a PGO function name, remove the filename prefix and return
comment|/// the original (static) function name.
name|StringRef
name|getFuncNameWithoutPrefix
parameter_list|(
name|StringRef
name|PGOFuncName
parameter_list|,
name|StringRef
name|FileName
parameter_list|)
function_decl|;
comment|/// Given a vector of strings (function PGO names) \c NameStrs, the
comment|/// method generates a combined string \c Result thatis ready to be
comment|/// serialized.  The \c Result string is comprised of three fields:
comment|/// The first field is the legnth of the uncompressed strings, and the
comment|/// the second field is the length of the zlib-compressed string.
comment|/// Both fields are encoded in ULEB128.  If \c doCompress is false, the
comment|///  third field is the uncompressed strings; otherwise it is the
comment|/// compressed string. When the string compression is off, the
comment|/// second field will have value zero.
name|int
name|collectPGOFuncNameStrings
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|NameStrs
argument_list|,
name|bool
name|doCompression
argument_list|,
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
comment|/// Produce \c Result string with the same format described above. The input
comment|/// is vector of PGO function name variables that are referenced.
name|int
name|collectPGOFuncNameStrings
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|GlobalVariable
operator|*
operator|>
operator|&
name|NameVars
argument_list|,
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
name|class
name|InstrProfSymtab
decl_stmt|;
comment|/// \c NameStrings is a string composed of one of more sub-strings encoded in
comment|/// the
comment|/// format described above. The substrings are seperated by 0 or more zero
comment|/// bytes.
comment|/// This method decodes the string and populates the \c Symtab.
name|int
name|readPGOFuncNameStrings
parameter_list|(
name|StringRef
name|NameStrings
parameter_list|,
name|InstrProfSymtab
modifier|&
name|Symtab
parameter_list|)
function_decl|;
specifier|const
name|std
operator|::
name|error_category
operator|&
name|instrprof_category
argument_list|()
expr_stmt|;
name|enum
name|class
name|instrprof_error
block|{
name|success
operator|=
literal|0
operator|,
name|eof
operator|,
name|unrecognized_format
operator|,
name|bad_magic
operator|,
name|bad_header
operator|,
name|unsupported_version
operator|,
name|unsupported_hash_type
operator|,
name|too_large
operator|,
name|truncated
operator|,
name|malformed
operator|,
name|unknown_function
operator|,
name|hash_mismatch
operator|,
name|count_mismatch
operator|,
name|counter_overflow
operator|,
name|value_site_count_mismatch
block|}
empty_stmt|;
specifier|inline
name|std
operator|::
name|error_code
name|make_error_code
argument_list|(
argument|instrprof_error E
argument_list|)
block|{
return|return
name|std
operator|::
name|error_code
argument_list|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|E
operator|)
argument_list|,
name|instrprof_category
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|instrprof_error
name|MergeResult
parameter_list|(
name|instrprof_error
modifier|&
name|Accumulator
parameter_list|,
name|instrprof_error
name|Result
parameter_list|)
block|{
comment|// Prefer first error encountered as later errors may be secondary effects of
comment|// the initial problem.
if|if
condition|(
name|Accumulator
operator|==
name|instrprof_error
operator|::
name|success
operator|&&
name|Result
operator|!=
name|instrprof_error
operator|::
name|success
condition|)
name|Accumulator
operator|=
name|Result
expr_stmt|;
return|return
name|Accumulator
return|;
block|}
enum|enum
name|InstrProfValueKind
enum|:
name|uint32_t
block|{
define|#
directive|define
name|VALUE_PROF_KIND
parameter_list|(
name|Enumerator
parameter_list|,
name|Value
parameter_list|)
value|Enumerator = Value,
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
enum|;
name|namespace
name|object
block|{
name|class
name|SectionRef
decl_stmt|;
block|}
name|namespace
name|IndexedInstrProf
block|{
name|uint64_t
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
function_decl|;
block|}
comment|/// A symbol table used for function PGO name look-up with keys
comment|/// (such as pointers, md5hash values) to the function. A function's
comment|/// PGO name or name's md5hash are used in retrieving the profile
comment|/// data of the function. See \c getPGOFuncName() method for details
comment|/// on how PGO name is formed.
name|class
name|InstrProfSymtab
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|uint64_t
operator|>>
name|AddrHashMap
expr_stmt|;
name|private
label|:
name|StringRef
name|Data
decl_stmt|;
name|uint64_t
name|Address
decl_stmt|;
comment|// A map from MD5 hash keys to function name strings.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|std
operator|::
name|string
operator|>>
name|HashNameMap
expr_stmt|;
comment|// A map from function runtime address to function name MD5 hash.
comment|// This map is only populated and used by raw instr profile reader.
name|AddrHashMap
name|AddrToMD5Map
decl_stmt|;
name|public
label|:
name|InstrProfSymtab
argument_list|()
operator|:
name|Data
argument_list|()
operator|,
name|Address
argument_list|(
literal|0
argument_list|)
operator|,
name|HashNameMap
argument_list|()
operator|,
name|AddrToMD5Map
argument_list|()
block|{}
comment|/// Create InstrProfSymtab from an object file section which
comment|/// contains function PGO names that are uncompressed.
comment|/// This interface is used by CoverageMappingReader.
name|std
operator|::
name|error_code
name|create
argument_list|(
name|object
operator|::
name|SectionRef
operator|&
name|Section
argument_list|)
expr_stmt|;
comment|/// This interface is used by reader of CoverageMapping test
comment|/// format.
specifier|inline
name|std
operator|::
name|error_code
name|create
argument_list|(
argument|StringRef D
argument_list|,
argument|uint64_t BaseAddr
argument_list|)
expr_stmt|;
comment|/// \c NameStrings is a string composed of one of more sub-strings
comment|///  encoded in the format described above. The substrings are
comment|/// seperated by 0 or more zero bytes. This method decodes the
comment|/// string and populates the \c Symtab.
specifier|inline
name|std
operator|::
name|error_code
name|create
argument_list|(
argument|StringRef NameStrings
argument_list|)
expr_stmt|;
comment|/// Create InstrProfSymtab from a set of names iteratable from
comment|/// \p IterRange. This interface is used by IndexedProfReader.
name|template
operator|<
name|typename
name|NameIterRange
operator|>
name|void
name|create
argument_list|(
specifier|const
name|NameIterRange
operator|&
name|IterRange
argument_list|)
expr_stmt|;
comment|// If the symtab is created by a series of calls to \c addFuncName, \c
comment|// finalizeSymtab needs to be called before looking up function names.
comment|// This is required because the underlying map is a vector (for space
comment|// efficiency) which needs to be sorted.
specifier|inline
name|void
name|finalizeSymtab
parameter_list|()
function_decl|;
comment|/// Update the symtab by adding \p FuncName to the table. This interface
comment|/// is used by the raw and text profile readers.
name|void
name|addFuncName
parameter_list|(
name|StringRef
name|FuncName
parameter_list|)
block|{
name|HashNameMap
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|IndexedInstrProf
operator|::
name|ComputeHash
argument_list|(
name|FuncName
argument_list|)
argument_list|,
name|FuncName
operator|.
name|str
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Map a function address to its name's MD5 hash. This interface
comment|/// is only used by the raw profiler reader.
name|void
name|mapAddress
parameter_list|(
name|uint64_t
name|Addr
parameter_list|,
name|uint64_t
name|MD5Val
parameter_list|)
block|{
name|AddrToMD5Map
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Addr
argument_list|,
name|MD5Val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AddrHashMap
modifier|&
name|getAddrHashMap
parameter_list|()
block|{
return|return
name|AddrToMD5Map
return|;
block|}
comment|/// Return function's PGO name from the function name's symbol
comment|/// address in the object file. If an error occurs, return
comment|/// an empty string.
name|StringRef
name|getFuncName
parameter_list|(
name|uint64_t
name|FuncNameAddress
parameter_list|,
name|size_t
name|NameSize
parameter_list|)
function_decl|;
comment|/// Return function's PGO name from the name's md5 hash value.
comment|/// If not found, return an empty string.
specifier|inline
name|StringRef
name|getFuncName
parameter_list|(
name|uint64_t
name|FuncMD5Hash
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|std
operator|::
name|error_code
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|StringRef D
argument_list|,
argument|uint64_t BaseAddr
argument_list|)
block|{
name|Data
operator|=
name|D
block|;
name|Address
operator|=
name|BaseAddr
block|;
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
block|}
name|std
operator|::
name|error_code
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|StringRef NameStrings
argument_list|)
block|{
if|if
condition|(
name|readPGOFuncNameStrings
argument_list|(
name|NameStrings
argument_list|,
operator|*
name|this
argument_list|)
condition|)
return|return
name|make_error_code
argument_list|(
name|instrprof_error
operator|::
name|malformed
argument_list|)
return|;
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|NameIterRange
operator|>
name|void
name|InstrProfSymtab
operator|::
name|create
argument_list|(
argument|const NameIterRange&IterRange
argument_list|)
block|{
for|for
control|(
name|auto
name|Name
range|:
name|IterRange
control|)
name|HashNameMap
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|IndexedInstrProf
operator|::
name|ComputeHash
argument_list|(
name|Name
argument_list|)
argument_list|,
name|Name
operator|.
name|str
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|finalizeSymtab
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  void
name|InstrProfSymtab
operator|::
name|finalizeSymtab
argument_list|()
block|{
name|std
operator|::
name|sort
argument_list|(
name|HashNameMap
operator|.
name|begin
argument_list|()
argument_list|,
name|HashNameMap
operator|.
name|end
argument_list|()
argument_list|,
name|less_first
argument_list|()
argument_list|)
block|;
name|HashNameMap
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|HashNameMap
operator|.
name|begin
argument_list|()
argument_list|,
name|HashNameMap
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|HashNameMap
operator|.
name|end
argument_list|()
argument_list|)
block|;
name|std
operator|::
name|sort
argument_list|(
name|AddrToMD5Map
operator|.
name|begin
argument_list|()
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|,
name|less_first
argument_list|()
argument_list|)
block|;
name|AddrToMD5Map
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|AddrToMD5Map
operator|.
name|begin
argument_list|()
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|AddrToMD5Map
operator|.
name|end
argument_list|()
argument_list|)
block|; }
name|StringRef
name|InstrProfSymtab
operator|::
name|getFuncName
argument_list|(
argument|uint64_t FuncMD5Hash
argument_list|)
block|{
name|auto
name|Result
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|HashNameMap
operator|.
name|begin
argument_list|()
argument_list|,
name|HashNameMap
operator|.
name|end
argument_list|()
argument_list|,
name|FuncMD5Hash
argument_list|,
index|[]
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|std
operator|::
name|string
operator|>
operator|&
name|LHS
operator|,
name|uint64_t
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|first
operator|<
name|RHS
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|Result
operator|!=
name|HashNameMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|Result
operator|->
name|second
return|;
end_if

begin_return
return|return
name|StringRef
argument_list|()
return|;
end_return

begin_macro
unit|}  struct
name|InstrProfValueSiteRecord
end_macro

begin_block
block|{
comment|/// Value profiling data pairs at a given value site.
name|std
operator|::
name|list
operator|<
name|InstrProfValueData
operator|>
name|ValueData
expr_stmt|;
name|InstrProfValueSiteRecord
argument_list|()
block|{
name|ValueData
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|template
operator|<
name|class
name|InputIterator
operator|>
name|InstrProfValueSiteRecord
argument_list|(
argument|InputIterator F
argument_list|,
argument|InputIterator L
argument_list|)
operator|:
name|ValueData
argument_list|(
argument|F
argument_list|,
argument|L
argument_list|)
block|{}
comment|/// Sort ValueData ascending by Value
name|void
name|sortByTargetValues
argument_list|()
block|{
name|ValueData
operator|.
name|sort
argument_list|(
index|[]
operator|(
specifier|const
name|InstrProfValueData
operator|&
name|left
operator|,
specifier|const
name|InstrProfValueData
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|Value
operator|<
name|right
operator|.
name|Value
return|;
block|}
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/// Sort ValueData Descending by Count
end_comment

begin_function_decl
unit|inline
name|void
name|sortByCount
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/// Merge data from another InstrProfValueSiteRecord
end_comment

begin_comment
comment|/// Optionally scale merged counts by \p Weight.
end_comment

begin_function_decl
name|instrprof_error
name|merge
parameter_list|(
name|InstrProfValueSiteRecord
modifier|&
name|Input
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Scale up value profile data counts.
end_comment

begin_function_decl
name|instrprof_error
name|scale
parameter_list|(
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// Profiling information for a single function.
end_comment

begin_struct
struct|struct
name|InstrProfRecord
block|{
name|InstrProfRecord
argument_list|()
block|{}
name|InstrProfRecord
argument_list|(
argument|StringRef Name
argument_list|,
argument|uint64_t Hash
argument_list|,
argument|std::vector<uint64_t> Counts
argument_list|)
block|:
name|Name
argument_list|(
name|Name
argument_list|)
operator|,
name|Hash
argument_list|(
name|Hash
argument_list|)
operator|,
name|Counts
argument_list|(
argument|std::move(Counts)
argument_list|)
block|{}
name|StringRef
name|Name
expr_stmt|;
name|uint64_t
name|Hash
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|uint64_t
operator|>
name|Counts
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|uint64_t
operator|>>
name|ValueMapType
expr_stmt|;
comment|/// Return the number of value profile kinds with non-zero number
comment|/// of profile sites.
specifier|inline
name|uint32_t
name|getNumValueKinds
argument_list|()
specifier|const
expr_stmt|;
comment|/// Return the number of instrumented sites for ValueKind.
specifier|inline
name|uint32_t
name|getNumValueSites
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the total number of ValueData for ValueKind.
specifier|inline
name|uint32_t
name|getNumValueData
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the number of value data collected for ValueKind at profiling
comment|/// site: Site.
specifier|inline
name|uint32_t
name|getNumValueDataForSite
argument_list|(
name|uint32_t
name|ValueKind
argument_list|,
name|uint32_t
name|Site
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the array of profiled values at \p Site.
specifier|inline
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
name|getValueForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|,
argument|uint64_t (*ValueMapper)(uint32_t, uint64_t) =
literal|0
argument_list|)
specifier|const
expr_stmt|;
specifier|inline
name|void
name|getValueForSite
argument_list|(
name|InstrProfValueData
name|Dest
index|[]
argument_list|,
name|uint32_t
name|ValueKind
argument_list|,
name|uint32_t
name|Site
argument_list|,
name|uint64_t
argument_list|(
operator|*
name|ValueMapper
argument_list|)
argument_list|(
name|uint32_t
argument_list|,
name|uint64_t
argument_list|)
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// Reserve space for NumValueSites sites.
specifier|inline
name|void
name|reserveSites
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint32_t
name|NumValueSites
parameter_list|)
function_decl|;
comment|/// Add ValueData for ValueKind at value Site.
name|void
name|addValueData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint32_t
name|Site
parameter_list|,
name|InstrProfValueData
modifier|*
name|VData
parameter_list|,
name|uint32_t
name|N
parameter_list|,
name|ValueMapType
modifier|*
name|ValueMap
parameter_list|)
function_decl|;
comment|/// Merge the counts in \p Other into this one.
comment|/// Optionally scale merged counts by \p Weight.
name|instrprof_error
name|merge
parameter_list|(
name|InstrProfRecord
modifier|&
name|Other
parameter_list|,
name|uint64_t
name|Weight
init|=
literal|1
parameter_list|)
function_decl|;
comment|/// Scale up profile counts (including value profile data) by
comment|/// \p Weight.
name|instrprof_error
name|scale
parameter_list|(
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
comment|/// Sort value profile data (per site) by count.
name|void
name|sortValueData
parameter_list|()
block|{
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
block|{
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|SiteRecords
operator|=
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|SR
operator|:
name|SiteRecords
control|)
name|SR
operator|.
name|sortByCount
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// Clear value data entries
name|void
name|clearValueData
parameter_list|()
block|{
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
name|IndirectCallSites
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|getValueSitesForKind
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
switch|switch
condition|(
name|ValueKind
condition|)
block|{
case|case
name|IPVK_IndirectCallTarget
case|:
return|return
name|IndirectCallSites
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown value kind!"
argument_list|)
expr_stmt|;
block|}
return|return
name|IndirectCallSites
return|;
block|}
name|std
decl|::
name|vector
decl|<
name|InstrProfValueSiteRecord
decl|>
modifier|&
name|getValueSitesForKind
argument_list|(
name|uint32_t
name|ValueKind
argument_list|)
block|{
return|return
name|const_cast
operator|<
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|InstrProfRecord
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
operator|)
return|;
block|}
comment|// Map indirect call target name hash to name string.
name|uint64_t
name|remapValue
argument_list|(
name|uint64_t
name|Value
argument_list|,
name|uint32_t
name|ValueKind
argument_list|,
name|ValueMapType
operator|*
name|HashKeys
argument_list|)
struct|;
end_struct

begin_comment
comment|// Merge Value Profile data from Src record to this record for ValueKind.
end_comment

begin_comment
comment|// Scale merged value counts by \p Weight.
end_comment

begin_function_decl
name|instrprof_error
name|mergeValueProfData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|InstrProfRecord
modifier|&
name|Src
parameter_list|,
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Scale up value profile data count.
end_comment

begin_function_decl
name|instrprof_error
name|scaleValueProfData
parameter_list|(
name|uint32_t
name|ValueKind
parameter_list|,
name|uint64_t
name|Weight
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
unit|};
name|uint32_t
name|InstrProfRecord
operator|::
name|getNumValueKinds
argument_list|()
specifier|const
block|{
name|uint32_t
name|NumValueKinds
operator|=
literal|0
block|;
for|for
control|(
name|uint32_t
name|Kind
init|=
name|IPVK_First
init|;
name|Kind
operator|<=
name|IPVK_Last
condition|;
operator|++
name|Kind
control|)
name|NumValueKinds
operator|+=
operator|!
operator|(
name|getValueSitesForKind
argument_list|(
name|Kind
argument_list|)
operator|.
name|empty
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NumValueKinds
return|;
end_return

begin_expr_stmt
unit|}  uint32_t
name|InstrProfRecord
operator|::
name|getNumValueData
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
name|uint32_t
name|N
operator|=
literal|0
block|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|SiteRecords
operator|=
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
block|;
for|for
control|(
name|auto
operator|&
name|SR
operator|:
name|SiteRecords
control|)
block|{
name|N
operator|+=
name|SR
operator|.
name|ValueData
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|N
return|;
end_return

begin_expr_stmt
unit|}  uint32_t
name|InstrProfRecord
operator|::
name|getNumValueSites
argument_list|(
argument|uint32_t ValueKind
argument_list|)
specifier|const
block|{
return|return
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint32_t
name|InstrProfRecord
operator|::
name|getNumValueDataForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|)
specifier|const
block|{
return|return
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
index|[
name|Site
index|]
operator|.
name|ValueData
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
name|InstrProfRecord
operator|::
name|getValueForSite
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|,
argument|uint64_t (*ValueMapper)(uint32_t, uint64_t)
argument_list|)
specifier|const
block|{
name|uint32_t
name|N
operator|=
name|getNumValueDataForSite
argument_list|(
name|ValueKind
argument_list|,
name|Site
argument_list|)
block|;
if|if
condition|(
name|N
operator|==
literal|0
condition|)
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|InstrProfValueData
index|[]
operator|>
operator|(
name|nullptr
operator|)
return|;
name|auto
name|VD
operator|=
name|llvm
operator|::
name|make_unique
operator|<
name|InstrProfValueData
index|[]
operator|>
operator|(
name|N
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getValueForSite
argument_list|(
name|VD
operator|.
name|get
argument_list|()
argument_list|,
name|ValueKind
argument_list|,
name|Site
argument_list|,
name|ValueMapper
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|VD
return|;
end_return

begin_expr_stmt
unit|}  void
name|InstrProfRecord
operator|::
name|getValueForSite
argument_list|(
argument|InstrProfValueData Dest[]
argument_list|,
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t Site
argument_list|,
argument|uint64_t (*ValueMapper)(uint32_t,                                                               uint64_t)
argument_list|)
specifier|const
block|{
name|uint32_t
name|I
operator|=
literal|0
block|;
for|for
control|(
name|auto
name|V
range|:
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
index|[
name|Site
index|]
operator|.
name|ValueData
control|)
block|{
name|Dest
index|[
name|I
index|]
operator|.
name|Value
operator|=
name|ValueMapper
condition|?
name|ValueMapper
argument_list|(
name|ValueKind
argument_list|,
name|V
operator|.
name|Value
argument_list|)
else|:
name|V
operator|.
name|Value
expr_stmt|;
name|Dest
index|[
name|I
index|]
operator|.
name|Count
operator|=
name|V
operator|.
name|Count
expr_stmt|;
name|I
operator|++
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  void
name|InstrProfRecord
operator|::
name|reserveSites
argument_list|(
argument|uint32_t ValueKind
argument_list|,
argument|uint32_t NumValueSites
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|InstrProfValueSiteRecord
operator|>
operator|&
name|ValueSites
operator|=
name|getValueSitesForKind
argument_list|(
name|ValueKind
argument_list|)
block|;
name|ValueSites
operator|.
name|reserve
argument_list|(
name|NumValueSites
argument_list|)
block|; }
specifier|inline
name|support
operator|::
name|endianness
name|getHostEndianness
argument_list|()
block|{
return|return
name|sys
operator|::
name|IsLittleEndianHost
operator|?
name|support
operator|::
name|little
operator|:
name|support
operator|::
name|big
return|;
block|}
end_expr_stmt

begin_comment
comment|// Include definitions for value profile data
end_comment

begin_define
define|#
directive|define
name|INSTR_PROF_VALUE_PROF_DATA
end_define

begin_include
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
end_include

begin_expr_stmt
name|void
name|InstrProfValueSiteRecord
operator|::
name|sortByCount
argument_list|()
block|{
name|ValueData
operator|.
name|sort
argument_list|(
index|[]
operator|(
specifier|const
name|InstrProfValueData
operator|&
name|left
operator|,
specifier|const
name|InstrProfValueData
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|Count
operator|>
name|right
operator|.
name|Count
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Now truncate
end_comment

begin_decl_stmt
name|size_t
name|max_s
init|=
name|INSTR_PROF_MAX_NUM_VAL_PER_SITE
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|ValueData
operator|.
name|size
argument_list|()
operator|>
name|max_s
condition|)
name|ValueData
operator|.
name|resize
argument_list|(
name|max_s
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/* * Initialize the record for runtime value profile data. * Return 0 if the initialization is successful, otherwise * return 1. */
end_comment

begin_expr_stmt
unit|int
name|initializeValueProfRuntimeRecord
argument_list|(
name|ValueProfRuntimeRecord
operator|*
name|RuntimeRecord
argument_list|,
specifier|const
name|uint16_t
operator|*
name|NumValueSites
argument_list|,
name|ValueProfNode
operator|*
operator|*
name|Nodes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Release memory allocated for the runtime record.  */
end_comment

begin_function_decl
name|void
name|finalizeValueProfRuntimeRecord
parameter_list|(
name|ValueProfRuntimeRecord
modifier|*
name|RuntimeRecord
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the size of ValueProfData structure that can be used to store    the value profile data collected at runtime. */
end_comment

begin_function_decl
name|uint32_t
name|getValueProfDataSizeRT
parameter_list|(
specifier|const
name|ValueProfRuntimeRecord
modifier|*
name|Record
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return a ValueProfData instance that stores the data collected at runtime. */
end_comment

begin_function_decl
name|ValueProfData
modifier|*
name|serializeValueProfDataFromRT
parameter_list|(
specifier|const
name|ValueProfRuntimeRecord
modifier|*
name|Record
parameter_list|,
name|ValueProfData
modifier|*
name|Dst
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|namespace
name|IndexedInstrProf
block|{
name|enum
name|class
name|HashT
range|:
name|uint32_t
block|{
name|MD5
block|,
name|Last
operator|=
name|MD5
block|}
decl_stmt|;
specifier|static
specifier|inline
name|uint64_t
name|MD5Hash
parameter_list|(
name|StringRef
name|Str
parameter_list|)
block|{
name|MD5
name|Hash
decl_stmt|;
name|Hash
operator|.
name|update
argument_list|(
name|Str
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|MD5
operator|::
name|MD5Result
name|Result
expr_stmt|;
name|Hash
operator|.
name|final
argument_list|(
name|Result
argument_list|)
expr_stmt|;
comment|// Return the least significant 8 bytes. Our MD5 implementation returns the
comment|// result in little endian, so we may need to swap bytes.
name|using
name|namespace
name|llvm
operator|::
name|support
expr_stmt|;
return|return
name|endian
operator|::
name|read
operator|<
name|uint64_t
operator|,
name|little
operator|,
name|unaligned
operator|>
operator|(
name|Result
operator|)
return|;
block|}
specifier|inline
name|uint64_t
name|ComputeHash
parameter_list|(
name|HashT
name|Type
parameter_list|,
name|StringRef
name|K
parameter_list|)
block|{
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|HashT
operator|::
name|MD5
case|:
return|return
name|IndexedInstrProf
operator|::
name|MD5Hash
argument_list|(
name|K
argument_list|)
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Unhandled hash type"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|uint64_t
name|Magic
init|=
literal|0x8169666f72706cff
decl_stmt|;
comment|// "\xfflprofi\x81"
specifier|const
name|uint64_t
name|Version
init|=
name|INSTR_PROF_INDEX_VERSION
decl_stmt|;
specifier|const
name|HashT
name|HashType
init|=
name|HashT
operator|::
name|MD5
decl_stmt|;
specifier|inline
name|uint64_t
name|ComputeHash
parameter_list|(
name|StringRef
name|K
parameter_list|)
block|{
return|return
name|ComputeHash
argument_list|(
name|HashType
argument_list|,
name|K
argument_list|)
return|;
block|}
comment|// This structure defines the file header of the LLVM profile
comment|// data file in indexed-format.
struct|struct
name|Header
block|{
name|uint64_t
name|Magic
decl_stmt|;
name|uint64_t
name|Version
decl_stmt|;
name|uint64_t
name|MaxFunctionCount
decl_stmt|;
name|uint64_t
name|HashType
decl_stmt|;
name|uint64_t
name|HashOffset
decl_stmt|;
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace IndexedInstrProf
end_comment

begin_decl_stmt
name|namespace
name|RawInstrProf
block|{
specifier|const
name|uint64_t
name|Version
init|=
name|INSTR_PROF_RAW_VERSION
decl_stmt|;
name|template
operator|<
name|class
name|IntPtrT
operator|>
specifier|inline
name|uint64_t
name|getMagic
argument_list|()
expr_stmt|;
name|template
operator|<
operator|>
specifier|inline
name|uint64_t
name|getMagic
operator|<
name|uint64_t
operator|>
operator|(
operator|)
block|{
return|return
name|INSTR_PROF_RAW_MAGIC_64
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|uint64_t
name|getMagic
operator|<
name|uint32_t
operator|>
operator|(
operator|)
block|{
return|return
name|INSTR_PROF_RAW_MAGIC_32
return|;
block|}
comment|// Per-function profile data header/control structure.
comment|// The definition should match the structure defined in
comment|// compiler-rt/lib/profile/InstrProfiling.h.
comment|// It should also match the synthesized type in
comment|// Transforms/Instrumentation/InstrProfiling.cpp:getOrCreateRegionCounters.
name|template
operator|<
name|class
name|IntPtrT
operator|>
expr|struct
name|LLVM_ALIGNAS
argument_list|(
literal|8
argument_list|)
name|ProfileData
block|{
define|#
directive|define
name|INSTR_PROF_DATA
parameter_list|(
name|Type
parameter_list|,
name|LLVMType
parameter_list|,
name|Name
parameter_list|,
name|Init
parameter_list|)
value|Type Name;
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
expr_stmt|;
comment|// File header structure of the LLVM profile data in raw format.
comment|// The definition should match the header referenced in
comment|// compiler-rt/lib/profile/InstrProfilingFile.c  and
comment|// InstrProfilingBuffer.c.
struct|struct
name|Header
block|{
define|#
directive|define
name|INSTR_PROF_RAW_HEADER
parameter_list|(
name|Type
parameter_list|,
name|Name
parameter_list|,
name|Init
parameter_list|)
value|const Type Name;
include|#
directive|include
file|"llvm/ProfileData/InstrProfData.inc"
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace RawInstrProf
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_macro
unit|namespace
name|std
end_macro

begin_block
block|{
name|template
operator|<
operator|>
expr|struct
name|is_error_code_enum
operator|<
name|llvm
operator|::
name|instrprof_error
operator|>
operator|:
name|std
operator|::
name|true_type
block|{}
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_PROFILEDATA_INSTRPROF_H_
end_comment

end_unit

