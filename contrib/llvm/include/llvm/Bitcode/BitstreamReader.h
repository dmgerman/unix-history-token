begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitstreamReader class.  This class can be used to
end_comment

begin_comment
comment|// read an arbitrary bitstream, regardless of its contents.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITSTREAM_READER_H
end_ifndef

begin_define
define|#
directive|define
name|BITSTREAM_READER_H
end_define

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitCodes.h"
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Deserializer
decl_stmt|;
name|class
name|BitstreamReader
block|{
name|public
label|:
comment|/// BlockInfo - This contains information emitted to BLOCKINFO_BLOCK blocks.
comment|/// These describe abbreviations that all blocks of the specified ID inherit.
struct|struct
name|BlockInfo
block|{
name|unsigned
name|BlockID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|Abbrevs
expr_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
expr|>
name|RecordNames
expr_stmt|;
block|}
struct|;
name|private
label|:
comment|/// FirstChar/LastChar - This remembers the first and last bytes of the
comment|/// stream.
specifier|const
name|unsigned
name|char
modifier|*
name|FirstChar
decl_stmt|,
modifier|*
name|LastChar
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BlockInfoRecords
expr_stmt|;
comment|/// IgnoreBlockInfoNames - This is set to true if we don't care about the
comment|/// block/record name information in the BlockInfo block. Only llvm-bcanalyzer
comment|/// uses this.
name|bool
name|IgnoreBlockInfoNames
decl_stmt|;
name|BitstreamReader
argument_list|(
specifier|const
name|BitstreamReader
operator|&
argument_list|)
expr_stmt|;
comment|// NOT IMPLEMENTED
name|void
name|operator
init|=
operator|(
specifier|const
name|BitstreamReader
operator|&
operator|)
decl_stmt|;
comment|// NOT IMPLEMENTED
name|public
label|:
name|BitstreamReader
argument_list|()
operator|:
name|FirstChar
argument_list|(
literal|0
argument_list|)
operator|,
name|LastChar
argument_list|(
literal|0
argument_list|)
operator|,
name|IgnoreBlockInfoNames
argument_list|(
argument|true
argument_list|)
block|{   }
name|BitstreamReader
argument_list|(
argument|const unsigned char *Start
argument_list|,
argument|const unsigned char *End
argument_list|)
block|{
name|IgnoreBlockInfoNames
operator|=
name|true
block|;
name|init
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
block|;   }
name|void
name|init
argument_list|(
argument|const unsigned char *Start
argument_list|,
argument|const unsigned char *End
argument_list|)
block|{
name|FirstChar
operator|=
name|Start
block|;
name|LastChar
operator|=
name|End
block|;
name|assert
argument_list|(
operator|(
operator|(
name|End
operator|-
name|Start
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
literal|"Bitcode stream not a multiple of 4 bytes"
argument_list|)
block|;   }
operator|~
name|BitstreamReader
argument_list|()
block|{
comment|// Free the BlockInfoRecords.
while|while
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
condition|)
block|{
name|BlockInfo
modifier|&
name|Info
init|=
name|BlockInfoRecords
operator|.
name|back
argument_list|()
decl_stmt|;
comment|// Free blockinfo abbrev info.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Info
operator|.
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Info
operator|.
name|Abbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|BlockInfoRecords
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
specifier|const
name|unsigned
name|char
operator|*
name|getFirstChar
argument_list|()
specifier|const
block|{
return|return
name|FirstChar
return|;
block|}
specifier|const
name|unsigned
name|char
operator|*
name|getLastChar
argument_list|()
specifier|const
block|{
return|return
name|LastChar
return|;
block|}
comment|/// CollectBlockInfoNames - This is called by clients that want block/record
comment|/// name information.
name|void
name|CollectBlockInfoNames
parameter_list|()
block|{
name|IgnoreBlockInfoNames
operator|=
name|false
expr_stmt|;
block|}
name|bool
name|isIgnoringBlockInfoNames
parameter_list|()
block|{
return|return
name|IgnoreBlockInfoNames
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Block Manipulation
comment|//===--------------------------------------------------------------------===//
comment|/// hasBlockInfoRecords - Return true if we've already read and processed the
comment|/// block info block for this Bitstream.  We only process it for the first
comment|/// cursor that walks over it.
name|bool
name|hasBlockInfoRecords
argument_list|()
specifier|const
block|{
return|return
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getBlockInfo - If there is block info for the specified ID, return it,
comment|/// otherwise return null.
specifier|const
name|BlockInfo
modifier|*
name|getBlockInfo
argument_list|(
name|unsigned
name|BlockID
argument_list|)
decl|const
block|{
comment|// Common case, the most recent entry matches BlockID.
if|if
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
operator|&&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockInfoRecords
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|BlockInfoRecords
index|[
name|i
index|]
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
name|BlockInfo
modifier|&
name|getOrCreateBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|BlockInfo
modifier|*
name|BI
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
return|return
operator|*
name|const_cast
operator|<
name|BlockInfo
operator|*
operator|>
operator|(
name|BI
operator|)
return|;
comment|// Otherwise, add a new record.
name|BlockInfoRecords
operator|.
name|push_back
argument_list|(
name|BlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|=
name|BlockID
expr_stmt|;
return|return
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|class
name|BitstreamCursor
block|{
name|friend
name|class
name|Deserializer
decl_stmt|;
name|BitstreamReader
modifier|*
name|BitStream
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|NextChar
decl_stmt|;
comment|/// CurWord - This is the current data we have pulled from the stream but have
comment|/// not returned to the client.
name|uint32_t
name|CurWord
decl_stmt|;
comment|/// BitsInCurWord - This is the number of bits in CurWord that are valid. This
comment|/// is always from [0...31] inclusive.
name|unsigned
name|BitsInCurWord
decl_stmt|;
comment|// CurCodeSize - This is the declared size of code values used for the current
comment|// block, in bits.
name|unsigned
name|CurCodeSize
decl_stmt|;
comment|/// CurAbbrevs - Abbrevs installed at in this block.
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|CurAbbrevs
expr_stmt|;
struct|struct
name|Block
block|{
name|unsigned
name|PrevCodeSize
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|PrevAbbrevs
expr_stmt|;
name|explicit
name|Block
argument_list|(
argument|unsigned PCS
argument_list|)
block|:
name|PrevCodeSize
argument_list|(
argument|PCS
argument_list|)
block|{}
block|}
struct|;
comment|/// BlockScope - This tracks the codesize of parent blocks.
name|SmallVector
operator|<
name|Block
operator|,
literal|8
operator|>
name|BlockScope
expr_stmt|;
name|public
label|:
name|BitstreamCursor
argument_list|()
operator|:
name|BitStream
argument_list|(
literal|0
argument_list|)
operator|,
name|NextChar
argument_list|(
literal|0
argument_list|)
block|{   }
name|BitstreamCursor
argument_list|(
specifier|const
name|BitstreamCursor
operator|&
name|RHS
argument_list|)
operator|:
name|BitStream
argument_list|(
literal|0
argument_list|)
operator|,
name|NextChar
argument_list|(
literal|0
argument_list|)
block|{
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;   }
name|explicit
name|BitstreamCursor
argument_list|(
name|BitstreamReader
operator|&
name|R
argument_list|)
operator|:
name|BitStream
argument_list|(
argument|&R
argument_list|)
block|{
name|NextChar
operator|=
name|R
operator|.
name|getFirstChar
argument_list|()
block|;
name|assert
argument_list|(
name|NextChar
operator|&&
literal|"Bitstream not initialized yet"
argument_list|)
block|;
name|CurWord
operator|=
literal|0
block|;
name|BitsInCurWord
operator|=
literal|0
block|;
name|CurCodeSize
operator|=
literal|2
block|;   }
name|void
name|init
argument_list|(
argument|BitstreamReader&R
argument_list|)
block|{
name|freeState
argument_list|()
block|;
name|BitStream
operator|=
operator|&
name|R
block|;
name|NextChar
operator|=
name|R
operator|.
name|getFirstChar
argument_list|()
block|;
name|assert
argument_list|(
name|NextChar
operator|&&
literal|"Bitstream not initialized yet"
argument_list|)
block|;
name|CurWord
operator|=
literal|0
block|;
name|BitsInCurWord
operator|=
literal|0
block|;
name|CurCodeSize
operator|=
literal|2
block|;   }
operator|~
name|BitstreamCursor
argument_list|()
block|{
name|freeState
argument_list|()
block|;   }
name|void
name|operator
operator|=
operator|(
specifier|const
name|BitstreamCursor
operator|&
name|RHS
operator|)
block|{
name|freeState
argument_list|()
block|;
name|BitStream
operator|=
name|RHS
operator|.
name|BitStream
block|;
name|NextChar
operator|=
name|RHS
operator|.
name|NextChar
block|;
name|CurWord
operator|=
name|RHS
operator|.
name|CurWord
block|;
name|BitsInCurWord
operator|=
name|RHS
operator|.
name|BitsInCurWord
block|;
name|CurCodeSize
operator|=
name|RHS
operator|.
name|CurCodeSize
block|;
comment|// Copy abbreviations, and bump ref counts.
name|CurAbbrevs
operator|=
name|RHS
operator|.
name|CurAbbrevs
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|CurAbbrevs
index|[
name|i
index|]
operator|->
name|addRef
argument_list|()
expr_stmt|;
comment|// Copy block scope and bump ref counts.
for|for
control|(
name|unsigned
name|S
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockScope
operator|.
name|size
argument_list|()
operator|)
init|;
name|S
operator|!=
name|e
condition|;
operator|++
name|S
control|)
block|{
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
operator|&
name|Abbrevs
operator|=
name|BlockScope
index|[
name|S
index|]
operator|.
name|PrevAbbrevs
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Abbrevs
index|[
name|i
index|]
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|freeState
parameter_list|()
block|{
comment|// Free all the Abbrevs.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|CurAbbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|CurAbbrevs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Free all the Abbrevs in the block scope.
for|for
control|(
name|unsigned
name|S
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockScope
operator|.
name|size
argument_list|()
operator|)
init|;
name|S
operator|!=
name|e
condition|;
operator|++
name|S
control|)
block|{
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
operator|&
name|Abbrevs
operator|=
name|BlockScope
index|[
name|S
index|]
operator|.
name|PrevAbbrevs
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Abbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
block|}
name|BlockScope
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/// GetAbbrevIDWidth - Return the number of bits used to encode an abbrev #.
name|unsigned
name|GetAbbrevIDWidth
argument_list|()
specifier|const
block|{
return|return
name|CurCodeSize
return|;
block|}
name|bool
name|AtEndOfStream
argument_list|()
specifier|const
block|{
return|return
name|NextChar
operator|==
name|BitStream
operator|->
name|getLastChar
argument_list|()
operator|&&
name|BitsInCurWord
operator|==
literal|0
return|;
block|}
comment|/// GetCurrentBitNo - Return the bit # of the bit we are reading.
name|uint64_t
name|GetCurrentBitNo
argument_list|()
specifier|const
block|{
return|return
operator|(
name|NextChar
operator|-
name|BitStream
operator|->
name|getFirstChar
argument_list|()
operator|)
operator|*
name|CHAR_BIT
operator|-
name|BitsInCurWord
return|;
block|}
name|BitstreamReader
modifier|*
name|getBitStreamReader
parameter_list|()
block|{
return|return
name|BitStream
return|;
block|}
specifier|const
name|BitstreamReader
operator|*
name|getBitStreamReader
argument_list|()
specifier|const
block|{
return|return
name|BitStream
return|;
block|}
comment|/// JumpToBit - Reset the stream to the specified bit number.
name|void
name|JumpToBit
parameter_list|(
name|uint64_t
name|BitNo
parameter_list|)
block|{
name|uintptr_t
name|ByteNo
init|=
name|uintptr_t
argument_list|(
name|BitNo
operator|/
literal|8
argument_list|)
operator|&
operator|~
literal|3
decl_stmt|;
name|uintptr_t
name|WordBitNo
init|=
name|uintptr_t
argument_list|(
name|BitNo
argument_list|)
operator|&
literal|31
decl_stmt|;
name|assert
argument_list|(
name|ByteNo
operator|<=
call|(
name|uintptr_t
call|)
argument_list|(
name|BitStream
operator|->
name|getLastChar
argument_list|()
operator|-
name|BitStream
operator|->
name|getFirstChar
argument_list|()
argument_list|)
operator|&&
literal|"Invalid location"
argument_list|)
expr_stmt|;
comment|// Move the cursor to the right word.
name|NextChar
operator|=
name|BitStream
operator|->
name|getFirstChar
argument_list|()
operator|+
name|ByteNo
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
name|CurWord
operator|=
literal|0
expr_stmt|;
comment|// Skip over any bits that are already consumed.
if|if
condition|(
name|WordBitNo
condition|)
name|Read
argument_list|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|WordBitNo
operator|)
argument_list|)
expr_stmt|;
block|}
name|uint32_t
name|Read
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|assert
argument_list|(
name|NumBits
operator|<=
literal|32
operator|&&
literal|"Cannot return more than 32 bits!"
argument_list|)
expr_stmt|;
comment|// If the field is fully contained by CurWord, return it quickly.
if|if
condition|(
name|BitsInCurWord
operator|>=
name|NumBits
condition|)
block|{
name|uint32_t
name|R
init|=
name|CurWord
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|NumBits
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|CurWord
operator|>>=
name|NumBits
expr_stmt|;
name|BitsInCurWord
operator|-=
name|NumBits
expr_stmt|;
return|return
name|R
return|;
block|}
comment|// If we run out of data, stop at the end of the stream.
if|if
condition|(
name|NextChar
operator|==
name|BitStream
operator|->
name|getLastChar
argument_list|()
condition|)
block|{
name|CurWord
operator|=
literal|0
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|unsigned
name|R
init|=
name|CurWord
decl_stmt|;
comment|// Read the next word from the stream.
name|CurWord
operator|=
operator|(
name|NextChar
index|[
literal|0
index|]
operator|<<
literal|0
operator|)
operator||
operator|(
name|NextChar
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|NextChar
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|NextChar
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|NextChar
operator|+=
literal|4
expr_stmt|;
comment|// Extract NumBits-BitsInCurWord from what we just read.
name|unsigned
name|BitsLeft
init|=
name|NumBits
operator|-
name|BitsInCurWord
decl_stmt|;
comment|// Be careful here, BitsLeft is in the range [1..32] inclusive.
name|R
operator||=
operator|(
name|CurWord
operator|&
operator|(
operator|~
literal|0U
operator|>>
operator|(
literal|32
operator|-
name|BitsLeft
operator|)
operator|)
operator|)
operator|<<
name|BitsInCurWord
expr_stmt|;
comment|// BitsLeft bits have just been used up from CurWord.
if|if
condition|(
name|BitsLeft
operator|!=
literal|32
condition|)
name|CurWord
operator|>>=
name|BitsLeft
expr_stmt|;
else|else
name|CurWord
operator|=
literal|0
expr_stmt|;
name|BitsInCurWord
operator|=
literal|32
operator|-
name|BitsLeft
expr_stmt|;
return|return
name|R
return|;
block|}
name|uint64_t
name|Read64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
if|if
condition|(
name|NumBits
operator|<=
literal|32
condition|)
return|return
name|Read
argument_list|(
name|NumBits
argument_list|)
return|;
name|uint64_t
name|V
init|=
name|Read
argument_list|(
literal|32
argument_list|)
decl_stmt|;
return|return
name|V
operator||
operator|(
name|uint64_t
operator|)
name|Read
argument_list|(
name|NumBits
operator|-
literal|32
argument_list|)
operator|<<
literal|32
return|;
block|}
name|uint32_t
name|ReadVBR
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Piece
return|;
name|uint32_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
operator|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ReadVBR64 - Read a VBR that may have a value up to 64-bits in size.  The
comment|// chunk size of the VBR must still be<= 32 bits though.
name|uint64_t
name|ReadVBR64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|uint64_t
argument_list|(
name|Piece
argument_list|)
return|;
name|uint64_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
name|uint64_t
argument_list|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|SkipToWord
parameter_list|()
block|{
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
name|CurWord
operator|=
literal|0
expr_stmt|;
block|}
name|unsigned
name|ReadCode
parameter_list|()
block|{
return|return
name|Read
argument_list|(
name|CurCodeSize
argument_list|)
return|;
block|}
comment|// Block header:
comment|//    [ENTER_SUBBLOCK, blockid, newcodelen,<align4bytes>, blocklen]
comment|/// ReadSubBlockID - Having read the ENTER_SUBBLOCK code, read the BlockID for
comment|/// the block.
name|unsigned
name|ReadSubBlockID
parameter_list|()
block|{
return|return
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|BlockIDWidth
argument_list|)
return|;
block|}
comment|/// SkipBlock - Having read the ENTER_SUBBLOCK abbrevid and a BlockID, skip
comment|/// over the body of this block.  If the block record is malformed, return
comment|/// true.
name|bool
name|SkipBlock
parameter_list|()
block|{
comment|// Read and ignore the codelen value.  Since we are skipping this block, we
comment|// don't care what code widths are used inside of it.
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
expr_stmt|;
name|SkipToWord
argument_list|()
expr_stmt|;
name|unsigned
name|NumWords
init|=
name|Read
argument_list|(
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
decl_stmt|;
comment|// Check that the block wasn't partially defined, and that the offset isn't
comment|// bogus.
if|if
condition|(
name|AtEndOfStream
argument_list|()
operator|||
name|NextChar
operator|+
name|NumWords
operator|*
literal|4
operator|>
name|BitStream
operator|->
name|getLastChar
argument_list|()
condition|)
return|return
name|true
return|;
name|NextChar
operator|+=
name|NumWords
operator|*
literal|4
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// EnterSubBlock - Having read the ENTER_SUBBLOCK abbrevid, enter
comment|/// the block, and return true if the block is valid.
name|bool
name|EnterSubBlock
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|unsigned
modifier|*
name|NumWordsP
init|=
literal|0
parameter_list|)
block|{
comment|// Save the current block's state on BlockScope.
name|BlockScope
operator|.
name|push_back
argument_list|(
name|Block
argument_list|(
name|CurCodeSize
argument_list|)
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
operator|.
name|swap
argument_list|(
name|CurAbbrevs
argument_list|)
expr_stmt|;
comment|// Add the abbrevs specific to this block to the CurAbbrevs list.
if|if
condition|(
specifier|const
name|BitstreamReader
operator|::
name|BlockInfo
operator|*
name|Info
operator|=
name|BitStream
operator|->
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Info
operator|->
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|CurAbbrevs
operator|.
name|push_back
argument_list|(
name|Info
operator|->
name|Abbrevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CurAbbrevs
operator|.
name|back
argument_list|()
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Get the codesize of this block.
name|CurCodeSize
operator|=
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
expr_stmt|;
name|SkipToWord
argument_list|()
expr_stmt|;
name|unsigned
name|NumWords
init|=
name|Read
argument_list|(
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|NumWordsP
condition|)
operator|*
name|NumWordsP
operator|=
name|NumWords
expr_stmt|;
comment|// Validate that this block is sane.
if|if
condition|(
name|CurCodeSize
operator|==
literal|0
operator|||
name|AtEndOfStream
argument_list|()
operator|||
name|NextChar
operator|+
name|NumWords
operator|*
literal|4
operator|>
name|BitStream
operator|->
name|getLastChar
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|bool
name|ReadBlockEnd
parameter_list|()
block|{
if|if
condition|(
name|BlockScope
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
comment|// Block tail:
comment|//    [END_BLOCK,<align4bytes>]
name|SkipToWord
argument_list|()
expr_stmt|;
name|PopBlockScope
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|private
label|:
name|void
name|PopBlockScope
parameter_list|()
block|{
name|CurCodeSize
operator|=
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevCodeSize
expr_stmt|;
comment|// Delete abbrevs from popped scope.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|CurAbbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
operator|.
name|swap
argument_list|(
name|CurAbbrevs
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Record Processing
comment|//===--------------------------------------------------------------------===//
name|private
label|:
name|void
name|ReadAbbreviatedLiteral
argument_list|(
specifier|const
name|BitCodeAbbrevOp
operator|&
name|Op
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|)
block|{
name|assert
argument_list|(
name|Op
operator|.
name|isLiteral
argument_list|()
operator|&&
literal|"Not a literal"
argument_list|)
expr_stmt|;
comment|// If the abbrev specifies the literal value to use, use it.
name|Vals
operator|.
name|push_back
argument_list|(
name|Op
operator|.
name|getLiteralValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|ReadAbbreviatedField
argument_list|(
specifier|const
name|BitCodeAbbrevOp
operator|&
name|Op
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Op
operator|.
name|isLiteral
argument_list|()
operator|&&
literal|"Use ReadAbbreviatedLiteral for literals!"
argument_list|)
expr_stmt|;
comment|// Decode the value as we are commanded.
switch|switch
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown encoding!"
argument_list|)
expr_stmt|;
case|case
name|BitCodeAbbrevOp
operator|::
name|Fixed
case|:
name|Vals
operator|.
name|push_back
argument_list|(
name|Read
argument_list|(
operator|(
name|unsigned
operator|)
name|Op
operator|.
name|getEncodingData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BitCodeAbbrevOp
operator|::
name|VBR
case|:
name|Vals
operator|.
name|push_back
argument_list|(
name|ReadVBR64
argument_list|(
operator|(
name|unsigned
operator|)
name|Op
operator|.
name|getEncodingData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BitCodeAbbrevOp
operator|::
name|Char6
case|:
name|Vals
operator|.
name|push_back
argument_list|(
name|BitCodeAbbrevOp
operator|::
name|DecodeChar6
argument_list|(
name|Read
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|public
label|:
comment|/// getAbbrev - Return the abbreviation for the specified AbbrevId.
specifier|const
name|BitCodeAbbrev
modifier|*
name|getAbbrev
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|unsigned
name|AbbrevNo
init|=
name|AbbrevID
operator|-
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
decl_stmt|;
name|assert
argument_list|(
name|AbbrevNo
operator|<
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid abbrev #!"
argument_list|)
expr_stmt|;
return|return
name|CurAbbrevs
index|[
name|AbbrevNo
index|]
return|;
block|}
name|unsigned
name|ReadRecord
argument_list|(
name|unsigned
name|AbbrevID
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|BlobStart
operator|=
literal|0
argument_list|,
name|unsigned
operator|*
name|BlobLen
operator|=
literal|0
argument_list|)
block|{
if|if
condition|(
name|AbbrevID
operator|==
name|bitc
operator|::
name|UNABBREV_RECORD
condition|)
block|{
name|unsigned
name|Code
init|=
name|ReadVBR
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|unsigned
name|NumElts
init|=
name|ReadVBR
argument_list|(
literal|6
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumElts
condition|;
operator|++
name|i
control|)
name|Vals
operator|.
name|push_back
argument_list|(
name|ReadVBR64
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Code
return|;
block|}
specifier|const
name|BitCodeAbbrev
modifier|*
name|Abbv
init|=
name|getAbbrev
argument_list|(
name|AbbrevID
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Abbv
operator|->
name|getNumOperandInfos
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|Op
init|=
name|Abbv
operator|->
name|getOperandInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Op
operator|.
name|isLiteral
argument_list|()
condition|)
block|{
name|ReadAbbreviatedLiteral
argument_list|(
name|Op
argument_list|,
name|Vals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
operator|==
name|BitCodeAbbrevOp
operator|::
name|Array
condition|)
block|{
comment|// Array case.  Read the number of elements as a vbr6.
name|unsigned
name|NumElts
init|=
name|ReadVBR
argument_list|(
literal|6
argument_list|)
decl_stmt|;
comment|// Get the element encoding.
name|assert
argument_list|(
name|i
operator|+
literal|2
operator|==
name|e
operator|&&
literal|"array op not second to last?"
argument_list|)
expr_stmt|;
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|EltEnc
init|=
name|Abbv
operator|->
name|getOperandInfo
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
comment|// Read all the elements.
for|for
control|(
init|;
name|NumElts
condition|;
operator|--
name|NumElts
control|)
name|ReadAbbreviatedField
argument_list|(
name|EltEnc
argument_list|,
name|Vals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Op
operator|.
name|getEncoding
argument_list|()
operator|==
name|BitCodeAbbrevOp
operator|::
name|Blob
condition|)
block|{
comment|// Blob case.  Read the number of bytes as a vbr6.
name|unsigned
name|NumElts
init|=
name|ReadVBR
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|SkipToWord
argument_list|()
expr_stmt|;
comment|// 32-bit alignment
comment|// Figure out where the end of this blob will be including tail padding.
specifier|const
name|unsigned
name|char
modifier|*
name|NewEnd
init|=
name|NextChar
operator|+
operator|(
operator|(
name|NumElts
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
decl_stmt|;
comment|// If this would read off the end of the bitcode file, just set the
comment|// record to empty and return.
if|if
condition|(
name|NewEnd
operator|>
name|BitStream
operator|->
name|getLastChar
argument_list|()
condition|)
block|{
name|Vals
operator|.
name|append
argument_list|(
name|NumElts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NextChar
operator|=
name|BitStream
operator|->
name|getLastChar
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// Otherwise, read the number of bytes.  If we can return a reference to
comment|// the data, do so to avoid copying it.
if|if
condition|(
name|BlobStart
condition|)
block|{
operator|*
name|BlobStart
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NextChar
expr_stmt|;
operator|*
name|BlobLen
operator|=
name|NumElts
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|NumElts
condition|;
operator|++
name|NextChar
operator|,
operator|--
name|NumElts
control|)
name|Vals
operator|.
name|push_back
argument_list|(
operator|*
name|NextChar
argument_list|)
expr_stmt|;
block|}
comment|// Skip over tail padding.
name|NextChar
operator|=
name|NewEnd
expr_stmt|;
block|}
else|else
block|{
name|ReadAbbreviatedField
argument_list|(
name|Op
argument_list|,
name|Vals
argument_list|)
expr_stmt|;
block|}
block|}
name|unsigned
name|Code
init|=
operator|(
name|unsigned
operator|)
name|Vals
index|[
literal|0
index|]
decl_stmt|;
name|Vals
operator|.
name|erase
argument_list|(
name|Vals
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Code
return|;
block|}
name|unsigned
name|ReadRecord
argument_list|(
name|unsigned
name|AbbrevID
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|,
specifier|const
name|char
operator|*
operator|&
name|BlobStart
argument_list|,
name|unsigned
operator|&
name|BlobLen
argument_list|)
block|{
return|return
name|ReadRecord
argument_list|(
name|AbbrevID
argument_list|,
name|Vals
argument_list|,
operator|&
name|BlobStart
argument_list|,
operator|&
name|BlobLen
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Abbrev Processing
comment|//===--------------------------------------------------------------------===//
name|void
name|ReadAbbrevRecord
parameter_list|()
block|{
name|BitCodeAbbrev
modifier|*
name|Abbv
init|=
name|new
name|BitCodeAbbrev
argument_list|()
decl_stmt|;
name|unsigned
name|NumOpInfo
init|=
name|ReadVBR
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumOpInfo
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|IsLiteral
init|=
name|Read
argument_list|(
literal|1
argument_list|)
condition|?
name|true
else|:
name|false
decl_stmt|;
if|if
condition|(
name|IsLiteral
condition|)
block|{
name|Abbv
operator|->
name|Add
argument_list|(
name|BitCodeAbbrevOp
argument_list|(
name|ReadVBR64
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BitCodeAbbrevOp
operator|::
name|Encoding
name|E
operator|=
operator|(
name|BitCodeAbbrevOp
operator|::
name|Encoding
operator|)
name|Read
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitCodeAbbrevOp
operator|::
name|hasEncodingData
argument_list|(
name|E
argument_list|)
condition|)
name|Abbv
operator|->
name|Add
argument_list|(
name|BitCodeAbbrevOp
argument_list|(
name|E
argument_list|,
name|ReadVBR64
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Abbv
operator|->
name|Add
argument_list|(
name|BitCodeAbbrevOp
argument_list|(
name|E
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CurAbbrevs
operator|.
name|push_back
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|bool
name|ReadBlockInfoBlock
parameter_list|()
block|{
comment|// If this is the second stream to get to the block info block, skip it.
if|if
condition|(
name|BitStream
operator|->
name|hasBlockInfoRecords
argument_list|()
condition|)
return|return
name|SkipBlock
argument_list|()
return|;
if|if
condition|(
name|EnterSubBlock
argument_list|(
name|bitc
operator|::
name|BLOCKINFO_BLOCK_ID
argument_list|)
condition|)
return|return
name|true
return|;
name|SmallVector
operator|<
name|uint64_t
operator|,
literal|64
operator|>
name|Record
expr_stmt|;
name|BitstreamReader
operator|::
name|BlockInfo
operator|*
name|CurBlockInfo
operator|=
literal|0
expr_stmt|;
comment|// Read all the records for this module.
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|Code
init|=
name|ReadCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|END_BLOCK
condition|)
return|return
name|ReadBlockEnd
argument_list|()
return|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|ENTER_SUBBLOCK
condition|)
block|{
name|ReadSubBlockID
argument_list|()
expr_stmt|;
if|if
condition|(
name|SkipBlock
argument_list|()
condition|)
return|return
name|true
return|;
continue|continue;
block|}
comment|// Read abbrev records, associate them with CurBID.
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|DEFINE_ABBREV
condition|)
block|{
if|if
condition|(
operator|!
name|CurBlockInfo
condition|)
return|return
name|true
return|;
name|ReadAbbrevRecord
argument_list|()
expr_stmt|;
comment|// ReadAbbrevRecord installs the abbrev in CurAbbrevs.  Move it to the
comment|// appropriate BlockInfo.
name|BitCodeAbbrev
modifier|*
name|Abbv
init|=
name|CurAbbrevs
operator|.
name|back
argument_list|()
decl_stmt|;
name|CurAbbrevs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|CurBlockInfo
operator|->
name|Abbrevs
operator|.
name|push_back
argument_list|(
name|Abbv
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Read a record.
name|Record
operator|.
name|clear
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ReadRecord
argument_list|(
name|Code
argument_list|,
name|Record
argument_list|)
condition|)
block|{
default|default:
break|break;
comment|// Default behavior, ignore unknown content.
case|case
name|bitc
operator|::
name|BLOCKINFO_CODE_SETBID
case|:
if|if
condition|(
name|Record
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
return|return
name|true
return|;
name|CurBlockInfo
operator|=
operator|&
name|BitStream
operator|->
name|getOrCreateBlockInfo
argument_list|(
operator|(
name|unsigned
operator|)
name|Record
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|bitc
operator|::
name|BLOCKINFO_CODE_BLOCKNAME
case|:
block|{
if|if
condition|(
operator|!
name|CurBlockInfo
condition|)
return|return
name|true
return|;
if|if
condition|(
name|BitStream
operator|->
name|isIgnoringBlockInfoNames
argument_list|()
condition|)
break|break;
comment|// Ignore name.
name|std
operator|::
name|string
name|Name
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Record
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Name
operator|+=
operator|(
name|char
operator|)
name|Record
index|[
name|i
index|]
expr_stmt|;
name|CurBlockInfo
operator|->
name|Name
operator|=
name|Name
expr_stmt|;
break|break;
block|}
case|case
name|bitc
operator|::
name|BLOCKINFO_CODE_SETRECORDNAME
case|:
block|{
if|if
condition|(
operator|!
name|CurBlockInfo
condition|)
return|return
name|true
return|;
if|if
condition|(
name|BitStream
operator|->
name|isIgnoringBlockInfoNames
argument_list|()
condition|)
break|break;
comment|// Ignore name.
name|std
operator|::
name|string
name|Name
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|,
name|e
init|=
name|Record
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Name
operator|+=
operator|(
name|char
operator|)
name|Record
index|[
name|i
index|]
expr_stmt|;
name|CurBlockInfo
operator|->
name|RecordNames
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|(
name|unsigned
operator|)
name|Record
index|[
literal|0
index|]
argument_list|,
name|Name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

