begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitstreamReader class.  This class can be used to
end_comment

begin_comment
comment|// read an arbitrary bitstream, regardless of its contents.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_BITCODE_BITSTREAMREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_BITCODE_BITSTREAMREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitCodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/StreamableMemoryObject.h"
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Deserializer
decl_stmt|;
comment|/// BitstreamReader - This class is used to read from an LLVM bitcode stream,
comment|/// maintaining information that is global to decoding the entire file.  While
comment|/// a file is being read, multiple cursors can be independently advanced or
comment|/// skipped around within the file.  These are represented by the
comment|/// BitstreamCursor class.
name|class
name|BitstreamReader
block|{
name|public
label|:
comment|/// BlockInfo - This contains information emitted to BLOCKINFO_BLOCK blocks.
comment|/// These describe abbreviations that all blocks of the specified ID inherit.
struct|struct
name|BlockInfo
block|{
name|unsigned
name|BlockID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|Abbrevs
expr_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
expr|>
name|RecordNames
expr_stmt|;
block|}
struct|;
name|private
label|:
name|OwningPtr
operator|<
name|StreamableMemoryObject
operator|>
name|BitcodeBytes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BlockInfoRecords
expr_stmt|;
comment|/// IgnoreBlockInfoNames - This is set to true if we don't care about the
comment|/// block/record name information in the BlockInfo block. Only llvm-bcanalyzer
comment|/// uses this.
name|bool
name|IgnoreBlockInfoNames
decl_stmt|;
name|BitstreamReader
argument_list|(
argument|const BitstreamReader&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|BitstreamReader
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|public
label|:
name|BitstreamReader
argument_list|()
operator|:
name|IgnoreBlockInfoNames
argument_list|(
argument|true
argument_list|)
block|{   }
name|BitstreamReader
argument_list|(
argument|const unsigned char *Start
argument_list|,
argument|const unsigned char *End
argument_list|)
block|{
name|IgnoreBlockInfoNames
operator|=
name|true
block|;
name|init
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
block|;   }
name|BitstreamReader
argument_list|(
argument|StreamableMemoryObject *bytes
argument_list|)
block|{
name|BitcodeBytes
operator|.
name|reset
argument_list|(
name|bytes
argument_list|)
block|;   }
name|void
name|init
argument_list|(
argument|const unsigned char *Start
argument_list|,
argument|const unsigned char *End
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|End
operator|-
name|Start
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
literal|"Bitcode stream not a multiple of 4 bytes"
argument_list|)
block|;
name|BitcodeBytes
operator|.
name|reset
argument_list|(
name|getNonStreamedMemoryObject
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
argument_list|)
block|;   }
name|StreamableMemoryObject
operator|&
name|getBitcodeBytes
argument_list|()
block|{
return|return
operator|*
name|BitcodeBytes
return|;
block|}
operator|~
name|BitstreamReader
argument_list|()
block|{
comment|// Free the BlockInfoRecords.
while|while
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
condition|)
block|{
name|BlockInfo
modifier|&
name|Info
init|=
name|BlockInfoRecords
operator|.
name|back
argument_list|()
decl_stmt|;
comment|// Free blockinfo abbrev info.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|Info
operator|.
name|Abbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Info
operator|.
name|Abbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|BlockInfoRecords
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
comment|/// CollectBlockInfoNames - This is called by clients that want block/record
comment|/// name information.
name|void
name|CollectBlockInfoNames
argument_list|()
block|{
name|IgnoreBlockInfoNames
operator|=
name|false
block|; }
name|bool
name|isIgnoringBlockInfoNames
argument_list|()
block|{
return|return
name|IgnoreBlockInfoNames
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Block Manipulation
comment|//===--------------------------------------------------------------------===//
comment|/// hasBlockInfoRecords - Return true if we've already read and processed the
comment|/// block info block for this Bitstream.  We only process it for the first
comment|/// cursor that walks over it.
name|bool
name|hasBlockInfoRecords
argument_list|()
specifier|const
block|{
return|return
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getBlockInfo - If there is block info for the specified ID, return it,
comment|/// otherwise return null.
specifier|const
name|BlockInfo
modifier|*
name|getBlockInfo
argument_list|(
name|unsigned
name|BlockID
argument_list|)
decl|const
block|{
comment|// Common case, the most recent entry matches BlockID.
if|if
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
operator|&&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockInfoRecords
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|BlockInfoRecords
index|[
name|i
index|]
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
name|BlockInfo
modifier|&
name|getOrCreateBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|BlockInfo
modifier|*
name|BI
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
return|return
operator|*
name|const_cast
operator|<
name|BlockInfo
operator|*
operator|>
operator|(
name|BI
operator|)
return|;
comment|// Otherwise, add a new record.
name|BlockInfoRecords
operator|.
name|push_back
argument_list|(
name|BlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|=
name|BlockID
expr_stmt|;
return|return
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/// BitstreamEntry - When advancing through a bitstream cursor, each advance can
comment|/// discover a few different kinds of entries:
comment|///   Error    - Malformed bitcode was found.
comment|///   EndBlock - We've reached the end of the current block, (or the end of the
comment|///              file, which is treated like a series of EndBlock records.
comment|///   SubBlock - This is the start of a new subblock of a specific ID.
comment|///   Record   - This is a record with a specific AbbrevID.
comment|///
struct|struct
name|BitstreamEntry
block|{
enum|enum
block|{
name|Error
block|,
name|EndBlock
block|,
name|SubBlock
block|,
name|Record
block|}
name|Kind
enum|;
name|unsigned
name|ID
decl_stmt|;
specifier|static
name|BitstreamEntry
name|getError
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Error
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getEndBlock
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|EndBlock
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getSubBlock
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|SubBlock
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|ID
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Record
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|AbbrevID
expr_stmt|;
return|return
name|E
return|;
block|}
block|}
struct|;
comment|/// BitstreamCursor - This represents a position within a bitcode file.  There
comment|/// may be multiple independent cursors reading within one bitstream, each
comment|/// maintaining their own local state.
comment|///
comment|/// Unlike iterators, BitstreamCursors are heavy-weight objects that should not
comment|/// be passed by value.
name|class
name|BitstreamCursor
block|{
name|friend
name|class
name|Deserializer
decl_stmt|;
name|BitstreamReader
modifier|*
name|BitStream
decl_stmt|;
name|size_t
name|NextChar
decl_stmt|;
comment|/// CurWord/word_t - This is the current data we have pulled from the stream
comment|/// but have not returned to the client.  This is specifically and
comment|/// intentionally defined to follow the word size of the host machine for
comment|/// efficiency.  We use word_t in places that are aware of this to make it
comment|/// perfectly explicit what is going on.
typedef|typedef
name|uint32_t
name|word_t
typedef|;
name|word_t
name|CurWord
decl_stmt|;
comment|/// BitsInCurWord - This is the number of bits in CurWord that are valid. This
comment|/// is always from [0...31/63] inclusive (depending on word size).
name|unsigned
name|BitsInCurWord
decl_stmt|;
comment|// CurCodeSize - This is the declared size of code values used for the current
comment|// block, in bits.
name|unsigned
name|CurCodeSize
decl_stmt|;
comment|/// CurAbbrevs - Abbrevs installed at in this block.
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|CurAbbrevs
expr_stmt|;
struct|struct
name|Block
block|{
name|unsigned
name|PrevCodeSize
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitCodeAbbrev
operator|*
operator|>
name|PrevAbbrevs
expr_stmt|;
name|explicit
name|Block
argument_list|(
argument|unsigned PCS
argument_list|)
block|:
name|PrevCodeSize
argument_list|(
argument|PCS
argument_list|)
block|{}
block|}
struct|;
comment|/// BlockScope - This tracks the codesize of parent blocks.
name|SmallVector
operator|<
name|Block
operator|,
literal|8
operator|>
name|BlockScope
expr_stmt|;
name|public
label|:
name|BitstreamCursor
argument_list|()
operator|:
name|BitStream
argument_list|(
literal|0
argument_list|)
operator|,
name|NextChar
argument_list|(
literal|0
argument_list|)
block|{   }
name|BitstreamCursor
argument_list|(
specifier|const
name|BitstreamCursor
operator|&
name|RHS
argument_list|)
operator|:
name|BitStream
argument_list|(
literal|0
argument_list|)
operator|,
name|NextChar
argument_list|(
literal|0
argument_list|)
block|{
name|operator
operator|=
operator|(
name|RHS
operator|)
block|;   }
name|explicit
name|BitstreamCursor
argument_list|(
name|BitstreamReader
operator|&
name|R
argument_list|)
operator|:
name|BitStream
argument_list|(
argument|&R
argument_list|)
block|{
name|NextChar
operator|=
literal|0
block|;
name|CurWord
operator|=
literal|0
block|;
name|BitsInCurWord
operator|=
literal|0
block|;
name|CurCodeSize
operator|=
literal|2
block|;   }
name|void
name|init
argument_list|(
argument|BitstreamReader&R
argument_list|)
block|{
name|freeState
argument_list|()
block|;
name|BitStream
operator|=
operator|&
name|R
block|;
name|NextChar
operator|=
literal|0
block|;
name|CurWord
operator|=
literal|0
block|;
name|BitsInCurWord
operator|=
literal|0
block|;
name|CurCodeSize
operator|=
literal|2
block|;   }
operator|~
name|BitstreamCursor
argument_list|()
block|{
name|freeState
argument_list|()
block|;   }
name|void
name|operator
operator|=
operator|(
specifier|const
name|BitstreamCursor
operator|&
name|RHS
operator|)
expr_stmt|;
name|void
name|freeState
parameter_list|()
function_decl|;
name|bool
name|isEndPos
parameter_list|(
name|size_t
name|pos
parameter_list|)
block|{
return|return
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|isObjectEnd
argument_list|(
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|pos
operator|)
argument_list|)
return|;
block|}
name|bool
name|canSkipToPos
argument_list|(
name|size_t
name|pos
argument_list|)
decl|const
block|{
comment|// pos can be skipped to if it is a valid address or one byte past the end.
return|return
name|pos
operator|==
literal|0
operator|||
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|isValidAddress
argument_list|(
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|pos
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
name|uint32_t
name|getWord
parameter_list|(
name|size_t
name|pos
parameter_list|)
block|{
name|uint8_t
name|buf
index|[
literal|4
index|]
init|=
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
decl_stmt|;
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|readBytes
argument_list|(
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|support
operator|::
name|ulittle32_t
operator|*
operator|>
operator|(
name|buf
operator|)
return|;
block|}
name|bool
name|AtEndOfStream
parameter_list|()
block|{
return|return
name|BitsInCurWord
operator|==
literal|0
operator|&&
name|isEndPos
argument_list|(
name|NextChar
argument_list|)
return|;
block|}
comment|/// getAbbrevIDWidth - Return the number of bits used to encode an abbrev #.
name|unsigned
name|getAbbrevIDWidth
argument_list|()
specifier|const
block|{
return|return
name|CurCodeSize
return|;
block|}
comment|/// GetCurrentBitNo - Return the bit # of the bit we are reading.
name|uint64_t
name|GetCurrentBitNo
argument_list|()
specifier|const
block|{
return|return
name|NextChar
operator|*
name|CHAR_BIT
operator|-
name|BitsInCurWord
return|;
block|}
name|BitstreamReader
modifier|*
name|getBitStreamReader
parameter_list|()
block|{
return|return
name|BitStream
return|;
block|}
specifier|const
name|BitstreamReader
operator|*
name|getBitStreamReader
argument_list|()
specifier|const
block|{
return|return
name|BitStream
return|;
block|}
comment|/// Flags that modify the behavior of advance().
enum|enum
block|{
comment|/// AF_DontPopBlockAtEnd - If this flag is used, the advance() method does
comment|/// not automatically pop the block scope when the end of a block is
comment|/// reached.
name|AF_DontPopBlockAtEnd
init|=
literal|1
block|,
comment|/// AF_DontAutoprocessAbbrevs - If this flag is used, abbrev entries are
comment|/// returned just like normal records.
name|AF_DontAutoprocessAbbrevs
init|=
literal|2
block|}
enum|;
comment|/// advance - Advance the current bitstream, returning the next entry in the
comment|/// stream.
name|BitstreamEntry
name|advance
parameter_list|(
name|unsigned
name|Flags
init|=
literal|0
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|Code
init|=
name|ReadCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|END_BLOCK
condition|)
block|{
comment|// Pop the end of the block unless Flags tells us not to.
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|AF_DontPopBlockAtEnd
operator|)
operator|&&
name|ReadBlockEnd
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
return|return
name|BitstreamEntry
operator|::
name|getEndBlock
argument_list|()
return|;
block|}
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|ENTER_SUBBLOCK
condition|)
return|return
name|BitstreamEntry
operator|::
name|getSubBlock
argument_list|(
name|ReadSubBlockID
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|DEFINE_ABBREV
operator|&&
operator|!
operator|(
name|Flags
operator|&
name|AF_DontAutoprocessAbbrevs
operator|)
condition|)
block|{
comment|// We read and accumulate abbrev's, the client can't do anything with
comment|// them anyway.
name|ReadAbbrevRecord
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
name|BitstreamEntry
operator|::
name|getRecord
argument_list|(
name|Code
argument_list|)
return|;
block|}
block|}
comment|/// advanceSkippingSubblocks - This is a convenience function for clients that
comment|/// don't expect any subblocks.  This just skips over them automatically.
name|BitstreamEntry
name|advanceSkippingSubblocks
parameter_list|(
name|unsigned
name|Flags
init|=
literal|0
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|// If we found a normal entry, return it.
name|BitstreamEntry
name|Entry
init|=
name|advance
argument_list|(
name|Flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|Entry
operator|.
name|Kind
operator|!=
name|BitstreamEntry
operator|::
name|SubBlock
condition|)
return|return
name|Entry
return|;
comment|// If we found a sub-block, just skip over it and check the next entry.
if|if
condition|(
name|SkipBlock
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
block|}
block|}
comment|/// JumpToBit - Reset the stream to the specified bit number.
name|void
name|JumpToBit
parameter_list|(
name|uint64_t
name|BitNo
parameter_list|)
block|{
name|uintptr_t
name|ByteNo
init|=
name|uintptr_t
argument_list|(
name|BitNo
operator|/
literal|8
argument_list|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|WordBitNo
init|=
name|unsigned
argument_list|(
name|BitNo
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|canSkipToPos
argument_list|(
name|ByteNo
argument_list|)
operator|&&
literal|"Invalid location"
argument_list|)
expr_stmt|;
comment|// Move the cursor to the right word.
name|NextChar
operator|=
name|ByteNo
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
name|CurWord
operator|=
literal|0
expr_stmt|;
comment|// Skip over any bits that are already consumed.
if|if
condition|(
name|WordBitNo
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
condition|)
name|Read64
argument_list|(
name|WordBitNo
argument_list|)
expr_stmt|;
else|else
name|Read
argument_list|(
name|WordBitNo
argument_list|)
expr_stmt|;
block|}
block|}
name|uint32_t
name|Read
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|assert
argument_list|(
name|NumBits
operator|&&
name|NumBits
operator|<=
literal|32
operator|&&
literal|"Cannot return zero or more than 32 bits!"
argument_list|)
expr_stmt|;
comment|// If the field is fully contained by CurWord, return it quickly.
if|if
condition|(
name|BitsInCurWord
operator|>=
name|NumBits
condition|)
block|{
name|uint32_t
name|R
init|=
name|uint32_t
argument_list|(
name|CurWord
argument_list|)
operator|&
operator|(
operator|~
literal|0U
operator|>>
operator|(
literal|32
operator|-
name|NumBits
operator|)
operator|)
decl_stmt|;
name|CurWord
operator|>>=
name|NumBits
expr_stmt|;
name|BitsInCurWord
operator|-=
name|NumBits
expr_stmt|;
return|return
name|R
return|;
block|}
comment|// If we run out of data, stop at the end of the stream.
if|if
condition|(
name|isEndPos
argument_list|(
name|NextChar
argument_list|)
condition|)
block|{
name|CurWord
operator|=
literal|0
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|uint32_t
name|R
init|=
name|uint32_t
argument_list|(
name|CurWord
argument_list|)
decl_stmt|;
comment|// Read the next word from the stream.
name|uint8_t
name|Array
index|[
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|readBytes
argument_list|(
name|NextChar
argument_list|,
sizeof|sizeof
argument_list|(
name|Array
argument_list|)
argument_list|,
name|Array
argument_list|)
expr_stmt|;
comment|// Handle big-endian byte-swapping if necessary.
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|word_t
operator|,
name|support
operator|::
name|little
operator|,
name|support
operator|::
name|unaligned
operator|>
name|EndianValue
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|EndianValue
argument_list|,
name|Array
argument_list|,
sizeof|sizeof
argument_list|(
name|Array
argument_list|)
argument_list|)
expr_stmt|;
name|CurWord
operator|=
name|EndianValue
expr_stmt|;
name|NextChar
operator|+=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
expr_stmt|;
comment|// Extract NumBits-BitsInCurWord from what we just read.
name|unsigned
name|BitsLeft
init|=
name|NumBits
operator|-
name|BitsInCurWord
decl_stmt|;
comment|// Be careful here, BitsLeft is in the range [1..32]/[1..64] inclusive.
name|R
operator||=
name|uint32_t
argument_list|(
operator|(
name|CurWord
operator|&
operator|(
name|word_t
argument_list|(
operator|~
literal|0ULL
argument_list|)
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
operator|-
name|BitsLeft
operator|)
operator|)
operator|)
operator|<<
name|BitsInCurWord
argument_list|)
expr_stmt|;
comment|// BitsLeft bits have just been used up from CurWord.  BitsLeft is in the
comment|// range [1..32]/[1..64] so be careful how we shift.
if|if
condition|(
name|BitsLeft
operator|!=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
condition|)
name|CurWord
operator|>>=
name|BitsLeft
expr_stmt|;
else|else
name|CurWord
operator|=
literal|0
expr_stmt|;
name|BitsInCurWord
operator|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
operator|-
name|BitsLeft
expr_stmt|;
return|return
name|R
return|;
block|}
name|uint64_t
name|Read64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
if|if
condition|(
name|NumBits
operator|<=
literal|32
condition|)
return|return
name|Read
argument_list|(
name|NumBits
argument_list|)
return|;
name|uint64_t
name|V
init|=
name|Read
argument_list|(
literal|32
argument_list|)
decl_stmt|;
return|return
name|V
operator||
operator|(
name|uint64_t
operator|)
name|Read
argument_list|(
name|NumBits
operator|-
literal|32
argument_list|)
operator|<<
literal|32
return|;
block|}
name|uint32_t
name|ReadVBR
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Piece
return|;
name|uint32_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
operator|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ReadVBR64 - Read a VBR that may have a value up to 64-bits in size.  The
comment|// chunk size of the VBR must still be<= 32 bits though.
name|uint64_t
name|ReadVBR64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|uint64_t
argument_list|(
name|Piece
argument_list|)
return|;
name|uint64_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
name|uint64_t
argument_list|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
name|private
label|:
name|void
name|SkipToFourByteBoundary
parameter_list|()
block|{
comment|// If word_t is 64-bits and if we've read less than 32 bits, just dump
comment|// the bits we have up to the next 32-bit boundary.
if|if
condition|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
operator|&&
name|BitsInCurWord
operator|>=
literal|32
condition|)
block|{
name|CurWord
operator|>>=
name|BitsInCurWord
operator|-
literal|32
expr_stmt|;
name|BitsInCurWord
operator|=
literal|32
expr_stmt|;
return|return;
block|}
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
name|CurWord
operator|=
literal|0
expr_stmt|;
block|}
name|public
label|:
name|unsigned
name|ReadCode
parameter_list|()
block|{
return|return
name|Read
argument_list|(
name|CurCodeSize
argument_list|)
return|;
block|}
comment|// Block header:
comment|//    [ENTER_SUBBLOCK, blockid, newcodelen,<align4bytes>, blocklen]
comment|/// ReadSubBlockID - Having read the ENTER_SUBBLOCK code, read the BlockID for
comment|/// the block.
name|unsigned
name|ReadSubBlockID
parameter_list|()
block|{
return|return
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|BlockIDWidth
argument_list|)
return|;
block|}
comment|/// SkipBlock - Having read the ENTER_SUBBLOCK abbrevid and a BlockID, skip
comment|/// over the body of this block.  If the block record is malformed, return
comment|/// true.
name|bool
name|SkipBlock
parameter_list|()
block|{
comment|// Read and ignore the codelen value.  Since we are skipping this block, we
comment|// don't care what code widths are used inside of it.
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
expr_stmt|;
name|SkipToFourByteBoundary
argument_list|()
expr_stmt|;
name|unsigned
name|NumFourBytes
init|=
name|Read
argument_list|(
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
decl_stmt|;
comment|// Check that the block wasn't partially defined, and that the offset isn't
comment|// bogus.
name|size_t
name|SkipTo
init|=
name|GetCurrentBitNo
argument_list|()
operator|+
name|NumFourBytes
operator|*
literal|4
operator|*
literal|8
decl_stmt|;
if|if
condition|(
name|AtEndOfStream
argument_list|()
operator|||
operator|!
name|canSkipToPos
argument_list|(
name|SkipTo
operator|/
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
name|JumpToBit
argument_list|(
name|SkipTo
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// EnterSubBlock - Having read the ENTER_SUBBLOCK abbrevid, enter
comment|/// the block, and return true if the block has an error.
name|bool
name|EnterSubBlock
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|unsigned
modifier|*
name|NumWordsP
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ReadBlockEnd
parameter_list|()
block|{
if|if
condition|(
name|BlockScope
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
comment|// Block tail:
comment|//    [END_BLOCK,<align4bytes>]
name|SkipToFourByteBoundary
argument_list|()
expr_stmt|;
name|popBlockScope
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|private
label|:
name|void
name|popBlockScope
parameter_list|()
block|{
name|CurCodeSize
operator|=
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevCodeSize
expr_stmt|;
comment|// Delete abbrevs from popped scope.
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|CurAbbrevs
index|[
name|i
index|]
operator|->
name|dropRef
argument_list|()
expr_stmt|;
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
operator|.
name|swap
argument_list|(
name|CurAbbrevs
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Record Processing
comment|//===--------------------------------------------------------------------===//
name|private
label|:
name|void
name|readAbbreviatedLiteral
argument_list|(
specifier|const
name|BitCodeAbbrevOp
operator|&
name|Op
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|)
decl_stmt|;
name|void
name|readAbbreviatedField
argument_list|(
specifier|const
name|BitCodeAbbrevOp
operator|&
name|Op
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|)
decl_stmt|;
name|void
name|skipAbbreviatedField
parameter_list|(
specifier|const
name|BitCodeAbbrevOp
modifier|&
name|Op
parameter_list|)
function_decl|;
name|public
label|:
comment|/// getAbbrev - Return the abbreviation for the specified AbbrevId.
specifier|const
name|BitCodeAbbrev
modifier|*
name|getAbbrev
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|unsigned
name|AbbrevNo
init|=
name|AbbrevID
operator|-
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
decl_stmt|;
name|assert
argument_list|(
name|AbbrevNo
operator|<
name|CurAbbrevs
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid abbrev #!"
argument_list|)
expr_stmt|;
return|return
name|CurAbbrevs
index|[
name|AbbrevNo
index|]
return|;
block|}
comment|/// skipRecord - Read the current record and discard it.
name|void
name|skipRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
function_decl|;
name|unsigned
name|readRecord
argument_list|(
name|unsigned
name|AbbrevID
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|,
name|StringRef
operator|*
name|Blob
operator|=
literal|0
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Abbrev Processing
comment|//===--------------------------------------------------------------------===//
name|void
name|ReadAbbrevRecord
parameter_list|()
function_decl|;
name|bool
name|ReadBlockInfoBlock
parameter_list|()
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

