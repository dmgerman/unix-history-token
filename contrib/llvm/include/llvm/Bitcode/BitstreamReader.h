begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitstreamReader class.  This class can be used to
end_comment

begin_comment
comment|// read an arbitrary bitstream, regardless of its contents.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_BITCODE_BITSTREAMREADER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_BITCODE_BITSTREAMREADER_H
end_define

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitCodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/StreamingMemoryObject.h"
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// This class is used to read from an LLVM bitcode stream, maintaining
comment|/// information that is global to decoding the entire file. While a file is
comment|/// being read, multiple cursors can be independently advanced or skipped around
comment|/// within the file.  These are represented by the BitstreamCursor class.
name|class
name|BitstreamReader
block|{
name|public
label|:
comment|/// This contains information emitted to BLOCKINFO_BLOCK blocks. These
comment|/// describe abbreviations that all blocks of the specified ID inherit.
struct|struct
name|BlockInfo
block|{
name|unsigned
name|BlockID
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|Abbrevs
expr_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
expr|>
name|RecordNames
expr_stmt|;
block|}
struct|;
name|private
label|:
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryObject
operator|>
name|BitcodeBytes
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BlockInfoRecords
expr_stmt|;
comment|/// This is set to true if we don't care about the block/record name
comment|/// information in the BlockInfo block. Only llvm-bcanalyzer uses this.
name|bool
name|IgnoreBlockInfoNames
decl_stmt|;
name|BitstreamReader
argument_list|(
specifier|const
name|BitstreamReader
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|BitstreamReader
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
name|BitstreamReader
argument_list|()
operator|:
name|IgnoreBlockInfoNames
argument_list|(
argument|true
argument_list|)
block|{   }
name|BitstreamReader
argument_list|(
argument|const unsigned char *Start
argument_list|,
argument|const unsigned char *End
argument_list|)
operator|:
name|IgnoreBlockInfoNames
argument_list|(
argument|true
argument_list|)
block|{
name|init
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
block|;   }
name|BitstreamReader
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryObject
operator|>
name|BitcodeBytes
argument_list|)
operator|:
name|BitcodeBytes
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|BitcodeBytes
argument_list|)
argument_list|)
operator|,
name|IgnoreBlockInfoNames
argument_list|(
argument|true
argument_list|)
block|{}
name|BitstreamReader
argument_list|(
argument|BitstreamReader&&Other
argument_list|)
block|{
operator|*
name|this
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
argument_list|)
block|;   }
name|BitstreamReader
operator|&
name|operator
operator|=
operator|(
name|BitstreamReader
operator|&&
name|Other
operator|)
block|{
name|BitcodeBytes
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
operator|.
name|BitcodeBytes
argument_list|)
block|;
comment|// Explicitly swap block info, so that nothing gets destroyed twice.
name|std
operator|::
name|swap
argument_list|(
name|BlockInfoRecords
argument_list|,
name|Other
operator|.
name|BlockInfoRecords
argument_list|)
block|;
name|IgnoreBlockInfoNames
operator|=
name|Other
operator|.
name|IgnoreBlockInfoNames
block|;
return|return
operator|*
name|this
return|;
block|}
name|void
name|init
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Start
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|End
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|End
operator|-
name|Start
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
literal|"Bitcode stream not a multiple of 4 bytes"
argument_list|)
expr_stmt|;
name|BitcodeBytes
operator|.
name|reset
argument_list|(
name|getNonStreamedMemoryObject
argument_list|(
name|Start
argument_list|,
name|End
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MemoryObject
modifier|&
name|getBitcodeBytes
parameter_list|()
block|{
return|return
operator|*
name|BitcodeBytes
return|;
block|}
comment|/// This is called by clients that want block/record name information.
name|void
name|CollectBlockInfoNames
parameter_list|()
block|{
name|IgnoreBlockInfoNames
operator|=
name|false
expr_stmt|;
block|}
name|bool
name|isIgnoringBlockInfoNames
parameter_list|()
block|{
return|return
name|IgnoreBlockInfoNames
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Block Manipulation
comment|//===--------------------------------------------------------------------===//
comment|/// Return true if we've already read and processed the block info block for
comment|/// this Bitstream. We only process it for the first cursor that walks over
comment|/// it.
name|bool
name|hasBlockInfoRecords
argument_list|()
specifier|const
block|{
return|return
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// If there is block info for the specified ID, return it, otherwise return
comment|/// null.
specifier|const
name|BlockInfo
modifier|*
name|getBlockInfo
argument_list|(
name|unsigned
name|BlockID
argument_list|)
decl|const
block|{
comment|// Common case, the most recent entry matches BlockID.
if|if
condition|(
operator|!
name|BlockInfoRecords
operator|.
name|empty
argument_list|()
operator|&&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|BlockInfoRecords
operator|.
name|size
argument_list|()
operator|)
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|BlockInfoRecords
index|[
name|i
index|]
operator|.
name|BlockID
operator|==
name|BlockID
condition|)
return|return
operator|&
name|BlockInfoRecords
index|[
name|i
index|]
return|;
return|return
name|nullptr
return|;
block|}
name|BlockInfo
modifier|&
name|getOrCreateBlockInfo
parameter_list|(
name|unsigned
name|BlockID
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|BlockInfo
modifier|*
name|BI
init|=
name|getBlockInfo
argument_list|(
name|BlockID
argument_list|)
condition|)
return|return
operator|*
name|const_cast
operator|<
name|BlockInfo
operator|*
operator|>
operator|(
name|BI
operator|)
return|;
comment|// Otherwise, add a new record.
name|BlockInfoRecords
operator|.
name|push_back
argument_list|(
name|BlockInfo
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfoRecords
operator|.
name|back
argument_list|()
operator|.
name|BlockID
operator|=
name|BlockID
expr_stmt|;
return|return
name|BlockInfoRecords
operator|.
name|back
argument_list|()
return|;
block|}
comment|/// Takes block info from the other bitstream reader.
comment|///
comment|/// This is a "take" operation because BlockInfo records are non-trivial, and
comment|/// indeed rather expensive.
name|void
name|takeBlockInfo
argument_list|(
name|BitstreamReader
operator|&&
name|Other
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|hasBlockInfoRecords
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfoRecords
operator|=
name|std
operator|::
name|move
argument_list|(
name|Other
operator|.
name|BlockInfoRecords
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// When advancing through a bitstream cursor, each advance can discover a few
comment|/// different kinds of entries:
struct|struct
name|BitstreamEntry
block|{
enum|enum
block|{
name|Error
block|,
comment|// Malformed bitcode was found.
name|EndBlock
block|,
comment|// We've reached the end of the current block, (or the end of the
comment|// file, which is treated like a series of EndBlock records.
name|SubBlock
block|,
comment|// This is the start of a new subblock of a specific ID.
name|Record
comment|// This is a record with a specific AbbrevID.
block|}
name|Kind
enum|;
name|unsigned
name|ID
decl_stmt|;
specifier|static
name|BitstreamEntry
name|getError
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Error
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getEndBlock
parameter_list|()
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|EndBlock
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getSubBlock
parameter_list|(
name|unsigned
name|ID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|SubBlock
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|ID
expr_stmt|;
return|return
name|E
return|;
block|}
specifier|static
name|BitstreamEntry
name|getRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|BitstreamEntry
name|E
decl_stmt|;
name|E
operator|.
name|Kind
operator|=
name|Record
expr_stmt|;
name|E
operator|.
name|ID
operator|=
name|AbbrevID
expr_stmt|;
return|return
name|E
return|;
block|}
block|}
struct|;
comment|/// This represents a position within a bitcode file. There may be multiple
comment|/// independent cursors reading within one bitstream, each maintaining their own
comment|/// local state.
comment|///
comment|/// Unlike iterators, BitstreamCursors are heavy-weight objects that should not
comment|/// be passed by value.
name|class
name|BitstreamCursor
block|{
name|BitstreamReader
modifier|*
name|BitStream
decl_stmt|;
name|size_t
name|NextChar
decl_stmt|;
comment|// The size of the bicode. 0 if we don't know it yet.
name|size_t
name|Size
decl_stmt|;
comment|/// This is the current data we have pulled from the stream but have not
comment|/// returned to the client. This is specifically and intentionally defined to
comment|/// follow the word size of the host machine for efficiency. We use word_t in
comment|/// places that are aware of this to make it perfectly explicit what is going
comment|/// on.
typedef|typedef
name|size_t
name|word_t
typedef|;
name|word_t
name|CurWord
decl_stmt|;
comment|/// This is the number of bits in CurWord that are valid. This is always from
comment|/// [0...bits_of(size_t)-1] inclusive.
name|unsigned
name|BitsInCurWord
decl_stmt|;
comment|// This is the declared size of code values used for the current block, in
comment|// bits.
name|unsigned
name|CurCodeSize
decl_stmt|;
comment|/// Abbrevs installed at in this block.
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|CurAbbrevs
expr_stmt|;
struct|struct
name|Block
block|{
name|unsigned
name|PrevCodeSize
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|IntrusiveRefCntPtr
operator|<
name|BitCodeAbbrev
operator|>>
name|PrevAbbrevs
expr_stmt|;
name|explicit
name|Block
argument_list|(
argument|unsigned PCS
argument_list|)
block|:
name|PrevCodeSize
argument_list|(
argument|PCS
argument_list|)
block|{}
block|}
struct|;
comment|/// This tracks the codesize of parent blocks.
name|SmallVector
operator|<
name|Block
operator|,
literal|8
operator|>
name|BlockScope
expr_stmt|;
name|public
label|:
specifier|static
specifier|const
name|size_t
name|MaxChunkSize
init|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
decl_stmt|;
name|BitstreamCursor
argument_list|()
block|{
name|init
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
block|}
name|explicit
name|BitstreamCursor
parameter_list|(
name|BitstreamReader
modifier|&
name|R
parameter_list|)
block|{
name|init
argument_list|(
operator|&
name|R
argument_list|)
expr_stmt|;
block|}
name|void
name|init
parameter_list|(
name|BitstreamReader
modifier|*
name|R
parameter_list|)
block|{
name|freeState
argument_list|()
expr_stmt|;
name|BitStream
operator|=
name|R
expr_stmt|;
name|NextChar
operator|=
literal|0
expr_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
name|CurCodeSize
operator|=
literal|2
expr_stmt|;
block|}
name|void
name|freeState
parameter_list|()
function_decl|;
name|bool
name|canSkipToPos
argument_list|(
name|size_t
name|pos
argument_list|)
decl|const
block|{
comment|// pos can be skipped to if it is a valid address or one byte past the end.
return|return
name|pos
operator|==
literal|0
operator|||
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|isValidAddress
argument_list|(
name|static_cast
operator|<
name|uint64_t
operator|>
operator|(
name|pos
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
name|bool
name|AtEndOfStream
parameter_list|()
block|{
if|if
condition|(
name|BitsInCurWord
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Size
operator|!=
literal|0
condition|)
return|return
name|Size
operator|==
name|NextChar
return|;
name|fillCurWord
argument_list|()
expr_stmt|;
return|return
name|BitsInCurWord
operator|==
literal|0
return|;
block|}
comment|/// Return the number of bits used to encode an abbrev #.
name|unsigned
name|getAbbrevIDWidth
argument_list|()
specifier|const
block|{
return|return
name|CurCodeSize
return|;
block|}
comment|/// Return the bit # of the bit we are reading.
name|uint64_t
name|GetCurrentBitNo
argument_list|()
specifier|const
block|{
return|return
name|NextChar
operator|*
name|CHAR_BIT
operator|-
name|BitsInCurWord
return|;
block|}
name|BitstreamReader
modifier|*
name|getBitStreamReader
parameter_list|()
block|{
return|return
name|BitStream
return|;
block|}
specifier|const
name|BitstreamReader
operator|*
name|getBitStreamReader
argument_list|()
specifier|const
block|{
return|return
name|BitStream
return|;
block|}
comment|/// Flags that modify the behavior of advance().
enum|enum
block|{
comment|/// If this flag is used, the advance() method does not automatically pop
comment|/// the block scope when the end of a block is reached.
name|AF_DontPopBlockAtEnd
init|=
literal|1
block|,
comment|/// If this flag is used, abbrev entries are returned just like normal
comment|/// records.
name|AF_DontAutoprocessAbbrevs
init|=
literal|2
block|}
enum|;
comment|/// Advance the current bitstream, returning the next entry in the stream.
name|BitstreamEntry
name|advance
parameter_list|(
name|unsigned
name|Flags
init|=
literal|0
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|Code
init|=
name|ReadCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|END_BLOCK
condition|)
block|{
comment|// Pop the end of the block unless Flags tells us not to.
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|AF_DontPopBlockAtEnd
operator|)
operator|&&
name|ReadBlockEnd
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
return|return
name|BitstreamEntry
operator|::
name|getEndBlock
argument_list|()
return|;
block|}
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|ENTER_SUBBLOCK
condition|)
return|return
name|BitstreamEntry
operator|::
name|getSubBlock
argument_list|(
name|ReadSubBlockID
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|Code
operator|==
name|bitc
operator|::
name|DEFINE_ABBREV
operator|&&
operator|!
operator|(
name|Flags
operator|&
name|AF_DontAutoprocessAbbrevs
operator|)
condition|)
block|{
comment|// We read and accumulate abbrev's, the client can't do anything with
comment|// them anyway.
name|ReadAbbrevRecord
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
name|BitstreamEntry
operator|::
name|getRecord
argument_list|(
name|Code
argument_list|)
return|;
block|}
block|}
comment|/// This is a convenience function for clients that don't expect any
comment|/// subblocks. This just skips over them automatically.
name|BitstreamEntry
name|advanceSkippingSubblocks
parameter_list|(
name|unsigned
name|Flags
init|=
literal|0
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|// If we found a normal entry, return it.
name|BitstreamEntry
name|Entry
init|=
name|advance
argument_list|(
name|Flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|Entry
operator|.
name|Kind
operator|!=
name|BitstreamEntry
operator|::
name|SubBlock
condition|)
return|return
name|Entry
return|;
comment|// If we found a sub-block, just skip over it and check the next entry.
if|if
condition|(
name|SkipBlock
argument_list|()
condition|)
return|return
name|BitstreamEntry
operator|::
name|getError
argument_list|()
return|;
block|}
block|}
comment|/// Reset the stream to the specified bit number.
name|void
name|JumpToBit
parameter_list|(
name|uint64_t
name|BitNo
parameter_list|)
block|{
name|size_t
name|ByteNo
init|=
name|size_t
argument_list|(
name|BitNo
operator|/
literal|8
argument_list|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|WordBitNo
init|=
name|unsigned
argument_list|(
name|BitNo
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|canSkipToPos
argument_list|(
name|ByteNo
argument_list|)
operator|&&
literal|"Invalid location"
argument_list|)
expr_stmt|;
comment|// Move the cursor to the right word.
name|NextChar
operator|=
name|ByteNo
expr_stmt|;
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
comment|// Skip over any bits that are already consumed.
if|if
condition|(
name|WordBitNo
condition|)
name|Read
argument_list|(
name|WordBitNo
argument_list|)
expr_stmt|;
block|}
name|void
name|fillCurWord
parameter_list|()
block|{
if|if
condition|(
name|Size
operator|!=
literal|0
operator|&&
name|NextChar
operator|>=
name|Size
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected end of file"
argument_list|)
expr_stmt|;
comment|// Read the next word from the stream.
name|uint8_t
name|Array
index|[
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|BytesRead
init|=
name|BitStream
operator|->
name|getBitcodeBytes
argument_list|()
operator|.
name|readBytes
argument_list|(
name|Array
argument_list|,
sizeof|sizeof
argument_list|(
name|Array
argument_list|)
argument_list|,
name|NextChar
argument_list|)
decl_stmt|;
comment|// If we run out of data, stop at the end of the stream.
if|if
condition|(
name|BytesRead
operator|==
literal|0
condition|)
block|{
name|Size
operator|=
name|NextChar
expr_stmt|;
return|return;
block|}
name|CurWord
operator|=
name|support
operator|::
name|endian
operator|::
name|read
operator|<
name|word_t
operator|,
name|support
operator|::
name|little
operator|,
name|support
operator|::
name|unaligned
operator|>
operator|(
name|Array
operator|)
expr_stmt|;
name|NextChar
operator|+=
name|BytesRead
expr_stmt|;
name|BitsInCurWord
operator|=
name|BytesRead
operator|*
literal|8
expr_stmt|;
block|}
name|word_t
name|Read
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|BitsInWord
init|=
name|MaxChunkSize
decl_stmt|;
name|assert
argument_list|(
name|NumBits
operator|&&
name|NumBits
operator|<=
name|BitsInWord
operator|&&
literal|"Cannot return zero or more than BitsInWord bits!"
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|unsigned
name|Mask
init|=
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
condition|?
literal|0x3f
else|:
literal|0x1f
decl_stmt|;
comment|// If the field is fully contained by CurWord, return it quickly.
if|if
condition|(
name|BitsInCurWord
operator|>=
name|NumBits
condition|)
block|{
name|word_t
name|R
init|=
name|CurWord
operator|&
operator|(
operator|~
name|word_t
argument_list|(
literal|0
argument_list|)
operator|>>
operator|(
name|BitsInWord
operator|-
name|NumBits
operator|)
operator|)
decl_stmt|;
comment|// Use a mask to avoid undefined behavior.
name|CurWord
operator|>>=
operator|(
name|NumBits
operator|&
name|Mask
operator|)
expr_stmt|;
name|BitsInCurWord
operator|-=
name|NumBits
expr_stmt|;
return|return
name|R
return|;
block|}
name|word_t
name|R
init|=
name|BitsInCurWord
condition|?
name|CurWord
else|:
literal|0
decl_stmt|;
name|unsigned
name|BitsLeft
init|=
name|NumBits
operator|-
name|BitsInCurWord
decl_stmt|;
name|fillCurWord
argument_list|()
expr_stmt|;
comment|// If we run out of data, stop at the end of the stream.
if|if
condition|(
name|BitsLeft
operator|>
name|BitsInCurWord
condition|)
return|return
literal|0
return|;
name|word_t
name|R2
init|=
name|CurWord
operator|&
operator|(
operator|~
name|word_t
argument_list|(
literal|0
argument_list|)
operator|>>
operator|(
name|BitsInWord
operator|-
name|BitsLeft
operator|)
operator|)
decl_stmt|;
comment|// Use a mask to avoid undefined behavior.
name|CurWord
operator|>>=
operator|(
name|BitsLeft
operator|&
name|Mask
operator|)
expr_stmt|;
name|BitsInCurWord
operator|-=
name|BitsLeft
expr_stmt|;
name|R
operator||=
name|R2
operator|<<
operator|(
name|NumBits
operator|-
name|BitsLeft
operator|)
expr_stmt|;
return|return
name|R
return|;
block|}
name|uint32_t
name|ReadVBR
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Piece
return|;
name|uint32_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
operator|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Read a VBR that may have a value up to 64-bits in size. The chunk size of
comment|// the VBR must still be<= 32 bits though.
name|uint64_t
name|ReadVBR64
parameter_list|(
name|unsigned
name|NumBits
parameter_list|)
block|{
name|uint32_t
name|Piece
init|=
name|Read
argument_list|(
name|NumBits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|uint64_t
argument_list|(
name|Piece
argument_list|)
return|;
name|uint64_t
name|Result
init|=
literal|0
decl_stmt|;
name|unsigned
name|NextBit
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Result
operator||=
name|uint64_t
argument_list|(
name|Piece
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|<<
name|NextBit
expr_stmt|;
if|if
condition|(
operator|(
name|Piece
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|NumBits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|Result
return|;
name|NextBit
operator|+=
name|NumBits
operator|-
literal|1
expr_stmt|;
name|Piece
operator|=
name|Read
argument_list|(
name|NumBits
argument_list|)
expr_stmt|;
block|}
block|}
name|private
label|:
name|void
name|SkipToFourByteBoundary
parameter_list|()
block|{
comment|// If word_t is 64-bits and if we've read less than 32 bits, just dump
comment|// the bits we have up to the next 32-bit boundary.
if|if
condition|(
sizeof|sizeof
argument_list|(
name|word_t
argument_list|)
operator|>
literal|4
operator|&&
name|BitsInCurWord
operator|>=
literal|32
condition|)
block|{
name|CurWord
operator|>>=
name|BitsInCurWord
operator|-
literal|32
expr_stmt|;
name|BitsInCurWord
operator|=
literal|32
expr_stmt|;
return|return;
block|}
name|BitsInCurWord
operator|=
literal|0
expr_stmt|;
block|}
name|public
label|:
name|unsigned
name|ReadCode
parameter_list|()
block|{
return|return
name|Read
argument_list|(
name|CurCodeSize
argument_list|)
return|;
block|}
comment|// Block header:
comment|//    [ENTER_SUBBLOCK, blockid, newcodelen,<align4bytes>, blocklen]
comment|/// Having read the ENTER_SUBBLOCK code, read the BlockID for the block.
name|unsigned
name|ReadSubBlockID
parameter_list|()
block|{
return|return
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|BlockIDWidth
argument_list|)
return|;
block|}
comment|/// Having read the ENTER_SUBBLOCK abbrevid and a BlockID, skip over the body
comment|/// of this block. If the block record is malformed, return true.
name|bool
name|SkipBlock
parameter_list|()
block|{
comment|// Read and ignore the codelen value.  Since we are skipping this block, we
comment|// don't care what code widths are used inside of it.
name|ReadVBR
argument_list|(
name|bitc
operator|::
name|CodeLenWidth
argument_list|)
expr_stmt|;
name|SkipToFourByteBoundary
argument_list|()
expr_stmt|;
name|unsigned
name|NumFourBytes
init|=
name|Read
argument_list|(
name|bitc
operator|::
name|BlockSizeWidth
argument_list|)
decl_stmt|;
comment|// Check that the block wasn't partially defined, and that the offset isn't
comment|// bogus.
name|size_t
name|SkipTo
init|=
name|GetCurrentBitNo
argument_list|()
operator|+
name|NumFourBytes
operator|*
literal|4
operator|*
literal|8
decl_stmt|;
if|if
condition|(
name|AtEndOfStream
argument_list|()
operator|||
operator|!
name|canSkipToPos
argument_list|(
name|SkipTo
operator|/
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
name|JumpToBit
argument_list|(
name|SkipTo
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/// Having read the ENTER_SUBBLOCK abbrevid, enter the block, and return true
comment|/// if the block has an error.
name|bool
name|EnterSubBlock
parameter_list|(
name|unsigned
name|BlockID
parameter_list|,
name|unsigned
modifier|*
name|NumWordsP
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|ReadBlockEnd
parameter_list|()
block|{
if|if
condition|(
name|BlockScope
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
comment|// Block tail:
comment|//    [END_BLOCK,<align4bytes>]
name|SkipToFourByteBoundary
argument_list|()
expr_stmt|;
name|popBlockScope
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|private
label|:
name|void
name|popBlockScope
parameter_list|()
block|{
name|CurCodeSize
operator|=
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevCodeSize
expr_stmt|;
name|CurAbbrevs
operator|=
name|std
operator|::
name|move
argument_list|(
name|BlockScope
operator|.
name|back
argument_list|()
operator|.
name|PrevAbbrevs
argument_list|)
expr_stmt|;
name|BlockScope
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Record Processing
comment|//===--------------------------------------------------------------------===//
name|public
label|:
comment|/// Return the abbreviation for the specified AbbrevId.
specifier|const
name|BitCodeAbbrev
modifier|*
name|getAbbrev
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
block|{
name|unsigned
name|AbbrevNo
init|=
name|AbbrevID
operator|-
name|bitc
operator|::
name|FIRST_APPLICATION_ABBREV
decl_stmt|;
if|if
condition|(
name|AbbrevNo
operator|>=
name|CurAbbrevs
operator|.
name|size
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Invalid abbrev number"
argument_list|)
expr_stmt|;
return|return
name|CurAbbrevs
index|[
name|AbbrevNo
index|]
operator|.
name|get
argument_list|()
return|;
block|}
comment|/// Read the current record and discard it.
name|void
name|skipRecord
parameter_list|(
name|unsigned
name|AbbrevID
parameter_list|)
function_decl|;
name|unsigned
name|readRecord
argument_list|(
name|unsigned
name|AbbrevID
argument_list|,
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
operator|&
name|Vals
argument_list|,
name|StringRef
operator|*
name|Blob
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Abbrev Processing
comment|//===--------------------------------------------------------------------===//
name|void
name|ReadAbbrevRecord
parameter_list|()
function_decl|;
name|bool
name|ReadBlockInfoBlock
parameter_list|()
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

