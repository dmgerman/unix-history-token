begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/TableGen/Record.h - Classes for Table Records -------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the main TableGen data structures, including the TableGen
end_comment

begin_comment
comment|// types, values, and high-level data structures.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TABLEGEN_RECORD_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TABLEGEN_RECORD_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SMLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ListRecTy
decl_stmt|;
struct_decl|struct
name|MultiClass
struct_decl|;
name|class
name|Record
decl_stmt|;
name|class
name|RecordVal
decl_stmt|;
name|class
name|RecordKeeper
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|//  Type Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|RecTy
block|{
name|public
label|:
comment|/// \brief Subclass discriminator (for dyn_cast<> et al.)
enum|enum
name|RecTyKind
block|{
name|BitRecTyKind
block|,
name|BitsRecTyKind
block|,
name|IntRecTyKind
block|,
name|StringRecTyKind
block|,
name|ListRecTyKind
block|,
name|DagRecTyKind
block|,
name|RecordRecTyKind
block|}
enum|;
name|private
label|:
name|RecTyKind
name|Kind
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ListRecTy
operator|>
name|ListTy
expr_stmt|;
name|public
label|:
name|RecTyKind
name|getRecTyKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|RecTy
argument_list|(
argument|RecTyKind K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|virtual
operator|~
name|RecTy
argument_list|()
block|{}
name|virtual
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
name|OS
operator|<<
name|getAsString
argument_list|()
expr_stmt|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// typeIsConvertibleTo - Return true if all values of 'this' type can be
comment|/// converted to the specified type.
name|virtual
name|bool
name|typeIsConvertibleTo
argument_list|(
specifier|const
name|RecTy
operator|*
name|RHS
argument_list|)
decl|const
decl_stmt|;
comment|/// getListTy - Returns the type representing list<this>.
name|ListRecTy
modifier|*
name|getListTy
parameter_list|()
function_decl|;
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|RecTy
operator|&
name|Ty
operator|)
block|{
name|Ty
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// BitRecTy - 'bit' - Represent a single bit
comment|///
name|class
name|BitRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|BitRecTy
name|Shared
block|;
name|BitRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|BitRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|BitRecTyKind
return|;
block|}
specifier|static
name|BitRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"bit"
return|;
block|}
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// BitsRecTy - 'bits<n>' - Represent a fixed number of bits
comment|///
name|class
name|BitsRecTy
range|:
name|public
name|RecTy
block|{
name|unsigned
name|Size
block|;
name|explicit
name|BitsRecTy
argument_list|(
argument|unsigned Sz
argument_list|)
operator|:
name|RecTy
argument_list|(
name|BitsRecTyKind
argument_list|)
block|,
name|Size
argument_list|(
argument|Sz
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|BitsRecTyKind
return|;
block|}
specifier|static
name|BitsRecTy
operator|*
name|get
argument_list|(
argument|unsigned Sz
argument_list|)
block|;
name|unsigned
name|getNumBits
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// IntRecTy - 'int' - Represent an integer value of no particular size
comment|///
name|class
name|IntRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|IntRecTy
name|Shared
block|;
name|IntRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|IntRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|IntRecTyKind
return|;
block|}
specifier|static
name|IntRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"int"
return|;
block|}
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// StringRecTy - 'string' - Represent an string value
comment|///
name|class
name|StringRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|StringRecTy
name|Shared
block|;
name|StringRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|StringRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|StringRecTyKind
return|;
block|}
specifier|static
name|StringRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// ListRecTy - 'list<Ty>' - Represent a list of values, all of which must be of
comment|/// the specified type.
comment|///
name|class
name|ListRecTy
range|:
name|public
name|RecTy
block|{
name|RecTy
operator|*
name|Ty
block|;
name|explicit
name|ListRecTy
argument_list|(
name|RecTy
operator|*
name|T
argument_list|)
operator|:
name|RecTy
argument_list|(
name|ListRecTyKind
argument_list|)
block|,
name|Ty
argument_list|(
argument|T
argument_list|)
block|{}
name|friend
name|ListRecTy
operator|*
name|RecTy
operator|::
name|getListTy
argument_list|()
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|ListRecTyKind
return|;
block|}
specifier|static
name|ListRecTy
operator|*
name|get
argument_list|(
argument|RecTy *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getListTy
argument_list|()
return|;
block|}
name|RecTy
operator|*
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// DagRecTy - 'dag' - Represent a dag fragment
comment|///
name|class
name|DagRecTy
range|:
name|public
name|RecTy
block|{
specifier|static
name|DagRecTy
name|Shared
block|;
name|DagRecTy
argument_list|()
operator|:
name|RecTy
argument_list|(
argument|DagRecTyKind
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|DagRecTyKind
return|;
block|}
specifier|static
name|DagRecTy
operator|*
name|get
argument_list|()
block|{
return|return
operator|&
name|Shared
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// RecordRecTy - '[classname]' - Represent an instance of a class, such as:
comment|/// (R32 X = EAX).
comment|///
name|class
name|RecordRecTy
range|:
name|public
name|RecTy
block|{
name|Record
operator|*
name|Rec
block|;
name|explicit
name|RecordRecTy
argument_list|(
name|Record
operator|*
name|R
argument_list|)
operator|:
name|RecTy
argument_list|(
name|RecordRecTyKind
argument_list|)
block|,
name|Rec
argument_list|(
argument|R
argument_list|)
block|{}
name|friend
name|class
name|Record
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const RecTy *RT
argument_list|)
block|{
return|return
name|RT
operator|->
name|getRecTyKind
argument_list|()
operator|==
name|RecordRecTyKind
return|;
block|}
specifier|static
name|RecordRecTy
operator|*
name|get
argument_list|(
name|Record
operator|*
name|R
argument_list|)
block|;
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|Rec
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|bool
name|typeIsConvertibleTo
argument_list|(
argument|const RecTy *RHS
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// resolveTypes - Find a common type that T1 and T2 convert to.
comment|/// Return 0 if no such type exists.
comment|///
name|RecTy
modifier|*
name|resolveTypes
parameter_list|(
name|RecTy
modifier|*
name|T1
parameter_list|,
name|RecTy
modifier|*
name|T2
parameter_list|)
function_decl|;
comment|//===----------------------------------------------------------------------===//
comment|//  Initializer Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|Init
block|{
name|protected
label|:
comment|/// \brief Discriminator enum (for isa<>, dyn_cast<>, et al.)
comment|///
comment|/// This enum is laid out by a preorder traversal of the inheritance
comment|/// hierarchy, and does not contain an entry for abstract classes, as per
comment|/// the recommendation in docs/HowToSetUpLLVMStyleRTTI.rst.
comment|///
comment|/// We also explicitly include "first" and "last" values for each
comment|/// interior node of the inheritance tree, to make it easier to read the
comment|/// corresponding classof().
comment|///
comment|/// We could pack these a bit tighter by not having the IK_FirstXXXInit
comment|/// and IK_LastXXXInit be their own values, but that would degrade
comment|/// readability for really no benefit.
enum|enum
name|InitKind
block|{
name|IK_BitInit
block|,
name|IK_FirstTypedInit
block|,
name|IK_BitsInit
block|,
name|IK_DagInit
block|,
name|IK_DefInit
block|,
name|IK_FieldInit
block|,
name|IK_IntInit
block|,
name|IK_ListInit
block|,
name|IK_FirstOpInit
block|,
name|IK_BinOpInit
block|,
name|IK_TernOpInit
block|,
name|IK_UnOpInit
block|,
name|IK_LastOpInit
block|,
name|IK_StringInit
block|,
name|IK_VarInit
block|,
name|IK_VarListElementInit
block|,
name|IK_LastTypedInit
block|,
name|IK_UnsetInit
block|,
name|IK_VarBitInit
block|}
enum|;
name|private
label|:
specifier|const
name|InitKind
name|Kind
decl_stmt|;
name|Init
argument_list|(
specifier|const
name|Init
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|Init
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Init
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
name|public
label|:
name|InitKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|protected
label|:
name|explicit
name|Init
argument_list|(
argument|InitKind K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|public
label|:
name|virtual
operator|~
name|Init
argument_list|()
block|{}
comment|/// isComplete - This virtual method should be overridden by values that may
comment|/// not be completely specified yet.
name|virtual
name|bool
name|isComplete
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
comment|/// print - Print out this value.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
name|OS
operator|<<
name|getAsString
argument_list|()
expr_stmt|;
block|}
comment|/// getAsString - Convert this value to a string form.
name|virtual
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|/// getAsUnquotedString - Convert this value to a string form,
comment|/// without adding quote markers.  This primaruly affects
comment|/// StringInits where we will not surround the string value with
comment|/// quotes.
name|virtual
name|std
operator|::
name|string
name|getAsUnquotedString
argument_list|()
specifier|const
block|{
return|return
name|getAsString
argument_list|()
return|;
block|}
comment|/// dump - Debugging method that may be called through a debugger, just
comment|/// invokes print on stderr.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// convertInitializerTo - This virtual function converts to the appropriate
comment|/// Init based on the passed in type.
name|virtual
name|Init
modifier|*
name|convertInitializerTo
argument_list|(
name|RecTy
operator|*
name|Ty
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
comment|/// convertInitializerBitRange - This method is used to implement the bitrange
comment|/// selection operator.  Given an initializer, it selects the specified bits
comment|/// out, returning them as a new init of bits type.  If it is not legal to use
comment|/// the bit subscript operator on this initializer, return null.
comment|///
name|virtual
name|Init
modifier|*
name|convertInitializerBitRange
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|Bits
argument_list|)
decl|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// convertInitListSlice - This method is used to implement the list slice
comment|/// selection operator.  Given an initializer, it selects the specified list
comment|/// elements, returning them as a new init of list type.  If it is not legal
comment|/// to take a slice of this, return null.
comment|///
name|virtual
name|Init
modifier|*
name|convertInitListSlice
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|&
name|Elements
argument_list|)
decl|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// getFieldType - This method is used to implement the FieldInit class.
comment|/// Implementors of this method should return the type of the named field if
comment|/// they are of record type.
comment|///
name|virtual
name|RecTy
modifier|*
name|getFieldType
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|FieldName
argument_list|)
decl|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// getFieldInit - This method complements getFieldType to return the
comment|/// initializer for the specified field.  If getFieldType returns non-null
comment|/// this method should return non-null, otherwise it returns null.
comment|///
name|virtual
name|Init
modifier|*
name|getFieldInit
argument_list|(
name|Record
operator|&
name|R
argument_list|,
specifier|const
name|RecordVal
operator|*
name|RV
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|FieldName
argument_list|)
decl|const
block|{
return|return
name|nullptr
return|;
block|}
comment|/// resolveReferences - This method is used by classes that refer to other
comment|/// variables which may not be defined at the time the expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|virtual
name|Init
modifier|*
name|resolveReferences
argument_list|(
name|Record
operator|&
name|R
argument_list|,
specifier|const
name|RecordVal
operator|*
name|RV
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|Init
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|/// getBit - This method is used to return the initializer for the specified
comment|/// bit.
name|virtual
name|Init
modifier|*
name|getBit
argument_list|(
name|unsigned
name|Bit
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
comment|/// getBitVar - This method is used to retrieve the initializer for bit
comment|/// reference. For non-VarBitInit, it simply returns itself.
name|virtual
name|Init
operator|*
name|getBitVar
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Init
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|/// getBitNum - This method is used to retrieve the bit number of a bit
comment|/// reference. For non-VarBitInit, it simply returns 0.
name|virtual
name|unsigned
name|getBitNum
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Init
operator|&
name|I
operator|)
block|{
name|I
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
comment|/// TypedInit - This is the common super-class of types that have a specific,
comment|/// explicit, type.
comment|///
name|class
name|TypedInit
range|:
name|public
name|Init
block|{
name|RecTy
operator|*
name|Ty
block|;
name|TypedInit
argument_list|(
specifier|const
name|TypedInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|TypedInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TypedInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|protected
operator|:
name|explicit
name|TypedInit
argument_list|(
argument|InitKind K
argument_list|,
argument|RecTy *T
argument_list|)
operator|:
name|Init
argument_list|(
name|K
argument_list|)
block|,
name|Ty
argument_list|(
argument|T
argument_list|)
block|{}
operator|~
name|TypedInit
argument_list|()
block|{
comment|// If this is a DefInit we need to delete the RecordRecTy.
if|if
condition|(
name|getKind
argument_list|()
operator|==
name|IK_DefInit
condition|)
name|delete
name|Ty
decl_stmt|;
block|}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|>=
name|IK_FirstTypedInit
operator|&&
name|I
operator|->
name|getKind
argument_list|()
operator|<=
name|IK_LastTypedInit
return|;
block|}
name|RecTy
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|const std::vector<unsigned>&Bits
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitListSlice
argument_list|(
argument|const std::vector<unsigned>&Elements
argument_list|)
specifier|const
name|override
block|;
comment|/// getFieldType - This method is used to implement the FieldInit class.
comment|/// Implementors of this method should return the type of the named field if
comment|/// they are of record type.
comment|///
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|const std::string&FieldName
argument_list|)
specifier|const
name|override
block|;
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|virtual
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
operator|=
literal|0
block|; }
decl_stmt|;
comment|/// UnsetInit - ? - Represents an uninitialized value
comment|///
name|class
name|UnsetInit
range|:
name|public
name|Init
block|{
name|UnsetInit
argument_list|()
operator|:
name|Init
argument_list|(
argument|IK_UnsetInit
argument_list|)
block|{}
name|UnsetInit
argument_list|(
specifier|const
name|UnsetInit
operator|&
argument_list|)
operator|=
name|delete
block|;
name|UnsetInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|UnsetInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_UnsetInit
return|;
block|}
specifier|static
name|UnsetInit
operator|*
name|get
argument_list|()
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
return|return
name|const_cast
operator|<
name|UnsetInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"?"
return|;
block|}
expr|}
block|;
comment|/// BitInit - true/false - Represent a concrete initializer for a bit.
comment|///
name|class
name|BitInit
operator|:
name|public
name|Init
block|{
name|bool
name|Value
block|;
name|explicit
name|BitInit
argument_list|(
argument|bool V
argument_list|)
operator|:
name|Init
argument_list|(
name|IK_BitInit
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|BitInit
argument_list|(
specifier|const
name|BitInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BitInit
operator|&
name|operator
operator|=
operator|(
name|BitInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BitInit
return|;
block|}
specifier|static
name|BitInit
operator|*
name|get
argument_list|(
argument|bool V
argument_list|)
block|;
name|bool
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Bit
operator|<
literal|1
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|BitInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Value
operator|?
literal|"1"
operator|:
literal|"0"
return|;
block|}
expr|}
block|;
comment|/// BitsInit - { a, b, c } - Represents an initializer for a BitsRecTy value.
comment|/// It contains a vector of bits, whose size is determined by the type.
comment|///
name|class
name|BitsInit
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|{
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
name|Bits
block|;
name|BitsInit
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_BitsInit
argument_list|,
name|BitsRecTy
operator|::
name|get
argument_list|(
name|Range
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
block|,
name|Bits
argument_list|(
argument|Range.begin()
argument_list|,
argument|Range.end()
argument_list|)
block|{}
name|BitsInit
argument_list|(
specifier|const
name|BitsInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BitsInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|BitsInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BitsInit
return|;
block|}
specifier|static
name|BitsInit
operator|*
name|get
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|unsigned
name|getNumBits
argument_list|()
specifier|const
block|{
return|return
name|Bits
operator|.
name|size
argument_list|()
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|const std::vector<unsigned>&Bits
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|getNumBits
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|getBit
argument_list|(
name|i
argument_list|)
operator|->
name|isComplete
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|allInComplete
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|getNumBits
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getBit
argument_list|(
name|i
argument_list|)
operator|->
name|isComplete
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off bits<n>"
argument_list|)
block|;   }
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Bit
operator|<
name|Bits
operator|.
name|size
argument_list|()
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|Bits
index|[
name|Bit
index|]
return|;
block|}
expr|}
block|;
comment|/// IntInit - 7 - Represent an initialization by a literal integer value.
comment|///
name|class
name|IntInit
operator|:
name|public
name|TypedInit
block|{
name|int64_t
name|Value
block|;
name|explicit
name|IntInit
argument_list|(
argument|int64_t V
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_IntInit
argument_list|,
name|IntRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|IntInit
argument_list|(
specifier|const
name|IntInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|IntInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|IntInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_IntInit
return|;
block|}
specifier|static
name|IntInit
operator|*
name|get
argument_list|(
argument|int64_t V
argument_list|)
block|;
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerBitRange
argument_list|(
argument|const std::vector<unsigned>&Bits
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off int"
argument_list|)
block|;   }
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
return|return
name|BitInit
operator|::
name|get
argument_list|(
operator|(
name|Value
operator|&
operator|(
literal|1ULL
operator|<<
name|Bit
operator|)
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// StringInit - "foo" - Represent an initialization by a string value.
comment|///
name|class
name|StringInit
operator|:
name|public
name|TypedInit
block|{
name|std
operator|::
name|string
name|Value
block|;
name|explicit
name|StringInit
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|V
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_StringInit
argument_list|,
name|StringRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|V
argument_list|)
block|{}
name|StringInit
argument_list|(
specifier|const
name|StringInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|StringInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|StringInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_StringInit
return|;
block|}
specifier|static
name|StringInit
operator|*
name|get
argument_list|(
name|StringRef
argument_list|)
block|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"\""
operator|+
name|Value
operator|+
literal|"\""
return|;
block|}
name|std
operator|::
name|string
name|getAsUnquotedString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Value
return|;
block|}
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off string"
argument_list|)
block|;   }
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off string"
argument_list|)
block|;   }
expr|}
block|;
comment|/// ListInit - [AL, AH, CL] - Represent a list of defs
comment|///
name|class
name|ListInit
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|{
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
name|Values
block|;
name|public
operator|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|private
operator|:
name|explicit
name|ListInit
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|,
name|RecTy
operator|*
name|EltTy
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_ListInit
argument_list|,
name|ListRecTy
operator|::
name|get
argument_list|(
name|EltTy
argument_list|)
argument_list|)
block|,
name|Values
argument_list|(
argument|Range.begin()
argument_list|,
argument|Range.end()
argument_list|)
block|{}
name|ListInit
argument_list|(
specifier|const
name|ListInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|ListInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ListInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_ListInit
return|;
block|}
specifier|static
name|ListInit
operator|*
name|get
argument_list|(
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|Range
argument_list|,
name|RecTy
operator|*
name|EltTy
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|getElement
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|Values
operator|.
name|size
argument_list|()
operator|&&
literal|"List element index out of range!"
argument_list|)
block|;
return|return
name|Values
index|[
name|i
index|]
return|;
block|}
name|Record
operator|*
name|getElementAsRecord
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|convertInitListSlice
argument_list|(
argument|const std::vector<unsigned>&Elements
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
comment|/// resolveReferences - This method is used by classes that refer to other
comment|/// variables which may not be defined at the time they expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|getValues
argument_list|()
specifier|const
block|{
return|return
name|Values
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Values
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Values
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Values
operator|.
name|size
argument_list|()
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Values
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off list"
argument_list|)
block|;   }
block|}
block|;
comment|/// OpInit - Base class for operators
comment|///
name|class
name|OpInit
operator|:
name|public
name|TypedInit
block|{
name|OpInit
argument_list|(
specifier|const
name|OpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|OpInit
operator|&
name|operator
operator|=
operator|(
name|OpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|protected
operator|:
name|explicit
name|OpInit
argument_list|(
argument|InitKind K
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|TypedInit
argument_list|(
argument|K
argument_list|,
argument|Type
argument_list|)
block|{}
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|>=
name|IK_FirstOpInit
operator|&&
name|I
operator|->
name|getKind
argument_list|()
operator|<=
name|IK_LastOpInit
return|;
block|}
comment|// Clone - Clone this operator, replacing arguments with the new list
name|virtual
name|OpInit
operator|*
name|clone
argument_list|(
argument|std::vector<Init *>&Operands
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|virtual
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|virtual
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// UnOpInit - !op (X) - Transform an init.
comment|///
name|class
name|UnOpInit
operator|:
name|public
name|OpInit
block|{
name|public
operator|:
expr|enum
name|UnaryOp
block|{
name|CAST
block|,
name|HEAD
block|,
name|TAIL
block|,
name|EMPTY
block|}
block|;
name|private
operator|:
name|UnaryOp
name|Opc
block|;
name|Init
operator|*
name|LHS
block|;
name|UnOpInit
argument_list|(
argument|UnaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_UnOpInit
argument_list|,
name|Type
argument_list|)
block|,
name|Opc
argument_list|(
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
argument|lhs
argument_list|)
block|{}
name|UnOpInit
argument_list|(
specifier|const
name|UnOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|UnOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|UnOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_UnOpInit
return|;
block|}
specifier|static
name|UnOpInit
operator|*
name|get
argument_list|(
argument|UnaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|std::vector<Init *>&Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Wrong number of operands for unary operation"
argument_list|)
block|;
return|return
name|UnOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
operator|*
name|Operands
operator|.
name|begin
argument_list|()
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|i
operator|==
literal|0
operator|&&
literal|"Invalid operand id for unary operator"
argument_list|)
block|;
return|return
name|getOperand
argument_list|()
return|;
block|}
name|UnaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opc
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// BinOpInit - !op (X, Y) - Combine two inits.
comment|///
name|class
name|BinOpInit
operator|:
name|public
name|OpInit
block|{
name|public
operator|:
expr|enum
name|BinaryOp
block|{
name|ADD
block|,
name|AND
block|,
name|SHL
block|,
name|SRA
block|,
name|SRL
block|,
name|LISTCONCAT
block|,
name|STRCONCAT
block|,
name|CONCAT
block|,
name|EQ
block|}
block|;
name|private
operator|:
name|BinaryOp
name|Opc
block|;
name|Init
operator|*
name|LHS
block|,
operator|*
name|RHS
block|;
name|BinOpInit
argument_list|(
argument|BinaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_BinOpInit
argument_list|,
name|Type
argument_list|)
block|,
name|Opc
argument_list|(
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|BinOpInit
argument_list|(
specifier|const
name|BinOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|BinOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|BinOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_BinOpInit
return|;
block|}
specifier|static
name|BinOpInit
operator|*
name|get
argument_list|(
argument|BinaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|std::vector<Init *>&Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
literal|"Wrong number of operands for binary operation"
argument_list|)
block|;
return|return
name|BinOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
name|Operands
index|[
literal|0
index|]
argument_list|,
name|Operands
index|[
literal|1
index|]
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid operand id for binary operator"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
return|return
name|getLHS
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|getRHS
argument_list|()
return|;
block|}
block|}
name|BinaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opc
return|;
block|}
name|Init
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
name|Init
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// TernOpInit - !op (X, Y, Z) - Combine two inits.
comment|///
name|class
name|TernOpInit
operator|:
name|public
name|OpInit
block|{
name|public
operator|:
expr|enum
name|TernaryOp
block|{
name|SUBST
block|,
name|FOREACH
block|,
name|IF
block|}
block|;
name|private
operator|:
name|TernaryOp
name|Opc
block|;
name|Init
operator|*
name|LHS
block|,
operator|*
name|MHS
block|,
operator|*
name|RHS
block|;
name|TernOpInit
argument_list|(
argument|TernaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *mhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
operator|:
name|OpInit
argument_list|(
name|IK_TernOpInit
argument_list|,
name|Type
argument_list|)
block|,
name|Opc
argument_list|(
name|opc
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|MHS
argument_list|(
name|mhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|TernOpInit
argument_list|(
specifier|const
name|TernOpInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|TernOpInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TernOpInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_TernOpInit
return|;
block|}
specifier|static
name|TernOpInit
operator|*
name|get
argument_list|(
argument|TernaryOp opc
argument_list|,
argument|Init *lhs
argument_list|,
argument|Init *mhs
argument_list|,
argument|Init *rhs
argument_list|,
argument|RecTy *Type
argument_list|)
block|;
comment|// Clone - Clone this operator, replacing arguments with the new list
name|OpInit
operator|*
name|clone
argument_list|(
argument|std::vector<Init *>&Operands
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|Operands
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
literal|"Wrong number of operands for ternary operation"
argument_list|)
block|;
return|return
name|TernOpInit
operator|::
name|get
argument_list|(
name|getOpcode
argument_list|()
argument_list|,
name|Operands
index|[
literal|0
index|]
argument_list|,
name|Operands
index|[
literal|1
index|]
argument_list|,
name|Operands
index|[
literal|2
index|]
argument_list|,
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
name|override
block|{
return|return
literal|3
return|;
block|}
name|Init
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
name|override
block|{
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid operand id for ternary operator"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
return|return
name|getLHS
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|getMHS
argument_list|()
return|;
case|case
literal|2
case|:
return|return
name|getRHS
argument_list|()
return|;
block|}
block|}
name|TernaryOp
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opc
return|;
block|}
name|Init
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
name|Init
operator|*
name|getMHS
argument_list|()
specifier|const
block|{
return|return
name|MHS
return|;
block|}
name|Init
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
comment|// Fold - If possible, fold this to a simpler init.  Return this if not
comment|// possible to fold.
name|Init
operator|*
name|Fold
argument_list|(
argument|Record *CurRec
argument_list|,
argument|MultiClass *CurMultiClass
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isComplete
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// VarInit - 'Opcode' - Represent a reference to an entire variable object.
comment|///
name|class
name|VarInit
operator|:
name|public
name|TypedInit
block|{
name|Init
operator|*
name|VarName
block|;
name|explicit
name|VarInit
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_VarInit
argument_list|,
name|T
argument_list|)
block|,
name|VarName
argument_list|(
argument|StringInit::get(VN)
argument_list|)
block|{}
name|explicit
name|VarInit
argument_list|(
name|Init
operator|*
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_VarInit
argument_list|,
name|T
argument_list|)
block|,
name|VarName
argument_list|(
argument|VN
argument_list|)
block|{}
name|VarInit
argument_list|(
specifier|const
name|VarInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|VarInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|VarInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarInit
return|;
block|}
specifier|static
name|VarInit
operator|*
name|get
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
block|;
specifier|static
name|VarInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|VN
argument_list|,
name|RecTy
operator|*
name|T
argument_list|)
block|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|;
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|VarName
return|;
block|}
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|const std::string&FieldName
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getFieldInit
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|const std::string&FieldName
argument_list|)
specifier|const
name|override
block|;
comment|/// resolveReferences - This method is used by classes that refer to other
comment|/// variables which may not be defined at the time they expression is formed.
comment|/// If a value is set for the variable later, this method will be called on
comment|/// users of the value to allow the value to propagate out.
comment|///
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|getName
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// VarBitInit - Opcode{0} - Represent access to one bit of a variable or field.
comment|///
name|class
name|VarBitInit
operator|:
name|public
name|Init
block|{
name|TypedInit
operator|*
name|TI
block|;
name|unsigned
name|Bit
block|;
name|VarBitInit
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned B
argument_list|)
operator|:
name|Init
argument_list|(
name|IK_VarBitInit
argument_list|)
block|,
name|TI
argument_list|(
name|T
argument_list|)
block|,
name|Bit
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|T
operator|->
name|getType
argument_list|()
operator|&&
operator|(
name|isa
operator|<
name|IntRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|||
operator|(
name|isa
operator|<
name|BitsRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|&&
name|cast
operator|<
name|BitsRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getNumBits
argument_list|()
operator|>
name|B
operator|)
operator|)
operator|&&
literal|"Illegal VarBitInit expression!"
argument_list|)
block|;   }
name|VarBitInit
argument_list|(
specifier|const
name|VarBitInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|VarBitInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|VarBitInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarBitInit
return|;
block|}
specifier|static
name|VarBitInit
operator|*
name|get
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned B
argument_list|)
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBitVar
argument_list|()
specifier|const
name|override
block|{
return|return
name|TI
return|;
block|}
name|unsigned
name|getBitNum
argument_list|()
specifier|const
name|override
block|{
return|return
name|Bit
return|;
block|}
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned B
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
name|B
operator|<
literal|1
operator|&&
literal|"Bit index out of range!"
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|VarBitInit
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
expr|}
block|;
comment|/// VarListElementInit - List[4] - Represent access to one element of a var or
comment|/// field.
name|class
name|VarListElementInit
operator|:
name|public
name|TypedInit
block|{
name|TypedInit
operator|*
name|TI
block|;
name|unsigned
name|Element
block|;
name|VarListElementInit
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned E
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_VarListElementInit
argument_list|,
name|cast
operator|<
name|ListRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|->
name|getElementType
argument_list|()
argument_list|)
block|,
name|TI
argument_list|(
name|T
argument_list|)
block|,
name|Element
argument_list|(
argument|E
argument_list|)
block|{
name|assert
argument_list|(
name|T
operator|->
name|getType
argument_list|()
operator|&&
name|isa
operator|<
name|ListRecTy
operator|>
operator|(
name|T
operator|->
name|getType
argument_list|()
operator|)
operator|&&
literal|"Illegal VarBitInit expression!"
argument_list|)
block|;   }
name|VarListElementInit
argument_list|(
specifier|const
name|VarListElementInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|VarListElementInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_VarListElementInit
return|;
block|}
specifier|static
name|VarListElementInit
operator|*
name|get
argument_list|(
argument|TypedInit *T
argument_list|,
argument|unsigned E
argument_list|)
block|;
name|TypedInit
operator|*
name|getVariable
argument_list|()
specifier|const
block|{
return|return
name|TI
return|;
block|}
name|unsigned
name|getElementNum
argument_list|()
specifier|const
block|{
return|return
name|Element
return|;
block|}
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// DefInit - AL - Represent a reference to a 'def' in the description
comment|///
name|class
name|DefInit
operator|:
name|public
name|TypedInit
block|{
name|Record
operator|*
name|Def
block|;
name|DefInit
argument_list|(
name|Record
operator|*
name|D
argument_list|,
name|RecordRecTy
operator|*
name|T
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_DefInit
argument_list|,
name|T
argument_list|)
block|,
name|Def
argument_list|(
argument|D
argument_list|)
block|{}
name|friend
name|class
name|Record
block|;
name|DefInit
argument_list|(
specifier|const
name|DefInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|DefInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DefInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_DefInit
return|;
block|}
specifier|static
name|DefInit
operator|*
name|get
argument_list|(
name|Record
operator|*
argument_list|)
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Record
operator|*
name|getDef
argument_list|()
specifier|const
block|{
return|return
name|Def
return|;
block|}
comment|//virtual Init *convertInitializerBitRange(const std::vector<unsigned>&Bits);
name|RecTy
operator|*
name|getFieldType
argument_list|(
argument|const std::string&FieldName
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getFieldInit
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|const std::string&FieldName
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off def"
argument_list|)
block|;   }
comment|/// resolveListElementReference - This method is used to implement
comment|/// VarListElementInit::resolveReferences.  If the list element is resolvable
comment|/// now, we return the resolved value, otherwise we return null.
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off def"
argument_list|)
block|;   }
block|}
block|;
comment|/// FieldInit - X.Y - Represent a reference to a subfield of a variable
comment|///
name|class
name|FieldInit
operator|:
name|public
name|TypedInit
block|{
name|Init
operator|*
name|Rec
block|;
comment|// Record we are referring to
name|std
operator|::
name|string
name|FieldName
block|;
comment|// Field we are accessing
name|FieldInit
argument_list|(
name|Init
operator|*
name|R
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|FN
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_FieldInit
argument_list|,
name|R
operator|->
name|getFieldType
argument_list|(
name|FN
argument_list|)
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|FieldName
argument_list|(
argument|FN
argument_list|)
block|{
name|assert
argument_list|(
name|getType
argument_list|()
operator|&&
literal|"FieldInit with non-record type!"
argument_list|)
block|;   }
name|FieldInit
argument_list|(
specifier|const
name|FieldInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|FieldInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|FieldInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_FieldInit
return|;
block|}
specifier|static
name|FieldInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|R
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|FN
argument_list|)
block|;
specifier|static
name|FieldInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|R
argument_list|,
specifier|const
name|Init
operator|*
name|FN
argument_list|)
block|;
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|{
return|return
name|Rec
operator|->
name|getAsString
argument_list|()
operator|+
literal|"."
operator|+
name|FieldName
return|;
block|}
expr|}
block|;
comment|/// DagInit - (v a, b) - Represent a DAG tree value.  DAG inits are required
comment|/// to have at least one value then a (possibly empty) list of arguments.  Each
comment|/// argument can have a name associated with it.
comment|///
name|class
name|DagInit
operator|:
name|public
name|TypedInit
block|,
name|public
name|FoldingSetNode
block|{
name|Init
operator|*
name|Val
block|;
name|std
operator|::
name|string
name|ValName
block|;
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
name|Args
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|ArgNames
block|;
name|DagInit
argument_list|(
name|Init
operator|*
name|V
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|VN
argument_list|,
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|ArgRange
argument_list|,
name|ArrayRef
operator|<
name|std
operator|::
name|string
operator|>
name|NameRange
argument_list|)
operator|:
name|TypedInit
argument_list|(
name|IK_DagInit
argument_list|,
name|DagRecTy
operator|::
name|get
argument_list|()
argument_list|)
block|,
name|Val
argument_list|(
name|V
argument_list|)
block|,
name|ValName
argument_list|(
name|VN
argument_list|)
block|,
name|Args
argument_list|(
name|ArgRange
operator|.
name|begin
argument_list|()
argument_list|,
name|ArgRange
operator|.
name|end
argument_list|()
argument_list|)
block|,
name|ArgNames
argument_list|(
argument|NameRange.begin()
argument_list|,
argument|NameRange.end()
argument_list|)
block|{}
name|DagInit
argument_list|(
specifier|const
name|DagInit
operator|&
name|Other
argument_list|)
operator|=
name|delete
block|;
name|DagInit
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DagInit
operator|&
name|Other
operator|)
operator|=
name|delete
block|;
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Init *I
argument_list|)
block|{
return|return
name|I
operator|->
name|getKind
argument_list|()
operator|==
name|IK_DagInit
return|;
block|}
specifier|static
name|DagInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|V
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|VN
argument_list|,
name|ArrayRef
operator|<
name|Init
operator|*
operator|>
name|ArgRange
argument_list|,
name|ArrayRef
operator|<
name|std
operator|::
name|string
operator|>
name|NameRange
argument_list|)
block|;
specifier|static
name|DagInit
operator|*
name|get
argument_list|(
name|Init
operator|*
name|V
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|VN
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Init
operator|*
argument_list|,
name|std
operator|::
name|string
operator|>
expr|>
operator|&
name|args
argument_list|)
block|;
name|void
name|Profile
argument_list|(
argument|FoldingSetNodeID&ID
argument_list|)
specifier|const
block|;
name|Init
operator|*
name|convertInitializerTo
argument_list|(
argument|RecTy *Ty
argument_list|)
specifier|const
name|override
block|;
name|Init
operator|*
name|getOperator
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|ValName
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
name|Init
operator|*
name|getArg
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Num
operator|<
name|Args
operator|.
name|size
argument_list|()
operator|&&
literal|"Arg number out of range!"
argument_list|)
block|;
return|return
name|Args
index|[
name|Num
index|]
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getArgName
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Num
operator|<
name|ArgNames
operator|.
name|size
argument_list|()
operator|&&
literal|"Arg number out of range!"
argument_list|)
block|;
return|return
name|ArgNames
index|[
name|Num
index|]
return|;
block|}
name|Init
operator|*
name|resolveReferences
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
name|override
block|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
operator|::
name|const_iterator
name|const_arg_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|::
name|const_iterator
name|const_name_iterator
expr_stmt|;
specifier|inline
name|const_arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|const_arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|end
argument_list|()
return|;
block|}
specifier|inline
name|size_t
name|arg_size
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|arg_empty
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|inline
name|const_name_iterator
name|name_begin
argument_list|()
specifier|const
block|{
return|return
name|ArgNames
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|const_name_iterator
name|name_end
argument_list|()
specifier|const
block|{
return|return
name|ArgNames
operator|.
name|end
argument_list|()
return|;
block|}
specifier|inline
name|size_t
name|name_size
argument_list|()
specifier|const
block|{
return|return
name|ArgNames
operator|.
name|size
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|name_empty
argument_list|()
specifier|const
block|{
return|return
name|ArgNames
operator|.
name|empty
argument_list|()
return|;
block|}
name|Init
operator|*
name|getBit
argument_list|(
argument|unsigned Bit
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal bit reference off dag"
argument_list|)
block|;   }
name|Init
operator|*
name|resolveListElementReference
argument_list|(
argument|Record&R
argument_list|,
argument|const RecordVal *RV
argument_list|,
argument|unsigned Elt
argument_list|)
specifier|const
name|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Illegal element reference off dag"
argument_list|)
block|;   }
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|//  High-Level Classes
comment|//===----------------------------------------------------------------------===//
name|class
name|RecordVal
block|{
name|PointerIntPair
operator|<
name|Init
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|NameAndPrefix
block|;
name|RecTy
operator|*
name|Ty
block|;
name|Init
operator|*
name|Value
block|;
name|public
operator|:
name|RecordVal
argument_list|(
argument|Init *N
argument_list|,
argument|RecTy *T
argument_list|,
argument|bool P
argument_list|)
block|;
name|RecordVal
argument_list|(
argument|const std::string&N
argument_list|,
argument|RecTy *T
argument_list|,
argument|bool P
argument_list|)
block|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|;
specifier|const
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|NameAndPrefix
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|bool
name|getPrefix
argument_list|()
specifier|const
block|{
return|return
name|NameAndPrefix
operator|.
name|getInt
argument_list|()
return|;
block|}
name|RecTy
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|Init
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|bool
name|setValue
argument_list|(
argument|Init *V
argument_list|)
block|{
if|if
condition|(
name|V
condition|)
block|{
name|Value
operator|=
name|V
operator|->
name|convertInitializerTo
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
return|return
name|Value
operator|==
name|nullptr
return|;
block|}
name|Value
operator|=
name|nullptr
expr_stmt|;
return|return
name|false
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
block|;
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintSem = true
argument_list|)
specifier|const
block|; }
block|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
expr|,
specifier|const
name|RecordVal
operator|&
name|RV
operator|)
block|{
name|RV
operator|.
name|print
argument_list|(
name|OS
operator|<<
literal|"  "
argument_list|)
block|;
return|return
name|OS
return|;
block|}
name|class
name|Record
block|{
specifier|static
name|unsigned
name|LastID
block|;
comment|// Unique record ID.
name|unsigned
name|ID
block|;
name|Init
operator|*
name|Name
block|;
comment|// Location where record was instantiated, followed by the location of
comment|// multiclass prototypes used.
name|SmallVector
operator|<
name|SMLoc
block|,
literal|4
operator|>
name|Locs
block|;
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
name|TemplateArgs
block|;
name|std
operator|::
name|vector
operator|<
name|RecordVal
operator|>
name|Values
block|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|SuperClasses
block|;
name|std
operator|::
name|vector
operator|<
name|SMRange
operator|>
name|SuperClassRanges
block|;
comment|// Tracks Record instances. Not owned by Record.
name|RecordKeeper
operator|&
name|TrackedRecords
block|;
name|DefInit
operator|*
name|TheInit
block|;
name|bool
name|IsAnonymous
block|;
comment|// Class-instance values can be used by other defs.  For example, Struct<i>
comment|// is used here as a template argument to another class:
comment|//
comment|//   multiclass MultiClass<int i> {
comment|//     def Def : Class<Struct<i>>;
comment|//
comment|// These need to get fully resolved before instantiating any other
comment|// definitions that use them (e.g. Def).  However, inside a multiclass they
comment|// can't be immediately resolved so we mark them ResolveFirst to fully
comment|// resolve them later as soon as the multiclass is instantiated.
name|bool
name|ResolveFirst
block|;
name|void
name|init
argument_list|()
block|;
name|void
name|checkName
argument_list|()
block|;
name|public
operator|:
comment|// Constructs a record.
name|explicit
name|Record
argument_list|(
argument|Init *N
argument_list|,
argument|ArrayRef<SMLoc> locs
argument_list|,
argument|RecordKeeper&records
argument_list|,
argument|bool Anonymous = false
argument_list|)
operator|:
name|ID
argument_list|(
name|LastID
operator|++
argument_list|)
block|,
name|Name
argument_list|(
name|N
argument_list|)
block|,
name|Locs
argument_list|(
name|locs
operator|.
name|begin
argument_list|()
argument_list|,
name|locs
operator|.
name|end
argument_list|()
argument_list|)
block|,
name|TrackedRecords
argument_list|(
name|records
argument_list|)
block|,
name|TheInit
argument_list|(
name|nullptr
argument_list|)
block|,
name|IsAnonymous
argument_list|(
name|Anonymous
argument_list|)
block|,
name|ResolveFirst
argument_list|(
argument|false
argument_list|)
block|{
name|init
argument_list|()
block|;   }
name|explicit
name|Record
argument_list|(
argument|const std::string&N
argument_list|,
argument|ArrayRef<SMLoc> locs
argument_list|,
argument|RecordKeeper&records
argument_list|,
argument|bool Anonymous = false
argument_list|)
operator|:
name|Record
argument_list|(
argument|StringInit::get(N)
argument_list|,
argument|locs
argument_list|,
argument|records
argument_list|,
argument|Anonymous
argument_list|)
block|{}
comment|// When copy-constructing a Record, we must still guarantee a globally unique
comment|// ID number.  All other fields can be copied normally.
name|Record
argument_list|(
specifier|const
name|Record
operator|&
name|O
argument_list|)
operator|:
name|ID
argument_list|(
name|LastID
operator|++
argument_list|)
block|,
name|Name
argument_list|(
name|O
operator|.
name|Name
argument_list|)
block|,
name|Locs
argument_list|(
name|O
operator|.
name|Locs
argument_list|)
block|,
name|TemplateArgs
argument_list|(
name|O
operator|.
name|TemplateArgs
argument_list|)
block|,
name|Values
argument_list|(
name|O
operator|.
name|Values
argument_list|)
block|,
name|SuperClasses
argument_list|(
name|O
operator|.
name|SuperClasses
argument_list|)
block|,
name|SuperClassRanges
argument_list|(
name|O
operator|.
name|SuperClassRanges
argument_list|)
block|,
name|TrackedRecords
argument_list|(
name|O
operator|.
name|TrackedRecords
argument_list|)
block|,
name|TheInit
argument_list|(
name|O
operator|.
name|TheInit
argument_list|)
block|,
name|IsAnonymous
argument_list|(
name|O
operator|.
name|IsAnonymous
argument_list|)
block|,
name|ResolveFirst
argument_list|(
argument|O.ResolveFirst
argument_list|)
block|{ }
specifier|static
name|unsigned
name|getNewUID
argument_list|()
block|{
return|return
name|LastID
operator|++
return|;
block|}
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|ID
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|;
name|Init
operator|*
name|getNameInit
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|getNameInitAsString
argument_list|()
specifier|const
block|{
return|return
name|getNameInit
argument_list|()
operator|->
name|getAsUnquotedString
argument_list|()
return|;
block|}
name|void
name|setName
argument_list|(
name|Init
operator|*
name|Name
argument_list|)
block|;
comment|// Also updates RecordKeeper.
name|void
name|setName
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
block|;
comment|// Also updates RecordKeeper.
name|ArrayRef
operator|<
name|SMLoc
operator|>
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|Locs
return|;
block|}
comment|/// get the corresponding DefInit.
name|DefInit
operator|*
name|getDefInit
argument_list|()
block|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|Init
operator|*
operator|>
operator|&
name|getTemplateArgs
argument_list|()
specifier|const
block|{
return|return
name|TemplateArgs
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|RecordVal
operator|>
operator|&
name|getValues
argument_list|()
specifier|const
block|{
return|return
name|Values
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getSuperClasses
argument_list|()
specifier|const
block|{
return|return
name|SuperClasses
return|;
block|}
name|ArrayRef
operator|<
name|SMRange
operator|>
name|getSuperClassRanges
argument_list|()
specifier|const
block|{
return|return
name|SuperClassRanges
return|;
block|}
name|bool
name|isTemplateArg
argument_list|(
argument|Init *Name
argument_list|)
specifier|const
block|{
for|for
control|(
name|Init
modifier|*
name|TA
range|:
name|TemplateArgs
control|)
if|if
condition|(
name|TA
operator|==
name|Name
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|bool
name|isTemplateArg
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
return|return
name|isTemplateArg
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
return|;
block|}
specifier|const
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|const Init *Name
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|RecordVal
modifier|&
name|Val
range|:
name|Values
control|)
if|if
condition|(
name|Val
operator|.
name|getNameInit
argument_list|()
operator|==
name|Name
condition|)
return|return
operator|&
name|Val
return|;
return|return
name|nullptr
return|;
block|}
specifier|const
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|StringRef Name
argument_list|)
specifier|const
block|{
return|return
name|getValue
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
return|;
block|}
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|const Init *Name
argument_list|)
block|{
for|for
control|(
name|RecordVal
modifier|&
name|Val
range|:
name|Values
control|)
if|if
condition|(
name|Val
operator|.
name|getNameInit
argument_list|()
operator|==
name|Name
condition|)
return|return
operator|&
name|Val
return|;
return|return
name|nullptr
return|;
block|}
name|RecordVal
operator|*
name|getValue
argument_list|(
argument|StringRef Name
argument_list|)
block|{
return|return
name|getValue
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
return|;
block|}
name|void
name|addTemplateArg
argument_list|(
argument|Init *Name
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isTemplateArg
argument_list|(
name|Name
argument_list|)
operator|&&
literal|"Template arg already defined!"
argument_list|)
block|;
name|TemplateArgs
operator|.
name|push_back
argument_list|(
name|Name
argument_list|)
block|;   }
name|void
name|addTemplateArg
argument_list|(
argument|StringRef Name
argument_list|)
block|{
name|addTemplateArg
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
block|;   }
name|void
name|addValue
argument_list|(
argument|const RecordVal&RV
argument_list|)
block|{
name|assert
argument_list|(
name|getValue
argument_list|(
name|RV
operator|.
name|getNameInit
argument_list|()
argument_list|)
operator|==
name|nullptr
operator|&&
literal|"Value already added!"
argument_list|)
block|;
name|Values
operator|.
name|push_back
argument_list|(
name|RV
argument_list|)
block|;
if|if
condition|(
name|Values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
comment|// Keep NAME at the end of the list.  It makes record dumps a
comment|// bit prettier and allows TableGen tests to be written more
comment|// naturally.  Tests can use CHECK-NEXT to look for Record
comment|// fields they expect to see after a def.  They can't do that if
comment|// NAME is the first Record field.
name|std
operator|::
name|swap
argument_list|(
name|Values
index|[
name|Values
operator|.
name|size
argument_list|()
operator|-
literal|2
index|]
argument_list|,
name|Values
index|[
name|Values
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|void
name|removeValue
argument_list|(
argument|Init *Name
argument_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Values
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Values
index|[
name|i
index|]
operator|.
name|getNameInit
argument_list|()
operator|==
name|Name
condition|)
block|{
name|Values
operator|.
name|erase
argument_list|(
name|Values
operator|.
name|begin
argument_list|()
operator|+
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|llvm_unreachable
argument_list|(
literal|"Cannot remove an entry that does not exist!"
argument_list|)
expr_stmt|;
block|}
name|void
name|removeValue
argument_list|(
argument|StringRef Name
argument_list|)
block|{
name|removeValue
argument_list|(
name|StringInit
operator|::
name|get
argument_list|(
name|Name
argument_list|)
argument_list|)
block|;   }
name|bool
name|isSubClassOf
argument_list|(
argument|const Record *R
argument_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|Record
modifier|*
name|SC
range|:
name|SuperClasses
control|)
if|if
condition|(
name|SC
operator|==
name|R
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|bool
name|isSubClassOf
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
block|{
for|for
control|(
specifier|const
name|Record
modifier|*
name|SC
range|:
name|SuperClasses
control|)
if|if
condition|(
name|SC
operator|->
name|getNameInitAsString
argument_list|()
operator|==
name|Name
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|void
name|addSuperClass
parameter_list|(
name|Record
modifier|*
name|R
parameter_list|,
name|SMRange
name|Range
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isSubClassOf
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Already subclassing record!"
argument_list|)
expr_stmt|;
name|SuperClasses
operator|.
name|push_back
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|SuperClassRanges
operator|.
name|push_back
argument_list|(
name|Range
argument_list|)
expr_stmt|;
block|}
comment|/// resolveReferences - If there are any field references that refer to fields
comment|/// that have been filled in, we can propagate the values now.
comment|///
name|void
name|resolveReferences
parameter_list|()
block|{
name|resolveReferencesTo
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
block|}
comment|/// resolveReferencesTo - If anything in this record refers to RV, replace the
comment|/// reference to RV with the RHS of RV.  If RV is null, we resolve all
comment|/// possible references.
name|void
name|resolveReferencesTo
parameter_list|(
specifier|const
name|RecordVal
modifier|*
name|RV
parameter_list|)
function_decl|;
name|RecordKeeper
operator|&
name|getRecords
argument_list|()
specifier|const
block|{
return|return
name|TrackedRecords
return|;
block|}
name|bool
name|isAnonymous
argument_list|()
specifier|const
block|{
return|return
name|IsAnonymous
return|;
block|}
name|bool
name|isResolveFirst
argument_list|()
specifier|const
block|{
return|return
name|ResolveFirst
return|;
block|}
name|void
name|setResolveFirst
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|ResolveFirst
operator|=
name|b
expr_stmt|;
block|}
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// High-level methods useful to tablegen back-ends
comment|//
comment|/// getValueInit - Return the initializer for a value with the specified name,
comment|/// or throw an exception if the field does not exist.
comment|///
name|Init
modifier|*
name|getValueInit
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if the named field is unset.
name|bool
name|isValueUnset
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
block|{
return|return
name|isa
operator|<
name|UnsetInit
operator|>
operator|(
name|getValueInit
argument_list|(
name|FieldName
argument_list|)
operator|)
return|;
block|}
comment|/// getValueAsString - This method looks up the specified field and returns
comment|/// its value as a string, throwing an exception if the field does not exist
comment|/// or if the value is not a string.
comment|///
name|std
operator|::
name|string
name|getValueAsString
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
expr_stmt|;
comment|/// getValueAsBitsInit - This method looks up the specified field and returns
comment|/// its value as a BitsInit, throwing an exception if the field does not exist
comment|/// or if the value is not the right type.
comment|///
name|BitsInit
modifier|*
name|getValueAsBitsInit
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsListInit - This method looks up the specified field and returns
comment|/// its value as a ListInit, throwing an exception if the field does not exist
comment|/// or if the value is not the right type.
comment|///
name|ListInit
modifier|*
name|getValueAsListInit
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsListOfDefs - This method looks up the specified field and
comment|/// returns its value as a vector of records, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|getValueAsListOfDefs
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
expr_stmt|;
comment|/// getValueAsListOfInts - This method looks up the specified field and
comment|/// returns its value as a vector of integers, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|int64_t
operator|>
name|getValueAsListOfInts
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
expr_stmt|;
comment|/// getValueAsListOfStrings - This method looks up the specified field and
comment|/// returns its value as a vector of strings, throwing an exception if the
comment|/// field does not exist or if the value is not the right type.
comment|///
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|getValueAsListOfStrings
argument_list|(
argument|StringRef FieldName
argument_list|)
specifier|const
expr_stmt|;
comment|/// getValueAsDef - This method looks up the specified field and returns its
comment|/// value as a Record, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|Record
modifier|*
name|getValueAsDef
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsBit - This method looks up the specified field and returns its
comment|/// value as a bit, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|bool
name|getValueAsBit
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsBitOrUnset - This method looks up the specified field and
comment|/// returns its value as a bit. If the field is unset, sets Unset to true and
comment|/// returns false.
comment|///
name|bool
name|getValueAsBitOrUnset
argument_list|(
name|StringRef
name|FieldName
argument_list|,
name|bool
operator|&
name|Unset
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsInt - This method looks up the specified field and returns its
comment|/// value as an int64_t, throwing an exception if the field does not exist or
comment|/// if the value is not the right type.
comment|///
name|int64_t
name|getValueAsInt
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
comment|/// getValueAsDag - This method looks up the specified field and returns its
comment|/// value as an Dag, throwing an exception if the field does not exist or if
comment|/// the value is not the right type.
comment|///
name|DagInit
modifier|*
name|getValueAsDag
argument_list|(
name|StringRef
name|FieldName
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Record
operator|&
name|R
operator|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|MultiClass
block|{
name|Record
name|Rec
decl_stmt|;
comment|// Placeholder for template args and Name.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>>
name|RecordVector
expr_stmt|;
name|RecordVector
name|DefPrototypes
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
decl_stmt|;
name|MultiClass
argument_list|(
argument|const std::string&Name
argument_list|,
argument|SMLoc Loc
argument_list|,
argument|RecordKeeper&Records
argument_list|)
block|:
name|Rec
argument_list|(
argument|Name
argument_list|,
argument|Loc
argument_list|,
argument|Records
argument_list|)
block|{}
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|RecordKeeper
block|{
typedef|typedef
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>>
name|RecordMap
expr_stmt|;
name|RecordMap
name|Classes
decl_stmt|,
name|Defs
decl_stmt|;
name|public
label|:
specifier|const
name|RecordMap
operator|&
name|getClasses
argument_list|()
specifier|const
block|{
return|return
name|Classes
return|;
block|}
specifier|const
name|RecordMap
operator|&
name|getDefs
argument_list|()
specifier|const
block|{
return|return
name|Defs
return|;
block|}
name|Record
modifier|*
name|getClass
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
decl|const
block|{
name|auto
name|I
init|=
name|Classes
operator|.
name|find
argument_list|(
name|Name
argument_list|)
decl_stmt|;
return|return
name|I
operator|==
name|Classes
operator|.
name|end
argument_list|()
condition|?
name|nullptr
else|:
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
name|Record
modifier|*
name|getDef
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
decl|const
block|{
name|auto
name|I
init|=
name|Defs
operator|.
name|find
argument_list|(
name|Name
argument_list|)
decl_stmt|;
return|return
name|I
operator|==
name|Defs
operator|.
name|end
argument_list|()
condition|?
name|nullptr
else|:
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|addClass
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>
name|R
argument_list|)
block|{
name|bool
name|Ins
init|=
name|Classes
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
operator|->
name|getName
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
argument_list|)
argument_list|)
operator|.
name|second
decl_stmt|;
operator|(
name|void
operator|)
name|Ins
expr_stmt|;
name|assert
argument_list|(
name|Ins
operator|&&
literal|"Class already exists"
argument_list|)
expr_stmt|;
block|}
name|void
name|addDef
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Record
operator|>
name|R
argument_list|)
block|{
name|bool
name|Ins
init|=
name|Defs
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|R
operator|->
name|getName
argument_list|()
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|R
argument_list|)
argument_list|)
argument_list|)
operator|.
name|second
decl_stmt|;
operator|(
name|void
operator|)
name|Ins
expr_stmt|;
name|assert
argument_list|(
name|Ins
operator|&&
literal|"Record already exists"
argument_list|)
expr_stmt|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// High-level helper methods, useful for tablegen backends...
comment|/// getAllDerivedDefinitions - This method returns all concrete definitions
comment|/// that derive from the specified class name.  If a class with the specified
comment|/// name does not exist, an exception is thrown.
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|getAllDerivedDefinitions
argument_list|(
argument|const std::string&ClassName
argument_list|)
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// LessRecord - Sorting predicate to sort record pointers by name.
end_comment

begin_comment
comment|///
end_comment

begin_struct
struct|struct
name|LessRecord
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
operator|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
return|return
name|StringRef
argument_list|(
name|Rec1
operator|->
name|getName
argument_list|()
argument_list|)
operator|.
name|compare_numeric
argument_list|(
name|Rec2
operator|->
name|getName
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// LessRecordByID - Sorting predicate to sort record pointers by their
end_comment

begin_comment
comment|/// unique ID. If you just need a deterministic order, use this, since it
end_comment

begin_comment
comment|/// just compares two `unsigned`; the other sorting predicates require
end_comment

begin_comment
comment|/// string manipulation.
end_comment

begin_struct
struct|struct
name|LessRecordByID
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|LHS
operator|,
specifier|const
name|Record
operator|*
name|RHS
operator|)
specifier|const
block|{
return|return
name|LHS
operator|->
name|getID
argument_list|()
operator|<
name|RHS
operator|->
name|getID
argument_list|()
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|/// LessRecordFieldName - Sorting predicate to sort record pointers by their
end_comment

begin_comment
comment|/// name field.
end_comment

begin_comment
comment|///
end_comment

begin_struct
struct|struct
name|LessRecordFieldName
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
operator|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
return|return
name|Rec1
operator|->
name|getValueAsString
argument_list|(
literal|"Name"
argument_list|)
operator|<
name|Rec2
operator|->
name|getValueAsString
argument_list|(
literal|"Name"
argument_list|)
return|;
block|}
block|}
struct|;
end_struct

begin_struct
struct|struct
name|LessRecordRegister
block|{
specifier|static
name|bool
name|ascii_isdigit
parameter_list|(
name|char
name|x
parameter_list|)
block|{
return|return
name|x
operator|>=
literal|'0'
operator|&&
name|x
operator|<=
literal|'9'
return|;
block|}
struct|struct
name|RecordParts
block|{
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
operator|,
literal|4
operator|>
name|Parts
expr_stmt|;
name|RecordParts
argument_list|(
argument|StringRef Rec
argument_list|)
block|{
if|if
condition|(
name|Rec
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|size_t
name|Len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|Start
init|=
name|Rec
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|Curr
init|=
name|Start
decl_stmt|;
name|bool
name|isDigitPart
init|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|I
init|=
literal|0
init|,
name|E
init|=
name|Rec
operator|.
name|size
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
operator|,
operator|++
name|Len
control|)
block|{
name|bool
name|isDigit
init|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
name|I
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDigit
operator|!=
name|isDigitPart
condition|)
block|{
name|Parts
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|isDigitPart
argument_list|,
name|StringRef
argument_list|(
name|Start
argument_list|,
name|Len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Len
operator|=
literal|0
expr_stmt|;
name|Start
operator|=
operator|&
name|Curr
index|[
name|I
index|]
expr_stmt|;
name|isDigitPart
operator|=
name|ascii_isdigit
argument_list|(
name|Curr
index|[
name|I
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Push the last part.
name|Parts
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|isDigitPart
argument_list|,
name|StringRef
argument_list|(
name|Start
argument_list|,
name|Len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|size_t
name|size
parameter_list|()
block|{
return|return
name|Parts
operator|.
name|size
argument_list|()
return|;
block|}
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|getPart
argument_list|(
argument|size_t i
argument_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|Parts
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid idx!"
argument_list|)
block|;
return|return
name|Parts
index|[
name|i
index|]
return|;
block|}
block|}
struct|;
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|Rec1
operator|,
specifier|const
name|Record
operator|*
name|Rec2
operator|)
specifier|const
block|{
name|RecordParts
name|LHSParts
argument_list|(
name|StringRef
argument_list|(
name|Rec1
operator|->
name|getName
argument_list|()
argument_list|)
argument_list|)
block|;
name|RecordParts
name|RHSParts
argument_list|(
name|StringRef
argument_list|(
name|Rec2
operator|->
name|getName
argument_list|()
argument_list|)
argument_list|)
block|;
name|size_t
name|LHSNumParts
operator|=
name|LHSParts
operator|.
name|size
argument_list|()
block|;
name|size_t
name|RHSNumParts
operator|=
name|RHSParts
operator|.
name|size
argument_list|()
block|;
name|assert
argument_list|(
name|LHSNumParts
operator|&&
name|RHSNumParts
operator|&&
literal|"Expected at least one part!"
argument_list|)
block|;
if|if
condition|(
name|LHSNumParts
operator|!=
name|RHSNumParts
condition|)
return|return
name|LHSNumParts
operator|<
name|RHSNumParts
return|;
comment|// We expect the registers to be of the form [_a-zA-z]+([0-9]*[_a-zA-Z]*)*.
for|for
control|(
name|size_t
name|I
init|=
literal|0
init|,
name|E
init|=
name|LHSNumParts
init|;
name|I
operator|<
name|E
condition|;
name|I
operator|+=
literal|2
control|)
block|{
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|LHSPart
operator|=
name|LHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|RHSPart
operator|=
name|RHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Expect even part to always be alpha.
name|assert
argument_list|(
name|LHSPart
operator|.
name|first
operator|==
name|false
operator|&&
name|RHSPart
operator|.
name|first
operator|==
name|false
operator|&&
literal|"Expected both parts to be alpha."
argument_list|)
expr_stmt|;
if|if
condition|(
name|int
name|Res
init|=
name|LHSPart
operator|.
name|second
operator|.
name|compare
argument_list|(
name|RHSPart
operator|.
name|second
argument_list|)
condition|)
return|return
name|Res
operator|<
literal|0
return|;
block|}
for|for
control|(
name|size_t
name|I
init|=
literal|1
init|,
name|E
init|=
name|LHSNumParts
init|;
name|I
operator|<
name|E
condition|;
name|I
operator|+=
literal|2
control|)
block|{
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|LHSPart
operator|=
name|LHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|StringRef
operator|>
name|RHSPart
operator|=
name|RHSParts
operator|.
name|getPart
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Expect odd part to always be numeric.
name|assert
argument_list|(
name|LHSPart
operator|.
name|first
operator|==
name|true
operator|&&
name|RHSPart
operator|.
name|first
operator|==
name|true
operator|&&
literal|"Expected both parts to be numeric."
argument_list|)
expr_stmt|;
if|if
condition|(
name|LHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
operator|!=
name|RHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
condition|)
return|return
name|LHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
operator|<
name|RHSPart
operator|.
name|second
operator|.
name|size
argument_list|()
return|;
name|unsigned
name|LHSVal
decl_stmt|,
name|RHSVal
decl_stmt|;
name|bool
name|LHSFailed
init|=
name|LHSPart
operator|.
name|second
operator|.
name|getAsInteger
argument_list|(
literal|10
argument_list|,
name|LHSVal
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|LHSFailed
expr_stmt|;
name|assert
argument_list|(
operator|!
name|LHSFailed
operator|&&
literal|"Unable to convert LHS to integer."
argument_list|)
expr_stmt|;
name|bool
name|RHSFailed
init|=
name|RHSPart
operator|.
name|second
operator|.
name|getAsInteger
argument_list|(
literal|10
argument_list|,
name|RHSVal
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|RHSFailed
expr_stmt|;
name|assert
argument_list|(
operator|!
name|RHSFailed
operator|&&
literal|"Unable to convert RHS to integer."
argument_list|)
expr_stmt|;
if|if
condition|(
name|LHSVal
operator|!=
name|RHSVal
condition|)
return|return
name|LHSVal
operator|<
name|RHSVal
return|;
block|}
return|return
name|LHSNumParts
operator|<
name|RHSNumParts
return|;
block|}
end_struct

begin_expr_stmt
unit|};
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|RecordKeeper
operator|&
name|RK
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// QualifyName - Return an Init with a qualifier prefix referring
end_comment

begin_comment
comment|/// to CurRec's name.
end_comment

begin_decl_stmt
name|Init
modifier|*
name|QualifyName
argument_list|(
name|Record
operator|&
name|CurRec
argument_list|,
name|MultiClass
operator|*
name|CurMultiClass
argument_list|,
name|Init
operator|*
name|Name
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|Scoper
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// QualifyName - Return an Init with a qualifier prefix referring
end_comment

begin_comment
comment|/// to CurRec's name.
end_comment

begin_decl_stmt
name|Init
modifier|*
name|QualifyName
argument_list|(
name|Record
operator|&
name|CurRec
argument_list|,
name|MultiClass
operator|*
name|CurMultiClass
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|Scoper
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

