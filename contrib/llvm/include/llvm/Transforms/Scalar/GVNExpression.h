begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//======- GVNExpression.h - GVN Expression classes --------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The header file for the GVN pass that contains expression handling
end_comment

begin_comment
comment|/// classes
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TRANSFORMS_SCALAR_GVNEXPRESSION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TRANSFORMS_SCALAR_GVNEXPRESSION_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/MemorySSA.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constant.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ArrayRecycler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|GVNExpression
block|{
enum|enum
name|ExpressionType
block|{
name|ET_Base
block|,
name|ET_Constant
block|,
name|ET_Variable
block|,
name|ET_Dead
block|,
name|ET_Unknown
block|,
name|ET_BasicStart
block|,
name|ET_Basic
block|,
name|ET_AggregateValue
block|,
name|ET_Phi
block|,
name|ET_MemoryStart
block|,
name|ET_Call
block|,
name|ET_Load
block|,
name|ET_Store
block|,
name|ET_MemoryEnd
block|,
name|ET_BasicEnd
block|}
enum|;
name|class
name|Expression
block|{
name|private
label|:
name|ExpressionType
name|EType
decl_stmt|;
name|unsigned
name|Opcode
decl_stmt|;
name|public
label|:
name|Expression
argument_list|(
argument|ExpressionType ET = ET_Base
argument_list|,
argument|unsigned O = ~
literal|2U
argument_list|)
block|:
name|EType
argument_list|(
name|ET
argument_list|)
operator|,
name|Opcode
argument_list|(
argument|O
argument_list|)
block|{}
name|Expression
argument_list|(
specifier|const
name|Expression
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|Expression
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Expression
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|virtual
operator|~
name|Expression
argument_list|()
expr_stmt|;
specifier|static
name|unsigned
name|getEmptyKey
parameter_list|()
block|{
return|return
operator|~
literal|0U
return|;
block|}
specifier|static
name|unsigned
name|getTombstoneKey
parameter_list|()
block|{
return|return
operator|~
literal|1U
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Expression
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|Other
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Expression
operator|&
name|Other
operator|)
specifier|const
block|{
if|if
condition|(
name|getOpcode
argument_list|()
operator|!=
name|Other
operator|.
name|getOpcode
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|getOpcode
argument_list|()
operator|==
name|getEmptyKey
argument_list|()
operator|||
name|getOpcode
argument_list|()
operator|==
name|getTombstoneKey
argument_list|()
condition|)
return|return
name|true
return|;
comment|// Compare the expression type for anything but load and store.
comment|// For load and store we set the opcode to zero to make them equal.
if|if
condition|(
name|getExpressionType
argument_list|()
operator|!=
name|ET_Load
operator|&&
name|getExpressionType
argument_list|()
operator|!=
name|ET_Store
operator|&&
name|getExpressionType
argument_list|()
operator|!=
name|Other
operator|.
name|getExpressionType
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|equals
argument_list|(
name|Other
argument_list|)
return|;
block|}
name|virtual
name|bool
name|equals
argument_list|(
specifier|const
name|Expression
operator|&
name|Other
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opcode
return|;
block|}
name|void
name|setOpcode
parameter_list|(
name|unsigned
name|opcode
parameter_list|)
block|{
name|Opcode
operator|=
name|opcode
expr_stmt|;
block|}
name|ExpressionType
name|getExpressionType
argument_list|()
specifier|const
block|{
return|return
name|EType
return|;
block|}
comment|// We deliberately leave the expression type out of the hash value.
name|virtual
name|hash_code
name|getHashValue
argument_list|()
specifier|const
block|{
return|return
name|getOpcode
argument_list|()
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|virtual
name|void
name|printInternal
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintEType
argument_list|)
decl|const
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"etype = "
operator|<<
name|getExpressionType
argument_list|()
operator|<<
literal|","
expr_stmt|;
name|OS
operator|<<
literal|"opcode = "
operator|<<
name|getOpcode
argument_list|()
operator|<<
literal|", "
expr_stmt|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
name|OS
operator|<<
literal|"{ "
expr_stmt|;
name|printInternal
argument_list|(
name|OS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|OS
operator|<<
literal|"}"
expr_stmt|;
block|}
name|LLVM_DUMP_METHOD
name|void
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
block|;
name|dbgs
argument_list|()
operator|<<
literal|"\n"
block|;   }
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|Expression
operator|&
name|E
operator|)
block|{
name|E
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
name|class
name|BasicExpression
range|:
name|public
name|Expression
block|{
name|private
operator|:
typedef|typedef
name|ArrayRecycler
operator|<
name|Value
operator|*
operator|>
name|RecyclerType
expr_stmt|;
typedef|typedef
name|RecyclerType
operator|::
name|Capacity
name|RecyclerCapacity
expr_stmt|;
name|Value
modifier|*
modifier|*
name|Operands
decl_stmt|;
name|unsigned
name|MaxOperands
decl_stmt|;
name|unsigned
name|NumOperands
decl_stmt|;
name|Type
modifier|*
name|ValueType
decl_stmt|;
name|public
label|:
name|BasicExpression
argument_list|(
argument|unsigned NumOperands
argument_list|)
block|:
name|BasicExpression
argument_list|(
argument|NumOperands
argument_list|,
argument|ET_Basic
argument_list|)
block|{}
name|BasicExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|ExpressionType ET
argument_list|)
block|:
name|Expression
argument_list|(
name|ET
argument_list|)
operator|,
name|Operands
argument_list|(
name|nullptr
argument_list|)
operator|,
name|MaxOperands
argument_list|(
name|NumOperands
argument_list|)
operator|,
name|NumOperands
argument_list|(
literal|0
argument_list|)
operator|,
name|ValueType
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|BasicExpression
argument_list|()
operator|=
name|delete
expr_stmt|;
name|BasicExpression
argument_list|(
specifier|const
name|BasicExpression
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|BasicExpression
modifier|&
name|operator
init|=
operator|(
specifier|const
name|BasicExpression
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|BasicExpression
argument_list|()
name|override
expr_stmt|;
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Expression
modifier|*
name|EB
parameter_list|)
block|{
name|ExpressionType
name|ET
init|=
name|EB
operator|->
name|getExpressionType
argument_list|()
decl_stmt|;
return|return
name|ET
operator|>
name|ET_BasicStart
operator|&&
name|ET
operator|<
name|ET_BasicEnd
return|;
block|}
comment|/// \brief Swap two operands. Used during GVN to put commutative operands in
comment|/// order.
name|void
name|swapOperands
parameter_list|(
name|unsigned
name|First
parameter_list|,
name|unsigned
name|Second
parameter_list|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|Operands
index|[
name|First
index|]
argument_list|,
name|Operands
index|[
name|Second
index|]
argument_list|)
expr_stmt|;
block|}
name|Value
modifier|*
name|getOperand
argument_list|(
name|unsigned
name|N
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Operands
operator|&&
literal|"Operands not allocated"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|N
operator|<
name|NumOperands
operator|&&
literal|"Operand out of range"
argument_list|)
expr_stmt|;
return|return
name|Operands
index|[
name|N
index|]
return|;
block|}
name|void
name|setOperand
parameter_list|(
name|unsigned
name|N
parameter_list|,
name|Value
modifier|*
name|V
parameter_list|)
block|{
name|assert
argument_list|(
name|Operands
operator|&&
literal|"Operands not allocated before setting"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|N
operator|<
name|NumOperands
operator|&&
literal|"Operand out of range"
argument_list|)
expr_stmt|;
name|Operands
index|[
name|N
index|]
operator|=
name|V
expr_stmt|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
typedef|typedef
name|Value
modifier|*
modifier|*
name|op_iterator
typedef|;
typedef|typedef
name|Value
modifier|*
specifier|const
modifier|*
name|const_op_iterator
typedef|;
name|op_iterator
name|op_begin
parameter_list|()
block|{
return|return
name|Operands
return|;
block|}
name|op_iterator
name|op_end
parameter_list|()
block|{
return|return
name|Operands
operator|+
name|NumOperands
return|;
block|}
name|const_op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|Operands
return|;
block|}
name|const_op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|+
name|NumOperands
return|;
block|}
name|iterator_range
operator|<
name|op_iterator
operator|>
name|operands
argument_list|()
block|{
return|return
name|iterator_range
operator|<
name|op_iterator
operator|>
operator|(
name|op_begin
argument_list|()
operator|,
name|op_end
argument_list|()
operator|)
return|;
block|}
name|iterator_range
operator|<
name|const_op_iterator
operator|>
name|operands
argument_list|()
specifier|const
block|{
return|return
name|iterator_range
operator|<
name|const_op_iterator
operator|>
operator|(
name|op_begin
argument_list|()
operator|,
name|op_end
argument_list|()
operator|)
return|;
block|}
name|void
name|op_push_back
parameter_list|(
name|Value
modifier|*
name|Arg
parameter_list|)
block|{
name|assert
argument_list|(
name|NumOperands
operator|<
name|MaxOperands
operator|&&
literal|"Tried to add too many operands"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Operands
operator|&&
literal|"Operandss not allocated before pushing"
argument_list|)
expr_stmt|;
name|Operands
index|[
name|NumOperands
operator|++
index|]
operator|=
name|Arg
expr_stmt|;
block|}
name|bool
name|op_empty
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|==
literal|0
return|;
block|}
name|void
name|allocateOperands
parameter_list|(
name|RecyclerType
modifier|&
name|Recycler
parameter_list|,
name|BumpPtrAllocator
modifier|&
name|Allocator
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|Operands
operator|&&
literal|"Operands already allocated"
argument_list|)
expr_stmt|;
name|Operands
operator|=
name|Recycler
operator|.
name|allocate
argument_list|(
name|RecyclerCapacity
operator|::
name|get
argument_list|(
name|MaxOperands
argument_list|)
argument_list|,
name|Allocator
argument_list|)
expr_stmt|;
block|}
name|void
name|deallocateOperands
parameter_list|(
name|RecyclerType
modifier|&
name|Recycler
parameter_list|)
block|{
name|Recycler
operator|.
name|deallocate
argument_list|(
name|RecyclerCapacity
operator|::
name|get
argument_list|(
name|MaxOperands
argument_list|)
argument_list|,
name|Operands
argument_list|)
expr_stmt|;
block|}
name|void
name|setType
parameter_list|(
name|Type
modifier|*
name|T
parameter_list|)
block|{
name|ValueType
operator|=
name|T
expr_stmt|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|ValueType
return|;
block|}
name|bool
name|equals
argument_list|(
specifier|const
name|Expression
operator|&
name|Other
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
name|getOpcode
argument_list|()
operator|!=
name|Other
operator|.
name|getOpcode
argument_list|()
condition|)
return|return
name|false
return|;
specifier|const
specifier|auto
modifier|&
name|OE
init|=
name|cast
operator|<
name|BasicExpression
operator|>
operator|(
name|Other
operator|)
decl_stmt|;
return|return
name|getType
argument_list|()
operator|==
name|OE
operator|.
name|getType
argument_list|()
operator|&&
name|NumOperands
operator|==
name|OE
operator|.
name|NumOperands
operator|&&
name|std
operator|::
name|equal
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|,
name|OE
operator|.
name|op_begin
argument_list|()
argument_list|)
return|;
block|}
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|Expression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|ValueType
argument_list|,
name|hash_combine_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintEType
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeBasic, "
expr_stmt|;
name|this
operator|->
name|Expression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|OS
operator|<<
literal|"operands = {"
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumOperands
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|OS
operator|<<
literal|"["
operator|<<
name|i
operator|<<
literal|"] = "
expr_stmt|;
name|Operands
index|[
name|i
index|]
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|)
expr_stmt|;
name|OS
operator|<<
literal|"  "
expr_stmt|;
block|}
name|OS
operator|<<
literal|"} "
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|op_inserter
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|output_iterator_tag
decl_stmt|,
name|void
decl_stmt|,
name|void
decl_stmt|,
name|void
decl_stmt|,
name|void
decl|>
block|{
name|private
label|:
typedef|typedef
name|BasicExpression
name|Container
typedef|;
name|Container
modifier|*
name|BE
decl_stmt|;
name|public
label|:
name|explicit
name|op_inserter
argument_list|(
name|BasicExpression
operator|&
name|E
argument_list|)
operator|:
name|BE
argument_list|(
argument|&E
argument_list|)
block|{}
name|explicit
name|op_inserter
argument_list|(
name|BasicExpression
operator|*
name|E
argument_list|)
operator|:
name|BE
argument_list|(
argument|E
argument_list|)
block|{}
name|op_inserter
operator|&
name|operator
operator|=
operator|(
name|Value
operator|*
name|val
operator|)
block|{
name|BE
operator|->
name|op_push_back
argument_list|(
name|val
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|op_inserter
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
name|op_inserter
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
name|op_inserter
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|MemoryExpression
range|:
name|public
name|BasicExpression
block|{
name|private
operator|:
specifier|const
name|MemoryAccess
operator|*
name|MemoryLeader
block|;
name|public
operator|:
name|MemoryExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|enum ExpressionType EType
argument_list|,
argument|const MemoryAccess *MemoryLeader
argument_list|)
operator|:
name|BasicExpression
argument_list|(
name|NumOperands
argument_list|,
name|EType
argument_list|)
block|,
name|MemoryLeader
argument_list|(
argument|MemoryLeader
argument_list|)
block|{}
block|;
name|MemoryExpression
argument_list|()
operator|=
name|delete
block|;
name|MemoryExpression
argument_list|(
specifier|const
name|MemoryExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|MemoryExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|MemoryExpression
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|>
name|ET_MemoryStart
operator|&&
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|<
name|ET_MemoryEnd
return|;
block|}
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|BasicExpression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|MemoryLeader
argument_list|)
return|;
block|}
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
operator|!
name|this
operator|->
name|BasicExpression
operator|::
name|equals
argument_list|(
name|Other
argument_list|)
condition|)
return|return
name|false
return|;
specifier|const
name|MemoryExpression
operator|&
name|OtherMCE
operator|=
name|cast
operator|<
name|MemoryExpression
operator|>
operator|(
name|Other
operator|)
block|;
return|return
name|MemoryLeader
operator|==
name|OtherMCE
operator|.
name|MemoryLeader
return|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|const
name|MemoryAccess
operator|*
name|getMemoryLeader
argument_list|()
specifier|const
block|{
return|return
name|MemoryLeader
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setMemoryLeader
parameter_list|(
specifier|const
name|MemoryAccess
modifier|*
name|ML
parameter_list|)
block|{
name|MemoryLeader
operator|=
name|ML
expr_stmt|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|CallExpression
name|final
range|:
name|public
name|MemoryExpression
block|{
name|private
operator|:
name|CallInst
operator|*
name|Call
block|;
name|public
operator|:
name|CallExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|CallInst *C
argument_list|,
argument|const MemoryAccess *MemoryLeader
argument_list|)
operator|:
name|MemoryExpression
argument_list|(
name|NumOperands
argument_list|,
name|ET_Call
argument_list|,
name|MemoryLeader
argument_list|)
block|,
name|Call
argument_list|(
argument|C
argument_list|)
block|{}
name|CallExpression
argument_list|()
operator|=
name|delete
block|;
name|CallExpression
argument_list|(
specifier|const
name|CallExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|CallExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|CallExpression
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|CallExpression
argument_list|()
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Call
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeCall, "
expr_stmt|;
name|this
operator|->
name|BasicExpression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" represents call at "
block|;
name|Call
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|)
block|;   }
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|LoadExpression
name|final
range|:
name|public
name|MemoryExpression
block|{
name|private
operator|:
name|LoadInst
operator|*
name|Load
block|;
name|unsigned
name|Alignment
block|;
name|public
operator|:
name|LoadExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|LoadInst *L
argument_list|,
argument|const MemoryAccess *MemoryLeader
argument_list|)
operator|:
name|LoadExpression
argument_list|(
argument|ET_Load
argument_list|,
argument|NumOperands
argument_list|,
argument|L
argument_list|,
argument|MemoryLeader
argument_list|)
block|{}
name|LoadExpression
argument_list|(
argument|enum ExpressionType EType
argument_list|,
argument|unsigned NumOperands
argument_list|,
argument|LoadInst *L
argument_list|,
argument|const MemoryAccess *MemoryLeader
argument_list|)
operator|:
name|MemoryExpression
argument_list|(
name|NumOperands
argument_list|,
name|EType
argument_list|,
name|MemoryLeader
argument_list|)
block|,
name|Load
argument_list|(
argument|L
argument_list|)
block|{
name|Alignment
operator|=
name|L
operator|?
name|L
operator|->
name|getAlignment
argument_list|()
operator|:
literal|0
block|;   }
name|LoadExpression
argument_list|()
operator|=
name|delete
block|;
name|LoadExpression
argument_list|(
specifier|const
name|LoadExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|LoadExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|LoadExpression
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|LoadExpression
argument_list|()
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Load
return|;
block|}
name|LoadInst
operator|*
name|getLoadInst
argument_list|()
specifier|const
block|{
return|return
name|Load
return|;
block|}
name|void
name|setLoadInst
argument_list|(
argument|LoadInst *L
argument_list|)
block|{
name|Load
operator|=
name|L
block|; }
name|unsigned
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|Alignment
return|;
block|}
name|void
name|setAlignment
argument_list|(
argument|unsigned Align
argument_list|)
block|{
name|Alignment
operator|=
name|Align
block|; }
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|;
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeLoad, "
expr_stmt|;
name|this
operator|->
name|BasicExpression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" represents Load at "
block|;
name|Load
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|)
block|;
name|OS
operator|<<
literal|" with MemoryLeader "
operator|<<
operator|*
name|getMemoryLeader
argument_list|()
block|;   }
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|StoreExpression
name|final
range|:
name|public
name|MemoryExpression
block|{
name|private
operator|:
name|StoreInst
operator|*
name|Store
block|;
name|Value
operator|*
name|StoredValue
block|;
name|public
operator|:
name|StoreExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|StoreInst *S
argument_list|,
argument|Value *StoredValue
argument_list|,
argument|const MemoryAccess *MemoryLeader
argument_list|)
operator|:
name|MemoryExpression
argument_list|(
name|NumOperands
argument_list|,
name|ET_Store
argument_list|,
name|MemoryLeader
argument_list|)
block|,
name|Store
argument_list|(
name|S
argument_list|)
block|,
name|StoredValue
argument_list|(
argument|StoredValue
argument_list|)
block|{}
name|StoreExpression
argument_list|()
operator|=
name|delete
block|;
name|StoreExpression
argument_list|(
specifier|const
name|StoreExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|StoreExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|StoreExpression
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|StoreExpression
argument_list|()
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Store
return|;
block|}
name|StoreInst
operator|*
name|getStoreInst
argument_list|()
specifier|const
block|{
return|return
name|Store
return|;
block|}
name|Value
operator|*
name|getStoredValue
argument_list|()
specifier|const
block|{
return|return
name|StoredValue
return|;
block|}
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|;
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeStore, "
expr_stmt|;
name|this
operator|->
name|BasicExpression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" represents Store  "
operator|<<
operator|*
name|Store
block|;
name|OS
operator|<<
literal|" with StoredValue "
block|;
name|StoredValue
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|)
block|;
name|OS
operator|<<
literal|" and MemoryLeader "
operator|<<
operator|*
name|getMemoryLeader
argument_list|()
block|;   }
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|AggregateValueExpression
name|final
range|:
name|public
name|BasicExpression
block|{
name|private
operator|:
name|unsigned
name|MaxIntOperands
block|;
name|unsigned
name|NumIntOperands
block|;
name|unsigned
operator|*
name|IntOperands
block|;
name|public
operator|:
name|AggregateValueExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|unsigned NumIntOperands
argument_list|)
operator|:
name|BasicExpression
argument_list|(
name|NumOperands
argument_list|,
name|ET_AggregateValue
argument_list|)
block|,
name|MaxIntOperands
argument_list|(
name|NumIntOperands
argument_list|)
block|,
name|NumIntOperands
argument_list|(
literal|0
argument_list|)
block|,
name|IntOperands
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|AggregateValueExpression
argument_list|()
operator|=
name|delete
block|;
name|AggregateValueExpression
argument_list|(
specifier|const
name|AggregateValueExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|AggregateValueExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|AggregateValueExpression
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|AggregateValueExpression
argument_list|()
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_AggregateValue
return|;
block|}
typedef|typedef
name|unsigned
modifier|*
name|int_arg_iterator
typedef|;
end_decl_stmt

begin_typedef
typedef|typedef
specifier|const
name|unsigned
modifier|*
name|const_int_arg_iterator
typedef|;
end_typedef

begin_function
name|int_arg_iterator
name|int_op_begin
parameter_list|()
block|{
return|return
name|IntOperands
return|;
block|}
end_function

begin_function
name|int_arg_iterator
name|int_op_end
parameter_list|()
block|{
return|return
name|IntOperands
operator|+
name|NumIntOperands
return|;
block|}
end_function

begin_expr_stmt
name|const_int_arg_iterator
name|int_op_begin
argument_list|()
specifier|const
block|{
return|return
name|IntOperands
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_int_arg_iterator
name|int_op_end
argument_list|()
specifier|const
block|{
return|return
name|IntOperands
operator|+
name|NumIntOperands
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|int_op_size
argument_list|()
specifier|const
block|{
return|return
name|NumIntOperands
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|int_op_empty
argument_list|()
specifier|const
block|{
return|return
name|NumIntOperands
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_function
name|void
name|int_op_push_back
parameter_list|(
name|unsigned
name|IntOperand
parameter_list|)
block|{
name|assert
argument_list|(
name|NumIntOperands
operator|<
name|MaxIntOperands
operator|&&
literal|"Tried to add too many int operands"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|IntOperands
operator|&&
literal|"Operands not allocated before pushing"
argument_list|)
expr_stmt|;
name|IntOperands
index|[
name|NumIntOperands
operator|++
index|]
operator|=
name|IntOperand
expr_stmt|;
block|}
end_function

begin_function
name|virtual
name|void
name|allocateIntOperands
parameter_list|(
name|BumpPtrAllocator
modifier|&
name|Allocator
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|IntOperands
operator|&&
literal|"Operands already allocated"
argument_list|)
expr_stmt|;
name|IntOperands
operator|=
name|Allocator
operator|.
name|Allocate
operator|<
name|unsigned
operator|>
operator|(
name|MaxIntOperands
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|equals
argument_list|(
specifier|const
name|Expression
operator|&
name|Other
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
operator|!
name|this
operator|->
name|BasicExpression
operator|::
name|equals
argument_list|(
name|Other
argument_list|)
condition|)
return|return
name|false
return|;
specifier|const
name|AggregateValueExpression
modifier|&
name|OE
init|=
name|cast
operator|<
name|AggregateValueExpression
operator|>
operator|(
name|Other
operator|)
decl_stmt|;
return|return
name|NumIntOperands
operator|==
name|OE
operator|.
name|NumIntOperands
operator|&&
name|std
operator|::
name|equal
argument_list|(
name|int_op_begin
argument_list|()
argument_list|,
name|int_op_end
argument_list|()
argument_list|,
name|OE
operator|.
name|int_op_begin
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|BasicExpression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|hash_combine_range
argument_list|(
name|int_op_begin
argument_list|()
argument_list|,
name|int_op_end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// Debugging support
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|void
name|printInternal
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintEType
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeAggregateValue, "
expr_stmt|;
name|this
operator|->
name|BasicExpression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|OS
operator|<<
literal|", intoperands = {"
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|int_op_size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|OS
operator|<<
literal|"["
operator|<<
name|i
operator|<<
literal|"] = "
operator|<<
name|IntOperands
index|[
name|i
index|]
operator|<<
literal|"  "
expr_stmt|;
block|}
name|OS
operator|<<
literal|"}"
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|int_op_inserter
range|:
name|public
name|std
operator|::
name|iterator
operator|<
name|std
operator|::
name|output_iterator_tag
decl_stmt|,
name|void
decl_stmt|,
name|void
decl_stmt|,
name|void
decl_stmt|,
name|void
decl|>
block|{
name|private
label|:
typedef|typedef
name|AggregateValueExpression
name|Container
typedef|;
name|Container
modifier|*
name|AVE
decl_stmt|;
name|public
label|:
name|explicit
name|int_op_inserter
argument_list|(
name|AggregateValueExpression
operator|&
name|E
argument_list|)
operator|:
name|AVE
argument_list|(
argument|&E
argument_list|)
block|{}
name|explicit
name|int_op_inserter
argument_list|(
name|AggregateValueExpression
operator|*
name|E
argument_list|)
operator|:
name|AVE
argument_list|(
argument|E
argument_list|)
block|{}
name|int_op_inserter
operator|&
name|operator
operator|=
operator|(
name|unsigned
name|int
name|val
operator|)
block|{
name|AVE
operator|->
name|int_op_push_back
argument_list|(
name|val
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|int_op_inserter
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
name|int_op_inserter
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
name|int_op_inserter
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|PHIExpression
name|final
range|:
name|public
name|BasicExpression
block|{
name|private
operator|:
name|BasicBlock
operator|*
name|BB
block|;
name|public
operator|:
name|PHIExpression
argument_list|(
argument|unsigned NumOperands
argument_list|,
argument|BasicBlock *B
argument_list|)
operator|:
name|BasicExpression
argument_list|(
name|NumOperands
argument_list|,
name|ET_Phi
argument_list|)
block|,
name|BB
argument_list|(
argument|B
argument_list|)
block|{}
name|PHIExpression
argument_list|()
operator|=
name|delete
block|;
name|PHIExpression
argument_list|(
specifier|const
name|PHIExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|PHIExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|PHIExpression
operator|&
operator|)
operator|=
name|delete
block|;
operator|~
name|PHIExpression
argument_list|()
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Phi
return|;
block|}
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
operator|!
name|this
operator|->
name|BasicExpression
operator|::
name|equals
argument_list|(
name|Other
argument_list|)
condition|)
return|return
name|false
return|;
specifier|const
name|PHIExpression
operator|&
name|OE
operator|=
name|cast
operator|<
name|PHIExpression
operator|>
operator|(
name|Other
operator|)
block|;
return|return
name|BB
operator|==
name|OE
operator|.
name|BB
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|BasicExpression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// Debugging support
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|void
name|printInternal
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|bool
name|PrintEType
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypePhi, "
expr_stmt|;
name|this
operator|->
name|BasicExpression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|OS
operator|<<
literal|"bb = "
operator|<<
name|BB
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|DeadExpression
name|final
range|:
name|public
name|Expression
block|{
name|public
operator|:
name|DeadExpression
argument_list|()
operator|:
name|Expression
argument_list|(
argument|ET_Dead
argument_list|)
block|{}
name|DeadExpression
argument_list|(
specifier|const
name|DeadExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|DeadExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DeadExpression
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *E
argument_list|)
block|{
return|return
name|E
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Dead
return|;
block|}
expr|}
block|;
name|class
name|VariableExpression
name|final
operator|:
name|public
name|Expression
block|{
name|private
operator|:
name|Value
operator|*
name|VariableValue
block|;
name|public
operator|:
name|VariableExpression
argument_list|(
name|Value
operator|*
name|V
argument_list|)
operator|:
name|Expression
argument_list|(
name|ET_Variable
argument_list|)
block|,
name|VariableValue
argument_list|(
argument|V
argument_list|)
block|{}
name|VariableExpression
argument_list|()
operator|=
name|delete
block|;
name|VariableExpression
argument_list|(
specifier|const
name|VariableExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|VariableExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|VariableExpression
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Variable
return|;
block|}
name|Value
operator|*
name|getVariableValue
argument_list|()
specifier|const
block|{
return|return
name|VariableValue
return|;
block|}
name|void
name|setVariableValue
argument_list|(
argument|Value *V
argument_list|)
block|{
name|VariableValue
operator|=
name|V
block|; }
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|{
specifier|const
name|VariableExpression
operator|&
name|OC
operator|=
name|cast
operator|<
name|VariableExpression
operator|>
operator|(
name|Other
operator|)
block|;
return|return
name|VariableValue
operator|==
name|OC
operator|.
name|VariableValue
return|;
block|}
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|Expression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|VariableValue
operator|->
name|getType
argument_list|()
argument_list|,
name|VariableValue
argument_list|)
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeVariable, "
expr_stmt|;
name|this
operator|->
name|Expression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" variable = "
operator|<<
operator|*
name|VariableValue
block|;   }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|ConstantExpression
name|final
range|:
name|public
name|Expression
block|{
name|private
operator|:
name|Constant
operator|*
name|ConstantValue
operator|=
name|nullptr
block|;
name|public
operator|:
name|ConstantExpression
argument_list|()
operator|:
name|Expression
argument_list|(
argument|ET_Constant
argument_list|)
block|{}
name|ConstantExpression
argument_list|(
name|Constant
operator|*
name|constantValue
argument_list|)
operator|:
name|Expression
argument_list|(
name|ET_Constant
argument_list|)
block|,
name|ConstantValue
argument_list|(
argument|constantValue
argument_list|)
block|{}
name|ConstantExpression
argument_list|(
specifier|const
name|ConstantExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|ConstantExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|ConstantExpression
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Constant
return|;
block|}
name|Constant
operator|*
name|getConstantValue
argument_list|()
specifier|const
block|{
return|return
name|ConstantValue
return|;
block|}
name|void
name|setConstantValue
argument_list|(
argument|Constant *V
argument_list|)
block|{
name|ConstantValue
operator|=
name|V
block|; }
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|{
specifier|const
name|ConstantExpression
operator|&
name|OC
operator|=
name|cast
operator|<
name|ConstantExpression
operator|>
operator|(
name|Other
operator|)
block|;
return|return
name|ConstantValue
operator|==
name|OC
operator|.
name|ConstantValue
return|;
block|}
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|Expression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|ConstantValue
operator|->
name|getType
argument_list|()
argument_list|,
name|ConstantValue
argument_list|)
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeConstant, "
expr_stmt|;
name|this
operator|->
name|Expression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" constant = "
operator|<<
operator|*
name|ConstantValue
block|;   }
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|UnknownExpression
name|final
range|:
name|public
name|Expression
block|{
name|private
operator|:
name|Instruction
operator|*
name|Inst
block|;
name|public
operator|:
name|UnknownExpression
argument_list|(
name|Instruction
operator|*
name|I
argument_list|)
operator|:
name|Expression
argument_list|(
name|ET_Unknown
argument_list|)
block|,
name|Inst
argument_list|(
argument|I
argument_list|)
block|{}
name|UnknownExpression
argument_list|()
operator|=
name|delete
block|;
name|UnknownExpression
argument_list|(
specifier|const
name|UnknownExpression
operator|&
argument_list|)
operator|=
name|delete
block|;
name|UnknownExpression
operator|&
name|operator
operator|=
operator|(
specifier|const
name|UnknownExpression
operator|&
operator|)
operator|=
name|delete
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Expression *EB
argument_list|)
block|{
return|return
name|EB
operator|->
name|getExpressionType
argument_list|()
operator|==
name|ET_Unknown
return|;
block|}
name|Instruction
operator|*
name|getInstruction
argument_list|()
specifier|const
block|{
return|return
name|Inst
return|;
block|}
name|void
name|setInstruction
argument_list|(
argument|Instruction *I
argument_list|)
block|{
name|Inst
operator|=
name|I
block|; }
name|bool
name|equals
argument_list|(
argument|const Expression&Other
argument_list|)
specifier|const
name|override
block|{
specifier|const
name|auto
operator|&
name|OU
operator|=
name|cast
operator|<
name|UnknownExpression
operator|>
operator|(
name|Other
operator|)
block|;
return|return
name|Inst
operator|==
name|OU
operator|.
name|Inst
return|;
block|}
name|hash_code
name|getHashValue
argument_list|()
specifier|const
name|override
block|{
return|return
name|hash_combine
argument_list|(
name|this
operator|->
name|Expression
operator|::
name|getHashValue
argument_list|()
argument_list|,
name|Inst
argument_list|)
return|;
block|}
comment|//
comment|// Debugging support
comment|//
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|bool PrintEType
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|PrintEType
condition|)
name|OS
operator|<<
literal|"ExpressionTypeUnknown, "
expr_stmt|;
name|this
operator|->
name|Expression
operator|::
name|printInternal
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
block|;
name|OS
operator|<<
literal|" inst = "
operator|<<
operator|*
name|Inst
block|;   }
end_decl_stmt

begin_comment
unit|};  }
comment|// end namespace GVNExpression
end_comment

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TRANSFORMS_SCALAR_GVNEXPRESSION_H
end_comment

end_unit

