begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- SSAUpdaterImpl.h - SSA Updater Implementation -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides a template that implements the core algorithm for the
end_comment

begin_comment
comment|// SSAUpdater and MachineSSAUpdater.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TRANSFORMS_UTILS_SSAUPDATERIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TRANSFORMS_UTILS_SSAUPDATERIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_TYPE
value|"ssaupdater"
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CastInst
decl_stmt|;
name|class
name|PHINode
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SSAUpdaterTraits
expr_stmt|;
name|template
operator|<
name|typename
name|UpdaterT
operator|>
name|class
name|SSAUpdaterImpl
block|{
name|private
operator|:
name|UpdaterT
operator|*
name|Updater
block|;
typedef|typedef
name|SSAUpdaterTraits
operator|<
name|UpdaterT
operator|>
name|Traits
expr_stmt|;
typedef|typedef
name|typename
name|Traits
operator|::
name|BlkT
name|BlkT
expr_stmt|;
typedef|typedef
name|typename
name|Traits
operator|::
name|ValT
name|ValT
expr_stmt|;
typedef|typedef
name|typename
name|Traits
operator|::
name|PhiT
name|PhiT
expr_stmt|;
comment|/// BBInfo - Per-basic block information used internally by SSAUpdaterImpl.
comment|/// The predecessors of each block are cached here since pred_iterator is
comment|/// slow and we need to iterate over the blocks at least a few times.
name|class
name|BBInfo
block|{
name|public
label|:
name|BlkT
modifier|*
name|BB
decl_stmt|;
comment|// Back-pointer to the corresponding block.
name|ValT
name|AvailableVal
decl_stmt|;
comment|// Value to use in this block.
name|BBInfo
modifier|*
name|DefBB
decl_stmt|;
comment|// Block that defines the available value.
name|int
name|BlkNum
decl_stmt|;
comment|// Postorder number.
name|BBInfo
modifier|*
name|IDom
decl_stmt|;
comment|// Immediate dominator.
name|unsigned
name|NumPreds
decl_stmt|;
comment|// Number of predecessor blocks.
name|BBInfo
modifier|*
modifier|*
name|Preds
decl_stmt|;
comment|// Array[NumPreds] of predecessor blocks.
name|PhiT
modifier|*
name|PHITag
decl_stmt|;
comment|// Marker for existing PHIs that match.
name|BBInfo
argument_list|(
argument|BlkT *ThisBB
argument_list|,
argument|ValT V
argument_list|)
block|:
name|BB
argument_list|(
name|ThisBB
argument_list|)
operator|,
name|AvailableVal
argument_list|(
name|V
argument_list|)
operator|,
name|DefBB
argument_list|(
name|V
condition|?
name|this
else|:
name|nullptr
argument_list|)
operator|,
name|BlkNum
argument_list|(
literal|0
argument_list|)
operator|,
name|IDom
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NumPreds
argument_list|(
literal|0
argument_list|)
operator|,
name|Preds
argument_list|(
name|nullptr
argument_list|)
operator|,
name|PHITag
argument_list|(
argument|nullptr
argument_list|)
block|{}
block|}
empty_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|BlkT
operator|*
operator|,
name|ValT
operator|>
name|AvailableValsTy
expr_stmt|;
name|AvailableValsTy
modifier|*
name|AvailableVals
decl_stmt|;
name|SmallVectorImpl
operator|<
name|PhiT
operator|*
operator|>
operator|*
name|InsertedPHIs
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|BBInfo
operator|*
operator|>
name|BlockListTy
expr_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|BlkT
operator|*
operator|,
name|BBInfo
operator|*
operator|>
name|BBMapTy
expr_stmt|;
name|BBMapTy
name|BBMap
decl_stmt|;
name|BumpPtrAllocator
name|Allocator
decl_stmt|;
name|public
label|:
name|explicit
name|SSAUpdaterImpl
argument_list|(
name|UpdaterT
operator|*
name|U
argument_list|,
name|AvailableValsTy
operator|*
name|A
argument_list|,
name|SmallVectorImpl
operator|<
name|PhiT
operator|*
operator|>
operator|*
name|Ins
argument_list|)
range|:
name|Updater
argument_list|(
name|U
argument_list|)
decl_stmt|,
name|AvailableVals
argument_list|(
name|A
argument_list|)
decl_stmt|,
name|InsertedPHIs
argument_list|(
name|Ins
argument_list|)
block|{ }
comment|/// GetValue - Check to see if AvailableVals has an entry for the specified
comment|/// BB and if so, return it.  If not, construct SSA form by first
comment|/// calculating the required placement of PHIs and then inserting new PHIs
comment|/// where needed.
name|ValT
name|GetValue
parameter_list|(
name|BlkT
modifier|*
name|BB
parameter_list|)
block|{
name|SmallVector
operator|<
name|BBInfo
operator|*
operator|,
literal|100
operator|>
name|BlockList
expr_stmt|;
name|BBInfo
modifier|*
name|PseudoEntry
init|=
name|BuildBlockList
argument_list|(
name|BB
argument_list|,
operator|&
name|BlockList
argument_list|)
decl_stmt|;
comment|// Special case: bail out if BB is unreachable.
if|if
condition|(
name|BlockList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ValT
name|V
init|=
name|Traits
operator|::
name|GetUndefVal
argument_list|(
name|BB
argument_list|,
name|Updater
argument_list|)
decl_stmt|;
operator|(
operator|*
name|AvailableVals
operator|)
index|[
name|BB
index|]
operator|=
name|V
expr_stmt|;
return|return
name|V
return|;
block|}
name|FindDominators
argument_list|(
operator|&
name|BlockList
argument_list|,
name|PseudoEntry
argument_list|)
expr_stmt|;
name|FindPHIPlacement
argument_list|(
operator|&
name|BlockList
argument_list|)
expr_stmt|;
name|FindAvailableVals
argument_list|(
operator|&
name|BlockList
argument_list|)
expr_stmt|;
return|return
name|BBMap
index|[
name|BB
index|]
operator|->
name|DefBB
operator|->
name|AvailableVal
return|;
block|}
comment|/// BuildBlockList - Starting from the specified basic block, traverse back
comment|/// through its predecessors until reaching blocks with known values.
comment|/// Create BBInfo structures for the blocks and append them to the block
comment|/// list.
name|BBInfo
modifier|*
name|BuildBlockList
parameter_list|(
name|BlkT
modifier|*
name|BB
parameter_list|,
name|BlockListTy
modifier|*
name|BlockList
parameter_list|)
block|{
name|SmallVector
operator|<
name|BBInfo
operator|*
operator|,
literal|10
operator|>
name|RootList
expr_stmt|;
name|SmallVector
operator|<
name|BBInfo
operator|*
operator|,
literal|64
operator|>
name|WorkList
expr_stmt|;
name|BBInfo
modifier|*
name|Info
init|=
name|new
argument_list|(
argument|Allocator
argument_list|)
name|BBInfo
argument_list|(
name|BB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|BBMap
index|[
name|BB
index|]
operator|=
name|Info
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|Info
argument_list|)
expr_stmt|;
comment|// Search backward from BB, creating BBInfos along the way and stopping
comment|// when reaching blocks that define the value.  Record those defining
comment|// blocks on the RootList.
name|SmallVector
operator|<
name|BlkT
operator|*
operator|,
literal|10
operator|>
name|Preds
expr_stmt|;
while|while
condition|(
operator|!
name|WorkList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Info
operator|=
name|WorkList
operator|.
name|pop_back_val
argument_list|()
expr_stmt|;
name|Preds
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Traits
operator|::
name|FindPredecessorBlocks
argument_list|(
name|Info
operator|->
name|BB
argument_list|,
operator|&
name|Preds
argument_list|)
expr_stmt|;
name|Info
operator|->
name|NumPreds
operator|=
name|Preds
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|Info
operator|->
name|NumPreds
operator|==
literal|0
condition|)
name|Info
operator|->
name|Preds
operator|=
name|nullptr
expr_stmt|;
else|else
name|Info
operator|->
name|Preds
operator|=
name|static_cast
operator|<
name|BBInfo
operator|*
operator|*
operator|>
operator|(
name|Allocator
operator|.
name|Allocate
argument_list|(
name|Info
operator|->
name|NumPreds
operator|*
sizeof|sizeof
argument_list|(
name|BBInfo
operator|*
argument_list|)
argument_list|,
name|alignof
argument_list|(
name|BBInfo
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|unsigned
name|p
init|=
literal|0
init|;
name|p
operator|!=
name|Info
operator|->
name|NumPreds
condition|;
operator|++
name|p
control|)
block|{
name|BlkT
modifier|*
name|Pred
init|=
name|Preds
index|[
name|p
index|]
decl_stmt|;
comment|// Check if BBMap already has a BBInfo for the predecessor block.
name|typename
name|BBMapTy
operator|::
name|value_type
operator|&
name|BBMapBucket
operator|=
name|BBMap
operator|.
name|FindAndConstruct
argument_list|(
name|Pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|BBMapBucket
operator|.
name|second
condition|)
block|{
name|Info
operator|->
name|Preds
index|[
name|p
index|]
operator|=
name|BBMapBucket
operator|.
name|second
expr_stmt|;
continue|continue;
block|}
comment|// Create a new BBInfo for the predecessor.
name|ValT
name|PredVal
init|=
name|AvailableVals
operator|->
name|lookup
argument_list|(
name|Pred
argument_list|)
decl_stmt|;
name|BBInfo
modifier|*
name|PredInfo
init|=
name|new
argument_list|(
argument|Allocator
argument_list|)
name|BBInfo
argument_list|(
name|Pred
argument_list|,
name|PredVal
argument_list|)
decl_stmt|;
name|BBMapBucket
operator|.
name|second
operator|=
name|PredInfo
expr_stmt|;
name|Info
operator|->
name|Preds
index|[
name|p
index|]
operator|=
name|PredInfo
expr_stmt|;
if|if
condition|(
name|PredInfo
operator|->
name|AvailableVal
condition|)
block|{
name|RootList
operator|.
name|push_back
argument_list|(
name|PredInfo
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|WorkList
operator|.
name|push_back
argument_list|(
name|PredInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now that we know what blocks are backwards-reachable from the starting
comment|// block, do a forward depth-first traversal to assign postorder numbers
comment|// to those blocks.
name|BBInfo
modifier|*
name|PseudoEntry
init|=
name|new
argument_list|(
argument|Allocator
argument_list|)
name|BBInfo
argument_list|(
name|nullptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|BlkNum
init|=
literal|1
decl_stmt|;
comment|// Initialize the worklist with the roots from the backward traversal.
while|while
condition|(
operator|!
name|RootList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Info
operator|=
name|RootList
operator|.
name|pop_back_val
argument_list|()
expr_stmt|;
name|Info
operator|->
name|IDom
operator|=
name|PseudoEntry
expr_stmt|;
name|Info
operator|->
name|BlkNum
operator|=
operator|-
literal|1
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|Info
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|WorkList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Info
operator|=
name|WorkList
operator|.
name|back
argument_list|()
expr_stmt|;
if|if
condition|(
name|Info
operator|->
name|BlkNum
operator|==
operator|-
literal|2
condition|)
block|{
comment|// All the successors have been handled; assign the postorder number.
name|Info
operator|->
name|BlkNum
operator|=
name|BlkNum
operator|++
expr_stmt|;
comment|// If not a root, put it on the BlockList.
if|if
condition|(
operator|!
name|Info
operator|->
name|AvailableVal
condition|)
name|BlockList
operator|->
name|push_back
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|WorkList
operator|.
name|pop_back
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Leave this entry on the worklist, but set its BlkNum to mark that its
comment|// successors have been put on the worklist.  When it returns to the top
comment|// the list, after handling its successors, it will be assigned a
comment|// number.
name|Info
operator|->
name|BlkNum
operator|=
operator|-
literal|2
expr_stmt|;
comment|// Add unvisited successors to the work list.
for|for
control|(
name|typename
name|Traits
operator|::
name|BlkSucc_iterator
name|SI
operator|=
name|Traits
operator|::
name|BlkSucc_begin
argument_list|(
name|Info
operator|->
name|BB
argument_list|)
operator|,
name|E
operator|=
name|Traits
operator|::
name|BlkSucc_end
argument_list|(
name|Info
operator|->
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|E
condition|;
operator|++
name|SI
control|)
block|{
name|BBInfo
modifier|*
name|SuccInfo
init|=
name|BBMap
index|[
operator|*
name|SI
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|SuccInfo
operator|||
name|SuccInfo
operator|->
name|BlkNum
condition|)
continue|continue;
name|SuccInfo
operator|->
name|BlkNum
operator|=
operator|-
literal|1
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|SuccInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|PseudoEntry
operator|->
name|BlkNum
operator|=
name|BlkNum
expr_stmt|;
return|return
name|PseudoEntry
return|;
block|}
comment|/// IntersectDominators - This is the dataflow lattice "meet" operation for
comment|/// finding dominators.  Given two basic blocks, it walks up the dominator
comment|/// tree until it finds a common dominator of both.  It uses the postorder
comment|/// number of the blocks to determine how to do that.
name|BBInfo
modifier|*
name|IntersectDominators
parameter_list|(
name|BBInfo
modifier|*
name|Blk1
parameter_list|,
name|BBInfo
modifier|*
name|Blk2
parameter_list|)
block|{
while|while
condition|(
name|Blk1
operator|!=
name|Blk2
condition|)
block|{
while|while
condition|(
name|Blk1
operator|->
name|BlkNum
operator|<
name|Blk2
operator|->
name|BlkNum
condition|)
block|{
name|Blk1
operator|=
name|Blk1
operator|->
name|IDom
expr_stmt|;
if|if
condition|(
operator|!
name|Blk1
condition|)
return|return
name|Blk2
return|;
block|}
while|while
condition|(
name|Blk2
operator|->
name|BlkNum
operator|<
name|Blk1
operator|->
name|BlkNum
condition|)
block|{
name|Blk2
operator|=
name|Blk2
operator|->
name|IDom
expr_stmt|;
if|if
condition|(
operator|!
name|Blk2
condition|)
return|return
name|Blk1
return|;
block|}
block|}
return|return
name|Blk1
return|;
block|}
comment|/// FindDominators - Calculate the dominator tree for the subset of the CFG
comment|/// corresponding to the basic blocks on the BlockList.  This uses the
comment|/// algorithm from: "A Simple, Fast Dominance Algorithm" by Cooper, Harvey
comment|/// and Kennedy, published in Software--Practice and Experience, 2001,
comment|/// 4:1-10.  Because the CFG subset does not include any edges leading into
comment|/// blocks that define the value, the results are not the usual dominator
comment|/// tree.  The CFG subset has a single pseudo-entry node with edges to a set
comment|/// of root nodes for blocks that define the value.  The dominators for this
comment|/// subset CFG are not the standard dominators but they are adequate for
comment|/// placing PHIs within the subset CFG.
name|void
name|FindDominators
parameter_list|(
name|BlockListTy
modifier|*
name|BlockList
parameter_list|,
name|BBInfo
modifier|*
name|PseudoEntry
parameter_list|)
block|{
name|bool
name|Changed
decl_stmt|;
do|do
block|{
name|Changed
operator|=
name|false
expr_stmt|;
comment|// Iterate over the list in reverse order, i.e., forward on CFG edges.
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|reverse_iterator
name|I
operator|=
name|BlockList
operator|->
name|rbegin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|rend
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BBInfo
modifier|*
name|Info
init|=
operator|*
name|I
decl_stmt|;
name|BBInfo
modifier|*
name|NewIDom
init|=
name|nullptr
decl_stmt|;
comment|// Iterate through the block's predecessors.
for|for
control|(
name|unsigned
name|p
init|=
literal|0
init|;
name|p
operator|!=
name|Info
operator|->
name|NumPreds
condition|;
operator|++
name|p
control|)
block|{
name|BBInfo
modifier|*
name|Pred
init|=
name|Info
operator|->
name|Preds
index|[
name|p
index|]
decl_stmt|;
comment|// Treat an unreachable predecessor as a definition with 'undef'.
if|if
condition|(
name|Pred
operator|->
name|BlkNum
operator|==
literal|0
condition|)
block|{
name|Pred
operator|->
name|AvailableVal
operator|=
name|Traits
operator|::
name|GetUndefVal
argument_list|(
name|Pred
operator|->
name|BB
argument_list|,
name|Updater
argument_list|)
expr_stmt|;
operator|(
operator|*
name|AvailableVals
operator|)
index|[
name|Pred
operator|->
name|BB
index|]
operator|=
name|Pred
operator|->
name|AvailableVal
expr_stmt|;
name|Pred
operator|->
name|DefBB
operator|=
name|Pred
expr_stmt|;
name|Pred
operator|->
name|BlkNum
operator|=
name|PseudoEntry
operator|->
name|BlkNum
expr_stmt|;
name|PseudoEntry
operator|->
name|BlkNum
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NewIDom
condition|)
name|NewIDom
operator|=
name|Pred
expr_stmt|;
else|else
name|NewIDom
operator|=
name|IntersectDominators
argument_list|(
name|NewIDom
argument_list|,
name|Pred
argument_list|)
expr_stmt|;
block|}
comment|// Check if the IDom value has changed.
if|if
condition|(
name|NewIDom
operator|&&
name|NewIDom
operator|!=
name|Info
operator|->
name|IDom
condition|)
block|{
name|Info
operator|->
name|IDom
operator|=
name|NewIDom
expr_stmt|;
name|Changed
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|Changed
condition|)
do|;
block|}
comment|/// IsDefInDomFrontier - Search up the dominator tree from Pred to IDom for
comment|/// any blocks containing definitions of the value.  If one is found, then
comment|/// the successor of Pred is in the dominance frontier for the definition,
comment|/// and this function returns true.
name|bool
name|IsDefInDomFrontier
parameter_list|(
specifier|const
name|BBInfo
modifier|*
name|Pred
parameter_list|,
specifier|const
name|BBInfo
modifier|*
name|IDom
parameter_list|)
block|{
for|for
control|(
init|;
name|Pred
operator|!=
name|IDom
condition|;
name|Pred
operator|=
name|Pred
operator|->
name|IDom
control|)
block|{
if|if
condition|(
name|Pred
operator|->
name|DefBB
operator|==
name|Pred
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// FindPHIPlacement - PHIs are needed in the iterated dominance frontiers
comment|/// of the known definitions.  Iteratively add PHIs in the dom frontiers
comment|/// until nothing changes.  Along the way, keep track of the nearest
comment|/// dominating definitions for non-PHI blocks.
name|void
name|FindPHIPlacement
parameter_list|(
name|BlockListTy
modifier|*
name|BlockList
parameter_list|)
block|{
name|bool
name|Changed
decl_stmt|;
do|do
block|{
name|Changed
operator|=
name|false
expr_stmt|;
comment|// Iterate over the list in reverse order, i.e., forward on CFG edges.
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|reverse_iterator
name|I
operator|=
name|BlockList
operator|->
name|rbegin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|rend
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BBInfo
modifier|*
name|Info
init|=
operator|*
name|I
decl_stmt|;
comment|// If this block already needs a PHI, there is nothing to do here.
if|if
condition|(
name|Info
operator|->
name|DefBB
operator|==
name|Info
condition|)
continue|continue;
comment|// Default to use the same def as the immediate dominator.
name|BBInfo
modifier|*
name|NewDefBB
init|=
name|Info
operator|->
name|IDom
operator|->
name|DefBB
decl_stmt|;
for|for
control|(
name|unsigned
name|p
init|=
literal|0
init|;
name|p
operator|!=
name|Info
operator|->
name|NumPreds
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|IsDefInDomFrontier
argument_list|(
name|Info
operator|->
name|Preds
index|[
name|p
index|]
argument_list|,
name|Info
operator|->
name|IDom
argument_list|)
condition|)
block|{
comment|// Need a PHI here.
name|NewDefBB
operator|=
name|Info
expr_stmt|;
break|break;
block|}
block|}
comment|// Check if anything changed.
if|if
condition|(
name|NewDefBB
operator|!=
name|Info
operator|->
name|DefBB
condition|)
block|{
name|Info
operator|->
name|DefBB
operator|=
name|NewDefBB
expr_stmt|;
name|Changed
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|Changed
condition|)
do|;
block|}
comment|/// FindAvailableVal - If this block requires a PHI, first check if an
comment|/// existing PHI matches the PHI placement and reaching definitions computed
comment|/// earlier, and if not, create a new PHI.  Visit all the block's
comment|/// predecessors to calculate the available value for each one and fill in
comment|/// the incoming values for a new PHI.
name|void
name|FindAvailableVals
parameter_list|(
name|BlockListTy
modifier|*
name|BlockList
parameter_list|)
block|{
comment|// Go through the worklist in forward order (i.e., backward through the CFG)
comment|// and check if existing PHIs can be used.  If not, create empty PHIs where
comment|// they are needed.
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|iterator
name|I
operator|=
name|BlockList
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BBInfo
modifier|*
name|Info
init|=
operator|*
name|I
decl_stmt|;
comment|// Check if there needs to be a PHI in BB.
if|if
condition|(
name|Info
operator|->
name|DefBB
operator|!=
name|Info
condition|)
continue|continue;
comment|// Look for an existing PHI.
name|FindExistingPHI
argument_list|(
name|Info
operator|->
name|BB
argument_list|,
name|BlockList
argument_list|)
expr_stmt|;
if|if
condition|(
name|Info
operator|->
name|AvailableVal
condition|)
continue|continue;
name|ValT
name|PHI
init|=
name|Traits
operator|::
name|CreateEmptyPHI
argument_list|(
name|Info
operator|->
name|BB
argument_list|,
name|Info
operator|->
name|NumPreds
argument_list|,
name|Updater
argument_list|)
decl_stmt|;
name|Info
operator|->
name|AvailableVal
operator|=
name|PHI
expr_stmt|;
operator|(
operator|*
name|AvailableVals
operator|)
index|[
name|Info
operator|->
name|BB
index|]
operator|=
name|PHI
expr_stmt|;
block|}
comment|// Now go back through the worklist in reverse order to fill in the
comment|// arguments for any new PHIs added in the forward traversal.
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|reverse_iterator
name|I
operator|=
name|BlockList
operator|->
name|rbegin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|rend
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BBInfo
modifier|*
name|Info
init|=
operator|*
name|I
decl_stmt|;
if|if
condition|(
name|Info
operator|->
name|DefBB
operator|!=
name|Info
condition|)
block|{
comment|// Record the available value at join nodes to speed up subsequent
comment|// uses of this SSAUpdater for the same value.
if|if
condition|(
name|Info
operator|->
name|NumPreds
operator|>
literal|1
condition|)
operator|(
operator|*
name|AvailableVals
operator|)
index|[
name|Info
operator|->
name|BB
index|]
operator|=
name|Info
operator|->
name|DefBB
operator|->
name|AvailableVal
expr_stmt|;
continue|continue;
block|}
comment|// Check if this block contains a newly added PHI.
name|PhiT
modifier|*
name|PHI
init|=
name|Traits
operator|::
name|ValueIsNewPHI
argument_list|(
name|Info
operator|->
name|AvailableVal
argument_list|,
name|Updater
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PHI
condition|)
continue|continue;
comment|// Iterate through the block's predecessors.
for|for
control|(
name|unsigned
name|p
init|=
literal|0
init|;
name|p
operator|!=
name|Info
operator|->
name|NumPreds
condition|;
operator|++
name|p
control|)
block|{
name|BBInfo
modifier|*
name|PredInfo
init|=
name|Info
operator|->
name|Preds
index|[
name|p
index|]
decl_stmt|;
name|BlkT
modifier|*
name|Pred
init|=
name|PredInfo
operator|->
name|BB
decl_stmt|;
comment|// Skip to the nearest preceding definition.
if|if
condition|(
name|PredInfo
operator|->
name|DefBB
operator|!=
name|PredInfo
condition|)
name|PredInfo
operator|=
name|PredInfo
operator|->
name|DefBB
expr_stmt|;
name|Traits
operator|::
name|AddPHIOperand
argument_list|(
name|PHI
argument_list|,
name|PredInfo
operator|->
name|AvailableVal
argument_list|,
name|Pred
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"  Inserted PHI: "
operator|<<
operator|*
name|PHI
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
comment|// If the client wants to know about all new instructions, tell it.
if|if
condition|(
name|InsertedPHIs
condition|)
name|InsertedPHIs
operator|->
name|push_back
argument_list|(
name|PHI
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// FindExistingPHI - Look through the PHI nodes in a block to see if any of
comment|/// them match what is needed.
name|void
name|FindExistingPHI
parameter_list|(
name|BlkT
modifier|*
name|BB
parameter_list|,
name|BlockListTy
modifier|*
name|BlockList
parameter_list|)
block|{
for|for
control|(
name|typename
name|BlkT
operator|::
name|iterator
name|BBI
operator|=
name|BB
operator|->
name|begin
argument_list|()
operator|,
name|BBE
operator|=
name|BB
operator|->
name|end
argument_list|()
init|;
name|BBI
operator|!=
name|BBE
condition|;
operator|++
name|BBI
control|)
block|{
name|PhiT
modifier|*
name|SomePHI
init|=
name|Traits
operator|::
name|InstrIsPHI
argument_list|(
operator|&
operator|*
name|BBI
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SomePHI
condition|)
break|break;
if|if
condition|(
name|CheckIfPHIMatches
argument_list|(
name|SomePHI
argument_list|)
condition|)
block|{
name|RecordMatchingPHIs
argument_list|(
name|BlockList
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Match failed: clear all the PHITag values.
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|iterator
name|I
operator|=
name|BlockList
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|PHITag
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
comment|/// CheckIfPHIMatches - Check if a PHI node matches the placement and values
comment|/// in the BBMap.
name|bool
name|CheckIfPHIMatches
parameter_list|(
name|PhiT
modifier|*
name|PHI
parameter_list|)
block|{
name|SmallVector
operator|<
name|PhiT
operator|*
operator|,
literal|20
operator|>
name|WorkList
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|PHI
argument_list|)
expr_stmt|;
comment|// Mark that the block containing this PHI has been visited.
name|BBMap
index|[
name|PHI
operator|->
name|getParent
argument_list|()
index|]
operator|->
name|PHITag
operator|=
name|PHI
expr_stmt|;
while|while
condition|(
operator|!
name|WorkList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|PHI
operator|=
name|WorkList
operator|.
name|pop_back_val
argument_list|()
expr_stmt|;
comment|// Iterate through the PHI's incoming values.
for|for
control|(
name|typename
name|Traits
operator|::
name|PHI_iterator
name|I
operator|=
name|Traits
operator|::
name|PHI_begin
argument_list|(
name|PHI
argument_list|)
operator|,
name|E
operator|=
name|Traits
operator|::
name|PHI_end
argument_list|(
name|PHI
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|ValT
name|IncomingVal
init|=
name|I
operator|.
name|getIncomingValue
argument_list|()
decl_stmt|;
name|BBInfo
modifier|*
name|PredInfo
init|=
name|BBMap
index|[
name|I
operator|.
name|getIncomingBlock
argument_list|()
index|]
decl_stmt|;
comment|// Skip to the nearest preceding definition.
if|if
condition|(
name|PredInfo
operator|->
name|DefBB
operator|!=
name|PredInfo
condition|)
name|PredInfo
operator|=
name|PredInfo
operator|->
name|DefBB
expr_stmt|;
comment|// Check if it matches the expected value.
if|if
condition|(
name|PredInfo
operator|->
name|AvailableVal
condition|)
block|{
if|if
condition|(
name|IncomingVal
operator|==
name|PredInfo
operator|->
name|AvailableVal
condition|)
continue|continue;
return|return
name|false
return|;
block|}
comment|// Check if the value is a PHI in the correct block.
name|PhiT
modifier|*
name|IncomingPHIVal
init|=
name|Traits
operator|::
name|ValueIsPHI
argument_list|(
name|IncomingVal
argument_list|,
name|Updater
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IncomingPHIVal
operator|||
name|IncomingPHIVal
operator|->
name|getParent
argument_list|()
operator|!=
name|PredInfo
operator|->
name|BB
condition|)
return|return
name|false
return|;
comment|// If this block has already been visited, check if this PHI matches.
if|if
condition|(
name|PredInfo
operator|->
name|PHITag
condition|)
block|{
if|if
condition|(
name|IncomingPHIVal
operator|==
name|PredInfo
operator|->
name|PHITag
condition|)
continue|continue;
return|return
name|false
return|;
block|}
name|PredInfo
operator|->
name|PHITag
operator|=
name|IncomingPHIVal
expr_stmt|;
name|WorkList
operator|.
name|push_back
argument_list|(
name|IncomingPHIVal
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
comment|/// RecordMatchingPHIs - For each PHI node that matches, record it in both
comment|/// the BBMap and the AvailableVals mapping.
name|void
name|RecordMatchingPHIs
parameter_list|(
name|BlockListTy
modifier|*
name|BlockList
parameter_list|)
block|{
for|for
control|(
name|typename
name|BlockListTy
operator|::
name|iterator
name|I
operator|=
name|BlockList
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|BlockList
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|PhiT
modifier|*
name|PHI
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|PHITag
condition|)
block|{
name|BlkT
modifier|*
name|BB
init|=
name|PHI
operator|->
name|getParent
argument_list|()
decl_stmt|;
name|ValT
name|PHIVal
init|=
name|Traits
operator|::
name|GetPHIValue
argument_list|(
name|PHI
argument_list|)
decl_stmt|;
operator|(
operator|*
name|AvailableVals
operator|)
index|[
name|BB
index|]
operator|=
name|PHIVal
expr_stmt|;
name|BBMap
index|[
name|BB
index|]
operator|->
name|AvailableVal
operator|=
name|PHIVal
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end llvm namespace
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_TYPE
end_undef

begin_comment
comment|// "ssaupdater"
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TRANSFORMS_UTILS_SSAUPDATERIMPL_H
end_comment

end_unit

