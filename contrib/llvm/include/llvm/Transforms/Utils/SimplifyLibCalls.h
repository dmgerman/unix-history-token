begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file exposes an interface to build some C language libcalls for
end_comment

begin_comment
comment|// optimization passes that need to call the various functions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TRANSFORMS_UTILS_SIMPLIFYLIBCALLS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TRANSFORMS_UTILS_SIMPLIFYLIBCALLS_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetLibraryInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|StringRef
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|CallInst
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|TargetLibraryInfo
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Function
decl_stmt|;
comment|/// \brief This class implements simplifications for calls to fortified library
comment|/// functions (__st*cpy_chk, __memcpy_chk, __memmove_chk, __memset_chk), to,
comment|/// when possible, replace them with their non-checking counterparts.
comment|/// Other optimizations can also be done, but it's possible to disable them and
comment|/// only simplify needless use of the checking versions (when the object size
comment|/// is unknown) by passing true for OnlyLowerUnknownSize.
name|class
name|FortifiedLibCallSimplifier
block|{
name|private
label|:
specifier|const
name|TargetLibraryInfo
modifier|*
name|TLI
decl_stmt|;
name|bool
name|OnlyLowerUnknownSize
decl_stmt|;
name|public
label|:
name|FortifiedLibCallSimplifier
argument_list|(
argument|const TargetLibraryInfo *TLI
argument_list|,
argument|bool OnlyLowerUnknownSize = false
argument_list|)
empty_stmt|;
comment|/// \brief Take the given call instruction and return a more
comment|/// optimal value to replace the instruction with or 0 if a more
comment|/// optimal form can't be found.
comment|/// The call must not be an indirect call.
name|Value
modifier|*
name|optimizeCall
parameter_list|(
name|CallInst
modifier|*
name|CI
parameter_list|)
function_decl|;
name|private
label|:
name|Value
modifier|*
name|optimizeMemCpyChk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemMoveChk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemSetChk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Str/Stp cpy are similar enough to be handled in the same functions.
name|Value
modifier|*
name|optimizeStrpCpyChk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|,
name|LibFunc
name|Func
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrpNCpyChk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|,
name|LibFunc
name|Func
argument_list|)
decl_stmt|;
comment|/// \brief Checks whether the call \p CI to a fortified libcall is foldable
comment|/// to the non-fortified version.
name|bool
name|isFortifiedCallFoldable
parameter_list|(
name|CallInst
modifier|*
name|CI
parameter_list|,
name|unsigned
name|ObjSizeOp
parameter_list|,
name|unsigned
name|SizeOp
parameter_list|,
name|bool
name|isString
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// LibCallSimplifier - This class implements a collection of optimizations
comment|/// that replace well formed calls to library functions with a more optimal
comment|/// form.  For example, replacing 'printf("Hello!")' with 'puts("Hello!")'.
name|class
name|LibCallSimplifier
block|{
name|private
label|:
name|FortifiedLibCallSimplifier
name|FortifiedSimplifier
decl_stmt|;
specifier|const
name|DataLayout
modifier|&
name|DL
decl_stmt|;
specifier|const
name|TargetLibraryInfo
modifier|*
name|TLI
decl_stmt|;
name|bool
name|UnsafeFPShrink
decl_stmt|;
name|function_ref
operator|<
name|void
argument_list|(
name|Instruction
operator|*
argument_list|,
name|Value
operator|*
argument_list|)
operator|>
name|Replacer
expr_stmt|;
comment|/// \brief Internal wrapper for RAUW that is the default implementation.
comment|///
comment|/// Other users may provide an alternate function with this signature instead
comment|/// of this one.
specifier|static
name|void
name|replaceAllUsesWithDefault
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|Value
modifier|*
name|With
parameter_list|)
function_decl|;
comment|/// \brief Replace an instruction's uses with a value using our replacer.
name|void
name|replaceAllUsesWith
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|Value
modifier|*
name|With
parameter_list|)
function_decl|;
name|public
label|:
name|LibCallSimplifier
argument_list|(
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|,
specifier|const
name|TargetLibraryInfo
operator|*
name|TLI
argument_list|,
name|function_ref
operator|<
name|void
argument_list|(
name|Instruction
operator|*
argument_list|,
name|Value
operator|*
argument_list|)
operator|>
name|Replacer
operator|=
operator|&
name|replaceAllUsesWithDefault
argument_list|)
expr_stmt|;
comment|/// optimizeCall - Take the given call instruction and return a more
comment|/// optimal value to replace the instruction with or 0 if a more
comment|/// optimal form can't be found.  Note that the returned value may
comment|/// be equal to the instruction being optimized.  In this case all
comment|/// other instructions that use the given instruction were modified
comment|/// and the given instruction is dead.
comment|/// The call must not be an indirect call.
name|Value
modifier|*
name|optimizeCall
parameter_list|(
name|CallInst
modifier|*
name|CI
parameter_list|)
function_decl|;
name|private
label|:
comment|// String and Memory Library Call Optimizations
name|Value
modifier|*
name|optimizeStrCat
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrNCat
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrChr
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrRChr
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrCmp
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrNCmp
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrCpy
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStpCpy
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrNCpy
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrLen
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrPBrk
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrTo
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrSpn
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrCSpn
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeStrStr
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemChr
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemCmp
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemCpy
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemMove
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeMemSet
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Wrapper for all String/Memory Library Call Optimizations
name|Value
modifier|*
name|optimizeStringMemoryLibCall
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Math Library Optimizations
name|Value
modifier|*
name|optimizeCos
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizePow
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeExp2
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFMinFMax
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeLog
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeSqrt
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeSinCosPi
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeTan
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Integer Library Call Optimizations
name|Value
modifier|*
name|optimizeFFS
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFls
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeAbs
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeIsDigit
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeIsAscii
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeToAscii
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Formatting and IO Library Call Optimizations
name|Value
modifier|*
name|optimizeErrorReporting
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|,
name|int
name|StreamArg
operator|=
operator|-
literal|1
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizePrintF
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeSPrintF
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFPrintF
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFWrite
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFPuts
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizePuts
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|// Helper methods
name|Value
modifier|*
name|emitStrLenMemCpy
argument_list|(
name|Value
operator|*
name|Src
argument_list|,
name|Value
operator|*
name|Dst
argument_list|,
name|uint64_t
name|Len
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|void
name|classifyArgUse
argument_list|(
name|Value
operator|*
name|Val
argument_list|,
name|Function
operator|*
name|F
argument_list|,
name|bool
name|IsFloat
argument_list|,
name|SmallVectorImpl
operator|<
name|CallInst
operator|*
operator|>
operator|&
name|SinCalls
argument_list|,
name|SmallVectorImpl
operator|<
name|CallInst
operator|*
operator|>
operator|&
name|CosCalls
argument_list|,
name|SmallVectorImpl
operator|<
name|CallInst
operator|*
operator|>
operator|&
name|SinCosCalls
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizePrintFString
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeSPrintFString
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|optimizeFPrintFString
argument_list|(
name|CallInst
operator|*
name|CI
argument_list|,
name|IRBuilder
operator|<
operator|>
operator|&
name|B
argument_list|)
decl_stmt|;
comment|/// hasFloatVersion - Checks if there is a float version of the specified
comment|/// function by checking for an existing function with name FuncName + f
name|bool
name|hasFloatVersion
parameter_list|(
name|StringRef
name|FuncName
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

