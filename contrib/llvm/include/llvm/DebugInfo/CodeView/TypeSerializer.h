begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- TypeSerializer.h -----------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_DEBUGINFO_CODEVIEW_TYPESERIALIZER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_DEBUGINFO_CODEVIEW_TYPESERIALIZER_H
end_define

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/TypeRecordMapping.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BinaryByteStream.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BinaryStreamWriter.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|codeview
block|{
name|class
name|TypeHasher
decl_stmt|;
name|class
name|TypeSerializer
range|:
name|public
name|TypeVisitorCallbacks
block|{   struct
name|SubRecord
block|{
name|SubRecord
argument_list|(
argument|TypeLeafKind K
argument_list|,
argument|uint32_t S
argument_list|)
operator|:
name|Kind
argument_list|(
name|K
argument_list|)
block|,
name|Size
argument_list|(
argument|S
argument_list|)
block|{}
name|TypeLeafKind
name|Kind
block|;
name|uint32_t
name|Size
operator|=
literal|0
block|;   }
block|;   struct
name|RecordSegment
block|{
name|SmallVector
operator|<
name|SubRecord
block|,
literal|16
operator|>
name|SubRecords
block|;
name|uint32_t
name|length
argument_list|()
specifier|const
block|{
name|uint32_t
name|L
operator|=
sizeof|sizeof
argument_list|(
name|RecordPrefix
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|R
range|:
name|SubRecords
control|)
block|{
name|L
operator|+=
name|R
operator|.
name|Size
expr_stmt|;
block|}
return|return
name|L
return|;
block|}
expr|}
block|;
typedef|typedef
name|SmallVector
operator|<
name|MutableArrayRef
operator|<
name|uint8_t
operator|>
operator|,
literal|2
operator|>
name|MutableRecordList
expr_stmt|;
specifier|static
name|constexpr
name|uint8_t
name|ContinuationLength
operator|=
literal|8
block|;
name|BumpPtrAllocator
operator|&
name|RecordStorage
block|;
name|RecordSegment
name|CurrentSegment
block|;
name|MutableRecordList
name|FieldListSegments
block|;
name|Optional
operator|<
name|TypeLeafKind
operator|>
name|TypeKind
block|;
name|Optional
operator|<
name|TypeLeafKind
operator|>
name|MemberKind
block|;
name|std
operator|::
name|vector
operator|<
name|uint8_t
operator|>
name|RecordBuffer
block|;
name|MutableBinaryByteStream
name|Stream
block|;
name|BinaryStreamWriter
name|Writer
block|;
name|TypeRecordMapping
name|Mapping
block|;
comment|/// Private type record hashing implementation details are handled here.
name|std
operator|::
name|unique_ptr
operator|<
name|TypeHasher
operator|>
name|Hasher
block|;
comment|/// Contains a list of all records indexed by TypeIndex.toArrayIndex().
name|SmallVector
operator|<
name|ArrayRef
operator|<
name|uint8_t
operator|>
block|,
literal|2
operator|>
name|SeenRecords
block|;
comment|/// Temporary storage that we use to copy a record's data while re-writing
comment|/// its type indices.
name|SmallVector
operator|<
name|uint8_t
block|,
literal|256
operator|>
name|RemapStorage
block|;
name|TypeIndex
name|nextTypeIndex
argument_list|()
specifier|const
block|;
name|bool
name|isInFieldList
argument_list|()
specifier|const
block|;
name|MutableArrayRef
operator|<
name|uint8_t
operator|>
name|getCurrentSubRecordData
argument_list|()
block|;
name|MutableArrayRef
operator|<
name|uint8_t
operator|>
name|getCurrentRecordData
argument_list|()
block|;
name|Error
name|writeRecordPrefix
argument_list|(
argument|TypeLeafKind Kind
argument_list|)
block|;
name|Expected
operator|<
name|MutableArrayRef
operator|<
name|uint8_t
operator|>>
name|addPadding
argument_list|(
name|MutableArrayRef
operator|<
name|uint8_t
operator|>
name|Record
argument_list|)
block|;
name|public
operator|:
name|explicit
name|TypeSerializer
argument_list|(
argument|BumpPtrAllocator&Storage
argument_list|,
argument|bool Hash = true
argument_list|)
block|;
operator|~
name|TypeSerializer
argument_list|()
block|;
name|void
name|reset
argument_list|()
block|;
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
block|{
return|return
name|RecordStorage
return|;
block|}
name|ArrayRef
operator|<
name|ArrayRef
operator|<
name|uint8_t
operator|>>
name|records
argument_list|()
specifier|const
block|;
name|TypeIndex
name|insertRecordBytes
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|&
name|Record
argument_list|)
block|;
name|TypeIndex
name|insertRecord
argument_list|(
specifier|const
name|RemappedType
operator|&
name|Record
argument_list|)
block|;
name|Expected
operator|<
name|TypeIndex
operator|>
name|visitTypeEndGetIndex
argument_list|(
name|CVType
operator|&
name|Record
argument_list|)
block|;
name|Error
name|visitTypeBegin
argument_list|(
argument|CVType&Record
argument_list|)
name|override
block|;
name|Error
name|visitTypeEnd
argument_list|(
argument|CVType&Record
argument_list|)
name|override
block|;
name|Error
name|visitMemberBegin
argument_list|(
argument|CVMemberRecord&Record
argument_list|)
name|override
block|;
name|Error
name|visitMemberEnd
argument_list|(
argument|CVMemberRecord&Record
argument_list|)
name|override
block|;
define|#
directive|define
name|TYPE_RECORD
parameter_list|(
name|EnumName
parameter_list|,
name|EnumVal
parameter_list|,
name|Name
parameter_list|)
define|\
value|virtual Error visitKnownRecord(CVType&CVR, Name##Record&Record) override { \     return visitKnownRecordImpl(CVR, Record);                                  \   }
define|#
directive|define
name|TYPE_RECORD_ALIAS
parameter_list|(
name|EnumName
parameter_list|,
name|EnumVal
parameter_list|,
name|Name
parameter_list|,
name|AliasName
parameter_list|)
define|#
directive|define
name|MEMBER_RECORD
parameter_list|(
name|EnumName
parameter_list|,
name|EnumVal
parameter_list|,
name|Name
parameter_list|)
define|\
value|Error visitKnownMember(CVMemberRecord&CVR, Name##Record&Record) override { \     return visitKnownMemberImpl<Name##Record>(CVR, Record);                    \   }
define|#
directive|define
name|MEMBER_RECORD_ALIAS
parameter_list|(
name|EnumName
parameter_list|,
name|EnumVal
parameter_list|,
name|Name
parameter_list|,
name|AliasName
parameter_list|)
include|#
directive|include
file|"llvm/DebugInfo/CodeView/CodeViewTypes.def"
name|private
operator|:
name|template
operator|<
name|typename
name|RecordKind
operator|>
name|Error
name|visitKnownRecordImpl
argument_list|(
argument|CVType&CVR
argument_list|,
argument|RecordKind&Record
argument_list|)
block|{
return|return
name|Mapping
operator|.
name|visitKnownRecord
argument_list|(
name|CVR
argument_list|,
name|Record
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|RecordType
operator|>
name|Error
name|visitKnownMemberImpl
argument_list|(
argument|CVMemberRecord&CVR
argument_list|,
argument|RecordType&Record
argument_list|)
block|{
name|assert
argument_list|(
name|CVR
operator|.
name|Kind
operator|==
name|static_cast
operator|<
name|TypeLeafKind
operator|>
operator|(
name|Record
operator|.
name|getKind
argument_list|()
operator|)
argument_list|)
block|;
if|if
condition|(
name|auto
name|EC
init|=
name|Writer
operator|.
name|writeEnum
argument_list|(
name|CVR
operator|.
name|Kind
argument_list|)
condition|)
return|return
name|EC
return|;
if|if
condition|(
name|auto
name|EC
init|=
name|Mapping
operator|.
name|visitKnownMember
argument_list|(
name|CVR
argument_list|,
name|Record
argument_list|)
condition|)
return|return
name|EC
return|;
comment|// Get all the data that was just written and is yet to be committed to
comment|// the current segment.  Then pad it to 4 bytes.
name|MutableArrayRef
operator|<
name|uint8_t
operator|>
name|ThisRecord
operator|=
name|getCurrentSubRecordData
argument_list|()
decl_stmt|;
name|auto
name|ExpectedRecord
init|=
name|addPadding
argument_list|(
name|ThisRecord
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ExpectedRecord
condition|)
return|return
name|ExpectedRecord
operator|.
name|takeError
argument_list|()
return|;
name|ThisRecord
operator|=
operator|*
name|ExpectedRecord
expr_stmt|;
name|CurrentSegment
operator|.
name|SubRecords
operator|.
name|emplace_back
argument_list|(
name|CVR
operator|.
name|Kind
argument_list|,
name|ThisRecord
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CVR
operator|.
name|Data
operator|=
name|ThisRecord
expr_stmt|;
comment|// Both the last subrecord and the total length of this segment should be
comment|// multiples of 4.
name|assert
argument_list|(
name|ThisRecord
operator|.
name|size
argument_list|()
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CurrentSegment
operator|.
name|length
argument_list|()
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|Error
operator|::
name|success
argument_list|()
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

