begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- StringsAndChecksums.h ------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H
end_define

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/CodeView.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/DebugStringTableSubsection.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DebugInfo/CodeView/DebugSubsectionRecord.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|codeview
block|{
name|class
name|StringsAndChecksumsRef
block|{
name|public
label|:
comment|// If no subsections are known about initially, we find as much as we can.
name|StringsAndChecksumsRef
argument_list|()
expr_stmt|;
comment|// If only a string table subsection is given, we find a checksums subsection.
name|explicit
name|StringsAndChecksumsRef
parameter_list|(
specifier|const
name|DebugStringTableSubsectionRef
modifier|&
name|Strings
parameter_list|)
function_decl|;
comment|// If both subsections are given, we don't need to find anything.
name|StringsAndChecksumsRef
argument_list|(
specifier|const
name|DebugStringTableSubsectionRef
operator|&
name|Strings
argument_list|,
specifier|const
name|DebugChecksumsSubsectionRef
operator|&
name|Checksums
argument_list|)
expr_stmt|;
name|void
name|setChecksums
parameter_list|(
specifier|const
name|DebugChecksumsSubsectionRef
modifier|&
name|CS
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|initialize
argument_list|(
argument|T&&FragmentRange
argument_list|)
block|{
for|for
control|(
specifier|const
name|DebugSubsectionRecord
modifier|&
name|R
range|:
name|FragmentRange
control|)
block|{
if|if
condition|(
name|Strings
operator|&&
name|Checksums
condition|)
return|return;
if|if
condition|(
name|R
operator|.
name|kind
argument_list|()
operator|==
name|DebugSubsectionKind
operator|::
name|FileChecksums
condition|)
block|{
name|initializeChecksums
argument_list|(
name|R
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|R
operator|.
name|kind
argument_list|()
operator|==
name|DebugSubsectionKind
operator|::
name|StringTable
operator|&&
operator|!
name|Strings
condition|)
block|{
comment|// While in practice we should never encounter a string table even
comment|// though the string table is already initialized, in theory it's
comment|// possible.  PDBs are supposed to have one global string table and
comment|// then this subsection should not appear.  Whereas object files are
comment|// supposed to have this subsection appear exactly once.  However,
comment|// for testing purposes it's nice to be able to test this subsection
comment|// independently of one format or the other, so for some tests we
comment|// manually construct a PDB that contains this subsection in addition
comment|// to a global string table.
name|initializeStrings
argument_list|(
name|R
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
specifier|const
name|DebugStringTableSubsectionRef
operator|&
name|strings
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Strings
return|;
block|}
specifier|const
name|DebugChecksumsSubsectionRef
operator|&
name|checksums
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Checksums
return|;
block|}
name|bool
name|hasStrings
argument_list|()
specifier|const
block|{
return|return
name|Strings
operator|!=
name|nullptr
return|;
block|}
name|bool
name|hasChecksums
argument_list|()
specifier|const
block|{
return|return
name|Checksums
operator|!=
name|nullptr
return|;
block|}
name|private
label|:
name|void
name|initializeStrings
parameter_list|(
specifier|const
name|DebugSubsectionRecord
modifier|&
name|SR
parameter_list|)
function_decl|;
name|void
name|initializeChecksums
parameter_list|(
specifier|const
name|DebugSubsectionRecord
modifier|&
name|FCR
parameter_list|)
function_decl|;
name|std
operator|::
name|unique_ptr
operator|<
name|DebugStringTableSubsectionRef
operator|>
name|OwnedStrings
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|DebugChecksumsSubsectionRef
operator|>
name|OwnedChecksums
expr_stmt|;
specifier|const
name|DebugStringTableSubsectionRef
modifier|*
name|Strings
init|=
name|nullptr
decl_stmt|;
specifier|const
name|DebugChecksumsSubsectionRef
modifier|*
name|Checksums
init|=
name|nullptr
decl_stmt|;
block|}
empty_stmt|;
name|class
name|StringsAndChecksums
block|{
name|public
label|:
name|using
name|StringsPtr
init|=
name|std
operator|::
name|shared_ptr
operator|<
name|DebugStringTableSubsection
operator|>
decl_stmt|;
name|using
name|ChecksumsPtr
init|=
name|std
operator|::
name|shared_ptr
operator|<
name|DebugChecksumsSubsection
operator|>
decl_stmt|;
comment|// If no subsections are known about initially, we find as much as we can.
name|StringsAndChecksums
argument_list|()
operator|=
expr|default
expr_stmt|;
name|void
name|setStrings
parameter_list|(
specifier|const
name|StringsPtr
modifier|&
name|SP
parameter_list|)
block|{
name|Strings
operator|=
name|SP
expr_stmt|;
block|}
name|void
name|setChecksums
parameter_list|(
specifier|const
name|ChecksumsPtr
modifier|&
name|CP
parameter_list|)
block|{
name|Checksums
operator|=
name|CP
expr_stmt|;
block|}
specifier|const
name|StringsPtr
operator|&
name|strings
argument_list|()
specifier|const
block|{
return|return
name|Strings
return|;
block|}
specifier|const
name|ChecksumsPtr
operator|&
name|checksums
argument_list|()
specifier|const
block|{
return|return
name|Checksums
return|;
block|}
name|bool
name|hasStrings
argument_list|()
specifier|const
block|{
return|return
name|Strings
operator|!=
name|nullptr
return|;
block|}
name|bool
name|hasChecksums
argument_list|()
specifier|const
block|{
return|return
name|Checksums
operator|!=
name|nullptr
return|;
block|}
name|private
label|:
name|StringsPtr
name|Strings
decl_stmt|;
name|ChecksumsPtr
name|Checksums
decl_stmt|;
block|}
empty_stmt|;
block|}
comment|// end namespace codeview
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_DEBUGINFO_CODEVIEW_STRINGSANDCHECKSUMS_H
end_comment

end_unit

