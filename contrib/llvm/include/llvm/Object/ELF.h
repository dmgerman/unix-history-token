begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ELF.h - ELF object file implementation -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the ELFObjectFile template class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_ELF_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_ELF_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|object
block|{
name|using
name|support
operator|::
name|endianness
expr_stmt|;
name|template
operator|<
name|endianness
name|target_endianness
operator|,
name|std
operator|::
name|size_t
name|max_alignment
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|ELFType
block|{
specifier|static
specifier|const
name|endianness
name|TargetEndianness
operator|=
name|target_endianness
block|;
specifier|static
specifier|const
name|std
operator|::
name|size_t
name|MaxAlignment
operator|=
name|max_alignment
block|;
specifier|static
specifier|const
name|bool
name|Is64Bits
operator|=
name|is64Bits
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|,
name|int
name|max_align
operator|>
expr|struct
name|MaximumAlignment
block|{   enum
block|{
name|value
operator|=
name|AlignOf
operator|<
name|T
operator|>
operator|::
name|Alignment
operator|>
name|max_align
operator|?
name|max_align
operator|:
name|AlignOf
operator|<
name|T
operator|>
operator|::
name|Alignment
block|}
block|; }
expr_stmt|;
comment|// Subclasses of ELFObjectFile may need this for template instantiation
specifier|inline
name|std
operator|::
name|pair
operator|<
name|unsigned
name|char
operator|,
name|unsigned
name|char
operator|>
name|getElfArchType
argument_list|(
argument|MemoryBuffer *Object
argument_list|)
block|{
if|if
condition|(
name|Object
operator|->
name|getBufferSize
argument_list|()
operator|<
name|ELF
operator|::
name|EI_NIDENT
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
operator|(
name|uint8_t
operator|)
name|ELF
operator|::
name|ELFCLASSNONE
argument_list|,
operator|(
name|uint8_t
operator|)
name|ELF
operator|::
name|ELFDATANONE
argument_list|)
return|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
operator|(
name|uint8_t
operator|)
name|Object
operator|->
name|getBufferStart
argument_list|()
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
argument_list|,
operator|(
name|uint8_t
operator|)
name|Object
operator|->
name|getBufferStart
argument_list|()
index|[
name|ELF
operator|::
name|EI_DATA
index|]
argument_list|)
return|;
block|}
comment|// Templates to choose Elf_Addr and Elf_Off depending on is64Bits.
name|template
operator|<
name|endianness
name|target_endianness
operator|,
name|std
operator|::
name|size_t
name|max_alignment
operator|>
expr|struct
name|ELFDataTypeTypedefHelperCommon
block|{
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint16_t
operator|,
name|target_endianness
operator|,
name|MaximumAlignment
operator|<
name|uint16_t
operator|,
name|max_alignment
operator|>
operator|::
name|value
operator|>
name|Elf_Half
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint32_t
operator|,
name|target_endianness
operator|,
name|MaximumAlignment
operator|<
name|uint32_t
operator|,
name|max_alignment
operator|>
operator|::
name|value
operator|>
name|Elf_Word
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int32_t
operator|,
name|target_endianness
operator|,
name|MaximumAlignment
operator|<
name|int32_t
operator|,
name|max_alignment
operator|>
operator|::
name|value
operator|>
name|Elf_Sword
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint64_t
operator|,
name|target_endianness
operator|,
name|MaximumAlignment
operator|<
name|uint64_t
operator|,
name|max_alignment
operator|>
operator|::
name|value
operator|>
name|Elf_Xword
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int64_t
operator|,
name|target_endianness
operator|,
name|MaximumAlignment
operator|<
name|int64_t
operator|,
name|max_alignment
operator|>
operator|::
name|value
operator|>
name|Elf_Sxword
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// ELF 32bit types.
end_comment

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
expr|>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|>
block|{
typedef|typedef
name|uint32_t
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|TargetEndianness
operator|,
name|MaximumAlignment
operator|<
name|value_type
operator|,
name|MaxAlign
operator|>
operator|::
name|value
operator|>
name|Elf_Addr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|TargetEndianness
operator|,
name|MaximumAlignment
operator|<
name|value_type
operator|,
name|MaxAlign
operator|>
operator|::
name|value
operator|>
name|Elf_Off
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|/// ELF 64bit types.
end_comment

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
expr|>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|>
block|{
typedef|typedef
name|uint64_t
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|TargetEndianness
operator|,
name|MaximumAlignment
operator|<
name|value_type
operator|,
name|MaxAlign
operator|>
operator|::
name|value
operator|>
name|Elf_Addr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|TargetEndianness
operator|,
name|MaximumAlignment
operator|<
name|value_type
operator|,
name|MaxAlign
operator|>
operator|::
name|value
operator|>
name|Elf_Off
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|// I really don't like doing this, but the alternative is copypasta.
end_comment

begin_define
define|#
directive|define
name|LLVM_ELF_IMPORT_TYPES
parameter_list|(
name|E
parameter_list|,
name|M
parameter_list|,
name|W
parameter_list|)
define|\
value|typedef typename ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Addr Elf_Addr; \ typedef typename ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Off Elf_Off;   \ typedef typename ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Half Elf_Half; \ typedef typename ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Word Elf_Word; \ typedef typename                                                               \   ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Sword Elf_Sword;              \ typedef typename                                                               \   ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Xword Elf_Xword;              \ typedef typename                                                               \   ELFDataTypeTypedefHelper<ELFType<E,M,W>>::Elf_Sxword Elf_Sxword;
end_define

begin_define
define|#
directive|define
name|LLVM_ELF_IMPORT_TYPES_ELFT
parameter_list|(
name|ELFT
parameter_list|)
define|\
value|LLVM_ELF_IMPORT_TYPES(ELFT::TargetEndianness, ELFT::MaxAlignment,            \   ELFT::Is64Bits)
end_define

begin_comment
comment|// Section header.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Shdr_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Word
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Word
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Word
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Word
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Xword
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Xword
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Xword
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Xword
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Shdr_Impl
operator|:
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
operator|::
name|sh_entsize
block|;
name|using
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
operator|::
name|sh_size
block|;
comment|/// @brief Get the number of entities this section contains if it has any.
name|unsigned
name|getEntityCount
argument_list|()
specifier|const
block|{
if|if
condition|(
name|sh_entsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|sh_size
operator|/
name|sh_entsize
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Sym_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Word
name|st_size
block|;
comment|// Size of the symbol
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Xword
name|st_size
block|;
comment|// Size of the symbol
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Sym_Impl
operator|:
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
operator|::
name|st_info
block|;
comment|// These accessors and mutators correspond to the ELF32_ST_BIND,
comment|// ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:
name|unsigned
name|char
name|getBinding
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|>>
literal|4
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|&
literal|0x0f
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setBinding
parameter_list|(
name|unsigned
name|char
name|b
parameter_list|)
block|{
name|setBindingAndType
argument_list|(
name|b
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|setBindingAndType
argument_list|(
name|getBinding
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setBindingAndType
parameter_list|(
name|unsigned
name|char
name|b
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|st_info
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator|+
operator|(
name|t
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Elf_Versym: This is the structure of entries in the SHT_GNU_versym section
end_comment

begin_comment
comment|/// (.gnu.version). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Versym_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Half
name|vs_index
block|;
comment|// Version index with flags (e.g. VERSYM_HIDDEN)
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdaux_Impl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verdef: This is the structure of entries in the SHT_GNU_verdef section
end_comment

begin_comment
comment|/// (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdef_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
typedef|typedef
name|Elf_Verdaux_Impl
operator|<
name|ELFT
operator|>
name|Elf_Verdaux
expr_stmt|;
name|Elf_Half
name|vd_version
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Version of this structure (e.g. VER_DEF_CURRENT)
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Bitwise flags (VER_DEF_*)
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_ndx
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Version index, used in .gnu.version entries
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Number of Verdaux entries
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Hash of name
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_aux
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Offset to the first Verdaux entry (in bytes)
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_next
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Offset to the next Verdef entry (in bytes)
end_comment

begin_comment
comment|/// Get the first Verdaux entry for this Verdef.
end_comment

begin_expr_stmt
specifier|const
name|Elf_Verdaux
operator|*
name|getAux
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verdaux
operator|*
operator|>
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
name|vd_aux
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// Elf_Verdaux: This is the structure of auxiliary data in the SHT_GNU_verdef
end_comment

begin_comment
comment|/// section (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|vda_name
block|;
comment|// Version name (offset in string table)
name|Elf_Word
name|vda_next
block|;
comment|// Offset to next Verdaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verneed: This is the structure of entries in the SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verneed_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Half
name|vn_version
block|;
comment|// Version of this structure (e.g. VER_NEED_CURRENT)
name|Elf_Half
name|vn_cnt
block|;
comment|// Number of associated Vernaux entries
name|Elf_Word
name|vn_file
block|;
comment|// Library name (string table offset)
name|Elf_Word
name|vn_aux
block|;
comment|// Offset to first Vernaux entry (in bytes)
name|Elf_Word
name|vn_next
block|;
comment|// Offset to next Verneed entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Vernaux: This is the structure of auxiliary data in SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Vernaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|vna_hash
block|;
comment|// Hash of dependency name
name|Elf_Half
name|vna_flags
block|;
comment|// Bitwise Flags (VER_FLAG_*)
name|Elf_Half
name|vna_other
block|;
comment|// Version index, used in .gnu.version entries
name|Elf_Word
name|vna_name
block|;
comment|// Dependency name
name|Elf_Word
name|vna_next
block|;
comment|// Offset to next Vernaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Base: This structure matches the form of entries in the dynamic
end_comment

begin_comment
comment|///               table section (.dynamic) look like.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Dyn_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Sword
name|d_tag
block|;
expr|union
block|{
name|Elf_Word
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Sxword
name|d_tag
block|;
expr|union
block|{
name|Elf_Xword
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Impl: This inherits from Elf_Dyn_Base, adding getters and setters.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Dyn_Impl
operator|:
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
operator|::
name|d_tag
block|;
name|using
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
operator|::
name|d_un
block|;
name|int64_t
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|d_tag
return|;
block|}
name|uint64_t
name|getVal
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|d_val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getPtr
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|ptr
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Elf_Rel: Elf Relocation
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Word
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|uint32_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isMips64EL
argument_list|)
block|;
return|return
name|r_info
return|;
block|}
name|void
name|setRInfo
argument_list|(
argument|uint32_t R
argument_list|)
block|{
name|r_info
operator|=
name|R
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Xword
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|uint64_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
name|uint64_t
name|t
operator|=
name|r_info
block|;
if|if
condition|(
operator|!
name|isMips64EL
condition|)
return|return
name|t
return|;
comment|// Mip64 little endian has a "special" encoding of r_info. Instead of one
comment|// 64 bit little endian number, it is a little ending 32 bit number followed
comment|// by a 32 bit big endian number.
return|return
operator|(
name|t
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|40
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|56
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
end_expr_stmt

begin_return
return|return
name|r_info
return|;
end_return

begin_macro
unit|}   void
name|setRInfo
argument_list|(
argument|uint64_t R
argument_list|)
end_macro

begin_block
block|{
comment|// FIXME: Add mips64el support.
name|r_info
operator|=
name|R
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Word
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|Elf_Sword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this
name|uint32_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isMips64EL
argument_list|)
block|;
return|return
name|r_info
return|;
block|}
name|void
name|setRInfo
argument_list|(
argument|uint32_t R
argument_list|)
block|{
name|r_info
operator|=
name|R
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Xword
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|Elf_Sxword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this.
name|uint64_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
comment|// Mip64 little endian has a "special" encoding of r_info. Instead of one
comment|// 64 bit little endian number, it is a little ending 32 bit number followed
comment|// by a 32 bit big endian number.
name|uint64_t
name|t
operator|=
name|r_info
block|;
if|if
condition|(
operator|!
name|isMips64EL
condition|)
return|return
name|t
return|;
return|return
operator|(
name|t
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|40
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|56
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setRInfo
parameter_list|(
name|uint64_t
name|R
parameter_list|)
block|{
comment|// FIXME: Add mips64el support.
name|r_info
operator|=
name|R
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
operator|,
name|isRela
operator|>
operator|:
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
operator|,
name|isRela
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
comment|// These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,
comment|// and ELF64_R_INFO macros defined in the ELF specification:
name|uint32_t
name|getSymbol
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|>>
literal|32
argument_list|)
return|;
block|}
name|uint32_t
name|getType
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|&
literal|0xffffffffL
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint32_t
name|s
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|uint32_t
name|t
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|uint32_t
name|t
parameter_list|)
block|{
name|this
operator|->
name|setRInfo
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|s
operator|<<
literal|32
operator|)
operator|+
operator|(
name|t
operator|&
literal|0xffffffffL
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
operator|,
name|isRela
operator|>
operator|:
name|Elf_Rel_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
operator|,
name|isRela
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
comment|// These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,
comment|// and ELF32_R_INFO macros defined in the ELF specification:
name|uint32_t
name|getSymbol
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
return|return
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|>>
literal|8
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|&
literal|0x0ff
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint32_t
name|s
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|this
operator|->
name|setRInfo
argument_list|(
operator|(
name|s
operator|<<
literal|8
operator|)
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Ehdr_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|unsigned
name|char
name|e_ident
index|[
name|ELF
operator|::
name|EI_NIDENT
index|]
block|;
comment|// ELF Identification bytes
name|Elf_Half
name|e_type
block|;
comment|// Type of file (see ET_*)
name|Elf_Half
name|e_machine
block|;
comment|// Required architecture for this file (see EM_*)
name|Elf_Word
name|e_version
block|;
comment|// Must be equal to 1
name|Elf_Addr
name|e_entry
block|;
comment|// Address to jump to in order to start program
name|Elf_Off
name|e_phoff
block|;
comment|// Program header table's file offset, in bytes
name|Elf_Off
name|e_shoff
block|;
comment|// Section header table's file offset, in bytes
name|Elf_Word
name|e_flags
block|;
comment|// Processor-specific flags
name|Elf_Half
name|e_ehsize
block|;
comment|// Size of ELF header, in bytes
name|Elf_Half
name|e_phentsize
block|;
comment|// Size of an entry in the program header table
name|Elf_Half
name|e_phnum
block|;
comment|// Number of entries in the program header table
name|Elf_Half
name|e_shentsize
block|;
comment|// Size of an entry in the section header table
name|Elf_Half
name|e_shnum
block|;
comment|// Number of entries in the section header table
name|Elf_Half
name|e_shstrndx
block|;
comment|// Section header table index of section name
comment|// string table
name|bool
name|checkMagic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|e_ident
argument_list|,
name|ELF
operator|::
name|ElfMagic
argument_list|,
name|strlen
argument_list|(
name|ELF
operator|::
name|ElfMagic
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
name|unsigned
name|char
name|getFileClass
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|char
name|getDataEncoding
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_DATA
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Phdr_Impl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Phdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|false
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|p_type
block|;
comment|// Type of segment
name|Elf_Off
name|p_offset
block|;
comment|// FileOffset where segment is located, in bytes
name|Elf_Addr
name|p_vaddr
block|;
comment|// Virtual Address of beginning of segment
name|Elf_Addr
name|p_paddr
block|;
comment|// Physical address of beginning of segment (OS-specific)
name|Elf_Word
name|p_filesz
block|;
comment|// Num. of bytes in file image of segment (may be zero)
name|Elf_Word
name|p_memsz
block|;
comment|// Num. of bytes in mem image of segment (may be zero)
name|Elf_Word
name|p_flags
block|;
comment|// Segment flags
name|Elf_Word
name|p_align
block|;
comment|// Segment alignment constraint
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|,
name|std
operator|::
name|size_t
name|MaxAlign
operator|>
expr|struct
name|Elf_Phdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|MaxAlign
operator|,
name|true
operator|>
expr|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|MaxAlign
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|p_type
block|;
comment|// Type of segment
name|Elf_Word
name|p_flags
block|;
comment|// Segment flags
name|Elf_Off
name|p_offset
block|;
comment|// FileOffset where segment is located, in bytes
name|Elf_Addr
name|p_vaddr
block|;
comment|// Virtual Address of beginning of segment
name|Elf_Addr
name|p_paddr
block|;
comment|// Physical address of beginning of segment (OS-specific)
name|Elf_Xword
name|p_filesz
block|;
comment|// Num. of bytes in file image of segment (may be zero)
name|Elf_Xword
name|p_memsz
block|;
comment|// Num. of bytes in mem image of segment (may be zero)
name|Elf_Xword
name|p_align
block|;
comment|// Segment alignment constraint
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFObjectFile
operator|:
name|public
name|ObjectFile
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|public
operator|:
comment|/// \brief Iterate over constant sized entities.
name|template
operator|<
name|class
name|EntT
operator|>
name|class
name|ELFEntityIterator
block|{
name|public
operator|:
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|EntT
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|random_access_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_comment
comment|/// \brief Default construct iterator.
end_comment

begin_expr_stmt
name|ELFEntityIterator
argument_list|()
operator|:
name|EntitySize
argument_list|(
literal|0
argument_list|)
operator|,
name|Current
argument_list|(
literal|0
argument_list|)
block|{}
name|ELFEntityIterator
argument_list|(
argument|uint64_t EntSize
argument_list|,
argument|const char *Start
argument_list|)
operator|:
name|EntitySize
argument_list|(
name|EntSize
argument_list|)
operator|,
name|Current
argument_list|(
argument|Start
argument_list|)
block|{}
name|reference
name|operator
operator|*
operator|(
operator|)
block|{
name|assert
argument_list|(
name|Current
operator|&&
literal|"Attempted to dereference an invalid iterator!"
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|Current
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
name|assert
argument_list|(
name|Current
operator|&&
literal|"Attempted to dereference an invalid iterator!"
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|Current
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ELFEntityIterator
operator|&
name|Other
operator|)
block|{
return|return
name|Current
operator|==
name|Other
operator|.
name|Current
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ELFEntityIterator
operator|&
name|Other
operator|)
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|Other
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ELFEntityIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|assert
argument_list|(
name|Current
operator|&&
literal|"Attempted to increment an invalid iterator!"
argument_list|)
block|;
name|Current
operator|+=
name|EntitySize
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ELFEntityIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|ELFEntityIterator
name|Tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|Tmp
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|ELFEntityIterator
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ELFEntityIterator
operator|&
name|Other
operator|)
block|{
name|EntitySize
operator|=
name|Other
operator|.
name|EntitySize
block|;
name|Current
operator|=
name|Other
operator|.
name|Current
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|difference_type
name|operator
operator|-
operator|(
specifier|const
name|ELFEntityIterator
operator|&
name|Other
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|EntitySize
operator|==
name|Other
operator|.
name|EntitySize
operator|&&
literal|"Subtracting iterators of different EntitiySize!"
argument_list|)
block|;
return|return
operator|(
name|Current
operator|-
name|Other
operator|.
name|Current
operator|)
operator|/
name|EntitySize
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|char
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Current
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|uint64_t
name|EntitySize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|Current
decl_stmt|;
end_decl_stmt

begin_typedef
unit|};
typedef|typedef
name|Elf_Ehdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Ehdr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Shdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Shdr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Dyn_Impl
operator|<
name|ELFT
operator|>
name|Elf_Dyn
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Phdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Phdr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|false
operator|>
name|Elf_Rel
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|true
operator|>
name|Elf_Rela
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verdef_Impl
operator|<
name|ELFT
operator|>
name|Elf_Verdef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verdaux_Impl
operator|<
name|ELFT
operator|>
name|Elf_Verdaux
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verneed_Impl
operator|<
name|ELFT
operator|>
name|Elf_Verneed
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Vernaux_Impl
operator|<
name|ELFT
operator|>
name|Elf_Vernaux
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Versym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Versym
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ELFEntityIterator
operator|<
specifier|const
name|Elf_Dyn
operator|>
name|Elf_Dyn_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ELFEntityIterator
operator|<
specifier|const
name|Elf_Sym
operator|>
name|Elf_Sym_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ELFEntityIterator
operator|<
specifier|const
name|Elf_Rela
operator|>
name|Elf_Rela_Iter
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ELFEntityIterator
operator|<
specifier|const
name|Elf_Rel
operator|>
name|Elf_Rel_Iter
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_comment
comment|// This flag is used for classof, to distinguish ELFObjectFile from
end_comment

begin_comment
comment|// its subclass. If more subclasses will be created, this flag will
end_comment

begin_comment
comment|// have to become an enum.
end_comment

begin_decl_stmt
name|bool
name|isDyldELFObject
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|,
literal|2
operator|>
name|Sections_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|IndexMap_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|,
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|1
operator|>
expr|>
name|RelocMap_t
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|const
name|Elf_Ehdr
modifier|*
name|Header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|SectionHeaderTable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_shstrtab_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Section header string table.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_strtab_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Symbol header string table.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_dynstr_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Dynamic symbol string table.
end_comment

begin_comment
comment|// SymbolTableSections[0] always points to the dynamic string table section
end_comment

begin_comment
comment|// header, or NULL if there is no dynamic string table.
end_comment

begin_decl_stmt
name|Sections_t
name|SymbolTableSections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IndexMap_t
name|SymbolTableSectionsIndexMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DenseMap
operator|<
specifier|const
name|Elf_Sym
operator|*
operator|,
name|ELF
operator|::
name|Elf64_Word
operator|>
name|ExtendedSymbolTable
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_dynamic_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .dynamic
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_r_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version_r
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_d_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version_d
end_comment

begin_comment
comment|// Pointer to SONAME entry in dynamic string table
end_comment

begin_comment
comment|// This is set the first time getLoadName is called.
end_comment

begin_decl_stmt
name|mutable
specifier|const
name|char
modifier|*
name|dt_soname
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|uint64_t
name|getROffset
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Records for each version index the corresponding Verdef or Vernaux entry.
end_comment

begin_comment
comment|// This is filled the first time LoadVersionMap() is called.
end_comment

begin_decl_stmt
name|class
name|VersionMapEntry
range|:
name|public
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
decl_stmt|, 1>
block|{
name|public
label|:
comment|// If the integer is 0, this is an Elf_Verdef*.
comment|// If the integer is 1, this is an Elf_Vernaux*.
name|VersionMapEntry
argument_list|()
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|NULL
operator|,
literal|0
operator|)
block|{ }
name|VersionMapEntry
argument_list|(
specifier|const
name|Elf_Verdef
operator|*
name|verdef
argument_list|)
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|verdef
operator|,
literal|0
operator|)
block|{ }
name|VersionMapEntry
argument_list|(
specifier|const
name|Elf_Vernaux
operator|*
name|vernaux
argument_list|)
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|vernaux
operator|,
literal|1
operator|)
block|{ }
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
name|getPointer
argument_list|()
operator|==
name|NULL
return|;
block|}
name|bool
name|isVerdef
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
operator|&&
name|getInt
argument_list|()
operator|==
literal|0
return|;
block|}
name|bool
name|isVernaux
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
operator|&&
name|getInt
argument_list|()
operator|==
literal|1
return|;
block|}
specifier|const
name|Elf_Verdef
operator|*
name|getVerdef
argument_list|()
specifier|const
block|{
return|return
name|isVerdef
argument_list|()
operator|?
operator|(
specifier|const
name|Elf_Verdef
operator|*
operator|)
name|getPointer
argument_list|()
operator|:
name|NULL
return|;
block|}
specifier|const
name|Elf_Vernaux
operator|*
name|getVernaux
argument_list|()
specifier|const
block|{
return|return
name|isVernaux
argument_list|()
operator|?
operator|(
specifier|const
name|Elf_Vernaux
operator|*
operator|)
name|getPointer
argument_list|()
operator|:
name|NULL
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|mutable
name|SmallVector
operator|<
name|VersionMapEntry
operator|,
literal|16
operator|>
name|VersionMap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|LoadVersionDefs
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|LoadVersionNeeds
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|ec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|LoadVersionMap
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// @brief Map sections to an array of relocation sections that reference
end_comment

begin_comment
comment|///        them sorted by section index.
end_comment

begin_decl_stmt
name|RelocMap_t
name|SectionRelocMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// @brief Get the relocation section that contains \a Rel.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getRelSection
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
block|{
return|return
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|bool
name|isRelocationHasAddend
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getEntry
argument_list|(
argument|uint16_t Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getEntry
argument_list|(
argument|const Elf_Shdr *Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
name|DataRefImpl
name|index
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
name|uint32_t
name|index
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Rel
modifier|*
name|getRel
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Rela
modifier|*
name|getRela
argument_list|(
name|DataRefImpl
name|Rela
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|getString
argument_list|(
name|uint32_t
name|section
argument_list|,
name|uint32_t
name|offset
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|getString
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
name|uint32_t
name|offset
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSymbolVersion
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|Symb
argument_list|,
name|StringRef
operator|&
name|Version
argument_list|,
name|bool
operator|&
name|IsDefault
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|VerifyStrTab
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sh
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|getSymbol
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: Should be private?
end_comment

begin_decl_stmt
name|void
name|validateSymbol
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|getRelocationTypeName
argument_list|(
name|uint32_t
name|Type
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|error_code
name|getSymbolName
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|Symb
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSectionName
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Dyn
modifier|*
name|getDyn
argument_list|(
name|DataRefImpl
name|DynData
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSymbolVersion
argument_list|(
name|SymbolRef
name|Symb
argument_list|,
name|StringRef
operator|&
name|Version
argument_list|,
name|bool
operator|&
name|IsDefault
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|getSymbolIndex
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|sym
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolNext
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolName
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolFileOffset
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolAddress
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolAlignment
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint32_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolSize
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolNMTypeChar
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|char
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolFlags
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint32_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolType
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|::
name|Type
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolSection
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|section_iterator
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolValue
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Val
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getLibraryNext
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|LibraryRef
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getLibraryPath
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionNext
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|SectionRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionName
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionAddress
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionSize
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionContents
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionAlignment
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionText
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionData
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionBSS
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionRequiredForExecution
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionVirtual
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionZeroInit
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionReadOnlyData
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|sectionContainsSymbol
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|DataRefImpl
name|Symb
argument_list|,
name|bool
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|relocation_iterator
name|getSectionRelBegin
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|relocation_iterator
name|getSectionRelEnd
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationNext
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|RelocationRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationAddress
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationOffset
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationSymbol
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SymbolRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationType
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationTypeName
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationAdditionalInfo
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|int64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationValueString
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isMips64EL
argument_list|()
specifier|const
block|{
return|return
name|Header
operator|->
name|e_machine
operator|==
name|ELF
operator|::
name|EM_MIPS
operator|&&
name|Header
operator|->
name|getFileClass
argument_list|()
operator|==
name|ELF
operator|::
name|ELFCLASS64
operator|&&
name|Header
operator|->
name|getDataEncoding
argument_list|()
operator|==
name|ELF
operator|::
name|ELFDATA2LSB
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|begin_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|end_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|begin_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|end_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|section_iterator
name|begin_sections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|section_iterator
name|end_sections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|library_iterator
name|begin_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|library_iterator
name|end_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Elf_Shdr
operator|*
name|getDynamicSymbolTableSectionHeader
argument_list|()
specifier|const
block|{
return|return
name|SymbolTableSections
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Elf_Shdr
operator|*
name|getDynamicStringTableSectionHeader
argument_list|()
specifier|const
block|{
return|return
name|dot_dynstr_sec
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Elf_Dyn_iterator
name|begin_dynamic_table
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \param NULLEnd use one past the first DT_NULL entry as the end instead of
end_comment

begin_comment
comment|/// the section size.
end_comment

begin_decl_stmt
name|Elf_Dyn_iterator
name|end_dynamic_table
argument_list|(
name|bool
name|NULLEnd
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Elf_Sym_iterator
name|begin_elf_dynamic_symbols
argument_list|()
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|DynSymtab
operator|=
name|SymbolTableSections
index|[
literal|0
index|]
block|;
if|if
condition|(
name|DynSymtab
condition|)
return|return
name|Elf_Sym_iterator
argument_list|(
name|DynSymtab
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|DynSymtab
operator|->
name|sh_offset
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|Elf_Sym_iterator
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
end_return

begin_macro
unit|}    Elf_Sym_iterator
name|end_elf_dynamic_symbols
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|DynSymtab
operator|=
name|SymbolTableSections
index|[
literal|0
index|]
block|;
if|if
condition|(
name|DynSymtab
condition|)
return|return
name|Elf_Sym_iterator
argument_list|(
name|DynSymtab
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|DynSymtab
operator|->
name|sh_offset
operator|+
name|DynSymtab
operator|->
name|sh_size
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|Elf_Sym_iterator
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
end_return

begin_macro
unit|}    Elf_Rela_Iter
name|beginELFRela
argument_list|(
argument|const Elf_Shdr *sec
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|Elf_Rela_Iter
argument_list|(
name|sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|Elf_Rela_Iter
name|endELFRela
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|)
decl|const
block|{
return|return
name|Elf_Rela_Iter
argument_list|(
name|sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
operator|+
name|sec
operator|->
name|sh_size
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Elf_Rel_Iter
name|beginELFRel
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|)
decl|const
block|{
return|return
name|Elf_Rel_Iter
argument_list|(
name|sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|Elf_Rel_Iter
name|endELFRel
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|)
decl|const
block|{
return|return
name|Elf_Rel_Iter
argument_list|(
name|sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
operator|+
name|sec
operator|->
name|sh_size
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Iterate over program header table.
end_comment

begin_typedef
typedef|typedef
name|ELFEntityIterator
operator|<
specifier|const
name|Elf_Phdr
operator|>
name|Elf_Phdr_Iter
expr_stmt|;
end_typedef

begin_expr_stmt
name|Elf_Phdr_Iter
name|begin_program_headers
argument_list|()
specifier|const
block|{
return|return
name|Elf_Phdr_Iter
argument_list|(
name|Header
operator|->
name|e_phentsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_phoff
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Elf_Phdr_Iter
name|end_program_headers
argument_list|()
specifier|const
block|{
return|return
name|Elf_Phdr_Iter
argument_list|(
name|Header
operator|->
name|e_phentsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_phoff
operator|+
operator|(
name|Header
operator|->
name|e_phnum
operator|*
name|Header
operator|->
name|e_phentsize
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|uint8_t
name|getBytesInAddress
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getFileFormatName
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getObjectType
argument_list|()
specifier|const
block|{
return|return
literal|"ELF"
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|unsigned
name|getArch
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getLoadName
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionContents
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|uint64_t
name|getNumSections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getStringTableIndex
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ELF
operator|::
name|Elf64_Word
name|getSymbolTableIndex
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Elf_Ehdr
operator|*
name|getElfHeader
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getElfSection
argument_list|(
name|section_iterator
operator|&
name|It
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|getElfSymbol
argument_list|(
name|symbol_iterator
operator|&
name|It
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|getElfSymbol
argument_list|(
name|uint32_t
name|index
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Methods for type inquiry through isa, cast, and dyn_cast
end_comment

begin_expr_stmt
name|bool
name|isDyldType
argument_list|()
specifier|const
block|{
return|return
name|isDyldELFObject
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Binary
modifier|*
name|v
parameter_list|)
block|{
return|return
name|v
operator|->
name|getType
argument_list|()
operator|==
name|getELFType
argument_list|(
name|ELFT
operator|::
name|TargetEndianness
operator|==
name|support
operator|::
name|little
argument_list|,
name|ELFT
operator|::
name|Is64Bits
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|// Iterate through the version definitions, and place each Elf_Verdef
end_comment

begin_comment
comment|// in the VersionMap according to its index.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|LoadVersionDefs
argument_list|(
argument|const Elf_Shdr *sec
argument_list|)
specifier|const
block|{
name|unsigned
name|vd_size
operator|=
name|sec
operator|->
name|sh_size
block|;
comment|// Size of section in bytes
name|unsigned
name|vd_count
operator|=
name|sec
operator|->
name|sh_info
block|;
comment|// Number of Verdef entries
specifier|const
name|char
operator|*
name|sec_start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
specifier|const
name|char
operator|*
name|sec_end
operator|=
name|sec_start
operator|+
name|vd_size
block|;
comment|// The first Verdef entry is at the start of the section.
specifier|const
name|char
operator|*
name|p
operator|=
name|sec_start
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpectedly while scanning "
literal|"version definitions."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Verdef
modifier|*
name|vd
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verdef
operator|*
operator|>
operator|(
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_version
operator|!=
name|ELF
operator|::
name|VER_DEF_CURRENT
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected verdef version"
argument_list|)
expr_stmt|;
name|size_t
name|index
init|=
name|vd
operator|->
name|vd_ndx
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
condition|)
name|VersionMap
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VersionMap
index|[
name|index
index|]
operator|=
name|VersionMapEntry
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|p
operator|+=
name|vd
operator|->
name|vd_next
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Iterate through the versions needed section, and place each Elf_Vernaux
end_comment

begin_comment
comment|// in the VersionMap according to its index.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|LoadVersionNeeds
argument_list|(
argument|const Elf_Shdr *sec
argument_list|)
specifier|const
block|{
name|unsigned
name|vn_size
operator|=
name|sec
operator|->
name|sh_size
block|;
comment|// Size of section in bytes
name|unsigned
name|vn_count
operator|=
name|sec
operator|->
name|sh_info
block|;
comment|// Number of Verneed entries
specifier|const
name|char
operator|*
name|sec_start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
specifier|const
name|char
operator|*
name|sec_end
operator|=
name|sec_start
operator|+
name|vn_size
block|;
comment|// The first Verneed entry is at the start of the section.
specifier|const
name|char
operator|*
name|p
operator|=
name|sec_start
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vn_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpectedly while scanning "
literal|"version needed records."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Verneed
modifier|*
name|vn
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verneed
operator|*
operator|>
operator|(
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|vn
operator|->
name|vn_version
operator|!=
name|ELF
operator|::
name|VER_NEED_CURRENT
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected verneed version"
argument_list|)
expr_stmt|;
comment|// Iterate through the Vernaux entries
specifier|const
name|char
modifier|*
name|paux
init|=
name|p
operator|+
name|vn
operator|->
name|vn_aux
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|vn
operator|->
name|vn_cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|paux
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpected while scanning auxiliary "
literal|"version needed records."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Vernaux
modifier|*
name|vna
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Vernaux
operator|*
operator|>
operator|(
name|paux
operator|)
decl_stmt|;
name|size_t
name|index
init|=
name|vna
operator|->
name|vna_other
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
condition|)
name|VersionMap
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VersionMap
index|[
name|index
index|]
operator|=
name|VersionMapEntry
argument_list|(
name|vna
argument_list|)
expr_stmt|;
name|paux
operator|+=
name|vna
operator|->
name|vna_next
expr_stmt|;
block|}
name|p
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|LoadVersionMap
argument_list|()
specifier|const
block|{
comment|// If there is no dynamic symtab or version table, there is nothing to do.
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|dot_gnu_version_sec
operator|==
name|NULL
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// Has the VersionMap already been loaded?
end_comment

begin_if
if|if
condition|(
name|VersionMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
return|return;
end_if

begin_comment
comment|// The first two version indexes are reserved.
end_comment

begin_comment
comment|// Index 0 is LOCAL, index 1 is GLOBAL.
end_comment

begin_expr_stmt
name|VersionMap
operator|.
name|push_back
argument_list|(
name|VersionMapEntry
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VersionMap
operator|.
name|push_back
argument_list|(
name|VersionMapEntry
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dot_gnu_version_d_sec
condition|)
name|LoadVersionDefs
argument_list|(
name|dot_gnu_version_d_sec
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|dot_gnu_version_r_sec
condition|)
name|LoadVersionNeeds
argument_list|(
name|dot_gnu_version_r_sec
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|validateSymbol
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|NDEBUG
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|SymbolTableSection
operator|=
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
block|;
comment|// FIXME: We really need to do proper error handling in the case of an invalid
comment|//        input file. Because we don't use exceptions, I think we'll just pass
comment|//        an error object around.
if|if
condition|(
operator|!
operator|(
name|symb
operator|&&
name|SymbolTableSection
operator|&&
name|symb
operator|>=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSection
operator|->
name|sh_offset
operator|)
operator|&&
name|symb
operator|<
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSection
operator|->
name|sh_offset
operator|+
name|SymbolTableSection
operator|->
name|sh_size
operator|)
operator|)
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Symb must point to a valid symbol!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolNext
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|SymbolTableSection
operator|=
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
block|;
operator|++
name|Symb
operator|.
name|d
operator|.
name|a
block|;
comment|// Check to see if we are at the end of this symbol table.
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|a
operator|>=
name|SymbolTableSection
operator|->
name|getEntityCount
argument_list|()
condition|)
block|{
comment|// We are at the end. If there are other symbol tables, jump to them.
comment|// If the symbol table is .dynsym, we are iterating dynamic symbols,
comment|// and there is only one table of these.
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|b
operator|!=
literal|0
condition|)
block|{
operator|++
name|Symb
operator|.
name|d
operator|.
name|b
expr_stmt|;
name|Symb
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
block|}
end_expr_stmt

begin_comment
comment|// Otherwise return the terminator.
end_comment

begin_if
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|b
operator|==
literal|0
operator|||
name|Symb
operator|.
name|d
operator|.
name|b
operator|>=
name|SymbolTableSections
operator|.
name|size
argument_list|()
condition|)
block|{
name|Symb
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|Symb
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}    Result
operator|=
name|SymbolRef
argument_list|(
name|Symb
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolName
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
return|return
name|getSymbolName
argument_list|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
argument_list|,
name|symb
argument_list|,
name|Result
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolVersion
argument_list|(
argument|SymbolRef SymRef
argument_list|,
argument|StringRef&Version
argument_list|,
argument|bool&IsDefault
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|Symb
operator|=
name|SymRef
operator|.
name|getRawDataRefImpl
argument_list|()
block|;
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
return|return
name|getSymbolVersion
argument_list|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
argument_list|,
name|symb
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|ELF
operator|::
name|Elf64_Word
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolTableIndex
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_XINDEX
condition|)
return|return
name|ExtendedSymbolTable
operator|.
name|lookup
argument_list|(
name|symb
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|symb
operator|->
name|st_shndx
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSection
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_XINDEX
condition|)
return|return
name|getSection
argument_list|(
name|ExtendedSymbolTable
operator|.
name|lookup
argument_list|(
name|symb
argument_list|)
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|>=
name|ELF
operator|::
name|SHN_LORESERVE
condition|)
return|return
literal|0
return|;
end_if

begin_return
return|return
name|getSection
argument_list|(
name|symb
operator|->
name|st_shndx
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Ehdr
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getElfHeader
argument_list|()
specifier|const
block|{
return|return
name|Header
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getElfSection
argument_list|(
argument|section_iterator&It
argument_list|)
specifier|const
block|{
name|llvm
operator|::
name|object
operator|::
name|DataRefImpl
name|ShdrRef
operator|=
name|It
operator|->
name|getRawDataRefImpl
argument_list|()
block|;
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|ShdrRef
operator|.
name|p
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getElfSymbol
argument_list|(
argument|symbol_iterator&It
argument_list|)
specifier|const
block|{
return|return
name|getSymbol
argument_list|(
name|It
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getElfSymbol
argument_list|(
argument|uint32_t index
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|index
block|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
literal|1
block|;
return|return
name|getSymbol
argument_list|(
name|SymbolData
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolFileOffset
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
block|;
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
comment|// Unintialized symbols have no offset in the object file
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|Section
condition|?
name|Section
operator|->
name|sh_offset
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
operator|+
operator|(
name|Section
condition|?
name|Section
operator|->
name|sh_offset
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolAddress
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
block|;
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|Section
condition|?
name|Section
operator|->
name|sh_addr
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|bool
name|IsRelocatable
decl_stmt|;
switch|switch
condition|(
name|Header
operator|->
name|e_type
condition|)
block|{
case|case
name|ELF
operator|::
name|ET_EXEC
case|:
case|case
name|ELF
operator|::
name|ET_DYN
case|:
name|IsRelocatable
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|IsRelocatable
operator|=
name|true
expr_stmt|;
block|}
name|Result
operator|=
name|symb
operator|->
name|st_value
expr_stmt|;
comment|// Clear the ARM/Thumb indicator flag.
if|if
condition|(
name|Header
operator|->
name|e_machine
operator|==
name|ELF
operator|::
name|EM_ARM
condition|)
name|Result
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|IsRelocatable
operator|&&
name|Section
operator|!=
literal|0
condition|)
name|Result
operator|+=
name|Section
operator|->
name|sh_addr
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolAlignment
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint32_t&Res
argument_list|)
specifier|const
block|{
name|uint32_t
name|flags
block|;
name|getSymbolFlags
argument_list|(
name|Symb
argument_list|,
name|flags
argument_list|)
block|;
if|if
condition|(
name|flags
operator|&
name|SymbolRef
operator|::
name|SF_Common
condition|)
block|{
name|uint64_t
name|Value
decl_stmt|;
name|getSymbolValue
argument_list|(
name|Symb
argument_list|,
name|Value
argument_list|)
expr_stmt|;
name|Res
operator|=
name|Value
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Res
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolSize
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
if|if
condition|(
name|symb
operator|->
name|st_size
operator|==
literal|0
condition|)
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
name|Result
operator|=
name|symb
operator|->
name|st_size
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolNMTypeChar
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|char&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
block|;
name|char
name|ret
operator|=
literal|'?'
block|;
if|if
condition|(
name|Section
condition|)
block|{
switch|switch
condition|(
name|Section
operator|->
name|sh_type
condition|)
block|{
case|case
name|ELF
operator|::
name|SHT_PROGBITS
case|:
case|case
name|ELF
operator|::
name|SHT_DYNAMIC
case|:
switch|switch
condition|(
name|Section
operator|->
name|sh_flags
condition|)
block|{
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_EXECINSTR
operator|)
case|:
name|ret
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
case|:
name|ret
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHF_ALLOC
case|:
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_MERGE
operator|)
case|:
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_MERGE
operator||
name|ELF
operator|::
name|SHF_STRINGS
operator|)
case|:
name|ret
operator|=
literal|'r'
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|SHT_NOBITS
case|:
end_case

begin_expr_stmt
name|ret
operator|=
literal|'b'
expr_stmt|;
end_expr_stmt

begin_switch
unit|}   }
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
if|if
condition|(
name|ret
operator|==
literal|'?'
condition|)
name|ret
operator|=
literal|'U'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|ret
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
name|ret
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STB_GLOBAL
case|:
name|ret
operator|=
operator|::
name|toupper
argument_list|(
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STB_WEAK
case|:
if|if
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|ret
operator|=
literal|'w'
expr_stmt|;
elseif|else
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_OBJECT
condition|)
name|ret
operator|=
literal|'V'
expr_stmt|;
else|else
name|ret
operator|=
literal|'W'
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|ret
operator|==
literal|'?'
operator|&&
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_SECTION
condition|)
block|{
name|StringRef
name|name
decl_stmt|;
if|if
condition|(
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|Symb
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|ec
return|;
name|Result
operator|=
name|StringSwitch
operator|<
name|char
operator|>
operator|(
name|name
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".debug"
argument_list|,
literal|'N'
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".note"
argument_list|,
literal|'n'
argument_list|)
operator|.
name|Default
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_if

begin_expr_stmt
name|Result
operator|=
name|ret
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolType
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef::Type&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Unknown
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Debug
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FILE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_File
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Function
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_COMMON
case|:
case|case
name|ELF
operator|::
name|STT_TLS
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Data
expr_stmt|;
break|break;
default|default:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Other
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolFlags
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint32_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|Result
operator|=
name|SymbolRef
operator|::
name|SF_None
block|;
if|if
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
operator|!=
name|ELF
operator|::
name|STB_LOCAL
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Global
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
operator|==
name|ELF
operator|::
name|STB_WEAK
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Weak
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_ABS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Absolute
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_FILE
operator|||
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_SECTION
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_FormatSpecific
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Undefined
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_COMMON
operator|||
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_COMMON
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Common
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_TLS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_ThreadLocal
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolSection
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|section_iterator&Res
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
block|;
if|if
condition|(
operator|!
name|sec
condition|)
name|Res
operator|=
name|end_sections
argument_list|()
expr_stmt|;
else|else
block|{
name|DataRefImpl
name|Sec
decl_stmt|;
name|Sec
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|sec
operator|)
expr_stmt|;
name|Res
operator|=
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|Sec
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolValue
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Val
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|Val
operator|=
name|symb
operator|->
name|st_value
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionNext
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|SectionRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|uint8_t
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|sec
operator|+=
name|Header
operator|->
name|e_shentsize
block|;
name|Sec
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|sec
operator|)
block|;
name|Result
operator|=
name|SectionRef
argument_list|(
name|Sec
argument_list|,
name|this
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionName
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|StringRef
argument_list|(
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|sec
operator|->
name|sh_name
argument_list|)
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionAddress
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_addr
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionSize
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_size
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionContents
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
specifier|const
name|char
operator|*
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
name|Result
operator|=
name|StringRef
argument_list|(
name|start
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionContents
argument_list|(
argument|const Elf_Shdr *Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|char
operator|*
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|Sec
operator|->
name|sh_offset
block|;
name|Result
operator|=
name|StringRef
argument_list|(
name|start
argument_list|,
name|Sec
operator|->
name|sh_size
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionAlignment
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_addralign
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionText
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_EXECINSTR
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionData
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_PROGBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionBSS
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionRequiredForExecution
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_ALLOC
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionVirtual
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionZeroInit
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
comment|// For ELF, all zero-init sections are virtual (that is, they occupy no space
comment|//   in the object image) and vice versa.
name|Result
operator|=
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|isSectionReadOnlyData
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_WRITE
operator|||
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_EXECINSTR
condition|)
name|Result
operator|=
name|false
expr_stmt|;
else|else
name|Result
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|sectionContainsSymbol
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|DataRefImpl Symb
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|unsigned
name|shndx
operator|=
name|symb
operator|->
name|st_shndx
block|;
name|bool
name|Reserved
operator|=
name|shndx
operator|>=
name|ELF
operator|::
name|SHN_LORESERVE
operator|&&
name|shndx
operator|<=
name|ELF
operator|::
name|SHN_HIRESERVE
block|;
name|Result
operator|=
operator|!
name|Reserved
operator|&&
operator|(
name|sec
operator|==
name|getSection
argument_list|(
name|symb
operator|->
name|st_shndx
argument_list|)
operator|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionRelBegin
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|typename
name|RelocMap_t
operator|::
name|const_iterator
name|ittr
operator|=
name|SectionRelocMap
operator|.
name|find
argument_list|(
name|sec
argument_list|)
block|;
if|if
condition|(
name|sec
operator|!=
literal|0
operator|&&
name|ittr
operator|!=
name|SectionRelocMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|RelData
operator|.
name|w
operator|.
name|a
operator|=
name|getSection
argument_list|(
name|ittr
operator|->
name|second
index|[
literal|0
index|]
argument_list|)
operator|->
name|sh_info
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|b
operator|=
name|ittr
operator|->
name|second
index|[
literal|0
index|]
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|c
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionRelEnd
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|typename
name|RelocMap_t
operator|::
name|const_iterator
name|ittr
operator|=
name|SectionRelocMap
operator|.
name|find
argument_list|(
name|sec
argument_list|)
block|;
if|if
condition|(
name|sec
operator|!=
literal|0
operator|&&
name|ittr
operator|!=
name|SectionRelocMap
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Get the index of the last relocation section for this section.
name|std
operator|::
name|size_t
name|relocsecindex
operator|=
name|ittr
operator|->
name|second
index|[
name|ittr
operator|->
name|second
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
expr_stmt|;
specifier|const
name|Elf_Shdr
modifier|*
name|relocsec
init|=
name|getSection
argument_list|(
name|relocsecindex
argument_list|)
decl_stmt|;
name|RelData
operator|.
name|w
operator|.
name|a
operator|=
name|relocsec
operator|->
name|sh_info
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|b
operator|=
name|relocsecindex
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|c
operator|=
name|relocsec
operator|->
name|sh_size
operator|/
name|relocsec
operator|->
name|sh_entsize
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Relocations
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationNext
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|RelocationRef&Result
argument_list|)
specifier|const
block|{
operator|++
name|Rel
operator|.
name|w
operator|.
name|c
block|;
specifier|const
name|Elf_Shdr
operator|*
name|relocsec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
if|if
condition|(
name|Rel
operator|.
name|w
operator|.
name|c
operator|>=
operator|(
name|relocsec
operator|->
name|sh_size
operator|/
name|relocsec
operator|->
name|sh_entsize
operator|)
condition|)
block|{
comment|// We have reached the end of the relocations for this section. See if there
comment|// is another relocation section.
name|typename
name|RelocMap_t
operator|::
name|mapped_type
name|relocseclist
operator|=
name|SectionRelocMap
operator|.
name|lookup
argument_list|(
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do a binary search for the current reloc section index (which must be
comment|// present). Then get the next one.
name|typename
name|RelocMap_t
operator|::
name|mapped_type
operator|::
name|const_iterator
name|loc
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|relocseclist
operator|.
name|begin
argument_list|()
argument_list|,
name|relocseclist
operator|.
name|end
argument_list|()
argument_list|,
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
expr_stmt|;
operator|++
name|loc
expr_stmt|;
comment|// If there is no next one, don't do anything. The ++Rel.w.c above sets Rel
comment|// to the end iterator.
if|if
condition|(
name|loc
operator|!=
name|relocseclist
operator|.
name|end
argument_list|()
condition|)
block|{
name|Rel
operator|.
name|w
operator|.
name|b
operator|=
operator|*
name|loc
expr_stmt|;
name|Rel
operator|.
name|w
operator|.
name|a
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   Result
operator|=
name|RelocationRef
argument_list|(
name|Rel
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationSymbol
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SymbolRef&Result
argument_list|)
specifier|const
block|{
name|uint32_t
name|symbolIdx
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|symbolIdx
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|symbolIdx
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   DataRefImpl
name|SymbolData
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IndexMap_t
operator|::
name|const_iterator
name|it
operator|=
name|SymbolTableSectionsIndexMap
operator|.
name|find
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|it
operator|==
name|SymbolTableSectionsIndexMap
operator|.
name|end
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Relocation symbol table not found!"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|symbolIdx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|it
operator|->
name|second
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Result
operator|=
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationAddress
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|Header
operator|->
name|e_type
operator|==
name|ELF
operator|::
name|ET_EXEC
operator|||
name|Header
operator|->
name|e_type
operator|==
name|ELF
operator|::
name|ET_DYN
operator|)
operator|&&
literal|"Only executable and shared objects files have addresses"
argument_list|)
block|;
name|Result
operator|=
name|getROffset
argument_list|(
name|Rel
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationOffset
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|Header
operator|->
name|e_type
operator|==
name|ELF
operator|::
name|ET_REL
operator|&&
literal|"Only relocatable object files have relocation offsets"
argument_list|)
block|;
name|Result
operator|=
name|getROffset
argument_list|(
name|Rel
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getROffset
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
return|return
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
return|;
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
return|return
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationType
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   return
name|object_error
operator|::
name|success
expr_stmt|;
end_expr_stmt

begin_define
unit|}
define|#
directive|define
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
parameter_list|(
name|enum
define|) \   case ELF::enum: Res = #enum; break;
end_define

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationTypeName
argument_list|(
argument|uint32_t Type
argument_list|)
specifier|const
block|{
name|StringRef
name|Res
operator|=
literal|"Unknown"
block|;
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_32S
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPMOD64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TPOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSGD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSLD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTTPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOT64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPCREL64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPC64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPLT64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PLTOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_SIZE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_SIZE64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPC32_TLSDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSDESC_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_IRELATIVE
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_386
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOTOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOTPC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_32PLT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_TPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_IE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GOTIE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_PUSH
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_POP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_PUSH
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_POP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDO_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_IE_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LE_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DTPMOD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DTPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_TPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GOTDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DESC_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_IRELATIVE
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_MIPS
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_26
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GPREL16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_LITERAL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_CALL16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GPREL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_SHIFT5
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_SHIFT6
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_SUB
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_INSERT_A
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_INSERT_B
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_DELETE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_SCN_DISP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_REL16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_ADD_IMMEDIATE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_PJUMP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_RELGOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_JALR
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPMOD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPREL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPMOD64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPREL64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_GD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_LDM
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPREL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_DTPREL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_GOTTPREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_TPREL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_TPREL64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_TPREL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_TLS_TPREL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_MIPS_NUM
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ABS64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ABS32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ABS16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_PREL64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_PREL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_PREL16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G1_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G2_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_UABS_G3
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_SABS_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_SABS_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_MOVW_SABS_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LD_PREL_LO19
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ADR_PREL_LO21
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ADR_PREL_PG_HI21
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ADD_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LDST8_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TSTBR14
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_CONDBR19
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_JUMP26
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_CALL26
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LDST16_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LDST32_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LDST64_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LDST128_ABS_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_ADR_GOT_PAGE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_LD64_GOT_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_MOVW_DTPREL_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_MOVW_DTPREL_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_MOVW_DTPREL_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_ADD_DTPREL_HI12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_ADD_DTPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST8_DTPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST16_DTPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST32_DTPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST64_DTPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSIE_LD_GOTTPREL_PREL19
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_MOVW_TPREL_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_MOVW_TPREL_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_MOVW_TPREL_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_ADD_TPREL_HI12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_ADD_TPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST8_TPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST16_TPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST32_TPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST64_TPREL_LO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSDESC_ADR_PAGE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSDESC_LD64_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSDESC_ADD_LO12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_AARCH64_TLSDESC_CALL
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_ARM
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PC24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_REL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_PC_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ABS16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ABS12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_ABS5
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ABS8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_SBREL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_PC8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_BREL_ADJ
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_DESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_SWI8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_XPC25
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_XPC22
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_DTPMOD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_DTPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_TPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOTOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_BASE_PREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOT_BREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_JUMP24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_JUMP24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_BASE_ABS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PCREL_7_0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PCREL_15_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PCREL_23_15
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_SBREL_11_0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SBREL_19_12_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SBREL_27_20_CK
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TARGET1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_SBREL31
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_V4BX
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TARGET2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PREL31
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVW_ABS_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVT_ABS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVW_PREL_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVT_PREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVW_ABS_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVT_ABS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVW_PREL_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVT_PREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_JUMP19
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_JUMP6
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_ALU_PREL_11_0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_PC12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ABS32_NOI
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_REL32_NOI
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PC_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PC_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PC_G1_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PC_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_PC_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_PC_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_PC_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_PC_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_PC_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_PC_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_PC_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_PC_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_PC_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SB_G0_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SB_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SB_G1_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SB_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ALU_SB_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_SB_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_SB_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDR_SB_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_SB_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_SB_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDRS_SB_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_SB_G0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_SB_G1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_LDC_SB_G2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVW_BREL_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVT_BREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_MOVW_BREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVW_BREL_NC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVT_BREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_MOVW_BREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_GOTDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_DESCSEQ
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_TLS_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PLT32_ABS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOT_ABS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOT_PREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOT_BREL12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOTOFF12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GOTRELAX
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GNU_VTENTRY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_GNU_VTINHERIT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_JUMP11
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_JUMP8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_GD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_LDM32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_LDO32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_IE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_LE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_LDO12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_LE12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_TLS_IE12GP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_3
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_4
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_5
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_6
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_7
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_9
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_10
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_11
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_13
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_14
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_PRIVATE_15
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_ME_TOO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_TLS_DESCSEQ16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_ARM_THM_TLS_DESCSEQ32
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B22_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B15_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B7_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GPREL16_0
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GPREL16_1
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GPREL16_2
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GPREL16_3
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_HL16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B13_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B9_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B32_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B22_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B15_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B13_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B9_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_B7_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_12_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_10_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_9_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_8_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_7_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_32_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_JMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_PLT_B22_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPMOD_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_PLT_B22_PCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_LO16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_HI16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_6_PCREL_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOTREL_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GOT_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_DTPREL_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_GD_GOT_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_IE_GOT_11_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_32_6_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_16_X
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_HEX_TPREL_11_X
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_PPC
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR16_HI
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR14
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR14_BRTAKEN
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_ADDR14_BRNTAKEN
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_REL24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_REL14
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_REL14_BRTAKEN
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_REL14_BRNTAKEN
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_REL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_TPREL16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC_TPREL16_HA
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_PPC64
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_HI
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR14
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_REL24
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_REL32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_HIGHER
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_HIGHEST
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_REL64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_DS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_ADDR16_LO_DS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC16_DS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TOC16_LO_DS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TLS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TPREL16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TPREL16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_DTPREL16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_DTPREL16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TLSGD16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TLSGD16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TLSLD16_LO
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TLSLD16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TPREL16_LO_DS
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_GOT_TPREL16_HA
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TLSGD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_PPC64_TLSLD
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_S390
case|:
end_case

begin_switch
switch|switch
condition|(
name|Type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOT12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_JMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOT16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PC16DBL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLT16DBL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PC32DBL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLT32DBL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPCDBL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PC64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOT64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLT64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTENT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTOFF16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLT12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLT16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLT64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLTENT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLTOFF16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLTOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_PLTOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LOAD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GDCALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LDCALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GD64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GOTIE12
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GOTIE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GOTIE64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LDM32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LDM64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_IE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_IE64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_IEENT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LE64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LDO32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_LDO64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_DTPMOD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_DTPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_TPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_20
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOT20
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_GOTPLT20
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_TLS_GOTIE20
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_390_IRELATIVE
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
end_switch

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_break
break|break;
end_break

begin_expr_stmt
unit|}   return
name|Res
expr_stmt|;
end_expr_stmt

begin_undef
unit|}
undef|#
directive|undef
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
end_undef

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationTypeName
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
name|uint32_t
name|type
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}    if
operator|(
operator|!
name|isMips64EL
argument_list|()
operator|)
block|{
name|StringRef
name|Name
operator|=
name|getRelocationTypeName
argument_list|(
name|type
argument_list|)
block|;
name|Result
operator|.
name|append
argument_list|(
name|Name
operator|.
name|begin
argument_list|()
argument_list|,
name|Name
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
end_expr_stmt

begin_else
else|else
block|{
name|uint8_t
name|Type1
init|=
operator|(
name|type
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
decl_stmt|;
name|uint8_t
name|Type2
init|=
operator|(
name|type
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
decl_stmt|;
name|uint8_t
name|Type3
init|=
operator|(
name|type
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
decl_stmt|;
comment|// Concat all three relocation type names.
name|StringRef
name|Name
init|=
name|getRelocationTypeName
argument_list|(
name|Type1
argument_list|)
decl_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|Name
operator|.
name|begin
argument_list|()
argument_list|,
name|Name
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Name
operator|=
name|getRelocationTypeName
argument_list|(
name|Type2
argument_list|)
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|Name
operator|.
name|begin
argument_list|()
argument_list|,
name|Name
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Name
operator|=
name|getRelocationTypeName
argument_list|(
name|Type3
argument_list|)
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|Name
operator|.
name|begin
argument_list|()
argument_list|,
name|Name
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationAdditionalInfo
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|int64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
literal|0
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_block

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRelocationValueString
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
name|uint8_t
name|type
block|;
name|StringRef
name|res
block|;
name|int64_t
name|addend
operator|=
literal|0
block|;
name|uint16_t
name|symbol_index
operator|=
literal|0
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default:
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_index
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Read implicit addend from section data.
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_index
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|()
argument_list|)
expr_stmt|;
name|addend
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
break|break;
block|}
end_block

begin_decl_stmt
unit|}   const
name|Elf_Sym
modifier|*
name|symb
init|=
name|getEntry
operator|<
name|Elf_Sym
operator|>
operator|(
name|sec
operator|->
name|sh_link
expr|,
name|symbol_index
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|symname
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|getSection
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
argument_list|,
name|symb
argument_list|,
name|symname
argument_list|)
condition|)
return|return
name|ec
return|;
end_if

begin_switch
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ELF
operator|::
name|R_X86_64_PC8
case|:
case|case
name|ELF
operator|::
name|R_X86_64_PC16
case|:
case|case
name|ELF
operator|::
name|R_X86_64_PC32
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
name|symname
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
operator|<<
literal|"-P"
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELF
operator|::
name|R_X86_64_8
case|:
case|case
name|ELF
operator|::
name|R_X86_64_16
case|:
case|case
name|ELF
operator|::
name|R_X86_64_32
case|:
case|case
name|ELF
operator|::
name|R_X86_64_32S
case|:
case|case
name|ELF
operator|::
name|R_X86_64_64
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
name|symname
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
break|break;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
case|case
name|ELF
operator|::
name|EM_ARM
case|:
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
name|res
operator|=
name|symname
expr_stmt|;
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|Result
operator|.
name|empty
argument_list|()
condition|)
name|Result
operator|.
name|append
argument_list|(
name|res
operator|.
name|begin
argument_list|()
argument_list|,
name|res
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_comment
unit|}
comment|// Verify that the last byte in the string table in a null.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|VerifyStrTab
argument_list|(
argument|const Elf_Shdr *sh
argument_list|)
specifier|const
block|{
specifier|const
name|char
operator|*
name|strtab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sh
operator|->
name|sh_offset
block|;
if|if
condition|(
name|strtab
index|[
name|sh
operator|->
name|sh_size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"String table must end with a null terminator!"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
operator|:
name|ObjectFile
argument_list|(
name|getELFType
argument_list|(
name|static_cast
operator|<
name|endianness
operator|>
operator|(
name|ELFT
operator|::
name|TargetEndianness
operator|)
operator|==
name|support
operator|::
name|little
argument_list|,
name|ELFT
operator|::
name|Is64Bits
argument_list|)
argument_list|,
name|Object
argument_list|)
operator|,
name|isDyldELFObject
argument_list|(
name|false
argument_list|)
operator|,
name|SectionHeaderTable
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_shstrtab_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_strtab_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_dynstr_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_dynamic_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_r_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_d_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dt_soname
argument_list|(
literal|0
argument_list|)
block|{
specifier|const
name|uint64_t
name|FileSize
operator|=
name|Data
operator|->
name|getBufferSize
argument_list|()
block|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"File too short!"
argument_list|)
expr_stmt|;
name|Header
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Ehdr
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Header
operator|->
name|e_shoff
operator|==
literal|0
condition|)
return|return;
end_if

begin_decl_stmt
specifier|const
name|uint64_t
name|SectionTableOffset
init|=
name|Header
operator|->
name|e_shoff
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SectionTableOffset
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Section header table goes past end of file!"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// The getNumSections() call below depends on SectionHeaderTable being set.
end_comment

begin_expr_stmt
name|SectionHeaderTable
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|SectionTableOffset
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|uint64_t
name|SectionTableSize
init|=
name|getNumSections
argument_list|()
operator|*
name|Header
operator|->
name|e_shentsize
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SectionTableOffset
operator|+
name|SectionTableSize
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Section table goes past end of file!"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// To find the symbol tables we walk the section table to find SHT_SYMTAB.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|SymbolTableSectionHeaderIndex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|sh
init|=
name|SectionHeaderTable
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Reserve SymbolTableSections[0] for .dynsym
end_comment

begin_expr_stmt
name|SymbolTableSections
operator|.
name|push_back
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumSections
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|sh
operator|->
name|sh_type
condition|)
block|{
case|case
name|ELF
operator|::
name|SHT_SYMTAB_SHNDX
case|:
block|{
if|if
condition|(
name|SymbolTableSectionHeaderIndex
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .symtab_shndx!"
argument_list|)
expr_stmt|;
name|SymbolTableSectionHeaderIndex
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_SYMTAB
case|:
block|{
name|SymbolTableSectionsIndexMap
index|[
name|i
index|]
operator|=
name|SymbolTableSections
operator|.
name|size
argument_list|()
expr_stmt|;
name|SymbolTableSections
operator|.
name|push_back
argument_list|(
name|sh
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_DYNSYM
case|:
block|{
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .dynsym!"
argument_list|)
expr_stmt|;
name|SymbolTableSectionsIndexMap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|SymbolTableSections
index|[
literal|0
index|]
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_REL
case|:
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
block|{
name|SectionRelocMap
index|[
name|getSection
argument_list|(
name|sh
operator|->
name|sh_info
argument_list|)
index|]
operator|.
name|push_back
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_DYNAMIC
case|:
block|{
if|if
condition|(
name|dot_dynamic_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .dynamic!"
argument_list|)
expr_stmt|;
name|dot_dynamic_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_versym
case|:
block|{
if|if
condition|(
name|dot_gnu_version_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_verdef
case|:
block|{
if|if
condition|(
name|dot_gnu_version_d_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version_d section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_d_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_verneed
case|:
block|{
if|if
condition|(
name|dot_gnu_version_r_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version_r section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_r_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|sh
expr_stmt|;
block|}
end_for

begin_comment
comment|// Sort section relocation lists by index.
end_comment

begin_for
for|for
control|(
name|typename
name|RelocMap_t
operator|::
name|iterator
name|i
operator|=
name|SectionRelocMap
operator|.
name|begin
argument_list|()
operator|,
name|e
operator|=
name|SectionRelocMap
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|i
operator|->
name|second
operator|.
name|begin
argument_list|()
argument_list|,
name|i
operator|->
name|second
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Get string table sections.
end_comment

begin_expr_stmt
name|dot_shstrtab_sec
operator|=
name|getSection
argument_list|(
name|getStringTableIndex
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dot_shstrtab_sec
condition|)
block|{
comment|// Verify that the last byte in the string table in a null.
name|VerifyStrTab
argument_list|(
name|dot_shstrtab_sec
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Merge this into the above loop.
end_comment

begin_for
for|for
control|(
specifier|const
name|char
modifier|*
name|i
init|=
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|SectionHeaderTable
operator|)
init|,
modifier|*
name|e
init|=
name|i
operator|+
name|getNumSections
argument_list|()
operator|*
name|Header
operator|->
name|e_shentsize
init|;
name|i
operator|!=
name|e
condition|;
name|i
operator|+=
name|Header
operator|->
name|e_shentsize
control|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|sh
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|i
operator|)
decl_stmt|;
if|if
condition|(
name|sh
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_STRTAB
condition|)
block|{
name|StringRef
name|SectionName
argument_list|(
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|sh
operator|->
name|sh_name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SectionName
operator|==
literal|".strtab"
condition|)
block|{
if|if
condition|(
name|dot_strtab_sec
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Already found section named .strtab!"
argument_list|)
expr_stmt|;
name|dot_strtab_sec
operator|=
name|sh
expr_stmt|;
name|VerifyStrTab
argument_list|(
name|dot_strtab_sec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SectionName
operator|==
literal|".dynstr"
condition|)
block|{
if|if
condition|(
name|dot_dynstr_sec
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Already found section named .dynstr!"
argument_list|)
expr_stmt|;
name|dot_dynstr_sec
operator|=
name|sh
expr_stmt|;
name|VerifyStrTab
argument_list|(
name|dot_dynstr_sec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_for

begin_comment
comment|// Build symbol name side-mapping if there is one.
end_comment

begin_if
if|if
condition|(
name|SymbolTableSectionHeaderIndex
condition|)
block|{
specifier|const
name|Elf_Word
modifier|*
name|ShndxTable
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Word
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSectionHeaderIndex
operator|->
name|sh_offset
operator|)
decl_stmt|;
name|error_code
name|ec
decl_stmt|;
for|for
control|(
name|symbol_iterator
name|si
init|=
name|begin_symbols
argument_list|()
init|,
name|se
init|=
name|end_symbols
argument_list|()
init|;
name|si
operator|!=
name|se
condition|;
name|si
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
control|)
block|{
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"Fewer extended symbol table entries than symbols!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ShndxTable
operator|!=
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|ExtendedSymbolTable
index|[
name|getSymbol
argument_list|(
name|si
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|)
index|]
operator|=
operator|*
name|ShndxTable
expr_stmt|;
operator|++
name|ShndxTable
expr_stmt|;
block|}
block|}
end_if

begin_comment
unit|}
comment|// Get the symbol table index in the symtab section given a symbol
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolIndex
argument_list|(
argument|const Elf_Sym *Sym
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|SymbolTableSections
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Only one symbol table supported!"
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|SymTab
operator|=
operator|*
name|SymbolTableSections
operator|.
name|begin
argument_list|()
block|;
name|uintptr_t
name|SymLoc
operator|=
name|uintptr_t
argument_list|(
name|Sym
argument_list|)
block|;
name|uintptr_t
name|SymTabLoc
operator|=
name|uintptr_t
argument_list|(
name|base
argument_list|()
operator|+
name|SymTab
operator|->
name|sh_offset
argument_list|)
block|;
name|assert
argument_list|(
name|SymLoc
operator|>
name|SymTabLoc
operator|&&
literal|"Symbol not in symbol table!"
argument_list|)
block|;
name|uint64_t
name|SymOffset
operator|=
name|SymLoc
operator|-
name|SymTabLoc
block|;
name|assert
argument_list|(
name|SymOffset
operator|%
name|SymTab
operator|->
name|sh_entsize
operator|==
literal|0
operator|&&
literal|"Symbol not multiple of symbol size!"
argument_list|)
block|;
return|return
name|SymOffset
operator|/
name|SymTab
operator|->
name|sh_entsize
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
if|if
condition|(
name|SymbolTableSections
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
literal|1
expr_stmt|;
comment|// The 0th table is .dynsym
block|}
end_else

begin_return
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_dynamic_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
literal|0
expr_stmt|;
comment|// The 0th table is .dynsym
block|}
end_else

begin_return
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_dynamic_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_sections
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|ret
block|;
name|ret
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_shoff
operator|)
block|;
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|ret
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_sections
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|ret
block|;
name|ret
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_shoff
operator|+
operator|(
name|Header
operator|->
name|e_shentsize
operator|*
name|getNumSections
argument_list|()
operator|)
operator|)
block|;
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|ret
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Dyn_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_dynamic_table
argument_list|()
specifier|const
block|{
if|if
condition|(
name|dot_dynamic_sec
condition|)
return|return
name|Elf_Dyn_iterator
argument_list|(
name|dot_dynamic_sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|dot_dynamic_sec
operator|->
name|sh_offset
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|Elf_Dyn_iterator
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Dyn_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_dynamic_table
argument_list|(
argument|bool NULLEnd
argument_list|)
specifier|const
block|{
if|if
condition|(
name|dot_dynamic_sec
condition|)
block|{
name|Elf_Dyn_iterator
name|Ret
argument_list|(
name|dot_dynamic_sec
operator|->
name|sh_entsize
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|dot_dynamic_sec
operator|->
name|sh_offset
operator|+
name|dot_dynamic_sec
operator|->
name|sh_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULLEnd
condition|)
block|{
name|Elf_Dyn_iterator
name|Start
init|=
name|begin_dynamic_table
argument_list|()
decl_stmt|;
while|while
condition|(
name|Start
operator|!=
name|Ret
operator|&&
name|Start
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NULL
condition|)
operator|++
name|Start
expr_stmt|;
comment|// Include the DT_NULL.
if|if
condition|(
name|Start
operator|!=
name|Ret
condition|)
operator|++
name|Start
expr_stmt|;
name|Ret
operator|=
name|Start
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|Ret
return|;
end_return

begin_expr_stmt
unit|}   return
name|Elf_Dyn_iterator
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLoadName
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dt_soname
condition|)
block|{
comment|// Find the DT_SONAME entry
name|Elf_Dyn_iterator
name|it
init|=
name|begin_dynamic_table
argument_list|()
decl_stmt|;
name|Elf_Dyn_iterator
name|ie
init|=
name|end_dynamic_table
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ie
operator|&&
name|it
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_SONAME
condition|)
operator|++
name|it
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|ie
condition|)
block|{
if|if
condition|(
name|dot_dynstr_sec
operator|==
name|NULL
condition|)
name|report_fatal_error
argument_list|(
literal|"Dynamic string table is missing"
argument_list|)
expr_stmt|;
name|dt_soname
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|it
operator|->
name|getVal
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|dt_soname
operator|=
literal|""
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}   return
name|dt_soname
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|begin_libraries_needed
argument_list|()
specifier|const
block|{
comment|// Find the first DT_NEEDED entry
name|Elf_Dyn_iterator
name|i
operator|=
name|begin_dynamic_table
argument_list|()
block|;
name|Elf_Dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
while|while
condition|(
name|i
operator|!=
name|e
operator|&&
name|i
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NEEDED
condition|)
operator|++
name|i
expr_stmt|;
name|DataRefImpl
name|DRI
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|i
operator|.
name|get
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|DRI
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLibraryNext
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|LibraryRef&Result
argument_list|)
specifier|const
block|{
comment|// Use the same DataRefImpl format as DynRef.
name|Elf_Dyn_iterator
name|i
operator|=
name|Elf_Dyn_iterator
argument_list|(
name|dot_dynamic_sec
operator|->
name|sh_entsize
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Data
operator|.
name|p
operator|)
argument_list|)
block|;
name|Elf_Dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
comment|// Skip the current dynamic table entry and find the next DT_NEEDED entry.
do|do
operator|++
name|i
expr_stmt|;
do|while
condition|(
name|i
operator|!=
name|e
operator|&&
name|i
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NEEDED
condition|)
do|;
name|DataRefImpl
name|DRI
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|i
operator|.
name|get
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Result
operator|=
name|LibraryRef
argument_list|(
name|DRI
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getLibraryPath
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|StringRef&Res
argument_list|)
specifier|const
block|{
name|Elf_Dyn_iterator
name|i
operator|=
name|Elf_Dyn_iterator
argument_list|(
name|dot_dynamic_sec
operator|->
name|sh_entsize
argument_list|,
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|Data
operator|.
name|p
operator|)
argument_list|)
block|;
if|if
condition|(
name|i
operator|==
name|end_dynamic_table
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"getLibraryPath() called on iterator end"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NEEDED
condition|)
name|report_fatal_error
argument_list|(
literal|"Invalid library_iterator"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// This uses .dynstr to lookup the name of the DT_NEEDED entry.
end_comment

begin_comment
comment|// THis works as long as DT_STRTAB == .dynstr. This is true most of
end_comment

begin_comment
comment|// the time, but the specification allows exceptions.
end_comment

begin_comment
comment|// TODO: This should really use DT_STRTAB instead. Doing this requires
end_comment

begin_comment
comment|// reading the program headers.
end_comment

begin_if
if|if
condition|(
name|dot_dynstr_sec
operator|==
name|NULL
condition|)
name|report_fatal_error
argument_list|(
literal|"Dynamic string table is missing"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|Res
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|i
operator|->
name|getVal
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|end_libraries_needed
argument_list|()
specifier|const
block|{
name|Elf_Dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
name|DataRefImpl
name|DRI
block|;
name|DRI
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|e
operator|.
name|get
argument_list|()
operator|)
block|;
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|DRI
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint8_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getBytesInAddress
argument_list|()
specifier|const
block|{
return|return
name|ELFT
operator|::
name|Is64Bits
operator|?
literal|8
operator|:
literal|4
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getFileFormatName
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Header
operator|->
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELF
operator|::
name|ELFCLASS32
case|:
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF32-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF32-x86-64"
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
literal|"ELF32-arm"
return|;
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
return|return
literal|"ELF32-hexagon"
return|;
case|case
name|ELF
operator|::
name|EM_MIPS
case|:
return|return
literal|"ELF32-mips"
return|;
default|default:
return|return
literal|"ELF32-unknown"
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|ELFCLASS64
case|:
end_case

begin_switch
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF64-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF64-x86-64"
return|;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
return|return
literal|"ELF64-aarch64"
return|;
case|case
name|ELF
operator|::
name|EM_PPC64
case|:
return|return
literal|"ELF64-ppc64"
return|;
case|case
name|ELF
operator|::
name|EM_S390
case|:
return|return
literal|"ELF64-s390"
return|;
default|default:
return|return
literal|"ELF64-unknown"
return|;
block|}
end_switch

begin_default
default|default:
end_default

begin_comment
comment|// FIXME: Proper error handling.
end_comment

begin_expr_stmt
name|report_fatal_error
argument_list|(
literal|"Invalid ELFCLASS!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|unsigned
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getArch
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
name|Triple
operator|::
name|x86
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
name|Triple
operator|::
name|x86_64
return|;
case|case
name|ELF
operator|::
name|EM_AARCH64
case|:
return|return
name|Triple
operator|::
name|aarch64
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
name|Triple
operator|::
name|arm
return|;
case|case
name|ELF
operator|::
name|EM_HEXAGON
case|:
return|return
name|Triple
operator|::
name|hexagon
return|;
case|case
name|ELF
operator|::
name|EM_MIPS
case|:
return|return
operator|(
name|ELFT
operator|::
name|TargetEndianness
operator|==
name|support
operator|::
name|little
operator|)
condition|?
name|Triple
operator|::
name|mipsel
else|:
name|Triple
operator|::
name|mips
return|;
case|case
name|ELF
operator|::
name|EM_PPC64
case|:
return|return
name|Triple
operator|::
name|ppc64
return|;
case|case
name|ELF
operator|::
name|EM_S390
case|:
return|return
name|Triple
operator|::
name|systemz
return|;
default|default:
return|return
name|Triple
operator|::
name|UnknownArch
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getNumSections
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Header
operator|&&
literal|"Header not initialized!"
argument_list|)
block|;
if|if
condition|(
name|Header
operator|->
name|e_shnum
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
block|{
name|assert
argument_list|(
name|SectionHeaderTable
operator|&&
literal|"SectionHeaderTable not initialized!"
argument_list|)
expr_stmt|;
return|return
name|SectionHeaderTable
operator|->
name|sh_size
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Header
operator|->
name|e_shnum
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getStringTableIndex
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Header
operator|->
name|e_shnum
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
name|Header
operator|->
name|e_shstrndx
operator|==
name|ELF
operator|::
name|SHN_HIRESERVE
condition|)
return|return
name|SectionHeaderTable
operator|->
name|sh_link
return|;
if|if
condition|(
name|Header
operator|->
name|e_shstrndx
operator|>=
name|getNumSections
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Header
operator|->
name|e_shstrndx
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
specifier|const
name|T
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getEntry
argument_list|(
argument|uint16_t Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|T
operator|>
operator|(
name|getSection
argument_list|(
name|Section
argument_list|)
operator|,
name|Entry
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
specifier|const
name|T
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getEntry
argument_list|(
argument|const Elf_Shdr * Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Section
operator|->
name|sh_offset
operator|+
operator|(
name|Entry
operator|*
name|Section
operator|->
name|sh_entsize
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbol
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Sym
operator|>
operator|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
operator|,
name|Symb
operator|.
name|d
operator|.
name|a
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rel
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRel
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Rel
operator|>
operator|(
name|Rel
operator|.
name|w
operator|.
name|b
operator|,
name|Rel
operator|.
name|w
operator|.
name|c
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rela
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getRela
argument_list|(
argument|DataRefImpl Rela
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Rela
operator|>
operator|(
name|Rela
operator|.
name|w
operator|.
name|b
operator|,
name|Rela
operator|.
name|w
operator|.
name|c
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSection
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Symb
operator|.
name|d
operator|.
name|b
argument_list|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_SYMTAB
operator|||
name|sec
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_DYNSYM
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Invalid symbol table section!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|sec
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSection
argument_list|(
argument|uint32_t index
argument_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|SectionHeaderTable
operator|||
name|index
operator|>=
name|getNumSections
argument_list|()
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Invalid section index!"
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|SectionHeaderTable
operator|)
operator|+
operator|(
name|index
operator|*
name|Header
operator|->
name|e_shentsize
operator|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|char
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getString
argument_list|(
argument|uint32_t section
argument_list|,
argument|ELF::Elf32_Word offset
argument_list|)
specifier|const
block|{
return|return
name|getString
argument_list|(
name|getSection
argument_list|(
name|section
argument_list|)
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|char
operator|*
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getString
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|ELF::Elf32_Word offset
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|section
operator|&&
name|section
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_STRTAB
operator|&&
literal|"Invalid section!"
argument_list|)
block|;
if|if
condition|(
name|offset
operator|>=
name|section
operator|->
name|sh_size
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Symbol name offset outside of string table!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|section
operator|->
name|sh_offset
operator|+
name|offset
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolName
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|const Elf_Sym *symb
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|section
init|=
name|getSection
argument_list|(
name|symb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
name|Result
operator|=
literal|""
expr_stmt|;
else|else
name|Result
operator|=
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|section
operator|==
name|SymbolTableSections
index|[
literal|0
index|]
condition|)
block|{
comment|// Symbol is in .dynsym, use .dynstr string table
name|Result
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|symb
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use the default symbol table name section.
name|Result
operator|=
name|getString
argument_list|(
name|dot_strtab_sec
argument_list|,
name|symb
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSectionName
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|Result
operator|=
name|StringRef
argument_list|(
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|ELFT
operator|>
operator|::
name|getSymbolVersion
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|const Elf_Sym *symb
argument_list|,
argument|StringRef&Version
argument_list|,
argument|bool&IsDefault
argument_list|)
specifier|const
block|{
comment|// Handle non-dynamic symbols.
if|if
condition|(
name|section
operator|!=
name|SymbolTableSections
index|[
literal|0
index|]
condition|)
block|{
comment|// Non-dynamic symbols can have versions in their names
comment|// A name of the form 'foo@V1' indicates version 'V1', non-default.
comment|// A name of the form 'foo@@V2' indicates version 'V2', default version.
name|StringRef
name|Name
decl_stmt|;
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|section
argument_list|,
name|symb
argument_list|,
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ec
operator|!=
name|object_error
operator|::
name|success
condition|)
return|return
name|ec
return|;
name|size_t
name|atpos
init|=
name|Name
operator|.
name|find
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|atpos
operator|==
name|StringRef
operator|::
name|npos
condition|)
block|{
name|Version
operator|=
literal|""
expr_stmt|;
name|IsDefault
operator|=
name|false
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
operator|++
name|atpos
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|atpos
operator|<
name|Name
operator|.
name|size
argument_list|()
operator|&&
name|Name
index|[
name|atpos
index|]
operator|==
literal|'@'
condition|)
block|{
name|IsDefault
operator|=
name|true
expr_stmt|;
operator|++
name|atpos
expr_stmt|;
block|}
else|else
block|{
name|IsDefault
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Version
operator|=
name|Name
operator|.
name|substr
argument_list|(
name|atpos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_comment
unit|}
comment|// This is a dynamic symbol. Look in the GNU symbol version table.
end_comment

begin_expr_stmt
unit|if
operator|(
name|dot_gnu_version_sec
operator|==
name|NULL
operator|)
block|{
comment|// No version table.
name|Version
operator|=
literal|""
block|;
name|IsDefault
operator|=
name|false
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_comment
comment|// Determine the position in the symbol table of this entry.
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|sec_start
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|section
operator|->
name|sh_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|entry_index
init|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|symb
operator|-
name|sec_start
operator|)
operator|/
name|section
operator|->
name|sh_entsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Get the corresponding version index entry
end_comment

begin_decl_stmt
specifier|const
name|Elf_Versym
modifier|*
name|vs
init|=
name|getEntry
operator|<
name|Elf_Versym
operator|>
operator|(
name|dot_gnu_version_sec
expr|,
name|entry_index
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|version_index
init|=
name|vs
operator|->
name|vs_index
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Special markers for unversioned symbols.
end_comment

begin_if
if|if
condition|(
name|version_index
operator|==
name|ELF
operator|::
name|VER_NDX_LOCAL
operator|||
name|version_index
operator|==
name|ELF
operator|::
name|VER_NDX_GLOBAL
condition|)
block|{
name|Version
operator|=
literal|""
expr_stmt|;
name|IsDefault
operator|=
name|false
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_if

begin_comment
comment|// Lookup this symbol in the version table
end_comment

begin_expr_stmt
name|LoadVersionMap
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|version_index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
operator|||
name|VersionMap
index|[
name|version_index
index|]
operator|.
name|isNull
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Symbol has version index without corresponding "
literal|"define or reference entry"
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
specifier|const
name|VersionMapEntry
modifier|&
name|entry
init|=
name|VersionMap
index|[
name|version_index
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Get the version name string
end_comment

begin_decl_stmt
name|size_t
name|name_offset
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|entry
operator|.
name|isVerdef
argument_list|()
condition|)
block|{
comment|// The first Verdaux entry holds the name.
name|name_offset
operator|=
name|entry
operator|.
name|getVerdef
argument_list|()
operator|->
name|getAux
argument_list|()
operator|->
name|vda_name
expr_stmt|;
block|}
else|else
block|{
name|name_offset
operator|=
name|entry
operator|.
name|getVernaux
argument_list|()
operator|->
name|vna_name
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Version
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|name_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set IsDefault
end_comment

begin_if
if|if
condition|(
name|entry
operator|.
name|isVerdef
argument_list|()
condition|)
block|{
name|IsDefault
operator|=
operator|!
operator|(
name|vs
operator|->
name|vs_index
operator|&
name|ELF
operator|::
name|VERSYM_HIDDEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|IsDefault
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_comment
unit|}
comment|/// This is a generic interface for retrieving GNU symbol version
end_comment

begin_comment
comment|/// information from an ELFObjectFile.
end_comment

begin_function
unit|static
specifier|inline
name|error_code
name|GetELFSymbolVersion
parameter_list|(
specifier|const
name|ObjectFile
modifier|*
name|Obj
parameter_list|,
specifier|const
name|SymbolRef
modifier|&
name|Sym
parameter_list|,
name|StringRef
modifier|&
name|Version
parameter_list|,
name|bool
modifier|&
name|IsDefault
parameter_list|)
block|{
comment|// Little-endian 32-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|4
operator|,
name|false
operator|>
expr|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|4
operator|,
name|false
operator|>
expr|>
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 32-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|4
operator|,
name|false
operator|>
expr|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|4
operator|,
name|false
operator|>
expr|>
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Little-endian 64-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|8
operator|,
name|true
operator|>
expr|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|little
operator|,
literal|8
operator|,
name|true
operator|>
expr|>
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 64-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|8
operator|,
name|true
operator|>
expr|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|ELFType
operator|<
name|support
operator|::
name|big
operator|,
literal|8
operator|,
name|true
operator|>
expr|>
operator|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Object passed to GetELFSymbolVersion() is not ELF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// This function returns the hash value for a symbol in the .dynsym section
end_comment

begin_comment
comment|/// Name of the API remains consistent as specified in the libelf
end_comment

begin_comment
comment|/// REF : http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|elf_hash
parameter_list|(
name|StringRef
modifier|&
name|symbolName
parameter_list|)
block|{
name|unsigned
name|h
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|j
init|=
name|symbolName
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|symbolName
index|[
name|i
index|]
expr_stmt|;
name|g
operator|=
name|h
operator|&
literal|0xf0000000L
expr_stmt|;
if|if
condition|(
name|g
operator|!=
literal|0
condition|)
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

