begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ELF.h - ELF object file implementation -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the ELFObjectFile template class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_ELF_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_ELF_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ObjectFile.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|object
block|{
comment|// Subclasses of ELFObjectFile may need this for template instantiation
specifier|inline
name|std
operator|::
name|pair
operator|<
name|unsigned
name|char
operator|,
name|unsigned
name|char
operator|>
name|getElfArchType
argument_list|(
argument|MemoryBuffer *Object
argument_list|)
block|{
if|if
condition|(
name|Object
operator|->
name|getBufferSize
argument_list|()
operator|<
name|ELF
operator|::
name|EI_NIDENT
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
operator|(
name|uint8_t
operator|)
name|ELF
operator|::
name|ELFCLASSNONE
argument_list|,
operator|(
name|uint8_t
operator|)
name|ELF
operator|::
name|ELFDATANONE
argument_list|)
return|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
operator|(
name|uint8_t
operator|)
name|Object
operator|->
name|getBufferStart
argument_list|()
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
argument_list|,
operator|(
name|uint8_t
operator|)
name|Object
operator|->
name|getBufferStart
argument_list|()
index|[
name|ELF
operator|::
name|EI_DATA
index|]
argument_list|)
return|;
block|}
comment|// Templates to choose Elf_Addr and Elf_Off depending on is64Bits.
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelperCommon
block|{
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint16_t
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Half
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint32_t
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Word
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int32_t
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Sword
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint64_t
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Xword
expr_stmt|;
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int64_t
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Sxword
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// ELF 32bit types.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|target_endianness
operator|,
name|false
operator|>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|target_endianness
operator|>
block|{
typedef|typedef
name|uint32_t
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Addr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Off
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|/// ELF 64bit types.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|target_endianness
operator|,
name|true
operator|>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|target_endianness
operator|>
block|{
typedef|typedef
name|uint64_t
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Addr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
operator|,
name|target_endianness
operator|,
name|support
operator|::
name|aligned
operator|>
name|Elf_Off
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|// I really don't like doing this, but the alternative is copypasta.
end_comment

begin_define
define|#
directive|define
name|LLVM_ELF_IMPORT_TYPES
parameter_list|(
name|target_endianness
parameter_list|,
name|is64Bits
parameter_list|)
define|\
value|typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Addr Elf_Addr; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Off Elf_Off; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Half Elf_Half; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Word Elf_Word; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Sword Elf_Sword; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Xword Elf_Xword; \ typedef typename \   ELFDataTypeTypedefHelper<target_endianness, is64Bits>::Elf_Sxword Elf_Sxword;
end_define

begin_comment
comment|// Section header.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Shdr_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|target_endianness
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Word
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Word
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Word
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Word
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|target_endianness
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Xword
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Xword
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Xword
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Xword
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Shdr_Impl
operator|:
name|Elf_Shdr_Base
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
block|{
name|using
name|Elf_Shdr_Base
operator|<
name|target_endianness
block|,
name|is64Bits
operator|>
operator|::
name|sh_entsize
block|;
name|using
name|Elf_Shdr_Base
operator|<
name|target_endianness
block|,
name|is64Bits
operator|>
operator|::
name|sh_size
block|;
comment|/// @brief Get the number of entities this section contains if it has any.
name|unsigned
name|getEntityCount
argument_list|()
specifier|const
block|{
if|if
condition|(
name|sh_entsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|sh_size
operator|/
name|sh_entsize
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Sym_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|target_endianness
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Word
name|st_size
block|;
comment|// Size of the symbol
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|target_endianness
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Xword
name|st_size
block|;
comment|// Size of the symbol
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Sym_Impl
operator|:
name|Elf_Sym_Base
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
block|{
name|using
name|Elf_Sym_Base
operator|<
name|target_endianness
block|,
name|is64Bits
operator|>
operator|::
name|st_info
block|;
comment|// These accessors and mutators correspond to the ELF32_ST_BIND,
comment|// ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:
name|unsigned
name|char
name|getBinding
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|>>
literal|4
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|&
literal|0x0f
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setBinding
parameter_list|(
name|unsigned
name|char
name|b
parameter_list|)
block|{
name|setBindingAndType
argument_list|(
name|b
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|setBindingAndType
argument_list|(
name|getBinding
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setBindingAndType
parameter_list|(
name|unsigned
name|char
name|b
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|st_info
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator|+
operator|(
name|t
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// Elf_Versym: This is the structure of entries in the SHT_GNU_versym section
end_comment

begin_comment
comment|/// (.gnu.version). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Versym_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
name|Elf_Half
name|vs_index
block|;
comment|// Version index with flags (e.g. VERSYM_HIDDEN)
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Verdaux_Impl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verdef: This is the structure of entries in the SHT_GNU_verdef section
end_comment

begin_comment
comment|/// (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Verdef_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
typedef|typedef
name|Elf_Verdaux_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Verdaux
expr_stmt|;
name|Elf_Half
name|vd_version
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Version of this structure (e.g. VER_DEF_CURRENT)
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Bitwise flags (VER_DEF_*)
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_ndx
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Version index, used in .gnu.version entries
end_comment

begin_decl_stmt
name|Elf_Half
name|vd_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Number of Verdaux entries
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Hash of name
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_aux
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Offset to the first Verdaux entry (in bytes)
end_comment

begin_decl_stmt
name|Elf_Word
name|vd_next
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Offset to the next Verdef entry (in bytes)
end_comment

begin_comment
comment|/// Get the first Verdaux entry for this Verdef.
end_comment

begin_expr_stmt
specifier|const
name|Elf_Verdaux
operator|*
name|getAux
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verdaux
operator|*
operator|>
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
name|vd_aux
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// Elf_Verdaux: This is the structure of auxilary data in the SHT_GNU_verdef
end_comment

begin_comment
comment|/// section (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Verdaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
name|Elf_Word
name|vda_name
block|;
comment|// Version name (offset in string table)
name|Elf_Word
name|vda_next
block|;
comment|// Offset to next Verdaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verneed: This is the structure of entries in the SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Verneed_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
name|Elf_Half
name|vn_version
block|;
comment|// Version of this structure (e.g. VER_NEED_CURRENT)
name|Elf_Half
name|vn_cnt
block|;
comment|// Number of associated Vernaux entries
name|Elf_Word
name|vn_file
block|;
comment|// Library name (string table offset)
name|Elf_Word
name|vn_aux
block|;
comment|// Offset to first Vernaux entry (in bytes)
name|Elf_Word
name|vn_next
block|;
comment|// Offset to next Verneed entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Vernaux: This is the structure of auxiliary data in SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Vernaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
name|Elf_Word
name|vna_hash
block|;
comment|// Hash of dependency name
name|Elf_Half
name|vna_flags
block|;
comment|// Bitwise Flags (VER_FLAG_*)
name|Elf_Half
name|vna_other
block|;
comment|// Version index, used in .gnu.version entries
name|Elf_Word
name|vna_name
block|;
comment|// Dependency name
name|Elf_Word
name|vna_next
block|;
comment|// Offset to next Vernaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Base: This structure matches the form of entries in the dynamic
end_comment

begin_comment
comment|///               table section (.dynamic) look like.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Dyn_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|target_endianness
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
name|Elf_Sword
name|d_tag
block|;
expr|union
block|{
name|Elf_Word
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|target_endianness
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
name|Elf_Sxword
name|d_tag
block|;
expr|union
block|{
name|Elf_Xword
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Impl: This inherits from Elf_Dyn_Base, adding getters and setters.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
expr|struct
name|Elf_Dyn_Impl
operator|:
name|Elf_Dyn_Base
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
block|{
name|using
name|Elf_Dyn_Base
operator|<
name|target_endianness
block|,
name|is64Bits
operator|>
operator|::
name|d_tag
block|;
name|using
name|Elf_Dyn_Base
operator|<
name|target_endianness
block|,
name|is64Bits
operator|>
operator|::
name|d_un
block|;
name|int64_t
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|d_tag
return|;
block|}
name|uint64_t
name|getVal
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|d_val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getPtr
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|class
name|ELFObjectFile
expr_stmt|;
end_expr_stmt

begin_comment
comment|// DynRefImpl: Reference to an entry in the dynamic table
end_comment

begin_comment
comment|// This is an ELF-specific interface.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|class
name|DynRefImpl
block|{
typedef|typedef
name|Elf_Dyn_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Dyn
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|OwningType
expr_stmt|;
end_typedef

begin_decl_stmt
name|DataRefImpl
name|DynPimpl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|OwningType
modifier|*
name|OwningObject
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|DynRefImpl
argument_list|()
operator|:
name|OwningObject
argument_list|(
argument|NULL
argument_list|)
block|{ }
name|DynRefImpl
argument_list|(
argument|DataRefImpl DynP
argument_list|,
argument|const OwningType *Owner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|DynRefImpl
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|DynRefImpl
operator|&
name|Other
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|error_code
name|getNext
argument_list|(
name|DynRefImpl
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int64_t
name|getTag
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getVal
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getPtr
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DataRefImpl
name|getRawDataRefImpl
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Elf_Rel: Elf Relocation
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|false
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Word
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|true
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Xword
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|false
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Word
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|Elf_Sword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|>
expr|struct
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|true
operator|,
name|true
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Xword
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|Elf_Sxword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this.
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|target_endianness
operator|,
name|true
operator|,
name|isRela
operator|>
operator|:
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|true
operator|,
name|isRela
operator|>
block|{
name|using
name|Elf_Rel_Base
operator|<
name|target_endianness
block|,
name|true
block|,
name|isRela
operator|>
operator|::
name|r_info
block|;
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|true
argument_list|)
comment|// These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,
comment|// and ELF64_R_INFO macros defined in the ELF specification:
name|uint64_t
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
operator|(
name|r_info
operator|>>
literal|32
operator|)
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_info
operator|&
literal|0xffffffffL
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint64_t
name|s
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint64_t
name|s
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|r_info
operator|=
operator|(
name|s
operator|<<
literal|32
operator|)
operator|+
operator|(
name|t
operator|&
literal|0xffffffffL
operator|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|target_endianness
operator|,
name|false
operator|,
name|isRela
operator|>
operator|:
name|Elf_Rel_Base
operator|<
name|target_endianness
operator|,
name|false
operator|,
name|isRela
operator|>
block|{
name|using
name|Elf_Rel_Base
operator|<
name|target_endianness
block|,
name|false
block|,
name|isRela
operator|>
operator|::
name|r_info
block|;
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|false
argument_list|)
comment|// These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,
comment|// and ELF32_R_INFO macros defined in the ELF specification:
name|uint32_t
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
operator|(
name|r_info
operator|>>
literal|8
operator|)
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_info
operator|&
literal|0x0ff
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint32_t
name|s
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|r_info
operator|=
operator|(
name|s
operator|<<
literal|8
operator|)
operator|+
name|t
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|class
name|ELFObjectFile
operator|:
name|public
name|ObjectFile
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|target_endianness
argument_list|,
argument|is64Bits
argument_list|)
typedef|typedef
name|Elf_Shdr_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Shdr
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Elf_Sym_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Sym
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Dyn_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Dyn
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Rel_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|,
name|false
operator|>
name|Elf_Rel
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Rel_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|,
name|true
operator|>
name|Elf_Rela
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verdef_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Verdef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verdaux_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Verdaux
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Verneed_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Verneed
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Vernaux_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Vernaux
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Versym_Impl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|Elf_Versym
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
name|DynRef
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|content_iterator
operator|<
name|DynRef
operator|>
name|dyn_iterator
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_struct
struct|struct
name|Elf_Ehdr
block|{
name|unsigned
name|char
name|e_ident
index|[
name|ELF
operator|::
name|EI_NIDENT
index|]
decl_stmt|;
comment|// ELF Identification bytes
name|Elf_Half
name|e_type
decl_stmt|;
comment|// Type of file (see ET_*)
name|Elf_Half
name|e_machine
decl_stmt|;
comment|// Required architecture for this file (see EM_*)
name|Elf_Word
name|e_version
decl_stmt|;
comment|// Must be equal to 1
name|Elf_Addr
name|e_entry
decl_stmt|;
comment|// Address to jump to in order to start program
name|Elf_Off
name|e_phoff
decl_stmt|;
comment|// Program header table's file offset, in bytes
name|Elf_Off
name|e_shoff
decl_stmt|;
comment|// Section header table's file offset, in bytes
name|Elf_Word
name|e_flags
decl_stmt|;
comment|// Processor-specific flags
name|Elf_Half
name|e_ehsize
decl_stmt|;
comment|// Size of ELF header, in bytes
name|Elf_Half
name|e_phentsize
decl_stmt|;
comment|// Size of an entry in the program header table
name|Elf_Half
name|e_phnum
decl_stmt|;
comment|// Number of entries in the program header table
name|Elf_Half
name|e_shentsize
decl_stmt|;
comment|// Size of an entry in the section header table
name|Elf_Half
name|e_shnum
decl_stmt|;
comment|// Number of entries in the section header table
name|Elf_Half
name|e_shstrndx
decl_stmt|;
comment|// Section header table index of section name
comment|// string table
name|bool
name|checkMagic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|e_ident
argument_list|,
name|ELF
operator|::
name|ElfMagic
argument_list|,
name|strlen
argument_list|(
name|ELF
operator|::
name|ElfMagic
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
name|unsigned
name|char
name|getFileClass
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
return|;
block|}
name|unsigned
name|char
name|getDataEncoding
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_DATA
index|]
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|// This flag is used for classof, to distinguish ELFObjectFile from
end_comment

begin_comment
comment|// its subclass. If more subclasses will be created, this flag will
end_comment

begin_comment
comment|// have to become an enum.
end_comment

begin_decl_stmt
name|bool
name|isDyldELFObject
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|,
literal|1
operator|>
name|Sections_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|IndexMap_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|,
name|SmallVector
operator|<
name|uint32_t
operator|,
literal|1
operator|>
expr|>
name|RelocMap_t
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|const
name|Elf_Ehdr
modifier|*
name|Header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|SectionHeaderTable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_shstrtab_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Section header string table.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_strtab_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Symbol header string table.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_dynstr_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Dynamic symbol string table.
end_comment

begin_comment
comment|// SymbolTableSections[0] always points to the dynamic string table section
end_comment

begin_comment
comment|// header, or NULL if there is no dynamic string table.
end_comment

begin_decl_stmt
name|Sections_t
name|SymbolTableSections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IndexMap_t
name|SymbolTableSectionsIndexMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DenseMap
operator|<
specifier|const
name|Elf_Sym
operator|*
operator|,
name|ELF
operator|::
name|Elf64_Word
operator|>
name|ExtendedSymbolTable
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_dynamic_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .dynamic
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_r_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version_r
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|dot_gnu_version_d_sec
decl_stmt|;
end_decl_stmt

begin_comment
comment|// .gnu.version_d
end_comment

begin_comment
comment|// Pointer to SONAME entry in dynamic string table
end_comment

begin_comment
comment|// This is set the first time getLoadName is called.
end_comment

begin_decl_stmt
name|mutable
specifier|const
name|char
modifier|*
name|dt_soname
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Records for each version index the corresponding Verdef or Vernaux entry.
end_comment

begin_comment
comment|// This is filled the first time LoadVersionMap() is called.
end_comment

begin_decl_stmt
name|class
name|VersionMapEntry
range|:
name|public
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
decl_stmt|, 1>
block|{
name|public
label|:
comment|// If the integer is 0, this is an Elf_Verdef*.
comment|// If the integer is 1, this is an Elf_Vernaux*.
name|VersionMapEntry
argument_list|()
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|NULL
operator|,
literal|0
operator|)
block|{ }
name|VersionMapEntry
argument_list|(
specifier|const
name|Elf_Verdef
operator|*
name|verdef
argument_list|)
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|verdef
operator|,
literal|0
operator|)
block|{ }
name|VersionMapEntry
argument_list|(
specifier|const
name|Elf_Vernaux
operator|*
name|vernaux
argument_list|)
operator|:
name|PointerIntPair
operator|<
specifier|const
name|void
operator|*
operator|,
literal|1
operator|>
operator|(
name|vernaux
operator|,
literal|1
operator|)
block|{ }
name|bool
name|isNull
argument_list|()
specifier|const
block|{
return|return
name|getPointer
argument_list|()
operator|==
name|NULL
return|;
block|}
name|bool
name|isVerdef
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
operator|&&
name|getInt
argument_list|()
operator|==
literal|0
return|;
block|}
name|bool
name|isVernaux
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNull
argument_list|()
operator|&&
name|getInt
argument_list|()
operator|==
literal|1
return|;
block|}
specifier|const
name|Elf_Verdef
operator|*
name|getVerdef
argument_list|()
specifier|const
block|{
return|return
name|isVerdef
argument_list|()
operator|?
operator|(
specifier|const
name|Elf_Verdef
operator|*
operator|)
name|getPointer
argument_list|()
operator|:
name|NULL
return|;
block|}
specifier|const
name|Elf_Vernaux
operator|*
name|getVernaux
argument_list|()
specifier|const
block|{
return|return
name|isVernaux
argument_list|()
operator|?
operator|(
specifier|const
name|Elf_Vernaux
operator|*
operator|)
name|getPointer
argument_list|()
operator|:
name|NULL
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|mutable
name|SmallVector
operator|<
name|VersionMapEntry
operator|,
literal|16
operator|>
name|VersionMap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|LoadVersionDefs
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|LoadVersionNeeds
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|ec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|LoadVersionMap
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// @brief Map sections to an array of relocation sections that reference
end_comment

begin_comment
comment|///        them sorted by section index.
end_comment

begin_decl_stmt
name|RelocMap_t
name|SectionRelocMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// @brief Get the relocation section that contains \a Rel.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getRelSection
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
block|{
return|return
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isRelocationHasAddend
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getEntry
argument_list|(
argument|uint16_t Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getEntry
argument_list|(
argument|const Elf_Shdr *Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
name|DataRefImpl
name|index
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
name|uint32_t
name|index
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Rel
modifier|*
name|getRel
argument_list|(
name|DataRefImpl
name|Rel
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Rela
modifier|*
name|getRela
argument_list|(
name|DataRefImpl
name|Rela
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|getString
argument_list|(
name|uint32_t
name|section
argument_list|,
name|uint32_t
name|offset
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|getString
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
name|uint32_t
name|offset
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSymbolName
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|Symb
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSymbolVersion
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|Symb
argument_list|,
name|StringRef
operator|&
name|Version
argument_list|,
name|bool
operator|&
name|IsDefault
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|VerifyStrTab
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|sh
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|getSymbol
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: Should be private?
end_comment

begin_decl_stmt
name|void
name|validateSymbol
argument_list|(
name|DataRefImpl
name|Symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
specifier|const
name|Elf_Dyn
modifier|*
name|getDyn
argument_list|(
name|DataRefImpl
name|DynData
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|error_code
name|getSymbolVersion
argument_list|(
name|SymbolRef
name|Symb
argument_list|,
name|StringRef
operator|&
name|Version
argument_list|,
name|bool
operator|&
name|IsDefault
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolNext
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolName
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolFileOffset
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolAddress
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolSize
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolNMTypeChar
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|char
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolFlags
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|uint32_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolType
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|SymbolRef
operator|::
name|Type
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSymbolSection
argument_list|(
name|DataRefImpl
name|Symb
argument_list|,
name|section_iterator
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|friend
name|class
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getDynNext
argument_list|(
name|DataRefImpl
name|DynData
argument_list|,
name|DynRef
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getLibraryNext
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|LibraryRef
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getLibraryPath
argument_list|(
name|DataRefImpl
name|Data
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionNext
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|SectionRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionName
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionAddress
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionSize
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionContents
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|StringRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getSectionAlignment
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionText
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionData
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionBSS
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionRequiredForExecution
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionVirtual
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|isSectionZeroInit
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|bool
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|sectionContainsSymbol
argument_list|(
name|DataRefImpl
name|Sec
argument_list|,
name|DataRefImpl
name|Symb
argument_list|,
name|bool
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|relocation_iterator
name|getSectionRelBegin
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|relocation_iterator
name|getSectionRelEnd
argument_list|(
name|DataRefImpl
name|Sec
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationNext
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|RelocationRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationAddress
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationOffset
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationSymbol
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SymbolRef
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationType
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|uint64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationTypeName
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationAdditionalInfo
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|int64_t
operator|&
name|Res
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|virtual
name|error_code
name|getRelocationValueString
argument_list|(
name|DataRefImpl
name|Rel
argument_list|,
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Result
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|begin_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|end_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|begin_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|symbol_iterator
name|end_dynamic_symbols
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|section_iterator
name|begin_sections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|section_iterator
name|end_sections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|library_iterator
name|begin_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|library_iterator
name|end_libraries_needed
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|dyn_iterator
name|begin_dynamic_table
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|dyn_iterator
name|end_dynamic_table
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|uint8_t
name|getBytesInAddress
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getFileFormatName
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getObjectType
argument_list|()
specifier|const
block|{
return|return
literal|"ELF"
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|unsigned
name|getArch
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual
name|StringRef
name|getLoadName
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getNumSections
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|getStringTableIndex
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ELF
operator|::
name|Elf64_Word
name|getSymbolTableIndex
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|getSection
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symb
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Methods for type inquiry through isa, cast, and dyn_cast
end_comment

begin_expr_stmt
name|bool
name|isDyldType
argument_list|()
specifier|const
block|{
return|return
name|isDyldELFObject
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Binary
modifier|*
name|v
parameter_list|)
block|{
return|return
name|v
operator|->
name|getType
argument_list|()
operator|==
name|getELFType
argument_list|(
name|target_endianness
operator|==
name|support
operator|::
name|little
argument_list|,
name|is64Bits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|ELFObjectFile
modifier|*
name|v
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
unit|};
comment|// Iterate through the version definitions, and place each Elf_Verdef
end_comment

begin_comment
comment|// in the VersionMap according to its index.
end_comment

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|void
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|LoadVersionDefs
argument_list|(
argument|const Elf_Shdr *sec
argument_list|)
specifier|const
block|{
name|unsigned
name|vd_size
operator|=
name|sec
operator|->
name|sh_size
block|;
comment|// Size of section in bytes
name|unsigned
name|vd_count
operator|=
name|sec
operator|->
name|sh_info
block|;
comment|// Number of Verdef entries
specifier|const
name|char
operator|*
name|sec_start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
specifier|const
name|char
operator|*
name|sec_end
operator|=
name|sec_start
operator|+
name|vd_size
block|;
comment|// The first Verdef entry is at the start of the section.
specifier|const
name|char
operator|*
name|p
operator|=
name|sec_start
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpectedly while scanning "
literal|"version definitions."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Verdef
modifier|*
name|vd
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verdef
operator|*
operator|>
operator|(
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_version
operator|!=
name|ELF
operator|::
name|VER_DEF_CURRENT
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected verdef version"
argument_list|)
expr_stmt|;
name|size_t
name|index
init|=
name|vd
operator|->
name|vd_ndx
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
condition|)
name|VersionMap
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VersionMap
index|[
name|index
index|]
operator|=
name|VersionMapEntry
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|p
operator|+=
name|vd
operator|->
name|vd_next
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Iterate through the versions needed section, and place each Elf_Vernaux
end_comment

begin_comment
comment|// in the VersionMap according to its index.
end_comment

begin_expr_stmt
unit|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|void
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|LoadVersionNeeds
argument_list|(
argument|const Elf_Shdr *sec
argument_list|)
specifier|const
block|{
name|unsigned
name|vn_size
operator|=
name|sec
operator|->
name|sh_size
block|;
comment|// Size of section in bytes
name|unsigned
name|vn_count
operator|=
name|sec
operator|->
name|sh_info
block|;
comment|// Number of Verneed entries
specifier|const
name|char
operator|*
name|sec_start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
specifier|const
name|char
operator|*
name|sec_end
operator|=
name|sec_start
operator|+
name|vn_size
block|;
comment|// The first Verneed entry is at the start of the section.
specifier|const
name|char
operator|*
name|p
operator|=
name|sec_start
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vn_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpectedly while scanning "
literal|"version needed records."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Verneed
modifier|*
name|vn
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verneed
operator|*
operator|>
operator|(
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|vn
operator|->
name|vn_version
operator|!=
name|ELF
operator|::
name|VER_NEED_CURRENT
condition|)
name|report_fatal_error
argument_list|(
literal|"Unexpected verneed version"
argument_list|)
expr_stmt|;
comment|// Iterate through the Vernaux entries
specifier|const
name|char
modifier|*
name|paux
init|=
name|p
operator|+
name|vn
operator|->
name|vn_aux
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|vn
operator|->
name|vn_cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|paux
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
operator|>
name|sec_end
condition|)
name|report_fatal_error
argument_list|(
literal|"Section ended unexpected while scanning auxiliary "
literal|"version needed records."
argument_list|)
expr_stmt|;
specifier|const
name|Elf_Vernaux
modifier|*
name|vna
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Vernaux
operator|*
operator|>
operator|(
name|paux
operator|)
decl_stmt|;
name|size_t
name|index
init|=
name|vna
operator|->
name|vna_other
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
condition|)
name|VersionMap
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VersionMap
index|[
name|index
index|]
operator|=
name|VersionMapEntry
argument_list|(
name|vna
argument_list|)
expr_stmt|;
name|paux
operator|+=
name|vna
operator|->
name|vna_next
expr_stmt|;
block|}
name|p
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|void
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|LoadVersionMap
argument_list|()
specifier|const
block|{
comment|// If there is no dynamic symtab or version table, there is nothing to do.
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|dot_gnu_version_sec
operator|==
name|NULL
condition|)
return|return;
end_expr_stmt

begin_comment
comment|// Has the VersionMap already been loaded?
end_comment

begin_if
if|if
condition|(
name|VersionMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
return|return;
end_if

begin_comment
comment|// The first two version indexes are reserved.
end_comment

begin_comment
comment|// Index 0 is LOCAL, index 1 is GLOBAL.
end_comment

begin_expr_stmt
name|VersionMap
operator|.
name|push_back
argument_list|(
name|VersionMapEntry
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VersionMap
operator|.
name|push_back
argument_list|(
name|VersionMapEntry
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dot_gnu_version_d_sec
condition|)
name|LoadVersionDefs
argument_list|(
name|dot_gnu_version_d_sec
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|dot_gnu_version_r_sec
condition|)
name|LoadVersionNeeds
argument_list|(
name|dot_gnu_version_r_sec
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|void
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|validateSymbol
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|SymbolTableSection
operator|=
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
block|;
comment|// FIXME: We really need to do proper error handling in the case of an invalid
comment|//        input file. Because we don't use exceptions, I think we'll just pass
comment|//        an error object around.
if|if
condition|(
operator|!
operator|(
name|symb
operator|&&
name|SymbolTableSection
operator|&&
name|symb
operator|>=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSection
operator|->
name|sh_offset
operator|)
operator|&&
name|symb
operator|<
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSection
operator|->
name|sh_offset
operator|+
name|SymbolTableSection
operator|->
name|sh_size
operator|)
operator|)
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Symb must point to a valid symbol!"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolNext
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|SymbolTableSection
operator|=
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
block|;
operator|++
name|Symb
operator|.
name|d
operator|.
name|a
block|;
comment|// Check to see if we are at the end of this symbol table.
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|a
operator|>=
name|SymbolTableSection
operator|->
name|getEntityCount
argument_list|()
condition|)
block|{
comment|// We are at the end. If there are other symbol tables, jump to them.
comment|// If the symbol table is .dynsym, we are iterating dynamic symbols,
comment|// and there is only one table of these.
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|b
operator|!=
literal|0
condition|)
block|{
operator|++
name|Symb
operator|.
name|d
operator|.
name|b
expr_stmt|;
name|Symb
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
block|}
end_expr_stmt

begin_comment
comment|// Otherwise return the terminator.
end_comment

begin_if
if|if
condition|(
name|Symb
operator|.
name|d
operator|.
name|b
operator|==
literal|0
operator|||
name|Symb
operator|.
name|d
operator|.
name|b
operator|>=
name|SymbolTableSections
operator|.
name|size
argument_list|()
condition|)
block|{
name|Symb
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|Symb
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}    Result
operator|=
name|SymbolRef
argument_list|(
name|Symb
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolName
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
return|return
name|getSymbolName
argument_list|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
argument_list|,
name|symb
argument_list|,
name|Result
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolVersion
argument_list|(
argument|SymbolRef SymRef
argument_list|,
argument|StringRef&Version
argument_list|,
argument|bool&IsDefault
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|Symb
operator|=
name|SymRef
operator|.
name|getRawDataRefImpl
argument_list|()
block|;
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
return|return
name|getSymbolVersion
argument_list|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
argument_list|,
name|symb
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|ELF
operator|::
name|Elf64_Word
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolTableIndex
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_XINDEX
condition|)
return|return
name|ExtendedSymbolTable
operator|.
name|lookup
argument_list|(
name|symb
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|symb
operator|->
name|st_shndx
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSection
argument_list|(
argument|const Elf_Sym *symb
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_XINDEX
condition|)
return|return
name|getSection
argument_list|(
name|ExtendedSymbolTable
operator|.
name|lookup
argument_list|(
name|symb
argument_list|)
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|>=
name|ELF
operator|::
name|SHN_LORESERVE
condition|)
return|return
literal|0
return|;
end_if

begin_return
return|return
name|getSection
argument_list|(
name|symb
operator|->
name|st_shndx
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolFileOffset
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
block|;
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
comment|// Unintialized symbols have no offset in the object file
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|Section
condition|?
name|Section
operator|->
name|sh_addr
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
operator|+
operator|(
name|Section
condition|?
name|Section
operator|->
name|sh_offset
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolAddress
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
block|;
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|Section
condition|?
name|Section
operator|->
name|sh_addr
else|:
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|symb
operator|->
name|st_value
operator|+
operator|(
name|Section
condition|?
name|Section
operator|->
name|sh_addr
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
default|default:
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_switch

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolSize
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
if|if
condition|(
name|symb
operator|->
name|st_size
operator|==
literal|0
condition|)
name|Result
operator|=
name|UnknownAddressOrSize
expr_stmt|;
name|Result
operator|=
name|symb
operator|->
name|st_size
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolNMTypeChar
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|char&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|Section
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
block|;
name|char
name|ret
operator|=
literal|'?'
block|;
if|if
condition|(
name|Section
condition|)
block|{
switch|switch
condition|(
name|Section
operator|->
name|sh_type
condition|)
block|{
case|case
name|ELF
operator|::
name|SHT_PROGBITS
case|:
case|case
name|ELF
operator|::
name|SHT_DYNAMIC
case|:
switch|switch
condition|(
name|Section
operator|->
name|sh_flags
condition|)
block|{
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_EXECINSTR
operator|)
case|:
name|ret
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
case|:
name|ret
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHF_ALLOC
case|:
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_MERGE
operator|)
case|:
case|case
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_MERGE
operator||
name|ELF
operator|::
name|SHF_STRINGS
operator|)
case|:
name|ret
operator|=
literal|'r'
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|SHT_NOBITS
case|:
end_case

begin_expr_stmt
name|ret
operator|=
literal|'b'
expr_stmt|;
end_expr_stmt

begin_switch
unit|}   }
switch|switch
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
condition|)
block|{
case|case
name|ELF
operator|::
name|SHN_UNDEF
case|:
if|if
condition|(
name|ret
operator|==
literal|'?'
condition|)
name|ret
operator|=
literal|'U'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHN_ABS
case|:
name|ret
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|SHN_COMMON
case|:
name|ret
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STB_GLOBAL
case|:
name|ret
operator|=
operator|::
name|toupper
argument_list|(
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STB_WEAK
case|:
if|if
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|ret
operator|=
literal|'w'
expr_stmt|;
elseif|else
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_OBJECT
condition|)
name|ret
operator|=
literal|'V'
expr_stmt|;
else|else
name|ret
operator|=
literal|'W'
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|ret
operator|==
literal|'?'
operator|&&
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_SECTION
condition|)
block|{
name|StringRef
name|name
decl_stmt|;
if|if
condition|(
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|Symb
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|ec
return|;
name|Result
operator|=
name|StringSwitch
operator|<
name|char
operator|>
operator|(
name|name
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".debug"
argument_list|,
literal|'N'
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".note"
argument_list|,
literal|'n'
argument_list|)
operator|.
name|Default
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_if

begin_expr_stmt
name|Result
operator|=
name|ret
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolType
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|SymbolRef::Type&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
switch|switch
condition|(
name|symb
operator|->
name|getType
argument_list|()
condition|)
block|{
case|case
name|ELF
operator|::
name|STT_NOTYPE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Unknown
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_SECTION
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Debug
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FILE
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_File
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_FUNC
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Function
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|STT_OBJECT
case|:
case|case
name|ELF
operator|::
name|STT_COMMON
case|:
case|case
name|ELF
operator|::
name|STT_TLS
case|:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Data
expr_stmt|;
break|break;
default|default:
name|Result
operator|=
name|SymbolRef
operator|::
name|ST_Other
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolFlags
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|uint32_t&Result
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
name|Result
operator|=
name|SymbolRef
operator|::
name|SF_None
block|;
if|if
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
operator|!=
name|ELF
operator|::
name|STB_LOCAL
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Global
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|symb
operator|->
name|getBinding
argument_list|()
operator|==
name|ELF
operator|::
name|STB_WEAK
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Weak
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_ABS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Absolute
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_FILE
operator|||
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_SECTION
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_FormatSpecific
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Undefined
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_COMMON
operator|||
name|getSymbolTableIndex
argument_list|(
name|symb
argument_list|)
operator|==
name|ELF
operator|::
name|SHN_COMMON
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_Common
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|symb
operator|->
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_TLS
condition|)
name|Result
operator||=
name|SymbolRef
operator|::
name|SF_ThreadLocal
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolSection
argument_list|(
argument|DataRefImpl Symb
argument_list|,
argument|section_iterator&Res
argument_list|)
specifier|const
block|{
name|validateSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Sym
operator|*
name|symb
operator|=
name|getSymbol
argument_list|(
name|Symb
argument_list|)
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|symb
argument_list|)
block|;
if|if
condition|(
operator|!
name|sec
condition|)
name|Res
operator|=
name|end_sections
argument_list|()
expr_stmt|;
else|else
block|{
name|DataRefImpl
name|Sec
decl_stmt|;
name|Sec
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|sec
operator|)
expr_stmt|;
name|Res
operator|=
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|Sec
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionNext
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|SectionRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|uint8_t
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|sec
operator|+=
name|Header
operator|->
name|e_shentsize
block|;
name|Sec
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|sec
operator|)
block|;
name|Result
operator|=
name|SectionRef
argument_list|(
name|Sec
argument_list|,
name|this
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionName
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|StringRef
argument_list|(
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|sec
operator|->
name|sh_name
argument_list|)
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionAddress
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_addr
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionSize
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_size
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionContents
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
specifier|const
name|char
operator|*
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sec
operator|->
name|sh_offset
block|;
name|Result
operator|=
name|StringRef
argument_list|(
name|start
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|)
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionAlignment
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|Result
operator|=
name|sec
operator|->
name|sh_addralign
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionText
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_EXECINSTR
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionData
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_PROGBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionBSS
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
operator|(
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|&&
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionRequiredForExecution
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHF_ALLOC
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionVirtual
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_NOBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|isSectionZeroInit
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
comment|// For ELF, all zero-init sections are virtual (that is, they occupy no space
comment|//   in the object image) and vice versa.
if|if
condition|(
name|sec
operator|->
name|sh_flags
operator|&
name|ELF
operator|::
name|SHT_NOBITS
condition|)
name|Result
operator|=
name|true
expr_stmt|;
else|else
name|Result
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|sectionContainsSymbol
argument_list|(
argument|DataRefImpl Sec
argument_list|,
argument|DataRefImpl Symb
argument_list|,
argument|bool&Result
argument_list|)
specifier|const
block|{
comment|// FIXME: Unimplemented.
name|Result
operator|=
name|false
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionRelBegin
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|typename
name|RelocMap_t
operator|::
name|const_iterator
name|ittr
operator|=
name|SectionRelocMap
operator|.
name|find
argument_list|(
name|sec
argument_list|)
block|;
if|if
condition|(
name|sec
operator|!=
literal|0
operator|&&
name|ittr
operator|!=
name|SectionRelocMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|RelData
operator|.
name|w
operator|.
name|a
operator|=
name|getSection
argument_list|(
name|ittr
operator|->
name|second
index|[
literal|0
index|]
argument_list|)
operator|->
name|sh_info
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|b
operator|=
name|ittr
operator|->
name|second
index|[
literal|0
index|]
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|c
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|relocation_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSectionRelEnd
argument_list|(
argument|DataRefImpl Sec
argument_list|)
specifier|const
block|{
name|DataRefImpl
name|RelData
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|Sec
operator|.
name|p
operator|)
block|;
name|typename
name|RelocMap_t
operator|::
name|const_iterator
name|ittr
operator|=
name|SectionRelocMap
operator|.
name|find
argument_list|(
name|sec
argument_list|)
block|;
if|if
condition|(
name|sec
operator|!=
literal|0
operator|&&
name|ittr
operator|!=
name|SectionRelocMap
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Get the index of the last relocation section for this section.
name|std
operator|::
name|size_t
name|relocsecindex
operator|=
name|ittr
operator|->
name|second
index|[
name|ittr
operator|->
name|second
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
expr_stmt|;
specifier|const
name|Elf_Shdr
modifier|*
name|relocsec
init|=
name|getSection
argument_list|(
name|relocsecindex
argument_list|)
decl_stmt|;
name|RelData
operator|.
name|w
operator|.
name|a
operator|=
name|relocsec
operator|->
name|sh_info
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|b
operator|=
name|relocsecindex
expr_stmt|;
name|RelData
operator|.
name|w
operator|.
name|c
operator|=
name|relocsec
operator|->
name|sh_size
operator|/
name|relocsec
operator|->
name|sh_entsize
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|relocation_iterator
argument_list|(
name|RelocationRef
argument_list|(
name|RelData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Relocations
end_comment

begin_expr_stmt
unit|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationNext
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|RelocationRef&Result
argument_list|)
specifier|const
block|{
operator|++
name|Rel
operator|.
name|w
operator|.
name|c
block|;
specifier|const
name|Elf_Shdr
operator|*
name|relocsec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
if|if
condition|(
name|Rel
operator|.
name|w
operator|.
name|c
operator|>=
operator|(
name|relocsec
operator|->
name|sh_size
operator|/
name|relocsec
operator|->
name|sh_entsize
operator|)
condition|)
block|{
comment|// We have reached the end of the relocations for this section. See if there
comment|// is another relocation section.
name|typename
name|RelocMap_t
operator|::
name|mapped_type
name|relocseclist
operator|=
name|SectionRelocMap
operator|.
name|lookup
argument_list|(
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do a binary search for the current reloc section index (which must be
comment|// present). Then get the next one.
name|typename
name|RelocMap_t
operator|::
name|mapped_type
operator|::
name|const_iterator
name|loc
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|relocseclist
operator|.
name|begin
argument_list|()
argument_list|,
name|relocseclist
operator|.
name|end
argument_list|()
argument_list|,
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
expr_stmt|;
operator|++
name|loc
expr_stmt|;
comment|// If there is no next one, don't do anything. The ++Rel.w.c above sets Rel
comment|// to the end iterator.
if|if
condition|(
name|loc
operator|!=
name|relocseclist
operator|.
name|end
argument_list|()
condition|)
block|{
name|Rel
operator|.
name|w
operator|.
name|b
operator|=
operator|*
name|loc
expr_stmt|;
name|Rel
operator|.
name|w
operator|.
name|a
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   Result
operator|=
name|RelocationRef
argument_list|(
name|Rel
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationSymbol
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SymbolRef&Result
argument_list|)
specifier|const
block|{
name|uint32_t
name|symbolIdx
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|symbolIdx
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|()
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|symbolIdx
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|()
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   DataRefImpl
name|SymbolData
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IndexMap_t
operator|::
name|const_iterator
name|it
operator|=
name|SymbolTableSectionsIndexMap
operator|.
name|find
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|it
operator|==
name|SymbolTableSectionsIndexMap
operator|.
name|end
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Relocation symbol table not found!"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|symbolIdx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|it
operator|->
name|second
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Result
operator|=
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationAddress
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|uint64_t
name|offset
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|offset
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|offset
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}    Result
operator|=
name|offset
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationOffset
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
name|uint64_t
name|offset
block|;
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|offset
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|offset
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_offset
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}    Result
operator|=
name|offset
operator|-
name|sec
operator|->
name|sh_addr
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationType
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|uint64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   return
name|object_error
operator|::
name|success
expr_stmt|;
end_expr_stmt

begin_define
unit|}
define|#
directive|define
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
parameter_list|(
name|enum
define|) \   case ELF::enum: res = #enum; break;
end_define

begin_expr_stmt
unit|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationTypeName
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
name|uint8_t
name|type
block|;
name|StringRef
name|res
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
end_block

begin_expr_stmt
unit|}   switch
operator|(
name|Header
operator|->
name|e_machine
operator|)
block|{
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
switch|switch
condition|(
name|type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPCREL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_32S
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPMOD64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TPOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSGD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSLD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_DTPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTTPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_PC64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTOFF64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_SIZE32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_SIZE64
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_GOTPC32_TLSDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSDESC_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_X86_64_TLSDESC
argument_list|)
expr_stmt|;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|ELF
operator|::
name|EM_386
case|:
end_case

begin_switch
switch|switch
condition|(
name|type
condition|)
block|{
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_NONE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PLT32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_COPY
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GLOB_DAT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_JUMP_SLOT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOTOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_GOTPC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_32PLT
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_TPOFF
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_IE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GOTIE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LE
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC16
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_PC8
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_PUSH
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GD_POP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_PUSH
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDM_POP
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LDO_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_IE_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_LE_32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DTPMOD32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DTPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_TPOFF32
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_GOTDESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DESC_CALL
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_TLS_DESC
argument_list|)
expr_stmt|;
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
argument_list|(
name|R_386_IRELATIVE
argument_list|)
expr_stmt|;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
end_switch

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|res
operator|=
literal|"Unknown"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   Result
operator|.
name|append
argument_list|(
name|res
operator|.
name|begin
argument_list|()
argument_list|,
name|res
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_undef
unit|}
undef|#
directive|undef
name|LLVM_ELF_SWITCH_RELOC_TYPE_NAME
end_undef

begin_expr_stmt
unit|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationAdditionalInfo
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|int64_t&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
name|report_fatal_error
argument_list|(
literal|"Invalid section type in Rel!"
argument_list|)
expr_stmt|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|Result
operator|=
literal|0
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|Result
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_block

begin_expr_stmt
unit|} }
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRelocationValueString
argument_list|(
argument|DataRefImpl Rel
argument_list|,
argument|SmallVectorImpl<char>&Result
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Rel
operator|.
name|w
operator|.
name|b
argument_list|)
block|;
name|uint8_t
name|type
block|;
name|StringRef
name|res
block|;
name|int64_t
name|addend
operator|=
literal|0
block|;
name|uint16_t
name|symbol_index
operator|=
literal|0
block|;
switch|switch
condition|(
name|sec
operator|->
name|sh_type
condition|)
block|{
default|default :
return|return
name|object_error
operator|::
name|parse_failed
return|;
case|case
name|ELF
operator|::
name|SHT_REL
case|:
block|{
name|type
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
name|symbol_index
operator|=
name|getRel
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|()
expr_stmt|;
comment|// TODO: Read implicit addend from section data.
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
end_case

begin_block
block|{
name|type
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getType
argument_list|()
expr_stmt|;
name|symbol_index
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|getSymbol
argument_list|()
expr_stmt|;
name|addend
operator|=
name|getRela
argument_list|(
name|Rel
argument_list|)
operator|->
name|r_addend
expr_stmt|;
break|break;
block|}
end_block

begin_decl_stmt
unit|}   const
name|Elf_Sym
modifier|*
name|symb
init|=
name|getEntry
operator|<
name|Elf_Sym
operator|>
operator|(
name|sec
operator|->
name|sh_link
expr|,
name|symbol_index
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|symname
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|getSection
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
argument_list|,
name|symb
argument_list|,
name|symname
argument_list|)
condition|)
return|return
name|ec
return|;
end_if

begin_switch
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ELF
operator|::
name|R_X86_64_32S
case|:
name|res
operator|=
name|symname
expr_stmt|;
break|break;
case|case
name|ELF
operator|::
name|R_X86_64_PC32
case|:
block|{
name|std
operator|::
name|string
name|fmtbuf
expr_stmt|;
name|raw_string_ostream
name|fmt
parameter_list|(
name|fmtbuf
parameter_list|)
function_decl|;
name|fmt
operator|<<
name|symname
operator|<<
operator|(
name|addend
operator|<
literal|0
condition|?
literal|""
else|:
literal|"+"
operator|)
operator|<<
name|addend
operator|<<
literal|"-P"
expr_stmt|;
name|fmt
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Result
operator|.
name|append
argument_list|(
name|fmtbuf
operator|.
name|begin
argument_list|()
argument_list|,
name|fmtbuf
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
break|break;
default|default:
name|res
operator|=
literal|"Unknown"
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|Result
operator|.
name|empty
argument_list|()
condition|)
name|Result
operator|.
name|append
argument_list|(
name|res
operator|.
name|begin
argument_list|()
argument_list|,
name|res
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_comment
unit|}
comment|// Verify that the last byte in the string table in a null.
end_comment

begin_expr_stmt
unit|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|void
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|VerifyStrTab
argument_list|(
argument|const Elf_Shdr *sh
argument_list|)
specifier|const
block|{
specifier|const
name|char
operator|*
name|strtab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|sh
operator|->
name|sh_offset
block|;
if|if
condition|(
name|strtab
index|[
name|sh
operator|->
name|sh_size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"String table must end with a null terminator!"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|ELFObjectFile
argument_list|(
name|MemoryBuffer
operator|*
name|Object
argument_list|,
name|error_code
operator|&
name|ec
argument_list|)
operator|:
name|ObjectFile
argument_list|(
name|getELFType
argument_list|(
name|target_endianness
operator|==
name|support
operator|::
name|little
argument_list|,
name|is64Bits
argument_list|)
argument_list|,
name|Object
argument_list|,
name|ec
argument_list|)
operator|,
name|isDyldELFObject
argument_list|(
name|false
argument_list|)
operator|,
name|SectionHeaderTable
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_shstrtab_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_strtab_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_dynstr_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_dynamic_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_r_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dot_gnu_version_d_sec
argument_list|(
literal|0
argument_list|)
operator|,
name|dt_soname
argument_list|(
literal|0
argument_list|)
block|{
specifier|const
name|uint64_t
name|FileSize
operator|=
name|Data
operator|->
name|getBufferSize
argument_list|()
block|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"File too short!"
argument_list|)
expr_stmt|;
name|Header
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Ehdr
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Header
operator|->
name|e_shoff
operator|==
literal|0
condition|)
return|return;
end_if

begin_decl_stmt
specifier|const
name|uint64_t
name|SectionTableOffset
init|=
name|Header
operator|->
name|e_shoff
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SectionTableOffset
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Section header table goes past end of file!"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// The getNumSections() call below depends on SectionHeaderTable being set.
end_comment

begin_expr_stmt
name|SectionHeaderTable
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|SectionTableOffset
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|uint64_t
name|SectionTableSize
init|=
name|getNumSections
argument_list|()
operator|*
name|Header
operator|->
name|e_shentsize
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SectionTableOffset
operator|+
name|SectionTableSize
operator|>
name|FileSize
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Section table goes past end of file!"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// To find the symbol tables we walk the section table to find SHT_SYMTAB.
end_comment

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|SymbolTableSectionHeaderIndex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|sh
init|=
name|SectionHeaderTable
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Reserve SymbolTableSections[0] for .dynsym
end_comment

begin_expr_stmt
name|SymbolTableSections
operator|.
name|push_back
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumSections
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|sh
operator|->
name|sh_type
condition|)
block|{
case|case
name|ELF
operator|::
name|SHT_SYMTAB_SHNDX
case|:
block|{
if|if
condition|(
name|SymbolTableSectionHeaderIndex
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .symtab_shndx!"
argument_list|)
expr_stmt|;
name|SymbolTableSectionHeaderIndex
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_SYMTAB
case|:
block|{
name|SymbolTableSectionsIndexMap
index|[
name|i
index|]
operator|=
name|SymbolTableSections
operator|.
name|size
argument_list|()
expr_stmt|;
name|SymbolTableSections
operator|.
name|push_back
argument_list|(
name|sh
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_DYNSYM
case|:
block|{
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .dynsym!"
argument_list|)
expr_stmt|;
name|SymbolTableSectionsIndexMap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|SymbolTableSections
index|[
literal|0
index|]
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_REL
case|:
case|case
name|ELF
operator|::
name|SHT_RELA
case|:
block|{
name|SectionRelocMap
index|[
name|getSection
argument_list|(
name|sh
operator|->
name|sh_info
argument_list|)
index|]
operator|.
name|push_back
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_DYNAMIC
case|:
block|{
if|if
condition|(
name|dot_dynamic_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .dynamic!"
argument_list|)
expr_stmt|;
name|dot_dynamic_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_versym
case|:
block|{
if|if
condition|(
name|dot_gnu_version_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_verdef
case|:
block|{
if|if
condition|(
name|dot_gnu_version_d_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version_d section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_d_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
case|case
name|ELF
operator|::
name|SHT_GNU_verneed
case|:
block|{
if|if
condition|(
name|dot_gnu_version_r_sec
operator|!=
name|NULL
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"More than one .gnu.version_r section!"
argument_list|)
expr_stmt|;
name|dot_gnu_version_r_sec
operator|=
name|sh
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|sh
expr_stmt|;
block|}
end_for

begin_comment
comment|// Sort section relocation lists by index.
end_comment

begin_for
for|for
control|(
name|typename
name|RelocMap_t
operator|::
name|iterator
name|i
operator|=
name|SectionRelocMap
operator|.
name|begin
argument_list|()
operator|,
name|e
operator|=
name|SectionRelocMap
operator|.
name|end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|i
operator|->
name|second
operator|.
name|begin
argument_list|()
argument_list|,
name|i
operator|->
name|second
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Get string table sections.
end_comment

begin_expr_stmt
name|dot_shstrtab_sec
operator|=
name|getSection
argument_list|(
name|getStringTableIndex
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dot_shstrtab_sec
condition|)
block|{
comment|// Verify that the last byte in the string table in a null.
name|VerifyStrTab
argument_list|(
name|dot_shstrtab_sec
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Merge this into the above loop.
end_comment

begin_for
for|for
control|(
specifier|const
name|char
modifier|*
name|i
init|=
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|SectionHeaderTable
operator|)
init|,
modifier|*
name|e
init|=
name|i
operator|+
name|getNumSections
argument_list|()
operator|*
name|Header
operator|->
name|e_shentsize
init|;
name|i
operator|!=
name|e
condition|;
name|i
operator|+=
name|Header
operator|->
name|e_shentsize
control|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|sh
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|i
operator|)
decl_stmt|;
if|if
condition|(
name|sh
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_STRTAB
condition|)
block|{
name|StringRef
name|SectionName
argument_list|(
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|sh
operator|->
name|sh_name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SectionName
operator|==
literal|".strtab"
condition|)
block|{
if|if
condition|(
name|dot_strtab_sec
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Already found section named .strtab!"
argument_list|)
expr_stmt|;
name|dot_strtab_sec
operator|=
name|sh
expr_stmt|;
name|VerifyStrTab
argument_list|(
name|dot_strtab_sec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SectionName
operator|==
literal|".dynstr"
condition|)
block|{
if|if
condition|(
name|dot_dynstr_sec
operator|!=
literal|0
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Already found section named .dynstr!"
argument_list|)
expr_stmt|;
name|dot_dynstr_sec
operator|=
name|sh
expr_stmt|;
name|VerifyStrTab
argument_list|(
name|dot_dynstr_sec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_for

begin_comment
comment|// Build symbol name side-mapping if there is one.
end_comment

begin_if
if|if
condition|(
name|SymbolTableSectionHeaderIndex
condition|)
block|{
specifier|const
name|Elf_Word
modifier|*
name|ShndxTable
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Word
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|SymbolTableSectionHeaderIndex
operator|->
name|sh_offset
operator|)
decl_stmt|;
name|error_code
name|ec
decl_stmt|;
for|for
control|(
name|symbol_iterator
name|si
init|=
name|begin_symbols
argument_list|()
init|,
name|se
init|=
name|end_symbols
argument_list|()
init|;
name|si
operator|!=
name|se
condition|;
name|si
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
control|)
block|{
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"Fewer extended symbol table entries than symbols!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ShndxTable
operator|!=
name|ELF
operator|::
name|SHN_UNDEF
condition|)
name|ExtendedSymbolTable
index|[
name|getSymbol
argument_list|(
name|si
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|)
index|]
operator|=
operator|*
name|ShndxTable
expr_stmt|;
operator|++
name|ShndxTable
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|begin_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
if|if
condition|(
name|SymbolTableSections
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
literal|1
expr_stmt|;
comment|// The 0th table is .dynsym
block|}
end_else

begin_return
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|end_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|begin_dynamic_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
if|if
condition|(
name|SymbolTableSections
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
literal|1
expr_stmt|;
comment|// The 0th symbol in ELF is fake.
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
literal|0
expr_stmt|;
comment|// The 0th table is .dynsym
block|}
end_else

begin_return
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|symbol_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|end_dynamic_symbols
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|SymbolData
block|;
name|SymbolData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
name|SymbolData
operator|.
name|d
operator|.
name|b
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
return|return
name|symbol_iterator
argument_list|(
name|SymbolRef
argument_list|(
name|SymbolData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|begin_sections
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|ret
block|;
name|ret
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_shoff
operator|)
block|;
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|ret
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|section_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|end_sections
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|ret
block|;
name|ret
operator|.
name|p
operator|=
name|reinterpret_cast
operator|<
name|intptr_t
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Header
operator|->
name|e_shoff
operator|+
operator|(
name|Header
operator|->
name|e_shentsize
operator|*
name|getNumSections
argument_list|()
operator|)
operator|)
block|;
return|return
name|section_iterator
argument_list|(
name|SectionRef
argument_list|(
name|ret
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|dyn_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|begin_dynamic_table
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|DynData
block|;
if|if
condition|(
name|dot_dynamic_sec
operator|==
name|NULL
operator|||
name|dot_dynamic_sec
operator|->
name|sh_size
operator|==
literal|0
condition|)
block|{
name|DynData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|DynData
operator|.
name|d
operator|.
name|a
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_return
return|return
name|dyn_iterator
argument_list|(
name|DynRef
argument_list|(
name|DynData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|dyn_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|end_dynamic_table
argument_list|()
specifier|const
block|{
name|DataRefImpl
name|DynData
block|;
name|DynData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
block|;
return|return
name|dyn_iterator
argument_list|(
name|DynRef
argument_list|(
name|DynData
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getDynNext
argument_list|(
argument|DataRefImpl DynData
argument_list|,
argument|DynRef&Result
argument_list|)
specifier|const
block|{
operator|++
name|DynData
operator|.
name|d
operator|.
name|a
block|;
comment|// Check to see if we are at the end of .dynamic
if|if
condition|(
name|DynData
operator|.
name|d
operator|.
name|a
operator|>=
name|dot_dynamic_sec
operator|->
name|getEntityCount
argument_list|()
condition|)
block|{
comment|// We are at the end. Return the terminator.
name|DynData
operator|.
name|d
operator|.
name|a
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
expr_stmt|;
block|}
name|Result
operator|=
name|DynRef
argument_list|(
name|DynData
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getLoadName
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dt_soname
condition|)
block|{
comment|// Find the DT_SONAME entry
name|dyn_iterator
name|it
init|=
name|begin_dynamic_table
argument_list|()
decl_stmt|;
name|dyn_iterator
name|ie
init|=
name|end_dynamic_table
argument_list|()
decl_stmt|;
name|error_code
name|ec
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ie
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|getTag
argument_list|()
operator|==
name|ELF
operator|::
name|DT_SONAME
condition|)
break|break;
name|it
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"dynamic table iteration failed"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|it
operator|!=
name|ie
condition|)
block|{
if|if
condition|(
name|dot_dynstr_sec
operator|==
name|NULL
condition|)
name|report_fatal_error
argument_list|(
literal|"Dynamic string table is missing"
argument_list|)
expr_stmt|;
name|dt_soname
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|it
operator|->
name|getVal
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_soname
operator|=
literal|""
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}   return
name|dt_soname
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|begin_libraries_needed
argument_list|()
specifier|const
block|{
comment|// Find the first DT_NEEDED entry
name|dyn_iterator
name|i
operator|=
name|begin_dynamic_table
argument_list|()
block|;
name|dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
name|error_code
name|ec
block|;
while|while
condition|(
name|i
operator|!=
name|e
condition|)
block|{
if|if
condition|(
name|i
operator|->
name|getTag
argument_list|()
operator|==
name|ELF
operator|::
name|DT_NEEDED
condition|)
break|break;
name|i
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"dynamic table iteration failed"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Use the same DataRefImpl format as DynRef.
end_comment

begin_return
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|i
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getLibraryNext
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|LibraryRef&Result
argument_list|)
specifier|const
block|{
comment|// Use the same DataRefImpl format as DynRef.
name|dyn_iterator
name|i
operator|=
name|dyn_iterator
argument_list|(
name|DynRef
argument_list|(
name|Data
argument_list|,
name|this
argument_list|)
argument_list|)
block|;
name|dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
comment|// Skip the current dynamic table entry.
name|error_code
name|ec
block|;
if|if
condition|(
name|i
operator|!=
name|e
condition|)
block|{
name|i
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
expr_stmt|;
comment|// TODO: proper error handling
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"dynamic table iteration failed"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Find the next DT_NEEDED entry.
end_comment

begin_while
while|while
condition|(
name|i
operator|!=
name|e
condition|)
block|{
if|if
condition|(
name|i
operator|->
name|getTag
argument_list|()
operator|==
name|ELF
operator|::
name|DT_NEEDED
condition|)
break|break;
name|i
operator|.
name|increment
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
condition|)
name|report_fatal_error
argument_list|(
literal|"dynamic table iteration failed"
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|Result
operator|=
name|LibraryRef
argument_list|(
name|i
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getLibraryPath
argument_list|(
argument|DataRefImpl Data
argument_list|,
argument|StringRef&Res
argument_list|)
specifier|const
block|{
name|dyn_iterator
name|i
operator|=
name|dyn_iterator
argument_list|(
name|DynRef
argument_list|(
name|Data
argument_list|,
name|this
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|i
operator|==
name|end_dynamic_table
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"getLibraryPath() called on iterator end"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|->
name|getTag
argument_list|()
operator|!=
name|ELF
operator|::
name|DT_NEEDED
condition|)
name|report_fatal_error
argument_list|(
literal|"Invalid library_iterator"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// This uses .dynstr to lookup the name of the DT_NEEDED entry.
end_comment

begin_comment
comment|// THis works as long as DT_STRTAB == .dynstr. This is true most of
end_comment

begin_comment
comment|// the time, but the specification allows exceptions.
end_comment

begin_comment
comment|// TODO: This should really use DT_STRTAB instead. Doing this requires
end_comment

begin_comment
comment|// reading the program headers.
end_comment

begin_if
if|if
condition|(
name|dot_dynstr_sec
operator|==
name|NULL
condition|)
name|report_fatal_error
argument_list|(
literal|"Dynamic string table is missing"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|Res
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|i
operator|->
name|getVal
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|library_iterator
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|end_libraries_needed
argument_list|()
specifier|const
block|{
name|dyn_iterator
name|e
operator|=
name|end_dynamic_table
argument_list|()
block|;
comment|// Use the same DataRefImpl format as DynRef.
return|return
name|library_iterator
argument_list|(
name|LibraryRef
argument_list|(
name|e
operator|->
name|getRawDataRefImpl
argument_list|()
argument_list|,
name|this
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|uint8_t
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getBytesInAddress
argument_list|()
specifier|const
block|{
return|return
name|is64Bits
operator|?
literal|8
operator|:
literal|4
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|StringRef
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getFileFormatName
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Header
operator|->
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELF
operator|::
name|ELFCLASS32
case|:
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF32-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF32-x86-64"
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
literal|"ELF32-arm"
return|;
default|default:
return|return
literal|"ELF32-unknown"
return|;
block|}
end_expr_stmt

begin_case
case|case
name|ELF
operator|::
name|ELFCLASS64
case|:
end_case

begin_switch
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
literal|"ELF64-i386"
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
literal|"ELF64-x86-64"
return|;
default|default:
return|return
literal|"ELF64-unknown"
return|;
block|}
end_switch

begin_default
default|default:
end_default

begin_comment
comment|// FIXME: Proper error handling.
end_comment

begin_expr_stmt
name|report_fatal_error
argument_list|(
literal|"Invalid ELFCLASS!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|unsigned
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getArch
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Header
operator|->
name|e_machine
condition|)
block|{
case|case
name|ELF
operator|::
name|EM_386
case|:
return|return
name|Triple
operator|::
name|x86
return|;
case|case
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
name|Triple
operator|::
name|x86_64
return|;
case|case
name|ELF
operator|::
name|EM_ARM
case|:
return|return
name|Triple
operator|::
name|arm
return|;
default|default:
return|return
name|Triple
operator|::
name|UnknownArch
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getNumSections
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Header
operator|&&
literal|"Header not initialized!"
argument_list|)
block|;
if|if
condition|(
name|Header
operator|->
name|e_shnum
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
block|{
name|assert
argument_list|(
name|SectionHeaderTable
operator|&&
literal|"SectionHeaderTable not initialized!"
argument_list|)
expr_stmt|;
return|return
name|SectionHeaderTable
operator|->
name|sh_size
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Header
operator|->
name|e_shnum
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|uint64_t
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getStringTableIndex
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Header
operator|->
name|e_shnum
operator|==
name|ELF
operator|::
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
name|Header
operator|->
name|e_shstrndx
operator|==
name|ELF
operator|::
name|SHN_HIRESERVE
condition|)
return|return
name|SectionHeaderTable
operator|->
name|sh_link
return|;
if|if
condition|(
name|Header
operator|->
name|e_shstrndx
operator|>=
name|getNumSections
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_return
return|return
name|Header
operator|->
name|e_shstrndx
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
specifier|const
name|T
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getEntry
argument_list|(
argument|uint16_t Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|T
operator|>
operator|(
name|getSection
argument_list|(
name|Section
argument_list|)
operator|,
name|Entry
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
specifier|const
name|T
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getEntry
argument_list|(
argument|const Elf_Shdr * Section
argument_list|,
argument|uint32_t Entry
argument_list|)
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|base
argument_list|()
operator|+
name|Section
operator|->
name|sh_offset
operator|+
operator|(
name|Entry
operator|*
name|Section
operator|->
name|sh_entsize
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Sym
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbol
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Sym
operator|>
operator|(
name|SymbolTableSections
index|[
name|Symb
operator|.
name|d
operator|.
name|b
index|]
operator|,
name|Symb
operator|.
name|d
operator|.
name|a
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Dyn
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getDyn
argument_list|(
argument|DataRefImpl DynData
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Dyn
operator|>
operator|(
name|dot_dynamic_sec
operator|,
name|DynData
operator|.
name|d
operator|.
name|a
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Rel
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRel
argument_list|(
argument|DataRefImpl Rel
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Rel
operator|>
operator|(
name|Rel
operator|.
name|w
operator|.
name|b
operator|,
name|Rel
operator|.
name|w
operator|.
name|c
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Rela
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRela
argument_list|(
argument|DataRefImpl Rela
argument_list|)
specifier|const
block|{
return|return
name|getEntry
operator|<
name|Elf_Rela
operator|>
operator|(
name|Rela
operator|.
name|w
operator|.
name|b
operator|,
name|Rela
operator|.
name|w
operator|.
name|c
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSection
argument_list|(
argument|DataRefImpl Symb
argument_list|)
specifier|const
block|{
specifier|const
name|Elf_Shdr
operator|*
name|sec
operator|=
name|getSection
argument_list|(
name|Symb
operator|.
name|d
operator|.
name|b
argument_list|)
block|;
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_SYMTAB
operator|||
name|sec
operator|->
name|sh_type
operator|!=
name|ELF
operator|::
name|SHT_DYNSYM
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Invalid symbol table section!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|sec
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|typename
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|Elf_Shdr
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSection
argument_list|(
argument|uint32_t index
argument_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|SectionHeaderTable
operator|||
name|index
operator|>=
name|getNumSections
argument_list|()
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Invalid section index!"
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|SectionHeaderTable
operator|)
operator|+
operator|(
name|index
operator|*
name|Header
operator|->
name|e_shentsize
operator|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|char
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getString
argument_list|(
argument|uint32_t section
argument_list|,
argument|ELF::Elf32_Word offset
argument_list|)
specifier|const
block|{
return|return
name|getString
argument_list|(
name|getSection
argument_list|(
name|section
argument_list|)
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|const
name|char
operator|*
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getString
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|ELF::Elf32_Word offset
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|section
operator|&&
name|section
operator|->
name|sh_type
operator|==
name|ELF
operator|::
name|SHT_STRTAB
operator|&&
literal|"Invalid section!"
argument_list|)
block|;
if|if
condition|(
name|offset
operator|>=
name|section
operator|->
name|sh_size
condition|)
comment|// FIXME: Proper error handling.
name|report_fatal_error
argument_list|(
literal|"Symbol name offset outside of string table!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|section
operator|->
name|sh_offset
operator|+
name|offset
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolName
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|const Elf_Sym *symb
argument_list|,
argument|StringRef&Result
argument_list|)
specifier|const
block|{
if|if
condition|(
name|symb
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|section
init|=
name|getSection
argument_list|(
name|symb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
name|Result
operator|=
literal|""
expr_stmt|;
else|else
name|Result
operator|=
name|getString
argument_list|(
name|dot_shstrtab_sec
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|section
operator|==
name|SymbolTableSections
index|[
literal|0
index|]
condition|)
block|{
comment|// Symbol is in .dynsym, use .dynstr string table
name|Result
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|symb
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use the default symbol table name section.
name|Result
operator|=
name|getString
argument_list|(
name|dot_strtab_sec
argument_list|,
name|symb
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
name|error_code
name|ELFObjectFile
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getSymbolVersion
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|const Elf_Sym *symb
argument_list|,
argument|StringRef&Version
argument_list|,
argument|bool&IsDefault
argument_list|)
specifier|const
block|{
comment|// Handle non-dynamic symbols.
if|if
condition|(
name|section
operator|!=
name|SymbolTableSections
index|[
literal|0
index|]
condition|)
block|{
comment|// Non-dynamic symbols can have versions in their names
comment|// A name of the form 'foo@V1' indicates version 'V1', non-default.
comment|// A name of the form 'foo@@V2' indicates version 'V2', default version.
name|StringRef
name|Name
decl_stmt|;
name|error_code
name|ec
init|=
name|getSymbolName
argument_list|(
name|section
argument_list|,
name|symb
argument_list|,
name|Name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ec
operator|!=
name|object_error
operator|::
name|success
condition|)
return|return
name|ec
return|;
name|size_t
name|atpos
init|=
name|Name
operator|.
name|find
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|atpos
operator|==
name|StringRef
operator|::
name|npos
condition|)
block|{
name|Version
operator|=
literal|""
expr_stmt|;
name|IsDefault
operator|=
name|false
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
operator|++
name|atpos
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|atpos
operator|<
name|Name
operator|.
name|size
argument_list|()
operator|&&
name|Name
index|[
name|atpos
index|]
operator|==
literal|'@'
condition|)
block|{
name|IsDefault
operator|=
name|true
expr_stmt|;
operator|++
name|atpos
expr_stmt|;
block|}
else|else
block|{
name|IsDefault
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Version
operator|=
name|Name
operator|.
name|substr
argument_list|(
name|atpos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_comment
unit|}
comment|// This is a dynamic symbol. Look in the GNU symbol version table.
end_comment

begin_expr_stmt
unit|if
operator|(
name|dot_gnu_version_sec
operator|==
name|NULL
operator|)
block|{
comment|// No version table.
name|Version
operator|=
literal|""
block|;
name|IsDefault
operator|=
name|false
block|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_expr_stmt

begin_comment
comment|// Determine the position in the symbol table of this entry.
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|sec_start
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|base
argument_list|()
operator|+
name|section
operator|->
name|sh_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|entry_index
init|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|symb
operator|-
name|sec_start
operator|)
operator|/
name|section
operator|->
name|sh_entsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Get the corresponding version index entry
end_comment

begin_decl_stmt
specifier|const
name|Elf_Versym
modifier|*
name|vs
init|=
name|getEntry
operator|<
name|Elf_Versym
operator|>
operator|(
name|dot_gnu_version_sec
expr|,
name|entry_index
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|version_index
init|=
name|vs
operator|->
name|vs_index
operator|&
name|ELF
operator|::
name|VERSYM_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Special markers for unversioned symbols.
end_comment

begin_if
if|if
condition|(
name|version_index
operator|==
name|ELF
operator|::
name|VER_NDX_LOCAL
operator|||
name|version_index
operator|==
name|ELF
operator|::
name|VER_NDX_GLOBAL
condition|)
block|{
name|Version
operator|=
literal|""
expr_stmt|;
name|IsDefault
operator|=
name|false
expr_stmt|;
return|return
name|object_error
operator|::
name|success
return|;
block|}
end_if

begin_comment
comment|// Lookup this symbol in the version table
end_comment

begin_expr_stmt
name|LoadVersionMap
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|version_index
operator|>=
name|VersionMap
operator|.
name|size
argument_list|()
operator|||
name|VersionMap
index|[
name|version_index
index|]
operator|.
name|isNull
argument_list|()
condition|)
name|report_fatal_error
argument_list|(
literal|"Symbol has version index without corresponding "
literal|"define or reference entry"
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
specifier|const
name|VersionMapEntry
modifier|&
name|entry
init|=
name|VersionMap
index|[
name|version_index
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Get the version name string
end_comment

begin_decl_stmt
name|size_t
name|name_offset
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|entry
operator|.
name|isVerdef
argument_list|()
condition|)
block|{
comment|// The first Verdaux entry holds the name.
name|name_offset
operator|=
name|entry
operator|.
name|getVerdef
argument_list|()
operator|->
name|getAux
argument_list|()
operator|->
name|vda_name
expr_stmt|;
block|}
else|else
block|{
name|name_offset
operator|=
name|entry
operator|.
name|getVernaux
argument_list|()
operator|->
name|vna_name
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|Version
operator|=
name|getString
argument_list|(
name|dot_dynstr_sec
argument_list|,
name|name_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set IsDefault
end_comment

begin_if
if|if
condition|(
name|entry
operator|.
name|isVerdef
argument_list|()
condition|)
block|{
name|IsDefault
operator|=
operator|!
operator|(
name|vs
operator|->
name|vs_index
operator|&
name|ELF
operator|::
name|VERSYM_HIDDEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|IsDefault
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_return
return|return
name|object_error
operator|::
name|success
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|DynRefImpl
argument_list|(
argument|DataRefImpl DynP
argument_list|,
argument|const OwningType *Owner
argument_list|)
operator|:
name|DynPimpl
argument_list|(
name|DynP
argument_list|)
operator|,
name|OwningObject
argument_list|(
argument|Owner
argument_list|)
block|{}
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|bool
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|operator
operator|==
operator|(
specifier|const
name|DynRefImpl
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|DynPimpl
operator|==
name|Other
operator|.
name|DynPimpl
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|bool
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|operator
operator|<
operator|(
specifier|const
name|DynRefImpl
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|DynPimpl
operator|<
name|Other
operator|.
name|DynPimpl
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|error_code
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getNext
argument_list|(
argument|DynRefImpl&Result
argument_list|)
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getDynNext
argument_list|(
name|DynPimpl
argument_list|,
name|Result
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|int64_t
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getDyn
argument_list|(
name|DynPimpl
argument_list|)
operator|->
name|d_tag
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|uint64_t
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getVal
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getDyn
argument_list|(
name|DynPimpl
argument_list|)
operator|->
name|d_un
operator|.
name|d_val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|uint64_t
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getPtr
argument_list|()
specifier|const
block|{
return|return
name|OwningObject
operator|->
name|getDyn
argument_list|(
name|DynPimpl
argument_list|)
operator|->
name|d_un
operator|.
name|d_ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|target_endianness
operator|,
name|bool
name|is64Bits
operator|>
specifier|inline
name|DataRefImpl
name|DynRefImpl
operator|<
name|target_endianness
operator|,
name|is64Bits
operator|>
operator|::
name|getRawDataRefImpl
argument_list|()
specifier|const
block|{
return|return
name|DynPimpl
return|;
block|}
end_expr_stmt

begin_comment
comment|/// This is a generic interface for retrieving GNU symbol version
end_comment

begin_comment
comment|/// information from an ELFObjectFile.
end_comment

begin_function
specifier|static
specifier|inline
name|error_code
name|GetELFSymbolVersion
parameter_list|(
specifier|const
name|ObjectFile
modifier|*
name|Obj
parameter_list|,
specifier|const
name|SymbolRef
modifier|&
name|Sym
parameter_list|,
name|StringRef
modifier|&
name|Version
parameter_list|,
name|bool
modifier|&
name|IsDefault
parameter_list|)
block|{
comment|// Little-endian 32-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|support
operator|::
name|little
operator|,
name|false
operator|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|support
operator|::
name|little
operator|,
name|false
operator|>
expr|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 32-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|support
operator|::
name|big
operator|,
name|false
operator|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|support
operator|::
name|big
operator|,
name|false
operator|>
expr|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Little-endian 64-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|support
operator|::
name|little
operator|,
name|true
operator|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|support
operator|::
name|little
operator|,
name|true
operator|>
expr|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
comment|// Big-endian 64-bit
if|if
condition|(
specifier|const
name|ELFObjectFile
operator|<
name|support
operator|::
name|big
operator|,
name|true
operator|>
operator|*
name|ELFObj
operator|=
name|dyn_cast
operator|<
name|ELFObjectFile
operator|<
name|support
operator|::
name|big
operator|,
name|true
operator|>
expr|>
operator|(
name|Obj
operator|)
condition|)
return|return
name|ELFObj
operator|->
name|getSymbolVersion
argument_list|(
name|Sym
argument_list|,
name|Version
argument_list|,
name|IsDefault
argument_list|)
return|;
name|llvm_unreachable
argument_list|(
literal|"Object passed to GetELFSymbolVersion() is not ELF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

