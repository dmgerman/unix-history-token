begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ELFTypes.h - Endian specific types for ELF ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_OBJECT_ELFTYPES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_OBJECT_ELFTYPES_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/BinaryFormat/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/Error.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Error.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|object
block|{
name|using
name|support
operator|::
name|endianness
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Ehdr_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Shdr_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Sym_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Dyn_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Phdr_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|,
name|bool
name|isRela
operator|>
expr|struct
name|Elf_Rel_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdef_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdaux_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verneed_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Vernaux_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Versym_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Hash_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_GnuHash_Impl
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Chdr_Impl
expr_stmt|;
name|template
operator|<
name|endianness
name|E
operator|,
name|bool
name|Is64
operator|>
expr|struct
name|ELFType
block|{
name|private
operator|:
name|template
operator|<
name|typename
name|Ty
operator|>
name|using
name|packed
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|Ty
block|,
name|E
block|,
literal|2
operator|>
block|;
name|public
operator|:
specifier|static
specifier|const
name|endianness
name|TargetEndianness
operator|=
name|E
block|;
specifier|static
specifier|const
name|bool
name|Is64Bits
operator|=
name|Is64
block|;
name|using
name|uint
operator|=
name|typename
name|std
operator|::
name|conditional
operator|<
name|Is64
block|,
name|uint64_t
block|,
name|uint32_t
operator|>
operator|::
name|type
block|;
name|using
name|Ehdr
operator|=
name|Elf_Ehdr_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Shdr
operator|=
name|Elf_Shdr_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Sym
operator|=
name|Elf_Sym_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Dyn
operator|=
name|Elf_Dyn_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Phdr
operator|=
name|Elf_Phdr_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Rel
operator|=
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>
block|,
name|false
operator|>
block|;
name|using
name|Rela
operator|=
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>
block|,
name|true
operator|>
block|;
name|using
name|Verdef
operator|=
name|Elf_Verdef_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Verdaux
operator|=
name|Elf_Verdaux_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Verneed
operator|=
name|Elf_Verneed_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Vernaux
operator|=
name|Elf_Vernaux_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Versym
operator|=
name|Elf_Versym_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Hash
operator|=
name|Elf_Hash_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|GnuHash
operator|=
name|Elf_GnuHash_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|Chdr
operator|=
name|Elf_Chdr_Impl
operator|<
name|ELFType
operator|<
name|E
block|,
name|Is64
operator|>>
block|;
name|using
name|DynRange
operator|=
name|ArrayRef
operator|<
name|Dyn
operator|>
block|;
name|using
name|ShdrRange
operator|=
name|ArrayRef
operator|<
name|Shdr
operator|>
block|;
name|using
name|SymRange
operator|=
name|ArrayRef
operator|<
name|Sym
operator|>
block|;
name|using
name|RelRange
operator|=
name|ArrayRef
operator|<
name|Rel
operator|>
block|;
name|using
name|RelaRange
operator|=
name|ArrayRef
operator|<
name|Rela
operator|>
block|;
name|using
name|PhdrRange
operator|=
name|ArrayRef
operator|<
name|Phdr
operator|>
block|;
name|using
name|Half
operator|=
name|packed
operator|<
name|uint16_t
operator|>
block|;
name|using
name|Word
operator|=
name|packed
operator|<
name|uint32_t
operator|>
block|;
name|using
name|Sword
operator|=
name|packed
operator|<
name|int32_t
operator|>
block|;
name|using
name|Xword
operator|=
name|packed
operator|<
name|uint64_t
operator|>
block|;
name|using
name|Sxword
operator|=
name|packed
operator|<
name|int64_t
operator|>
block|;
name|using
name|Addr
operator|=
name|packed
operator|<
name|uint
operator|>
block|;
name|using
name|Off
operator|=
name|packed
operator|<
name|uint
operator|>
block|; }
expr_stmt|;
name|using
name|ELF32LE
init|=
name|ELFType
operator|<
name|support
operator|::
name|little
decl_stmt|,
name|false
decl|>
decl_stmt|;
name|using
name|ELF32BE
init|=
name|ELFType
operator|<
name|support
operator|::
name|big
decl_stmt|,
name|false
decl|>
decl_stmt|;
name|using
name|ELF64LE
init|=
name|ELFType
operator|<
name|support
operator|::
name|little
decl_stmt|,
name|true
decl|>
decl_stmt|;
name|using
name|ELF64BE
init|=
name|ELFType
operator|<
name|support
operator|::
name|big
decl_stmt|,
name|true
decl|>
decl_stmt|;
comment|// Use an alignment of 2 for the typedefs since that is the worst case for
comment|// ELF files in archives.
comment|// Templates to choose Elf_Addr and Elf_Off depending on is64Bits.
name|template
operator|<
name|endianness
name|target_endianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelperCommon
block|{
name|using
name|Elf_Half
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint16_t
block|,
name|target_endianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Word
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint32_t
block|,
name|target_endianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Sword
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int32_t
block|,
name|target_endianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Xword
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|uint64_t
block|,
name|target_endianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Sxword
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|int64_t
block|,
name|target_endianness
block|,
literal|2
operator|>
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
expr_stmt|;
comment|/// ELF 32bit types.
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|TargetEndianness
operator|>
block|{
name|using
name|value_type
operator|=
name|uint32_t
block|;
name|using
name|Elf_Addr
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
block|,
name|TargetEndianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Off
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
block|,
name|TargetEndianness
block|,
literal|2
operator|>
block|; }
expr_stmt|;
comment|/// ELF 64bit types.
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|ELFDataTypeTypedefHelper
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
operator|:
name|ELFDataTypeTypedefHelperCommon
operator|<
name|TargetEndianness
operator|>
block|{
name|using
name|value_type
operator|=
name|uint64_t
block|;
name|using
name|Elf_Addr
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
block|,
name|TargetEndianness
block|,
literal|2
operator|>
block|;
name|using
name|Elf_Off
operator|=
name|support
operator|::
name|detail
operator|::
name|packed_endian_specific_integral
operator|<
name|value_type
block|,
name|TargetEndianness
block|,
literal|2
operator|>
block|; }
expr_stmt|;
comment|// I really don't like doing this, but the alternative is copypasta.
define|#
directive|define
name|LLVM_ELF_IMPORT_TYPES_ELFT
parameter_list|(
name|ELFT
parameter_list|)
define|\
value|using Elf_Addr = typename ELFT::Addr;                                        \   using Elf_Off = typename ELFT::Off;                                          \   using Elf_Half = typename ELFT::Half;                                        \   using Elf_Word = typename ELFT::Word;                                        \   using Elf_Sword = typename ELFT::Sword;                                      \   using Elf_Xword = typename ELFT::Xword;                                      \   using Elf_Sxword = typename ELFT::Sxword;
define|#
directive|define
name|LLD_ELF_COMMA
value|,
define|#
directive|define
name|LLVM_ELF_IMPORT_TYPES
parameter_list|(
name|E
parameter_list|,
name|W
parameter_list|)
define|\
value|LLVM_ELF_IMPORT_TYPES_ELFT(ELFType<E LLD_ELF_COMMA W>)
comment|// Section header.
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Shdr_Base
expr_stmt|;
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Word
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Word
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Word
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Word
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Shdr_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|sh_name
block|;
comment|// Section name (index into string table)
name|Elf_Word
name|sh_type
block|;
comment|// Section type (SHT_*)
name|Elf_Xword
name|sh_flags
block|;
comment|// Section flags (SHF_*)
name|Elf_Addr
name|sh_addr
block|;
comment|// Address where section is to be loaded
name|Elf_Off
name|sh_offset
block|;
comment|// File offset of section data, in bytes
name|Elf_Xword
name|sh_size
block|;
comment|// Size of section, in bytes
name|Elf_Word
name|sh_link
block|;
comment|// Section type-specific header table index link
name|Elf_Word
name|sh_info
block|;
comment|// Section type-specific extra information
name|Elf_Xword
name|sh_addralign
block|;
comment|// Section address alignment
name|Elf_Xword
name|sh_entsize
block|;
comment|// Size of records contained within the section
block|}
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Shdr_Impl
operator|:
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
operator|::
name|sh_entsize
block|;
name|using
name|Elf_Shdr_Base
operator|<
name|ELFT
operator|>
operator|::
name|sh_size
block|;
comment|/// @brief Get the number of entities this section contains if it has any.
name|unsigned
name|getEntityCount
argument_list|()
specifier|const
block|{
if|if
condition|(
name|sh_entsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|sh_size
operator|/
name|sh_entsize
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Sym_Base
expr_stmt|;
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Word
name|st_size
block|;
comment|// Size of the symbol
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
block|}
expr_stmt|;
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Sym_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|st_name
block|;
comment|// Symbol name (index into string table)
name|unsigned
name|char
name|st_info
block|;
comment|// Symbol's type and binding attributes
name|unsigned
name|char
name|st_other
block|;
comment|// Must be zero; reserved
name|Elf_Half
name|st_shndx
block|;
comment|// Which section (header table index) it's defined in
name|Elf_Addr
name|st_value
block|;
comment|// Value or address associated with the symbol
name|Elf_Xword
name|st_size
block|;
comment|// Size of the symbol
block|}
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Sym_Impl
operator|:
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
operator|::
name|st_info
block|;
name|using
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
operator|::
name|st_shndx
block|;
name|using
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
operator|::
name|st_other
block|;
name|using
name|Elf_Sym_Base
operator|<
name|ELFT
operator|>
operator|::
name|st_value
block|;
comment|// These accessors and mutators correspond to the ELF32_ST_BIND,
comment|// ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:
name|unsigned
name|char
name|getBinding
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|>>
literal|4
return|;
block|}
name|unsigned
name|char
name|getType
argument_list|()
specifier|const
block|{
return|return
name|st_info
operator|&
literal|0x0f
return|;
block|}
name|uint64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|st_value
return|;
block|}
name|void
name|setBinding
argument_list|(
argument|unsigned char b
argument_list|)
block|{
name|setBindingAndType
argument_list|(
name|b
argument_list|,
name|getType
argument_list|()
argument_list|)
block|; }
name|void
name|setType
argument_list|(
argument|unsigned char t
argument_list|)
block|{
name|setBindingAndType
argument_list|(
name|getBinding
argument_list|()
argument_list|,
name|t
argument_list|)
block|; }
name|void
name|setBindingAndType
argument_list|(
argument|unsigned char b
argument_list|,
argument|unsigned char t
argument_list|)
block|{
name|st_info
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator|+
operator|(
name|t
operator|&
literal|0x0f
operator|)
block|;   }
comment|/// Access to the STV_xxx flag stored in the first two bits of st_other.
comment|/// STV_DEFAULT: 0
comment|/// STV_INTERNAL: 1
comment|/// STV_HIDDEN: 2
comment|/// STV_PROTECTED: 3
name|unsigned
name|char
name|getVisibility
argument_list|()
specifier|const
block|{
return|return
name|st_other
operator|&
literal|0x3
return|;
block|}
name|void
name|setVisibility
argument_list|(
argument|unsigned char v
argument_list|)
block|{
name|assert
argument_list|(
name|v
operator|<
literal|4
operator|&&
literal|"Invalid value for visibility"
argument_list|)
block|;
name|st_other
operator|=
operator|(
name|st_other
operator|&
operator|~
literal|0x3
operator|)
operator||
name|v
block|;   }
name|bool
name|isAbsolute
argument_list|()
specifier|const
block|{
return|return
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_ABS
return|;
block|}
name|bool
name|isCommon
argument_list|()
specifier|const
block|{
return|return
name|getType
argument_list|()
operator|==
name|ELF
operator|::
name|STT_COMMON
operator|||
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_COMMON
return|;
block|}
name|bool
name|isDefined
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isUndefined
argument_list|()
return|;
block|}
name|bool
name|isProcessorSpecific
argument_list|()
specifier|const
block|{
return|return
name|st_shndx
operator|>=
name|ELF
operator|::
name|SHN_LOPROC
operator|&&
name|st_shndx
operator|<=
name|ELF
operator|::
name|SHN_HIPROC
return|;
block|}
name|bool
name|isOSSpecific
argument_list|()
specifier|const
block|{
return|return
name|st_shndx
operator|>=
name|ELF
operator|::
name|SHN_LOOS
operator|&&
name|st_shndx
operator|<=
name|ELF
operator|::
name|SHN_HIOS
return|;
block|}
name|bool
name|isReserved
argument_list|()
specifier|const
block|{
comment|// ELF::SHN_HIRESERVE is 0xffff so st_shndx<= ELF::SHN_HIRESERVE is always
comment|// true and some compilers warn about it.
return|return
name|st_shndx
operator|>=
name|ELF
operator|::
name|SHN_LORESERVE
return|;
block|}
name|bool
name|isUndefined
argument_list|()
specifier|const
block|{
return|return
name|st_shndx
operator|==
name|ELF
operator|::
name|SHN_UNDEF
return|;
block|}
name|bool
name|isExternal
argument_list|()
specifier|const
block|{
return|return
name|getBinding
argument_list|()
operator|!=
name|ELF
operator|::
name|STB_LOCAL
return|;
block|}
name|Expected
operator|<
name|StringRef
operator|>
name|getName
argument_list|(
argument|StringRef StrTab
argument_list|)
specifier|const
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|Expected
operator|<
name|StringRef
operator|>
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
operator|::
name|getName
argument_list|(
argument|StringRef StrTab
argument_list|)
specifier|const
block|{
name|uint32_t
name|Offset
operator|=
name|this
operator|->
name|st_name
block|;
if|if
condition|(
name|Offset
operator|>=
name|StrTab
operator|.
name|size
argument_list|()
condition|)
return|return
name|errorCodeToError
argument_list|(
name|object_error
operator|::
name|parse_failed
argument_list|)
return|;
return|return
name|StringRef
argument_list|(
name|StrTab
operator|.
name|data
argument_list|()
operator|+
name|Offset
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Elf_Versym: This is the structure of entries in the SHT_GNU_versym section
end_comment

begin_comment
comment|/// (.gnu.version). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Versym_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Half
name|vs_index
block|;
comment|// Version index with flags (e.g. VERSYM_HIDDEN)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verdef: This is the structure of entries in the SHT_GNU_verdef section
end_comment

begin_comment
comment|/// (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdef_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|using
name|Elf_Verdaux
operator|=
name|Elf_Verdaux_Impl
operator|<
name|ELFT
operator|>
block|;
name|Elf_Half
name|vd_version
block|;
comment|// Version of this structure (e.g. VER_DEF_CURRENT)
name|Elf_Half
name|vd_flags
block|;
comment|// Bitwise flags (VER_DEF_*)
name|Elf_Half
name|vd_ndx
block|;
comment|// Version index, used in .gnu.version entries
name|Elf_Half
name|vd_cnt
block|;
comment|// Number of Verdaux entries
name|Elf_Word
name|vd_hash
block|;
comment|// Hash of name
name|Elf_Word
name|vd_aux
block|;
comment|// Offset to the first Verdaux entry (in bytes)
name|Elf_Word
name|vd_next
block|;
comment|// Offset to the next Verdef entry (in bytes)
comment|/// Get the first Verdaux entry for this Verdef.
specifier|const
name|Elf_Verdaux
operator|*
name|getAux
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Verdaux
operator|*
operator|>
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
name|vd_aux
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// Elf_Verdaux: This is the structure of auxiliary data in the SHT_GNU_verdef
end_comment

begin_comment
comment|/// section (.gnu.version_d). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verdaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|vda_name
block|;
comment|// Version name (offset in string table)
name|Elf_Word
name|vda_next
block|;
comment|// Offset to next Verdaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Verneed: This is the structure of entries in the SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Verneed_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Half
name|vn_version
block|;
comment|// Version of this structure (e.g. VER_NEED_CURRENT)
name|Elf_Half
name|vn_cnt
block|;
comment|// Number of associated Vernaux entries
name|Elf_Word
name|vn_file
block|;
comment|// Library name (string table offset)
name|Elf_Word
name|vn_aux
block|;
comment|// Offset to first Vernaux entry (in bytes)
name|Elf_Word
name|vn_next
block|;
comment|// Offset to next Verneed entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Vernaux: This is the structure of auxiliary data in SHT_GNU_verneed
end_comment

begin_comment
comment|/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Vernaux_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|vna_hash
block|;
comment|// Hash of dependency name
name|Elf_Half
name|vna_flags
block|;
comment|// Bitwise Flags (VER_FLAG_*)
name|Elf_Half
name|vna_other
block|;
comment|// Version index, used in .gnu.version entries
name|Elf_Word
name|vna_name
block|;
comment|// Dependency name
name|Elf_Word
name|vna_next
block|;
comment|// Offset to next Vernaux entry (in bytes)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Base: This structure matches the form of entries in the dynamic
end_comment

begin_comment
comment|///               table section (.dynamic) look like.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Dyn_Base
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Sword
name|d_tag
block|;
expr|union
block|{
name|Elf_Word
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Dyn_Base
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Sxword
name|d_tag
block|;
expr|union
block|{
name|Elf_Xword
name|d_val
block|;
name|Elf_Addr
name|d_ptr
block|;   }
name|d_un
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Elf_Dyn_Impl: This inherits from Elf_Dyn_Base, adding getters.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Dyn_Impl
operator|:
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
block|{
name|using
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
operator|::
name|d_tag
block|;
name|using
name|Elf_Dyn_Base
operator|<
name|ELFT
operator|>
operator|::
name|d_un
block|;
name|using
name|intX_t
operator|=
name|typename
name|std
operator|::
name|conditional
operator|<
name|ELFT
operator|::
name|Is64Bits
block|,
name|int64_t
block|,
name|int32_t
operator|>
operator|::
name|type
block|;
name|using
name|uintX_t
operator|=
name|typename
name|std
operator|::
name|conditional
operator|<
name|ELFT
operator|::
name|Is64Bits
block|,
name|uint64_t
block|,
name|uint32_t
operator|>
operator|::
name|type
block|;
name|intX_t
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|d_tag
return|;
block|}
name|uintX_t
name|getVal
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|d_val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uintX_t
name|getPtr
argument_list|()
specifier|const
block|{
return|return
name|d_un
operator|.
name|d_ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
specifier|static
specifier|const
name|bool
name|IsRela
operator|=
name|false
block|;
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Word
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|uint32_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isMips64EL
argument_list|)
block|;
return|return
name|r_info
return|;
block|}
name|void
name|setRInfo
argument_list|(
argument|uint32_t R
argument_list|,
argument|bool IsMips64EL
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|IsMips64EL
argument_list|)
block|;
name|r_info
operator|=
name|R
block|;   }
comment|// These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,
comment|// and ELF32_R_INFO macros defined in the ELF specification:
name|uint32_t
name|getSymbol
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
return|return
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|>>
literal|8
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|unsigned
name|char
name|getType
argument_list|(
name|bool
name|isMips64EL
argument_list|)
decl|const
block|{
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|&
literal|0x0ff
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|this
operator|->
name|setRInfo
argument_list|(
operator|(
name|s
operator|<<
literal|8
operator|)
operator|+
name|t
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>
operator|,
name|true
operator|>
operator|:
name|public
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
specifier|static
specifier|const
name|bool
name|IsRela
operator|=
name|true
block|;
name|Elf_Sword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
specifier|static
specifier|const
name|bool
name|IsRela
operator|=
name|false
block|;
name|Elf_Addr
name|r_offset
block|;
comment|// Location (file byte offset, or program virtual addr)
name|Elf_Xword
name|r_info
block|;
comment|// Symbol table index and type of relocation to apply
name|uint64_t
name|getRInfo
argument_list|(
argument|bool isMips64EL
argument_list|)
specifier|const
block|{
name|uint64_t
name|t
operator|=
name|r_info
block|;
if|if
condition|(
operator|!
name|isMips64EL
condition|)
return|return
name|t
return|;
comment|// Mips64 little endian has a "special" encoding of r_info. Instead of one
comment|// 64 bit little endian number, it is a little endian 32 bit number followed
comment|// by a 32 bit big endian number.
return|return
operator|(
name|t
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|40
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|56
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setRInfo
parameter_list|(
name|uint64_t
name|R
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
if|if
condition|(
name|IsMips64EL
condition|)
name|r_info
operator|=
operator|(
name|R
operator|>>
literal|32
operator|)
operator||
operator|(
operator|(
name|R
operator|&
literal|0xff000000
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|R
operator|&
literal|0x00ff0000
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|R
operator|&
literal|0x0000ff00
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|R
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|56
operator|)
expr_stmt|;
else|else
name|r_info
operator|=
name|R
expr_stmt|;
block|}
end_function

begin_comment
comment|// These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,
end_comment

begin_comment
comment|// and ELF64_R_INFO macros defined in the ELF specification:
end_comment

begin_decl_stmt
name|uint32_t
name|getSymbol
argument_list|(
name|bool
name|isMips64EL
argument_list|)
decl|const
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|>>
literal|32
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|getType
argument_list|(
name|bool
name|isMips64EL
argument_list|)
decl|const
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|this
operator|->
name|getRInfo
argument_list|(
name|isMips64EL
argument_list|)
operator|&
literal|0xffffffffL
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|setSymbol
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|s
argument_list|,
name|getType
argument_list|()
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|uint32_t
name|t
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|setSymbolAndType
argument_list|(
name|getSymbol
argument_list|()
argument_list|,
name|t
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setSymbolAndType
parameter_list|(
name|uint32_t
name|s
parameter_list|,
name|uint32_t
name|t
parameter_list|,
name|bool
name|IsMips64EL
parameter_list|)
block|{
name|this
operator|->
name|setRInfo
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|s
operator|<<
literal|32
operator|)
operator|+
operator|(
name|t
operator|&
literal|0xffffffffL
operator|)
argument_list|,
name|IsMips64EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>
operator|,
name|true
operator|>
operator|:
name|public
name|Elf_Rel_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>
operator|,
name|false
operator|>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
specifier|static
specifier|const
name|bool
name|IsRela
operator|=
name|true
block|;
name|Elf_Sxword
name|r_addend
block|;
comment|// Compute value for relocatable field by adding this.
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Ehdr_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|unsigned
name|char
name|e_ident
index|[
name|ELF
operator|::
name|EI_NIDENT
index|]
block|;
comment|// ELF Identification bytes
name|Elf_Half
name|e_type
block|;
comment|// Type of file (see ET_*)
name|Elf_Half
name|e_machine
block|;
comment|// Required architecture for this file (see EM_*)
name|Elf_Word
name|e_version
block|;
comment|// Must be equal to 1
name|Elf_Addr
name|e_entry
block|;
comment|// Address to jump to in order to start program
name|Elf_Off
name|e_phoff
block|;
comment|// Program header table's file offset, in bytes
name|Elf_Off
name|e_shoff
block|;
comment|// Section header table's file offset, in bytes
name|Elf_Word
name|e_flags
block|;
comment|// Processor-specific flags
name|Elf_Half
name|e_ehsize
block|;
comment|// Size of ELF header, in bytes
name|Elf_Half
name|e_phentsize
block|;
comment|// Size of an entry in the program header table
name|Elf_Half
name|e_phnum
block|;
comment|// Number of entries in the program header table
name|Elf_Half
name|e_shentsize
block|;
comment|// Size of an entry in the section header table
name|Elf_Half
name|e_shnum
block|;
comment|// Number of entries in the section header table
name|Elf_Half
name|e_shstrndx
block|;
comment|// Section header table index of section name
comment|// string table
name|bool
name|checkMagic
argument_list|()
specifier|const
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|e_ident
argument_list|,
name|ELF
operator|::
name|ElfMagic
argument_list|,
name|strlen
argument_list|(
name|ELF
operator|::
name|ElfMagic
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
name|unsigned
name|char
name|getFileClass
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_CLASS
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|char
name|getDataEncoding
argument_list|()
specifier|const
block|{
return|return
name|e_ident
index|[
name|ELF
operator|::
name|EI_DATA
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Phdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|p_type
block|;
comment|// Type of segment
name|Elf_Off
name|p_offset
block|;
comment|// FileOffset where segment is located, in bytes
name|Elf_Addr
name|p_vaddr
block|;
comment|// Virtual Address of beginning of segment
name|Elf_Addr
name|p_paddr
block|;
comment|// Physical address of beginning of segment (OS-specific)
name|Elf_Word
name|p_filesz
block|;
comment|// Num. of bytes in file image of segment (may be zero)
name|Elf_Word
name|p_memsz
block|;
comment|// Num. of bytes in mem image of segment (may be zero)
name|Elf_Word
name|p_flags
block|;
comment|// Segment flags
name|Elf_Word
name|p_align
block|;
comment|// Segment alignment constraint
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Phdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|p_type
block|;
comment|// Type of segment
name|Elf_Word
name|p_flags
block|;
comment|// Segment flags
name|Elf_Off
name|p_offset
block|;
comment|// FileOffset where segment is located, in bytes
name|Elf_Addr
name|p_vaddr
block|;
comment|// Virtual Address of beginning of segment
name|Elf_Addr
name|p_paddr
block|;
comment|// Physical address of beginning of segment (OS-specific)
name|Elf_Xword
name|p_filesz
block|;
comment|// Num. of bytes in file image of segment (may be zero)
name|Elf_Xword
name|p_memsz
block|;
comment|// Num. of bytes in mem image of segment (may be zero)
name|Elf_Xword
name|p_align
block|;
comment|// Segment alignment constraint
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// ELFT needed for endianness.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Hash_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|nbucket
block|;
name|Elf_Word
name|nchain
block|;
name|ArrayRef
operator|<
name|Elf_Word
operator|>
name|buckets
argument_list|()
specifier|const
block|{
return|return
name|ArrayRef
operator|<
name|Elf_Word
operator|>
operator|(
operator|&
name|nbucket
operator|+
literal|2
operator|,
operator|&
name|nbucket
operator|+
literal|2
operator|+
name|nbucket
operator|)
return|;
block|}
name|ArrayRef
operator|<
name|Elf_Word
operator|>
name|chains
argument_list|()
specifier|const
block|{
return|return
name|ArrayRef
operator|<
name|Elf_Word
operator|>
operator|(
operator|&
name|nbucket
operator|+
literal|2
operator|+
name|nbucket
operator|,
operator|&
name|nbucket
operator|+
literal|2
operator|+
name|nbucket
operator|+
name|nchain
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// .gnu.hash section
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_GnuHash_Impl
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Word
name|nbuckets
block|;
name|Elf_Word
name|symndx
block|;
name|Elf_Word
name|maskwords
block|;
name|Elf_Word
name|shift2
block|;
name|ArrayRef
operator|<
name|Elf_Off
operator|>
name|filter
argument_list|()
specifier|const
block|{
return|return
name|ArrayRef
operator|<
name|Elf_Off
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Off
operator|*
operator|>
operator|(
operator|&
name|shift2
operator|+
literal|1
operator|)
operator|,
name|maskwords
operator|)
return|;
block|}
name|ArrayRef
operator|<
name|Elf_Word
operator|>
name|buckets
argument_list|()
specifier|const
block|{
return|return
name|ArrayRef
operator|<
name|Elf_Word
operator|>
operator|(
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Word
operator|*
operator|>
operator|(
name|filter
argument_list|()
operator|.
name|end
argument_list|()
operator|)
operator|,
name|nbuckets
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|Elf_Word
operator|>
name|values
argument_list|(
argument|unsigned DynamicSymCount
argument_list|)
specifier|const
block|{
return|return
name|ArrayRef
operator|<
name|Elf_Word
operator|>
operator|(
name|buckets
argument_list|()
operator|.
name|end
argument_list|()
operator|,
name|DynamicSymCount
operator|-
name|symndx
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Compressed section headers.
end_comment

begin_comment
comment|// http://www.sco.com/developers/gabi/latest/ch4.sheader.html#compression_header
end_comment

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Chdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|ch_type
block|;
name|Elf_Word
name|ch_size
block|;
name|Elf_Word
name|ch_addralign
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Chdr_Impl
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|ch_type
block|;
name|Elf_Word
name|ch_reserved
block|;
name|Elf_Xword
name|ch_size
block|;
name|Elf_Xword
name|ch_addralign
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// MIPS .reginfo section
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Mips_RegInfo
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Mips_RegInfo
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|false
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|false
argument_list|)
name|Elf_Word
name|ri_gprmask
block|;
comment|// bit-mask of used general registers
name|Elf_Word
name|ri_cprmask
index|[
literal|4
index|]
block|;
comment|// bit-mask of used co-processor registers
name|Elf_Addr
name|ri_gp_value
block|;
comment|// gp register value
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|support
operator|::
name|endianness
name|TargetEndianness
operator|>
expr|struct
name|Elf_Mips_RegInfo
operator|<
name|ELFType
operator|<
name|TargetEndianness
operator|,
name|true
operator|>>
block|{
name|LLVM_ELF_IMPORT_TYPES
argument_list|(
argument|TargetEndianness
argument_list|,
argument|true
argument_list|)
name|Elf_Word
name|ri_gprmask
block|;
comment|// bit-mask of used general registers
name|Elf_Word
name|ri_pad
block|;
comment|// unused padding field
name|Elf_Word
name|ri_cprmask
index|[
literal|4
index|]
block|;
comment|// bit-mask of used co-processor registers
name|Elf_Addr
name|ri_gp_value
block|;
comment|// gp register value
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// .MIPS.options section
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Mips_Options
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|uint8_t
name|kind
block|;
comment|// Determines interpretation of variable part of descriptor
name|uint8_t
name|size
block|;
comment|// Byte size of descriptor, including this header
name|Elf_Half
name|section
block|;
comment|// Section header index of section affected,
comment|// or 0 for global options
name|Elf_Word
name|info
block|;
comment|// Kind-specific information
name|Elf_Mips_RegInfo
operator|<
name|ELFT
operator|>
operator|&
name|getRegInfo
argument_list|()
block|{
name|assert
argument_list|(
name|kind
operator|==
name|ELF
operator|::
name|ODK_REGINFO
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|Elf_Mips_RegInfo
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|this
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Mips_Options
argument_list|)
operator|)
return|;
block|}
specifier|const
name|Elf_Mips_RegInfo
operator|<
name|ELFT
operator|>
operator|&
name|getRegInfo
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Elf_Mips_Options
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getRegInfo
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// .MIPS.abiflags section content
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Elf_Mips_ABIFlags
block|{
name|LLVM_ELF_IMPORT_TYPES_ELFT
argument_list|(
argument|ELFT
argument_list|)
name|Elf_Half
name|version
block|;
comment|// Version of the structure
name|uint8_t
name|isa_level
block|;
comment|// ISA level: 1-5, 32, and 64
name|uint8_t
name|isa_rev
block|;
comment|// ISA revision (0 for MIPS I - MIPS V)
name|uint8_t
name|gpr_size
block|;
comment|// General purpose registers size
name|uint8_t
name|cpr1_size
block|;
comment|// Co-processor 1 registers size
name|uint8_t
name|cpr2_size
block|;
comment|// Co-processor 2 registers size
name|uint8_t
name|fp_abi
block|;
comment|// Floating-point ABI flag
name|Elf_Word
name|isa_ext
block|;
comment|// Processor-specific extension
name|Elf_Word
name|ases
block|;
comment|// ASEs flags
name|Elf_Word
name|flags1
block|;
comment|// General flags
name|Elf_Word
name|flags2
block|;
comment|// General flags
block|}
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// end namespace object.
end_comment

begin_comment
unit|}
comment|// end namespace llvm.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_OBJECT_ELFTYPES_H
end_comment

end_unit

