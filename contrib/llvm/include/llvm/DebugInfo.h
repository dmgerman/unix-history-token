begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- llvm/Analysis/DebugInfo.h - Debug Information Helpers --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines a bunch of datatypes that are useful for creating and
end_comment

begin_comment
comment|// walking debug info in LLVM IR form. They essentially provide wrappers around
end_comment

begin_comment
comment|// the information in the global variables that's needed when constructing the
end_comment

begin_comment
comment|// DWARF information.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_DEBUGINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_DEBUGINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|GlobalVariable
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|DbgDeclareInst
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|NamedMDNode
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|DIFile
decl_stmt|;
name|class
name|DISubprogram
decl_stmt|;
name|class
name|DILexicalBlock
decl_stmt|;
name|class
name|DILexicalBlockFile
decl_stmt|;
name|class
name|DIVariable
decl_stmt|;
name|class
name|DIType
decl_stmt|;
name|class
name|DIObjCProperty
decl_stmt|;
comment|/// DIDescriptor - A thin wraper around MDNode to access encoded debug info.
comment|/// This should not be stored in a container, because the underlying MDNode
comment|/// may change in certain situations.
name|class
name|DIDescriptor
block|{
name|public
label|:
enum|enum
block|{
name|FlagPrivate
init|=
literal|1
operator|<<
literal|0
block|,
name|FlagProtected
init|=
literal|1
operator|<<
literal|1
block|,
name|FlagFwdDecl
init|=
literal|1
operator|<<
literal|2
block|,
name|FlagAppleBlock
init|=
literal|1
operator|<<
literal|3
block|,
name|FlagBlockByrefStruct
init|=
literal|1
operator|<<
literal|4
block|,
name|FlagVirtual
init|=
literal|1
operator|<<
literal|5
block|,
name|FlagArtificial
init|=
literal|1
operator|<<
literal|6
block|,
name|FlagExplicit
init|=
literal|1
operator|<<
literal|7
block|,
name|FlagPrototyped
init|=
literal|1
operator|<<
literal|8
block|,
name|FlagObjcClassComplete
init|=
literal|1
operator|<<
literal|9
block|,
name|FlagObjectPointer
init|=
literal|1
operator|<<
literal|10
block|,
name|FlagVector
init|=
literal|1
operator|<<
literal|11
block|,
name|FlagStaticMember
init|=
literal|1
operator|<<
literal|12
block|}
enum|;
name|protected
label|:
specifier|const
name|MDNode
modifier|*
name|DbgNode
decl_stmt|;
name|StringRef
name|getStringField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|getUnsignedField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
block|{
return|return
operator|(
name|unsigned
operator|)
name|getUInt64Field
argument_list|(
name|Elt
argument_list|)
return|;
block|}
name|uint64_t
name|getUInt64Field
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|int64_t
name|getInt64Field
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|DIDescriptor
name|getDescriptorField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|template
operator|<
name|typename
name|DescTy
operator|>
name|DescTy
name|getFieldAs
argument_list|(
argument|unsigned Elt
argument_list|)
specifier|const
block|{
return|return
name|DescTy
argument_list|(
name|getDescriptorField
argument_list|(
name|Elt
argument_list|)
argument_list|)
return|;
block|}
name|GlobalVariable
modifier|*
name|getGlobalVariableField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|Constant
modifier|*
name|getConstantField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|Function
modifier|*
name|getFunctionField
argument_list|(
name|unsigned
name|Elt
argument_list|)
decl|const
decl_stmt|;
name|void
name|replaceFunctionField
parameter_list|(
name|unsigned
name|Elt
parameter_list|,
name|Function
modifier|*
name|F
parameter_list|)
function_decl|;
name|public
label|:
name|explicit
name|DIDescriptor
argument_list|()
operator|:
name|DbgNode
argument_list|(
literal|0
argument_list|)
block|{}
name|explicit
name|DIDescriptor
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DbgNode
argument_list|(
argument|N
argument_list|)
block|{}
name|explicit
name|DIDescriptor
argument_list|(
argument|const DIFile F
argument_list|)
expr_stmt|;
name|explicit
name|DIDescriptor
parameter_list|(
specifier|const
name|DISubprogram
name|F
parameter_list|)
function_decl|;
name|explicit
name|DIDescriptor
parameter_list|(
specifier|const
name|DILexicalBlockFile
name|F
parameter_list|)
function_decl|;
name|explicit
name|DIDescriptor
parameter_list|(
specifier|const
name|DILexicalBlock
name|F
parameter_list|)
function_decl|;
name|explicit
name|DIDescriptor
parameter_list|(
specifier|const
name|DIVariable
name|F
parameter_list|)
function_decl|;
name|explicit
name|DIDescriptor
parameter_list|(
specifier|const
name|DIType
name|F
parameter_list|)
function_decl|;
name|bool
name|Verify
argument_list|()
specifier|const
expr_stmt|;
name|operator
name|MDNode
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|DbgNode
operator|)
return|;
block|}
name|MDNode
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|MDNode
operator|*
operator|>
operator|(
name|DbgNode
operator|)
return|;
block|}
name|unsigned
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|LLVMDebugVersionMask
return|;
block|}
name|bool
name|isDerivedType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isCompositeType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isBasicType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isVariable
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isSubprogram
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isGlobalVariable
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isScope
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isFile
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isCompileUnit
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isNameSpace
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isLexicalBlockFile
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isLexicalBlock
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isSubrange
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isEnumerator
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isGlobal
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isUnspecifiedParameter
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isTemplateTypeParameter
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isTemplateValueParameter
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isObjCProperty
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isImportedModule
argument_list|()
specifier|const
expr_stmt|;
comment|/// print - print descriptor.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
comment|/// dump - print descriptor to dbgs() with a newline.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// DISubrange - This is used to represent ranges, for array bounds.
end_comment

begin_decl_stmt
name|class
name|DISubrange
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DISubrange
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|int64_t
name|getLo
argument_list|()
specifier|const
block|{
return|return
name|getInt64Field
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|int64_t
name|getCount
argument_list|()
specifier|const
block|{
return|return
name|getInt64Field
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DIArray - This descriptor holds an array of descriptors.
end_comment

begin_decl_stmt
name|class
name|DIArray
range|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DIArray
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getNumElements
argument_list|()
specifier|const
block|;
name|DIDescriptor
name|getElement
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|getDescriptorField
argument_list|(
name|Idx
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// DIScope - A base class for various scopes.
name|class
name|DIScope
operator|:
name|public
name|DIDescriptor
block|{
name|protected
operator|:
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIScope
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|;
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DIFile - This is a wrapper for a file.
name|class
name|DIFile
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|public
operator|:
name|explicit
name|DIFile
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{
if|if
condition|(
name|DbgNode
operator|&&
operator|!
name|isFile
argument_list|()
condition|)
name|DbgNode
operator|=
literal|0
expr_stmt|;
block|}
name|MDNode
operator|*
name|getFileNode
argument_list|()
specifier|const
block|;
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DICompileUnit - A wrapper for a compile unit.
name|class
name|DICompileUnit
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DICompileUnit
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getLanguage
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|StringRef
name|getProducer
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|bool
name|isOptimized
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
operator|!=
literal|0
return|;
block|}
name|StringRef
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|unsigned
name|getRunTimeVersion
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|DIArray
name|getEnumTypes
argument_list|()
specifier|const
block|;
name|DIArray
name|getRetainedTypes
argument_list|()
specifier|const
block|;
name|DIArray
name|getSubprograms
argument_list|()
specifier|const
block|;
name|DIArray
name|getGlobalVariables
argument_list|()
specifier|const
block|;
name|DIArray
name|getImportedModules
argument_list|()
specifier|const
block|;
name|StringRef
name|getSplitDebugFilename
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|12
argument_list|)
return|;
block|}
comment|/// Verify - Verify that a compile unit is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DIEnumerator - A wrapper for an enumerator (e.g. X and Y in 'enum {X,Y}').
comment|/// FIXME: it seems strange that this doesn't have either a reference to the
comment|/// type/precision or a file/line pair for location info.
name|class
name|DIEnumerator
operator|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIEnumerator
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|uint64_t
name|getEnumValue
argument_list|()
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DIType - This is a wrapper for a type.
comment|/// FIXME: Types should be factored much better so that CV qualifiers and
comment|/// others do not require a huge and empty descriptor full of zeros.
name|class
name|DIType
operator|:
name|public
name|DIScope
block|{
name|protected
operator|:
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|// This ctor is used when the Tag has already been validated by a derived
comment|// ctor.
name|DIType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|public
operator|:
comment|/// Verify - Verify that a type descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;
name|explicit
name|DIType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
block|;
name|explicit
name|DIType
argument_list|()
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|uint64_t
name|getSizeInBits
argument_list|()
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|uint64_t
name|getAlignInBits
argument_list|()
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
literal|6
argument_list|)
return|;
block|}
comment|// FIXME: Offset is only used for DW_TAG_member nodes.  Making every type
comment|// carry this is just plain insane.
name|uint64_t
name|getOffsetInBits
argument_list|()
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|8
argument_list|)
return|;
block|}
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagPrivate
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagProtected
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isForwardDecl
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagFwdDecl
operator|)
operator|!=
literal|0
return|;
block|}
comment|// isAppleBlock - Return true if this is the Apple Blocks extension.
name|bool
name|isAppleBlockExtension
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagAppleBlock
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isBlockByrefStruct
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagBlockByrefStruct
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagVirtual
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagObjectPointer
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjcClassComplete
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagObjcClassComplete
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isVector
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagVector
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isStaticMember
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getFlags
argument_list|()
operator|&
name|FlagStaticMember
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|DbgNode
operator|&&
operator|(
name|isBasicType
argument_list|()
operator|||
name|isDerivedType
argument_list|()
operator|||
name|isCompositeType
argument_list|()
operator|)
return|;
block|}
comment|/// isUnsignedDIType - Return true if type encoding is unsigned.
name|bool
name|isUnsignedDIType
argument_list|()
block|;
comment|/// replaceAllUsesWith - Replace all uses of debug info referenced by
comment|/// this descriptor.
name|void
name|replaceAllUsesWith
argument_list|(
name|DIDescriptor
operator|&
name|D
argument_list|)
block|;
name|void
name|replaceAllUsesWith
argument_list|(
name|MDNode
operator|*
name|D
argument_list|)
block|;   }
block|;
comment|/// DIBasicType - A basic type, like 'int' or 'float'.
name|class
name|DIBasicType
operator|:
name|public
name|DIType
block|{
name|public
operator|:
name|explicit
name|DIBasicType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIType
argument_list|(
argument|N
argument_list|)
block|{}
name|unsigned
name|getEncoding
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|9
argument_list|)
return|;
block|}
comment|/// Verify - Verify that a basic type descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DIDerivedType - A simple derived type, like a const qualified type,
comment|/// a typedef, a pointer or reference, et cetera.  Or, a data member of
comment|/// a class/struct/union.
name|class
name|DIDerivedType
operator|:
name|public
name|DIType
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|explicit
name|DIDerivedType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|)
operator|:
name|DIType
argument_list|(
argument|N
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|{}
name|public
operator|:
name|explicit
name|DIDerivedType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIType
argument_list|(
argument|N
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|{}
name|DIType
name|getTypeDerivedFrom
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|9
operator|)
return|;
block|}
comment|/// getOriginalTypeSize - If this type is derived from a base type then
comment|/// return base type size.
name|uint64_t
name|getOriginalTypeSize
argument_list|()
specifier|const
block|;
comment|/// getObjCProperty - Return property node, if this ivar is
comment|/// associated with one.
name|MDNode
operator|*
name|getObjCProperty
argument_list|()
specifier|const
block|;
name|DIType
name|getClassType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_ptr_to_member_type
argument_list|)
block|;
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|10
operator|)
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getTag
argument_list|()
operator|==
name|dwarf
operator|::
name|DW_TAG_member
operator|)
operator|&&
name|isStaticMember
argument_list|()
argument_list|)
block|;
return|return
name|getConstantField
argument_list|(
literal|10
argument_list|)
return|;
block|}
comment|/// Verify - Verify that a derived type descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DICompositeType - This descriptor holds a type that can refer to multiple
comment|/// other types, like a function or struct.
comment|/// DICompositeType is derived from DIDerivedType because some
comment|/// composite types (such as enums) can be derived from basic types
comment|// FIXME: Make this derive from DIType directly& just store the
comment|// base type in a single DIType field.
name|class
name|DICompositeType
operator|:
name|public
name|DIDerivedType
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DICompositeType
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDerivedType
argument_list|(
argument|N
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|{
if|if
condition|(
name|N
operator|&&
operator|!
name|isCompositeType
argument_list|()
condition|)
name|DbgNode
operator|=
literal|0
expr_stmt|;
block|}
name|DIArray
name|getTypeArray
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|10
operator|)
return|;
block|}
name|void
name|setTypeArray
argument_list|(
argument|DIArray Elements
argument_list|,
argument|DIArray TParams = DIArray()
argument_list|)
block|;
name|unsigned
name|getRunTimeLang
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|11
argument_list|)
return|;
block|}
name|DICompositeType
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DICompositeType
operator|>
operator|(
literal|12
operator|)
return|;
block|}
name|void
name|setContainingType
argument_list|(
argument|DICompositeType ContainingType
argument_list|)
block|;
name|DIArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|13
operator|)
return|;
block|}
comment|/// Verify - Verify that a composite type descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DITemplateTypeParameter - This is a wrapper for template type parameter.
name|class
name|DITemplateTypeParameter
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DITemplateTypeParameter
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|4
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|4
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DITemplateValueParameter - This is a wrapper for template value parameter.
name|class
name|DITemplateValueParameter
operator|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DITemplateValueParameter
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|uint64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|5
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|5
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
block|;
comment|/// DISubprogram - This is a wrapper for a subprogram (e.g. a function).
name|class
name|DISubprogram
operator|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DISubprogram
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
return|;
block|}
name|DICompositeType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DICompositeType
operator|>
operator|(
literal|7
operator|)
return|;
block|}
comment|/// getReturnTypeName - Subprogram return types are encoded either as
comment|/// DIType or as DICompositeType.
name|StringRef
name|getReturnTypeName
argument_list|()
specifier|const
block|{
name|DICompositeType
name|DCT
argument_list|(
name|getFieldAs
operator|<
name|DICompositeType
operator|>
operator|(
literal|7
operator|)
argument_list|)
block|;
if|if
condition|(
name|DCT
operator|.
name|Verify
argument_list|()
condition|)
block|{
name|DIArray
name|A
init|=
name|DCT
operator|.
name|getTypeArray
argument_list|()
decl_stmt|;
name|DIType
name|T
argument_list|(
name|A
operator|.
name|getElement
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|T
operator|.
name|getName
argument_list|()
return|;
block|}
name|DIType
name|T
argument_list|(
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|7
operator|)
argument_list|)
decl_stmt|;
return|return
name|T
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/// isLocalToUnit - Return true if this subprogram is local to the current
comment|/// compile unit, like 'static' in C.
name|unsigned
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|8
argument_list|)
return|;
block|}
name|unsigned
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|9
argument_list|)
return|;
block|}
name|unsigned
name|getVirtuality
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|10
argument_list|)
return|;
block|}
name|unsigned
name|getVirtualIndex
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|11
argument_list|)
return|;
block|}
name|DICompositeType
name|getContainingType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DICompositeType
operator|>
operator|(
literal|12
operator|)
return|;
block|}
name|unsigned
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
return|;
block|}
name|unsigned
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// isPrivate - Return true if this subprogram has "private"
comment|/// access specifier.
name|bool
name|isPrivate
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
operator|&
name|FlagPrivate
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// isProtected - Return true if this subprogram has "protected"
comment|/// access specifier.
name|bool
name|isProtected
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
operator|&
name|FlagProtected
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// isExplicit - Return true if this subprogram is marked as explicit.
name|bool
name|isExplicit
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
operator|&
name|FlagExplicit
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// isPrototyped - Return true if this subprogram is prototyped.
name|bool
name|isPrototyped
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|13
argument_list|)
operator|&
name|FlagPrototyped
operator|)
operator|!=
literal|0
return|;
block|}
name|unsigned
name|isOptimized
argument_list|()
specifier|const
block|;
comment|/// getScopeLineNumber - Get the beginning of the scope of the
comment|/// function, not necessarily where the name of the program
comment|/// starts.
name|unsigned
name|getScopeLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|19
argument_list|)
return|;
block|}
comment|/// Verify - Verify that a subprogram descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;
comment|/// describes - Return true if this subprogram provides debugging
comment|/// information for the function F.
name|bool
name|describes
argument_list|(
specifier|const
name|Function
operator|*
name|F
argument_list|)
block|;
name|Function
operator|*
name|getFunction
argument_list|()
specifier|const
block|{
return|return
name|getFunctionField
argument_list|(
literal|15
argument_list|)
return|;
block|}
name|void
name|replaceFunction
argument_list|(
argument|Function *F
argument_list|)
block|{
name|replaceFunctionField
argument_list|(
literal|15
argument_list|,
name|F
argument_list|)
block|; }
name|DIArray
name|getTemplateParams
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIArray
operator|>
operator|(
literal|16
operator|)
return|;
block|}
name|DISubprogram
name|getFunctionDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DISubprogram
operator|>
operator|(
literal|17
operator|)
return|;
block|}
name|MDNode
operator|*
name|getVariablesNodes
argument_list|()
specifier|const
block|;
name|DIArray
name|getVariables
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DIGlobalVariable - This is a wrapper for a global variable.
end_comment

begin_decl_stmt
name|class
name|DIGlobalVariable
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIGlobalVariable
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getDisplayName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getLinkageName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|6
operator|)
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|6
operator|)
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|7
argument_list|)
return|;
block|}
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|8
operator|)
return|;
block|}
name|unsigned
name|isLocalToUnit
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|9
argument_list|)
return|;
block|}
name|unsigned
name|isDefinition
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|10
argument_list|)
return|;
block|}
name|GlobalVariable
operator|*
name|getGlobal
argument_list|()
specifier|const
block|{
return|return
name|getGlobalVariableField
argument_list|(
literal|11
argument_list|)
return|;
block|}
name|Constant
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
return|return
name|getConstantField
argument_list|(
literal|11
argument_list|)
return|;
block|}
name|DIDerivedType
name|getStaticDataMemberDeclaration
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIDerivedType
operator|>
operator|(
literal|12
operator|)
return|;
block|}
comment|/// Verify - Verify that a global variable descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DIVariable - This is a wrapper for a variable (e.g. parameter, local,
end_comment

begin_comment
comment|/// global etc).
end_comment

begin_decl_stmt
name|class
name|DIVariable
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIVariable
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|2
argument_list|)
return|;
block|}
name|DIFile
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
operator|<<
literal|8
operator|)
operator|>>
literal|8
return|;
block|}
name|unsigned
name|getArgNumber
argument_list|()
specifier|const
block|{
name|unsigned
name|L
operator|=
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
block|;
return|return
name|L
operator|>>
literal|24
return|;
block|}
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|5
operator|)
return|;
block|}
comment|/// isArtificial - Return true if this variable is marked as "artificial".
name|bool
name|isArtificial
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|FlagArtificial
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isObjectPointer
argument_list|()
specifier|const
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|FlagObjectPointer
operator|)
operator|!=
literal|0
return|;
block|}
comment|/// getInlinedAt - If this variable is inlined then return inline location.
name|MDNode
operator|*
name|getInlinedAt
argument_list|()
specifier|const
block|;
comment|/// Verify - Verify that a variable descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;
comment|/// HasComplexAddr - Return true if the variable has a complex address.
name|bool
name|hasComplexAddress
argument_list|()
specifier|const
block|{
return|return
name|getNumAddrElements
argument_list|()
operator|>
literal|0
return|;
block|}
name|unsigned
name|getNumAddrElements
argument_list|()
specifier|const
block|;
name|uint64_t
name|getAddrElement
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|getUInt64Field
argument_list|(
name|Idx
operator|+
literal|8
argument_list|)
return|;
block|}
comment|/// isBlockByrefVariable - Return true if the variable was declared as
comment|/// a "__block" variable (Apple Blocks).
name|bool
name|isBlockByrefVariable
argument_list|()
specifier|const
block|{
return|return
name|getType
argument_list|()
operator|.
name|isBlockByrefStruct
argument_list|()
return|;
block|}
comment|/// isInlinedFnArgument - Return true if this variable provides debugging
comment|/// information for an inlined function arguments.
name|bool
name|isInlinedFnArgument
argument_list|(
specifier|const
name|Function
operator|*
name|CurFn
argument_list|)
block|;
name|void
name|printExtendedName
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DILexicalBlock - This is a wrapper for a lexical block.
end_comment

begin_decl_stmt
name|class
name|DILexicalBlock
range|:
name|public
name|DIScope
block|{
name|public
operator|:
name|explicit
name|DILexicalBlock
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DILexicalBlockFile - This is a wrapper for a lexical block with
end_comment

begin_comment
comment|/// a filename change.
end_comment

begin_decl_stmt
name|class
name|DILexicalBlockFile
range|:
name|public
name|DIScope
block|{
name|public
operator|:
name|explicit
name|DILexicalBlockFile
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getScope
argument_list|()
operator|.
name|isSubprogram
argument_list|()
condition|)
return|return
name|getScope
argument_list|()
return|;
return|return
name|getScope
argument_list|()
operator|.
name|getContext
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getLineNumber
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getColumnNumber
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DILexicalBlock
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DILexicalBlock
operator|>
operator|(
literal|2
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|Verify
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// DINameSpace - A wrapper for a C++ style name space.
end_comment

begin_decl_stmt
name|class
name|DINameSpace
range|:
name|public
name|DIScope
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DINameSpace
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
operator|=
literal|0
argument_list|)
operator|:
name|DIScope
argument_list|(
argument|N
argument_list|)
block|{}
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|StringRef
name|getName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DILocation - This object holds location information. This object
end_comment

begin_comment
comment|/// is not associated with any DWARF tag.
end_comment

begin_decl_stmt
name|class
name|DILocation
range|:
name|public
name|DIDescriptor
block|{
name|public
operator|:
name|explicit
name|DILocation
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{ }
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|unsigned
name|getColumnNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIScope
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|DILocation
name|getOrigLocation
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DILocation
operator|>
operator|(
literal|3
operator|)
return|;
block|}
name|StringRef
name|getFilename
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getFilename
argument_list|()
return|;
block|}
name|StringRef
name|getDirectory
argument_list|()
specifier|const
block|{
return|return
name|getScope
argument_list|()
operator|.
name|getDirectory
argument_list|()
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|DIObjCProperty
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIObjCProperty
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{ }
name|StringRef
name|getObjCPropertyName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|DIFile
name|getFile
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIFile
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|StringRef
name|getObjCPropertyGetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|4
argument_list|)
return|;
block|}
name|StringRef
name|getObjCPropertySetterName
argument_list|()
specifier|const
block|{
return|return
name|getStringField
argument_list|(
literal|5
argument_list|)
return|;
block|}
name|bool
name|isReadOnlyObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_readonly
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isReadWriteObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_readwrite
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isAssignObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_assign
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isRetainObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_retain
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isCopyObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_copy
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isNonAtomicObjCProperty
argument_list|()
block|{
return|return
operator|(
name|getUnsignedField
argument_list|(
literal|6
argument_list|)
operator|&
name|dwarf
operator|::
name|DW_APPLE_PROPERTY_nonatomic
operator|)
operator|!=
literal|0
return|;
block|}
name|DIType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIType
operator|>
operator|(
literal|7
operator|)
return|;
block|}
comment|/// Verify - Verify that a derived type descriptor is well formed.
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief An imported module (C++ using directive or similar).
end_comment

begin_decl_stmt
name|class
name|DIImportedModule
range|:
name|public
name|DIDescriptor
block|{
name|friend
name|class
name|DIDescriptor
block|;
name|void
name|printInternal
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|public
operator|:
name|explicit
name|DIImportedModule
argument_list|(
specifier|const
name|MDNode
operator|*
name|N
argument_list|)
operator|:
name|DIDescriptor
argument_list|(
argument|N
argument_list|)
block|{ }
name|DIScope
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DIScope
operator|>
operator|(
literal|1
operator|)
return|;
block|}
name|DINameSpace
name|getNameSpace
argument_list|()
specifier|const
block|{
return|return
name|getFieldAs
operator|<
name|DINameSpace
operator|>
operator|(
literal|2
operator|)
return|;
block|}
name|unsigned
name|getLineNumber
argument_list|()
specifier|const
block|{
return|return
name|getUnsignedField
argument_list|(
literal|3
argument_list|)
return|;
block|}
name|bool
name|Verify
argument_list|()
specifier|const
block|;   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// getDISubprogram - Find subprogram that is enclosing this scope.
end_comment

begin_function_decl
name|DISubprogram
name|getDISubprogram
parameter_list|(
specifier|const
name|MDNode
modifier|*
name|Scope
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// getDICompositeType - Find underlying composite type.
end_comment

begin_function_decl
name|DICompositeType
name|getDICompositeType
parameter_list|(
name|DIType
name|T
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// isSubprogramContext - Return true if Context is either a subprogram
end_comment

begin_comment
comment|/// or another context nested inside a subprogram.
end_comment

begin_function_decl
name|bool
name|isSubprogramContext
parameter_list|(
specifier|const
name|MDNode
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// getOrInsertFnSpecificMDNode - Return a NameMDNode that is suitable
end_comment

begin_comment
comment|/// to hold function specific information.
end_comment

begin_function_decl
name|NamedMDNode
modifier|*
name|getOrInsertFnSpecificMDNode
parameter_list|(
name|Module
modifier|&
name|M
parameter_list|,
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// getFnSpecificMDNode - Return a NameMDNode, if available, that is
end_comment

begin_comment
comment|/// suitable to hold function specific information.
end_comment

begin_function_decl
name|NamedMDNode
modifier|*
name|getFnSpecificMDNode
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|,
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// createInlinedVariable - Create a new inlined variable based on current
end_comment

begin_comment
comment|/// variable.
end_comment

begin_comment
comment|/// @param DV            Current Variable.
end_comment

begin_comment
comment|/// @param InlinedScope  Location at current variable is inlined.
end_comment

begin_function_decl
name|DIVariable
name|createInlinedVariable
parameter_list|(
name|MDNode
modifier|*
name|DV
parameter_list|,
name|MDNode
modifier|*
name|InlinedScope
parameter_list|,
name|LLVMContext
modifier|&
name|VMContext
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// cleanseInlinedVariable - Remove inlined scope from the variable.
end_comment

begin_function_decl
name|DIVariable
name|cleanseInlinedVariable
parameter_list|(
name|MDNode
modifier|*
name|DV
parameter_list|,
name|LLVMContext
modifier|&
name|VMContext
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|class
name|DebugInfoFinder
block|{
name|public
label|:
comment|/// processModule - Process entire module and collect debug info
comment|/// anchors.
name|void
name|processModule
parameter_list|(
specifier|const
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
name|private
label|:
comment|/// processType - Process DIType.
name|void
name|processType
parameter_list|(
name|DIType
name|DT
parameter_list|)
function_decl|;
comment|/// processLexicalBlock - Process DILexicalBlock.
name|void
name|processLexicalBlock
parameter_list|(
name|DILexicalBlock
name|LB
parameter_list|)
function_decl|;
comment|/// processSubprogram - Process DISubprogram.
name|void
name|processSubprogram
parameter_list|(
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
comment|/// processDeclare - Process DbgDeclareInst.
name|void
name|processDeclare
parameter_list|(
specifier|const
name|DbgDeclareInst
modifier|*
name|DDI
parameter_list|)
function_decl|;
comment|/// processLocation - Process DILocation.
name|void
name|processLocation
parameter_list|(
name|DILocation
name|Loc
parameter_list|)
function_decl|;
comment|/// addCompileUnit - Add compile unit into CUs.
name|bool
name|addCompileUnit
parameter_list|(
name|DICompileUnit
name|CU
parameter_list|)
function_decl|;
comment|/// addGlobalVariable - Add global variable into GVs.
name|bool
name|addGlobalVariable
parameter_list|(
name|DIGlobalVariable
name|DIG
parameter_list|)
function_decl|;
comment|// addSubprogram - Add subprogram into SPs.
name|bool
name|addSubprogram
parameter_list|(
name|DISubprogram
name|SP
parameter_list|)
function_decl|;
comment|/// addType - Add type into Tys.
name|bool
name|addType
parameter_list|(
name|DIType
name|DT
parameter_list|)
function_decl|;
name|public
label|:
typedef|typedef
name|SmallVector
operator|<
name|MDNode
operator|*
operator|,
literal|8
operator|>
operator|::
name|const_iterator
name|iterator
expr_stmt|;
name|iterator
name|compile_unit_begin
argument_list|()
specifier|const
block|{
return|return
name|CUs
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|compile_unit_end
argument_list|()
specifier|const
block|{
return|return
name|CUs
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|subprogram_begin
argument_list|()
specifier|const
block|{
return|return
name|SPs
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|subprogram_end
argument_list|()
specifier|const
block|{
return|return
name|SPs
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|global_variable_begin
argument_list|()
specifier|const
block|{
return|return
name|GVs
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|global_variable_end
argument_list|()
specifier|const
block|{
return|return
name|GVs
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|type_begin
argument_list|()
specifier|const
block|{
return|return
name|TYs
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|type_end
argument_list|()
specifier|const
block|{
return|return
name|TYs
operator|.
name|end
argument_list|()
return|;
block|}
name|unsigned
name|compile_unit_count
argument_list|()
specifier|const
block|{
return|return
name|CUs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|global_variable_count
argument_list|()
specifier|const
block|{
return|return
name|GVs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|subprogram_count
argument_list|()
specifier|const
block|{
return|return
name|SPs
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|type_count
argument_list|()
specifier|const
block|{
return|return
name|TYs
operator|.
name|size
argument_list|()
return|;
block|}
name|private
label|:
name|SmallVector
operator|<
name|MDNode
operator|*
operator|,
literal|8
operator|>
name|CUs
expr_stmt|;
comment|// Compile Units
name|SmallVector
operator|<
name|MDNode
operator|*
operator|,
literal|8
operator|>
name|SPs
expr_stmt|;
comment|// Subprograms
name|SmallVector
operator|<
name|MDNode
operator|*
operator|,
literal|8
operator|>
name|GVs
expr_stmt|;
comment|// Global Variables;
name|SmallVector
operator|<
name|MDNode
operator|*
operator|,
literal|8
operator|>
name|TYs
expr_stmt|;
comment|// Types
name|SmallPtrSet
operator|<
name|MDNode
operator|*
operator|,
literal|64
operator|>
name|NodesSeen
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

