begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/MC/MCInst.h - MCInst class --------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the declaration of the MCInst and MCOperand classes, which
end_comment

begin_comment
comment|// is the basic representation used to represent low-level machine code
end_comment

begin_comment
comment|// instructions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_MC_MCINST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_MC_MCINST_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SMLoc.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCExpr
decl_stmt|;
name|class
name|MCInst
decl_stmt|;
name|class
name|MCInstPrinter
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
comment|/// \brief Instances of this class represent operands of the MCInst class.
comment|/// This is a simple discriminated union.
name|class
name|MCOperand
block|{
enum|enum
name|MachineOperandType
enum|:
name|unsigned
name|char
block|{
name|kInvalid
block|,
comment|///< Uninitialized.
name|kRegister
block|,
comment|///< Register operand.
name|kImmediate
block|,
comment|///< Immediate operand.
name|kFPImmediate
block|,
comment|///< Floating-point immediate operand.
name|kExpr
block|,
comment|///< Relocatable immediate operand.
name|kInst
comment|///< Sub-instruction operand.
block|}
enum|;
name|MachineOperandType
name|Kind
init|=
name|kInvalid
decl_stmt|;
union|union
block|{
name|unsigned
name|RegVal
decl_stmt|;
name|int64_t
name|ImmVal
decl_stmt|;
name|double
name|FPImmVal
decl_stmt|;
specifier|const
name|MCExpr
modifier|*
name|ExprVal
decl_stmt|;
specifier|const
name|MCInst
modifier|*
name|InstVal
decl_stmt|;
block|}
union|;
name|public
label|:
name|MCOperand
argument_list|()
operator|:
name|FPImmVal
argument_list|(
literal|0.0
argument_list|)
block|{}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|!=
name|kInvalid
return|;
block|}
name|bool
name|isReg
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|kRegister
return|;
block|}
name|bool
name|isImm
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|kImmediate
return|;
block|}
name|bool
name|isFPImm
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|kFPImmediate
return|;
block|}
name|bool
name|isExpr
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|kExpr
return|;
block|}
name|bool
name|isInst
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|kInst
return|;
block|}
comment|/// \brief Returns the register number.
name|unsigned
name|getReg
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isReg
argument_list|()
operator|&&
literal|"This is not a register operand!"
argument_list|)
block|;
return|return
name|RegVal
return|;
block|}
comment|/// \brief Set the register number.
name|void
name|setReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|assert
argument_list|(
name|isReg
argument_list|()
operator|&&
literal|"This is not a register operand!"
argument_list|)
expr_stmt|;
name|RegVal
operator|=
name|Reg
expr_stmt|;
block|}
name|int64_t
name|getImm
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isImm
argument_list|()
operator|&&
literal|"This is not an immediate"
argument_list|)
block|;
return|return
name|ImmVal
return|;
block|}
name|void
name|setImm
parameter_list|(
name|int64_t
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|isImm
argument_list|()
operator|&&
literal|"This is not an immediate"
argument_list|)
expr_stmt|;
name|ImmVal
operator|=
name|Val
expr_stmt|;
block|}
name|double
name|getFPImm
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isFPImm
argument_list|()
operator|&&
literal|"This is not an FP immediate"
argument_list|)
block|;
return|return
name|FPImmVal
return|;
block|}
name|void
name|setFPImm
parameter_list|(
name|double
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|isFPImm
argument_list|()
operator|&&
literal|"This is not an FP immediate"
argument_list|)
expr_stmt|;
name|FPImmVal
operator|=
name|Val
expr_stmt|;
block|}
specifier|const
name|MCExpr
operator|*
name|getExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExpr
argument_list|()
operator|&&
literal|"This is not an expression"
argument_list|)
block|;
return|return
name|ExprVal
return|;
block|}
name|void
name|setExpr
parameter_list|(
specifier|const
name|MCExpr
modifier|*
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|isExpr
argument_list|()
operator|&&
literal|"This is not an expression"
argument_list|)
expr_stmt|;
name|ExprVal
operator|=
name|Val
expr_stmt|;
block|}
specifier|const
name|MCInst
operator|*
name|getInst
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isInst
argument_list|()
operator|&&
literal|"This is not a sub-instruction"
argument_list|)
block|;
return|return
name|InstVal
return|;
block|}
name|void
name|setInst
parameter_list|(
specifier|const
name|MCInst
modifier|*
name|Val
parameter_list|)
block|{
name|assert
argument_list|(
name|isInst
argument_list|()
operator|&&
literal|"This is not a sub-instruction"
argument_list|)
expr_stmt|;
name|InstVal
operator|=
name|Val
expr_stmt|;
block|}
specifier|static
name|MCOperand
name|createReg
parameter_list|(
name|unsigned
name|Reg
parameter_list|)
block|{
name|MCOperand
name|Op
decl_stmt|;
name|Op
operator|.
name|Kind
operator|=
name|kRegister
expr_stmt|;
name|Op
operator|.
name|RegVal
operator|=
name|Reg
expr_stmt|;
return|return
name|Op
return|;
block|}
specifier|static
name|MCOperand
name|createImm
parameter_list|(
name|int64_t
name|Val
parameter_list|)
block|{
name|MCOperand
name|Op
decl_stmt|;
name|Op
operator|.
name|Kind
operator|=
name|kImmediate
expr_stmt|;
name|Op
operator|.
name|ImmVal
operator|=
name|Val
expr_stmt|;
return|return
name|Op
return|;
block|}
specifier|static
name|MCOperand
name|createFPImm
parameter_list|(
name|double
name|Val
parameter_list|)
block|{
name|MCOperand
name|Op
decl_stmt|;
name|Op
operator|.
name|Kind
operator|=
name|kFPImmediate
expr_stmt|;
name|Op
operator|.
name|FPImmVal
operator|=
name|Val
expr_stmt|;
return|return
name|Op
return|;
block|}
specifier|static
name|MCOperand
name|createExpr
parameter_list|(
specifier|const
name|MCExpr
modifier|*
name|Val
parameter_list|)
block|{
name|MCOperand
name|Op
decl_stmt|;
name|Op
operator|.
name|Kind
operator|=
name|kExpr
expr_stmt|;
name|Op
operator|.
name|ExprVal
operator|=
name|Val
expr_stmt|;
return|return
name|Op
return|;
block|}
specifier|static
name|MCOperand
name|createInst
parameter_list|(
specifier|const
name|MCInst
modifier|*
name|Val
parameter_list|)
block|{
name|MCOperand
name|Op
decl_stmt|;
name|Op
operator|.
name|Kind
operator|=
name|kInst
expr_stmt|;
name|Op
operator|.
name|InstVal
operator|=
name|Val
expr_stmt|;
return|return
name|Op
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|isPodLike
operator|<
name|MCOperand
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
comment|/// \brief Instances of this class represent a single low-level machine
comment|/// instruction.
name|class
name|MCInst
block|{
name|unsigned
name|Opcode
init|=
literal|0
decl_stmt|;
name|SMLoc
name|Loc
decl_stmt|;
name|SmallVector
operator|<
name|MCOperand
operator|,
literal|8
operator|>
name|Operands
expr_stmt|;
name|public
label|:
name|MCInst
argument_list|()
operator|=
expr|default
expr_stmt|;
name|void
name|setOpcode
parameter_list|(
name|unsigned
name|Op
parameter_list|)
block|{
name|Opcode
operator|=
name|Op
expr_stmt|;
block|}
name|unsigned
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opcode
return|;
block|}
name|void
name|setLoc
parameter_list|(
name|SMLoc
name|loc
parameter_list|)
block|{
name|Loc
operator|=
name|loc
expr_stmt|;
block|}
name|SMLoc
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
specifier|const
name|MCOperand
modifier|&
name|getOperand
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
name|MCOperand
modifier|&
name|getOperand
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|addOperand
parameter_list|(
specifier|const
name|MCOperand
modifier|&
name|Op
parameter_list|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
name|using
name|iterator
init|=
name|SmallVectorImpl
operator|<
name|MCOperand
operator|>
operator|::
name|iterator
decl_stmt|;
name|using
name|const_iterator
init|=
name|SmallVectorImpl
operator|<
name|MCOperand
operator|>
operator|::
name|const_iterator
decl_stmt|;
name|void
name|clear
parameter_list|()
block|{
name|Operands
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|erase
parameter_list|(
name|iterator
name|I
parameter_list|)
block|{
name|Operands
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Operands
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Operands
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|end
argument_list|()
return|;
block|}
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
specifier|const
name|MCOperand
modifier|&
name|Op
parameter_list|)
block|{
return|return
name|Operands
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|Op
argument_list|)
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Dump the MCInst as prettily as possible using the additional MC
comment|/// structures, if given. Operators are separated by the \p Separator
comment|/// string.
name|void
name|dump_pretty
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|MCInstPrinter
operator|*
name|Printer
operator|=
name|nullptr
argument_list|,
name|StringRef
name|Separator
operator|=
literal|" "
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|MCOperand
operator|&
name|MO
operator|)
block|{
name|MO
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|MCInst
operator|&
name|MI
operator|)
block|{
name|MI
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_MC_MCINST_H
end_comment

end_unit

