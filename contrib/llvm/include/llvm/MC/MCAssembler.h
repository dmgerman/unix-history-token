begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- MCAssembler.h - Object File Generation -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_MC_MCASSEMBLER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_MC_MCASSEMBLER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCDirectives.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCDwarf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCFixup.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCFragment.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCLinkerOptimizationHint.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCSymbol.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCAsmBackend
decl_stmt|;
name|class
name|MCAsmLayout
decl_stmt|;
name|class
name|MCContext
decl_stmt|;
name|class
name|MCCodeEmitter
decl_stmt|;
name|class
name|MCFragment
decl_stmt|;
name|class
name|MCObjectWriter
decl_stmt|;
name|class
name|MCSection
decl_stmt|;
name|class
name|MCValue
decl_stmt|;
comment|// FIXME: This really doesn't belong here. See comments below.
struct|struct
name|IndirectSymbolData
block|{
name|MCSymbol
modifier|*
name|Symbol
decl_stmt|;
name|MCSection
modifier|*
name|Section
decl_stmt|;
block|}
struct|;
comment|// FIXME: Ditto this. Purely so the Streamer and the ObjectWriter can talk
comment|// to one another.
struct|struct
name|DataRegionData
block|{
comment|// This enum should be kept in sync w/ the mach-o definition in
comment|// llvm/Object/MachOFormat.h.
enum|enum
name|KindTy
block|{
name|Data
init|=
literal|1
block|,
name|JumpTable8
block|,
name|JumpTable16
block|,
name|JumpTable32
block|}
name|Kind
enum|;
name|MCSymbol
modifier|*
name|Start
decl_stmt|;
name|MCSymbol
modifier|*
name|End
decl_stmt|;
block|}
struct|;
name|class
name|MCAssembler
block|{
name|friend
name|class
name|MCAsmLayout
decl_stmt|;
name|public
label|:
name|using
name|SectionListType
init|=
name|std
operator|::
name|vector
operator|<
name|MCSection
operator|*
operator|>
decl_stmt|;
name|using
name|SymbolDataListType
init|=
name|std
operator|::
name|vector
operator|<
specifier|const
name|MCSymbol
operator|*
operator|>
decl_stmt|;
name|using
name|const_iterator
init|=
name|pointee_iterator
operator|<
name|SectionListType
operator|::
name|const_iterator
operator|>
decl_stmt|;
name|using
name|iterator
init|=
name|pointee_iterator
operator|<
name|SectionListType
operator|::
name|iterator
operator|>
decl_stmt|;
name|using
name|const_symbol_iterator
init|=
name|pointee_iterator
operator|<
name|SymbolDataListType
operator|::
name|const_iterator
operator|>
decl_stmt|;
name|using
name|symbol_iterator
init|=
name|pointee_iterator
operator|<
name|SymbolDataListType
operator|::
name|iterator
operator|>
decl_stmt|;
name|using
name|symbol_range
init|=
name|iterator_range
operator|<
name|symbol_iterator
operator|>
decl_stmt|;
name|using
name|const_symbol_range
init|=
name|iterator_range
operator|<
name|const_symbol_iterator
operator|>
decl_stmt|;
name|using
name|const_indirect_symbol_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|IndirectSymbolData
operator|>
operator|::
name|const_iterator
decl_stmt|;
name|using
name|indirect_symbol_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|IndirectSymbolData
operator|>
operator|::
name|iterator
decl_stmt|;
name|using
name|const_data_region_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|DataRegionData
operator|>
operator|::
name|const_iterator
decl_stmt|;
name|using
name|data_region_iterator
init|=
name|std
operator|::
name|vector
operator|<
name|DataRegionData
operator|>
operator|::
name|iterator
decl_stmt|;
comment|/// MachO specific deployment target version info.
comment|// A Major version of 0 indicates that no version information was supplied
comment|// and so the corresponding load command should not be emitted.
name|using
name|VersionMinInfoType
init|= struct
block|{
name|MCVersionMinType
name|Kind
block|;
name|unsigned
name|Major
block|;
name|unsigned
name|Minor
block|;
name|unsigned
name|Update
block|;   }
decl_stmt|;
name|private
label|:
name|MCContext
modifier|&
name|Context
decl_stmt|;
name|MCAsmBackend
modifier|&
name|Backend
decl_stmt|;
name|MCCodeEmitter
modifier|&
name|Emitter
decl_stmt|;
name|MCObjectWriter
modifier|&
name|Writer
decl_stmt|;
name|SectionListType
name|Sections
decl_stmt|;
name|SymbolDataListType
name|Symbols
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|IndirectSymbolData
operator|>
name|IndirectSymbols
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|DataRegionData
operator|>
name|DataRegions
expr_stmt|;
comment|/// The list of linker options to propagate into the object file.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>>
name|LinkerOptions
expr_stmt|;
comment|/// List of declared file names
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|FileNames
expr_stmt|;
name|MCDwarfLineTableParams
name|LTParams
decl_stmt|;
comment|/// The set of function symbols for which a .thumb_func directive has
comment|/// been seen.
comment|//
comment|// FIXME: We really would like this in target specific code rather than
comment|// here. Maybe when the relocation stuff moves to target specific,
comment|// this can go with it? The streamer would need some target specific
comment|// refactoring too.
name|mutable
name|SmallPtrSet
operator|<
specifier|const
name|MCSymbol
operator|*
operator|,
literal|32
operator|>
name|ThumbFuncs
expr_stmt|;
comment|/// \brief The bundle alignment size currently set in the assembler.
comment|///
comment|/// By default it's 0, which means bundling is disabled.
name|unsigned
name|BundleAlignSize
decl_stmt|;
name|bool
name|RelaxAll
range|:
literal|1
decl_stmt|;
name|bool
name|SubsectionsViaSymbols
range|:
literal|1
decl_stmt|;
name|bool
name|IncrementalLinkerCompatible
range|:
literal|1
decl_stmt|;
comment|/// ELF specific e_header flags
comment|// It would be good if there were an MCELFAssembler class to hold this.
comment|// ELF header flags are used both by the integrated and standalone assemblers.
comment|// Access to the flags is necessary in cases where assembler directives affect
comment|// which flags to be set.
name|unsigned
name|ELFHeaderEFlags
decl_stmt|;
comment|/// Used to communicate Linker Optimization Hint information between
comment|/// the Streamer and the .o writer
name|MCLOHContainer
name|LOHContainer
decl_stmt|;
name|VersionMinInfoType
name|VersionMinInfo
decl_stmt|;
comment|/// Evaluate a fixup to a relocatable expression and the value which should be
comment|/// placed into the fixup.
comment|///
comment|/// \param Layout The layout to use for evaluation.
comment|/// \param Fixup The fixup to evaluate.
comment|/// \param DF The fragment the fixup is inside.
comment|/// \param Target [out] On return, the relocatable expression the fixup
comment|/// evaluates to.
comment|/// \param Value [out] On return, the value of the fixup as currently laid
comment|/// out.
comment|/// \return Whether the fixup value was fully resolved. This is true if the
comment|/// \p Value result is fixed, otherwise the value may change due to
comment|/// relocation.
name|bool
name|evaluateFixup
argument_list|(
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|,
specifier|const
name|MCFixup
operator|&
name|Fixup
argument_list|,
specifier|const
name|MCFragment
operator|*
name|DF
argument_list|,
name|MCValue
operator|&
name|Target
argument_list|,
name|uint64_t
operator|&
name|Value
argument_list|)
decl|const
decl_stmt|;
comment|/// Check whether a fixup can be satisfied, or whether it needs to be relaxed
comment|/// (increased in size, in order to hold its value correctly).
name|bool
name|fixupNeedsRelaxation
argument_list|(
specifier|const
name|MCFixup
operator|&
name|Fixup
argument_list|,
specifier|const
name|MCRelaxableFragment
operator|*
name|DF
argument_list|,
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|)
decl|const
decl_stmt|;
comment|/// Check whether the given fragment needs relaxation.
name|bool
name|fragmentNeedsRelaxation
argument_list|(
specifier|const
name|MCRelaxableFragment
operator|*
name|IF
argument_list|,
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Perform one layout iteration and return true if any offsets
comment|/// were adjusted.
name|bool
name|layoutOnce
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|)
function_decl|;
comment|/// \brief Perform one layout iteration of the given section and return true
comment|/// if any offsets were adjusted.
name|bool
name|layoutSectionOnce
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCSection
modifier|&
name|Sec
parameter_list|)
function_decl|;
name|bool
name|relaxInstruction
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCRelaxableFragment
modifier|&
name|IF
parameter_list|)
function_decl|;
name|bool
name|relaxLEB
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCLEBFragment
modifier|&
name|IF
parameter_list|)
function_decl|;
name|bool
name|relaxDwarfLineAddr
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCDwarfLineAddrFragment
modifier|&
name|DF
parameter_list|)
function_decl|;
name|bool
name|relaxDwarfCallFrameFragment
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCDwarfCallFrameFragment
modifier|&
name|DF
parameter_list|)
function_decl|;
name|bool
name|relaxCVInlineLineTable
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCCVInlineLineTableFragment
modifier|&
name|DF
parameter_list|)
function_decl|;
name|bool
name|relaxCVDefRange
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|,
name|MCCVDefRangeFragment
modifier|&
name|DF
parameter_list|)
function_decl|;
comment|/// finishLayout - Finalize a layout, including fragment lowering.
name|void
name|finishLayout
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|)
function_decl|;
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|bool
operator|>
name|handleFixup
argument_list|(
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|,
name|MCFragment
operator|&
name|F
argument_list|,
specifier|const
name|MCFixup
operator|&
name|Fixup
argument_list|)
expr_stmt|;
name|public
label|:
comment|/// Construct a new assembler instance.
comment|//
comment|// FIXME: How are we going to parameterize this? Two obvious options are stay
comment|// concrete and require clients to pass in a target like object. The other
comment|// option is to make this abstract, and have targets provide concrete
comment|// implementations as we do with AsmParser.
name|MCAssembler
argument_list|(
name|MCContext
operator|&
name|Context
argument_list|,
name|MCAsmBackend
operator|&
name|Backend
argument_list|,
name|MCCodeEmitter
operator|&
name|Emitter
argument_list|,
name|MCObjectWriter
operator|&
name|Writer
argument_list|)
expr_stmt|;
name|MCAssembler
argument_list|(
specifier|const
name|MCAssembler
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|MCAssembler
modifier|&
name|operator
init|=
operator|(
specifier|const
name|MCAssembler
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
operator|~
name|MCAssembler
argument_list|()
expr_stmt|;
comment|/// Compute the effective fragment size assuming it is laid out at the given
comment|/// \p SectionAddress and \p FragmentOffset.
name|uint64_t
name|computeFragmentSize
argument_list|(
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|,
specifier|const
name|MCFragment
operator|&
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// Find the symbol which defines the atom containing the given symbol, or
comment|/// null if there is no such symbol.
specifier|const
name|MCSymbol
modifier|*
name|getAtom
argument_list|(
specifier|const
name|MCSymbol
operator|&
name|S
argument_list|)
decl|const
decl_stmt|;
comment|/// Check whether a particular symbol is visible to the linker and is required
comment|/// in the symbol table, or whether it can be discarded by the assembler. This
comment|/// also effects whether the assembler treats the label as potentially
comment|/// defining a separate atom.
name|bool
name|isSymbolLinkerVisible
argument_list|(
specifier|const
name|MCSymbol
operator|&
name|SD
argument_list|)
decl|const
decl_stmt|;
comment|/// Emit the section contents using the given object writer.
name|void
name|writeSectionData
argument_list|(
specifier|const
name|MCSection
operator|*
name|Section
argument_list|,
specifier|const
name|MCAsmLayout
operator|&
name|Layout
argument_list|)
decl|const
decl_stmt|;
comment|/// Check whether a given symbol has been flagged with .thumb_func.
name|bool
name|isThumbFunc
argument_list|(
specifier|const
name|MCSymbol
operator|*
name|Func
argument_list|)
decl|const
decl_stmt|;
comment|/// Flag a function symbol as the target of a .thumb_func directive.
name|void
name|setIsThumbFunc
parameter_list|(
specifier|const
name|MCSymbol
modifier|*
name|Func
parameter_list|)
block|{
name|ThumbFuncs
operator|.
name|insert
argument_list|(
name|Func
argument_list|)
expr_stmt|;
block|}
comment|/// ELF e_header flags
name|unsigned
name|getELFHeaderEFlags
argument_list|()
specifier|const
block|{
return|return
name|ELFHeaderEFlags
return|;
block|}
name|void
name|setELFHeaderEFlags
parameter_list|(
name|unsigned
name|Flags
parameter_list|)
block|{
name|ELFHeaderEFlags
operator|=
name|Flags
expr_stmt|;
block|}
comment|/// MachO deployment target version information.
specifier|const
name|VersionMinInfoType
operator|&
name|getVersionMinInfo
argument_list|()
specifier|const
block|{
return|return
name|VersionMinInfo
return|;
block|}
name|void
name|setVersionMinInfo
parameter_list|(
name|MCVersionMinType
name|Kind
parameter_list|,
name|unsigned
name|Major
parameter_list|,
name|unsigned
name|Minor
parameter_list|,
name|unsigned
name|Update
parameter_list|)
block|{
name|VersionMinInfo
operator|.
name|Kind
operator|=
name|Kind
expr_stmt|;
name|VersionMinInfo
operator|.
name|Major
operator|=
name|Major
expr_stmt|;
name|VersionMinInfo
operator|.
name|Minor
operator|=
name|Minor
expr_stmt|;
name|VersionMinInfo
operator|.
name|Update
operator|=
name|Update
expr_stmt|;
block|}
comment|/// Reuse an assembler instance
comment|///
name|void
name|reset
parameter_list|()
function_decl|;
name|MCContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
name|MCAsmBackend
operator|&
name|getBackend
argument_list|()
specifier|const
block|{
return|return
name|Backend
return|;
block|}
name|MCCodeEmitter
operator|&
name|getEmitter
argument_list|()
specifier|const
block|{
return|return
name|Emitter
return|;
block|}
name|MCObjectWriter
operator|&
name|getWriter
argument_list|()
specifier|const
block|{
return|return
name|Writer
return|;
block|}
name|MCDwarfLineTableParams
name|getDWARFLinetableParams
argument_list|()
specifier|const
block|{
return|return
name|LTParams
return|;
block|}
name|void
name|setDWARFLinetableParams
parameter_list|(
name|MCDwarfLineTableParams
name|P
parameter_list|)
block|{
name|LTParams
operator|=
name|P
expr_stmt|;
block|}
comment|/// Finish - Do final processing and write the object to the output stream.
comment|/// \p Writer is used for custom object writer (as the MCJIT does),
comment|/// if not specified it is automatically created from backend.
name|void
name|Finish
parameter_list|()
function_decl|;
comment|// Layout all section and prepare them for emission.
name|void
name|layout
parameter_list|(
name|MCAsmLayout
modifier|&
name|Layout
parameter_list|)
function_decl|;
comment|// FIXME: This does not belong here.
name|bool
name|getSubsectionsViaSymbols
argument_list|()
specifier|const
block|{
return|return
name|SubsectionsViaSymbols
return|;
block|}
name|void
name|setSubsectionsViaSymbols
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|SubsectionsViaSymbols
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isIncrementalLinkerCompatible
argument_list|()
specifier|const
block|{
return|return
name|IncrementalLinkerCompatible
return|;
block|}
name|void
name|setIncrementalLinkerCompatible
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|IncrementalLinkerCompatible
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|getRelaxAll
argument_list|()
specifier|const
block|{
return|return
name|RelaxAll
return|;
block|}
name|void
name|setRelaxAll
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|RelaxAll
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isBundlingEnabled
argument_list|()
specifier|const
block|{
return|return
name|BundleAlignSize
operator|!=
literal|0
return|;
block|}
name|unsigned
name|getBundleAlignSize
argument_list|()
specifier|const
block|{
return|return
name|BundleAlignSize
return|;
block|}
name|void
name|setBundleAlignSize
parameter_list|(
name|unsigned
name|Size
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|Size
operator|==
literal|0
operator|||
operator|!
operator|(
name|Size
operator|&
operator|(
name|Size
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
literal|"Expect a power-of-two bundle align size"
argument_list|)
expr_stmt|;
name|BundleAlignSize
operator|=
name|Size
expr_stmt|;
block|}
comment|/// \name Section List Access
comment|/// @{
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Sections
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Sections
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Sections
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Sections
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Sections
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// @}
comment|/// \name Symbol List Access
comment|/// @{
name|symbol_iterator
name|symbol_begin
parameter_list|()
block|{
return|return
name|Symbols
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_symbol_iterator
name|symbol_begin
argument_list|()
specifier|const
block|{
return|return
name|Symbols
operator|.
name|begin
argument_list|()
return|;
block|}
name|symbol_iterator
name|symbol_end
parameter_list|()
block|{
return|return
name|Symbols
operator|.
name|end
argument_list|()
return|;
block|}
name|const_symbol_iterator
name|symbol_end
argument_list|()
specifier|const
block|{
return|return
name|Symbols
operator|.
name|end
argument_list|()
return|;
block|}
name|symbol_range
name|symbols
parameter_list|()
block|{
return|return
name|make_range
argument_list|(
name|symbol_begin
argument_list|()
argument_list|,
name|symbol_end
argument_list|()
argument_list|)
return|;
block|}
name|const_symbol_range
name|symbols
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|symbol_begin
argument_list|()
argument_list|,
name|symbol_end
argument_list|()
argument_list|)
return|;
block|}
name|size_t
name|symbol_size
argument_list|()
specifier|const
block|{
return|return
name|Symbols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// @}
comment|/// \name Indirect Symbol List Access
comment|/// @{
comment|// FIXME: This is a total hack, this should not be here. Once things are
comment|// factored so that the streamer has direct access to the .o writer, it can
comment|// disappear.
name|std
operator|::
name|vector
operator|<
name|IndirectSymbolData
operator|>
operator|&
name|getIndirectSymbols
argument_list|()
block|{
return|return
name|IndirectSymbols
return|;
block|}
name|indirect_symbol_iterator
name|indirect_symbol_begin
parameter_list|()
block|{
return|return
name|IndirectSymbols
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_indirect_symbol_iterator
name|indirect_symbol_begin
argument_list|()
specifier|const
block|{
return|return
name|IndirectSymbols
operator|.
name|begin
argument_list|()
return|;
block|}
name|indirect_symbol_iterator
name|indirect_symbol_end
parameter_list|()
block|{
return|return
name|IndirectSymbols
operator|.
name|end
argument_list|()
return|;
block|}
name|const_indirect_symbol_iterator
name|indirect_symbol_end
argument_list|()
specifier|const
block|{
return|return
name|IndirectSymbols
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|indirect_symbol_size
argument_list|()
specifier|const
block|{
return|return
name|IndirectSymbols
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// @}
comment|/// \name Linker Option List Access
comment|/// @{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>>
operator|&
name|getLinkerOptions
argument_list|()
block|{
return|return
name|LinkerOptions
return|;
block|}
comment|/// @}
comment|/// \name Data Region List Access
comment|/// @{
comment|// FIXME: This is a total hack, this should not be here. Once things are
comment|// factored so that the streamer has direct access to the .o writer, it can
comment|// disappear.
name|std
operator|::
name|vector
operator|<
name|DataRegionData
operator|>
operator|&
name|getDataRegions
argument_list|()
block|{
return|return
name|DataRegions
return|;
block|}
name|data_region_iterator
name|data_region_begin
parameter_list|()
block|{
return|return
name|DataRegions
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_data_region_iterator
name|data_region_begin
argument_list|()
specifier|const
block|{
return|return
name|DataRegions
operator|.
name|begin
argument_list|()
return|;
block|}
name|data_region_iterator
name|data_region_end
parameter_list|()
block|{
return|return
name|DataRegions
operator|.
name|end
argument_list|()
return|;
block|}
name|const_data_region_iterator
name|data_region_end
argument_list|()
specifier|const
block|{
return|return
name|DataRegions
operator|.
name|end
argument_list|()
return|;
block|}
name|size_t
name|data_region_size
argument_list|()
specifier|const
block|{
return|return
name|DataRegions
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// @}
comment|/// \name Data Region List Access
comment|/// @{
comment|// FIXME: This is a total hack, this should not be here. Once things are
comment|// factored so that the streamer has direct access to the .o writer, it can
comment|// disappear.
name|MCLOHContainer
modifier|&
name|getLOHContainer
parameter_list|()
block|{
return|return
name|LOHContainer
return|;
block|}
specifier|const
name|MCLOHContainer
operator|&
name|getLOHContainer
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MCAssembler
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getLOHContainer
argument_list|()
return|;
block|}
comment|/// @}
comment|/// \name Backend Data Access
comment|/// @{
name|bool
name|registerSection
parameter_list|(
name|MCSection
modifier|&
name|Section
parameter_list|)
function_decl|;
name|void
name|registerSymbol
parameter_list|(
specifier|const
name|MCSymbol
modifier|&
name|Symbol
parameter_list|,
name|bool
modifier|*
name|Created
init|=
name|nullptr
parameter_list|)
function_decl|;
name|ArrayRef
operator|<
name|std
operator|::
name|string
operator|>
name|getFileNames
argument_list|()
block|{
return|return
name|FileNames
return|;
block|}
name|void
name|addFileName
parameter_list|(
name|StringRef
name|FileName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_contained
argument_list|(
name|FileNames
argument_list|,
name|FileName
argument_list|)
condition|)
name|FileNames
operator|.
name|push_back
argument_list|(
name|FileName
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Write the necessary bundle padding to the given object writer.
comment|/// Expects a fragment \p F containing instructions and its size \p FSize.
name|void
name|writeFragmentPadding
argument_list|(
specifier|const
name|MCFragment
operator|&
name|F
argument_list|,
name|uint64_t
name|FSize
argument_list|,
name|MCObjectWriter
operator|*
name|OW
argument_list|)
decl|const
decl_stmt|;
comment|/// @}
name|void
name|dump
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// \brief Compute the amount of padding required before the fragment \p F to
comment|/// obey bundling restrictions, where \p FOffset is the fragment's offset in
comment|/// its section and \p FSize is the fragment's size.
name|uint64_t
name|computeBundlePadding
parameter_list|(
specifier|const
name|MCAssembler
modifier|&
name|Assembler
parameter_list|,
specifier|const
name|MCFragment
modifier|*
name|F
parameter_list|,
name|uint64_t
name|FOffset
parameter_list|,
name|uint64_t
name|FSize
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_MC_MCASSEMBLER_H
end_comment

end_unit

