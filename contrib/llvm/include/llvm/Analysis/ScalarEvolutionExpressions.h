begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/ScalarEvolutionExpressions.h - SCEV Exprs --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to represent and build scalar expressions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_SCALAREVOLUTION_EXPRESSIONS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_SCALAREVOLUTION_EXPRESSIONS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolution.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantInt
decl_stmt|;
name|class
name|ConstantRange
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
enum|enum
name|SCEVTypes
block|{
comment|// These should be ordered in terms of increasing complexity to make the
comment|// folders simpler.
name|scConstant
block|,
name|scTruncate
block|,
name|scZeroExtend
block|,
name|scSignExtend
block|,
name|scAddExpr
block|,
name|scMulExpr
block|,
name|scUDivExpr
block|,
name|scAddRecExpr
block|,
name|scUMaxExpr
block|,
name|scSMaxExpr
block|,
name|scUnknown
block|,
name|scCouldNotCompute
block|}
enum|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVConstant - This class represents a constant integer value.
comment|///
name|class
name|SCEVConstant
range|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|ConstantInt
operator|*
name|V
block|;
name|SCEVConstant
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|ConstantInt *v
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scConstant
argument_list|)
block|,
name|V
argument_list|(
argument|v
argument_list|)
block|{}
name|public
operator|:
name|ConstantInt
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVConstant *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scConstant
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVCastExpr - This is the base class for unary cast operator classes.
comment|///
name|class
name|SCEVCastExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
specifier|const
name|SCEV
operator|*
name|Op
block|;
name|Type
operator|*
name|Ty
block|;
name|SCEVCastExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|unsigned SCEVTy
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVCastExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVTruncateExpr - This class represents a truncation of an integer value
comment|/// to a smaller integer value.
comment|///
name|class
name|SCEVTruncateExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVTruncateExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVTruncateExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVZeroExtendExpr - This class represents a zero extension of a small
comment|/// integer value to a larger integer value.
comment|///
name|class
name|SCEVZeroExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVZeroExtendExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVZeroExtendExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVSignExtendExpr - This class represents a sign extension of a small
comment|/// integer value to a larger integer value.
comment|///
name|class
name|SCEVSignExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVSignExtendExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVSignExtendExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVNAryExpr - This node is a base class providing common
comment|/// functionality for n'ary operators.
comment|///
name|class
name|SCEVNAryExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
comment|// Since SCEVs are immutable, ScalarEvolution allocates operand
comment|// arrays with its SCEVAllocator, so this class just needs a simple
comment|// pointer rather than a more elaborate vector-like data structure.
comment|// This also avoids the need for a non-trivial destructor.
specifier|const
name|SCEV
operator|*
specifier|const
operator|*
name|Operands
block|;
name|size_t
name|NumOperands
block|;
name|SCEVNAryExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|enum SCEVTypes T
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|T
argument_list|)
block|,
name|Operands
argument_list|(
name|O
argument_list|)
block|,
name|NumOperands
argument_list|(
argument|N
argument_list|)
block|{}
name|public
operator|:
name|size_t
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
specifier|const
name|SCEV
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumOperands
operator|&&
literal|"Operand index out of range!"
argument_list|)
block|;
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
typedef|typedef
specifier|const
name|SCEV
modifier|*
specifier|const
modifier|*
name|op_iterator
typedef|;
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|Operands
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|+
name|NumOperands
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
return|;
block|}
name|NoWrapFlags
name|getNoWrapFlags
argument_list|(
argument|NoWrapFlags Mask = NoWrapMask
argument_list|)
specifier|const
block|{
return|return
call|(
name|NoWrapFlags
call|)
argument_list|(
name|SubclassData
operator|&
name|Mask
argument_list|)
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVNAryExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVCommutativeExpr - This node is the base class for n'ary commutative
comment|/// operators.
comment|///
name|class
name|SCEVCommutativeExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|protected
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|enum SCEVTypes T
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
argument|ID
argument_list|,
argument|T
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{}
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVCommutativeExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
comment|/// Set flags for a non-recurrence without clearing previously set flags.
name|void
name|setNoWrapFlags
argument_list|(
argument|NoWrapFlags Flags
argument_list|)
block|{
name|SubclassData
operator||=
name|Flags
block|;     }
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVAddExpr - This node represents an addition of some number of SCEVs.
comment|///
name|class
name|SCEVAddExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVAddExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scAddExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{     }
name|public
operator|:
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
comment|// Use the type of the last operand, which is likely to be a pointer
comment|// type, if there is one. This doesn't usually matter, but it can help
comment|// reduce casts when the expressions are expanded.
return|return
name|getOperand
argument_list|(
name|getNumOperands
argument_list|()
operator|-
literal|1
argument_list|)
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVAddExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVMulExpr - This node represents multiplication of some number of SCEVs.
comment|///
name|class
name|SCEVMulExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVMulExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scMulExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVMulExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUDivExpr - This class represents a binary unsigned division operation.
comment|///
name|class
name|SCEVUDivExpr
operator|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
specifier|const
name|SCEV
operator|*
name|LHS
block|;
specifier|const
name|SCEV
operator|*
name|RHS
block|;
name|SCEVUDivExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *lhs
argument_list|,
argument|const SCEV *rhs
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scUDivExpr
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
specifier|const
name|SCEV
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
comment|// In most cases the types of LHS and RHS will be the same, but in some
comment|// crazy cases one or the other may be a pointer. ScalarEvolution doesn't
comment|// depend on the type for correctness, but handling types carefully can
comment|// avoid extra casts in the SCEVExpander. The LHS is more likely to be
comment|// a pointer type than the RHS, so use the RHS' type here.
return|return
name|getRHS
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUDivExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUDivExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVAddRecExpr - This node represents a polynomial recurrence on the trip
comment|/// count of the specified loop.  This is the primary focus of the
comment|/// ScalarEvolution framework; all the other SCEV subclasses are mostly just
comment|/// supporting infrastructure to allow SCEVAddRecExpr expressions to be
comment|/// created and analyzed.
comment|///
comment|/// All operands of an AddRec are required to be loop invariant.
comment|///
name|class
name|SCEVAddRecExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
specifier|const
name|Loop
operator|*
name|L
block|;
name|SCEVAddRecExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|,
argument|const Loop *l
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
name|ID
argument_list|,
name|scAddRecExpr
argument_list|,
name|O
argument_list|,
name|N
argument_list|)
block|,
name|L
argument_list|(
argument|l
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Operands
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|Loop
operator|*
name|getLoop
argument_list|()
specifier|const
block|{
return|return
name|L
return|;
block|}
comment|/// getStepRecurrence - This method constructs and returns the recurrence
comment|/// indicating how much this expression steps by.  If this is a polynomial
comment|/// of degree N, it returns a chrec of degree N-1.
comment|/// We cannot determine whether the step recurrence has self-wraparound.
specifier|const
name|SCEV
operator|*
name|getStepRecurrence
argument_list|(
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
if|if
condition|(
name|isAffine
argument_list|()
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|SE
operator|.
name|getAddRecExpr
argument_list|(
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
argument_list|,
literal|3
operator|>
operator|(
name|op_begin
argument_list|()
operator|+
literal|1
expr|,
name|op_end
argument_list|()
operator|)
argument_list|,
name|getLoop
argument_list|()
argument_list|,
name|FlagAnyWrap
argument_list|)
return|;
block|}
comment|/// isAffine - Return true if this is an affine AddRec (i.e., it represents
comment|/// an expressions A+B*x where A and B are loop invariant values.
name|bool
name|isAffine
argument_list|()
specifier|const
block|{
comment|// We know that the start value is invariant.  This expression is thus
comment|// affine iff the step is also invariant.
return|return
name|getNumOperands
argument_list|()
operator|==
literal|2
return|;
block|}
comment|/// isQuadratic - Return true if this is an quadratic AddRec (i.e., it
comment|/// represents an expressions A+B*x+C*x^2 where A, B and C are loop
comment|/// invariant values.  This corresponds to an addrec of the form {L,+,M,+,N}
name|bool
name|isQuadratic
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|==
literal|3
return|;
block|}
comment|/// Set flags for a recurrence without clearing any previously set flags.
comment|/// For AddRec, either NUW or NSW implies NW. Keep track of this fact here
comment|/// to make it easier to propagate flags.
name|void
name|setNoWrapFlags
argument_list|(
argument|NoWrapFlags Flags
argument_list|)
block|{
if|if
condition|(
name|Flags
operator|&
operator|(
name|FlagNUW
operator||
name|FlagNSW
operator|)
condition|)
name|Flags
operator|=
name|ScalarEvolution
operator|::
name|setFlags
argument_list|(
name|Flags
argument_list|,
name|FlagNW
argument_list|)
expr_stmt|;
name|SubclassData
operator||=
name|Flags
block|;     }
comment|/// evaluateAtIteration - Return the value of this chain of recurrences at
comment|/// the specified iteration number.
specifier|const
name|SCEV
operator|*
name|evaluateAtIteration
argument_list|(
argument|const SCEV *It
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
comment|/// getNumIterationsInRange - Return the number of iterations of this loop
comment|/// that produce values in the specified constant range.  Another way of
comment|/// looking at this is that it returns the first iteration number where the
comment|/// value is not in the condition, thus computing the exit count.  If the
comment|/// iteration count can't be computed, an instance of SCEVCouldNotCompute is
comment|/// returned.
specifier|const
name|SCEV
operator|*
name|getNumIterationsInRange
argument_list|(
argument|ConstantRange Range
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
comment|/// getPostIncExpr - Return an expression representing the value of
comment|/// this expression one iteration of the loop ahead.
specifier|const
name|SCEVAddRecExpr
operator|*
name|getPostIncExpr
argument_list|(
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|SCEVAddRecExpr
operator|>
operator|(
name|SE
operator|.
name|getAddExpr
argument_list|(
name|this
argument_list|,
name|getStepRecurrence
argument_list|(
name|SE
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVAddRecExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVSMaxExpr - This class represents a signed maximum selection.
comment|///
name|class
name|SCEVSMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVSMaxExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scSMaxExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{
comment|// Max never overflows.
name|setNoWrapFlags
argument_list|(
call|(
name|NoWrapFlags
call|)
argument_list|(
name|FlagNUW
operator||
name|FlagNSW
argument_list|)
argument_list|)
block|;     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVSMaxExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUMaxExpr - This class represents an unsigned maximum selection.
comment|///
name|class
name|SCEVUMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVUMaxExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scUMaxExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{
comment|// Max never overflows.
name|setNoWrapFlags
argument_list|(
call|(
name|NoWrapFlags
call|)
argument_list|(
name|FlagNUW
operator||
name|FlagNSW
argument_list|)
argument_list|)
block|;     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUMaxExpr *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
expr|}
block|;
comment|//===--------------------------------------------------------------------===//
comment|/// SCEVUnknown - This means that we are dealing with an entirely unknown SCEV
comment|/// value, and only represent it as its LLVM Value.  This is the "bottom"
comment|/// value for the analysis.
comment|///
name|class
name|SCEVUnknown
operator|:
name|public
name|SCEV
block|,
name|private
name|CallbackVH
block|{
name|friend
name|class
name|ScalarEvolution
block|;
comment|// Implement CallbackVH.
name|virtual
name|void
name|deleted
argument_list|()
block|;
name|virtual
name|void
name|allUsesReplacedWith
argument_list|(
name|Value
operator|*
name|New
argument_list|)
block|;
comment|/// SE - The parent ScalarEvolution value. This is used to update
comment|/// the parent's maps when the value associated with a SCEVUnknown
comment|/// is deleted or RAUW'd.
name|ScalarEvolution
operator|*
name|SE
block|;
comment|/// Next - The next pointer in the linked list of all
comment|/// SCEVUnknown instances owned by a ScalarEvolution.
name|SCEVUnknown
operator|*
name|Next
block|;
name|SCEVUnknown
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|Value *V
argument_list|,
argument|ScalarEvolution *se
argument_list|,
argument|SCEVUnknown *next
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scUnknown
argument_list|)
block|,
name|CallbackVH
argument_list|(
name|V
argument_list|)
block|,
name|SE
argument_list|(
name|se
argument_list|)
block|,
name|Next
argument_list|(
argument|next
argument_list|)
block|{}
name|public
operator|:
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
comment|/// isSizeOf, isAlignOf, isOffsetOf - Test whether this is a special
comment|/// constant representing a type size, alignment, or field offset in
comment|/// a target-independent manner, and hasn't happened to have been
comment|/// folded with other operations into something unrecognizable. This
comment|/// is mainly only useful for pretty-printing and other situations
comment|/// where it isn't absolutely required for these to succeed.
name|bool
name|isSizeOf
argument_list|(
argument|Type *&AllocTy
argument_list|)
specifier|const
block|;
name|bool
name|isAlignOf
argument_list|(
argument|Type *&AllocTy
argument_list|)
specifier|const
block|;
name|bool
name|isOffsetOf
argument_list|(
argument|Type *&STy
argument_list|,
argument|Constant *&FieldNo
argument_list|)
specifier|const
block|;
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEVUnknown *S
argument_list|)
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUnknown
return|;
block|}
expr|}
block|;
comment|/// SCEVVisitor - This class defines a simple visitor class that may be used
comment|/// for various SCEV analysis purposes.
name|template
operator|<
name|typename
name|SC
block|,
name|typename
name|RetVal
operator|=
name|void
operator|>
expr|struct
name|SCEVVisitor
block|{
name|RetVal
name|visit
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
switch|switch
condition|(
name|S
operator|->
name|getSCEVType
argument_list|()
condition|)
block|{
case|case
name|scConstant
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitConstant
argument_list|(
operator|(
specifier|const
name|SCEVConstant
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scTruncate
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitTruncateExpr
argument_list|(
operator|(
specifier|const
name|SCEVTruncateExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scZeroExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitZeroExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVZeroExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSignExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSignExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVSignExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scMulExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitMulExpr
argument_list|(
operator|(
specifier|const
name|SCEVMulExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUDivExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUDivExpr
argument_list|(
operator|(
specifier|const
name|SCEVUDivExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddRecExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddRecExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddRecExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVSMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVUMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUnknown
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUnknown
argument_list|(
operator|(
specifier|const
name|SCEVUnknown
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scCouldNotCompute
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitCouldNotCompute
argument_list|(
operator|(
specifier|const
name|SCEVCouldNotCompute
operator|*
operator|)
name|S
argument_list|)
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown SCEV type!"
argument_list|)
expr_stmt|;
block|}
block|}
name|RetVal
name|visitCouldNotCompute
argument_list|(
argument|const SCEVCouldNotCompute *S
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Invalid use of SCEVCouldNotCompute!"
argument_list|)
block|;     }
block|}
block|;
comment|/// Visit all nodes in the expression tree using worklist traversal.
comment|///
comment|/// Visitor implements:
comment|///   // return true to follow this node.
comment|///   bool follow(const SCEV *S);
comment|///   // return true to terminate the search.
comment|///   bool isDone();
name|template
operator|<
name|typename
name|SV
operator|>
name|class
name|SCEVTraversal
block|{
name|SV
operator|&
name|Visitor
block|;
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|8
operator|>
name|Worklist
block|;
name|SmallPtrSet
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|8
operator|>
name|Visited
block|;
name|void
name|push
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|S
argument_list|)
operator|&&
name|Visitor
operator|.
name|follow
argument_list|(
name|S
argument_list|)
condition|)
name|Worklist
operator|.
name|push_back
argument_list|(
name|S
argument_list|)
expr_stmt|;
block|}
name|public
operator|:
name|SCEVTraversal
argument_list|(
name|SV
operator|&
name|V
argument_list|)
operator|:
name|Visitor
argument_list|(
argument|V
argument_list|)
block|{}
name|void
name|visitAll
argument_list|(
argument|const SCEV *Root
argument_list|)
block|{
name|push
argument_list|(
name|Root
argument_list|)
block|;
while|while
condition|(
operator|!
name|Worklist
operator|.
name|empty
argument_list|()
operator|&&
operator|!
name|Visitor
operator|.
name|isDone
argument_list|()
condition|)
block|{
specifier|const
name|SCEV
modifier|*
name|S
init|=
name|Worklist
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|S
operator|->
name|getSCEVType
argument_list|()
condition|)
block|{
case|case
name|scConstant
case|:
case|case
name|scUnknown
case|:
break|break;
case|case
name|scTruncate
case|:
case|case
name|scZeroExtend
case|:
case|case
name|scSignExtend
case|:
name|push
argument_list|(
name|cast
operator|<
name|SCEVCastExpr
operator|>
operator|(
name|S
operator|)
operator|->
name|getOperand
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|scAddExpr
case|:
case|case
name|scMulExpr
case|:
case|case
name|scSMaxExpr
case|:
case|case
name|scUMaxExpr
case|:
case|case
name|scAddRecExpr
case|:
block|{
specifier|const
name|SCEVNAryExpr
modifier|*
name|NAry
init|=
name|cast
operator|<
name|SCEVNAryExpr
operator|>
operator|(
name|S
operator|)
decl_stmt|;
for|for
control|(
name|SCEVNAryExpr
operator|::
name|op_iterator
name|I
operator|=
name|NAry
operator|->
name|op_begin
argument_list|()
init|,
name|E
operator|=
name|NAry
operator|->
name|op_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|push
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|scUDivExpr
case|:
block|{
specifier|const
name|SCEVUDivExpr
modifier|*
name|UDiv
init|=
name|cast
operator|<
name|SCEVUDivExpr
operator|>
operator|(
name|S
operator|)
decl_stmt|;
name|push
argument_list|(
name|UDiv
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|UDiv
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|scCouldNotCompute
case|:
name|llvm_unreachable
argument_list|(
literal|"Attempt to use a SCEVCouldNotCompute object!"
argument_list|)
expr_stmt|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown SCEV kind!"
argument_list|)
expr_stmt|;
block|}
block|}
expr|}   }
block|;
comment|/// Use SCEVTraversal to visit all nodes in the givien expression tree.
name|template
operator|<
name|typename
name|SV
operator|>
name|void
name|visitAll
argument_list|(
argument|const SCEV *Root
argument_list|,
argument|SV& Visitor
argument_list|)
block|{
name|SCEVTraversal
operator|<
name|SV
operator|>
name|T
argument_list|(
name|Visitor
argument_list|)
block|;
name|T
operator|.
name|visitAll
argument_list|(
name|Root
argument_list|)
block|;   }
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

