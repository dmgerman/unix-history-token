begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/ScalarEvolutionExpressions.h - SCEV Exprs --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to represent and build scalar expressions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_SCALAREVOLUTIONEXPRESSIONS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_SCALAREVOLUTIONEXPRESSIONS_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator_range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolution.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantInt
decl_stmt|;
name|class
name|ConstantRange
decl_stmt|;
name|class
name|DominatorTree
decl_stmt|;
enum|enum
name|SCEVTypes
block|{
comment|// These should be ordered in terms of increasing complexity to make the
comment|// folders simpler.
name|scConstant
block|,
name|scTruncate
block|,
name|scZeroExtend
block|,
name|scSignExtend
block|,
name|scAddExpr
block|,
name|scMulExpr
block|,
name|scUDivExpr
block|,
name|scAddRecExpr
block|,
name|scUMaxExpr
block|,
name|scSMaxExpr
block|,
name|scUnknown
block|,
name|scCouldNotCompute
block|}
enum|;
comment|/// This class represents a constant integer value.
name|class
name|SCEVConstant
range|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|ConstantInt
operator|*
name|V
block|;
name|SCEVConstant
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|ConstantInt *v
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scConstant
argument_list|)
block|,
name|V
argument_list|(
argument|v
argument_list|)
block|{}
name|public
operator|:
name|ConstantInt
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|V
return|;
block|}
specifier|const
name|APInt
operator|&
name|getAPInt
argument_list|()
specifier|const
block|{
return|return
name|getValue
argument_list|()
operator|->
name|getValue
argument_list|()
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|V
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scConstant
return|;
block|}
expr|}
block|;
comment|/// This is the base class for unary cast operator classes.
name|class
name|SCEVCastExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
specifier|const
name|SCEV
operator|*
name|Op
block|;
name|Type
operator|*
name|Ty
block|;
name|SCEVCastExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|unsigned SCEVTy
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getOperand
argument_list|()
specifier|const
block|{
return|return
name|Op
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|/// This class represents a truncation of an integer value to a
comment|/// smaller integer value.
name|class
name|SCEVTruncateExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVTruncateExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scTruncate
return|;
block|}
expr|}
block|;
comment|/// This class represents a zero extension of a small integer value
comment|/// to a larger integer value.
name|class
name|SCEVZeroExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVZeroExtendExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scZeroExtend
return|;
block|}
expr|}
block|;
comment|/// This class represents a sign extension of a small integer value
comment|/// to a larger integer value.
name|class
name|SCEVSignExtendExpr
operator|:
name|public
name|SCEVCastExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVSignExtendExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *op
argument_list|,
argument|Type *ty
argument_list|)
block|;
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSignExtend
return|;
block|}
expr|}
block|;
comment|/// This node is a base class providing common functionality for
comment|/// n'ary operators.
name|class
name|SCEVNAryExpr
operator|:
name|public
name|SCEV
block|{
name|protected
operator|:
comment|// Since SCEVs are immutable, ScalarEvolution allocates operand
comment|// arrays with its SCEVAllocator, so this class just needs a simple
comment|// pointer rather than a more elaborate vector-like data structure.
comment|// This also avoids the need for a non-trivial destructor.
specifier|const
name|SCEV
operator|*
specifier|const
operator|*
name|Operands
block|;
name|size_t
name|NumOperands
block|;
name|SCEVNAryExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|enum SCEVTypes T
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|T
argument_list|)
block|,
name|Operands
argument_list|(
name|O
argument_list|)
block|,
name|NumOperands
argument_list|(
argument|N
argument_list|)
block|{}
name|public
operator|:
name|size_t
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
specifier|const
name|SCEV
operator|*
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumOperands
operator|&&
literal|"Operand index out of range!"
argument_list|)
block|;
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
typedef|typedef
specifier|const
name|SCEV
modifier|*
specifier|const
modifier|*
name|op_iterator
typedef|;
typedef|typedef
name|iterator_range
operator|<
name|op_iterator
operator|>
name|op_range
expr_stmt|;
name|op_iterator
name|op_begin
argument_list|()
specifier|const
block|{
return|return
name|Operands
return|;
block|}
name|op_iterator
name|op_end
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|+
name|NumOperands
return|;
block|}
name|op_range
name|operands
argument_list|()
specifier|const
block|{
return|return
name|make_range
argument_list|(
name|op_begin
argument_list|()
argument_list|,
name|op_end
argument_list|()
argument_list|)
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
return|;
block|}
name|NoWrapFlags
name|getNoWrapFlags
argument_list|(
argument|NoWrapFlags Mask = NoWrapMask
argument_list|)
specifier|const
block|{
return|return
call|(
name|NoWrapFlags
call|)
argument_list|(
name|SubclassData
operator|&
name|Mask
argument_list|)
return|;
block|}
name|bool
name|hasNoUnsignedWrap
argument_list|()
specifier|const
block|{
return|return
name|getNoWrapFlags
argument_list|(
name|FlagNUW
argument_list|)
operator|!=
name|FlagAnyWrap
return|;
block|}
name|bool
name|hasNoSignedWrap
argument_list|()
specifier|const
block|{
return|return
name|getNoWrapFlags
argument_list|(
name|FlagNSW
argument_list|)
operator|!=
name|FlagAnyWrap
return|;
block|}
name|bool
name|hasNoSelfWrap
argument_list|()
specifier|const
block|{
return|return
name|getNoWrapFlags
argument_list|(
name|FlagNW
argument_list|)
operator|!=
name|FlagAnyWrap
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|/// This node is the base class for n'ary commutative operators.
name|class
name|SCEVCommutativeExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|protected
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|enum SCEVTypes T
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
argument|ID
argument_list|,
argument|T
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{}
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
operator|||
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
comment|/// Set flags for a non-recurrence without clearing previously set flags.
name|void
name|setNoWrapFlags
argument_list|(
argument|NoWrapFlags Flags
argument_list|)
block|{
name|SubclassData
operator||=
name|Flags
block|;     }
expr|}
block|;
comment|/// This node represents an addition of some number of SCEVs.
name|class
name|SCEVAddExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVAddExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scAddExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{     }
name|public
operator|:
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
comment|// Use the type of the last operand, which is likely to be a pointer
comment|// type, if there is one. This doesn't usually matter, but it can help
comment|// reduce casts when the expressions are expanded.
return|return
name|getOperand
argument_list|(
name|getNumOperands
argument_list|()
operator|-
literal|1
argument_list|)
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddExpr
return|;
block|}
expr|}
block|;
comment|/// This node represents multiplication of some number of SCEVs.
name|class
name|SCEVMulExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVMulExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scMulExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scMulExpr
return|;
block|}
expr|}
block|;
comment|/// This class represents a binary unsigned division operation.
name|class
name|SCEVUDivExpr
operator|:
name|public
name|SCEV
block|{
name|friend
name|class
name|ScalarEvolution
block|;
specifier|const
name|SCEV
operator|*
name|LHS
block|;
specifier|const
name|SCEV
operator|*
name|RHS
block|;
name|SCEVUDivExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *lhs
argument_list|,
argument|const SCEV *rhs
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scUDivExpr
argument_list|)
block|,
name|LHS
argument_list|(
name|lhs
argument_list|)
block|,
name|RHS
argument_list|(
argument|rhs
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|LHS
return|;
block|}
specifier|const
name|SCEV
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|RHS
return|;
block|}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
comment|// In most cases the types of LHS and RHS will be the same, but in some
comment|// crazy cases one or the other may be a pointer. ScalarEvolution doesn't
comment|// depend on the type for correctness, but handling types carefully can
comment|// avoid extra casts in the SCEVExpander. The LHS is more likely to be
comment|// a pointer type than the RHS, so use the RHS' type here.
return|return
name|getRHS
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUDivExpr
return|;
block|}
expr|}
block|;
comment|/// This node represents a polynomial recurrence on the trip count
comment|/// of the specified loop.  This is the primary focus of the
comment|/// ScalarEvolution framework; all the other SCEV subclasses are
comment|/// mostly just supporting infrastructure to allow SCEVAddRecExpr
comment|/// expressions to be created and analyzed.
comment|///
comment|/// All operands of an AddRec are required to be loop invariant.
comment|///
name|class
name|SCEVAddRecExpr
operator|:
name|public
name|SCEVNAryExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
specifier|const
name|Loop
operator|*
name|L
block|;
name|SCEVAddRecExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|,
argument|const Loop *l
argument_list|)
operator|:
name|SCEVNAryExpr
argument_list|(
name|ID
argument_list|,
name|scAddRecExpr
argument_list|,
name|O
argument_list|,
name|N
argument_list|)
block|,
name|L
argument_list|(
argument|l
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SCEV
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Operands
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|Loop
operator|*
name|getLoop
argument_list|()
specifier|const
block|{
return|return
name|L
return|;
block|}
comment|/// Constructs and returns the recurrence indicating how much this
comment|/// expression steps by.  If this is a polynomial of degree N, it
comment|/// returns a chrec of degree N-1.  We cannot determine whether
comment|/// the step recurrence has self-wraparound.
specifier|const
name|SCEV
operator|*
name|getStepRecurrence
argument_list|(
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
if|if
condition|(
name|isAffine
argument_list|()
condition|)
return|return
name|getOperand
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|SE
operator|.
name|getAddRecExpr
argument_list|(
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
argument_list|,
literal|3
operator|>
operator|(
name|op_begin
argument_list|()
operator|+
literal|1
expr|,
name|op_end
argument_list|()
operator|)
argument_list|,
name|getLoop
argument_list|()
argument_list|,
name|FlagAnyWrap
argument_list|)
return|;
block|}
comment|/// Return true if this represents an expression A + B*x where A
comment|/// and B are loop invariant values.
name|bool
name|isAffine
argument_list|()
specifier|const
block|{
comment|// We know that the start value is invariant.  This expression is thus
comment|// affine iff the step is also invariant.
return|return
name|getNumOperands
argument_list|()
operator|==
literal|2
return|;
block|}
comment|/// Return true if this represents an expression A + B*x + C*x^2
comment|/// where A, B and C are loop invariant values.  This corresponds
comment|/// to an addrec of the form {L,+,M,+,N}
name|bool
name|isQuadratic
argument_list|()
specifier|const
block|{
return|return
name|getNumOperands
argument_list|()
operator|==
literal|3
return|;
block|}
comment|/// Set flags for a recurrence without clearing any previously set flags.
comment|/// For AddRec, either NUW or NSW implies NW. Keep track of this fact here
comment|/// to make it easier to propagate flags.
name|void
name|setNoWrapFlags
argument_list|(
argument|NoWrapFlags Flags
argument_list|)
block|{
if|if
condition|(
name|Flags
operator|&
operator|(
name|FlagNUW
operator||
name|FlagNSW
operator|)
condition|)
name|Flags
operator|=
name|ScalarEvolution
operator|::
name|setFlags
argument_list|(
name|Flags
argument_list|,
name|FlagNW
argument_list|)
expr_stmt|;
name|SubclassData
operator||=
name|Flags
block|;     }
comment|/// Return the value of this chain of recurrences at the specified
comment|/// iteration number.
specifier|const
name|SCEV
operator|*
name|evaluateAtIteration
argument_list|(
argument|const SCEV *It
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
comment|/// Return the number of iterations of this loop that produce
comment|/// values in the specified constant range.  Another way of
comment|/// looking at this is that it returns the first iteration number
comment|/// where the value is not in the condition, thus computing the
comment|/// exit count.  If the iteration count can't be computed, an
comment|/// instance of SCEVCouldNotCompute is returned.
specifier|const
name|SCEV
operator|*
name|getNumIterationsInRange
argument_list|(
argument|const ConstantRange&Range
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|;
comment|/// Return an expression representing the value of this expression
comment|/// one iteration of the loop ahead.
specifier|const
name|SCEVAddRecExpr
operator|*
name|getPostIncExpr
argument_list|(
argument|ScalarEvolution&SE
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|SCEVAddRecExpr
operator|>
operator|(
name|SE
operator|.
name|getAddExpr
argument_list|(
name|this
argument_list|,
name|getStepRecurrence
argument_list|(
name|SE
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scAddRecExpr
return|;
block|}
expr|}
block|;
comment|/// This class represents a signed maximum selection.
name|class
name|SCEVSMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVSMaxExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scSMaxExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{
comment|// Max never overflows.
name|setNoWrapFlags
argument_list|(
call|(
name|NoWrapFlags
call|)
argument_list|(
name|FlagNUW
operator||
name|FlagNSW
argument_list|)
argument_list|)
block|;     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scSMaxExpr
return|;
block|}
expr|}
block|;
comment|/// This class represents an unsigned maximum selection.
name|class
name|SCEVUMaxExpr
operator|:
name|public
name|SCEVCommutativeExpr
block|{
name|friend
name|class
name|ScalarEvolution
block|;
name|SCEVUMaxExpr
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|const SCEV *const *O
argument_list|,
argument|size_t N
argument_list|)
operator|:
name|SCEVCommutativeExpr
argument_list|(
argument|ID
argument_list|,
argument|scUMaxExpr
argument_list|,
argument|O
argument_list|,
argument|N
argument_list|)
block|{
comment|// Max never overflows.
name|setNoWrapFlags
argument_list|(
call|(
name|NoWrapFlags
call|)
argument_list|(
name|FlagNUW
operator||
name|FlagNSW
argument_list|)
argument_list|)
block|;     }
name|public
operator|:
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUMaxExpr
return|;
block|}
expr|}
block|;
comment|/// This means that we are dealing with an entirely unknown SCEV
comment|/// value, and only represent it as its LLVM Value.  This is the
comment|/// "bottom" value for the analysis.
name|class
name|SCEVUnknown
name|final
operator|:
name|public
name|SCEV
block|,
name|private
name|CallbackVH
block|{
name|friend
name|class
name|ScalarEvolution
block|;
comment|// Implement CallbackVH.
name|void
name|deleted
argument_list|()
name|override
block|;
name|void
name|allUsesReplacedWith
argument_list|(
argument|Value *New
argument_list|)
name|override
block|;
comment|/// The parent ScalarEvolution value. This is used to update the
comment|/// parent's maps when the value associated with a SCEVUnknown is
comment|/// deleted or RAUW'd.
name|ScalarEvolution
operator|*
name|SE
block|;
comment|/// The next pointer in the linked list of all SCEVUnknown
comment|/// instances owned by a ScalarEvolution.
name|SCEVUnknown
operator|*
name|Next
block|;
name|SCEVUnknown
argument_list|(
argument|const FoldingSetNodeIDRef ID
argument_list|,
argument|Value *V
argument_list|,
argument|ScalarEvolution *se
argument_list|,
argument|SCEVUnknown *next
argument_list|)
operator|:
name|SCEV
argument_list|(
name|ID
argument_list|,
name|scUnknown
argument_list|)
block|,
name|CallbackVH
argument_list|(
name|V
argument_list|)
block|,
name|SE
argument_list|(
name|se
argument_list|)
block|,
name|Next
argument_list|(
argument|next
argument_list|)
block|{}
name|public
operator|:
name|Value
operator|*
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
return|;
block|}
comment|/// @{
comment|/// Test whether this is a special constant representing a type
comment|/// size, alignment, or field offset in a target-independent
comment|/// manner, and hasn't happened to have been folded with other
comment|/// operations into something unrecognizable. This is mainly only
comment|/// useful for pretty-printing and other situations where it isn't
comment|/// absolutely required for these to succeed.
name|bool
name|isSizeOf
argument_list|(
argument|Type *&AllocTy
argument_list|)
specifier|const
block|;
name|bool
name|isAlignOf
argument_list|(
argument|Type *&AllocTy
argument_list|)
specifier|const
block|;
name|bool
name|isOffsetOf
argument_list|(
argument|Type *&STy
argument_list|,
argument|Constant *&FieldNo
argument_list|)
specifier|const
block|;
comment|/// @}
name|Type
operator|*
name|getType
argument_list|()
specifier|const
block|{
return|return
name|getValPtr
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
return|return
name|S
operator|->
name|getSCEVType
argument_list|()
operator|==
name|scUnknown
return|;
block|}
expr|}
block|;
comment|/// This class defines a simple visitor class that may be used for
comment|/// various SCEV analysis purposes.
name|template
operator|<
name|typename
name|SC
block|,
name|typename
name|RetVal
operator|=
name|void
operator|>
expr|struct
name|SCEVVisitor
block|{
name|RetVal
name|visit
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
switch|switch
condition|(
name|S
operator|->
name|getSCEVType
argument_list|()
condition|)
block|{
case|case
name|scConstant
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitConstant
argument_list|(
operator|(
specifier|const
name|SCEVConstant
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scTruncate
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitTruncateExpr
argument_list|(
operator|(
specifier|const
name|SCEVTruncateExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scZeroExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitZeroExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVZeroExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSignExtend
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSignExtendExpr
argument_list|(
operator|(
specifier|const
name|SCEVSignExtendExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scMulExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitMulExpr
argument_list|(
operator|(
specifier|const
name|SCEVMulExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUDivExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUDivExpr
argument_list|(
operator|(
specifier|const
name|SCEVUDivExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scAddRecExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitAddRecExpr
argument_list|(
operator|(
specifier|const
name|SCEVAddRecExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scSMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitSMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVSMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUMaxExpr
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUMaxExpr
argument_list|(
operator|(
specifier|const
name|SCEVUMaxExpr
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scUnknown
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitUnknown
argument_list|(
operator|(
specifier|const
name|SCEVUnknown
operator|*
operator|)
name|S
argument_list|)
return|;
case|case
name|scCouldNotCompute
case|:
return|return
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visitCouldNotCompute
argument_list|(
operator|(
specifier|const
name|SCEVCouldNotCompute
operator|*
operator|)
name|S
argument_list|)
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown SCEV type!"
argument_list|)
expr_stmt|;
block|}
block|}
name|RetVal
name|visitCouldNotCompute
argument_list|(
argument|const SCEVCouldNotCompute *S
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Invalid use of SCEVCouldNotCompute!"
argument_list|)
block|;     }
block|}
block|;
comment|/// Visit all nodes in the expression tree using worklist traversal.
comment|///
comment|/// Visitor implements:
comment|///   // return true to follow this node.
comment|///   bool follow(const SCEV *S);
comment|///   // return true to terminate the search.
comment|///   bool isDone();
name|template
operator|<
name|typename
name|SV
operator|>
name|class
name|SCEVTraversal
block|{
name|SV
operator|&
name|Visitor
block|;
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|8
operator|>
name|Worklist
block|;
name|SmallPtrSet
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|8
operator|>
name|Visited
block|;
name|void
name|push
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
if|if
condition|(
name|Visited
operator|.
name|insert
argument_list|(
name|S
argument_list|)
operator|.
name|second
operator|&&
name|Visitor
operator|.
name|follow
argument_list|(
name|S
argument_list|)
condition|)
name|Worklist
operator|.
name|push_back
argument_list|(
name|S
argument_list|)
expr_stmt|;
block|}
name|public
operator|:
name|SCEVTraversal
argument_list|(
name|SV
operator|&
name|V
argument_list|)
operator|:
name|Visitor
argument_list|(
argument|V
argument_list|)
block|{}
name|void
name|visitAll
argument_list|(
argument|const SCEV *Root
argument_list|)
block|{
name|push
argument_list|(
name|Root
argument_list|)
block|;
while|while
condition|(
operator|!
name|Worklist
operator|.
name|empty
argument_list|()
operator|&&
operator|!
name|Visitor
operator|.
name|isDone
argument_list|()
condition|)
block|{
specifier|const
name|SCEV
modifier|*
name|S
init|=
name|Worklist
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|S
operator|->
name|getSCEVType
argument_list|()
condition|)
block|{
case|case
name|scConstant
case|:
case|case
name|scUnknown
case|:
break|break;
case|case
name|scTruncate
case|:
case|case
name|scZeroExtend
case|:
case|case
name|scSignExtend
case|:
name|push
argument_list|(
name|cast
operator|<
name|SCEVCastExpr
operator|>
operator|(
name|S
operator|)
operator|->
name|getOperand
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|scAddExpr
case|:
case|case
name|scMulExpr
case|:
case|case
name|scSMaxExpr
case|:
case|case
name|scUMaxExpr
case|:
case|case
name|scAddRecExpr
case|:
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|Op
range|:
name|cast
operator|<
name|SCEVNAryExpr
operator|>
operator|(
name|S
operator|)
operator|->
name|operands
argument_list|()
control|)
name|push
argument_list|(
name|Op
argument_list|)
expr_stmt|;
break|break;
case|case
name|scUDivExpr
case|:
block|{
specifier|const
name|SCEVUDivExpr
modifier|*
name|UDiv
init|=
name|cast
operator|<
name|SCEVUDivExpr
operator|>
operator|(
name|S
operator|)
decl_stmt|;
name|push
argument_list|(
name|UDiv
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|UDiv
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|scCouldNotCompute
case|:
name|llvm_unreachable
argument_list|(
literal|"Attempt to use a SCEVCouldNotCompute object!"
argument_list|)
expr_stmt|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown SCEV kind!"
argument_list|)
expr_stmt|;
block|}
block|}
expr|}   }
block|;
comment|/// Use SCEVTraversal to visit all nodes in the given expression tree.
name|template
operator|<
name|typename
name|SV
operator|>
name|void
name|visitAll
argument_list|(
argument|const SCEV *Root
argument_list|,
argument|SV& Visitor
argument_list|)
block|{
name|SCEVTraversal
operator|<
name|SV
operator|>
name|T
argument_list|(
name|Visitor
argument_list|)
block|;
name|T
operator|.
name|visitAll
argument_list|(
name|Root
argument_list|)
block|;   }
comment|/// Return true if any node in \p Root satisfies the predicate \p Pred.
name|template
operator|<
name|typename
name|PredTy
operator|>
name|bool
name|SCEVExprContains
argument_list|(
argument|const SCEV *Root
argument_list|,
argument|PredTy Pred
argument_list|)
block|{     struct
name|FindClosure
block|{
name|bool
name|Found
operator|=
name|false
block|;
name|PredTy
name|Pred
block|;
name|FindClosure
argument_list|(
argument|PredTy Pred
argument_list|)
operator|:
name|Pred
argument_list|(
argument|Pred
argument_list|)
block|{}
name|bool
name|follow
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
if|if
condition|(
operator|!
name|Pred
argument_list|(
name|S
argument_list|)
condition|)
return|return
name|true
return|;
name|Found
operator|=
name|true
block|;
return|return
name|false
return|;
block|}
name|bool
name|isDone
argument_list|()
specifier|const
block|{
return|return
name|Found
return|;
block|}
expr|}
block|;
name|FindClosure
name|FC
argument_list|(
name|Pred
argument_list|)
block|;
name|visitAll
argument_list|(
name|Root
argument_list|,
name|FC
argument_list|)
block|;
return|return
name|FC
operator|.
name|Found
return|;
block|}
comment|/// This visitor recursively visits a SCEV expression and re-writes it.
comment|/// The result from each visit is cached, so it will return the same
comment|/// SCEV for the same input.
name|template
operator|<
name|typename
name|SC
operator|>
name|class
name|SCEVRewriteVisitor
operator|:
name|public
name|SCEVVisitor
operator|<
name|SC
block|,
specifier|const
name|SCEV
operator|*
operator|>
block|{
name|protected
operator|:
name|ScalarEvolution
operator|&
name|SE
block|;
comment|// Memoize the result of each visit so that we only compute once for
comment|// the same input SCEV. This is to avoid redundant computations when
comment|// a SCEV is referenced by multiple SCEVs. Without memoization, this
comment|// visit algorithm would have exponential time complexity in the worst
comment|// case, causing the compiler to hang on certain tests.
name|DenseMap
operator|<
specifier|const
name|SCEV
operator|*
block|,
specifier|const
name|SCEV
operator|*
operator|>
name|RewriteResults
block|;
name|public
operator|:
name|SCEVRewriteVisitor
argument_list|(
name|ScalarEvolution
operator|&
name|SE
argument_list|)
operator|:
name|SE
argument_list|(
argument|SE
argument_list|)
block|{}
specifier|const
name|SCEV
operator|*
name|visit
argument_list|(
argument|const SCEV *S
argument_list|)
block|{
name|auto
name|It
operator|=
name|RewriteResults
operator|.
name|find
argument_list|(
name|S
argument_list|)
block|;
if|if
condition|(
name|It
operator|!=
name|RewriteResults
operator|.
name|end
argument_list|()
condition|)
return|return
name|It
operator|->
name|second
return|;
name|auto
operator|*
name|Visited
operator|=
name|SCEVVisitor
operator|<
name|SC
block|,
specifier|const
name|SCEV
operator|*
operator|>
operator|::
name|visit
argument_list|(
name|S
argument_list|)
block|;
name|auto
name|Result
operator|=
name|RewriteResults
operator|.
name|try_emplace
argument_list|(
name|S
argument_list|,
name|Visited
argument_list|)
block|;
name|assert
argument_list|(
name|Result
operator|.
name|second
operator|&&
literal|"Should insert a new entry"
argument_list|)
block|;
return|return
name|Result
operator|.
name|first
operator|->
name|second
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitConstant
argument_list|(
argument|const SCEVConstant *Constant
argument_list|)
block|{
return|return
name|Constant
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitTruncateExpr
argument_list|(
argument|const SCEVTruncateExpr *Expr
argument_list|)
block|{
specifier|const
name|SCEV
operator|*
name|Operand
operator|=
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Expr
operator|->
name|getOperand
argument_list|()
argument_list|)
block|;
return|return
name|Operand
operator|==
name|Expr
operator|->
name|getOperand
argument_list|()
condition|?
name|Expr
else|:
name|SE
operator|.
name|getTruncateExpr
argument_list|(
name|Operand
argument_list|,
name|Expr
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitZeroExtendExpr
argument_list|(
argument|const SCEVZeroExtendExpr *Expr
argument_list|)
block|{
specifier|const
name|SCEV
operator|*
name|Operand
operator|=
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Expr
operator|->
name|getOperand
argument_list|()
argument_list|)
block|;
return|return
name|Operand
operator|==
name|Expr
operator|->
name|getOperand
argument_list|()
condition|?
name|Expr
else|:
name|SE
operator|.
name|getZeroExtendExpr
argument_list|(
name|Operand
argument_list|,
name|Expr
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitSignExtendExpr
argument_list|(
argument|const SCEVSignExtendExpr *Expr
argument_list|)
block|{
specifier|const
name|SCEV
operator|*
name|Operand
operator|=
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Expr
operator|->
name|getOperand
argument_list|()
argument_list|)
block|;
return|return
name|Operand
operator|==
name|Expr
operator|->
name|getOperand
argument_list|()
condition|?
name|Expr
else|:
name|SE
operator|.
name|getSignExtendExpr
argument_list|(
name|Operand
argument_list|,
name|Expr
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitAddExpr
argument_list|(
argument|const SCEVAddExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
name|bool
name|Changed
operator|=
name|false
block|;
for|for
control|(
name|auto
operator|*
name|Op
operator|:
name|Expr
operator|->
name|operands
argument_list|()
control|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Op
argument_list|)
argument_list|)
expr_stmt|;
name|Changed
operator||=
name|Op
operator|!=
name|Operands
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getAddExpr
argument_list|(
name|Operands
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitMulExpr
argument_list|(
argument|const SCEVMulExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
name|bool
name|Changed
operator|=
name|false
block|;
for|for
control|(
name|auto
operator|*
name|Op
operator|:
name|Expr
operator|->
name|operands
argument_list|()
control|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Op
argument_list|)
argument_list|)
expr_stmt|;
name|Changed
operator||=
name|Op
operator|!=
name|Operands
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getMulExpr
argument_list|(
name|Operands
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitUDivExpr
argument_list|(
argument|const SCEVUDivExpr *Expr
argument_list|)
block|{
name|auto
operator|*
name|LHS
operator|=
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Expr
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
name|auto
operator|*
name|RHS
operator|=
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Expr
operator|->
name|getRHS
argument_list|()
argument_list|)
block|;
name|bool
name|Changed
operator|=
name|LHS
operator|!=
name|Expr
operator|->
name|getLHS
argument_list|()
operator|||
name|RHS
operator|!=
name|Expr
operator|->
name|getRHS
argument_list|()
block|;
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getUDivExpr
argument_list|(
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitAddRecExpr
argument_list|(
argument|const SCEVAddRecExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
name|bool
name|Changed
operator|=
name|false
block|;
for|for
control|(
name|auto
operator|*
name|Op
operator|:
name|Expr
operator|->
name|operands
argument_list|()
control|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Op
argument_list|)
argument_list|)
expr_stmt|;
name|Changed
operator||=
name|Op
operator|!=
name|Operands
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getAddRecExpr
argument_list|(
name|Operands
argument_list|,
name|Expr
operator|->
name|getLoop
argument_list|()
argument_list|,
name|Expr
operator|->
name|getNoWrapFlags
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitSMaxExpr
argument_list|(
argument|const SCEVSMaxExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
name|bool
name|Changed
operator|=
name|false
block|;
for|for
control|(
name|auto
operator|*
name|Op
operator|:
name|Expr
operator|->
name|operands
argument_list|()
control|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Op
argument_list|)
argument_list|)
expr_stmt|;
name|Changed
operator||=
name|Op
operator|!=
name|Operands
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getSMaxExpr
argument_list|(
name|Operands
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitUMaxExpr
argument_list|(
argument|const SCEVUMaxExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
name|bool
name|Changed
operator|=
name|false
block|;
for|for
control|(
name|auto
operator|*
name|Op
operator|:
name|Expr
operator|->
name|operands
argument_list|()
control|)
block|{
name|Operands
operator|.
name|push_back
argument_list|(
operator|(
operator|(
name|SC
operator|*
operator|)
name|this
operator|)
operator|->
name|visit
argument_list|(
name|Op
argument_list|)
argument_list|)
expr_stmt|;
name|Changed
operator||=
name|Op
operator|!=
name|Operands
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|Changed
condition|?
name|Expr
else|:
name|SE
operator|.
name|getUMaxExpr
argument_list|(
name|Operands
argument_list|)
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitUnknown
argument_list|(
argument|const SCEVUnknown *Expr
argument_list|)
block|{
return|return
name|Expr
return|;
block|}
specifier|const
name|SCEV
operator|*
name|visitCouldNotCompute
argument_list|(
argument|const SCEVCouldNotCompute *Expr
argument_list|)
block|{
return|return
name|Expr
return|;
block|}
expr|}
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|Value
operator|*
operator|>
name|ValueToValueMap
expr_stmt|;
comment|/// The SCEVParameterRewriter takes a scalar evolution expression and updates
comment|/// the SCEVUnknown components following the Map (Value -> Value).
name|class
name|SCEVParameterRewriter
operator|:
name|public
name|SCEVRewriteVisitor
operator|<
name|SCEVParameterRewriter
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|SCEV
operator|*
name|rewrite
argument_list|(
argument|const SCEV *Scev
argument_list|,
argument|ScalarEvolution&SE
argument_list|,
argument|ValueToValueMap&Map
argument_list|,
argument|bool InterpretConsts = false
argument_list|)
block|{
name|SCEVParameterRewriter
name|Rewriter
argument_list|(
name|SE
argument_list|,
name|Map
argument_list|,
name|InterpretConsts
argument_list|)
block|;
return|return
name|Rewriter
operator|.
name|visit
argument_list|(
name|Scev
argument_list|)
return|;
block|}
name|SCEVParameterRewriter
argument_list|(
argument|ScalarEvolution&SE
argument_list|,
argument|ValueToValueMap&M
argument_list|,
argument|bool C
argument_list|)
operator|:
name|SCEVRewriteVisitor
argument_list|(
name|SE
argument_list|)
block|,
name|Map
argument_list|(
name|M
argument_list|)
block|,
name|InterpretConsts
argument_list|(
argument|C
argument_list|)
block|{}
specifier|const
name|SCEV
operator|*
name|visitUnknown
argument_list|(
argument|const SCEVUnknown *Expr
argument_list|)
block|{
name|Value
operator|*
name|V
operator|=
name|Expr
operator|->
name|getValue
argument_list|()
block|;
if|if
condition|(
name|Map
operator|.
name|count
argument_list|(
name|V
argument_list|)
condition|)
block|{
name|Value
modifier|*
name|NV
init|=
name|Map
index|[
name|V
index|]
decl_stmt|;
if|if
condition|(
name|InterpretConsts
operator|&&
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|NV
operator|)
condition|)
return|return
name|SE
operator|.
name|getConstant
argument_list|(
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|NV
operator|)
argument_list|)
return|;
return|return
name|SE
operator|.
name|getUnknown
argument_list|(
name|NV
argument_list|)
return|;
block|}
return|return
name|Expr
return|;
block|}
name|private
operator|:
name|ValueToValueMap
operator|&
name|Map
block|;
name|bool
name|InterpretConsts
block|;   }
block|;
typedef|typedef
name|DenseMap
operator|<
specifier|const
name|Loop
operator|*
operator|,
specifier|const
name|SCEV
operator|*
operator|>
name|LoopToScevMapT
expr_stmt|;
comment|/// The SCEVLoopAddRecRewriter takes a scalar evolution expression and applies
comment|/// the Map (Loop -> SCEV) to all AddRecExprs.
name|class
name|SCEVLoopAddRecRewriter
operator|:
name|public
name|SCEVRewriteVisitor
operator|<
name|SCEVLoopAddRecRewriter
operator|>
block|{
name|public
operator|:
specifier|static
specifier|const
name|SCEV
operator|*
name|rewrite
argument_list|(
argument|const SCEV *Scev
argument_list|,
argument|LoopToScevMapT&Map
argument_list|,
argument|ScalarEvolution&SE
argument_list|)
block|{
name|SCEVLoopAddRecRewriter
name|Rewriter
argument_list|(
name|SE
argument_list|,
name|Map
argument_list|)
block|;
return|return
name|Rewriter
operator|.
name|visit
argument_list|(
name|Scev
argument_list|)
return|;
block|}
name|SCEVLoopAddRecRewriter
argument_list|(
name|ScalarEvolution
operator|&
name|SE
argument_list|,
name|LoopToScevMapT
operator|&
name|M
argument_list|)
operator|:
name|SCEVRewriteVisitor
argument_list|(
name|SE
argument_list|)
block|,
name|Map
argument_list|(
argument|M
argument_list|)
block|{}
specifier|const
name|SCEV
operator|*
name|visitAddRecExpr
argument_list|(
argument|const SCEVAddRecExpr *Expr
argument_list|)
block|{
name|SmallVector
operator|<
specifier|const
name|SCEV
operator|*
block|,
literal|2
operator|>
name|Operands
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|e
init|=
name|Expr
operator|->
name|getNumOperands
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
name|Operands
operator|.
name|push_back
argument_list|(
name|visit
argument_list|(
name|Expr
operator|->
name|getOperand
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|Loop
operator|*
name|L
operator|=
name|Expr
operator|->
name|getLoop
argument_list|()
block|;
specifier|const
name|SCEV
operator|*
name|Res
operator|=
name|SE
operator|.
name|getAddRecExpr
argument_list|(
name|Operands
argument_list|,
name|L
argument_list|,
name|Expr
operator|->
name|getNoWrapFlags
argument_list|()
argument_list|)
block|;
if|if
condition|(
literal|0
operator|==
name|Map
operator|.
name|count
argument_list|(
name|L
argument_list|)
condition|)
return|return
name|Res
return|;
specifier|const
name|SCEVAddRecExpr
operator|*
name|Rec
operator|=
name|cast
operator|<
name|SCEVAddRecExpr
operator|>
operator|(
name|Res
operator|)
block|;
return|return
name|Rec
operator|->
name|evaluateAtIteration
argument_list|(
name|Map
index|[
name|L
index|]
argument_list|,
name|SE
argument_list|)
return|;
block|}
name|private
operator|:
name|LoopToScevMapT
operator|&
name|Map
block|;   }
block|; }
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

