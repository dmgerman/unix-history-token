begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- BlockFrequencyImpl.h - Block Frequency Implementation --*- C++ -*--===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Shared implementation of BlockFrequency for IR and Machine Instructions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_BLOCKFREQUENCYIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_BLOCKFREQUENCYIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PostOrderIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineBasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineFunction.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/BasicBlock.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BlockFrequency.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/BranchProbability.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|BlockFrequencyInfo
decl_stmt|;
name|class
name|MachineBlockFrequencyInfo
decl_stmt|;
comment|/// BlockFrequencyImpl implements block frequency algorithm for IR and
comment|/// Machine Instructions. Algorithm starts with value ENTRY_FREQ
comment|/// for the entry block and then propagates frequencies using branch weights
comment|/// from (Machine)BranchProbabilityInfo. LoopInfo is not required because
comment|/// algorithm can find "backedges" by itself.
name|template
operator|<
name|class
name|BlockT
operator|,
name|class
name|FunctionT
operator|,
name|class
name|BlockProbInfoT
operator|>
name|class
name|BlockFrequencyImpl
block|{
name|DenseMap
operator|<
specifier|const
name|BlockT
operator|*
block|,
name|BlockFrequency
operator|>
name|Freqs
block|;
name|BlockProbInfoT
operator|*
name|BPI
block|;
name|FunctionT
operator|*
name|Fn
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
name|GT
expr_stmt|;
specifier|const
name|uint32_t
name|EntryFreq
expr_stmt|;
name|std
operator|::
name|string
name|getBlockName
argument_list|(
argument|BasicBlock *BB
argument_list|)
specifier|const
block|{
return|return
name|BB
operator|->
name|getName
argument_list|()
operator|.
name|str
argument_list|()
return|;
block|}
name|std
operator|::
name|string
name|getBlockName
argument_list|(
argument|MachineBasicBlock *MBB
argument_list|)
specifier|const
block|{
name|std
operator|::
name|string
name|str
block|;
name|raw_string_ostream
name|ss
argument_list|(
name|str
argument_list|)
block|;
name|ss
operator|<<
literal|"BB#"
operator|<<
name|MBB
operator|->
name|getNumber
argument_list|()
block|;
if|if
condition|(
specifier|const
name|BasicBlock
modifier|*
name|BB
init|=
name|MBB
operator|->
name|getBasicBlock
argument_list|()
condition|)
name|ss
operator|<<
literal|" derived from LLVM BB "
operator|<<
name|BB
operator|->
name|getName
argument_list|()
expr_stmt|;
return|return
name|ss
operator|.
name|str
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|void
name|setBlockFreq
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|,
name|BlockFrequency
name|Freq
parameter_list|)
block|{
name|Freqs
index|[
name|BB
index|]
operator|=
name|Freq
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Frequency("
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|") = "
operator|<<
name|Freq
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// getEdgeFreq - Return edge frequency based on SRC frequency and Src -> Dst
end_comment

begin_comment
comment|/// edge probability.
end_comment

begin_decl_stmt
name|BlockFrequency
name|getEdgeFreq
argument_list|(
name|BlockT
operator|*
name|Src
argument_list|,
name|BlockT
operator|*
name|Dst
argument_list|)
decl|const
block|{
name|BranchProbability
name|Prob
init|=
name|BPI
operator|->
name|getEdgeProbability
argument_list|(
name|Src
argument_list|,
name|Dst
argument_list|)
decl_stmt|;
return|return
name|getBlockFreq
argument_list|(
name|Src
argument_list|)
operator|*
name|Prob
return|;
block|}
end_decl_stmt

begin_comment
comment|/// incBlockFreq - Increase BB block frequency by FREQ.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|incBlockFreq
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|,
name|BlockFrequency
name|Freq
parameter_list|)
block|{
name|Freqs
index|[
name|BB
index|]
operator|+=
name|Freq
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Frequency("
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|") += "
operator|<<
name|Freq
operator|<<
literal|" --> "
operator|<<
name|Freqs
index|[
name|BB
index|]
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// All blocks in postorder.
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
name|POT
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Map Block -> Position in reverse-postorder list.
end_comment

begin_expr_stmt
name|DenseMap
operator|<
name|BlockT
operator|*
operator|,
name|unsigned
operator|>
name|RPO
expr_stmt|;
end_expr_stmt

begin_comment
comment|// For each loop header, record the per-iteration probability of exiting the
end_comment

begin_comment
comment|// loop. This is the reciprocal of the expected number of loop iterations.
end_comment

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|BlockT
operator|*
operator|,
name|BranchProbability
operator|>
name|LoopExitProbMap
expr_stmt|;
end_typedef

begin_decl_stmt
name|LoopExitProbMap
name|LoopExitProb
decl_stmt|;
end_decl_stmt

begin_comment
comment|// (reverse-)postorder traversal iterators.
end_comment

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|iterator
name|pot_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|reverse_iterator
name|rpot_iterator
expr_stmt|;
end_typedef

begin_function
name|pot_iterator
name|pot_begin
parameter_list|()
block|{
return|return
name|POT
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|pot_iterator
name|pot_end
parameter_list|()
block|{
return|return
name|POT
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_function
name|rpot_iterator
name|rpot_begin
parameter_list|()
block|{
return|return
name|POT
operator|.
name|rbegin
argument_list|()
return|;
block|}
end_function

begin_function
name|rpot_iterator
name|rpot_end
parameter_list|()
block|{
return|return
name|POT
operator|.
name|rend
argument_list|()
return|;
block|}
end_function

begin_function
name|rpot_iterator
name|rpot_at
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|rpot_iterator
name|I
init|=
name|rpot_begin
argument_list|()
decl_stmt|;
name|unsigned
name|idx
init|=
name|RPO
operator|.
name|lookup
argument_list|(
name|BB
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|I
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|I
operator|==
name|BB
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
end_function

begin_comment
comment|/// isBackedge - Return if edge Src -> Dst is a reachable backedge.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|bool
name|isBackedge
argument_list|(
name|BlockT
operator|*
name|Src
argument_list|,
name|BlockT
operator|*
name|Dst
argument_list|)
decl|const
block|{
name|unsigned
name|a
init|=
name|RPO
operator|.
name|lookup
argument_list|(
name|Src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|false
return|;
name|unsigned
name|b
init|=
name|RPO
operator|.
name|lookup
argument_list|(
name|Dst
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|b
operator|&&
literal|"Destination block should be reachable"
argument_list|)
expr_stmt|;
return|return
name|a
operator|>=
name|b
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getSingleBlockPred - return single BB block predecessor or NULL if
end_comment

begin_comment
comment|/// BB has none or more predecessors.
end_comment

begin_function
name|BlockT
modifier|*
name|getSingleBlockPred
parameter_list|(
name|BlockT
modifier|*
name|BB
parameter_list|)
block|{
name|typename
name|GT
operator|::
name|ChildIteratorType
name|PI
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|PE
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|PI
operator|==
name|PE
condition|)
return|return
literal|0
return|;
name|BlockT
modifier|*
name|Pred
init|=
operator|*
name|PI
decl_stmt|;
operator|++
name|PI
expr_stmt|;
if|if
condition|(
name|PI
operator|!=
name|PE
condition|)
return|return
literal|0
return|;
return|return
name|Pred
return|;
block|}
end_function

begin_decl_stmt
name|void
name|doBlock
argument_list|(
name|BlockT
operator|*
name|BB
argument_list|,
name|BlockT
operator|*
name|LoopHead
argument_list|,
name|SmallPtrSet
operator|<
name|BlockT
operator|*
argument_list|,
literal|8
operator|>
operator|&
name|BlocksInLoop
argument_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"doBlock("
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|setBlockFreq
argument_list|(
name|BB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB
operator|==
name|LoopHead
condition|)
block|{
name|setBlockFreq
argument_list|(
name|BB
argument_list|,
name|EntryFreq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BlockT
modifier|*
name|Pred
init|=
name|getSingleBlockPred
argument_list|(
name|BB
argument_list|)
condition|)
block|{
if|if
condition|(
name|BlocksInLoop
operator|.
name|count
argument_list|(
name|Pred
argument_list|)
condition|)
name|setBlockFreq
argument_list|(
name|BB
argument_list|,
name|getEdgeFreq
argument_list|(
name|Pred
argument_list|,
name|BB
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: else? irreducible, ignore it for now.
return|return;
block|}
name|bool
name|isInLoop
init|=
name|false
decl_stmt|;
name|bool
name|isLoopHead
init|=
name|false
decl_stmt|;
for|for
control|(
name|typename
name|GT
operator|::
name|ChildIteratorType
name|PI
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|PE
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|BlockT
modifier|*
name|Pred
init|=
operator|*
name|PI
decl_stmt|;
if|if
condition|(
name|isBackedge
argument_list|(
name|Pred
argument_list|,
name|BB
argument_list|)
condition|)
block|{
name|isLoopHead
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BlocksInLoop
operator|.
name|count
argument_list|(
name|Pred
argument_list|)
condition|)
block|{
name|incBlockFreq
argument_list|(
name|BB
argument_list|,
name|getEdgeFreq
argument_list|(
name|Pred
argument_list|,
name|BB
argument_list|)
argument_list|)
expr_stmt|;
name|isInLoop
operator|=
name|true
expr_stmt|;
block|}
comment|// TODO: else? irreducible.
block|}
if|if
condition|(
operator|!
name|isInLoop
condition|)
return|return;
if|if
condition|(
operator|!
name|isLoopHead
condition|)
return|return;
comment|// This block is a loop header, so boost its frequency by the expected
comment|// number of loop iterations. The loop blocks will be revisited so they all
comment|// get this boost.
name|typename
name|LoopExitProbMap
operator|::
name|const_iterator
name|I
operator|=
name|LoopExitProb
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|LoopExitProb
operator|.
name|end
argument_list|()
operator|&&
literal|"Loop header missing from table"
argument_list|)
expr_stmt|;
name|Freqs
index|[
name|BB
index|]
operator|/=
name|I
operator|->
name|second
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"Loop header scaled to "
operator|<<
name|Freqs
index|[
name|BB
index|]
operator|<<
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// doLoop - Propagate block frequency down through the loop.
end_comment

begin_function
name|void
name|doLoop
parameter_list|(
name|BlockT
modifier|*
name|Head
parameter_list|,
name|BlockT
modifier|*
name|Tail
parameter_list|)
block|{
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"doLoop("
operator|<<
name|getBlockName
argument_list|(
name|Head
argument_list|)
operator|<<
literal|", "
operator|<<
name|getBlockName
argument_list|(
name|Tail
argument_list|)
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|SmallPtrSet
operator|<
name|BlockT
operator|*
operator|,
literal|8
operator|>
name|BlocksInLoop
expr_stmt|;
for|for
control|(
name|rpot_iterator
name|I
init|=
name|rpot_at
argument_list|(
name|Head
argument_list|)
init|,
name|E
init|=
name|rpot_at
argument_list|(
name|Tail
argument_list|)
init|;
condition|;
operator|++
name|I
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
name|doBlock
argument_list|(
name|BB
argument_list|,
name|Head
argument_list|,
name|BlocksInLoop
argument_list|)
expr_stmt|;
name|BlocksInLoop
operator|.
name|insert
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|E
condition|)
break|break;
block|}
comment|// Compute loop's cyclic probability using backedges probabilities.
name|BlockFrequency
name|BackFreq
decl_stmt|;
for|for
control|(
name|typename
name|GT
operator|::
name|ChildIteratorType
name|PI
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_begin
argument_list|(
name|Head
argument_list|)
operator|,
name|PE
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_end
argument_list|(
name|Head
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|BlockT
modifier|*
name|Pred
init|=
operator|*
name|PI
decl_stmt|;
name|assert
argument_list|(
name|Pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBackedge
argument_list|(
name|Pred
argument_list|,
name|Head
argument_list|)
condition|)
name|BackFreq
operator|+=
name|getEdgeFreq
argument_list|(
name|Pred
argument_list|,
name|Head
argument_list|)
expr_stmt|;
block|}
comment|// The cyclic probability is freq(BackEdges) / freq(Head), where freq(Head)
comment|// only counts edges entering the loop, not the loop backedges.
comment|// The probability of leaving the loop on each iteration is:
comment|//
comment|//   ExitProb = 1 - CyclicProb
comment|//
comment|// The Expected number of loop iterations is:
comment|//
comment|//   Iterations = 1 / ExitProb
comment|//
name|uint64_t
name|D
init|=
name|std
operator|::
name|max
argument_list|(
name|getBlockFreq
argument_list|(
name|Head
argument_list|)
operator|.
name|getFrequency
argument_list|()
argument_list|,
name|UINT64_C
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|N
init|=
name|std
operator|::
name|max
argument_list|(
name|BackFreq
operator|.
name|getFrequency
argument_list|()
argument_list|,
name|UINT64_C
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|N
operator|<
name|D
condition|)
name|N
operator|=
name|D
operator|-
name|N
expr_stmt|;
else|else
comment|// We'd expect N< D, but rounding and saturation means that can't be
comment|// guaranteed.
name|N
operator|=
literal|1
expr_stmt|;
comment|// Now ExitProb = N / D, make sure it fits in an i32/i32 fraction.
name|assert
argument_list|(
name|N
operator|<=
name|D
argument_list|)
expr_stmt|;
if|if
condition|(
name|D
operator|>
name|UINT32_MAX
condition|)
block|{
name|unsigned
name|Shift
init|=
literal|32
operator|-
name|countLeadingZeros
argument_list|(
name|D
argument_list|)
decl_stmt|;
name|D
operator|>>=
name|Shift
expr_stmt|;
name|N
operator|>>=
name|Shift
expr_stmt|;
if|if
condition|(
name|N
operator|==
literal|0
condition|)
name|N
operator|=
literal|1
expr_stmt|;
block|}
name|BranchProbability
name|LEP
init|=
name|BranchProbability
argument_list|(
name|N
argument_list|,
name|D
argument_list|)
decl_stmt|;
name|LoopExitProb
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Head
argument_list|,
name|LEP
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"LoopExitProb["
operator|<<
name|getBlockName
argument_list|(
name|Head
argument_list|)
operator|<<
literal|"] = "
operator|<<
name|LEP
operator|<<
literal|" from 1 - "
operator|<<
name|BackFreq
operator|<<
literal|" / "
operator|<<
name|getBlockFreq
argument_list|(
name|Head
argument_list|)
operator|<<
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|friend
name|class
name|BlockFrequencyInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|friend
name|class
name|MachineBlockFrequencyInfo
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|BlockFrequencyImpl
argument_list|()
operator|:
name|EntryFreq
argument_list|(
argument|BlockFrequency::getEntryFrequency()
argument_list|)
block|{ }
name|void
name|doFunction
argument_list|(
argument|FunctionT *fn
argument_list|,
argument|BlockProbInfoT *bpi
argument_list|)
block|{
name|Fn
operator|=
name|fn
block|;
name|BPI
operator|=
name|bpi
block|;
comment|// Clear everything.
name|RPO
operator|.
name|clear
argument_list|()
block|;
name|POT
operator|.
name|clear
argument_list|()
block|;
name|LoopExitProb
operator|.
name|clear
argument_list|()
block|;
name|Freqs
operator|.
name|clear
argument_list|()
block|;
name|BlockT
operator|*
name|EntryBlock
operator|=
name|fn
operator|->
name|begin
argument_list|()
block|;
name|std
operator|::
name|copy
argument_list|(
name|po_begin
argument_list|(
name|EntryBlock
argument_list|)
argument_list|,
name|po_end
argument_list|(
name|EntryBlock
argument_list|)
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|POT
argument_list|)
argument_list|)
block|;
name|unsigned
name|RPOidx
operator|=
literal|0
block|;
for|for
control|(
name|rpot_iterator
name|I
init|=
name|rpot_begin
argument_list|()
init|,
name|E
init|=
name|rpot_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
name|RPO
index|[
name|BB
index|]
operator|=
operator|++
name|RPOidx
expr_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"RPO["
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|"] = "
operator|<<
name|RPO
index|[
name|BB
index|]
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Travel over all blocks in postorder.
end_comment

begin_for
for|for
control|(
name|pot_iterator
name|I
init|=
name|pot_begin
argument_list|()
init|,
name|E
init|=
name|pot_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
operator|*
name|I
decl_stmt|;
name|BlockT
modifier|*
name|LastTail
init|=
literal|0
decl_stmt|;
name|DEBUG
argument_list|(
name|dbgs
argument_list|()
operator|<<
literal|"POT: "
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|typename
name|GT
operator|::
name|ChildIteratorType
name|PI
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|PE
operator|=
name|GraphTraits
operator|<
name|Inverse
operator|<
name|BlockT
operator|*
operator|>
expr|>
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
block|{
name|BlockT
modifier|*
name|Pred
init|=
operator|*
name|PI
decl_stmt|;
if|if
condition|(
name|isBackedge
argument_list|(
name|Pred
argument_list|,
name|BB
argument_list|)
operator|&&
operator|(
operator|!
name|LastTail
operator|||
name|RPO
index|[
name|Pred
index|]
operator|>
name|RPO
index|[
name|LastTail
index|]
operator|)
condition|)
name|LastTail
operator|=
name|Pred
expr_stmt|;
block|}
if|if
condition|(
name|LastTail
condition|)
name|doLoop
argument_list|(
name|BB
argument_list|,
name|LastTail
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// At the end assume the whole function as a loop, and travel over it once
end_comment

begin_comment
comment|// again.
end_comment

begin_expr_stmt
name|doLoop
argument_list|(
operator|*
operator|(
name|rpot_begin
argument_list|()
operator|)
argument_list|,
operator|*
operator|(
name|pot_begin
argument_list|()
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}  public:
comment|/// getBlockFreq - Return block frequency. Return 0 if we don't have it.
end_comment

begin_decl_stmt
name|BlockFrequency
name|getBlockFreq
argument_list|(
specifier|const
name|BlockT
operator|*
name|BB
argument_list|)
decl|const
block|{
name|typename
name|DenseMap
operator|<
specifier|const
name|BlockT
operator|*
operator|,
name|BlockFrequency
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|Freqs
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|!=
name|Freqs
operator|.
name|end
argument_list|()
condition|)
return|return
name|I
operator|->
name|second
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
block|{
name|OS
operator|<<
literal|"\n\n---- Block Freqs ----\n"
expr_stmt|;
for|for
control|(
name|typename
name|FunctionT
operator|::
name|iterator
name|I
operator|=
name|Fn
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Fn
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
control|)
block|{
name|BlockT
modifier|*
name|BB
init|=
name|I
operator|++
decl_stmt|;
name|OS
operator|<<
literal|" "
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" = "
operator|<<
name|getBlockFreq
argument_list|(
name|BB
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
for|for
control|(
name|typename
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|ChildIteratorType
name|SI
operator|=
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|child_begin
argument_list|(
name|BB
argument_list|)
operator|,
name|SE
operator|=
name|GraphTraits
operator|<
name|BlockT
operator|*
operator|>
operator|::
name|child_end
argument_list|(
name|BB
argument_list|)
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
name|BlockT
modifier|*
name|Succ
init|=
operator|*
name|SI
decl_stmt|;
name|OS
operator|<<
literal|"  "
operator|<<
name|getBlockName
argument_list|(
name|BB
argument_list|)
operator|<<
literal|" -> "
operator|<<
name|getBlockName
argument_list|(
name|Succ
argument_list|)
operator|<<
literal|" = "
operator|<<
name|getEdgeFreq
argument_list|(
name|BB
argument_list|,
name|Succ
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
block|;   }
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

end_unit

