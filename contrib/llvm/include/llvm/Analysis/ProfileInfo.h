begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/ProfileInfo.h - Profile Info Interface -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the generic ProfileInfo interface, which is used as the
end_comment

begin_comment
comment|// common interface used by all clients of profiling information, and
end_comment

begin_comment
comment|// implemented either by making static guestimations, or by actually reading in
end_comment

begin_comment
comment|// profiling information gathered by running the program.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that to be useful, all profile-based optimizations should preserve
end_comment

begin_comment
comment|// ProfileInfo, which requires that they notify it when changes to the CFG are
end_comment

begin_comment
comment|// made. (This is not implemented yet.)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_PROFILEINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_PROFILEINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Format.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Pass
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
comment|// Helper for dumping edges to dbgs().
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
name|std
operator|::
name|pair
operator|<
specifier|const
name|BasicBlock
operator|*
operator|,
specifier|const
name|BasicBlock
operator|*
operator|>
name|E
operator|)
expr_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
name|std
operator|::
name|pair
operator|<
specifier|const
name|MachineBasicBlock
operator|*
operator|,
specifier|const
name|MachineBasicBlock
operator|*
operator|>
name|E
operator|)
expr_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
specifier|const
name|BasicBlock
operator|*
name|BB
operator|)
expr_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
specifier|const
name|MachineBasicBlock
operator|*
name|MBB
operator|)
expr_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
specifier|const
name|Function
operator|*
name|F
operator|)
expr_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|O
operator|,
specifier|const
name|MachineFunction
operator|*
name|MF
operator|)
expr_stmt|;
comment|/// ProfileInfo Class - This class holds and maintains profiling
comment|/// information for some unit of code.
name|template
operator|<
name|class
name|FType
operator|,
name|class
name|BType
operator|>
name|class
name|ProfileInfoT
block|{
name|public
operator|:
comment|// Types for handling profiling information.
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|BType
operator|*
operator|,
specifier|const
name|BType
operator|*
operator|>
name|Edge
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Edge
operator|,
name|double
operator|>
name|EdgeWeight
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|Edge
operator|,
name|double
operator|>
name|EdgeWeights
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
specifier|const
name|BType
operator|*
operator|,
name|double
operator|>
name|BlockCounts
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
specifier|const
name|BType
operator|*
operator|,
specifier|const
name|BType
operator|*
operator|>
name|Path
expr_stmt|;
name|protected
label|:
comment|// EdgeInformation - Count the number of times a transition between two
comment|// blocks is executed. As a special case, we also hold an edge from the
comment|// null BasicBlock to the entry block to indicate how many times the
comment|// function was entered.
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|EdgeWeights
operator|>
name|EdgeInformation
expr_stmt|;
comment|// BlockInformation - Count the number of times a block is executed.
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|BlockCounts
operator|>
name|BlockInformation
expr_stmt|;
comment|// FunctionInformation - Count the number of times a function is executed.
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|double
operator|>
name|FunctionInformation
expr_stmt|;
name|ProfileInfoT
operator|<
name|MachineFunction
operator|,
name|MachineBasicBlock
operator|>
operator|*
name|MachineProfile
expr_stmt|;
name|public
label|:
specifier|static
name|char
name|ID
decl_stmt|;
comment|// Class identification, replacement for typeinfo
name|ProfileInfoT
argument_list|()
expr_stmt|;
operator|~
name|ProfileInfoT
argument_list|()
expr_stmt|;
comment|// We want to be subclassed
comment|// MissingValue - The value that is returned for execution counts in case
comment|// no value is available.
specifier|static
specifier|const
name|double
name|MissingValue
decl_stmt|;
comment|// getFunction() - Returns the Function for an Edge, checking for validity.
specifier|static
specifier|const
name|FType
modifier|*
name|getFunction
parameter_list|(
name|Edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|first
condition|)
block|{
return|return
name|e
operator|.
name|first
operator|->
name|getParent
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|second
condition|)
block|{
return|return
name|e
operator|.
name|second
operator|->
name|getParent
argument_list|()
return|;
block|}
name|assert
argument_list|(
literal|0
operator|&&
literal|"Invalid ProfileInfo::Edge"
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|FType
operator|*
operator|)
literal|0
return|;
block|}
comment|// getEdge() - Creates an Edge from two BasicBlocks.
specifier|static
name|Edge
name|getEdge
parameter_list|(
specifier|const
name|BType
modifier|*
name|Src
parameter_list|,
specifier|const
name|BType
modifier|*
name|Dest
parameter_list|)
block|{
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|Src
argument_list|,
name|Dest
argument_list|)
return|;
block|}
comment|//===------------------------------------------------------------------===//
comment|/// Profile Information Queries
comment|///
name|double
name|getExecutionCount
parameter_list|(
specifier|const
name|FType
modifier|*
name|F
parameter_list|)
function_decl|;
name|double
name|getExecutionCount
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|)
function_decl|;
name|void
name|setExecutionCount
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|,
name|double
name|w
parameter_list|)
function_decl|;
name|void
name|addExecutionCount
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|,
name|double
name|w
parameter_list|)
function_decl|;
name|double
name|getEdgeWeight
argument_list|(
name|Edge
name|e
argument_list|)
decl|const
block|{
name|typename
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|EdgeWeights
operator|>
operator|::
name|const_iterator
name|J
operator|=
name|EdgeInformation
operator|.
name|find
argument_list|(
name|getFunction
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|J
operator|==
name|EdgeInformation
operator|.
name|end
argument_list|()
condition|)
return|return
name|MissingValue
return|;
name|typename
name|EdgeWeights
operator|::
name|const_iterator
name|I
operator|=
name|J
operator|->
name|second
operator|.
name|find
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|J
operator|->
name|second
operator|.
name|end
argument_list|()
condition|)
return|return
name|MissingValue
return|;
return|return
name|I
operator|->
name|second
return|;
block|}
name|void
name|setEdgeWeight
parameter_list|(
name|Edge
name|e
parameter_list|,
name|double
name|w
parameter_list|)
block|{
name|DEBUG_WITH_TYPE
argument_list|(
literal|"profile-info"
argument_list|,
name|dbgs
argument_list|()
operator|<<
literal|"Creating Edge "
operator|<<
name|e
operator|<<
literal|" (weight: "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|w
argument_list|)
operator|<<
literal|")\n"
argument_list|)
expr_stmt|;
name|EdgeInformation
index|[
name|getFunction
argument_list|(
name|e
argument_list|)
index|]
index|[
name|e
index|]
operator|=
name|w
expr_stmt|;
block|}
name|void
name|addEdgeWeight
parameter_list|(
name|Edge
name|e
parameter_list|,
name|double
name|w
parameter_list|)
function_decl|;
name|EdgeWeights
modifier|&
name|getEdgeWeights
parameter_list|(
specifier|const
name|FType
modifier|*
name|F
parameter_list|)
block|{
return|return
name|EdgeInformation
index|[
name|F
index|]
return|;
block|}
comment|//===------------------------------------------------------------------===//
comment|/// Analysis Update Methods
comment|///
name|void
name|removeBlock
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|)
function_decl|;
name|void
name|removeEdge
parameter_list|(
name|Edge
name|e
parameter_list|)
function_decl|;
name|void
name|replaceEdge
parameter_list|(
specifier|const
name|Edge
modifier|&
parameter_list|,
specifier|const
name|Edge
modifier|&
parameter_list|)
function_decl|;
enum|enum
name|GetPathMode
block|{
name|GetPathToExit
init|=
literal|1
block|,
name|GetPathToValue
init|=
literal|2
block|,
name|GetPathToDest
init|=
literal|4
block|,
name|GetPathWithNewEdges
init|=
literal|8
block|}
enum|;
specifier|const
name|BType
modifier|*
name|GetPath
parameter_list|(
specifier|const
name|BType
modifier|*
name|Src
parameter_list|,
specifier|const
name|BType
modifier|*
name|Dest
parameter_list|,
name|Path
modifier|&
name|P
parameter_list|,
name|unsigned
name|Mode
parameter_list|)
function_decl|;
name|void
name|divertFlow
parameter_list|(
specifier|const
name|Edge
modifier|&
parameter_list|,
specifier|const
name|Edge
modifier|&
parameter_list|)
function_decl|;
name|void
name|splitEdge
parameter_list|(
specifier|const
name|BType
modifier|*
name|FirstBB
parameter_list|,
specifier|const
name|BType
modifier|*
name|SecondBB
parameter_list|,
specifier|const
name|BType
modifier|*
name|NewBB
parameter_list|,
name|bool
name|MergeIdenticalEdges
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|splitBlock
parameter_list|(
specifier|const
name|BType
modifier|*
name|Old
parameter_list|,
specifier|const
name|BType
modifier|*
name|New
parameter_list|)
function_decl|;
name|void
name|splitBlock
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|,
specifier|const
name|BType
modifier|*
name|NewBB
parameter_list|,
name|BType
modifier|*
specifier|const
modifier|*
name|Preds
parameter_list|,
name|unsigned
name|NumPreds
parameter_list|)
function_decl|;
name|void
name|replaceAllUses
parameter_list|(
specifier|const
name|BType
modifier|*
name|RmBB
parameter_list|,
specifier|const
name|BType
modifier|*
name|DestBB
parameter_list|)
function_decl|;
name|void
name|transfer
parameter_list|(
specifier|const
name|FType
modifier|*
name|Old
parameter_list|,
specifier|const
name|FType
modifier|*
name|New
parameter_list|)
function_decl|;
name|void
name|repair
parameter_list|(
specifier|const
name|FType
modifier|*
name|F
parameter_list|)
function_decl|;
name|void
name|dump
parameter_list|(
name|FType
modifier|*
name|F
init|=
literal|0
parameter_list|,
name|bool
name|real
init|=
name|true
parameter_list|)
block|{
name|dbgs
argument_list|()
operator|<<
literal|"**** This is ProfileInfo "
operator|<<
name|this
operator|<<
literal|" speaking:\n"
expr_stmt|;
if|if
condition|(
operator|!
name|real
condition|)
block|{
name|typename
name|std
operator|::
name|set
operator|<
specifier|const
name|FType
operator|*
operator|>
name|Functions
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
literal|"Functions: \n"
expr_stmt|;
if|if
condition|(
name|F
condition|)
block|{
name|dbgs
argument_list|()
operator|<<
name|F
operator|<<
literal|"@"
operator|<<
name|format
argument_list|(
literal|"%p"
argument_list|,
name|F
argument_list|)
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|getExecutionCount
argument_list|(
name|F
argument_list|)
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
name|Functions
operator|.
name|insert
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|typename
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|double
operator|>
operator|::
name|iterator
name|fi
operator|=
name|FunctionInformation
operator|.
name|begin
argument_list|()
operator|,
name|fe
operator|=
name|FunctionInformation
operator|.
name|end
argument_list|()
init|;
name|fi
operator|!=
name|fe
condition|;
operator|++
name|fi
control|)
block|{
name|dbgs
argument_list|()
operator|<<
name|fi
operator|->
name|first
operator|<<
literal|"@"
operator|<<
name|format
argument_list|(
literal|"%p"
argument_list|,
name|fi
operator|->
name|first
argument_list|)
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|fi
operator|->
name|second
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
name|Functions
operator|.
name|insert
argument_list|(
name|fi
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|typename
name|std
operator|::
name|set
operator|<
specifier|const
name|FType
operator|*
operator|>
operator|::
name|iterator
name|FI
operator|=
name|Functions
operator|.
name|begin
argument_list|()
operator|,
name|FE
operator|=
name|Functions
operator|.
name|end
argument_list|()
init|;
name|FI
operator|!=
name|FE
condition|;
operator|++
name|FI
control|)
block|{
specifier|const
name|FType
modifier|*
name|F
init|=
operator|*
name|FI
decl_stmt|;
name|typename
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|BlockCounts
operator|>
operator|::
name|iterator
name|bwi
operator|=
name|BlockInformation
operator|.
name|find
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
literal|"BasicBlocks for Function "
operator|<<
name|F
operator|<<
literal|":\n"
expr_stmt|;
for|for
control|(
name|typename
name|BlockCounts
operator|::
name|const_iterator
name|bi
operator|=
name|bwi
operator|->
name|second
operator|.
name|begin
argument_list|()
operator|,
name|be
operator|=
name|bwi
operator|->
name|second
operator|.
name|end
argument_list|()
init|;
name|bi
operator|!=
name|be
condition|;
operator|++
name|bi
control|)
block|{
name|dbgs
argument_list|()
operator|<<
name|bi
operator|->
name|first
operator|<<
literal|"@"
operator|<<
name|format
argument_list|(
literal|"%p"
argument_list|,
name|bi
operator|->
name|first
argument_list|)
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|bi
operator|->
name|second
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
for|for
control|(
name|typename
name|std
operator|::
name|set
operator|<
specifier|const
name|FType
operator|*
operator|>
operator|::
name|iterator
name|FI
operator|=
name|Functions
operator|.
name|begin
argument_list|()
operator|,
name|FE
operator|=
name|Functions
operator|.
name|end
argument_list|()
init|;
name|FI
operator|!=
name|FE
condition|;
operator|++
name|FI
control|)
block|{
name|typename
name|std
operator|::
name|map
operator|<
specifier|const
name|FType
operator|*
operator|,
name|EdgeWeights
operator|>
operator|::
name|iterator
name|ei
operator|=
name|EdgeInformation
operator|.
name|find
argument_list|(
operator|*
name|FI
argument_list|)
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
literal|"Edges for Function "
operator|<<
name|ei
operator|->
name|first
operator|<<
literal|":\n"
expr_stmt|;
for|for
control|(
name|typename
name|EdgeWeights
operator|::
name|iterator
name|ewi
operator|=
name|ei
operator|->
name|second
operator|.
name|begin
argument_list|()
operator|,
name|ewe
operator|=
name|ei
operator|->
name|second
operator|.
name|end
argument_list|()
init|;
name|ewi
operator|!=
name|ewe
condition|;
operator|++
name|ewi
control|)
block|{
name|dbgs
argument_list|()
operator|<<
name|ewi
operator|->
name|first
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|ewi
operator|->
name|second
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|F
operator|&&
literal|"No function given, this is not supported!"
argument_list|)
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
literal|"Functions: \n"
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
name|F
operator|<<
literal|"@"
operator|<<
name|format
argument_list|(
literal|"%p"
argument_list|,
name|F
argument_list|)
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|getExecutionCount
argument_list|(
name|F
argument_list|)
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
name|dbgs
argument_list|()
operator|<<
literal|"BasicBlocks for Function "
operator|<<
name|F
operator|<<
literal|":\n"
expr_stmt|;
for|for
control|(
name|typename
name|FType
operator|::
name|const_iterator
name|BI
operator|=
name|F
operator|->
name|begin
argument_list|()
operator|,
name|BE
operator|=
name|F
operator|->
name|end
argument_list|()
init|;
name|BI
operator|!=
name|BE
condition|;
operator|++
name|BI
control|)
block|{
specifier|const
name|BType
modifier|*
name|BB
init|=
operator|&
operator|(
operator|*
name|BI
operator|)
decl_stmt|;
name|dbgs
argument_list|()
operator|<<
name|BB
operator|<<
literal|"@"
operator|<<
name|format
argument_list|(
literal|"%p"
argument_list|,
name|BB
argument_list|)
operator|<<
literal|": "
operator|<<
name|format
argument_list|(
literal|"%.20g"
argument_list|,
name|getExecutionCount
argument_list|(
name|BB
argument_list|)
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
name|dbgs
argument_list|()
operator|<<
literal|"**** ProfileInfo "
operator|<<
name|this
operator|<<
literal|", over and out.\n"
expr_stmt|;
block|}
name|bool
name|CalculateMissingEdge
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|,
name|Edge
modifier|&
name|removed
parameter_list|,
name|bool
name|assumeEmptyExit
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|EstimateMissingEdges
parameter_list|(
specifier|const
name|BType
modifier|*
name|BB
parameter_list|)
function_decl|;
name|ProfileInfoT
operator|<
name|MachineFunction
operator|,
name|MachineBasicBlock
operator|>
operator|*
name|MI
argument_list|()
block|{
if|if
condition|(
name|MachineProfile
operator|==
literal|0
condition|)
name|MachineProfile
operator|=
name|new
name|ProfileInfoT
operator|<
name|MachineFunction
operator|,
name|MachineBasicBlock
operator|>
operator|(
operator|)
expr_stmt|;
return|return
name|MachineProfile
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|hasMI
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MachineProfile
operator|!=
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_typedef
unit|};
typedef|typedef
name|ProfileInfoT
operator|<
name|Function
operator|,
name|BasicBlock
operator|>
name|ProfileInfo
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ProfileInfoT
operator|<
name|MachineFunction
operator|,
name|MachineBasicBlock
operator|>
name|MachineProfileInfo
expr_stmt|;
end_typedef

begin_comment
comment|/// createProfileLoaderPass - This function returns a Pass that loads the
end_comment

begin_comment
comment|/// profiling information for the module from the specified filename, making
end_comment

begin_comment
comment|/// it available to the optimizers.
end_comment

begin_decl_stmt
name|Pass
modifier|*
name|createProfileLoaderPass
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Filename
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

