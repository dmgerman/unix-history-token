begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/DominanceFrontier.h - Dominator Frontiers --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This is the generic implementation of the DominanceFrontier class, which
end_comment

begin_comment
comment|// calculate and holds the dominance frontier for a function for.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This should be considered deprecated, don't add any more uses of this data
end_comment

begin_comment
comment|// structure.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_DOMINANCEFRONTIERIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_DOMINANCEFRONTIERIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/DominanceFrontier.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/GenericDomTree.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|class
name|BlockT
operator|>
name|class
name|DFCalculateWorkObject
block|{
name|public
operator|:
typedef|typedef
name|DomTreeNodeBase
operator|<
name|BlockT
operator|>
name|DomTreeNodeT
expr_stmt|;
name|DFCalculateWorkObject
argument_list|(
name|BlockT
operator|*
name|B
argument_list|,
name|BlockT
operator|*
name|P
argument_list|,
specifier|const
name|DomTreeNodeT
operator|*
name|N
argument_list|,
specifier|const
name|DomTreeNodeT
operator|*
name|PN
argument_list|)
operator|:
name|currentBB
argument_list|(
name|B
argument_list|)
operator|,
name|parentBB
argument_list|(
name|P
argument_list|)
operator|,
name|Node
argument_list|(
name|N
argument_list|)
operator|,
name|parentNode
argument_list|(
argument|PN
argument_list|)
block|{}
name|BlockT
operator|*
name|currentBB
expr_stmt|;
name|BlockT
modifier|*
name|parentBB
decl_stmt|;
specifier|const
name|DomTreeNodeT
modifier|*
name|Node
decl_stmt|;
specifier|const
name|DomTreeNodeT
modifier|*
name|parentNode
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|void
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|removeBlock
argument_list|(
argument|BlockT *BB
argument_list|)
block|{
name|assert
argument_list|(
name|find
argument_list|(
name|BB
argument_list|)
operator|!=
name|end
argument_list|()
operator|&&
literal|"Block is not in DominanceFrontier!"
argument_list|)
block|;
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|I
operator|->
name|second
operator|.
name|erase
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|Frontiers
operator|.
name|erase
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|void
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|addToFrontier
argument_list|(
argument|iterator I
argument_list|,
argument|BlockT *Node
argument_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|end
argument_list|()
operator|&&
literal|"BB is not in DominanceFrontier!"
argument_list|)
block|;
name|assert
argument_list|(
name|I
operator|->
name|second
operator|.
name|count
argument_list|(
name|Node
argument_list|)
operator|&&
literal|"Node is not in DominanceFrontier of BB"
argument_list|)
block|;
name|I
operator|->
name|second
operator|.
name|erase
argument_list|(
name|Node
argument_list|)
block|; }
name|template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|void
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|removeFromFrontier
argument_list|(
argument|iterator I
argument_list|,
argument|BlockT *Node
argument_list|)
block|{
name|assert
argument_list|(
name|I
operator|!=
name|end
argument_list|()
operator|&&
literal|"BB is not in DominanceFrontier!"
argument_list|)
block|;
name|assert
argument_list|(
name|I
operator|->
name|second
operator|.
name|count
argument_list|(
name|Node
argument_list|)
operator|&&
literal|"Node is not in DominanceFrontier of BB"
argument_list|)
block|;
name|I
operator|->
name|second
operator|.
name|erase
argument_list|(
name|Node
argument_list|)
block|; }
name|template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|bool
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|compareDomSet
argument_list|(
argument|DomSetType&DS1
argument_list|,
argument|const DomSetType&DS2
argument_list|)
specifier|const
block|{
name|std
operator|::
name|set
operator|<
name|BlockT
operator|*
operator|>
name|tmpSet
block|;
for|for
control|(
name|BlockT
modifier|*
name|BB
range|:
name|DS2
control|)
name|tmpSet
operator|.
name|insert
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|DomSetType
operator|::
name|const_iterator
name|I
operator|=
name|DS1
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|DS1
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
control|)
block|{
name|BlockT
modifier|*
name|Node
init|=
operator|*
name|I
operator|++
decl_stmt|;
if|if
condition|(
name|tmpSet
operator|.
name|erase
argument_list|(
name|Node
argument_list|)
operator|==
literal|0
condition|)
comment|// Node is in DS1 but tnot in DS2.
return|return
name|true
return|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|tmpSet
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// There are nodes that are in DS2 but not in DS1.
return|return
name|true
return|;
block|}
end_if

begin_comment
comment|// DS1 and DS2 matches.
end_comment

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|bool
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|compare
argument_list|(
argument|DominanceFrontierBase<BlockT
argument_list|,
argument|IsPostDom>&Other
argument_list|)
specifier|const
block|{
name|DomSetMapType
name|tmpFrontiers
block|;
for|for
control|(
name|typename
name|DomSetMapType
operator|::
name|const_iterator
name|I
operator|=
name|Other
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Other
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|tmpFrontiers
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|I
operator|->
name|first
argument_list|,
name|I
operator|->
name|second
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|DomSetMapType
operator|::
name|iterator
name|I
operator|=
name|tmpFrontiers
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|tmpFrontiers
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
control|)
block|{
name|BlockT
modifier|*
name|Node
init|=
name|I
operator|->
name|first
decl_stmt|;
name|const_iterator
name|DFI
init|=
name|find
argument_list|(
name|Node
argument_list|)
decl_stmt|;
if|if
condition|(
name|DFI
operator|==
name|end
argument_list|()
condition|)
return|return
name|true
return|;
if|if
condition|(
name|compareDomSet
argument_list|(
name|I
operator|->
name|second
argument_list|,
name|DFI
operator|->
name|second
argument_list|)
condition|)
return|return
name|true
return|;
operator|++
name|I
expr_stmt|;
name|tmpFrontiers
operator|.
name|erase
argument_list|(
name|Node
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|tmpFrontiers
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
end_if

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|void
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|{
for|for
control|(
name|const_iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|OS
operator|<<
literal|"  DomFrontier for BB "
expr_stmt|;
if|if
condition|(
name|I
operator|->
name|first
condition|)
name|I
operator|->
name|first
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|OS
operator|<<
literal|"<<exit node>>"
expr_stmt|;
name|OS
operator|<<
literal|" is:\t"
expr_stmt|;
specifier|const
name|std
operator|::
name|set
operator|<
name|BlockT
operator|*
operator|>
operator|&
name|BBs
operator|=
name|I
operator|->
name|second
expr_stmt|;
for|for
control|(
specifier|const
name|BlockT
modifier|*
name|BB
range|:
name|BBs
control|)
block|{
name|OS
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
name|BB
condition|)
name|BB
operator|->
name|printAsOperand
argument_list|(
name|OS
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|OS
operator|<<
literal|"<<exit node>>"
expr_stmt|;
block|}
name|OS
operator|<<
literal|'\n'
expr_stmt|;
end_expr_stmt

begin_if
unit|} }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|LLVM_ENABLE_DUMP
argument_list|)
end_if

begin_expr_stmt
name|template
operator|<
name|class
name|BlockT
operator|,
name|bool
name|IsPostDom
operator|>
name|void
name|DominanceFrontierBase
operator|<
name|BlockT
operator|,
name|IsPostDom
operator|>
operator|::
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
name|dbgs
argument_list|()
argument_list|)
block|; }
endif|#
directive|endif
name|template
operator|<
name|class
name|BlockT
operator|>
specifier|const
name|typename
name|ForwardDominanceFrontierBase
operator|<
name|BlockT
operator|>
operator|::
name|DomSetType
operator|&
name|ForwardDominanceFrontierBase
operator|<
name|BlockT
operator|>
operator|::
name|calculate
argument_list|(
argument|const DomTreeT&DT
argument_list|,
argument|const DomTreeNodeT *Node
argument_list|)
block|{
name|BlockT
operator|*
name|BB
operator|=
name|Node
operator|->
name|getBlock
argument_list|()
block|;
name|DomSetType
operator|*
name|Result
operator|=
name|nullptr
block|;
name|std
operator|::
name|vector
operator|<
name|DFCalculateWorkObject
operator|<
name|BlockT
operator|>>
name|workList
block|;
name|SmallPtrSet
operator|<
name|BlockT
operator|*
block|,
literal|32
operator|>
name|visited
block|;
name|workList
operator|.
name|push_back
argument_list|(
name|DFCalculateWorkObject
operator|<
name|BlockT
operator|>
operator|(
name|BB
operator|,
name|nullptr
operator|,
name|Node
operator|,
name|nullptr
operator|)
argument_list|)
block|;
do|do
block|{
name|DFCalculateWorkObject
operator|<
name|BlockT
operator|>
operator|*
name|currentW
operator|=
operator|&
name|workList
operator|.
name|back
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|currentW
operator|&&
literal|"Missing work object."
argument_list|)
expr_stmt|;
name|BlockT
modifier|*
name|currentBB
init|=
name|currentW
operator|->
name|currentBB
decl_stmt|;
name|BlockT
modifier|*
name|parentBB
init|=
name|currentW
operator|->
name|parentBB
decl_stmt|;
specifier|const
name|DomTreeNodeT
modifier|*
name|currentNode
init|=
name|currentW
operator|->
name|Node
decl_stmt|;
specifier|const
name|DomTreeNodeT
modifier|*
name|parentNode
init|=
name|currentW
operator|->
name|parentNode
decl_stmt|;
name|assert
argument_list|(
name|currentBB
operator|&&
literal|"Invalid work object. Missing current Basic Block"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|currentNode
operator|&&
literal|"Invalid work object. Missing current Node"
argument_list|)
expr_stmt|;
name|DomSetType
modifier|&
name|S
init|=
name|this
operator|->
name|Frontiers
index|[
name|currentBB
index|]
decl_stmt|;
comment|// Visit each block only once.
if|if
condition|(
name|visited
operator|.
name|insert
argument_list|(
name|currentBB
argument_list|)
operator|.
name|second
condition|)
block|{
comment|// Loop over CFG successors to calculate DFlocal[currentNode]
for|for
control|(
specifier|const
specifier|auto
name|Succ
range|:
name|children
operator|<
name|BlockT
operator|*
operator|>
operator|(
name|currentBB
operator|)
control|)
block|{
comment|// Does Node immediately dominate this successor?
if|if
condition|(
name|DT
index|[
name|Succ
index|]
operator|->
name|getIDom
argument_list|()
operator|!=
name|currentNode
condition|)
name|S
operator|.
name|insert
argument_list|(
name|Succ
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// At this point, S is DFlocal.  Now we union in DFup's of our children...
end_comment

begin_comment
comment|// Loop through and visit the nodes that Node immediately dominates (Node's
end_comment

begin_comment
comment|// children in the IDomTree)
end_comment

begin_expr_stmt
unit|bool
name|visitChild
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|DomTreeNodeT
operator|::
name|const_iterator
name|NI
operator|=
name|currentNode
operator|->
name|begin
argument_list|()
operator|,
name|NE
operator|=
name|currentNode
operator|->
name|end
argument_list|()
init|;
name|NI
operator|!=
name|NE
condition|;
operator|++
name|NI
control|)
block|{
name|DomTreeNodeT
modifier|*
name|IDominee
init|=
operator|*
name|NI
decl_stmt|;
name|BlockT
modifier|*
name|childBB
init|=
name|IDominee
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|visited
operator|.
name|count
argument_list|(
name|childBB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|workList
operator|.
name|push_back
argument_list|(
name|DFCalculateWorkObject
operator|<
name|BlockT
operator|>
operator|(
name|childBB
operator|,
name|currentBB
operator|,
name|IDominee
operator|,
name|currentNode
operator|)
argument_list|)
expr_stmt|;
name|visitChild
operator|=
name|true
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|// If all children are visited or there is any child then pop this block
end_comment

begin_comment
comment|// from the workList.
end_comment

begin_if
if|if
condition|(
operator|!
name|visitChild
condition|)
block|{
if|if
condition|(
operator|!
name|parentBB
condition|)
block|{
name|Result
operator|=
operator|&
name|S
expr_stmt|;
break|break;
block|}
name|typename
name|DomSetType
operator|::
name|const_iterator
name|CDFI
operator|=
name|S
operator|.
name|begin
argument_list|()
operator|,
name|CDFE
operator|=
name|S
operator|.
name|end
argument_list|()
expr_stmt|;
name|DomSetType
modifier|&
name|parentSet
init|=
name|this
operator|->
name|Frontiers
index|[
name|parentBB
index|]
decl_stmt|;
for|for
control|(
init|;
name|CDFI
operator|!=
name|CDFE
condition|;
operator|++
name|CDFI
control|)
block|{
if|if
condition|(
operator|!
name|DT
operator|.
name|properlyDominates
argument_list|(
name|parentNode
argument_list|,
name|DT
index|[
operator|*
name|CDFI
index|]
argument_list|)
condition|)
name|parentSet
operator|.
name|insert
argument_list|(
operator|*
name|CDFI
argument_list|)
expr_stmt|;
block|}
name|workList
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|} while
operator|(
operator|!
name|workList
operator|.
name|empty
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|Result
return|;
end_return

begin_comment
unit|}  }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

