begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- TargetTransformInfoImpl.h --------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file provides helpers for the implementation of
end_comment

begin_comment
comment|/// a TargetTransformInfo-conforming class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_TARGETTRANSFORMINFOIMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_TARGETTRANSFORMINFOIMPL_H
end_define

begin_include
include|#
directive|include
file|"llvm/Analysis/ScalarEvolutionExpressions.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/TargetTransformInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/VectorUtils.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/CallSite.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DataLayout.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GetElementPtrTypeIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Operator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Type.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// \brief Base class for use as a mix-in that aids implementing
comment|/// a TargetTransformInfo-compatible class.
name|class
name|TargetTransformInfoImplBase
block|{
name|protected
label|:
typedef|typedef
name|TargetTransformInfo
name|TTI
typedef|;
specifier|const
name|DataLayout
modifier|&
name|DL
decl_stmt|;
name|explicit
name|TargetTransformInfoImplBase
argument_list|(
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|)
operator|:
name|DL
argument_list|(
argument|DL
argument_list|)
block|{}
name|public
operator|:
comment|// Provide value semantics. MSVC requires that we spell all of these out.
name|TargetTransformInfoImplBase
argument_list|(
specifier|const
name|TargetTransformInfoImplBase
operator|&
name|Arg
argument_list|)
operator|:
name|DL
argument_list|(
argument|Arg.DL
argument_list|)
block|{}
name|TargetTransformInfoImplBase
argument_list|(
name|TargetTransformInfoImplBase
operator|&&
name|Arg
argument_list|)
operator|:
name|DL
argument_list|(
argument|Arg.DL
argument_list|)
block|{}
specifier|const
name|DataLayout
operator|&
name|getDataLayout
argument_list|()
specifier|const
block|{
return|return
name|DL
return|;
block|}
name|unsigned
name|getOperationCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|,
name|Type
modifier|*
name|OpTy
parameter_list|)
block|{
switch|switch
condition|(
name|Opcode
condition|)
block|{
default|default:
comment|// By default, just classify everything as 'basic'.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
case|case
name|Instruction
operator|::
name|GetElementPtr
case|:
name|llvm_unreachable
argument_list|(
literal|"Use getGEPCost for GEP operations!"
argument_list|)
expr_stmt|;
case|case
name|Instruction
operator|::
name|BitCast
case|:
name|assert
argument_list|(
name|OpTy
operator|&&
literal|"Cast instructions must provide the operand type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ty
operator|==
name|OpTy
operator|||
operator|(
name|Ty
operator|->
name|isPointerTy
argument_list|()
operator|&&
name|OpTy
operator|->
name|isPointerTy
argument_list|()
operator|)
condition|)
comment|// Identity and pointer-to-pointer casts are free.
return|return
name|TTI
operator|::
name|TCC_Free
return|;
comment|// Otherwise, the default basic cost is used.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
case|case
name|Instruction
operator|::
name|FDiv
case|:
case|case
name|Instruction
operator|::
name|FRem
case|:
case|case
name|Instruction
operator|::
name|SDiv
case|:
case|case
name|Instruction
operator|::
name|SRem
case|:
case|case
name|Instruction
operator|::
name|UDiv
case|:
case|case
name|Instruction
operator|::
name|URem
case|:
return|return
name|TTI
operator|::
name|TCC_Expensive
return|;
case|case
name|Instruction
operator|::
name|IntToPtr
case|:
block|{
comment|// An inttoptr cast is free so long as the input is a legal integer type
comment|// which doesn't contain values outside the range of a pointer.
name|unsigned
name|OpSize
init|=
name|OpTy
operator|->
name|getScalarSizeInBits
argument_list|()
decl_stmt|;
if|if
condition|(
name|DL
operator|.
name|isLegalInteger
argument_list|(
name|OpSize
argument_list|)
operator|&&
name|OpSize
operator|<=
name|DL
operator|.
name|getPointerTypeSizeInBits
argument_list|(
name|Ty
argument_list|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
comment|// Otherwise it's not a no-op.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
case|case
name|Instruction
operator|::
name|PtrToInt
case|:
block|{
comment|// A ptrtoint cast is free so long as the result is large enough to store
comment|// the pointer, and a legal integer type.
name|unsigned
name|DestSize
init|=
name|Ty
operator|->
name|getScalarSizeInBits
argument_list|()
decl_stmt|;
if|if
condition|(
name|DL
operator|.
name|isLegalInteger
argument_list|(
name|DestSize
argument_list|)
operator|&&
name|DestSize
operator|>=
name|DL
operator|.
name|getPointerTypeSizeInBits
argument_list|(
name|OpTy
argument_list|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
comment|// Otherwise it's not a no-op.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
case|case
name|Instruction
operator|::
name|Trunc
case|:
comment|// trunc to a native type is free (assuming the target has compare and
comment|// shift-right of the same width).
if|if
condition|(
name|DL
operator|.
name|isLegalInteger
argument_list|(
name|DL
operator|.
name|getTypeSizeInBits
argument_list|(
name|Ty
argument_list|)
argument_list|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
block|}
name|int
name|getGEPCost
argument_list|(
name|Type
operator|*
name|PointeeType
argument_list|,
specifier|const
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Operands
argument_list|)
block|{
comment|// In the basic model, we just assume that all-constant GEPs will be folded
comment|// into their uses via addressing modes.
for|for
control|(
name|unsigned
name|Idx
init|=
literal|0
init|,
name|Size
init|=
name|Operands
operator|.
name|size
argument_list|()
init|;
name|Idx
operator|!=
name|Size
condition|;
operator|++
name|Idx
control|)
if|if
condition|(
operator|!
name|isa
operator|<
name|Constant
operator|>
operator|(
name|Operands
index|[
name|Idx
index|]
operator|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
return|return
name|TTI
operator|::
name|TCC_Free
return|;
block|}
name|unsigned
name|getEstimatedNumberOfCaseClusters
parameter_list|(
specifier|const
name|SwitchInst
modifier|&
name|SI
parameter_list|,
name|unsigned
modifier|&
name|JTSize
parameter_list|)
block|{
name|JTSize
operator|=
literal|0
expr_stmt|;
return|return
name|SI
operator|.
name|getNumCases
argument_list|()
return|;
block|}
name|int
name|getExtCost
parameter_list|(
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|,
specifier|const
name|Value
modifier|*
name|Src
parameter_list|)
block|{
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
name|unsigned
name|getCallCost
parameter_list|(
name|FunctionType
modifier|*
name|FTy
parameter_list|,
name|int
name|NumArgs
parameter_list|)
block|{
name|assert
argument_list|(
name|FTy
operator|&&
literal|"FunctionType must be provided to this routine."
argument_list|)
expr_stmt|;
comment|// The target-independent implementation just measures the size of the
comment|// function by approximating that each argument will take on average one
comment|// instruction to prepare.
if|if
condition|(
name|NumArgs
operator|<
literal|0
condition|)
comment|// Set the argument number to the number of explicit arguments in the
comment|// function.
name|NumArgs
operator|=
name|FTy
operator|->
name|getNumParams
argument_list|()
expr_stmt|;
return|return
name|TTI
operator|::
name|TCC_Basic
operator|*
operator|(
name|NumArgs
operator|+
literal|1
operator|)
return|;
block|}
name|unsigned
name|getInliningThresholdMultiplier
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|ParamTys
argument_list|)
block|{
switch|switch
condition|(
name|IID
condition|)
block|{
default|default:
comment|// Intrinsics rarely (if ever) have normal argument setup constraints.
comment|// Model them as having a basic instruction cost.
comment|// FIXME: This is wrong for libc intrinsics.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
case|case
name|Intrinsic
operator|::
name|annotation
case|:
case|case
name|Intrinsic
operator|::
name|assume
case|:
case|case
name|Intrinsic
operator|::
name|dbg_declare
case|:
case|case
name|Intrinsic
operator|::
name|dbg_value
case|:
case|case
name|Intrinsic
operator|::
name|invariant_start
case|:
case|case
name|Intrinsic
operator|::
name|invariant_end
case|:
case|case
name|Intrinsic
operator|::
name|lifetime_start
case|:
case|case
name|Intrinsic
operator|::
name|lifetime_end
case|:
case|case
name|Intrinsic
operator|::
name|objectsize
case|:
case|case
name|Intrinsic
operator|::
name|ptr_annotation
case|:
case|case
name|Intrinsic
operator|::
name|var_annotation
case|:
case|case
name|Intrinsic
operator|::
name|experimental_gc_result
case|:
case|case
name|Intrinsic
operator|::
name|experimental_gc_relocate
case|:
case|case
name|Intrinsic
operator|::
name|coro_alloc
case|:
case|case
name|Intrinsic
operator|::
name|coro_begin
case|:
case|case
name|Intrinsic
operator|::
name|coro_free
case|:
case|case
name|Intrinsic
operator|::
name|coro_end
case|:
case|case
name|Intrinsic
operator|::
name|coro_frame
case|:
case|case
name|Intrinsic
operator|::
name|coro_size
case|:
case|case
name|Intrinsic
operator|::
name|coro_suspend
case|:
case|case
name|Intrinsic
operator|::
name|coro_param
case|:
case|case
name|Intrinsic
operator|::
name|coro_subfn_addr
case|:
comment|// These intrinsics don't actually represent code after lowering.
return|return
name|TTI
operator|::
name|TCC_Free
return|;
block|}
block|}
name|bool
name|hasBranchDivergence
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|isSourceOfDivergence
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isAlwaysUniform
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getFlatAddressSpace
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
name|bool
name|isLoweredToCall
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|)
block|{
comment|// FIXME: These should almost certainly not be handled here, and instead
comment|// handled with the help of TLI or the target itself. This was largely
comment|// ported from existing analysis heuristics here so that such refactorings
comment|// can take place in the future.
if|if
condition|(
name|F
operator|->
name|isIntrinsic
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|F
operator|->
name|hasLocalLinkage
argument_list|()
operator|||
operator|!
name|F
operator|->
name|hasName
argument_list|()
condition|)
return|return
name|true
return|;
name|StringRef
name|Name
init|=
name|F
operator|->
name|getName
argument_list|()
decl_stmt|;
comment|// These will all likely lower to a single selection DAG node.
if|if
condition|(
name|Name
operator|==
literal|"copysign"
operator|||
name|Name
operator|==
literal|"copysignf"
operator|||
name|Name
operator|==
literal|"copysignl"
operator|||
name|Name
operator|==
literal|"fabs"
operator|||
name|Name
operator|==
literal|"fabsf"
operator|||
name|Name
operator|==
literal|"fabsl"
operator|||
name|Name
operator|==
literal|"sin"
operator|||
name|Name
operator|==
literal|"fmin"
operator|||
name|Name
operator|==
literal|"fminf"
operator|||
name|Name
operator|==
literal|"fminl"
operator|||
name|Name
operator|==
literal|"fmax"
operator|||
name|Name
operator|==
literal|"fmaxf"
operator|||
name|Name
operator|==
literal|"fmaxl"
operator|||
name|Name
operator|==
literal|"sinf"
operator|||
name|Name
operator|==
literal|"sinl"
operator|||
name|Name
operator|==
literal|"cos"
operator|||
name|Name
operator|==
literal|"cosf"
operator|||
name|Name
operator|==
literal|"cosl"
operator|||
name|Name
operator|==
literal|"sqrt"
operator|||
name|Name
operator|==
literal|"sqrtf"
operator|||
name|Name
operator|==
literal|"sqrtl"
condition|)
return|return
name|false
return|;
comment|// These are all likely to be optimized into something smaller.
if|if
condition|(
name|Name
operator|==
literal|"pow"
operator|||
name|Name
operator|==
literal|"powf"
operator|||
name|Name
operator|==
literal|"powl"
operator|||
name|Name
operator|==
literal|"exp2"
operator|||
name|Name
operator|==
literal|"exp2l"
operator|||
name|Name
operator|==
literal|"exp2f"
operator|||
name|Name
operator|==
literal|"floor"
operator|||
name|Name
operator|==
literal|"floorf"
operator|||
name|Name
operator|==
literal|"ceil"
operator|||
name|Name
operator|==
literal|"round"
operator|||
name|Name
operator|==
literal|"ffs"
operator|||
name|Name
operator|==
literal|"ffsl"
operator|||
name|Name
operator|==
literal|"abs"
operator|||
name|Name
operator|==
literal|"labs"
operator|||
name|Name
operator|==
literal|"llabs"
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|void
name|getUnrollingPreferences
argument_list|(
name|Loop
operator|*
argument_list|,
name|ScalarEvolution
operator|&
argument_list|,
name|TTI
operator|::
name|UnrollingPreferences
operator|&
argument_list|)
block|{}
name|bool
name|isLegalAddImmediate
parameter_list|(
name|int64_t
name|Imm
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalICmpImmediate
parameter_list|(
name|int64_t
name|Imm
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalAddressingMode
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
comment|// Guess that only reg and reg+reg addressing is allowed. This heuristic is
comment|// taken from the implementation of LSR.
return|return
operator|!
name|BaseGV
operator|&&
name|BaseOffset
operator|==
literal|0
operator|&&
operator|(
name|Scale
operator|==
literal|0
operator|||
name|Scale
operator|==
literal|1
operator|)
return|;
block|}
name|bool
name|isLSRCostLess
argument_list|(
name|TTI
operator|::
name|LSRCost
operator|&
name|C1
argument_list|,
name|TTI
operator|::
name|LSRCost
operator|&
name|C2
argument_list|)
block|{
return|return
name|std
operator|::
name|tie
argument_list|(
name|C1
operator|.
name|NumRegs
argument_list|,
name|C1
operator|.
name|AddRecCost
argument_list|,
name|C1
operator|.
name|NumIVMuls
argument_list|,
name|C1
operator|.
name|NumBaseAdds
argument_list|,
name|C1
operator|.
name|ScaleCost
argument_list|,
name|C1
operator|.
name|ImmCost
argument_list|,
name|C1
operator|.
name|SetupCost
argument_list|)
operator|<
name|std
operator|::
name|tie
argument_list|(
name|C2
operator|.
name|NumRegs
argument_list|,
name|C2
operator|.
name|AddRecCost
argument_list|,
name|C2
operator|.
name|NumIVMuls
argument_list|,
name|C2
operator|.
name|NumBaseAdds
argument_list|,
name|C2
operator|.
name|ScaleCost
argument_list|,
name|C2
operator|.
name|ImmCost
argument_list|,
name|C2
operator|.
name|SetupCost
argument_list|)
return|;
block|}
name|bool
name|isLegalMaskedStore
parameter_list|(
name|Type
modifier|*
name|DataType
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalMaskedLoad
parameter_list|(
name|Type
modifier|*
name|DataType
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalMaskedScatter
parameter_list|(
name|Type
modifier|*
name|DataType
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isLegalMaskedGather
parameter_list|(
name|Type
modifier|*
name|DataType
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|prefersVectorizedAddressing
parameter_list|()
block|{
return|return
name|true
return|;
block|}
name|int
name|getScalingFactorCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|GlobalValue
modifier|*
name|BaseGV
parameter_list|,
name|int64_t
name|BaseOffset
parameter_list|,
name|bool
name|HasBaseReg
parameter_list|,
name|int64_t
name|Scale
parameter_list|,
name|unsigned
name|AddrSpace
parameter_list|)
block|{
comment|// Guess that all legal addressing mode are free.
if|if
condition|(
name|isLegalAddressingMode
argument_list|(
name|Ty
argument_list|,
name|BaseGV
argument_list|,
name|BaseOffset
argument_list|,
name|HasBaseReg
argument_list|,
name|Scale
argument_list|,
name|AddrSpace
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
name|bool
name|isFoldableMemAccessOffset
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|int64_t
name|Offset
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|bool
name|isTruncateFree
parameter_list|(
name|Type
modifier|*
name|Ty1
parameter_list|,
name|Type
modifier|*
name|Ty2
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|isProfitableToHoist
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|bool
name|isTypeLegal
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getJumpBufAlignment
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getJumpBufSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|bool
name|shouldBuildLookupTables
parameter_list|()
block|{
return|return
name|true
return|;
block|}
name|bool
name|shouldBuildLookupTablesForConstant
parameter_list|(
name|Constant
modifier|*
name|C
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|getScalarizationOverhead
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|,
name|bool
name|Insert
parameter_list|,
name|bool
name|Extract
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getOperandsScalarizationOverhead
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|unsigned
name|VF
argument_list|)
block|{
return|return
literal|0
return|;
block|}
name|bool
name|supportsEfficientVectorElementLoadStore
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|enableAggressiveInterleaving
parameter_list|(
name|bool
name|LoopHasReductions
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|expandMemCmp
parameter_list|(
name|Instruction
modifier|*
name|I
parameter_list|,
name|unsigned
modifier|&
name|MaxLoadSize
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|bool
name|enableInterleavedAccessVectorization
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|isFPVectorizationPotentiallyUnsafe
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|allowsMisalignedMemoryAccesses
parameter_list|(
name|LLVMContext
modifier|&
name|Context
parameter_list|,
name|unsigned
name|BitWidth
parameter_list|,
name|unsigned
name|AddressSpace
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|bool
modifier|*
name|Fast
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|TTI
operator|::
name|PopcntSupportKind
name|getPopcntSupport
argument_list|(
argument|unsigned IntTyWidthInBit
argument_list|)
block|{
return|return
name|TTI
operator|::
name|PSK_Software
return|;
block|}
name|bool
name|haveFastSqrt
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getFPOpCost
parameter_list|(
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|TargetTransformInfo
operator|::
name|TCC_Basic
return|;
block|}
name|int
name|getIntImmCodeSizeCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getIntImmCost
parameter_list|(
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
name|unsigned
name|getIntImmCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|APInt
modifier|&
name|Imm
parameter_list|,
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|TTI
operator|::
name|TCC_Free
return|;
block|}
name|unsigned
name|getIntImmCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|unsigned
name|Idx
argument_list|,
specifier|const
name|APInt
operator|&
name|Imm
argument_list|,
name|Type
operator|*
name|Ty
argument_list|)
block|{
return|return
name|TTI
operator|::
name|TCC_Free
return|;
block|}
name|unsigned
name|getNumberOfRegisters
parameter_list|(
name|bool
name|Vector
parameter_list|)
block|{
return|return
literal|8
return|;
block|}
name|unsigned
name|getRegisterBitWidth
argument_list|(
name|bool
name|Vector
argument_list|)
decl|const
block|{
return|return
literal|32
return|;
block|}
name|unsigned
name|getMinVectorRegisterBitWidth
parameter_list|()
block|{
return|return
literal|128
return|;
block|}
name|bool
name|shouldConsiderAddressTypePromotion
parameter_list|(
specifier|const
name|Instruction
modifier|&
name|I
parameter_list|,
name|bool
modifier|&
name|AllowPromotionWithoutCommonHeader
parameter_list|)
block|{
name|AllowPromotionWithoutCommonHeader
operator|=
name|false
expr_stmt|;
return|return
name|false
return|;
block|}
name|unsigned
name|getCacheLineSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getPrefetchDistance
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getMinPrefetchStride
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getMaxPrefetchIterationsAhead
parameter_list|()
block|{
return|return
name|UINT_MAX
return|;
block|}
name|unsigned
name|getMaxInterleaveFactor
parameter_list|(
name|unsigned
name|VF
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getArithmeticInstrCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd1Info
argument_list|,
name|TTI
operator|::
name|OperandValueKind
name|Opd2Info
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd1PropInfo
argument_list|,
name|TTI
operator|::
name|OperandValueProperties
name|Opd2PropInfo
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Args
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getShuffleCost
argument_list|(
name|TTI
operator|::
name|ShuffleKind
name|Kind
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|int
name|Index
argument_list|,
name|Type
operator|*
name|SubTp
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getCastInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Dst
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getExtractWithExtendCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Dst
parameter_list|,
name|VectorType
modifier|*
name|VecTy
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getCFInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getCmpSelInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|ValTy
parameter_list|,
name|Type
modifier|*
name|CondTy
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getVectorInstrCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Val
parameter_list|,
name|unsigned
name|Index
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getMemoryOpCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|unsigned
name|AddressSpace
parameter_list|,
specifier|const
name|Instruction
modifier|*
name|I
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getMaskedMemoryOpCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|Src
parameter_list|,
name|unsigned
name|Alignment
parameter_list|,
name|unsigned
name|AddressSpace
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getGatherScatterOpCost
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|Type
modifier|*
name|DataTy
parameter_list|,
name|Value
modifier|*
name|Ptr
parameter_list|,
name|bool
name|VariableMask
parameter_list|,
name|unsigned
name|Alignment
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getInterleavedMemoryOpCost
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|VecTy
argument_list|,
name|unsigned
name|Factor
argument_list|,
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Indices
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|unsigned
name|AddressSpace
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|,
name|FastMathFlags
name|FMF
argument_list|,
name|unsigned
name|ScalarizationCostPassed
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getIntrinsicInstrCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|ID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Value
operator|*
operator|>
name|Args
argument_list|,
name|FastMathFlags
name|FMF
argument_list|,
name|unsigned
name|VF
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getCallInstrCost
argument_list|(
name|Function
operator|*
name|F
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getNumberOfParts
parameter_list|(
name|Type
modifier|*
name|Tp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getAddressComputationCost
parameter_list|(
name|Type
modifier|*
name|Tp
parameter_list|,
name|ScalarEvolution
modifier|*
parameter_list|,
specifier|const
name|SCEV
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
name|unsigned
name|getReductionCost
parameter_list|(
name|unsigned
parameter_list|,
name|Type
modifier|*
parameter_list|,
name|bool
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
name|unsigned
name|getCostOfKeepingLiveOverCall
argument_list|(
name|ArrayRef
operator|<
name|Type
operator|*
operator|>
name|Tys
argument_list|)
block|{
return|return
literal|0
return|;
block|}
name|bool
name|getTgtMemIntrinsic
parameter_list|(
name|IntrinsicInst
modifier|*
name|Inst
parameter_list|,
name|MemIntrinsicInfo
modifier|&
name|Info
parameter_list|)
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getAtomicMemIntrinsicMaxElementSize
argument_list|()
specifier|const
block|{
comment|// Note for overrides: You must ensure for all element unordered-atomic
comment|// memory intrinsics that all power-of-2 element sizes up to, and
comment|// including, the return value of this method have a corresponding
comment|// runtime lib call. These runtime lib call definitions can be found
comment|// in RuntimeLibcalls.h
return|return
literal|0
return|;
block|}
name|Value
modifier|*
name|getOrCreateResultFromMemIntrinsic
parameter_list|(
name|IntrinsicInst
modifier|*
name|Inst
parameter_list|,
name|Type
modifier|*
name|ExpectedType
parameter_list|)
block|{
return|return
name|nullptr
return|;
block|}
name|Type
modifier|*
name|getMemcpyLoopLoweringType
argument_list|(
name|LLVMContext
operator|&
name|Context
argument_list|,
name|Value
operator|*
name|Length
argument_list|,
name|unsigned
name|SrcAlign
argument_list|,
name|unsigned
name|DestAlign
argument_list|)
decl|const
block|{
return|return
name|Type
operator|::
name|getInt8Ty
argument_list|(
name|Context
argument_list|)
return|;
block|}
name|void
name|getMemcpyLoopResidualLoweringType
argument_list|(
name|SmallVectorImpl
operator|<
name|Type
operator|*
operator|>
operator|&
name|OpsOut
argument_list|,
name|LLVMContext
operator|&
name|Context
argument_list|,
name|unsigned
name|RemainingBytes
argument_list|,
name|unsigned
name|SrcAlign
argument_list|,
name|unsigned
name|DestAlign
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|RemainingBytes
condition|;
operator|++
name|i
control|)
name|OpsOut
operator|.
name|push_back
argument_list|(
name|Type
operator|::
name|getInt8Ty
argument_list|(
name|Context
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bool
name|areInlineCompatible
argument_list|(
specifier|const
name|Function
operator|*
name|Caller
argument_list|,
specifier|const
name|Function
operator|*
name|Callee
argument_list|)
decl|const
block|{
return|return
operator|(
name|Caller
operator|->
name|getFnAttribute
argument_list|(
literal|"target-cpu"
argument_list|)
operator|==
name|Callee
operator|->
name|getFnAttribute
argument_list|(
literal|"target-cpu"
argument_list|)
operator|)
operator|&&
operator|(
name|Caller
operator|->
name|getFnAttribute
argument_list|(
literal|"target-features"
argument_list|)
operator|==
name|Callee
operator|->
name|getFnAttribute
argument_list|(
literal|"target-features"
argument_list|)
operator|)
return|;
block|}
name|unsigned
name|getLoadStoreVecRegBitWidth
argument_list|(
name|unsigned
name|AddrSpace
argument_list|)
decl|const
block|{
return|return
literal|128
return|;
block|}
name|bool
name|isLegalToVectorizeLoad
argument_list|(
name|LoadInst
operator|*
name|LI
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|bool
name|isLegalToVectorizeStore
argument_list|(
name|StoreInst
operator|*
name|SI
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|bool
name|isLegalToVectorizeLoadChain
argument_list|(
name|unsigned
name|ChainSizeInBytes
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|unsigned
name|AddrSpace
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|bool
name|isLegalToVectorizeStoreChain
argument_list|(
name|unsigned
name|ChainSizeInBytes
argument_list|,
name|unsigned
name|Alignment
argument_list|,
name|unsigned
name|AddrSpace
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|getLoadVectorFactor
argument_list|(
name|unsigned
name|VF
argument_list|,
name|unsigned
name|LoadSize
argument_list|,
name|unsigned
name|ChainSizeInBytes
argument_list|,
name|VectorType
operator|*
name|VecTy
argument_list|)
decl|const
block|{
return|return
name|VF
return|;
block|}
name|unsigned
name|getStoreVectorFactor
argument_list|(
name|unsigned
name|VF
argument_list|,
name|unsigned
name|StoreSize
argument_list|,
name|unsigned
name|ChainSizeInBytes
argument_list|,
name|VectorType
operator|*
name|VecTy
argument_list|)
decl|const
block|{
return|return
name|VF
return|;
block|}
name|bool
name|useReductionIntrinsic
argument_list|(
name|unsigned
name|Opcode
argument_list|,
name|Type
operator|*
name|Ty
argument_list|,
name|TTI
operator|::
name|ReductionFlags
name|Flags
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
name|bool
name|shouldExpandReduction
argument_list|(
specifier|const
name|IntrinsicInst
operator|*
name|II
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|protected
label|:
comment|// Obtain the minimum required size to hold the value (without the sign)
comment|// In case of a vector it returns the min required size for one element.
name|unsigned
name|minRequiredElementSize
parameter_list|(
specifier|const
name|Value
modifier|*
name|Val
parameter_list|,
name|bool
modifier|&
name|isSigned
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|ConstantDataVector
operator|>
operator|(
name|Val
operator|)
operator|||
name|isa
operator|<
name|ConstantVector
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
specifier|const
specifier|auto
modifier|*
name|VectorValue
init|=
name|cast
operator|<
name|Constant
operator|>
operator|(
name|Val
operator|)
decl_stmt|;
comment|// In case of a vector need to pick the max between the min
comment|// required size for each element
name|auto
operator|*
name|VT
operator|=
name|cast
operator|<
name|VectorType
operator|>
operator|(
name|Val
operator|->
name|getType
argument_list|()
operator|)
expr_stmt|;
comment|// Assume unsigned elements
name|isSigned
operator|=
name|false
expr_stmt|;
comment|// The max required size is the total vector width divided by num
comment|// of elements in the vector
name|unsigned
name|MaxRequiredSize
init|=
name|VT
operator|->
name|getBitWidth
argument_list|()
operator|/
name|VT
operator|->
name|getNumElements
argument_list|()
decl_stmt|;
name|unsigned
name|MinRequiredSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|VT
operator|->
name|getNumElements
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|auto
operator|*
name|IntElement
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|VectorValue
operator|->
name|getAggregateElement
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
name|bool
name|signedElement
init|=
name|IntElement
operator|->
name|getValue
argument_list|()
operator|.
name|isNegative
argument_list|()
decl_stmt|;
comment|// Get the element min required size.
name|unsigned
name|ElementMinRequiredSize
init|=
name|IntElement
operator|->
name|getValue
argument_list|()
operator|.
name|getMinSignedBits
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// In case one element is signed then all the vector is signed.
name|isSigned
operator||=
name|signedElement
expr_stmt|;
comment|// Save the max required bit size between all the elements.
name|MinRequiredSize
operator|=
name|std
operator|::
name|max
argument_list|(
name|MinRequiredSize
argument_list|,
name|ElementMinRequiredSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not an int constant element
return|return
name|MaxRequiredSize
return|;
block|}
block|}
return|return
name|MinRequiredSize
return|;
block|}
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
name|isSigned
operator|=
name|CI
operator|->
name|getValue
argument_list|()
operator|.
name|isNegative
argument_list|()
expr_stmt|;
return|return
name|CI
operator|->
name|getValue
argument_list|()
operator|.
name|getMinSignedBits
argument_list|()
operator|-
literal|1
return|;
block|}
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|Cast
init|=
name|dyn_cast
operator|<
name|SExtInst
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
name|isSigned
operator|=
name|true
expr_stmt|;
return|return
name|Cast
operator|->
name|getSrcTy
argument_list|()
operator|->
name|getScalarSizeInBits
argument_list|()
operator|-
literal|1
return|;
block|}
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|Cast
init|=
name|dyn_cast
operator|<
name|ZExtInst
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
name|isSigned
operator|=
name|false
expr_stmt|;
return|return
name|Cast
operator|->
name|getSrcTy
argument_list|()
operator|->
name|getScalarSizeInBits
argument_list|()
return|;
block|}
name|isSigned
operator|=
name|false
expr_stmt|;
return|return
name|Val
operator|->
name|getType
argument_list|()
operator|->
name|getScalarSizeInBits
argument_list|()
return|;
block|}
name|bool
name|isStridedAccess
parameter_list|(
specifier|const
name|SCEV
modifier|*
name|Ptr
parameter_list|)
block|{
return|return
name|Ptr
operator|&&
name|isa
operator|<
name|SCEVAddRecExpr
operator|>
operator|(
name|Ptr
operator|)
return|;
block|}
specifier|const
name|SCEVConstant
modifier|*
name|getConstantStrideStep
parameter_list|(
name|ScalarEvolution
modifier|*
name|SE
parameter_list|,
specifier|const
name|SCEV
modifier|*
name|Ptr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isStridedAccess
argument_list|(
name|Ptr
argument_list|)
condition|)
return|return
name|nullptr
return|;
specifier|const
name|SCEVAddRecExpr
modifier|*
name|AddRec
init|=
name|cast
operator|<
name|SCEVAddRecExpr
operator|>
operator|(
name|Ptr
operator|)
decl_stmt|;
return|return
name|dyn_cast
operator|<
name|SCEVConstant
operator|>
operator|(
name|AddRec
operator|->
name|getStepRecurrence
argument_list|(
operator|*
name|SE
argument_list|)
operator|)
return|;
block|}
name|bool
name|isConstantStridedAccessLessThan
parameter_list|(
name|ScalarEvolution
modifier|*
name|SE
parameter_list|,
specifier|const
name|SCEV
modifier|*
name|Ptr
parameter_list|,
name|int64_t
name|MergeDistance
parameter_list|)
block|{
specifier|const
name|SCEVConstant
modifier|*
name|Step
init|=
name|getConstantStrideStep
argument_list|(
name|SE
argument_list|,
name|Ptr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Step
condition|)
return|return
name|false
return|;
name|APInt
name|StrideVal
init|=
name|Step
operator|->
name|getAPInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|StrideVal
operator|.
name|getBitWidth
argument_list|()
operator|>
literal|64
condition|)
return|return
name|false
return|;
comment|// FIXME: need to take absolute value for negtive stride case
return|return
name|StrideVal
operator|.
name|getSExtValue
argument_list|()
operator|<
name|MergeDistance
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief CRTP base class for use as a mix-in that aids implementing
comment|/// a TargetTransformInfo-compatible class.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|TargetTransformInfoImplCRTPBase
operator|:
name|public
name|TargetTransformInfoImplBase
block|{
name|private
operator|:
typedef|typedef
name|TargetTransformInfoImplBase
name|BaseT
typedef|;
name|protected
operator|:
name|explicit
name|TargetTransformInfoImplCRTPBase
argument_list|(
specifier|const
name|DataLayout
operator|&
name|DL
argument_list|)
operator|:
name|BaseT
argument_list|(
argument|DL
argument_list|)
block|{}
name|public
operator|:
name|using
name|BaseT
operator|::
name|getCallCost
expr_stmt|;
name|unsigned
name|getCallCost
parameter_list|(
specifier|const
name|Function
modifier|*
name|F
parameter_list|,
name|int
name|NumArgs
parameter_list|)
block|{
name|assert
argument_list|(
name|F
operator|&&
literal|"A concrete function must be provided to this routine."
argument_list|)
expr_stmt|;
if|if
condition|(
name|NumArgs
operator|<
literal|0
condition|)
comment|// Set the argument number to the number of explicit arguments in the
comment|// function.
name|NumArgs
operator|=
name|F
operator|->
name|arg_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|Intrinsic
operator|::
name|ID
name|IID
operator|=
name|F
operator|->
name|getIntrinsicID
argument_list|()
condition|)
block|{
name|FunctionType
modifier|*
name|FTy
init|=
name|F
operator|->
name|getFunctionType
argument_list|()
decl_stmt|;
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|8
operator|>
name|ParamTys
argument_list|(
name|FTy
operator|->
name|param_begin
argument_list|()
argument_list|,
name|FTy
operator|->
name|param_end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|FTy
operator|->
name|getReturnType
argument_list|()
argument_list|,
name|ParamTys
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|isLoweredToCall
argument_list|(
name|F
argument_list|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
comment|// Give a basic cost if it will be lowered
comment|// directly.
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCallCost
argument_list|(
name|F
operator|->
name|getFunctionType
argument_list|()
argument_list|,
name|NumArgs
argument_list|)
return|;
block|}
name|unsigned
name|getCallCost
argument_list|(
specifier|const
name|Function
operator|*
name|F
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Arguments
argument_list|)
block|{
comment|// Simply delegate to generic handling of the call.
comment|// FIXME: We should use instsimplify or something else to catch calls which
comment|// will constant fold with these arguments.
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCallCost
argument_list|(
name|F
argument_list|,
name|Arguments
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
name|using
name|BaseT
operator|::
name|getGEPCost
expr_stmt|;
name|int
name|getGEPCost
argument_list|(
name|Type
operator|*
name|PointeeType
argument_list|,
specifier|const
name|Value
operator|*
name|Ptr
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Operands
argument_list|)
block|{
specifier|const
name|GlobalValue
modifier|*
name|BaseGV
init|=
name|nullptr
decl_stmt|;
if|if
condition|(
name|Ptr
operator|!=
name|nullptr
condition|)
block|{
comment|// TODO: will remove this when pointers have an opaque type.
name|assert
argument_list|(
name|Ptr
operator|->
name|getType
argument_list|()
operator|->
name|getScalarType
argument_list|()
operator|->
name|getPointerElementType
argument_list|()
operator|==
name|PointeeType
operator|&&
literal|"explicit pointee type doesn't match operand's pointee type"
argument_list|)
expr_stmt|;
name|BaseGV
operator|=
name|dyn_cast
operator|<
name|GlobalValue
operator|>
operator|(
name|Ptr
operator|->
name|stripPointerCasts
argument_list|()
operator|)
expr_stmt|;
block|}
name|bool
name|HasBaseReg
init|=
operator|(
name|BaseGV
operator|==
name|nullptr
operator|)
decl_stmt|;
name|int64_t
name|BaseOffset
init|=
literal|0
decl_stmt|;
name|int64_t
name|Scale
init|=
literal|0
decl_stmt|;
name|auto
name|GTI
init|=
name|gep_type_begin
argument_list|(
name|PointeeType
argument_list|,
name|Operands
argument_list|)
decl_stmt|;
name|Type
modifier|*
name|TargetType
decl_stmt|;
for|for
control|(
name|auto
name|I
init|=
name|Operands
operator|.
name|begin
argument_list|()
init|;
name|I
operator|!=
name|Operands
operator|.
name|end
argument_list|()
condition|;
operator|++
name|I
operator|,
operator|++
name|GTI
control|)
block|{
name|TargetType
operator|=
name|GTI
operator|.
name|getIndexedType
argument_list|()
expr_stmt|;
comment|// We assume that the cost of Scalar GEP with constant index and the
comment|// cost of Vector GEP with splat constant index are the same.
specifier|const
name|ConstantInt
modifier|*
name|ConstIdx
init|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
operator|*
name|I
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|ConstIdx
condition|)
if|if
condition|(
name|auto
name|Splat
init|=
name|getSplatValue
argument_list|(
operator|*
name|I
argument_list|)
condition|)
name|ConstIdx
operator|=
name|dyn_cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Splat
operator|)
expr_stmt|;
if|if
condition|(
name|StructType
modifier|*
name|STy
init|=
name|GTI
operator|.
name|getStructTypeOrNull
argument_list|()
condition|)
block|{
comment|// For structures the index is always splat or scalar constant
name|assert
argument_list|(
name|ConstIdx
operator|&&
literal|"Unexpected GEP index"
argument_list|)
expr_stmt|;
name|uint64_t
name|Field
init|=
name|ConstIdx
operator|->
name|getZExtValue
argument_list|()
decl_stmt|;
name|BaseOffset
operator|+=
name|DL
operator|.
name|getStructLayout
argument_list|(
name|STy
argument_list|)
operator|->
name|getElementOffset
argument_list|(
name|Field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int64_t
name|ElementSize
init|=
name|DL
operator|.
name|getTypeAllocSize
argument_list|(
name|GTI
operator|.
name|getIndexedType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ConstIdx
condition|)
name|BaseOffset
operator|+=
name|ConstIdx
operator|->
name|getSExtValue
argument_list|()
operator|*
name|ElementSize
expr_stmt|;
else|else
block|{
comment|// Needs scale register.
if|if
condition|(
name|Scale
operator|!=
literal|0
condition|)
comment|// No addressing mode takes two scale registers.
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
name|Scale
operator|=
name|ElementSize
expr_stmt|;
block|}
block|}
block|}
comment|// Assumes the address space is 0 when Ptr is nullptr.
name|unsigned
name|AS
init|=
operator|(
name|Ptr
operator|==
name|nullptr
condition|?
literal|0
else|:
name|Ptr
operator|->
name|getType
argument_list|()
operator|->
name|getPointerAddressSpace
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|isLegalAddressingMode
argument_list|(
name|TargetType
argument_list|,
name|const_cast
operator|<
name|GlobalValue
operator|*
operator|>
operator|(
name|BaseGV
operator|)
argument_list|,
name|BaseOffset
argument_list|,
name|HasBaseReg
argument_list|,
name|Scale
argument_list|,
name|AS
argument_list|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
return|return
name|TTI
operator|::
name|TCC_Basic
return|;
block|}
name|using
name|BaseT
operator|::
name|getIntrinsicCost
expr_stmt|;
name|unsigned
name|getIntrinsicCost
argument_list|(
name|Intrinsic
operator|::
name|ID
name|IID
argument_list|,
name|Type
operator|*
name|RetTy
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Arguments
argument_list|)
block|{
comment|// Delegate to the generic intrinsic handling code. This mostly provides an
comment|// opportunity for targets to (for example) special case the cost of
comment|// certain intrinsics based on constants used as arguments.
name|SmallVector
operator|<
name|Type
operator|*
operator|,
literal|8
operator|>
name|ParamTys
expr_stmt|;
name|ParamTys
operator|.
name|reserve
argument_list|(
name|Arguments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|Idx
init|=
literal|0
init|,
name|Size
init|=
name|Arguments
operator|.
name|size
argument_list|()
init|;
name|Idx
operator|!=
name|Size
condition|;
operator|++
name|Idx
control|)
name|ParamTys
operator|.
name|push_back
argument_list|(
name|Arguments
index|[
name|Idx
index|]
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getIntrinsicCost
argument_list|(
name|IID
argument_list|,
name|RetTy
argument_list|,
name|ParamTys
argument_list|)
return|;
block|}
name|unsigned
name|getUserCost
argument_list|(
specifier|const
name|User
operator|*
name|U
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Value
operator|*
operator|>
name|Operands
argument_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|PHINode
operator|>
operator|(
name|U
operator|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
comment|// Model all PHI nodes as free.
if|if
condition|(
specifier|const
name|GEPOperator
modifier|*
name|GEP
init|=
name|dyn_cast
operator|<
name|GEPOperator
operator|>
operator|(
name|U
operator|)
condition|)
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getGEPCost
argument_list|(
name|GEP
operator|->
name|getSourceElementType
argument_list|()
argument_list|,
name|GEP
operator|->
name|getPointerOperand
argument_list|()
argument_list|,
name|Operands
operator|.
name|drop_front
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|auto
name|CS
init|=
name|ImmutableCallSite
argument_list|(
name|U
argument_list|)
condition|)
block|{
specifier|const
name|Function
modifier|*
name|F
init|=
name|CS
operator|.
name|getCalledFunction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|F
condition|)
block|{
comment|// Just use the called value type.
name|Type
modifier|*
name|FTy
init|=
name|CS
operator|.
name|getCalledValue
argument_list|()
operator|->
name|getType
argument_list|()
operator|->
name|getPointerElementType
argument_list|()
decl_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCallCost
argument_list|(
name|cast
operator|<
name|FunctionType
operator|>
operator|(
name|FTy
operator|)
argument_list|,
name|CS
operator|.
name|arg_size
argument_list|()
argument_list|)
return|;
block|}
name|SmallVector
operator|<
specifier|const
name|Value
operator|*
operator|,
literal|8
operator|>
name|Arguments
argument_list|(
name|CS
operator|.
name|arg_begin
argument_list|()
argument_list|,
name|CS
operator|.
name|arg_end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCallCost
argument_list|(
name|F
argument_list|,
name|Arguments
argument_list|)
return|;
block|}
if|if
condition|(
specifier|const
name|CastInst
modifier|*
name|CI
init|=
name|dyn_cast
operator|<
name|CastInst
operator|>
operator|(
name|U
operator|)
condition|)
block|{
comment|// Result of a cmp instruction is often extended (to be used by other
comment|// cmp instructions, logical or return instructions). These are usually
comment|// nop on most sane targets.
if|if
condition|(
name|isa
operator|<
name|CmpInst
operator|>
operator|(
name|CI
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
return|return
name|TTI
operator|::
name|TCC_Free
return|;
if|if
condition|(
name|isa
operator|<
name|SExtInst
operator|>
operator|(
name|CI
operator|)
operator|||
name|isa
operator|<
name|ZExtInst
operator|>
operator|(
name|CI
operator|)
operator|||
name|isa
operator|<
name|FPExtInst
operator|>
operator|(
name|CI
operator|)
condition|)
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getExtCost
argument_list|(
name|CI
argument_list|,
name|Operands
operator|.
name|back
argument_list|()
argument_list|)
return|;
block|}
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getOperationCost
argument_list|(
name|Operator
operator|::
name|getOpcode
argument_list|(
name|U
argument_list|)
argument_list|,
name|U
operator|->
name|getType
argument_list|()
argument_list|,
name|U
operator|->
name|getNumOperands
argument_list|()
operator|==
literal|1
condition|?
name|U
operator|->
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|->
name|getType
argument_list|()
else|:
name|nullptr
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

