begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- TargetLibraryInfo.h - Library information ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_TARGETLIBRARYINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_TARGETLIBRARYINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// VecDesc - Describes a possible vectorization of a function.
comment|/// Function 'VectorFnName' is equivalent to 'ScalarFnName' vectorized
comment|/// by a factor 'VectorizationFactor'.
struct|struct
name|VecDesc
block|{
specifier|const
name|char
modifier|*
name|ScalarFnName
decl_stmt|;
specifier|const
name|char
modifier|*
name|VectorFnName
decl_stmt|;
name|unsigned
name|VectorizationFactor
decl_stmt|;
block|}
struct|;
name|class
name|PreservedAnalyses
decl_stmt|;
name|namespace
name|LibFunc
block|{
enum|enum
name|Func
block|{
define|#
directive|define
name|TLI_DEFINE_ENUM
include|#
directive|include
file|"llvm/Analysis/TargetLibraryInfo.def"
name|NumLibFuncs
block|}
enum|;
block|}
comment|/// \brief Implementation of the target library information.
comment|///
comment|/// This class constructs tables that hold the target library information and
comment|/// make it available. However, it is somewhat expensive to compute and only
comment|/// depends on the triple. So users typically interact with the \c
comment|/// TargetLibraryInfo wrapper below.
name|class
name|TargetLibraryInfoImpl
block|{
name|friend
name|class
name|TargetLibraryInfo
decl_stmt|;
name|unsigned
name|char
name|AvailableArray
index|[
operator|(
name|LibFunc
operator|::
name|NumLibFuncs
operator|+
literal|3
operator|)
operator|/
literal|4
index|]
decl_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
name|CustomNames
expr_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|StandardNames
index|[
name|LibFunc
operator|::
name|NumLibFuncs
index|]
decl_stmt|;
enum|enum
name|AvailabilityState
block|{
name|StandardName
init|=
literal|3
block|,
comment|// (memset to all ones)
name|CustomName
init|=
literal|1
block|,
name|Unavailable
init|=
literal|0
comment|// (memset to all zeros)
block|}
enum|;
name|void
name|setState
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|,
name|AvailabilityState
name|State
argument_list|)
block|{
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator||=
name|State
operator|<<
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
expr_stmt|;
block|}
name|AvailabilityState
name|getState
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
return|return
name|static_cast
operator|<
name|AvailabilityState
operator|>
operator|(
operator|(
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator|>>
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
return|;
block|}
comment|/// Vectorization descriptors - sorted by ScalarFnName.
name|std
operator|::
name|vector
operator|<
name|VecDesc
operator|>
name|VectorDescs
expr_stmt|;
comment|/// Scalarization descriptors - same content as VectorDescs but sorted based
comment|/// on VectorFnName rather than ScalarFnName.
name|std
operator|::
name|vector
operator|<
name|VecDesc
operator|>
name|ScalarDescs
expr_stmt|;
name|public
label|:
comment|/// \brief  List of known vector-functions libraries.
comment|///
comment|/// The vector-functions library defines, which functions are vectorizable
comment|/// and with which factor. The library can be specified by either frontend,
comment|/// or a commandline option, and then used by
comment|/// addVectorizableFunctionsFromVecLib for filling up the tables of
comment|/// vectorizable functions.
enum|enum
name|VectorLibrary
block|{
name|NoLibrary
block|,
comment|// Don't use any vector library.
name|Accelerate
comment|// Use Accelerate framework.
block|}
enum|;
name|TargetLibraryInfoImpl
argument_list|()
expr_stmt|;
name|explicit
name|TargetLibraryInfoImpl
parameter_list|(
specifier|const
name|Triple
modifier|&
name|T
parameter_list|)
function_decl|;
comment|// Provide value semantics.
name|TargetLibraryInfoImpl
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
argument_list|)
expr_stmt|;
name|TargetLibraryInfoImpl
argument_list|(
name|TargetLibraryInfoImpl
operator|&&
name|TLI
argument_list|)
expr_stmt|;
name|TargetLibraryInfoImpl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
operator|)
decl_stmt|;
name|TargetLibraryInfoImpl
modifier|&
name|operator
init|=
operator|(
name|TargetLibraryInfoImpl
operator|&&
name|TLI
operator|)
decl_stmt|;
comment|/// \brief Searches for a particular function name.
comment|///
comment|/// If it is one of the known library functions, return true and set F to the
comment|/// corresponding value.
name|bool
name|getLibFunc
argument_list|(
name|StringRef
name|funcName
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Forces a function to be marked as unavailable.
name|void
name|setUnavailable
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|Unavailable
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Forces a function to be marked as available.
name|void
name|setAvailable
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|StandardName
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Forces a function to be marked as available and provide an
comment|/// alternate name that must be used.
name|void
name|setAvailableWithName
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|,
name|StringRef
name|Name
argument_list|)
block|{
if|if
condition|(
name|StandardNames
index|[
name|F
index|]
operator|!=
name|Name
condition|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|CustomName
argument_list|)
expr_stmt|;
name|CustomNames
index|[
name|F
index|]
operator|=
name|Name
expr_stmt|;
name|assert
argument_list|(
name|CustomNames
operator|.
name|find
argument_list|(
name|F
argument_list|)
operator|!=
name|CustomNames
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|StandardName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// \brief Disables all builtins.
comment|///
comment|/// This can be used for options like -fno-builtin.
name|void
name|disableAllFunctions
parameter_list|()
function_decl|;
comment|/// addVectorizableFunctions - Add a set of scalar -> vector mappings,
comment|/// queryable via getVectorizedFunction and getScalarizedFunction.
name|void
name|addVectorizableFunctions
argument_list|(
name|ArrayRef
operator|<
name|VecDesc
operator|>
name|Fns
argument_list|)
decl_stmt|;
comment|/// Calls addVectorizableFunctions with a known preset of functions for the
comment|/// given vector library.
name|void
name|addVectorizableFunctionsFromVecLib
parameter_list|(
name|enum
name|VectorLibrary
name|VecLib
parameter_list|)
function_decl|;
comment|/// isFunctionVectorizable - Return true if the function F has a
comment|/// vector equivalent with vectorization factor VF.
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
operator|!
name|getVectorizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// isFunctionVectorizable - Return true if the function F has a
comment|/// vector equivalent with any vectorization factor.
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// getVectorizedFunction - Return the name of the equivalent of
comment|/// F, vectorized with factor VF. If no such mapping exists,
comment|/// return the empty string.
name|StringRef
name|getVectorizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
decl_stmt|;
comment|/// isFunctionScalarizable - Return true if the function F has a
comment|/// scalar equivalent, and set VF to be the vectorization factor.
name|bool
name|isFunctionScalarizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
operator|&
name|VF
argument_list|)
decl|const
block|{
return|return
operator|!
name|getScalarizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getScalarizedFunction - Return the name of the equivalent of
comment|/// F, scalarized. If no such mapping exists, return the empty string.
comment|///
comment|/// Set VF to the vectorization factor.
name|StringRef
name|getScalarizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
operator|&
name|VF
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief Provides information about what library functions are available for
comment|/// the current target.
comment|///
comment|/// This both allows optimizations to handle them specially and frontends to
comment|/// disable such optimizations through -fno-builtin etc.
name|class
name|TargetLibraryInfo
block|{
name|friend
name|class
name|TargetLibraryAnalysis
decl_stmt|;
name|friend
name|class
name|TargetLibraryInfoWrapperPass
decl_stmt|;
specifier|const
name|TargetLibraryInfoImpl
modifier|*
name|Impl
decl_stmt|;
name|public
label|:
name|explicit
name|TargetLibraryInfo
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|Impl
argument_list|)
operator|:
name|Impl
argument_list|(
argument|&Impl
argument_list|)
block|{}
comment|// Provide value semantics.
name|TargetLibraryInfo
argument_list|(
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
argument_list|)
operator|:
name|Impl
argument_list|(
argument|TLI.Impl
argument_list|)
block|{}
name|TargetLibraryInfo
argument_list|(
name|TargetLibraryInfo
operator|&&
name|TLI
argument_list|)
operator|:
name|Impl
argument_list|(
argument|TLI.Impl
argument_list|)
block|{}
name|TargetLibraryInfo
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
operator|)
block|{
name|Impl
operator|=
name|TLI
operator|.
name|Impl
block|;
return|return
operator|*
name|this
return|;
block|}
name|TargetLibraryInfo
modifier|&
name|operator
init|=
operator|(
name|TargetLibraryInfo
operator|&&
name|TLI
operator|)
block|{
name|Impl
operator|=
name|TLI
operator|.
name|Impl
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// \brief Searches for a particular function name.
comment|///
comment|/// If it is one of the known library functions, return true and set F to the
comment|/// corresponding value.
name|bool
name|getLibFunc
argument_list|(
name|StringRef
name|funcName
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getLibFunc
argument_list|(
name|funcName
argument_list|,
name|F
argument_list|)
return|;
block|}
comment|/// \brief Tests whether a library function is available.
name|bool
name|has
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
operator|!=
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
return|;
block|}
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|isFunctionVectorizable
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
return|;
block|}
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|isFunctionVectorizable
argument_list|(
name|F
argument_list|)
return|;
block|}
name|StringRef
name|getVectorizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getVectorizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
return|;
block|}
comment|/// \brief Tests if the function is both available and a candidate for
comment|/// optimized code generation.
name|bool
name|hasOptimizedCodeGen
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
if|if
condition|(
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
operator|==
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|F
condition|)
block|{
default|default:
break|break;
case|case
name|LibFunc
operator|::
name|copysign
case|:
case|case
name|LibFunc
operator|::
name|copysignf
case|:
case|case
name|LibFunc
operator|::
name|copysignl
case|:
case|case
name|LibFunc
operator|::
name|fabs
case|:
case|case
name|LibFunc
operator|::
name|fabsf
case|:
case|case
name|LibFunc
operator|::
name|fabsl
case|:
case|case
name|LibFunc
operator|::
name|sin
case|:
case|case
name|LibFunc
operator|::
name|sinf
case|:
case|case
name|LibFunc
operator|::
name|sinl
case|:
case|case
name|LibFunc
operator|::
name|cos
case|:
case|case
name|LibFunc
operator|::
name|cosf
case|:
case|case
name|LibFunc
operator|::
name|cosl
case|:
case|case
name|LibFunc
operator|::
name|sqrt
case|:
case|case
name|LibFunc
operator|::
name|sqrtf
case|:
case|case
name|LibFunc
operator|::
name|sqrtl
case|:
case|case
name|LibFunc
operator|::
name|sqrt_finite
case|:
case|case
name|LibFunc
operator|::
name|sqrtf_finite
case|:
case|case
name|LibFunc
operator|::
name|sqrtl_finite
case|:
case|case
name|LibFunc
operator|::
name|fmax
case|:
case|case
name|LibFunc
operator|::
name|fmaxf
case|:
case|case
name|LibFunc
operator|::
name|fmaxl
case|:
case|case
name|LibFunc
operator|::
name|fmin
case|:
case|case
name|LibFunc
operator|::
name|fminf
case|:
case|case
name|LibFunc
operator|::
name|fminl
case|:
case|case
name|LibFunc
operator|::
name|floor
case|:
case|case
name|LibFunc
operator|::
name|floorf
case|:
case|case
name|LibFunc
operator|::
name|floorl
case|:
case|case
name|LibFunc
operator|::
name|nearbyint
case|:
case|case
name|LibFunc
operator|::
name|nearbyintf
case|:
case|case
name|LibFunc
operator|::
name|nearbyintl
case|:
case|case
name|LibFunc
operator|::
name|ceil
case|:
case|case
name|LibFunc
operator|::
name|ceilf
case|:
case|case
name|LibFunc
operator|::
name|ceill
case|:
case|case
name|LibFunc
operator|::
name|rint
case|:
case|case
name|LibFunc
operator|::
name|rintf
case|:
case|case
name|LibFunc
operator|::
name|rintl
case|:
case|case
name|LibFunc
operator|::
name|round
case|:
case|case
name|LibFunc
operator|::
name|roundf
case|:
case|case
name|LibFunc
operator|::
name|roundl
case|:
case|case
name|LibFunc
operator|::
name|trunc
case|:
case|case
name|LibFunc
operator|::
name|truncf
case|:
case|case
name|LibFunc
operator|::
name|truncl
case|:
case|case
name|LibFunc
operator|::
name|log2
case|:
case|case
name|LibFunc
operator|::
name|log2f
case|:
case|case
name|LibFunc
operator|::
name|log2l
case|:
case|case
name|LibFunc
operator|::
name|exp2
case|:
case|case
name|LibFunc
operator|::
name|exp2f
case|:
case|case
name|LibFunc
operator|::
name|exp2l
case|:
case|case
name|LibFunc
operator|::
name|memcmp
case|:
case|case
name|LibFunc
operator|::
name|strcmp
case|:
case|case
name|LibFunc
operator|::
name|strcpy
case|:
case|case
name|LibFunc
operator|::
name|stpcpy
case|:
case|case
name|LibFunc
operator|::
name|strlen
case|:
case|case
name|LibFunc
operator|::
name|strnlen
case|:
case|case
name|LibFunc
operator|::
name|memchr
case|:
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|StringRef
name|getName
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
name|auto
name|State
init|=
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
decl_stmt|;
if|if
condition|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
condition|)
return|return
name|StringRef
argument_list|()
return|;
if|if
condition|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|StandardName
condition|)
return|return
name|Impl
operator|->
name|StandardNames
index|[
name|F
index|]
return|;
name|assert
argument_list|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|CustomName
argument_list|)
expr_stmt|;
return|return
name|Impl
operator|->
name|CustomNames
operator|.
name|find
argument_list|(
name|F
argument_list|)
operator|->
name|second
return|;
block|}
comment|/// \brief Handle invalidation from the pass manager.
comment|///
comment|/// If we try to invalidate this info, just return false. It cannot become
comment|/// invalid even if the module changes.
name|bool
name|invalidate
parameter_list|(
name|Module
modifier|&
parameter_list|,
specifier|const
name|PreservedAnalyses
modifier|&
parameter_list|)
block|{
return|return
name|false
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief Analysis pass providing the \c TargetLibraryInfo.
comment|///
comment|/// Note that this pass's result cannot be invalidated, it is immutable for the
comment|/// life of the module.
name|class
name|TargetLibraryAnalysis
block|{
name|public
label|:
typedef|typedef
name|TargetLibraryInfo
name|Result
typedef|;
comment|/// \brief Opaque, unique identifier for this analysis pass.
specifier|static
name|void
modifier|*
name|ID
parameter_list|()
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|PassID
return|;
block|}
comment|/// \brief Default construct the library analysis.
comment|///
comment|/// This will use the module's triple to construct the library info for that
comment|/// module.
name|TargetLibraryAnalysis
argument_list|()
block|{}
comment|/// \brief Construct a library analysis with preset info.
comment|///
comment|/// This will directly copy the preset info into the result without
comment|/// consulting the module's triple.
name|TargetLibraryAnalysis
argument_list|(
argument|TargetLibraryInfoImpl PresetInfoImpl
argument_list|)
block|:
name|PresetInfoImpl
argument_list|(
argument|std::move(PresetInfoImpl)
argument_list|)
block|{}
comment|// Move semantics. We spell out the constructors for MSVC.
name|TargetLibraryAnalysis
argument_list|(
name|TargetLibraryAnalysis
operator|&&
name|Arg
argument_list|)
operator|:
name|PresetInfoImpl
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Arg
operator|.
name|PresetInfoImpl
argument_list|)
argument_list|)
operator|,
name|Impls
argument_list|(
argument|std::move(Arg.Impls)
argument_list|)
block|{}
name|TargetLibraryAnalysis
operator|&
name|operator
operator|=
operator|(
name|TargetLibraryAnalysis
operator|&&
name|RHS
operator|)
block|{
name|PresetInfoImpl
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|PresetInfoImpl
argument_list|)
block|;
name|Impls
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|Impls
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|TargetLibraryInfo
name|run
parameter_list|(
name|Module
modifier|&
name|M
parameter_list|)
function_decl|;
name|TargetLibraryInfo
name|run
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|)
function_decl|;
comment|/// \brief Provide access to a name for this pass for debugging purposes.
specifier|static
name|StringRef
name|name
parameter_list|()
block|{
return|return
literal|"TargetLibraryAnalysis"
return|;
block|}
name|private
label|:
specifier|static
name|char
name|PassID
decl_stmt|;
name|Optional
operator|<
name|TargetLibraryInfoImpl
operator|>
name|PresetInfoImpl
expr_stmt|;
name|StringMap
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|TargetLibraryInfoImpl
operator|>>
name|Impls
expr_stmt|;
name|TargetLibraryInfoImpl
modifier|&
name|lookupInfoImpl
parameter_list|(
name|Triple
name|T
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|class
name|TargetLibraryInfoWrapperPass
range|:
name|public
name|ImmutablePass
block|{
name|TargetLibraryInfoImpl
name|TLIImpl
block|;
name|TargetLibraryInfo
name|TLI
block|;
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|TargetLibraryInfoWrapperPass
argument_list|()
block|;
name|explicit
name|TargetLibraryInfoWrapperPass
argument_list|(
specifier|const
name|Triple
operator|&
name|T
argument_list|)
block|;
name|explicit
name|TargetLibraryInfoWrapperPass
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
argument_list|)
block|;
name|TargetLibraryInfo
operator|&
name|getTLI
argument_list|()
block|{
return|return
name|TLI
return|;
block|}
specifier|const
name|TargetLibraryInfo
operator|&
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

