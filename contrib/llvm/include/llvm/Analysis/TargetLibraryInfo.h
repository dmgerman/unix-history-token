begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- TargetLibraryInfo.h - Library information ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_TARGETLIBRARYINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_TARGETLIBRARYINFO_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/PassManager.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|ArrayRef
expr_stmt|;
comment|/// Describes a possible vectorization of a function.
comment|/// Function 'VectorFnName' is equivalent to 'ScalarFnName' vectorized
comment|/// by a factor 'VectorizationFactor'.
struct|struct
name|VecDesc
block|{
name|StringRef
name|ScalarFnName
decl_stmt|;
name|StringRef
name|VectorFnName
decl_stmt|;
name|unsigned
name|VectorizationFactor
decl_stmt|;
block|}
struct|;
name|namespace
name|LibFunc
block|{
enum|enum
name|Func
block|{
define|#
directive|define
name|TLI_DEFINE_ENUM
include|#
directive|include
file|"llvm/Analysis/TargetLibraryInfo.def"
name|NumLibFuncs
block|}
enum|;
block|}
comment|/// Implementation of the target library information.
comment|///
comment|/// This class constructs tables that hold the target library information and
comment|/// make it available. However, it is somewhat expensive to compute and only
comment|/// depends on the triple. So users typically interact with the \c
comment|/// TargetLibraryInfo wrapper below.
name|class
name|TargetLibraryInfoImpl
block|{
name|friend
name|class
name|TargetLibraryInfo
decl_stmt|;
name|unsigned
name|char
name|AvailableArray
index|[
operator|(
name|LibFunc
operator|::
name|NumLibFuncs
operator|+
literal|3
operator|)
operator|/
literal|4
index|]
decl_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|std
operator|::
name|string
operator|>
name|CustomNames
expr_stmt|;
specifier|static
name|StringRef
specifier|const
name|StandardNames
index|[
name|LibFunc
operator|::
name|NumLibFuncs
index|]
decl_stmt|;
name|bool
name|ShouldExtI32Param
decl_stmt|,
name|ShouldExtI32Return
decl_stmt|,
name|ShouldSignExtI32Param
decl_stmt|;
enum|enum
name|AvailabilityState
block|{
name|StandardName
init|=
literal|3
block|,
comment|// (memset to all ones)
name|CustomName
init|=
literal|1
block|,
name|Unavailable
init|=
literal|0
comment|// (memset to all zeros)
block|}
enum|;
name|void
name|setState
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|,
name|AvailabilityState
name|State
argument_list|)
block|{
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator||=
name|State
operator|<<
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
expr_stmt|;
block|}
name|AvailabilityState
name|getState
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
return|return
name|static_cast
operator|<
name|AvailabilityState
operator|>
operator|(
operator|(
name|AvailableArray
index|[
name|F
operator|/
literal|4
index|]
operator|>>
literal|2
operator|*
operator|(
name|F
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
return|;
block|}
comment|/// Vectorization descriptors - sorted by ScalarFnName.
name|std
operator|::
name|vector
operator|<
name|VecDesc
operator|>
name|VectorDescs
expr_stmt|;
comment|/// Scalarization descriptors - same content as VectorDescs but sorted based
comment|/// on VectorFnName rather than ScalarFnName.
name|std
operator|::
name|vector
operator|<
name|VecDesc
operator|>
name|ScalarDescs
expr_stmt|;
comment|/// Return true if the function type FTy is valid for the library function
comment|/// F, regardless of whether the function is available.
name|bool
name|isValidProtoForLibFunc
argument_list|(
specifier|const
name|FunctionType
operator|&
name|FTy
argument_list|,
name|LibFunc
operator|::
name|Func
name|F
argument_list|,
specifier|const
name|DataLayout
operator|*
name|DL
argument_list|)
decl|const
decl_stmt|;
name|public
label|:
comment|/// List of known vector-functions libraries.
comment|///
comment|/// The vector-functions library defines, which functions are vectorizable
comment|/// and with which factor. The library can be specified by either frontend,
comment|/// or a commandline option, and then used by
comment|/// addVectorizableFunctionsFromVecLib for filling up the tables of
comment|/// vectorizable functions.
enum|enum
name|VectorLibrary
block|{
name|NoLibrary
block|,
comment|// Don't use any vector library.
name|Accelerate
block|,
comment|// Use Accelerate framework.
name|SVML
comment|// Intel short vector math library.
block|}
enum|;
name|TargetLibraryInfoImpl
argument_list|()
expr_stmt|;
name|explicit
name|TargetLibraryInfoImpl
parameter_list|(
specifier|const
name|Triple
modifier|&
name|T
parameter_list|)
function_decl|;
comment|// Provide value semantics.
name|TargetLibraryInfoImpl
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
argument_list|)
expr_stmt|;
name|TargetLibraryInfoImpl
argument_list|(
name|TargetLibraryInfoImpl
operator|&&
name|TLI
argument_list|)
expr_stmt|;
name|TargetLibraryInfoImpl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
operator|)
decl_stmt|;
name|TargetLibraryInfoImpl
modifier|&
name|operator
init|=
operator|(
name|TargetLibraryInfoImpl
operator|&&
name|TLI
operator|)
decl_stmt|;
comment|/// Searches for a particular function name.
comment|///
comment|/// If it is one of the known library functions, return true and set F to the
comment|/// corresponding value.
name|bool
name|getLibFunc
argument_list|(
name|StringRef
name|funcName
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// Searches for a particular function name, also checking that its type is
comment|/// valid for the library function matching that name.
comment|///
comment|/// If it is one of the known library functions, return true and set F to the
comment|/// corresponding value.
name|bool
name|getLibFunc
argument_list|(
specifier|const
name|Function
operator|&
name|FDecl
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// Forces a function to be marked as unavailable.
name|void
name|setUnavailable
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|Unavailable
argument_list|)
expr_stmt|;
block|}
comment|/// Forces a function to be marked as available.
name|void
name|setAvailable
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|StandardName
argument_list|)
expr_stmt|;
block|}
comment|/// Forces a function to be marked as available and provide an alternate name
comment|/// that must be used.
name|void
name|setAvailableWithName
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|,
name|StringRef
name|Name
argument_list|)
block|{
if|if
condition|(
name|StandardNames
index|[
name|F
index|]
operator|!=
name|Name
condition|)
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|CustomName
argument_list|)
expr_stmt|;
name|CustomNames
index|[
name|F
index|]
operator|=
name|Name
expr_stmt|;
name|assert
argument_list|(
name|CustomNames
operator|.
name|find
argument_list|(
name|F
argument_list|)
operator|!=
name|CustomNames
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setState
argument_list|(
name|F
argument_list|,
name|StandardName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// Disables all builtins.
comment|///
comment|/// This can be used for options like -fno-builtin.
name|void
name|disableAllFunctions
parameter_list|()
function_decl|;
comment|/// Add a set of scalar -> vector mappings, queryable via
comment|/// getVectorizedFunction and getScalarizedFunction.
name|void
name|addVectorizableFunctions
argument_list|(
name|ArrayRef
operator|<
name|VecDesc
operator|>
name|Fns
argument_list|)
decl_stmt|;
comment|/// Calls addVectorizableFunctions with a known preset of functions for the
comment|/// given vector library.
name|void
name|addVectorizableFunctionsFromVecLib
parameter_list|(
name|enum
name|VectorLibrary
name|VecLib
parameter_list|)
function_decl|;
comment|/// Return true if the function F has a vector equivalent with vectorization
comment|/// factor VF.
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
operator|!
name|getVectorizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// Return true if the function F has a vector equivalent with any
comment|/// vectorization factor.
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|)
decl|const
decl_stmt|;
comment|/// Return the name of the equivalent of F, vectorized with factor VF. If no
comment|/// such mapping exists, return the empty string.
name|StringRef
name|getVectorizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
decl_stmt|;
comment|/// Return true if the function F has a scalar equivalent, and set VF to be
comment|/// the vectorization factor.
name|bool
name|isFunctionScalarizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
operator|&
name|VF
argument_list|)
decl|const
block|{
return|return
operator|!
name|getScalarizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// Return the name of the equivalent of F, scalarized. If no such mapping
comment|/// exists, return the empty string.
comment|///
comment|/// Set VF to the vectorization factor.
name|StringRef
name|getScalarizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
operator|&
name|VF
argument_list|)
decl|const
decl_stmt|;
comment|/// Set to true iff i32 parameters to library functions should have signext
comment|/// or zeroext attributes if they correspond to C-level int or unsigned int,
comment|/// respectively.
name|void
name|setShouldExtI32Param
parameter_list|(
name|bool
name|Val
parameter_list|)
block|{
name|ShouldExtI32Param
operator|=
name|Val
expr_stmt|;
block|}
comment|/// Set to true iff i32 results from library functions should have signext
comment|/// or zeroext attributes if they correspond to C-level int or unsigned int,
comment|/// respectively.
name|void
name|setShouldExtI32Return
parameter_list|(
name|bool
name|Val
parameter_list|)
block|{
name|ShouldExtI32Return
operator|=
name|Val
expr_stmt|;
block|}
comment|/// Set to true iff i32 parameters to library functions should have signext
comment|/// attribute if they correspond to C-level int or unsigned int.
name|void
name|setShouldSignExtI32Param
parameter_list|(
name|bool
name|Val
parameter_list|)
block|{
name|ShouldSignExtI32Param
operator|=
name|Val
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// Provides information about what library functions are available for
comment|/// the current target.
comment|///
comment|/// This both allows optimizations to handle them specially and frontends to
comment|/// disable such optimizations through -fno-builtin etc.
name|class
name|TargetLibraryInfo
block|{
name|friend
name|class
name|TargetLibraryAnalysis
decl_stmt|;
name|friend
name|class
name|TargetLibraryInfoWrapperPass
decl_stmt|;
specifier|const
name|TargetLibraryInfoImpl
modifier|*
name|Impl
decl_stmt|;
name|public
label|:
name|explicit
name|TargetLibraryInfo
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|Impl
argument_list|)
operator|:
name|Impl
argument_list|(
argument|&Impl
argument_list|)
block|{}
comment|// Provide value semantics.
name|TargetLibraryInfo
argument_list|(
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
argument_list|)
operator|:
name|Impl
argument_list|(
argument|TLI.Impl
argument_list|)
block|{}
name|TargetLibraryInfo
argument_list|(
name|TargetLibraryInfo
operator|&&
name|TLI
argument_list|)
operator|:
name|Impl
argument_list|(
argument|TLI.Impl
argument_list|)
block|{}
name|TargetLibraryInfo
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
operator|)
block|{
name|Impl
operator|=
name|TLI
operator|.
name|Impl
block|;
return|return
operator|*
name|this
return|;
block|}
name|TargetLibraryInfo
modifier|&
name|operator
init|=
operator|(
name|TargetLibraryInfo
operator|&&
name|TLI
operator|)
block|{
name|Impl
operator|=
name|TLI
operator|.
name|Impl
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Searches for a particular function name.
comment|///
comment|/// If it is one of the known library functions, return true and set F to the
comment|/// corresponding value.
name|bool
name|getLibFunc
argument_list|(
name|StringRef
name|funcName
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getLibFunc
argument_list|(
name|funcName
argument_list|,
name|F
argument_list|)
return|;
block|}
name|bool
name|getLibFunc
argument_list|(
specifier|const
name|Function
operator|&
name|FDecl
argument_list|,
name|LibFunc
operator|::
name|Func
operator|&
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getLibFunc
argument_list|(
name|FDecl
argument_list|,
name|F
argument_list|)
return|;
block|}
comment|/// Tests whether a library function is available.
name|bool
name|has
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
operator|!=
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
return|;
block|}
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|isFunctionVectorizable
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
return|;
block|}
name|bool
name|isFunctionVectorizable
argument_list|(
name|StringRef
name|F
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|isFunctionVectorizable
argument_list|(
name|F
argument_list|)
return|;
block|}
name|StringRef
name|getVectorizedFunction
argument_list|(
name|StringRef
name|F
argument_list|,
name|unsigned
name|VF
argument_list|)
decl|const
block|{
return|return
name|Impl
operator|->
name|getVectorizedFunction
argument_list|(
name|F
argument_list|,
name|VF
argument_list|)
return|;
block|}
comment|/// Tests if the function is both available and a candidate for optimized code
comment|/// generation.
name|bool
name|hasOptimizedCodeGen
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
if|if
condition|(
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
operator|==
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|F
condition|)
block|{
default|default:
break|break;
case|case
name|LibFunc
operator|::
name|copysign
case|:
case|case
name|LibFunc
operator|::
name|copysignf
case|:
case|case
name|LibFunc
operator|::
name|copysignl
case|:
case|case
name|LibFunc
operator|::
name|fabs
case|:
case|case
name|LibFunc
operator|::
name|fabsf
case|:
case|case
name|LibFunc
operator|::
name|fabsl
case|:
case|case
name|LibFunc
operator|::
name|sin
case|:
case|case
name|LibFunc
operator|::
name|sinf
case|:
case|case
name|LibFunc
operator|::
name|sinl
case|:
case|case
name|LibFunc
operator|::
name|cos
case|:
case|case
name|LibFunc
operator|::
name|cosf
case|:
case|case
name|LibFunc
operator|::
name|cosl
case|:
case|case
name|LibFunc
operator|::
name|sqrt
case|:
case|case
name|LibFunc
operator|::
name|sqrtf
case|:
case|case
name|LibFunc
operator|::
name|sqrtl
case|:
case|case
name|LibFunc
operator|::
name|sqrt_finite
case|:
case|case
name|LibFunc
operator|::
name|sqrtf_finite
case|:
case|case
name|LibFunc
operator|::
name|sqrtl_finite
case|:
case|case
name|LibFunc
operator|::
name|fmax
case|:
case|case
name|LibFunc
operator|::
name|fmaxf
case|:
case|case
name|LibFunc
operator|::
name|fmaxl
case|:
case|case
name|LibFunc
operator|::
name|fmin
case|:
case|case
name|LibFunc
operator|::
name|fminf
case|:
case|case
name|LibFunc
operator|::
name|fminl
case|:
case|case
name|LibFunc
operator|::
name|floor
case|:
case|case
name|LibFunc
operator|::
name|floorf
case|:
case|case
name|LibFunc
operator|::
name|floorl
case|:
case|case
name|LibFunc
operator|::
name|nearbyint
case|:
case|case
name|LibFunc
operator|::
name|nearbyintf
case|:
case|case
name|LibFunc
operator|::
name|nearbyintl
case|:
case|case
name|LibFunc
operator|::
name|ceil
case|:
case|case
name|LibFunc
operator|::
name|ceilf
case|:
case|case
name|LibFunc
operator|::
name|ceill
case|:
case|case
name|LibFunc
operator|::
name|rint
case|:
case|case
name|LibFunc
operator|::
name|rintf
case|:
case|case
name|LibFunc
operator|::
name|rintl
case|:
case|case
name|LibFunc
operator|::
name|round
case|:
case|case
name|LibFunc
operator|::
name|roundf
case|:
case|case
name|LibFunc
operator|::
name|roundl
case|:
case|case
name|LibFunc
operator|::
name|trunc
case|:
case|case
name|LibFunc
operator|::
name|truncf
case|:
case|case
name|LibFunc
operator|::
name|truncl
case|:
case|case
name|LibFunc
operator|::
name|log2
case|:
case|case
name|LibFunc
operator|::
name|log2f
case|:
case|case
name|LibFunc
operator|::
name|log2l
case|:
case|case
name|LibFunc
operator|::
name|exp2
case|:
case|case
name|LibFunc
operator|::
name|exp2f
case|:
case|case
name|LibFunc
operator|::
name|exp2l
case|:
case|case
name|LibFunc
operator|::
name|memcmp
case|:
case|case
name|LibFunc
operator|::
name|strcmp
case|:
case|case
name|LibFunc
operator|::
name|strcpy
case|:
case|case
name|LibFunc
operator|::
name|stpcpy
case|:
case|case
name|LibFunc
operator|::
name|strlen
case|:
case|case
name|LibFunc
operator|::
name|strnlen
case|:
case|case
name|LibFunc
operator|::
name|memchr
case|:
case|case
name|LibFunc
operator|::
name|mempcpy
case|:
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|StringRef
name|getName
argument_list|(
name|LibFunc
operator|::
name|Func
name|F
argument_list|)
decl|const
block|{
name|auto
name|State
init|=
name|Impl
operator|->
name|getState
argument_list|(
name|F
argument_list|)
decl_stmt|;
if|if
condition|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|Unavailable
condition|)
return|return
name|StringRef
argument_list|()
return|;
if|if
condition|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|StandardName
condition|)
return|return
name|Impl
operator|->
name|StandardNames
index|[
name|F
index|]
return|;
name|assert
argument_list|(
name|State
operator|==
name|TargetLibraryInfoImpl
operator|::
name|CustomName
argument_list|)
expr_stmt|;
return|return
name|Impl
operator|->
name|CustomNames
operator|.
name|find
argument_list|(
name|F
argument_list|)
operator|->
name|second
return|;
block|}
comment|/// Returns extension attribute kind to be used for i32 parameters
comment|/// correpsonding to C-level int or unsigned int.  May be zeroext, signext,
comment|/// or none.
name|Attribute
operator|::
name|AttrKind
name|getExtAttrForI32Param
argument_list|(
argument|bool Signed = true
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Impl
operator|->
name|ShouldExtI32Param
condition|)
return|return
name|Signed
operator|?
name|Attribute
operator|::
name|SExt
operator|:
name|Attribute
operator|::
name|ZExt
return|;
if|if
condition|(
name|Impl
operator|->
name|ShouldSignExtI32Param
condition|)
return|return
name|Attribute
operator|::
name|SExt
return|;
return|return
name|Attribute
operator|::
name|None
return|;
block|}
comment|/// Returns extension attribute kind to be used for i32 return values
comment|/// correpsonding to C-level int or unsigned int.  May be zeroext, signext,
comment|/// or none.
name|Attribute
operator|::
name|AttrKind
name|getExtAttrForI32Return
argument_list|(
argument|bool Signed = true
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Impl
operator|->
name|ShouldExtI32Return
condition|)
return|return
name|Signed
operator|?
name|Attribute
operator|::
name|SExt
operator|:
name|Attribute
operator|::
name|ZExt
return|;
return|return
name|Attribute
operator|::
name|None
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Handle invalidation from the pass manager.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// If we try to invalidate this info, just return false. It cannot become
end_comment

begin_comment
comment|/// invalid even if the module or function changes.
end_comment

begin_decl_stmt
name|bool
name|invalidate
argument_list|(
name|Module
operator|&
argument_list|,
specifier|const
name|PreservedAnalyses
operator|&
argument_list|,
name|ModuleAnalysisManager
operator|::
name|Invalidator
operator|&
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|invalidate
argument_list|(
name|Function
operator|&
argument_list|,
specifier|const
name|PreservedAnalyses
operator|&
argument_list|,
name|FunctionAnalysisManager
operator|::
name|Invalidator
operator|&
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|/// Analysis pass providing the \c TargetLibraryInfo.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that this pass's result cannot be invalidated, it is immutable for the
end_comment

begin_comment
comment|/// life of the module.
end_comment

begin_decl_stmt
name|class
name|TargetLibraryAnalysis
range|:
name|public
name|AnalysisInfoMixin
operator|<
name|TargetLibraryAnalysis
operator|>
block|{
name|public
operator|:
typedef|typedef
name|TargetLibraryInfo
name|Result
typedef|;
comment|/// Default construct the library analysis.
comment|///
comment|/// This will use the module's triple to construct the library info for that
comment|/// module.
name|TargetLibraryAnalysis
argument_list|()
block|{}
comment|/// Construct a library analysis with preset info.
comment|///
comment|/// This will directly copy the preset info into the result without
comment|/// consulting the module's triple.
name|TargetLibraryAnalysis
argument_list|(
argument|TargetLibraryInfoImpl PresetInfoImpl
argument_list|)
operator|:
name|PresetInfoImpl
argument_list|(
argument|std::move(PresetInfoImpl)
argument_list|)
block|{}
name|TargetLibraryInfo
name|run
argument_list|(
name|Module
operator|&
name|M
argument_list|,
name|ModuleAnalysisManager
operator|&
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|TargetLibraryInfo
name|run
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|,
name|FunctionAnalysisManager
modifier|&
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|friend
name|AnalysisInfoMixin
operator|<
name|TargetLibraryAnalysis
operator|>
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|AnalysisKey
name|Key
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|TargetLibraryInfoImpl
operator|>
name|PresetInfoImpl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringMap
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|TargetLibraryInfoImpl
operator|>>
name|Impls
expr_stmt|;
end_expr_stmt

begin_function_decl
name|TargetLibraryInfoImpl
modifier|&
name|lookupInfoImpl
parameter_list|(
specifier|const
name|Triple
modifier|&
name|T
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
unit|};
name|class
name|TargetLibraryInfoWrapperPass
range|:
name|public
name|ImmutablePass
block|{
name|TargetLibraryInfoImpl
name|TLIImpl
block|;
name|TargetLibraryInfo
name|TLI
block|;
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
specifier|static
name|char
name|ID
block|;
name|TargetLibraryInfoWrapperPass
argument_list|()
block|;
name|explicit
name|TargetLibraryInfoWrapperPass
argument_list|(
specifier|const
name|Triple
operator|&
name|T
argument_list|)
block|;
name|explicit
name|TargetLibraryInfoWrapperPass
argument_list|(
specifier|const
name|TargetLibraryInfoImpl
operator|&
name|TLI
argument_list|)
block|;
name|TargetLibraryInfo
operator|&
name|getTLI
argument_list|()
block|{
return|return
name|TLI
return|;
block|}
specifier|const
name|TargetLibraryInfo
operator|&
name|getTLI
argument_list|()
specifier|const
block|{
return|return
name|TLI
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

