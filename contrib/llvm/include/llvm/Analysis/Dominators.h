begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- llvm/Analysis/Dominators.h - Dominator Info Calculation --*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the DominatorTree class, which provides fast and efficient
end_comment

begin_comment
comment|// dominance queries.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_DOMINATORS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_DOMINATORS_H
end_define

begin_include
include|#
directive|include
file|"llvm/Pass.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DepthFirstIterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/GraphTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CFG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//===----------------------------------------------------------------------===//
comment|/// DominatorBase - Base class that other, more interesting dominator analyses
comment|/// inherit from.
comment|///
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorBase
block|{
name|protected
operator|:
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
name|Roots
block|;
specifier|const
name|bool
name|IsPostDominators
block|;
specifier|inline
name|explicit
name|DominatorBase
argument_list|(
argument|bool isPostDom
argument_list|)
operator|:
name|Roots
argument_list|()
block|,
name|IsPostDominators
argument_list|(
argument|isPostDom
argument_list|)
block|{}
name|public
operator|:
comment|/// getRoots - Return the root blocks of the current CFG.  This may include
comment|/// multiple blocks if we are computing post dominators.  For forward
comment|/// dominators, this will always be a single block (the entry node).
comment|///
specifier|inline
specifier|const
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
operator|&
name|getRoots
argument_list|()
specifier|const
block|{
return|return
name|Roots
return|;
block|}
comment|/// isPostDominator - Returns true if analysis based of postdoms
comment|///
name|bool
name|isPostDominator
argument_list|()
specifier|const
block|{
return|return
name|IsPostDominators
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|// DomTreeNode - Dominator Tree Node
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorTreeBase
block|; struct
name|PostDominatorTree
block|;
name|class
name|MachineBasicBlock
block|;
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DomTreeNodeBase
block|{
name|NodeT
operator|*
name|TheBB
block|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
block|;
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
name|Children
block|;
name|int
name|DFSNumIn
block|,
name|DFSNumOut
block|;
name|template
operator|<
name|class
name|N
operator|>
name|friend
name|class
name|DominatorTreeBase
block|;
name|friend
expr|struct
name|PostDominatorTree
block|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|Children
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|Children
operator|.
name|end
argument_list|()
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|end
argument_list|()
return|;
block|}
name|NodeT
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|TheBB
return|;
block|}
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getIDom
argument_list|()
specifier|const
block|{
return|return
name|IDom
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|&
name|getChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
return|;
block|}
name|DomTreeNodeBase
argument_list|(
name|NodeT
operator|*
name|BB
argument_list|,
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|iDom
argument_list|)
operator|:
name|TheBB
argument_list|(
name|BB
argument_list|)
operator|,
name|IDom
argument_list|(
name|iDom
argument_list|)
operator|,
name|DFSNumIn
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|DFSNumOut
argument_list|(
argument|-
literal|1
argument_list|)
block|{ }
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|addChild
argument_list|(
argument|DomTreeNodeBase<NodeT> *C
argument_list|)
block|{
name|Children
operator|.
name|push_back
argument_list|(
name|C
argument_list|)
block|;
return|return
name|C
return|;
block|}
name|size_t
name|getNumChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|clearAllChildren
parameter_list|()
block|{
name|Children
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|compare
argument_list|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Other
argument_list|)
block|{
if|if
condition|(
name|getNumChildren
argument_list|()
operator|!=
name|Other
operator|->
name|getNumChildren
argument_list|()
condition|)
return|return
name|true
return|;
name|SmallPtrSet
operator|<
name|NodeT
operator|*
operator|,
literal|4
operator|>
name|OtherChildren
expr_stmt|;
for|for
control|(
name|iterator
name|I
init|=
name|Other
operator|->
name|begin
argument_list|()
init|,
name|E
init|=
name|Other
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NodeT
modifier|*
name|Nd
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|getBlock
argument_list|()
decl_stmt|;
name|OtherChildren
operator|.
name|insert
argument_list|(
name|Nd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NodeT
modifier|*
name|N
init|=
operator|(
operator|*
name|I
operator|)
operator|->
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|OtherChildren
operator|.
name|count
argument_list|(
name|N
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|void
name|setIDom
argument_list|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewIDom
argument_list|)
block|{
name|assert
argument_list|(
name|IDom
operator|&&
literal|"No immediate dominator?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDom
operator|!=
name|NewIDom
condition|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|IDom
operator|->
name|Children
operator|.
name|begin
argument_list|()
argument_list|,
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
operator|&&
literal|"Not in immediate dominator children set!"
argument_list|)
expr_stmt|;
comment|// I am no longer your child...
name|IDom
operator|->
name|Children
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Switch to new dominator
name|IDom
operator|=
name|NewIDom
expr_stmt|;
name|IDom
operator|->
name|Children
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// getDFSNumIn/getDFSNumOut - These are an internal implementation detail, do
comment|/// not call them.
name|unsigned
name|getDFSNumIn
argument_list|()
specifier|const
block|{
return|return
name|DFSNumIn
return|;
block|}
name|unsigned
name|getDFSNumOut
argument_list|()
specifier|const
block|{
return|return
name|DFSNumOut
return|;
block|}
name|private
label|:
comment|// Return true if this node is dominated by other. Use this only if DFS info
comment|// is valid.
name|bool
name|DominatedBy
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|other
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|DFSNumIn
operator|>=
name|other
operator|->
name|DFSNumIn
operator|&&
name|this
operator|->
name|DFSNumOut
operator|<=
name|other
operator|->
name|DFSNumOut
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class DomTreeNodeBase<BasicBlock>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|EXTERN_TEMPLATE_INSTANTIATION
argument_list|(
argument|class DomTreeNodeBase<MachineBasicBlock>
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|o
operator|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|)
block|{
if|if
condition|(
name|Node
operator|->
name|getBlock
argument_list|()
condition|)
name|WriteAsOperand
argument_list|(
name|o
argument_list|,
name|Node
operator|->
name|getBlock
argument_list|()
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|o
operator|<<
literal|"<<exit node>>"
expr_stmt|;
name|o
operator|<<
literal|" {"
operator|<<
name|Node
operator|->
name|getDFSNumIn
argument_list|()
operator|<<
literal|","
operator|<<
name|Node
operator|->
name|getDFSNumOut
argument_list|()
operator|<<
literal|"}"
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|o
operator|<<
literal|"\n"
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|NodeT
operator|>
specifier|inline
name|void
name|PrintDomTree
argument_list|(
argument|const DomTreeNodeBase<NodeT> *N
argument_list|,
argument|raw_ostream&o
argument_list|,
argument|unsigned Lev
argument_list|)
block|{
name|o
operator|.
name|indent
argument_list|(
literal|2
operator|*
name|Lev
argument_list|)
operator|<<
literal|"["
operator|<<
name|Lev
operator|<<
literal|"] "
operator|<<
name|N
block|;
for|for
control|(
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|N
operator|->
name|begin
argument_list|()
operator|,
name|E
operator|=
name|N
operator|->
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|PrintDomTree
operator|<
name|NodeT
operator|>
operator|(
operator|*
name|I
operator|,
name|o
operator|,
name|Lev
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|DomTreeNodeBase
operator|<
name|BasicBlock
operator|>
name|DomTreeNode
expr_stmt|;
end_typedef

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// DominatorTree - Calculate the immediate dominator tree for a function.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|N
operator|>
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT
argument_list|,
argument|FuncT& F
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
name|class
name|DominatorTreeBase
operator|:
name|public
name|DominatorBase
operator|<
name|NodeT
operator|>
block|{
name|bool
name|dominatedBySlowTreeWalk
argument_list|(
argument|const DomTreeNodeBase<NodeT> *A
argument_list|,
argument|const DomTreeNodeBase<NodeT> *B
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|A
operator|!=
name|B
argument_list|)
block|;
name|assert
argument_list|(
name|isReachableFromEntry
argument_list|(
name|B
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|isReachableFromEntry
argument_list|(
name|A
argument_list|)
argument_list|)
block|;
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
block|;
while|while
condition|(
operator|(
name|IDom
operator|=
name|B
operator|->
name|getIDom
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|IDom
operator|!=
name|A
operator|&&
name|IDom
operator|!=
name|B
condition|)
name|B
operator|=
name|IDom
expr_stmt|;
comment|// Walk up the tree
return|return
name|IDom
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_typedef
typedef|typedef
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
name|DomTreeNodeMapType
expr_stmt|;
end_typedef

begin_decl_stmt
name|DomTreeNodeMapType
name|DomTreeNodes
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|RootNode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|DFSInfoValid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|SlowQueries
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Information record used during immediate dominators computation.
end_comment

begin_struct
struct|struct
name|InfoRec
block|{
name|unsigned
name|DFSNum
decl_stmt|;
name|unsigned
name|Parent
decl_stmt|;
name|unsigned
name|Semi
decl_stmt|;
name|NodeT
modifier|*
name|Label
decl_stmt|;
name|InfoRec
argument_list|()
operator|:
name|DFSNum
argument_list|(
literal|0
argument_list|)
operator|,
name|Parent
argument_list|(
literal|0
argument_list|)
operator|,
name|Semi
argument_list|(
literal|0
argument_list|)
operator|,
name|Label
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
end_struct

begin_expr_stmt
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|NodeT
operator|*
operator|>
name|IDoms
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Vertex - Map the DFS number to the BasicBlock*
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|NodeT
operator|*
operator|>
name|Vertex
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Info - Collection of information used during the computation of idoms.
end_comment

begin_expr_stmt
name|DenseMap
operator|<
name|NodeT
operator|*
operator|,
name|InfoRec
operator|>
name|Info
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
block|{
for|for
control|(
name|typename
name|DomTreeNodeMapType
operator|::
name|iterator
name|I
operator|=
name|this
operator|->
name|DomTreeNodes
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|DomTreeNodes
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|delete
name|I
operator|->
name|second
decl_stmt|;
name|DomTreeNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|IDoms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|->
name|Roots
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Vertex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|RootNode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|// NewBB is split and now it has one successor. Update dominator tree to
end_comment

begin_comment
comment|// reflect this change.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|N
operator|,
name|class
name|GraphT
operator|>
name|void
name|Split
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType* NewBB
argument_list|)
block|{
name|assert
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|GraphT
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
argument_list|,
name|GraphT
operator|::
name|child_end
argument_list|(
name|NewBB
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
literal|"NewBB should have a single successor!"
argument_list|)
block|;
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|NewBBSucc
operator|=
operator|*
name|GraphT
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
block|;
name|std
operator|::
name|vector
operator|<
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
operator|>
name|PredBlocks
block|;
typedef|typedef
name|GraphTraits
operator|<
name|Inverse
operator|<
name|N
operator|>
expr|>
name|InvTraits
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|InvTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvTraits
operator|::
name|child_begin
argument_list|(
name|NewBB
argument_list|)
operator|,
name|PE
operator|=
name|InvTraits
operator|::
name|child_end
argument_list|(
name|NewBB
argument_list|)
init|;
name|PI
operator|!=
name|PE
condition|;
operator|++
name|PI
control|)
name|PredBlocks
operator|.
name|push_back
argument_list|(
operator|*
name|PI
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|assert
argument_list|(
operator|!
name|PredBlocks
operator|.
name|empty
argument_list|()
operator|&&
literal|"No predblocks?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|NewBBDominatesNewBBSucc
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|typename
name|InvTraits
operator|::
name|ChildIteratorType
name|PI
operator|=
name|InvTraits
operator|::
name|child_begin
argument_list|(
name|NewBBSucc
argument_list|)
operator|,
name|E
operator|=
name|InvTraits
operator|::
name|child_end
argument_list|(
name|NewBBSucc
argument_list|)
init|;
name|PI
operator|!=
name|E
condition|;
operator|++
name|PI
control|)
block|{
name|typename
name|InvTraits
operator|::
name|NodeType
operator|*
name|ND
operator|=
operator|*
name|PI
expr_stmt|;
if|if
condition|(
name|ND
operator|!=
name|NewBB
operator|&&
operator|!
name|DT
operator|.
name|dominates
argument_list|(
name|NewBBSucc
argument_list|,
name|ND
argument_list|)
operator|&&
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|ND
argument_list|)
condition|)
block|{
name|NewBBDominatesNewBBSucc
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_comment
comment|// Find NewBB's immediate dominator and create new dominator tree node for
end_comment

begin_comment
comment|// NewBB.
end_comment

begin_decl_stmt
name|NodeT
modifier|*
name|NewBBIDom
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PredBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|PredBlocks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|NewBBIDom
operator|=
name|PredBlocks
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
end_for

begin_comment
comment|// It's possible that none of the predecessors of NewBB are reachable;
end_comment

begin_comment
comment|// in that case, NewBB itself is unreachable, so nothing needs to be
end_comment

begin_comment
comment|// changed.
end_comment

begin_if
if|if
condition|(
operator|!
name|NewBBIDom
condition|)
return|return;
end_if

begin_for
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|PredBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|DT
operator|.
name|isReachableFromEntry
argument_list|(
name|PredBlocks
index|[
name|i
index|]
argument_list|)
condition|)
name|NewBBIDom
operator|=
name|DT
operator|.
name|findNearestCommonDominator
argument_list|(
name|NewBBIDom
argument_list|,
name|PredBlocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Create the new dominator tree node... and set the idom of NewBB.
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewBBNode
operator|=
name|DT
operator|.
name|addNewBlock
argument_list|(
name|NewBB
argument_list|,
name|NewBBIDom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If NewBB strictly dominates other blocks, then it is now the immediate
end_comment

begin_comment
comment|// dominator of NewBBSucc.  Update the dominator tree as appropriate.
end_comment

begin_if
if|if
condition|(
name|NewBBDominatesNewBBSucc
condition|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewBBSuccNode
operator|=
name|DT
operator|.
name|getNode
argument_list|(
name|NewBBSucc
argument_list|)
expr_stmt|;
name|DT
operator|.
name|changeImmediateDominator
argument_list|(
name|NewBBSuccNode
argument_list|,
name|NewBBNode
argument_list|)
expr_stmt|;
block|}
end_if

begin_macro
unit|}  public:
name|explicit
end_macro

begin_macro
name|DominatorTreeBase
argument_list|(
argument|bool isPostDom
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|DominatorBase
operator|<
name|NodeT
operator|>
operator|(
name|isPostDom
operator|)
operator|,
name|DFSInfoValid
argument_list|(
name|false
argument_list|)
operator|,
name|SlowQueries
argument_list|(
literal|0
argument_list|)
block|{}
name|virtual
operator|~
name|DominatorTreeBase
argument_list|()
block|{
name|reset
argument_list|()
block|; }
comment|/// compare - Return false if the other dominator tree base matches this
comment|/// dominator tree base. Otherwise return true.
name|bool
name|compare
argument_list|(
argument|DominatorTreeBase&Other
argument_list|)
specifier|const
block|{
specifier|const
name|DomTreeNodeMapType
operator|&
name|OtherDomTreeNodes
operator|=
name|Other
operator|.
name|DomTreeNodes
block|;
if|if
condition|(
name|DomTreeNodes
operator|.
name|size
argument_list|()
operator|!=
name|OtherDomTreeNodes
operator|.
name|size
argument_list|()
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_for
for|for
control|(
name|typename
name|DomTreeNodeMapType
operator|::
name|const_iterator
name|I
operator|=
name|this
operator|->
name|DomTreeNodes
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|this
operator|->
name|DomTreeNodes
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NodeT
modifier|*
name|BB
init|=
name|I
operator|->
name|first
decl_stmt|;
name|typename
name|DomTreeNodeMapType
operator|::
name|const_iterator
name|OI
operator|=
name|OtherDomTreeNodes
operator|.
name|find
argument_list|(
name|BB
argument_list|)
expr_stmt|;
if|if
condition|(
name|OI
operator|==
name|OtherDomTreeNodes
operator|.
name|end
argument_list|()
condition|)
return|return
name|true
return|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|MyNd
operator|=
name|I
operator|->
name|second
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|OtherNd
operator|=
name|OI
operator|->
name|second
expr_stmt|;
if|if
condition|(
name|MyNd
operator|->
name|compare
argument_list|(
name|OtherNd
argument_list|)
condition|)
return|return
name|true
return|;
block|}
end_for

begin_return
return|return
name|false
return|;
end_return

begin_function
unit|}    virtual
name|void
name|releaseMemory
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// getNode - return the (Post)DominatorTree node for the specified basic
end_comment

begin_comment
comment|/// block.  This is the same as using operator[] on this class.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
specifier|inline
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getNode
argument_list|(
argument|NodeT *BB
argument_list|)
specifier|const
block|{
return|return
name|DomTreeNodes
operator|.
name|lookup
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getRootNode - This returns the entry node for the CFG of the function.  If
end_comment

begin_comment
comment|/// this tree represents the post-dominance relations for a function, however,
end_comment

begin_comment
comment|/// this root may be a node with the block == NULL.  This is the case when
end_comment

begin_comment
comment|/// there are multiple exit nodes from a particular function.  Consumers of
end_comment

begin_comment
comment|/// post-dominance information must be capable of dealing with this
end_comment

begin_comment
comment|/// possibility.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getRootNode
argument_list|()
block|{
return|return
name|RootNode
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getRootNode
argument_list|()
specifier|const
block|{
return|return
name|RootNode
return|;
block|}
end_expr_stmt

begin_comment
comment|/// properlyDominates - Returns true iff A dominates B and A != B.
end_comment

begin_comment
comment|/// Note that this is not a constant time operation!
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|bool
name|properlyDominates
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|B
argument_list|)
block|{
if|if
condition|(
name|A
operator|==
literal|0
operator|||
name|B
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|false
return|;
return|return
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_function_decl
name|bool
name|properlyDominates
parameter_list|(
specifier|const
name|NodeT
modifier|*
name|A
parameter_list|,
specifier|const
name|NodeT
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// isReachableFromEntry - Return true if A is dominated by the entry
end_comment

begin_comment
comment|/// block of the function containing it.
end_comment

begin_decl_stmt
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|NodeT
operator|*
name|A
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|isPostDominator
argument_list|()
operator|&&
literal|"This is not implemented for post dominators"
argument_list|)
expr_stmt|;
return|return
name|isReachableFromEntry
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|inline
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|)
decl|const
block|{
return|return
name|A
return|;
block|}
end_decl_stmt

begin_comment
comment|/// dominates - Returns true iff A dominates B.  Note that this is not a
end_comment

begin_comment
comment|/// constant time operation!
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
specifier|inline
name|bool
name|dominates
argument_list|(
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|B
argument_list|)
block|{
comment|// A node trivially dominates itself.
if|if
condition|(
name|B
operator|==
name|A
condition|)
return|return
name|true
return|;
comment|// An unreachable node is dominated by anything.
if|if
condition|(
operator|!
name|isReachableFromEntry
argument_list|(
name|B
argument_list|)
condition|)
return|return
name|true
return|;
comment|// And dominates nothing.
if|if
condition|(
operator|!
name|isReachableFromEntry
argument_list|(
name|A
argument_list|)
condition|)
return|return
name|false
return|;
comment|// Compare the result of the tree walk and the dfs numbers, if expensive
comment|// checks are enabled.
ifdef|#
directive|ifdef
name|XDEBUG
name|assert
argument_list|(
operator|(
operator|!
name|DFSInfoValid
operator|||
operator|(
name|dominatedBySlowTreeWalk
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
operator|==
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
operator|)
operator|)
operator|&&
literal|"Tree walk disagrees with dfs numbers!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DFSInfoValid
condition|)
return|return
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
return|;
comment|// If we end up with too many slow queries, just update the
comment|// DFS numbers on the theory that we are going to keep querying.
name|SlowQueries
operator|++
expr_stmt|;
if|if
condition|(
name|SlowQueries
operator|>
literal|32
condition|)
block|{
name|updateDFSNumbers
argument_list|()
expr_stmt|;
return|return
name|B
operator|->
name|DominatedBy
argument_list|(
name|A
argument_list|)
return|;
block|}
return|return
name|dominatedBySlowTreeWalk
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_function_decl
name|bool
name|dominates
parameter_list|(
specifier|const
name|NodeT
modifier|*
name|A
parameter_list|,
specifier|const
name|NodeT
modifier|*
name|B
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|NodeT
operator|*
name|getRoot
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|this
operator|->
name|Roots
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Should always have entry node!"
argument_list|)
block|;
return|return
name|this
operator|->
name|Roots
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_comment
comment|/// findNearestCommonDominator - Find nearest common dominator basic block
end_comment

begin_comment
comment|/// for basic block A and B. If there is no such block then return NULL.
end_comment

begin_function
name|NodeT
modifier|*
name|findNearestCommonDominator
parameter_list|(
name|NodeT
modifier|*
name|A
parameter_list|,
name|NodeT
modifier|*
name|B
parameter_list|)
block|{
name|assert
argument_list|(
name|A
operator|->
name|getParent
argument_list|()
operator|==
name|B
operator|->
name|getParent
argument_list|()
operator|&&
literal|"Two blocks are not in same function"
argument_list|)
expr_stmt|;
comment|// If either A or B is a entry block then it is nearest common dominator
comment|// (for forward-dominators).
if|if
condition|(
operator|!
name|this
operator|->
name|isPostDominator
argument_list|()
condition|)
block|{
name|NodeT
modifier|&
name|Entry
init|=
name|A
operator|->
name|getParent
argument_list|()
operator|->
name|front
argument_list|()
decl_stmt|;
if|if
condition|(
name|A
operator|==
operator|&
name|Entry
operator|||
name|B
operator|==
operator|&
name|Entry
condition|)
return|return
operator|&
name|Entry
return|;
block|}
comment|// If B dominates A then B is nearest common dominator.
if|if
condition|(
name|dominates
argument_list|(
name|B
argument_list|,
name|A
argument_list|)
condition|)
return|return
name|B
return|;
comment|// If A dominates B then A is nearest common dominator.
if|if
condition|(
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
condition|)
return|return
name|A
return|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NodeA
operator|=
name|getNode
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NodeB
operator|=
name|getNode
argument_list|(
name|B
argument_list|)
expr_stmt|;
comment|// Collect NodeA dominators set.
name|SmallPtrSet
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|,
literal|16
operator|>
name|NodeADoms
expr_stmt|;
name|NodeADoms
operator|.
name|insert
argument_list|(
name|NodeA
argument_list|)
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomA
operator|=
name|NodeA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
while|while
condition|(
name|IDomA
condition|)
block|{
name|NodeADoms
operator|.
name|insert
argument_list|(
name|IDomA
argument_list|)
expr_stmt|;
name|IDomA
operator|=
name|IDomA
operator|->
name|getIDom
argument_list|()
expr_stmt|;
block|}
comment|// Walk NodeB immediate dominators chain and find common dominator node.
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomB
operator|=
name|NodeB
operator|->
name|getIDom
argument_list|()
expr_stmt|;
while|while
condition|(
name|IDomB
condition|)
block|{
if|if
condition|(
name|NodeADoms
operator|.
name|count
argument_list|(
name|IDomB
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|IDomB
operator|->
name|getBlock
argument_list|()
return|;
name|IDomB
operator|=
name|IDomB
operator|->
name|getIDom
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|NodeT
modifier|*
name|findNearestCommonDominator
parameter_list|(
specifier|const
name|NodeT
modifier|*
name|A
parameter_list|,
specifier|const
name|NodeT
modifier|*
name|B
parameter_list|)
block|{
comment|// Cast away the const qualifiers here. This is ok since
comment|// const is re-introduced on the return type.
return|return
name|findNearestCommonDominator
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|,
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//===--------------------------------------------------------------------===//
end_comment

begin_comment
comment|// API to update (Post)DominatorTree information based on modifications to
end_comment

begin_comment
comment|// the CFG...
end_comment

begin_comment
comment|/// addNewBlock - Add a new node to the dominator tree information.  This
end_comment

begin_comment
comment|/// creates a new node as a child of DomBB dominator node,linking it into
end_comment

begin_comment
comment|/// the children list of the immediate dominator.
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|addNewBlock
argument_list|(
argument|NodeT *BB
argument_list|,
argument|NodeT *DomBB
argument_list|)
block|{
name|assert
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
operator|==
literal|0
operator|&&
literal|"Block already in dominator tree!"
argument_list|)
block|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomNode
operator|=
name|getNode
argument_list|(
name|DomBB
argument_list|)
block|;
name|assert
argument_list|(
name|IDomNode
operator|&&
literal|"Not immediate dominator specified for block!"
argument_list|)
block|;
name|DFSInfoValid
operator|=
name|false
block|;
return|return
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
argument|new DomTreeNodeBase<NodeT>(BB, IDomNode)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// changeImmediateDominator - This method is used to update the dominator
end_comment

begin_comment
comment|/// tree information when a node's immediate dominator changes.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|changeImmediateDominator
argument_list|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|N
argument_list|,
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|NewIDom
argument_list|)
block|{
name|assert
argument_list|(
name|N
operator|&&
name|NewIDom
operator|&&
literal|"Cannot change null node pointers!"
argument_list|)
expr_stmt|;
name|DFSInfoValid
operator|=
name|false
expr_stmt|;
name|N
operator|->
name|setIDom
argument_list|(
name|NewIDom
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|changeImmediateDominator
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|,
name|NodeT
modifier|*
name|NewBB
parameter_list|)
block|{
name|changeImmediateDominator
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|NewBB
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// eraseNode - Removes a node from the dominator tree. Block must not
end_comment

begin_comment
comment|/// dominate any other blocks. Removes node from its immediate dominator's
end_comment

begin_comment
comment|/// children list. Deletes dominator node associated with basic block BB.
end_comment

begin_function
name|void
name|eraseNode
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|getNode
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Node
operator|&&
literal|"Removing node that isn't in dominator tree."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Node
operator|->
name|getChildren
argument_list|()
operator|.
name|empty
argument_list|()
operator|&&
literal|"Node is not a leaf node."
argument_list|)
expr_stmt|;
comment|// Remove node from immediate dominator's children list.
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDom
operator|=
name|Node
operator|->
name|getIDom
argument_list|()
expr_stmt|;
if|if
condition|(
name|IDom
condition|)
block|{
name|typename
name|std
operator|::
name|vector
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|IDom
operator|->
name|Children
operator|.
name|begin
argument_list|()
argument_list|,
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|IDom
operator|->
name|Children
operator|.
name|end
argument_list|()
operator|&&
literal|"Not in immediate dominator children set!"
argument_list|)
expr_stmt|;
comment|// I am no longer your child...
name|IDom
operator|->
name|Children
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
name|DomTreeNodes
operator|.
name|erase
argument_list|(
name|BB
argument_list|)
expr_stmt|;
name|delete
name|Node
decl_stmt|;
block|}
end_function

begin_comment
comment|/// removeNode - Removes a node from the dominator tree.  Block must not
end_comment

begin_comment
comment|/// dominate any other blocks.  Invalidates any node pointing to removed
end_comment

begin_comment
comment|/// block.
end_comment

begin_function
name|void
name|removeNode
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|)
block|{
name|assert
argument_list|(
name|getNode
argument_list|(
name|BB
argument_list|)
operator|&&
literal|"Removing node that isn't in dominator tree."
argument_list|)
expr_stmt|;
name|DomTreeNodes
operator|.
name|erase
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// splitBlock - BB is split and now it has one successor. Update dominator
end_comment

begin_comment
comment|/// tree to reflect this change.
end_comment

begin_function
name|void
name|splitBlock
parameter_list|(
name|NodeT
modifier|*
name|NewBB
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|IsPostDominators
condition|)
name|this
operator|->
name|Split
operator|<
name|Inverse
operator|<
name|NodeT
operator|*
operator|>
operator|,
name|GraphTraits
operator|<
name|Inverse
operator|<
name|NodeT
operator|*
operator|>
expr|>
operator|>
operator|(
operator|*
name|this
operator|,
name|NewBB
operator|)
expr_stmt|;
else|else
name|this
operator|->
name|Split
operator|<
name|NodeT
operator|*
operator|,
name|GraphTraits
operator|<
name|NodeT
operator|*
operator|>
expr|>
operator|(
operator|*
name|this
operator|,
name|NewBB
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// print - Convert to human readable form
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|o
argument_list|)
decl|const
block|{
name|o
operator|<<
literal|"=============================--------------------------------\n"
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|isPostDominator
argument_list|()
condition|)
name|o
operator|<<
literal|"Inorder PostDominator Tree: "
expr_stmt|;
else|else
name|o
operator|<<
literal|"Inorder Dominator Tree: "
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|DFSInfoValid
condition|)
name|o
operator|<<
literal|"DFSNumbers invalid: "
operator|<<
name|SlowQueries
operator|<<
literal|" slow queries."
expr_stmt|;
name|o
operator|<<
literal|"\n"
expr_stmt|;
comment|// The postdom tree can have a null root if there are no returns.
if|if
condition|(
name|getRootNode
argument_list|()
condition|)
name|PrintDomTree
operator|<
name|NodeT
operator|>
operator|(
name|getRootNode
argument_list|()
operator|,
name|o
operator|,
literal|1
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|friend
name|typename
name|GraphT
operator|::
name|NodeType
operator|*
name|Eval
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType* V
argument_list|,
argument|unsigned LastLinked
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|GraphT
operator|>
name|friend
name|unsigned
name|DFSPass
argument_list|(
argument|DominatorTreeBase<typename GraphT::NodeType>& DT
argument_list|,
argument|typename GraphT::NodeType* V
argument_list|,
argument|unsigned N
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|FuncT
operator|,
name|class
name|N
operator|>
name|friend
name|void
name|Calculate
argument_list|(
argument|DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT
argument_list|,
argument|FuncT& F
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// updateDFSNumbers - Assign In and Out numbers to the nodes while walking
end_comment

begin_comment
comment|/// dominator tree in dfs order.
end_comment

begin_function
name|void
name|updateDFSNumbers
parameter_list|()
block|{
name|unsigned
name|DFSNum
init|=
literal|0
decl_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
operator|,
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|iterator
operator|>
operator|,
literal|32
operator|>
name|WorkStack
expr_stmt|;
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|ThisRoot
operator|=
name|getRootNode
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ThisRoot
condition|)
return|return;
comment|// Even in the case of multiple exits that form the post dominator root
comment|// nodes, do not iterate over all exits, but start from the virtual root
comment|// node. Otherwise bbs, that are not post dominated by any exit but by the
comment|// virtual root node, will never be assigned a DFS number.
name|WorkStack
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ThisRoot
argument_list|,
name|ThisRoot
operator|->
name|begin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ThisRoot
operator|->
name|DFSNumIn
operator|=
name|DFSNum
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|WorkStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|first
expr_stmt|;
name|typename
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|::
name|iterator
name|ChildIt
operator|=
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
comment|// If we visited all of the children of this node, "recurse" back up the
comment|// stack setting the DFOutNum.
if|if
condition|(
name|ChildIt
operator|==
name|Node
operator|->
name|end
argument_list|()
condition|)
block|{
name|Node
operator|->
name|DFSNumOut
operator|=
name|DFSNum
operator|++
expr_stmt|;
name|WorkStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise, recursively visit this child.
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Child
operator|=
operator|*
name|ChildIt
expr_stmt|;
operator|++
name|WorkStack
operator|.
name|back
argument_list|()
operator|.
name|second
expr_stmt|;
name|WorkStack
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|Child
argument_list|,
name|Child
operator|->
name|begin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Child
operator|->
name|DFSNumIn
operator|=
name|DFSNum
operator|++
expr_stmt|;
block|}
block|}
name|SlowQueries
operator|=
literal|0
expr_stmt|;
name|DFSInfoValid
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|getNodeForBlock
argument_list|(
argument|NodeT *BB
argument_list|)
block|{
if|if
condition|(
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|Node
operator|=
name|getNode
argument_list|(
name|BB
argument_list|)
condition|)
return|return
name|Node
return|;
comment|// Haven't calculated this node yet?  Get or calculate the node for the
comment|// immediate dominator.
name|NodeT
operator|*
name|IDom
operator|=
name|getIDom
argument_list|(
name|BB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|IDom
operator|||
name|this
operator|->
name|DomTreeNodes
index|[
name|NULL
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|IDomNode
operator|=
name|getNodeForBlock
argument_list|(
name|IDom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Add a new tree node for this BasicBlock, and link it as a child of
end_comment

begin_comment
comment|// IDomNode
end_comment

begin_expr_stmt
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|*
name|C
operator|=
name|new
name|DomTreeNodeBase
operator|<
name|NodeT
operator|>
operator|(
name|BB
operator|,
name|IDomNode
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|this
operator|->
name|DomTreeNodes
index|[
name|BB
index|]
operator|=
name|IDomNode
operator|->
name|addChild
argument_list|(
name|C
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}    inline
name|NodeT
modifier|*
name|getIDom
argument_list|(
name|NodeT
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|IDoms
operator|.
name|lookup
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|inline
name|void
name|addRoot
parameter_list|(
name|NodeT
modifier|*
name|BB
parameter_list|)
block|{
name|this
operator|->
name|Roots
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// recalculate - compute a dominator tree for the given function
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|FT
operator|>
name|void
name|recalculate
argument_list|(
argument|FT& F
argument_list|)
block|{
typedef|typedef
name|GraphTraits
operator|<
name|FT
operator|*
operator|>
name|TraitsTy
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|Vertex
operator|.
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|this
operator|->
name|IsPostDominators
condition|)
block|{
comment|// Initialize root
name|NodeT
modifier|*
name|entry
init|=
name|TraitsTy
operator|::
name|getEntryNode
argument_list|(
operator|&
name|F
argument_list|)
decl_stmt|;
name|this
operator|->
name|Roots
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|this
operator|->
name|IDoms
index|[
name|entry
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|DomTreeNodes
index|[
name|entry
index|]
operator|=
literal|0
expr_stmt|;
name|Calculate
operator|<
name|FT
operator|,
name|NodeT
operator|*
operator|>
operator|(
operator|*
name|this
operator|,
name|F
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Initialize the roots list
for|for
control|(
name|typename
name|TraitsTy
operator|::
name|nodes_iterator
name|I
operator|=
name|TraitsTy
operator|::
name|nodes_begin
argument_list|(
operator|&
name|F
argument_list|)
operator|,
name|E
operator|=
name|TraitsTy
operator|::
name|nodes_end
argument_list|(
operator|&
name|F
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|std
operator|::
name|distance
argument_list|(
name|TraitsTy
operator|::
name|child_begin
argument_list|(
name|I
argument_list|)
argument_list|,
name|TraitsTy
operator|::
name|child_end
argument_list|(
name|I
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|addRoot
argument_list|(
name|I
argument_list|)
expr_stmt|;
comment|// Prepopulate maps so that we don't get iterator invalidation issues later.
name|this
operator|->
name|IDoms
index|[
name|I
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|DomTreeNodes
index|[
name|I
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|Calculate
operator|<
name|FT
operator|,
name|Inverse
operator|<
name|NodeT
operator|*
operator|>
expr|>
operator|(
operator|*
name|this
operator|,
name|F
operator|)
expr_stmt|;
block|}
end_if

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|// These two functions are declared out of line as a workaround for building
end_comment

begin_comment
comment|// with old (< r147295) versions of clang because of pr11642.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|NodeT
operator|>
name|bool
name|DominatorTreeBase
operator|<
name|NodeT
operator|>
operator|::
name|dominates
argument_list|(
argument|const NodeT *A
argument_list|,
argument|const NodeT *B
argument_list|)
block|{
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_comment
comment|// Cast away the const qualifiers here. This is ok since
end_comment

begin_comment
comment|// this function doesn't actually return the values returned
end_comment

begin_comment
comment|// from getNode.
end_comment

begin_return
return|return
name|dominates
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|} template
operator|<
name|class
name|NodeT
operator|>
name|bool
name|DominatorTreeBase
operator|<
name|NodeT
operator|>
operator|::
name|properlyDominates
argument_list|(
argument|const NodeT *A
argument_list|,
argument|const NodeT *B
argument_list|)
block|{
if|if
condition|(
name|A
operator|==
name|B
condition|)
return|return
name|false
return|;
end_expr_stmt

begin_comment
comment|// Cast away the const qualifiers here. This is ok since
end_comment

begin_comment
comment|// this function doesn't actually return the values returned
end_comment

begin_comment
comment|// from getNode.
end_comment

begin_return
return|return
name|dominates
argument_list|(
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|A
operator|)
argument_list|)
argument_list|,
name|getNode
argument_list|(
name|const_cast
operator|<
name|NodeT
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  EXTERN_TEMPLATE_INSTANTIATION
operator|(
name|class
name|DominatorTreeBase
operator|<
name|BasicBlock
operator|>
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|class
name|BasicBlockEdge
block|{
specifier|const
name|BasicBlock
modifier|*
name|Start
decl_stmt|;
specifier|const
name|BasicBlock
modifier|*
name|End
decl_stmt|;
name|public
label|:
name|BasicBlockEdge
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|Start_
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|End_
argument_list|)
operator|:
name|Start
argument_list|(
name|Start_
argument_list|)
operator|,
name|End
argument_list|(
argument|End_
argument_list|)
block|{ }
specifier|const
name|BasicBlock
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Start
return|;
block|}
specifier|const
name|BasicBlock
operator|*
name|getEnd
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
name|bool
name|isSingleEdge
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===-------------------------------------
end_comment

begin_comment
comment|/// DominatorTree Class - Concrete subclass of DominatorTreeBase that is used to
end_comment

begin_comment
comment|/// compute a normal dominator tree.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|DominatorTree
range|:
name|public
name|FunctionPass
block|{
name|public
operator|:
specifier|static
name|char
name|ID
block|;
comment|// Pass ID, replacement for typeid
name|DominatorTreeBase
operator|<
name|BasicBlock
operator|>
operator|*
name|DT
block|;
name|DominatorTree
argument_list|()
operator|:
name|FunctionPass
argument_list|(
argument|ID
argument_list|)
block|{
name|initializeDominatorTreePass
argument_list|(
operator|*
name|PassRegistry
operator|::
name|getPassRegistry
argument_list|()
argument_list|)
block|;
name|DT
operator|=
name|new
name|DominatorTreeBase
operator|<
name|BasicBlock
operator|>
operator|(
name|false
operator|)
block|;   }
operator|~
name|DominatorTree
argument_list|()
block|{
name|delete
name|DT
block|;   }
name|DominatorTreeBase
operator|<
name|BasicBlock
operator|>
operator|&
name|getBase
argument_list|()
block|{
return|return
operator|*
name|DT
return|;
block|}
comment|/// getRoots - Return the root blocks of the current CFG.  This may include
comment|/// multiple blocks if we are computing post dominators.  For forward
comment|/// dominators, this will always be a single block (the entry node).
comment|///
specifier|inline
specifier|const
name|std
operator|::
name|vector
operator|<
name|BasicBlock
operator|*
operator|>
operator|&
name|getRoots
argument_list|()
specifier|const
block|{
return|return
name|DT
operator|->
name|getRoots
argument_list|()
return|;
block|}
specifier|inline
name|BasicBlock
operator|*
name|getRoot
argument_list|()
specifier|const
block|{
return|return
name|DT
operator|->
name|getRoot
argument_list|()
return|;
block|}
specifier|inline
name|DomTreeNode
operator|*
name|getRootNode
argument_list|()
specifier|const
block|{
return|return
name|DT
operator|->
name|getRootNode
argument_list|()
return|;
block|}
comment|/// compare - Return false if the other dominator tree matches this
comment|/// dominator tree. Otherwise return true.
specifier|inline
name|bool
name|compare
argument_list|(
argument|DominatorTree&Other
argument_list|)
specifier|const
block|{
name|DomTreeNode
operator|*
name|R
operator|=
name|getRootNode
argument_list|()
block|;
name|DomTreeNode
operator|*
name|OtherR
operator|=
name|Other
operator|.
name|getRootNode
argument_list|()
block|;
if|if
condition|(
operator|!
name|R
operator|||
operator|!
name|OtherR
operator|||
name|R
operator|->
name|getBlock
argument_list|()
operator|!=
name|OtherR
operator|->
name|getBlock
argument_list|()
condition|)
return|return
name|true
return|;
if|if
condition|(
name|DT
operator|->
name|compare
argument_list|(
name|Other
operator|.
name|getBase
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
end_decl_stmt

begin_return
return|return
name|false
return|;
end_return

begin_function_decl
unit|}    virtual
name|bool
name|runOnFunction
parameter_list|(
name|Function
modifier|&
name|F
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|virtual
name|void
name|verifyAnalysis
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|getAnalysisUsage
argument_list|(
name|AnalysisUsage
operator|&
name|AU
argument_list|)
decl|const
block|{
name|AU
operator|.
name|setPreservesAll
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|inline
name|bool
name|dominates
argument_list|(
specifier|const
name|DomTreeNode
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNode
operator|*
name|B
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|inline
name|bool
name|dominates
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|A
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|B
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|dominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// dominates - Return true if Def dominates a use in User. This performs
end_comment

begin_comment
comment|// the special checks necessary if Def and User are in the same basic block.
end_comment

begin_comment
comment|// Note that Def doesn't dominate a use in Def itself!
end_comment

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|Instruction
operator|*
name|Def
argument_list|,
specifier|const
name|Use
operator|&
name|U
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|Instruction
operator|*
name|Def
argument_list|,
specifier|const
name|Instruction
operator|*
name|User
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|Instruction
operator|*
name|Def
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|BasicBlockEdge
operator|&
name|BBE
argument_list|,
specifier|const
name|Use
operator|&
name|U
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|dominates
argument_list|(
specifier|const
name|BasicBlockEdge
operator|&
name|BBE
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|properlyDominates
argument_list|(
specifier|const
name|DomTreeNode
operator|*
name|A
argument_list|,
specifier|const
name|DomTreeNode
operator|*
name|B
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|properlyDominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|properlyDominates
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|A
argument_list|,
specifier|const
name|BasicBlock
operator|*
name|B
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|properlyDominates
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// findNearestCommonDominator - Find nearest common dominator basic block
end_comment

begin_comment
comment|/// for basic block A and B. If there is no such block then return NULL.
end_comment

begin_function
specifier|inline
name|BasicBlock
modifier|*
name|findNearestCommonDominator
parameter_list|(
name|BasicBlock
modifier|*
name|A
parameter_list|,
name|BasicBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|DT
operator|->
name|findNearestCommonDominator
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
specifier|const
name|BasicBlock
modifier|*
name|findNearestCommonDominator
parameter_list|(
specifier|const
name|BasicBlock
modifier|*
name|A
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|DT
operator|->
name|findNearestCommonDominator
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|inline
name|DomTreeNode
modifier|*
name|operator
index|[]
argument_list|(
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|getNode
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getNode - return the (Post)DominatorTree node for the specified basic
end_comment

begin_comment
comment|/// block.  This is the same as using operator[] on this class.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
specifier|inline
name|DomTreeNode
modifier|*
name|getNode
argument_list|(
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|getNode
argument_list|(
name|BB
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// addNewBlock - Add a new node to the dominator tree information.  This
end_comment

begin_comment
comment|/// creates a new node as a child of DomBB dominator node,linking it into
end_comment

begin_comment
comment|/// the children list of the immediate dominator.
end_comment

begin_function
specifier|inline
name|DomTreeNode
modifier|*
name|addNewBlock
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|BasicBlock
modifier|*
name|DomBB
parameter_list|)
block|{
return|return
name|DT
operator|->
name|addNewBlock
argument_list|(
name|BB
argument_list|,
name|DomBB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// changeImmediateDominator - This method is used to update the dominator
end_comment

begin_comment
comment|/// tree information when a node's immediate dominator changes.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|inline
name|void
name|changeImmediateDominator
parameter_list|(
name|BasicBlock
modifier|*
name|N
parameter_list|,
name|BasicBlock
modifier|*
name|NewIDom
parameter_list|)
block|{
name|DT
operator|->
name|changeImmediateDominator
argument_list|(
name|N
argument_list|,
name|NewIDom
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|changeImmediateDominator
parameter_list|(
name|DomTreeNode
modifier|*
name|N
parameter_list|,
name|DomTreeNode
modifier|*
name|NewIDom
parameter_list|)
block|{
name|DT
operator|->
name|changeImmediateDominator
argument_list|(
name|N
argument_list|,
name|NewIDom
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// eraseNode - Removes a node from the dominator tree. Block must not
end_comment

begin_comment
comment|/// dominate any other blocks. Removes node from its immediate dominator's
end_comment

begin_comment
comment|/// children list. Deletes dominator node associated with basic block BB.
end_comment

begin_function
specifier|inline
name|void
name|eraseNode
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|DT
operator|->
name|eraseNode
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// splitBlock - BB is split and now it has one successor. Update dominator
end_comment

begin_comment
comment|/// tree to reflect this change.
end_comment

begin_function
specifier|inline
name|void
name|splitBlock
parameter_list|(
name|BasicBlock
modifier|*
name|NewBB
parameter_list|)
block|{
name|DT
operator|->
name|splitBlock
argument_list|(
name|NewBB
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|A
argument_list|)
decl|const
block|{
return|return
name|DT
operator|->
name|isReachableFromEntry
argument_list|(
name|A
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isReachableFromEntry
argument_list|(
specifier|const
name|Use
operator|&
name|U
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function
name|virtual
name|void
name|releaseMemory
parameter_list|()
block|{
name|DT
operator|->
name|releaseMemory
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|virtual
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|Module
operator|*
name|M
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|//===-------------------------------------
end_comment

begin_comment
comment|/// DominatorTree GraphTraits specialization so the DominatorTree can be
end_comment

begin_comment
comment|/// iterable by generic graph iterators.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|DomTreeNode
operator|*
operator|>
block|{
typedef|typedef
name|DomTreeNode
name|NodeType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|NodeType
operator|::
name|iterator
name|ChildIteratorType
expr_stmt|;
end_typedef

begin_function
specifier|static
name|NodeType
modifier|*
name|getEntryNode
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_begin
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ChildIteratorType
name|child_end
parameter_list|(
name|NodeType
modifier|*
name|N
parameter_list|)
block|{
return|return
name|N
operator|->
name|end
argument_list|()
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|df_iterator
operator|<
name|DomTreeNode
operator|*
operator|>
name|nodes_iterator
expr_stmt|;
end_typedef

begin_function
specifier|static
name|nodes_iterator
name|nodes_begin
parameter_list|(
name|DomTreeNode
modifier|*
name|N
parameter_list|)
block|{
return|return
name|df_begin
argument_list|(
name|getEntryNode
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|nodes_iterator
name|nodes_end
parameter_list|(
name|DomTreeNode
modifier|*
name|N
parameter_list|)
block|{
return|return
name|df_end
argument_list|(
name|getEntryNode
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|GraphTraits
operator|<
name|DominatorTree
operator|*
operator|>
operator|:
name|public
name|GraphTraits
operator|<
name|DomTreeNode
operator|*
operator|>
block|{
specifier|static
name|NodeType
operator|*
name|getEntryNode
argument_list|(
argument|DominatorTree *DT
argument_list|)
block|{
return|return
name|DT
operator|->
name|getRootNode
argument_list|()
return|;
block|}
specifier|static
name|nodes_iterator
name|nodes_begin
argument_list|(
argument|DominatorTree *N
argument_list|)
block|{
return|return
name|df_begin
argument_list|(
name|getEntryNode
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|nodes_iterator
name|nodes_end
parameter_list|(
name|DominatorTree
modifier|*
name|N
parameter_list|)
block|{
return|return
name|df_end
argument_list|(
name|getEntryNode
argument_list|(
name|N
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};   }
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

