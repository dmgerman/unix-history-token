begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Target/TargetCallingConv.h - Calling Convention ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines types for working with calling-convention information.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TARGET_TARGETCALLINGCONV_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TARGET_TARGETCALLINGCONV_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|ISD
block|{
struct|struct
name|ArgFlagsTy
block|{
name|private
label|:
specifier|static
specifier|const
name|uint64_t
name|NoFlagSet
init|=
literal|0ULL
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|ZExt
init|=
literal|1ULL
operator|<<
literal|0
decl_stmt|;
comment|///< Zero extended
specifier|static
specifier|const
name|uint64_t
name|ZExtOffs
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SExt
init|=
literal|1ULL
operator|<<
literal|1
decl_stmt|;
comment|///< Sign extended
specifier|static
specifier|const
name|uint64_t
name|SExtOffs
init|=
literal|1
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|InReg
init|=
literal|1ULL
operator|<<
literal|2
decl_stmt|;
comment|///< Passed in register
specifier|static
specifier|const
name|uint64_t
name|InRegOffs
init|=
literal|2
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SRet
init|=
literal|1ULL
operator|<<
literal|3
decl_stmt|;
comment|///< Hidden struct-ret ptr
specifier|static
specifier|const
name|uint64_t
name|SRetOffs
init|=
literal|3
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|ByVal
init|=
literal|1ULL
operator|<<
literal|4
decl_stmt|;
comment|///< Struct passed by value
specifier|static
specifier|const
name|uint64_t
name|ByValOffs
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|Nest
init|=
literal|1ULL
operator|<<
literal|5
decl_stmt|;
comment|///< Nested fn static chain
specifier|static
specifier|const
name|uint64_t
name|NestOffs
init|=
literal|5
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|Returned
init|=
literal|1ULL
operator|<<
literal|6
decl_stmt|;
comment|///< Always returned
specifier|static
specifier|const
name|uint64_t
name|ReturnedOffs
init|=
literal|6
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|ByValAlign
init|=
literal|0xFULL
operator|<<
literal|7
decl_stmt|;
comment|///< Struct alignment
specifier|static
specifier|const
name|uint64_t
name|ByValAlignOffs
init|=
literal|7
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|Split
init|=
literal|1ULL
operator|<<
literal|11
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SplitOffs
init|=
literal|11
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|InAlloca
init|=
literal|1ULL
operator|<<
literal|12
decl_stmt|;
comment|///< Passed with inalloca
specifier|static
specifier|const
name|uint64_t
name|InAllocaOffs
init|=
literal|12
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SplitEnd
init|=
literal|1ULL
operator|<<
literal|13
decl_stmt|;
comment|///< Last part of a split
specifier|static
specifier|const
name|uint64_t
name|SplitEndOffs
init|=
literal|13
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SwiftSelf
init|=
literal|1ULL
operator|<<
literal|14
decl_stmt|;
comment|///< Swift self parameter
specifier|static
specifier|const
name|uint64_t
name|SwiftSelfOffs
init|=
literal|14
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SwiftError
init|=
literal|1ULL
operator|<<
literal|15
decl_stmt|;
comment|///< Swift error parameter
specifier|static
specifier|const
name|uint64_t
name|SwiftErrorOffs
init|=
literal|15
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|Hva
init|=
literal|1ULL
operator|<<
literal|16
decl_stmt|;
comment|///< HVA field for
comment|///< vectorcall
specifier|static
specifier|const
name|uint64_t
name|HvaOffs
init|=
literal|16
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|HvaStart
init|=
literal|1ULL
operator|<<
literal|17
decl_stmt|;
comment|///< HVA structure start
comment|///< for vectorcall
specifier|static
specifier|const
name|uint64_t
name|HvaStartOffs
init|=
literal|17
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|SecArgPass
init|=
literal|1ULL
operator|<<
literal|18
decl_stmt|;
comment|///< Second argument
comment|///< pass for vectorcall
specifier|static
specifier|const
name|uint64_t
name|SecArgPassOffs
init|=
literal|18
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|OrigAlign
init|=
literal|0x1FULL
operator|<<
literal|27
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|OrigAlignOffs
init|=
literal|27
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|ByValSize
init|=
literal|0x3fffffffULL
operator|<<
literal|32
decl_stmt|;
comment|///< Struct size
specifier|static
specifier|const
name|uint64_t
name|ByValSizeOffs
init|=
literal|32
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|InConsecutiveRegsLast
init|=
literal|0x1ULL
operator|<<
literal|62
decl_stmt|;
comment|///< Struct size
specifier|static
specifier|const
name|uint64_t
name|InConsecutiveRegsLastOffs
init|=
literal|62
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|InConsecutiveRegs
init|=
literal|0x1ULL
operator|<<
literal|63
decl_stmt|;
comment|///< Struct size
specifier|static
specifier|const
name|uint64_t
name|InConsecutiveRegsOffs
init|=
literal|63
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|One
init|=
literal|1ULL
decl_stmt|;
comment|///< 1 of this type, for shifts
name|uint64_t
name|Flags
decl_stmt|;
name|public
label|:
name|ArgFlagsTy
argument_list|()
operator|:
name|Flags
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|isZExt
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|ZExt
return|;
block|}
name|void
name|setZExt
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|ZExtOffs
expr_stmt|;
block|}
name|bool
name|isSExt
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SExt
return|;
block|}
name|void
name|setSExt
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SExtOffs
expr_stmt|;
block|}
name|bool
name|isInReg
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|InReg
return|;
block|}
name|void
name|setInReg
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|InRegOffs
expr_stmt|;
block|}
name|bool
name|isSRet
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SRet
return|;
block|}
name|void
name|setSRet
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SRetOffs
expr_stmt|;
block|}
name|bool
name|isByVal
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|ByVal
return|;
block|}
name|void
name|setByVal
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|ByValOffs
expr_stmt|;
block|}
name|bool
name|isInAlloca
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|InAlloca
return|;
block|}
name|void
name|setInAlloca
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|InAllocaOffs
expr_stmt|;
block|}
name|bool
name|isSwiftSelf
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SwiftSelf
return|;
block|}
name|void
name|setSwiftSelf
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SwiftSelfOffs
expr_stmt|;
block|}
name|bool
name|isSwiftError
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SwiftError
return|;
block|}
name|void
name|setSwiftError
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SwiftErrorOffs
expr_stmt|;
block|}
name|bool
name|isHva
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|Hva
return|;
block|}
name|void
name|setHva
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|HvaOffs
expr_stmt|;
block|}
name|bool
name|isHvaStart
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|HvaStart
return|;
block|}
name|void
name|setHvaStart
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|HvaStartOffs
expr_stmt|;
block|}
name|bool
name|isSecArgPass
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SecArgPass
return|;
block|}
name|void
name|setSecArgPass
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SecArgPassOffs
expr_stmt|;
block|}
name|bool
name|isNest
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|Nest
return|;
block|}
name|void
name|setNest
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|NestOffs
expr_stmt|;
block|}
name|bool
name|isReturned
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|Returned
return|;
block|}
name|void
name|setReturned
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|ReturnedOffs
expr_stmt|;
block|}
name|bool
name|isInConsecutiveRegs
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|InConsecutiveRegs
return|;
block|}
name|void
name|setInConsecutiveRegs
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|InConsecutiveRegsOffs
expr_stmt|;
block|}
name|bool
name|isInConsecutiveRegsLast
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|InConsecutiveRegsLast
return|;
block|}
name|void
name|setInConsecutiveRegsLast
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|InConsecutiveRegsLastOffs
expr_stmt|;
block|}
name|unsigned
name|getByValAlign
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|One
operator|<<
operator|(
operator|(
name|Flags
operator|&
name|ByValAlign
operator|)
operator|>>
name|ByValAlignOffs
operator|)
operator|)
operator|/
literal|2
argument_list|)
return|;
block|}
name|void
name|setByValAlign
parameter_list|(
name|unsigned
name|A
parameter_list|)
block|{
name|Flags
operator|=
operator|(
name|Flags
operator|&
operator|~
name|ByValAlign
operator|)
operator||
operator|(
name|uint64_t
argument_list|(
name|Log2_32
argument_list|(
name|A
argument_list|)
operator|+
literal|1
argument_list|)
operator|<<
name|ByValAlignOffs
operator|)
expr_stmt|;
block|}
name|bool
name|isSplit
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|Split
return|;
block|}
name|void
name|setSplit
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SplitOffs
expr_stmt|;
block|}
name|bool
name|isSplitEnd
argument_list|()
specifier|const
block|{
return|return
name|Flags
operator|&
name|SplitEnd
return|;
block|}
name|void
name|setSplitEnd
parameter_list|()
block|{
name|Flags
operator||=
name|One
operator|<<
name|SplitEndOffs
expr_stmt|;
block|}
name|unsigned
name|getOrigAlign
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|One
operator|<<
operator|(
operator|(
name|Flags
operator|&
name|OrigAlign
operator|)
operator|>>
name|OrigAlignOffs
operator|)
operator|)
operator|/
literal|2
argument_list|)
return|;
block|}
name|void
name|setOrigAlign
parameter_list|(
name|unsigned
name|A
parameter_list|)
block|{
name|Flags
operator|=
operator|(
name|Flags
operator|&
operator|~
name|OrigAlign
operator|)
operator||
operator|(
name|uint64_t
argument_list|(
name|Log2_32
argument_list|(
name|A
argument_list|)
operator|+
literal|1
argument_list|)
operator|<<
name|OrigAlignOffs
operator|)
expr_stmt|;
block|}
name|unsigned
name|getByValSize
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|Flags
operator|&
name|ByValSize
operator|)
operator|>>
name|ByValSizeOffs
argument_list|)
return|;
block|}
name|void
name|setByValSize
parameter_list|(
name|unsigned
name|S
parameter_list|)
block|{
name|Flags
operator|=
operator|(
name|Flags
operator|&
operator|~
name|ByValSize
operator|)
operator||
operator|(
name|uint64_t
argument_list|(
name|S
argument_list|)
operator|<<
name|ByValSizeOffs
operator|)
expr_stmt|;
block|}
comment|/// getRawBits - Represent the flags as a bunch of bits.
name|uint64_t
name|getRawBits
argument_list|()
specifier|const
block|{
return|return
name|Flags
return|;
block|}
block|}
struct|;
comment|/// InputArg - This struct carries flags and type information about a
comment|/// single incoming (formal) argument or incoming (from the perspective
comment|/// of the caller) return value virtual register.
comment|///
struct|struct
name|InputArg
block|{
name|ArgFlagsTy
name|Flags
decl_stmt|;
name|MVT
name|VT
decl_stmt|;
name|EVT
name|ArgVT
decl_stmt|;
name|bool
name|Used
decl_stmt|;
comment|/// Index original Function's argument.
name|unsigned
name|OrigArgIndex
decl_stmt|;
comment|/// Sentinel value for implicit machine-level input arguments.
specifier|static
specifier|const
name|unsigned
name|NoArgIndex
init|=
name|UINT_MAX
decl_stmt|;
comment|/// Offset in bytes of current input value relative to the beginning of
comment|/// original argument. E.g. if argument was splitted into four 32 bit
comment|/// registers, we got 4 InputArgs with PartOffsets 0, 4, 8 and 12.
name|unsigned
name|PartOffset
decl_stmt|;
name|InputArg
argument_list|()
operator|:
name|VT
argument_list|(
name|MVT
operator|::
name|Other
argument_list|)
operator|,
name|Used
argument_list|(
argument|false
argument_list|)
block|{}
name|InputArg
argument_list|(
argument|ArgFlagsTy flags
argument_list|,
argument|EVT vt
argument_list|,
argument|EVT argvt
argument_list|,
argument|bool used
argument_list|,
argument|unsigned origIdx
argument_list|,
argument|unsigned partOffs
argument_list|)
operator|:
name|Flags
argument_list|(
name|flags
argument_list|)
operator|,
name|Used
argument_list|(
name|used
argument_list|)
operator|,
name|OrigArgIndex
argument_list|(
name|origIdx
argument_list|)
operator|,
name|PartOffset
argument_list|(
argument|partOffs
argument_list|)
block|{
name|VT
operator|=
name|vt
operator|.
name|getSimpleVT
argument_list|()
block|;
name|ArgVT
operator|=
name|argvt
block|;     }
name|bool
name|isOrigArg
argument_list|()
specifier|const
block|{
return|return
name|OrigArgIndex
operator|!=
name|NoArgIndex
return|;
block|}
name|unsigned
name|getOrigArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|OrigArgIndex
operator|!=
name|NoArgIndex
operator|&&
literal|"Implicit machine-level argument"
argument_list|)
block|;
return|return
name|OrigArgIndex
return|;
block|}
block|}
struct|;
comment|/// OutputArg - This struct carries flags and a value for a
comment|/// single outgoing (actual) argument or outgoing (from the perspective
comment|/// of the caller) return value virtual register.
comment|///
struct|struct
name|OutputArg
block|{
name|ArgFlagsTy
name|Flags
decl_stmt|;
name|MVT
name|VT
decl_stmt|;
name|EVT
name|ArgVT
decl_stmt|;
comment|/// IsFixed - Is this a "fixed" value, ie not passed through a vararg "...".
name|bool
name|IsFixed
decl_stmt|;
comment|/// Index original Function's argument.
name|unsigned
name|OrigArgIndex
decl_stmt|;
comment|/// Offset in bytes of current output value relative to the beginning of
comment|/// original argument. E.g. if argument was splitted into four 32 bit
comment|/// registers, we got 4 OutputArgs with PartOffsets 0, 4, 8 and 12.
name|unsigned
name|PartOffset
decl_stmt|;
name|OutputArg
argument_list|()
operator|:
name|IsFixed
argument_list|(
argument|false
argument_list|)
block|{}
name|OutputArg
argument_list|(
argument|ArgFlagsTy flags
argument_list|,
argument|EVT vt
argument_list|,
argument|EVT argvt
argument_list|,
argument|bool isfixed
argument_list|,
argument|unsigned origIdx
argument_list|,
argument|unsigned partOffs
argument_list|)
operator|:
name|Flags
argument_list|(
name|flags
argument_list|)
operator|,
name|IsFixed
argument_list|(
name|isfixed
argument_list|)
operator|,
name|OrigArgIndex
argument_list|(
name|origIdx
argument_list|)
operator|,
name|PartOffset
argument_list|(
argument|partOffs
argument_list|)
block|{
name|VT
operator|=
name|vt
operator|.
name|getSimpleVT
argument_list|()
block|;
name|ArgVT
operator|=
name|argvt
block|;     }
block|}
struct|;
block|}
comment|// end namespace ISD
block|}
end_decl_stmt

begin_comment
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TARGET_TARGETCALLINGCONV_H
end_comment

end_unit

