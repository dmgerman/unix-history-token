begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- llvm/Target/TargetCallingConv.h - Calling Convention ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines types for working with calling-convention information.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TARGET_TARGETCALLINGCONV_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TARGET_TARGETCALLINGCONV_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/MachineValueType.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|ISD
block|{
struct|struct
name|ArgFlagsTy
block|{
name|private
label|:
name|unsigned
name|IsZExt
range|:
literal|1
decl_stmt|;
comment|///< Zero extended
name|unsigned
name|IsSExt
range|:
literal|1
decl_stmt|;
comment|///< Sign extended
name|unsigned
name|IsInReg
range|:
literal|1
decl_stmt|;
comment|///< Passed in register
name|unsigned
name|IsSRet
range|:
literal|1
decl_stmt|;
comment|///< Hidden struct-ret ptr
name|unsigned
name|IsByVal
range|:
literal|1
decl_stmt|;
comment|///< Struct passed by value
name|unsigned
name|IsNest
range|:
literal|1
decl_stmt|;
comment|///< Nested fn static chain
name|unsigned
name|IsReturned
range|:
literal|1
decl_stmt|;
comment|///< Always returned
name|unsigned
name|IsSplit
range|:
literal|1
decl_stmt|;
name|unsigned
name|IsInAlloca
range|:
literal|1
decl_stmt|;
comment|///< Passed with inalloca
name|unsigned
name|IsSplitEnd
range|:
literal|1
decl_stmt|;
comment|///< Last part of a split
name|unsigned
name|IsSwiftSelf
range|:
literal|1
decl_stmt|;
comment|///< Swift self parameter
name|unsigned
name|IsSwiftError
range|:
literal|1
decl_stmt|;
comment|///< Swift error parameter
name|unsigned
name|IsHva
range|:
literal|1
decl_stmt|;
comment|///< HVA field for
name|unsigned
name|IsHvaStart
range|:
literal|1
decl_stmt|;
comment|///< HVA structure start
name|unsigned
name|IsSecArgPass
range|:
literal|1
decl_stmt|;
comment|///< Second argument
name|unsigned
name|ByValAlign
range|:
literal|4
decl_stmt|;
comment|///< Log 2 of byval alignment
name|unsigned
name|OrigAlign
range|:
literal|5
decl_stmt|;
comment|///< Log 2 of original alignment
name|unsigned
name|IsInConsecutiveRegsLast
range|:
literal|1
decl_stmt|;
name|unsigned
name|IsInConsecutiveRegs
range|:
literal|1
decl_stmt|;
name|unsigned
name|IsCopyElisionCandidate
range|:
literal|1
decl_stmt|;
comment|///< Argument copy elision candidate
name|unsigned
name|ByValSize
decl_stmt|;
comment|///< Byval struct size
name|public
label|:
name|ArgFlagsTy
argument_list|()
operator|:
name|IsZExt
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSExt
argument_list|(
literal|0
argument_list|)
operator|,
name|IsInReg
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSRet
argument_list|(
literal|0
argument_list|)
operator|,
name|IsByVal
argument_list|(
literal|0
argument_list|)
operator|,
name|IsNest
argument_list|(
literal|0
argument_list|)
operator|,
name|IsReturned
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSplit
argument_list|(
literal|0
argument_list|)
operator|,
name|IsInAlloca
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSplitEnd
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSwiftSelf
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSwiftError
argument_list|(
literal|0
argument_list|)
operator|,
name|IsHva
argument_list|(
literal|0
argument_list|)
operator|,
name|IsHvaStart
argument_list|(
literal|0
argument_list|)
operator|,
name|IsSecArgPass
argument_list|(
literal|0
argument_list|)
operator|,
name|ByValAlign
argument_list|(
literal|0
argument_list|)
operator|,
name|OrigAlign
argument_list|(
literal|0
argument_list|)
operator|,
name|IsInConsecutiveRegsLast
argument_list|(
literal|0
argument_list|)
operator|,
name|IsInConsecutiveRegs
argument_list|(
literal|0
argument_list|)
operator|,
name|IsCopyElisionCandidate
argument_list|(
literal|0
argument_list|)
operator|,
name|ByValSize
argument_list|(
literal|0
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|,
literal|"flags are too big"
argument_list|)
block|;     }
name|bool
name|isZExt
argument_list|()
specifier|const
block|{
return|return
name|IsZExt
return|;
block|}
name|void
name|setZExt
parameter_list|()
block|{
name|IsZExt
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSExt
argument_list|()
specifier|const
block|{
return|return
name|IsSExt
return|;
block|}
name|void
name|setSExt
parameter_list|()
block|{
name|IsSExt
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isInReg
argument_list|()
specifier|const
block|{
return|return
name|IsInReg
return|;
block|}
name|void
name|setInReg
parameter_list|()
block|{
name|IsInReg
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSRet
argument_list|()
specifier|const
block|{
return|return
name|IsSRet
return|;
block|}
name|void
name|setSRet
parameter_list|()
block|{
name|IsSRet
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isByVal
argument_list|()
specifier|const
block|{
return|return
name|IsByVal
return|;
block|}
name|void
name|setByVal
parameter_list|()
block|{
name|IsByVal
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isInAlloca
argument_list|()
specifier|const
block|{
return|return
name|IsInAlloca
return|;
block|}
name|void
name|setInAlloca
parameter_list|()
block|{
name|IsInAlloca
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSwiftSelf
argument_list|()
specifier|const
block|{
return|return
name|IsSwiftSelf
return|;
block|}
name|void
name|setSwiftSelf
parameter_list|()
block|{
name|IsSwiftSelf
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSwiftError
argument_list|()
specifier|const
block|{
return|return
name|IsSwiftError
return|;
block|}
name|void
name|setSwiftError
parameter_list|()
block|{
name|IsSwiftError
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isHva
argument_list|()
specifier|const
block|{
return|return
name|IsHva
return|;
block|}
name|void
name|setHva
parameter_list|()
block|{
name|IsHva
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isHvaStart
argument_list|()
specifier|const
block|{
return|return
name|IsHvaStart
return|;
block|}
name|void
name|setHvaStart
parameter_list|()
block|{
name|IsHvaStart
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSecArgPass
argument_list|()
specifier|const
block|{
return|return
name|IsSecArgPass
return|;
block|}
name|void
name|setSecArgPass
parameter_list|()
block|{
name|IsSecArgPass
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isNest
argument_list|()
specifier|const
block|{
return|return
name|IsNest
return|;
block|}
name|void
name|setNest
parameter_list|()
block|{
name|IsNest
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isReturned
argument_list|()
specifier|const
block|{
return|return
name|IsReturned
return|;
block|}
name|void
name|setReturned
parameter_list|()
block|{
name|IsReturned
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isInConsecutiveRegs
argument_list|()
specifier|const
block|{
return|return
name|IsInConsecutiveRegs
return|;
block|}
name|void
name|setInConsecutiveRegs
parameter_list|()
block|{
name|IsInConsecutiveRegs
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isInConsecutiveRegsLast
argument_list|()
specifier|const
block|{
return|return
name|IsInConsecutiveRegsLast
return|;
block|}
name|void
name|setInConsecutiveRegsLast
parameter_list|()
block|{
name|IsInConsecutiveRegsLast
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSplit
argument_list|()
specifier|const
block|{
return|return
name|IsSplit
return|;
block|}
name|void
name|setSplit
parameter_list|()
block|{
name|IsSplit
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isSplitEnd
argument_list|()
specifier|const
block|{
return|return
name|IsSplitEnd
return|;
block|}
name|void
name|setSplitEnd
parameter_list|()
block|{
name|IsSplitEnd
operator|=
literal|1
expr_stmt|;
block|}
name|bool
name|isCopyElisionCandidate
argument_list|()
specifier|const
block|{
return|return
name|IsCopyElisionCandidate
return|;
block|}
name|void
name|setCopyElisionCandidate
parameter_list|()
block|{
name|IsCopyElisionCandidate
operator|=
literal|1
expr_stmt|;
block|}
name|unsigned
name|getByValAlign
argument_list|()
specifier|const
block|{
return|return
operator|(
literal|1U
operator|<<
name|ByValAlign
operator|)
operator|/
literal|2
return|;
block|}
name|void
name|setByValAlign
parameter_list|(
name|unsigned
name|A
parameter_list|)
block|{
name|ByValAlign
operator|=
name|Log2_32
argument_list|(
name|A
argument_list|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|getByValAlign
argument_list|()
operator|==
name|A
operator|&&
literal|"bitfield overflow"
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|getOrigAlign
argument_list|()
specifier|const
block|{
return|return
operator|(
literal|1U
operator|<<
name|OrigAlign
operator|)
operator|/
literal|2
return|;
block|}
name|void
name|setOrigAlign
parameter_list|(
name|unsigned
name|A
parameter_list|)
block|{
name|OrigAlign
operator|=
name|Log2_32
argument_list|(
name|A
argument_list|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|getOrigAlign
argument_list|()
operator|==
name|A
operator|&&
literal|"bitfield overflow"
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|getByValSize
argument_list|()
specifier|const
block|{
return|return
name|ByValSize
return|;
block|}
name|void
name|setByValSize
parameter_list|(
name|unsigned
name|S
parameter_list|)
block|{
name|ByValSize
operator|=
name|S
expr_stmt|;
block|}
block|}
struct|;
comment|/// InputArg - This struct carries flags and type information about a
comment|/// single incoming (formal) argument or incoming (from the perspective
comment|/// of the caller) return value virtual register.
comment|///
struct|struct
name|InputArg
block|{
name|ArgFlagsTy
name|Flags
decl_stmt|;
name|MVT
name|VT
init|=
name|MVT
operator|::
name|Other
decl_stmt|;
name|EVT
name|ArgVT
decl_stmt|;
name|bool
name|Used
init|=
name|false
decl_stmt|;
comment|/// Index original Function's argument.
name|unsigned
name|OrigArgIndex
decl_stmt|;
comment|/// Sentinel value for implicit machine-level input arguments.
specifier|static
specifier|const
name|unsigned
name|NoArgIndex
init|=
name|UINT_MAX
decl_stmt|;
comment|/// Offset in bytes of current input value relative to the beginning of
comment|/// original argument. E.g. if argument was splitted into four 32 bit
comment|/// registers, we got 4 InputArgs with PartOffsets 0, 4, 8 and 12.
name|unsigned
name|PartOffset
decl_stmt|;
name|InputArg
argument_list|()
operator|=
expr|default
expr_stmt|;
name|InputArg
argument_list|(
argument|ArgFlagsTy flags
argument_list|,
argument|EVT vt
argument_list|,
argument|EVT argvt
argument_list|,
argument|bool used
argument_list|,
argument|unsigned origIdx
argument_list|,
argument|unsigned partOffs
argument_list|)
block|:
name|Flags
argument_list|(
name|flags
argument_list|)
operator|,
name|Used
argument_list|(
name|used
argument_list|)
operator|,
name|OrigArgIndex
argument_list|(
name|origIdx
argument_list|)
operator|,
name|PartOffset
argument_list|(
argument|partOffs
argument_list|)
block|{
name|VT
operator|=
name|vt
operator|.
name|getSimpleVT
argument_list|()
block|;
name|ArgVT
operator|=
name|argvt
block|;     }
name|bool
name|isOrigArg
argument_list|()
specifier|const
block|{
return|return
name|OrigArgIndex
operator|!=
name|NoArgIndex
return|;
block|}
name|unsigned
name|getOrigArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|OrigArgIndex
operator|!=
name|NoArgIndex
operator|&&
literal|"Implicit machine-level argument"
argument_list|)
block|;
return|return
name|OrigArgIndex
return|;
block|}
block|}
struct|;
comment|/// OutputArg - This struct carries flags and a value for a
comment|/// single outgoing (actual) argument or outgoing (from the perspective
comment|/// of the caller) return value virtual register.
comment|///
struct|struct
name|OutputArg
block|{
name|ArgFlagsTy
name|Flags
decl_stmt|;
name|MVT
name|VT
decl_stmt|;
name|EVT
name|ArgVT
decl_stmt|;
comment|/// IsFixed - Is this a "fixed" value, ie not passed through a vararg "...".
name|bool
name|IsFixed
init|=
name|false
decl_stmt|;
comment|/// Index original Function's argument.
name|unsigned
name|OrigArgIndex
decl_stmt|;
comment|/// Offset in bytes of current output value relative to the beginning of
comment|/// original argument. E.g. if argument was splitted into four 32 bit
comment|/// registers, we got 4 OutputArgs with PartOffsets 0, 4, 8 and 12.
name|unsigned
name|PartOffset
decl_stmt|;
name|OutputArg
argument_list|()
operator|=
expr|default
expr_stmt|;
name|OutputArg
argument_list|(
argument|ArgFlagsTy flags
argument_list|,
argument|EVT vt
argument_list|,
argument|EVT argvt
argument_list|,
argument|bool isfixed
argument_list|,
argument|unsigned origIdx
argument_list|,
argument|unsigned partOffs
argument_list|)
block|:
name|Flags
argument_list|(
name|flags
argument_list|)
operator|,
name|IsFixed
argument_list|(
name|isfixed
argument_list|)
operator|,
name|OrigArgIndex
argument_list|(
name|origIdx
argument_list|)
operator|,
name|PartOffset
argument_list|(
argument|partOffs
argument_list|)
block|{
name|VT
operator|=
name|vt
operator|.
name|getSimpleVT
argument_list|()
block|;
name|ArgVT
operator|=
name|argvt
block|;     }
block|}
struct|;
block|}
comment|// end namespace ISD
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TARGET_TARGETCALLINGCONV_H
end_comment

end_unit

