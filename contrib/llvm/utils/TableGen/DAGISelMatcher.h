begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- DAGISelMatcher.h - Representation of DAG pattern matcher -----------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TBLGEN_DAGISELMATCHER_H
end_ifndef

begin_define
define|#
directive|define
name|TBLGEN_DAGISELMATCHER_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CodeGenDAGPatterns
decl_stmt|;
name|class
name|Matcher
decl_stmt|;
name|class
name|PatternToMatch
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|ComplexPattern
decl_stmt|;
name|class
name|Record
decl_stmt|;
name|class
name|SDNodeInfo
decl_stmt|;
name|Matcher
modifier|*
name|ConvertPatternToMatcher
parameter_list|(
specifier|const
name|PatternToMatch
modifier|&
name|Pattern
parameter_list|,
name|unsigned
name|Variant
parameter_list|,
specifier|const
name|CodeGenDAGPatterns
modifier|&
name|CGP
parameter_list|)
function_decl|;
name|Matcher
modifier|*
name|OptimizeMatcher
parameter_list|(
name|Matcher
modifier|*
name|Matcher
parameter_list|,
specifier|const
name|CodeGenDAGPatterns
modifier|&
name|CGP
parameter_list|)
function_decl|;
name|void
name|EmitMatcherTable
parameter_list|(
specifier|const
name|Matcher
modifier|*
name|Matcher
parameter_list|,
specifier|const
name|CodeGenDAGPatterns
modifier|&
name|CGP
parameter_list|,
name|raw_ostream
modifier|&
name|OS
parameter_list|)
function_decl|;
comment|/// Matcher - Base class for all the the DAG ISel Matcher representation
comment|/// nodes.
name|class
name|Matcher
block|{
comment|// The next matcher node that is executed after this one.  Null if this is the
comment|// last stage of a match.
name|OwningPtr
operator|<
name|Matcher
operator|>
name|Next
expr_stmt|;
name|public
label|:
enum|enum
name|KindTy
block|{
comment|// Matcher state manipulation.
name|Scope
block|,
comment|// Push a checking scope.
name|RecordNode
block|,
comment|// Record the current node.
name|RecordChild
block|,
comment|// Record a child of the current node.
name|RecordMemRef
block|,
comment|// Record the memref in the current node.
name|CaptureGlueInput
block|,
comment|// If the current node has an input glue, save it.
name|MoveChild
block|,
comment|// Move current node to specified child.
name|MoveParent
block|,
comment|// Move current node to parent.
comment|// Predicate checking.
name|CheckSame
block|,
comment|// Fail if not same as prev match.
name|CheckPatternPredicate
block|,
name|CheckPredicate
block|,
comment|// Fail if node predicate fails.
name|CheckOpcode
block|,
comment|// Fail if not opcode.
name|SwitchOpcode
block|,
comment|// Dispatch based on opcode.
name|CheckType
block|,
comment|// Fail if not correct type.
name|SwitchType
block|,
comment|// Dispatch based on type.
name|CheckChildType
block|,
comment|// Fail if child has wrong type.
name|CheckInteger
block|,
comment|// Fail if wrong val.
name|CheckCondCode
block|,
comment|// Fail if not condcode.
name|CheckValueType
block|,
name|CheckComplexPat
block|,
name|CheckAndImm
block|,
name|CheckOrImm
block|,
name|CheckFoldableChainNode
block|,
comment|// Node creation/emisssion.
name|EmitInteger
block|,
comment|// Create a TargetConstant
name|EmitStringInteger
block|,
comment|// Create a TargetConstant from a string.
name|EmitRegister
block|,
comment|// Create a register.
name|EmitConvertToTarget
block|,
comment|// Convert a imm/fpimm to target imm/fpimm
name|EmitMergeInputChains
block|,
comment|// Merge together a chains for an input.
name|EmitCopyToReg
block|,
comment|// Emit a copytoreg into a physreg.
name|EmitNode
block|,
comment|// Create a DAG node
name|EmitNodeXForm
block|,
comment|// Run a SDNodeXForm
name|MarkGlueResults
block|,
comment|// Indicate which interior nodes have glue results.
name|CompleteMatch
block|,
comment|// Finish a match and update the results.
name|MorphNodeTo
comment|// Build a node, finish a match and update results.
block|}
enum|;
specifier|const
name|KindTy
name|Kind
decl_stmt|;
name|protected
label|:
name|Matcher
argument_list|(
argument|KindTy K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|public
label|:
name|virtual
operator|~
name|Matcher
argument_list|()
block|{}
name|KindTy
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|Matcher
modifier|*
name|getNext
parameter_list|()
block|{
return|return
name|Next
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|Matcher
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|Next
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|setNext
parameter_list|(
name|Matcher
modifier|*
name|C
parameter_list|)
block|{
name|Next
operator|.
name|reset
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
name|Matcher
modifier|*
name|takeNext
parameter_list|()
block|{
return|return
name|Next
operator|.
name|take
argument_list|()
return|;
block|}
name|OwningPtr
operator|<
name|Matcher
operator|>
operator|&
name|getNextPtr
argument_list|()
block|{
return|return
name|Next
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|Matcher
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|bool
name|isEqual
argument_list|(
specifier|const
name|Matcher
operator|*
name|M
argument_list|)
decl|const
block|{
if|if
condition|(
name|getKind
argument_list|()
operator|!=
name|M
operator|->
name|getKind
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|isEqualImpl
argument_list|(
name|M
argument_list|)
return|;
block|}
name|unsigned
name|getHash
argument_list|()
specifier|const
block|{
comment|// Clear the high bit so we don't conflict with tombstones etc.
return|return
operator|(
operator|(
name|getHashImpl
argument_list|()
operator|<<
literal|4
operator|)
operator|^
name|getKind
argument_list|()
operator|)
operator|&
operator|(
operator|~
literal|0U
operator|>>
literal|1
operator|)
return|;
block|}
comment|/// isSafeToReorderWithPatternPredicate - Return true if it is safe to sink a
comment|/// PatternPredicate node past this one.
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// isSimplePredicateNode - Return true if this is a simple predicate that
comment|/// operates on the node or its children without potential side effects or a
comment|/// change of the current node.
name|bool
name|isSimplePredicateNode
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|CheckSame
case|:
case|case
name|CheckPatternPredicate
case|:
case|case
name|CheckPredicate
case|:
case|case
name|CheckOpcode
case|:
case|case
name|CheckType
case|:
case|case
name|CheckChildType
case|:
case|case
name|CheckInteger
case|:
case|case
name|CheckCondCode
case|:
case|case
name|CheckValueType
case|:
case|case
name|CheckAndImm
case|:
case|case
name|CheckOrImm
case|:
case|case
name|CheckFoldableChainNode
case|:
return|return
name|true
return|;
block|}
block|}
comment|/// isSimplePredicateOrRecordNode - Return true if this is a record node or
comment|/// a simple predicate.
name|bool
name|isSimplePredicateOrRecordNode
argument_list|()
specifier|const
block|{
return|return
name|isSimplePredicateNode
argument_list|()
operator|||
name|getKind
argument_list|()
operator|==
name|RecordNode
operator|||
name|getKind
argument_list|()
operator|==
name|RecordChild
return|;
block|}
comment|/// unlinkNode - Unlink the specified node from this chain.  If Other == this,
comment|/// we unlink the next pointer and return it.  Otherwise we unlink Other from
comment|/// the list and return this.
name|Matcher
modifier|*
name|unlinkNode
parameter_list|(
name|Matcher
modifier|*
name|Other
parameter_list|)
function_decl|;
comment|/// canMoveBefore - Return true if this matcher is the same as Other, or if
comment|/// we can move this matcher past all of the nodes in-between Other and this
comment|/// node.  Other must be equal to or before this.
name|bool
name|canMoveBefore
argument_list|(
specifier|const
name|Matcher
operator|*
name|Other
argument_list|)
decl|const
decl_stmt|;
comment|/// canMoveBefore - Return true if it is safe to move the current matcher
comment|/// across the specified one.
name|bool
name|canMoveBeforeNode
argument_list|(
specifier|const
name|Matcher
operator|*
name|Other
argument_list|)
decl|const
decl_stmt|;
comment|/// isContradictory - Return true of these two matchers could never match on
comment|/// the same node.
name|bool
name|isContradictory
argument_list|(
specifier|const
name|Matcher
operator|*
name|Other
argument_list|)
decl|const
block|{
comment|// Since this predicate is reflexive, we canonicalize the ordering so that
comment|// we always match a node against nodes with kinds that are greater or equal
comment|// to them.  For example, we'll pass in a CheckType node as an argument to
comment|// the CheckOpcode method, not the other way around.
if|if
condition|(
name|getKind
argument_list|()
operator|<
name|Other
operator|->
name|getKind
argument_list|()
condition|)
return|return
name|isContradictoryImpl
argument_list|(
name|Other
argument_list|)
return|;
return|return
name|Other
operator|->
name|isContradictoryImpl
argument_list|(
name|this
argument_list|)
return|;
block|}
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|indent
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|void
name|printOne
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|protected
label|:
name|virtual
name|void
name|printImpl
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|indent
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
specifier|const
name|Matcher
operator|*
name|M
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|virtual
name|bool
name|isContradictoryImpl
argument_list|(
specifier|const
name|Matcher
operator|*
name|M
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
block|}
empty_stmt|;
comment|/// ScopeMatcher - This attempts to match each of its children to find the first
comment|/// one that successfully matches.  If one child fails, it tries the next child.
comment|/// If none of the children match then this check fails.  It never has a 'next'.
name|class
name|ScopeMatcher
range|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|Matcher
operator|*
block|,
literal|4
operator|>
name|Children
block|;
name|public
operator|:
name|ScopeMatcher
argument_list|(
argument|Matcher *const *children
argument_list|,
argument|unsigned numchildren
argument_list|)
operator|:
name|Matcher
argument_list|(
name|Scope
argument_list|)
block|,
name|Children
argument_list|(
argument|children
argument_list|,
argument|children+numchildren
argument_list|)
block|{   }
name|virtual
operator|~
name|ScopeMatcher
argument_list|()
block|;
name|unsigned
name|getNumChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|size
argument_list|()
return|;
block|}
name|Matcher
operator|*
name|getChild
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Children
index|[
name|i
index|]
return|;
block|}
specifier|const
name|Matcher
operator|*
name|getChild
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Children
index|[
name|i
index|]
return|;
block|}
name|void
name|resetChild
argument_list|(
argument|unsigned i
argument_list|,
argument|Matcher *N
argument_list|)
block|{
name|delete
name|Children
index|[
name|i
index|]
block|;
name|Children
index|[
name|i
index|]
operator|=
name|N
block|;   }
name|Matcher
operator|*
name|takeChild
argument_list|(
argument|unsigned i
argument_list|)
block|{
name|Matcher
operator|*
name|Res
operator|=
name|Children
index|[
name|i
index|]
block|;
name|Children
index|[
name|i
index|]
operator|=
literal|0
block|;
return|return
name|Res
return|;
block|}
name|void
name|setNumChildren
argument_list|(
argument|unsigned NC
argument_list|)
block|{
if|if
condition|(
name|NC
operator|<
name|Children
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// delete any children we're about to lose pointers to.
for|for
control|(
name|unsigned
name|i
init|=
name|NC
init|,
name|e
init|=
name|Children
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|delete
name|Children
index|[
name|i
index|]
decl_stmt|;
block|}
name|Children
operator|.
name|resize
argument_list|(
name|NC
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|Scope
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|12312
return|;
block|}
expr|}
block|;
comment|/// RecordMatcher - Save the current node in the operand list.
name|class
name|RecordMatcher
operator|:
name|public
name|Matcher
block|{
comment|/// WhatFor - This is a string indicating why we're recording this.  This
comment|/// should only be used for comment generation not anything semantic.
name|std
operator|::
name|string
name|WhatFor
block|;
comment|/// ResultNo - The slot number in the RecordedNodes vector that this will be,
comment|/// just printed as a comment.
name|unsigned
name|ResultNo
block|;
name|public
operator|:
name|RecordMatcher
argument_list|(
argument|const std::string&whatfor
argument_list|,
argument|unsigned resultNo
argument_list|)
operator|:
name|Matcher
argument_list|(
name|RecordNode
argument_list|)
block|,
name|WhatFor
argument_list|(
name|whatfor
argument_list|)
block|,
name|ResultNo
argument_list|(
argument|resultNo
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getWhatFor
argument_list|()
specifier|const
block|{
return|return
name|WhatFor
return|;
block|}
name|unsigned
name|getResultNo
argument_list|()
specifier|const
block|{
return|return
name|ResultNo
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|RecordNode
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
comment|/// RecordChildMatcher - Save a numbered child of the current node, or fail
comment|/// the match if it doesn't exist.  This is logically equivalent to:
comment|///    MoveChild N + RecordNode + MoveParent.
name|class
name|RecordChildMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|ChildNo
block|;
comment|/// WhatFor - This is a string indicating why we're recording this.  This
comment|/// should only be used for comment generation not anything semantic.
name|std
operator|::
name|string
name|WhatFor
block|;
comment|/// ResultNo - The slot number in the RecordedNodes vector that this will be,
comment|/// just printed as a comment.
name|unsigned
name|ResultNo
block|;
name|public
operator|:
name|RecordChildMatcher
argument_list|(
argument|unsigned childno
argument_list|,
argument|const std::string&whatfor
argument_list|,
argument|unsigned resultNo
argument_list|)
operator|:
name|Matcher
argument_list|(
name|RecordChild
argument_list|)
block|,
name|ChildNo
argument_list|(
name|childno
argument_list|)
block|,
name|WhatFor
argument_list|(
name|whatfor
argument_list|)
block|,
name|ResultNo
argument_list|(
argument|resultNo
argument_list|)
block|{}
name|unsigned
name|getChildNo
argument_list|()
specifier|const
block|{
return|return
name|ChildNo
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getWhatFor
argument_list|()
specifier|const
block|{
return|return
name|WhatFor
return|;
block|}
name|unsigned
name|getResultNo
argument_list|()
specifier|const
block|{
return|return
name|ResultNo
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|RecordChild
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|RecordChildMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|getChildNo
argument_list|()
operator|==
name|getChildNo
argument_list|()
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|getChildNo
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// RecordMemRefMatcher - Save the current node's memref.
name|class
name|RecordMemRefMatcher
operator|:
name|public
name|Matcher
block|{
name|public
operator|:
name|RecordMemRefMatcher
argument_list|()
operator|:
name|Matcher
argument_list|(
argument|RecordMemRef
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|RecordMemRef
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
comment|/// CaptureGlueInputMatcher - If the current record has a glue input, record
comment|/// it so that it is used as an input to the generated code.
name|class
name|CaptureGlueInputMatcher
operator|:
name|public
name|Matcher
block|{
name|public
operator|:
name|CaptureGlueInputMatcher
argument_list|()
operator|:
name|Matcher
argument_list|(
argument|CaptureGlueInput
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CaptureGlueInput
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
comment|/// MoveChildMatcher - This tells the interpreter to move into the
comment|/// specified child node.
name|class
name|MoveChildMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|ChildNo
block|;
name|public
operator|:
name|MoveChildMatcher
argument_list|(
argument|unsigned childNo
argument_list|)
operator|:
name|Matcher
argument_list|(
name|MoveChild
argument_list|)
block|,
name|ChildNo
argument_list|(
argument|childNo
argument_list|)
block|{}
name|unsigned
name|getChildNo
argument_list|()
specifier|const
block|{
return|return
name|ChildNo
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MoveChild
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|MoveChildMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|getChildNo
argument_list|()
operator|==
name|getChildNo
argument_list|()
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|getChildNo
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// MoveParentMatcher - This tells the interpreter to move to the parent
comment|/// of the current node.
name|class
name|MoveParentMatcher
operator|:
name|public
name|Matcher
block|{
name|public
operator|:
name|MoveParentMatcher
argument_list|()
operator|:
name|Matcher
argument_list|(
argument|MoveParent
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MoveParent
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
comment|/// CheckSameMatcher - This checks to see if this node is exactly the same
comment|/// node as the specified match that was recorded with 'Record'.  This is used
comment|/// when patterns have the same name in them, like '(mul GPR:$in, GPR:$in)'.
name|class
name|CheckSameMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|MatchNumber
block|;
name|public
operator|:
name|CheckSameMatcher
argument_list|(
argument|unsigned matchnumber
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckSame
argument_list|)
block|,
name|MatchNumber
argument_list|(
argument|matchnumber
argument_list|)
block|{}
name|unsigned
name|getMatchNumber
argument_list|()
specifier|const
block|{
return|return
name|MatchNumber
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckSame
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckSameMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|getMatchNumber
argument_list|()
operator|==
name|getMatchNumber
argument_list|()
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|getMatchNumber
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// CheckPatternPredicateMatcher - This checks the target-specific predicate
comment|/// to see if the entire pattern is capable of matching.  This predicate does
comment|/// not take a node as input.  This is used for subtarget feature checks etc.
name|class
name|CheckPatternPredicateMatcher
operator|:
name|public
name|Matcher
block|{
name|std
operator|::
name|string
name|Predicate
block|;
name|public
operator|:
name|CheckPatternPredicateMatcher
argument_list|(
argument|StringRef predicate
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckPatternPredicate
argument_list|)
block|,
name|Predicate
argument_list|(
argument|predicate
argument_list|)
block|{}
name|StringRef
name|getPredicate
argument_list|()
specifier|const
block|{
return|return
name|Predicate
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckPatternPredicate
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckPatternPredicateMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|getPredicate
argument_list|()
operator|==
name|Predicate
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// CheckPredicateMatcher - This checks the target-specific predicate to
comment|/// see if the node is acceptable.
name|class
name|CheckPredicateMatcher
operator|:
name|public
name|Matcher
block|{
name|StringRef
name|PredName
block|;
name|public
operator|:
name|CheckPredicateMatcher
argument_list|(
argument|StringRef predname
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckPredicate
argument_list|)
block|,
name|PredName
argument_list|(
argument|predname
argument_list|)
block|{}
name|StringRef
name|getPredicateName
argument_list|()
specifier|const
block|{
return|return
name|PredName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckPredicate
return|;
block|}
comment|// TODO: Ok?
comment|//virtual bool isSafeToReorderWithPatternPredicate() const { return true; }
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckPredicateMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|PredName
operator|==
name|PredName
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// CheckOpcodeMatcher - This checks to see if the current node has the
comment|/// specified opcode, if not it fails to match.
name|class
name|CheckOpcodeMatcher
operator|:
name|public
name|Matcher
block|{
specifier|const
name|SDNodeInfo
operator|&
name|Opcode
block|;
name|public
operator|:
name|CheckOpcodeMatcher
argument_list|(
specifier|const
name|SDNodeInfo
operator|&
name|opcode
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckOpcode
argument_list|)
block|,
name|Opcode
argument_list|(
argument|opcode
argument_list|)
block|{}
specifier|const
name|SDNodeInfo
operator|&
name|getOpcode
argument_list|()
specifier|const
block|{
return|return
name|Opcode
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckOpcode
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|;
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|isContradictoryImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|; }
block|;
comment|/// SwitchOpcodeMatcher - Switch based on the current node's opcode, dispatching
comment|/// to one matcher per opcode.  If the opcode doesn't match any of the cases,
comment|/// then the match fails.  This is semantically equivalent to a Scope node where
comment|/// every child does a CheckOpcode, but is much faster.
name|class
name|SwitchOpcodeMatcher
operator|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|SDNodeInfo
operator|*
block|,
name|Matcher
operator|*
operator|>
block|,
literal|8
operator|>
name|Cases
block|;
name|public
operator|:
name|SwitchOpcodeMatcher
argument_list|(
argument|const std::pair<const SDNodeInfo*
argument_list|,
argument|Matcher*> *cases
argument_list|,
argument|unsigned numcases
argument_list|)
operator|:
name|Matcher
argument_list|(
name|SwitchOpcode
argument_list|)
block|,
name|Cases
argument_list|(
argument|cases
argument_list|,
argument|cases+numcases
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|SwitchOpcode
return|;
block|}
name|unsigned
name|getNumCases
argument_list|()
specifier|const
block|{
return|return
name|Cases
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|SDNodeInfo
operator|&
name|getCaseOpcode
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
operator|*
name|Cases
index|[
name|i
index|]
operator|.
name|first
return|;
block|}
name|Matcher
operator|*
name|getCaseMatcher
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Cases
index|[
name|i
index|]
operator|.
name|second
return|;
block|}
specifier|const
name|Matcher
operator|*
name|getCaseMatcher
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Cases
index|[
name|i
index|]
operator|.
name|second
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|4123
return|;
block|}
expr|}
block|;
comment|/// CheckTypeMatcher - This checks to see if the current node has the
comment|/// specified type at the specified result, if not it fails to match.
name|class
name|CheckTypeMatcher
operator|:
name|public
name|Matcher
block|{
name|MVT
operator|::
name|SimpleValueType
name|Type
block|;
name|unsigned
name|ResNo
block|;
name|public
operator|:
name|CheckTypeMatcher
argument_list|(
argument|MVT::SimpleValueType type
argument_list|,
argument|unsigned resno
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckType
argument_list|)
block|,
name|Type
argument_list|(
name|type
argument_list|)
block|,
name|ResNo
argument_list|(
argument|resno
argument_list|)
block|{}
name|MVT
operator|::
name|SimpleValueType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
name|unsigned
name|getResNo
argument_list|()
specifier|const
block|{
return|return
name|ResNo
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckType
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckTypeMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Type
operator|==
name|Type
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
name|virtual
name|bool
name|isContradictoryImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|; }
block|;
comment|/// SwitchTypeMatcher - Switch based on the current node's type, dispatching
comment|/// to one matcher per case.  If the type doesn't match any of the cases,
comment|/// then the match fails.  This is semantically equivalent to a Scope node where
comment|/// every child does a CheckType, but is much faster.
name|class
name|SwitchTypeMatcher
operator|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|MVT
operator|::
name|SimpleValueType
block|,
name|Matcher
operator|*
operator|>
block|,
literal|8
operator|>
name|Cases
block|;
name|public
operator|:
name|SwitchTypeMatcher
argument_list|(
argument|const std::pair<MVT::SimpleValueType
argument_list|,
argument|Matcher*> *cases
argument_list|,
argument|unsigned numcases
argument_list|)
operator|:
name|Matcher
argument_list|(
name|SwitchType
argument_list|)
block|,
name|Cases
argument_list|(
argument|cases
argument_list|,
argument|cases+numcases
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|SwitchType
return|;
block|}
name|unsigned
name|getNumCases
argument_list|()
specifier|const
block|{
return|return
name|Cases
operator|.
name|size
argument_list|()
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getCaseType
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Cases
index|[
name|i
index|]
operator|.
name|first
return|;
block|}
name|Matcher
operator|*
name|getCaseMatcher
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Cases
index|[
name|i
index|]
operator|.
name|second
return|;
block|}
specifier|const
name|Matcher
operator|*
name|getCaseMatcher
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Cases
index|[
name|i
index|]
operator|.
name|second
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|false
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|4123
return|;
block|}
expr|}
block|;
comment|/// CheckChildTypeMatcher - This checks to see if a child node has the
comment|/// specified type, if not it fails to match.
name|class
name|CheckChildTypeMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|ChildNo
block|;
name|MVT
operator|::
name|SimpleValueType
name|Type
block|;
name|public
operator|:
name|CheckChildTypeMatcher
argument_list|(
argument|unsigned childno
argument_list|,
argument|MVT::SimpleValueType type
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckChildType
argument_list|)
block|,
name|ChildNo
argument_list|(
name|childno
argument_list|)
block|,
name|Type
argument_list|(
argument|type
argument_list|)
block|{}
name|unsigned
name|getChildNo
argument_list|()
specifier|const
block|{
return|return
name|ChildNo
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckChildType
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckChildTypeMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|ChildNo
operator|==
name|ChildNo
operator|&&
name|cast
operator|<
name|CheckChildTypeMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Type
operator|==
name|Type
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Type
operator|<<
literal|3
operator|)
operator||
name|ChildNo
return|;
block|}
name|virtual
name|bool
name|isContradictoryImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|; }
block|;
comment|/// CheckIntegerMatcher - This checks to see if the current node is a
comment|/// ConstantSDNode with the specified integer value, if not it fails to match.
name|class
name|CheckIntegerMatcher
operator|:
name|public
name|Matcher
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckIntegerMatcher
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckInteger
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckInteger
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckIntegerMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Value
operator|==
name|Value
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
name|virtual
name|bool
name|isContradictoryImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|; }
block|;
comment|/// CheckCondCodeMatcher - This checks to see if the current node is a
comment|/// CondCodeSDNode with the specified condition, if not it fails to match.
name|class
name|CheckCondCodeMatcher
operator|:
name|public
name|Matcher
block|{
name|StringRef
name|CondCodeName
block|;
name|public
operator|:
name|CheckCondCodeMatcher
argument_list|(
argument|StringRef condcodename
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckCondCode
argument_list|)
block|,
name|CondCodeName
argument_list|(
argument|condcodename
argument_list|)
block|{}
name|StringRef
name|getCondCodeName
argument_list|()
specifier|const
block|{
return|return
name|CondCodeName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckCondCode
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckCondCodeMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|CondCodeName
operator|==
name|CondCodeName
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// CheckValueTypeMatcher - This checks to see if the current node is a
comment|/// VTSDNode with the specified type, if not it fails to match.
name|class
name|CheckValueTypeMatcher
operator|:
name|public
name|Matcher
block|{
name|StringRef
name|TypeName
block|;
name|public
operator|:
name|CheckValueTypeMatcher
argument_list|(
argument|StringRef type_name
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckValueType
argument_list|)
block|,
name|TypeName
argument_list|(
argument|type_name
argument_list|)
block|{}
name|StringRef
name|getTypeName
argument_list|()
specifier|const
block|{
return|return
name|TypeName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckValueType
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckValueTypeMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|TypeName
operator|==
name|TypeName
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|;
name|bool
name|isContradictoryImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|; }
block|;
comment|/// CheckComplexPatMatcher - This node runs the specified ComplexPattern on
comment|/// the current node.
name|class
name|CheckComplexPatMatcher
operator|:
name|public
name|Matcher
block|{
specifier|const
name|ComplexPattern
operator|&
name|Pattern
block|;
comment|/// MatchNumber - This is the recorded nodes slot that contains the node we
comment|/// want to match against.
name|unsigned
name|MatchNumber
block|;
comment|/// Name - The name of the node we're matching, for comment emission.
name|std
operator|::
name|string
name|Name
block|;
comment|/// FirstResult - This is the first slot in the RecordedNodes list that the
comment|/// result of the match populates.
name|unsigned
name|FirstResult
block|;
name|public
operator|:
name|CheckComplexPatMatcher
argument_list|(
argument|const ComplexPattern&pattern
argument_list|,
argument|unsigned matchnumber
argument_list|,
argument|const std::string&name
argument_list|,
argument|unsigned firstresult
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckComplexPat
argument_list|)
block|,
name|Pattern
argument_list|(
name|pattern
argument_list|)
block|,
name|MatchNumber
argument_list|(
name|matchnumber
argument_list|)
block|,
name|Name
argument_list|(
name|name
argument_list|)
block|,
name|FirstResult
argument_list|(
argument|firstresult
argument_list|)
block|{}
specifier|const
name|ComplexPattern
operator|&
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
name|unsigned
name|getMatchNumber
argument_list|()
specifier|const
block|{
return|return
name|MatchNumber
return|;
block|}
specifier|const
name|std
operator|::
name|string
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|unsigned
name|getFirstResult
argument_list|()
specifier|const
block|{
return|return
name|FirstResult
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckComplexPat
return|;
block|}
comment|// Not safe to move a pattern predicate past a complex pattern.
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
operator|&
name|cast
operator|<
name|CheckComplexPatMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Pattern
operator|==
operator|&
name|Pattern
operator|&&
name|cast
operator|<
name|CheckComplexPatMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|MatchNumber
operator|==
name|MatchNumber
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
name|intptr_t
argument_list|)
operator|&
name|Pattern
operator|^
name|MatchNumber
return|;
block|}
expr|}
block|;
comment|/// CheckAndImmMatcher - This checks to see if the current node is an 'and'
comment|/// with something equivalent to the specified immediate.
name|class
name|CheckAndImmMatcher
operator|:
name|public
name|Matcher
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckAndImmMatcher
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckAndImm
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckAndImm
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckAndImmMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Value
operator|==
name|Value
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
expr|}
block|;
comment|/// CheckOrImmMatcher - This checks to see if the current node is an 'and'
comment|/// with something equivalent to the specified immediate.
name|class
name|CheckOrImmMatcher
operator|:
name|public
name|Matcher
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckOrImmMatcher
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CheckOrImm
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckOrImm
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CheckOrImmMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Value
operator|==
name|Value
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
expr|}
block|;
comment|/// CheckFoldableChainNodeMatcher - This checks to see if the current node
comment|/// (which defines a chain operand) is safe to fold into a larger pattern.
name|class
name|CheckFoldableChainNodeMatcher
operator|:
name|public
name|Matcher
block|{
name|public
operator|:
name|CheckFoldableChainNodeMatcher
argument_list|()
operator|:
name|Matcher
argument_list|(
argument|CheckFoldableChainNode
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckFoldableChainNode
return|;
block|}
name|virtual
name|bool
name|isSafeToReorderWithPatternPredicate
argument_list|()
specifier|const
block|{
return|return
name|true
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
expr|}
block|;
comment|/// EmitIntegerMatcher - This creates a new TargetConstant.
name|class
name|EmitIntegerMatcher
operator|:
name|public
name|Matcher
block|{
name|int64_t
name|Val
block|;
name|MVT
operator|::
name|SimpleValueType
name|VT
block|;
name|public
operator|:
name|EmitIntegerMatcher
argument_list|(
argument|int64_t val
argument_list|,
argument|MVT::SimpleValueType vt
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitInteger
argument_list|)
block|,
name|Val
argument_list|(
name|val
argument_list|)
block|,
name|VT
argument_list|(
argument|vt
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getVT
argument_list|()
specifier|const
block|{
return|return
name|VT
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitInteger
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitIntegerMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Val
operator|==
name|Val
operator|&&
name|cast
operator|<
name|EmitIntegerMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|VT
operator|==
name|VT
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Val
operator|<<
literal|4
operator|)
operator||
name|VT
return|;
block|}
expr|}
block|;
comment|/// EmitStringIntegerMatcher - A target constant whose value is represented
comment|/// by a string.
name|class
name|EmitStringIntegerMatcher
operator|:
name|public
name|Matcher
block|{
name|std
operator|::
name|string
name|Val
block|;
name|MVT
operator|::
name|SimpleValueType
name|VT
block|;
name|public
operator|:
name|EmitStringIntegerMatcher
argument_list|(
argument|const std::string&val
argument_list|,
argument|MVT::SimpleValueType vt
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitStringInteger
argument_list|)
block|,
name|Val
argument_list|(
name|val
argument_list|)
block|,
name|VT
argument_list|(
argument|vt
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getVT
argument_list|()
specifier|const
block|{
return|return
name|VT
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitStringInteger
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitStringIntegerMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Val
operator|==
name|Val
operator|&&
name|cast
operator|<
name|EmitStringIntegerMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|VT
operator|==
name|VT
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// EmitRegisterMatcher - This creates a new TargetConstant.
name|class
name|EmitRegisterMatcher
operator|:
name|public
name|Matcher
block|{
comment|/// Reg - The def for the register that we're emitting.  If this is null, then
comment|/// this is a reference to zero_reg.
name|Record
operator|*
name|Reg
block|;
name|MVT
operator|::
name|SimpleValueType
name|VT
block|;
name|public
operator|:
name|EmitRegisterMatcher
argument_list|(
argument|Record *reg
argument_list|,
argument|MVT::SimpleValueType vt
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitRegister
argument_list|)
block|,
name|Reg
argument_list|(
name|reg
argument_list|)
block|,
name|VT
argument_list|(
argument|vt
argument_list|)
block|{}
name|Record
operator|*
name|getReg
argument_list|()
specifier|const
block|{
return|return
name|Reg
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getVT
argument_list|()
specifier|const
block|{
return|return
name|VT
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitRegister
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitRegisterMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Reg
operator|==
name|Reg
operator|&&
name|cast
operator|<
name|EmitRegisterMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|VT
operator|==
name|VT
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
operator|(
name|intptr_t
operator|)
name|Reg
operator|)
operator|<<
literal|4
operator||
name|VT
return|;
block|}
expr|}
block|;
comment|/// EmitConvertToTargetMatcher - Emit an operation that reads a specified
comment|/// recorded node and converts it from being a ISD::Constant to
comment|/// ISD::TargetConstant, likewise for ConstantFP.
name|class
name|EmitConvertToTargetMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|Slot
block|;
name|public
operator|:
name|EmitConvertToTargetMatcher
argument_list|(
argument|unsigned slot
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitConvertToTarget
argument_list|)
block|,
name|Slot
argument_list|(
argument|slot
argument_list|)
block|{}
name|unsigned
name|getSlot
argument_list|()
specifier|const
block|{
return|return
name|Slot
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitConvertToTarget
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitConvertToTargetMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Slot
operator|==
name|Slot
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Slot
return|;
block|}
expr|}
block|;
comment|/// EmitMergeInputChainsMatcher - Emit a node that merges a list of input
comment|/// chains together with a token factor.  The list of nodes are the nodes in the
comment|/// matched pattern that have chain input/outputs.  This node adds all input
comment|/// chains of these nodes if they are not themselves a node in the pattern.
name|class
name|EmitMergeInputChainsMatcher
operator|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|unsigned
block|,
literal|3
operator|>
name|ChainNodes
block|;
name|public
operator|:
name|EmitMergeInputChainsMatcher
argument_list|(
argument|const unsigned *nodes
argument_list|,
argument|unsigned NumNodes
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitMergeInputChains
argument_list|)
block|,
name|ChainNodes
argument_list|(
argument|nodes
argument_list|,
argument|nodes+NumNodes
argument_list|)
block|{}
name|unsigned
name|getNumNodes
argument_list|()
specifier|const
block|{
return|return
name|ChainNodes
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNode
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|ChainNodes
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|ChainNodes
index|[
name|i
index|]
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitMergeInputChains
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitMergeInputChainsMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|ChainNodes
operator|==
name|ChainNodes
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// EmitCopyToRegMatcher - Emit a CopyToReg node from a value to a physreg,
comment|/// pushing the chain and glue results.
comment|///
name|class
name|EmitCopyToRegMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|SrcSlot
block|;
comment|// Value to copy into the physreg.
name|Record
operator|*
name|DestPhysReg
block|;
name|public
operator|:
name|EmitCopyToRegMatcher
argument_list|(
argument|unsigned srcSlot
argument_list|,
argument|Record *destPhysReg
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitCopyToReg
argument_list|)
block|,
name|SrcSlot
argument_list|(
name|srcSlot
argument_list|)
block|,
name|DestPhysReg
argument_list|(
argument|destPhysReg
argument_list|)
block|{}
name|unsigned
name|getSrcSlot
argument_list|()
specifier|const
block|{
return|return
name|SrcSlot
return|;
block|}
name|Record
operator|*
name|getDestPhysReg
argument_list|()
specifier|const
block|{
return|return
name|DestPhysReg
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitCopyToReg
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitCopyToRegMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|SrcSlot
operator|==
name|SrcSlot
operator|&&
name|cast
operator|<
name|EmitCopyToRegMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|DestPhysReg
operator|==
name|DestPhysReg
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|SrcSlot
operator|^
operator|(
operator|(
name|unsigned
operator|)
operator|(
name|intptr_t
operator|)
name|DestPhysReg
operator|<<
literal|4
operator|)
return|;
block|}
expr|}
block|;
comment|/// EmitNodeXFormMatcher - Emit an operation that runs an SDNodeXForm on a
comment|/// recorded node and records the result.
name|class
name|EmitNodeXFormMatcher
operator|:
name|public
name|Matcher
block|{
name|unsigned
name|Slot
block|;
name|Record
operator|*
name|NodeXForm
block|;
name|public
operator|:
name|EmitNodeXFormMatcher
argument_list|(
argument|unsigned slot
argument_list|,
argument|Record *nodeXForm
argument_list|)
operator|:
name|Matcher
argument_list|(
name|EmitNodeXForm
argument_list|)
block|,
name|Slot
argument_list|(
name|slot
argument_list|)
block|,
name|NodeXForm
argument_list|(
argument|nodeXForm
argument_list|)
block|{}
name|unsigned
name|getSlot
argument_list|()
specifier|const
block|{
return|return
name|Slot
return|;
block|}
name|Record
operator|*
name|getNodeXForm
argument_list|()
specifier|const
block|{
return|return
name|NodeXForm
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitNodeXForm
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|EmitNodeXFormMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Slot
operator|==
name|Slot
operator|&&
name|cast
operator|<
name|EmitNodeXFormMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|NodeXForm
operator|==
name|NodeXForm
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|{
return|return
name|Slot
operator|^
operator|(
operator|(
name|unsigned
operator|)
operator|(
name|intptr_t
operator|)
name|NodeXForm
operator|<<
literal|4
operator|)
return|;
block|}
expr|}
block|;
comment|/// EmitNodeMatcherCommon - Common class shared between EmitNode and
comment|/// MorphNodeTo.
name|class
name|EmitNodeMatcherCommon
operator|:
name|public
name|Matcher
block|{
name|std
operator|::
name|string
name|OpcodeName
block|;
specifier|const
name|SmallVector
operator|<
name|MVT
operator|::
name|SimpleValueType
block|,
literal|3
operator|>
name|VTs
block|;
specifier|const
name|SmallVector
operator|<
name|unsigned
block|,
literal|6
operator|>
name|Operands
block|;
name|bool
name|HasChain
block|,
name|HasInGlue
block|,
name|HasOutGlue
block|,
name|HasMemRefs
block|;
comment|/// NumFixedArityOperands - If this is a fixed arity node, this is set to -1.
comment|/// If this is a varidic node, this is set to the number of fixed arity
comment|/// operands in the root of the pattern.  The rest are appended to this node.
name|int
name|NumFixedArityOperands
block|;
name|public
operator|:
name|EmitNodeMatcherCommon
argument_list|(
argument|const std::string&opcodeName
argument_list|,
argument|const MVT::SimpleValueType *vts
argument_list|,
argument|unsigned numvts
argument_list|,
argument|const unsigned *operands
argument_list|,
argument|unsigned numops
argument_list|,
argument|bool hasChain
argument_list|,
argument|bool hasInGlue
argument_list|,
argument|bool hasOutGlue
argument_list|,
argument|bool hasmemrefs
argument_list|,
argument|int numfixedarityoperands
argument_list|,
argument|bool isMorphNodeTo
argument_list|)
operator|:
name|Matcher
argument_list|(
name|isMorphNodeTo
condition|?
name|MorphNodeTo
else|:
name|EmitNode
argument_list|)
block|,
name|OpcodeName
argument_list|(
name|opcodeName
argument_list|)
block|,
name|VTs
argument_list|(
name|vts
argument_list|,
name|vts
operator|+
name|numvts
argument_list|)
block|,
name|Operands
argument_list|(
name|operands
argument_list|,
name|operands
operator|+
name|numops
argument_list|)
block|,
name|HasChain
argument_list|(
name|hasChain
argument_list|)
block|,
name|HasInGlue
argument_list|(
name|hasInGlue
argument_list|)
block|,
name|HasOutGlue
argument_list|(
name|hasOutGlue
argument_list|)
block|,
name|HasMemRefs
argument_list|(
name|hasmemrefs
argument_list|)
block|,
name|NumFixedArityOperands
argument_list|(
argument|numfixedarityoperands
argument_list|)
block|{}
specifier|const
name|std
operator|::
name|string
operator|&
name|getOpcodeName
argument_list|()
specifier|const
block|{
return|return
name|OpcodeName
return|;
block|}
name|unsigned
name|getNumVTs
argument_list|()
specifier|const
block|{
return|return
name|VTs
operator|.
name|size
argument_list|()
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getVT
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|VTs
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|VTs
index|[
name|i
index|]
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getOperand
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|Operands
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|Operands
index|[
name|i
index|]
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
operator|&
name|getVTList
argument_list|()
specifier|const
block|{
return|return
name|VTs
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|getOperandList
argument_list|()
specifier|const
block|{
return|return
name|Operands
return|;
block|}
name|bool
name|hasChain
argument_list|()
specifier|const
block|{
return|return
name|HasChain
return|;
block|}
name|bool
name|hasInFlag
argument_list|()
specifier|const
block|{
return|return
name|HasInGlue
return|;
block|}
name|bool
name|hasOutFlag
argument_list|()
specifier|const
block|{
return|return
name|HasOutGlue
return|;
block|}
name|bool
name|hasMemRefs
argument_list|()
specifier|const
block|{
return|return
name|HasMemRefs
return|;
block|}
name|int
name|getNumFixedArityOperands
argument_list|()
specifier|const
block|{
return|return
name|NumFixedArityOperands
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitNode
operator|||
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MorphNodeTo
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|;
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// EmitNodeMatcher - This signals a successful match and generates a node.
name|class
name|EmitNodeMatcher
operator|:
name|public
name|EmitNodeMatcherCommon
block|{
name|unsigned
name|FirstResultSlot
block|;
name|public
operator|:
name|EmitNodeMatcher
argument_list|(
argument|const std::string&opcodeName
argument_list|,
argument|const MVT::SimpleValueType *vts
argument_list|,
argument|unsigned numvts
argument_list|,
argument|const unsigned *operands
argument_list|,
argument|unsigned numops
argument_list|,
argument|bool hasChain
argument_list|,
argument|bool hasInFlag
argument_list|,
argument|bool hasOutFlag
argument_list|,
argument|bool hasmemrefs
argument_list|,
argument|int numfixedarityoperands
argument_list|,
argument|unsigned firstresultslot
argument_list|)
operator|:
name|EmitNodeMatcherCommon
argument_list|(
name|opcodeName
argument_list|,
name|vts
argument_list|,
name|numvts
argument_list|,
name|operands
argument_list|,
name|numops
argument_list|,
name|hasChain
argument_list|,
name|hasInFlag
argument_list|,
name|hasOutFlag
argument_list|,
name|hasmemrefs
argument_list|,
name|numfixedarityoperands
argument_list|,
name|false
argument_list|)
block|,
name|FirstResultSlot
argument_list|(
argument|firstresultslot
argument_list|)
block|{}
name|unsigned
name|getFirstResultSlot
argument_list|()
specifier|const
block|{
return|return
name|FirstResultSlot
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitNode
return|;
block|}
expr|}
block|;
name|class
name|MorphNodeToMatcher
operator|:
name|public
name|EmitNodeMatcherCommon
block|{
specifier|const
name|PatternToMatch
operator|&
name|Pattern
block|;
name|public
operator|:
name|MorphNodeToMatcher
argument_list|(
argument|const std::string&opcodeName
argument_list|,
argument|const MVT::SimpleValueType *vts
argument_list|,
argument|unsigned numvts
argument_list|,
argument|const unsigned *operands
argument_list|,
argument|unsigned numops
argument_list|,
argument|bool hasChain
argument_list|,
argument|bool hasInFlag
argument_list|,
argument|bool hasOutFlag
argument_list|,
argument|bool hasmemrefs
argument_list|,
argument|int numfixedarityoperands
argument_list|,
argument|const PatternToMatch&pattern
argument_list|)
operator|:
name|EmitNodeMatcherCommon
argument_list|(
name|opcodeName
argument_list|,
name|vts
argument_list|,
name|numvts
argument_list|,
name|operands
argument_list|,
name|numops
argument_list|,
name|hasChain
argument_list|,
name|hasInFlag
argument_list|,
name|hasOutFlag
argument_list|,
name|hasmemrefs
argument_list|,
name|numfixedarityoperands
argument_list|,
name|true
argument_list|)
block|,
name|Pattern
argument_list|(
argument|pattern
argument_list|)
block|{   }
specifier|const
name|PatternToMatch
operator|&
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MorphNodeTo
return|;
block|}
expr|}
block|;
comment|/// MarkGlueResultsMatcher - This node indicates which non-root nodes in the
comment|/// pattern produce glue.  This allows CompleteMatchMatcher to update them
comment|/// with the output glue of the resultant code.
name|class
name|MarkGlueResultsMatcher
operator|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|unsigned
block|,
literal|3
operator|>
name|GlueResultNodes
block|;
name|public
operator|:
name|MarkGlueResultsMatcher
argument_list|(
argument|const unsigned *nodes
argument_list|,
argument|unsigned NumNodes
argument_list|)
operator|:
name|Matcher
argument_list|(
name|MarkGlueResults
argument_list|)
block|,
name|GlueResultNodes
argument_list|(
argument|nodes
argument_list|,
argument|nodes+NumNodes
argument_list|)
block|{}
name|unsigned
name|getNumNodes
argument_list|()
specifier|const
block|{
return|return
name|GlueResultNodes
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNode
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|GlueResultNodes
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|GlueResultNodes
index|[
name|i
index|]
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MarkGlueResults
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|MarkGlueResultsMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|GlueResultNodes
operator|==
name|GlueResultNodes
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;
comment|/// CompleteMatchMatcher - Complete a match by replacing the results of the
comment|/// pattern with the newly generated nodes.  This also prints a comment
comment|/// indicating the source and dest patterns.
name|class
name|CompleteMatchMatcher
operator|:
name|public
name|Matcher
block|{
name|SmallVector
operator|<
name|unsigned
block|,
literal|2
operator|>
name|Results
block|;
specifier|const
name|PatternToMatch
operator|&
name|Pattern
block|;
name|public
operator|:
name|CompleteMatchMatcher
argument_list|(
argument|const unsigned *results
argument_list|,
argument|unsigned numresults
argument_list|,
argument|const PatternToMatch&pattern
argument_list|)
operator|:
name|Matcher
argument_list|(
name|CompleteMatch
argument_list|)
block|,
name|Results
argument_list|(
name|results
argument_list|,
name|results
operator|+
name|numresults
argument_list|)
block|,
name|Pattern
argument_list|(
argument|pattern
argument_list|)
block|{}
name|unsigned
name|getNumResults
argument_list|()
specifier|const
block|{
return|return
name|Results
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getResult
argument_list|(
argument|unsigned R
argument_list|)
specifier|const
block|{
return|return
name|Results
index|[
name|R
index|]
return|;
block|}
specifier|const
name|PatternToMatch
operator|&
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const Matcher *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CompleteMatch
return|;
block|}
name|private
operator|:
name|virtual
name|void
name|printImpl
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isEqualImpl
argument_list|(
argument|const Matcher *M
argument_list|)
specifier|const
block|{
return|return
name|cast
operator|<
name|CompleteMatchMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Results
operator|==
name|Results
operator|&&
operator|&
name|cast
operator|<
name|CompleteMatchMatcher
operator|>
operator|(
name|M
operator|)
operator|->
name|Pattern
operator|==
operator|&
name|Pattern
return|;
block|}
name|virtual
name|unsigned
name|getHashImpl
argument_list|()
specifier|const
block|; }
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

