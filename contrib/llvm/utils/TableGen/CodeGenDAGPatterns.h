begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGenDAGPatterns.h - Read DAG patterns from .td file ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the CodeGenDAGPatterns class, which is used to read and
end_comment

begin_comment
comment|// represent the patterns present in a .td file for instructions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CODEGEN_DAGPATTERNS_H
end_ifndef

begin_define
define|#
directive|define
name|CODEGEN_DAGPATTERNS_H
end_define

begin_include
include|#
directive|include
file|"CodeGenTarget.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenIntrinsics.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Record
decl_stmt|;
name|class
name|Init
decl_stmt|;
name|class
name|ListInit
decl_stmt|;
name|class
name|DagInit
decl_stmt|;
name|class
name|SDNodeInfo
decl_stmt|;
name|class
name|TreePattern
decl_stmt|;
name|class
name|TreePatternNode
decl_stmt|;
name|class
name|CodeGenDAGPatterns
decl_stmt|;
name|class
name|ComplexPattern
decl_stmt|;
comment|/// EEVT::DAGISelGenValueType - These are some extended forms of
comment|/// MVT::SimpleValueType that we use as lattice values during type inference.
comment|/// The existing MVT iAny, fAny and vAny types suffice to represent
comment|/// arbitrary integer, floating-point, and vector types, so only an unknown
comment|/// value is needed.
name|namespace
name|EEVT
block|{
comment|/// TypeSet - This is either empty if it's completely unknown, or holds a set
comment|/// of types.  It is used during type inference because register classes can
comment|/// have multiple possible types and we don't know which one they get until
comment|/// type inference is complete.
comment|///
comment|/// TypeSet can have three states:
comment|///    Vector is empty: The type is completely unknown, it can be any valid
comment|///       target type.
comment|///    Vector has multiple constrained types: (e.g. v4i32 + v4f32) it is one
comment|///       of those types only.
comment|///    Vector has one concrete type: The type is completely known.
comment|///
name|class
name|TypeSet
block|{
name|SmallVector
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|,
literal|4
operator|>
name|TypeVec
expr_stmt|;
name|public
label|:
name|TypeSet
argument_list|()
block|{}
name|TypeSet
argument_list|(
argument|MVT::SimpleValueType VT
argument_list|,
argument|TreePattern&TP
argument_list|)
empty_stmt|;
name|TypeSet
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
operator|&
name|VTList
argument_list|)
expr_stmt|;
name|bool
name|isCompletelyUnknown
argument_list|()
specifier|const
block|{
return|return
name|TypeVec
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|isConcrete
argument_list|()
specifier|const
block|{
if|if
condition|(
name|TypeVec
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
return|return
name|false
return|;
name|unsigned
name|char
name|T
operator|=
name|TypeVec
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|T
expr_stmt|;
name|assert
argument_list|(
name|T
operator|<
name|MVT
operator|::
name|LAST_VALUETYPE
operator|||
name|T
operator|==
name|MVT
operator|::
name|iPTR
operator|||
name|T
operator|==
name|MVT
operator|::
name|iPTRAny
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getConcrete
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isConcrete
argument_list|()
operator|&&
literal|"Type isn't concrete yet"
argument_list|)
block|;
return|return
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|TypeVec
index|[
literal|0
index|]
return|;
block|}
name|bool
name|isDynamicallyResolved
argument_list|()
specifier|const
block|{
return|return
name|getConcrete
argument_list|()
operator|==
name|MVT
operator|::
name|iPTR
operator|||
name|getConcrete
argument_list|()
operator|==
name|MVT
operator|::
name|iPTRAny
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
operator|&
name|getTypeList
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|TypeVec
operator|.
name|empty
argument_list|()
operator|&&
literal|"Not a type list!"
argument_list|)
block|;
return|return
name|TypeVec
return|;
block|}
name|bool
name|isVoid
argument_list|()
specifier|const
block|{
return|return
name|TypeVec
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|TypeVec
index|[
literal|0
index|]
operator|==
name|MVT
operator|::
name|isVoid
return|;
block|}
comment|/// hasIntegerTypes - Return true if this TypeSet contains any integer value
comment|/// types.
name|bool
name|hasIntegerTypes
argument_list|()
specifier|const
expr_stmt|;
comment|/// hasFloatingPointTypes - Return true if this TypeSet contains an fAny or
comment|/// a floating point value type.
name|bool
name|hasFloatingPointTypes
argument_list|()
specifier|const
expr_stmt|;
comment|/// hasVectorTypes - Return true if this TypeSet contains a vector value
comment|/// type.
name|bool
name|hasVectorTypes
argument_list|()
specifier|const
expr_stmt|;
comment|/// getName() - Return this TypeSet as a string.
name|std
operator|::
name|string
name|getName
argument_list|()
specifier|const
expr_stmt|;
comment|/// MergeInTypeInfo - This merges in type information from the specified
comment|/// argument.  If 'this' changes, it returns true.  If the two types are
comment|/// contradictory (e.g. merge f32 into i32) then this throws an exception.
name|bool
name|MergeInTypeInfo
argument_list|(
specifier|const
name|EEVT
operator|::
name|TypeSet
operator|&
name|InVT
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl_stmt|;
name|bool
name|MergeInTypeInfo
argument_list|(
name|MVT
operator|::
name|SimpleValueType
name|InVT
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
block|{
return|return
name|MergeInTypeInfo
argument_list|(
name|EEVT
operator|::
name|TypeSet
argument_list|(
name|InVT
argument_list|,
name|TP
argument_list|)
argument_list|,
name|TP
argument_list|)
return|;
block|}
comment|/// Force this type list to only contain integer types.
name|bool
name|EnforceInteger
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// Force this type list to only contain floating point types.
name|bool
name|EnforceFloatingPoint
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// EnforceScalar - Remove all vector types from this type list.
name|bool
name|EnforceScalar
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// EnforceVector - Remove all non-vector types from this type list.
name|bool
name|EnforceVector
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// EnforceSmallerThan - 'this' must be a smaller VT than Other.  Update
comment|/// this an other based on this information.
name|bool
name|EnforceSmallerThan
argument_list|(
name|EEVT
operator|::
name|TypeSet
operator|&
name|Other
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl_stmt|;
comment|/// EnforceVectorEltTypeIs - 'this' is now constrainted to be a vector type
comment|/// whose element is VT.
name|bool
name|EnforceVectorEltTypeIs
argument_list|(
name|EEVT
operator|::
name|TypeSet
operator|&
name|VT
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl_stmt|;
comment|/// EnforceVectorSubVectorTypeIs - 'this' is now constrainted to
comment|/// be a vector type VT.
name|bool
name|EnforceVectorSubVectorTypeIs
argument_list|(
name|EEVT
operator|::
name|TypeSet
operator|&
name|VT
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypeSet
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|TypeVec
operator|!=
name|RHS
operator|.
name|TypeVec
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypeSet
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|TypeVec
operator|==
name|RHS
operator|.
name|TypeVec
return|;
block|}
name|private
label|:
comment|/// FillWithPossibleTypes - Set to all legal types and return true, only
comment|/// valid on completely unknown type sets.  If Pred is non-null, only MVTs
comment|/// that pass the predicate are added.
name|bool
name|FillWithPossibleTypes
argument_list|(
name|TreePattern
operator|&
name|TP
argument_list|,
name|bool
argument_list|(
operator|*
name|Pred
argument_list|)
argument_list|(
name|MVT
operator|::
name|SimpleValueType
argument_list|)
operator|=
literal|0
argument_list|,
specifier|const
name|char
operator|*
name|PredicateName
operator|=
literal|0
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Set type used to track multiply used variables in patterns
end_comment

begin_typedef
typedef|typedef
name|std
operator|::
name|set
operator|<
name|std
operator|::
name|string
operator|>
name|MultipleUseVarSet
expr_stmt|;
end_typedef

begin_comment
comment|/// SDTypeConstraint - This is a discriminated union of constraints,
end_comment

begin_comment
comment|/// corresponding to the SDTypeConstraint tablegen class in Target.td.
end_comment

begin_struct
struct|struct
name|SDTypeConstraint
block|{
name|SDTypeConstraint
argument_list|(
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
name|unsigned
name|OperandNo
decl_stmt|;
comment|// The operand # this constraint applies to.
enum|enum
block|{
name|SDTCisVT
block|,
name|SDTCisPtrTy
block|,
name|SDTCisInt
block|,
name|SDTCisFP
block|,
name|SDTCisVec
block|,
name|SDTCisSameAs
block|,
name|SDTCisVTSmallerThanOp
block|,
name|SDTCisOpSmallerThanOp
block|,
name|SDTCisEltOfVec
block|,
name|SDTCisSubVecOfVec
block|}
name|ConstraintType
enum|;
union|union
block|{
comment|// The discriminated union.
struct|struct
block|{
name|MVT
operator|::
name|SimpleValueType
name|VT
expr_stmt|;
block|}
name|SDTCisVT_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisSameAs_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisVTSmallerThanOp_Info
struct|;
struct|struct
block|{
name|unsigned
name|BigOperandNum
decl_stmt|;
block|}
name|SDTCisOpSmallerThanOp_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisEltOfVec_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisSubVecOfVec_Info
struct|;
block|}
name|x
union|;
comment|/// ApplyTypeConstraint - Given a node in a pattern, apply this type
comment|/// constraint to the nodes operands.  This returns true if it makes a
comment|/// change, false otherwise.  If a type contradiction is found, throw an
comment|/// exception.
name|bool
name|ApplyTypeConstraint
argument_list|(
name|TreePatternNode
operator|*
name|N
argument_list|,
specifier|const
name|SDNodeInfo
operator|&
name|NodeInfo
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// SDNodeInfo - One of these records is created for each SDNode instance in
end_comment

begin_comment
comment|/// the target .td file.  This represents the various dag nodes we will be
end_comment

begin_comment
comment|/// processing.
end_comment

begin_decl_stmt
name|class
name|SDNodeInfo
block|{
name|Record
modifier|*
name|Def
decl_stmt|;
name|std
operator|::
name|string
name|EnumName
expr_stmt|;
name|std
operator|::
name|string
name|SDClassName
expr_stmt|;
name|unsigned
name|Properties
decl_stmt|;
name|unsigned
name|NumResults
decl_stmt|;
name|int
name|NumOperands
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SDTypeConstraint
operator|>
name|TypeConstraints
expr_stmt|;
name|public
label|:
name|SDNodeInfo
argument_list|(
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
comment|// Parse the specified record.
name|unsigned
name|getNumResults
argument_list|()
specifier|const
block|{
return|return
name|NumResults
return|;
block|}
comment|/// getNumOperands - This is the number of operands required or -1 if
comment|/// variadic.
name|int
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|Def
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getEnumName
argument_list|()
specifier|const
block|{
return|return
name|EnumName
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getSDClassName
argument_list|()
specifier|const
block|{
return|return
name|SDClassName
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|SDTypeConstraint
operator|>
operator|&
name|getTypeConstraints
argument_list|()
specifier|const
block|{
return|return
name|TypeConstraints
return|;
block|}
comment|/// getKnownType - If the type constraints on this node imply a fixed type
comment|/// (e.g. all stores return void, etc), then return it as an
comment|/// MVT::SimpleValueType.  Otherwise, return MVT::Other.
name|MVT
operator|::
name|SimpleValueType
name|getKnownType
argument_list|(
argument|unsigned ResNo
argument_list|)
specifier|const
expr_stmt|;
comment|/// hasProperty - Return true if this node has the specified property.
comment|///
name|bool
name|hasProperty
argument_list|(
expr|enum
name|SDNP
name|Prop
argument_list|)
decl|const
block|{
return|return
name|Properties
operator|&
operator|(
literal|1
operator|<<
name|Prop
operator|)
return|;
block|}
comment|/// ApplyTypeConstraints - Given a node in a pattern, apply the type
comment|/// constraints for this node to the operands of the node.  This returns
comment|/// true if it makes a change, false otherwise.  If a type contradiction is
comment|/// found, throw an exception.
name|bool
name|ApplyTypeConstraints
argument_list|(
name|TreePatternNode
operator|*
name|N
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl|const
block|{
name|bool
name|MadeChange
init|=
name|false
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TypeConstraints
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|MadeChange
operator||=
name|TypeConstraints
index|[
name|i
index|]
operator|.
name|ApplyTypeConstraint
argument_list|(
name|N
argument_list|,
operator|*
name|this
argument_list|,
name|TP
argument_list|)
expr_stmt|;
return|return
name|MadeChange
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// TreePredicateFn - This is an abstraction that represents the predicates on
end_comment

begin_comment
comment|/// a PatFrag node.  This is a simple one-word wrapper around a pointer to
end_comment

begin_comment
comment|/// provide nice accessors.
end_comment

begin_decl_stmt
name|class
name|TreePredicateFn
block|{
comment|/// PatFragRec - This is the TreePattern for the PatFrag that we
comment|/// originally came from.
name|TreePattern
modifier|*
name|PatFragRec
decl_stmt|;
name|public
label|:
comment|/// TreePredicateFn constructor.  Here 'N' is a subclass of PatFrag.
name|TreePredicateFn
argument_list|(
name|TreePattern
operator|*
name|N
argument_list|)
expr_stmt|;
name|TreePattern
operator|*
name|getOrigPatFragRecord
argument_list|()
specifier|const
block|{
return|return
name|PatFragRec
return|;
block|}
comment|/// isAlwaysTrue - Return true if this is a noop predicate.
name|bool
name|isAlwaysTrue
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isImmediatePattern
argument_list|()
specifier|const
block|{
return|return
operator|!
name|getImmCode
argument_list|()
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/// getImmediatePredicateCode - Return the code that evaluates this pattern if
comment|/// this is an immediate predicate.  It is an error to call this on a
comment|/// non-immediate pattern.
name|std
operator|::
name|string
name|getImmediatePredicateCode
argument_list|()
specifier|const
block|{
name|std
operator|::
name|string
name|Result
operator|=
name|getImmCode
argument_list|()
block|;
name|assert
argument_list|(
operator|!
name|Result
operator|.
name|empty
argument_list|()
operator|&&
literal|"Isn't an immediate pattern!"
argument_list|)
block|;
return|return
name|Result
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TreePredicateFn
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|PatFragRec
operator|==
name|RHS
operator|.
name|PatFragRec
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TreePredicateFn
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|RHS
operator|)
return|;
block|}
comment|/// Return the name to use in the generated code to reference this, this is
comment|/// "Predicate_foo" if from a pattern fragment "foo".
name|std
operator|::
name|string
name|getFnName
argument_list|()
specifier|const
expr_stmt|;
comment|/// getCodeToRunOnSDNode - Return the code for the function body that
comment|/// evaluates this predicate.  The argument is expected to be in "Node",
comment|/// not N.  This handles casting and conversion to a concrete node type as
comment|/// appropriate.
name|std
operator|::
name|string
name|getCodeToRunOnSDNode
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|std
operator|::
name|string
name|getPredCode
argument_list|()
specifier|const
expr_stmt|;
name|std
operator|::
name|string
name|getImmCode
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// FIXME: TreePatternNode's can be shared in some cases (due to dag-shaped
end_comment

begin_comment
comment|/// patterns), and as such should be ref counted.  We currently just leak all
end_comment

begin_comment
comment|/// TreePatternNode objects!
end_comment

begin_decl_stmt
name|class
name|TreePatternNode
block|{
comment|/// The type of each node result.  Before and during type inference, each
comment|/// result may be a set of possible types.  After (successful) type inference,
comment|/// each is a single concrete type.
name|SmallVector
operator|<
name|EEVT
operator|::
name|TypeSet
operator|,
literal|1
operator|>
name|Types
expr_stmt|;
comment|/// Operator - The Record for the operator if this is an interior node (not
comment|/// a leaf).
name|Record
modifier|*
name|Operator
decl_stmt|;
comment|/// Val - The init value (e.g. the "GPRC" record, or "7") for a leaf.
comment|///
name|Init
modifier|*
name|Val
decl_stmt|;
comment|/// Name - The name given to this node with the :$foo notation.
comment|///
name|std
operator|::
name|string
name|Name
expr_stmt|;
comment|/// PredicateFns - The predicate functions to execute on this node to check
comment|/// for a match.  If this list is empty, no predicate is involved.
name|std
operator|::
name|vector
operator|<
name|TreePredicateFn
operator|>
name|PredicateFns
expr_stmt|;
comment|/// TransformFn - The transformation function to execute on this node before
comment|/// it can be substituted into the resulting instruction on a pattern match.
name|Record
modifier|*
name|TransformFn
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|Children
expr_stmt|;
name|public
label|:
name|TreePatternNode
argument_list|(
argument|Record *Op
argument_list|,
argument|const std::vector<TreePatternNode*>&Ch
argument_list|,
argument|unsigned NumResults
argument_list|)
block|:
name|Operator
argument_list|(
name|Op
argument_list|)
operator|,
name|Val
argument_list|(
literal|0
argument_list|)
operator|,
name|TransformFn
argument_list|(
literal|0
argument_list|)
operator|,
name|Children
argument_list|(
argument|Ch
argument_list|)
block|{
name|Types
operator|.
name|resize
argument_list|(
name|NumResults
argument_list|)
block|;   }
name|TreePatternNode
argument_list|(
argument|Init *val
argument_list|,
argument|unsigned NumResults
argument_list|)
comment|// leaf ctor
operator|:
name|Operator
argument_list|(
literal|0
argument_list|)
operator|,
name|Val
argument_list|(
name|val
argument_list|)
operator|,
name|TransformFn
argument_list|(
literal|0
argument_list|)
block|{
name|Types
operator|.
name|resize
argument_list|(
name|NumResults
argument_list|)
block|;   }
operator|~
name|TreePatternNode
argument_list|()
expr_stmt|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|void
name|setName
parameter_list|(
name|StringRef
name|N
parameter_list|)
block|{
name|Name
operator|.
name|assign
argument_list|(
name|N
operator|.
name|begin
argument_list|()
argument_list|,
name|N
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|bool
name|isLeaf
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|!=
literal|0
return|;
block|}
comment|// Type accessors.
name|unsigned
name|getNumTypes
argument_list|()
specifier|const
block|{
return|return
name|Types
operator|.
name|size
argument_list|()
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getType
argument_list|(
argument|unsigned ResNo
argument_list|)
specifier|const
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|getConcrete
argument_list|()
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|EEVT
operator|::
name|TypeSet
operator|>
operator|&
name|getExtTypes
argument_list|()
specifier|const
block|{
return|return
name|Types
return|;
block|}
specifier|const
name|EEVT
operator|::
name|TypeSet
operator|&
name|getExtType
argument_list|(
argument|unsigned ResNo
argument_list|)
specifier|const
block|{
return|return
name|Types
index|[
name|ResNo
index|]
return|;
block|}
name|EEVT
operator|::
name|TypeSet
operator|&
name|getExtType
argument_list|(
argument|unsigned ResNo
argument_list|)
block|{
return|return
name|Types
index|[
name|ResNo
index|]
return|;
block|}
name|void
name|setType
argument_list|(
name|unsigned
name|ResNo
argument_list|,
specifier|const
name|EEVT
operator|::
name|TypeSet
operator|&
name|T
argument_list|)
block|{
name|Types
index|[
name|ResNo
index|]
operator|=
name|T
expr_stmt|;
block|}
name|bool
name|hasTypeSet
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|isConcrete
argument_list|()
return|;
block|}
name|bool
name|isTypeCompletelyUnknown
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|isCompletelyUnknown
argument_list|()
return|;
block|}
name|bool
name|isTypeDynamicallyResolved
argument_list|(
name|unsigned
name|ResNo
argument_list|)
decl|const
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|isDynamicallyResolved
argument_list|()
return|;
block|}
name|Init
operator|*
name|getLeafValue
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isLeaf
argument_list|()
argument_list|)
block|;
return|return
name|Val
return|;
block|}
name|Record
operator|*
name|getOperator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isLeaf
argument_list|()
argument_list|)
block|;
return|return
name|Operator
return|;
block|}
name|unsigned
name|getNumChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|size
argument_list|()
return|;
block|}
name|TreePatternNode
modifier|*
name|getChild
argument_list|(
name|unsigned
name|N
argument_list|)
decl|const
block|{
return|return
name|Children
index|[
name|N
index|]
return|;
block|}
name|void
name|setChild
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|TreePatternNode
modifier|*
name|N
parameter_list|)
block|{
name|Children
index|[
name|i
index|]
operator|=
name|N
expr_stmt|;
block|}
comment|/// hasChild - Return true if N is any of our children.
name|bool
name|hasChild
argument_list|(
specifier|const
name|TreePatternNode
operator|*
name|N
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Children
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Children
index|[
name|i
index|]
operator|==
name|N
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|bool
name|hasAnyPredicate
argument_list|()
specifier|const
block|{
return|return
operator|!
name|PredicateFns
operator|.
name|empty
argument_list|()
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|TreePredicateFn
operator|>
operator|&
name|getPredicateFns
argument_list|()
specifier|const
block|{
return|return
name|PredicateFns
return|;
block|}
name|void
name|clearPredicateFns
parameter_list|()
block|{
name|PredicateFns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|setPredicateFns
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|TreePredicateFn
operator|>
operator|&
name|Fns
argument_list|)
block|{
name|assert
argument_list|(
name|PredicateFns
operator|.
name|empty
argument_list|()
operator|&&
literal|"Overwriting non-empty predicate list!"
argument_list|)
expr_stmt|;
name|PredicateFns
operator|=
name|Fns
expr_stmt|;
block|}
name|void
name|addPredicateFn
parameter_list|(
specifier|const
name|TreePredicateFn
modifier|&
name|Fn
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|Fn
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
literal|"Empty predicate string!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|PredicateFns
operator|.
name|begin
argument_list|()
argument_list|,
name|PredicateFns
operator|.
name|end
argument_list|()
argument_list|,
name|Fn
argument_list|)
operator|==
name|PredicateFns
operator|.
name|end
argument_list|()
condition|)
name|PredicateFns
operator|.
name|push_back
argument_list|(
name|Fn
argument_list|)
expr_stmt|;
block|}
name|Record
operator|*
name|getTransformFn
argument_list|()
specifier|const
block|{
return|return
name|TransformFn
return|;
block|}
name|void
name|setTransformFn
parameter_list|(
name|Record
modifier|*
name|Fn
parameter_list|)
block|{
name|TransformFn
operator|=
name|Fn
expr_stmt|;
block|}
comment|/// getIntrinsicInfo - If this node corresponds to an intrinsic, return the
comment|/// CodeGenIntrinsic information for it, otherwise return a null pointer.
specifier|const
name|CodeGenIntrinsic
modifier|*
name|getIntrinsicInfo
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl|const
decl_stmt|;
comment|/// getComplexPatternInfo - If this node corresponds to a ComplexPattern,
comment|/// return the ComplexPattern information, otherwise return null.
specifier|const
name|ComplexPattern
modifier|*
name|getComplexPatternInfo
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CGP
argument_list|)
decl|const
decl_stmt|;
comment|/// NodeHasProperty - Return true if this node has the specified property.
name|bool
name|NodeHasProperty
argument_list|(
name|SDNP
name|Property
argument_list|,
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CGP
argument_list|)
decl|const
decl_stmt|;
comment|/// TreeHasProperty - Return true if any node in this tree has the specified
comment|/// property.
name|bool
name|TreeHasProperty
argument_list|(
name|SDNP
name|Property
argument_list|,
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CGP
argument_list|)
decl|const
decl_stmt|;
comment|/// isCommutativeIntrinsic - Return true if the node is an intrinsic which is
comment|/// marked isCommutative.
name|bool
name|isCommutativeIntrinsic
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|public
label|:
comment|// Higher level manipulation routines.
comment|/// clone - Return a new copy of this tree.
comment|///
name|TreePatternNode
operator|*
name|clone
argument_list|()
specifier|const
expr_stmt|;
comment|/// RemoveAllTypes - Recursively strip all the types of this tree.
name|void
name|RemoveAllTypes
parameter_list|()
function_decl|;
comment|/// isIsomorphicTo - Return true if this node is recursively isomorphic to
comment|/// the specified node.  For this comparison, all of the state of the node
comment|/// is considered, except for the assigned name.  Nodes with differing names
comment|/// that are otherwise identical are considered isomorphic.
name|bool
name|isIsomorphicTo
argument_list|(
specifier|const
name|TreePatternNode
operator|*
name|N
argument_list|,
specifier|const
name|MultipleUseVarSet
operator|&
name|DepVars
argument_list|)
decl|const
decl_stmt|;
comment|/// SubstituteFormalArguments - Replace the formal arguments in this tree
comment|/// with actual values specified by ArgMap.
name|void
name|SubstituteFormalArguments
argument_list|(
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|ArgMap
argument_list|)
decl_stmt|;
comment|/// InlinePatternFragments - If this pattern refers to any pattern
comment|/// fragments, inline them into place, giving us a pattern without any
comment|/// PatFrag references.
name|TreePatternNode
modifier|*
name|InlinePatternFragments
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// ApplyTypeConstraints - Apply all of the type constraints relevant to
comment|/// this node and its children in the tree.  This returns true if it makes a
comment|/// change, false otherwise.  If a type contradiction is found, throw an
comment|/// exception.
name|bool
name|ApplyTypeConstraints
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|,
name|bool
name|NotRegisters
parameter_list|)
function_decl|;
comment|/// UpdateNodeType - Set the node type of N to VT if VT contains
comment|/// information.  If N already contains a conflicting type, then throw an
comment|/// exception.  This returns true if any information was updated.
comment|///
name|bool
name|UpdateNodeType
argument_list|(
name|unsigned
name|ResNo
argument_list|,
specifier|const
name|EEVT
operator|::
name|TypeSet
operator|&
name|InTy
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|MergeInTypeInfo
argument_list|(
name|InTy
argument_list|,
name|TP
argument_list|)
return|;
block|}
name|bool
name|UpdateNodeType
argument_list|(
name|unsigned
name|ResNo
argument_list|,
name|MVT
operator|::
name|SimpleValueType
name|InTy
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
block|{
return|return
name|Types
index|[
name|ResNo
index|]
operator|.
name|MergeInTypeInfo
argument_list|(
name|EEVT
operator|::
name|TypeSet
argument_list|(
name|InTy
argument_list|,
name|TP
argument_list|)
argument_list|,
name|TP
argument_list|)
return|;
block|}
comment|/// ContainsUnresolvedType - Return true if this tree contains any
comment|/// unresolved types.
name|bool
name|ContainsUnresolvedType
argument_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Types
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|Types
index|[
name|i
index|]
operator|.
name|isConcrete
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumChildren
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getChild
argument_list|(
name|i
argument_list|)
operator|->
name|ContainsUnresolvedType
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// canPatternMatch - If it is impossible for this pattern to match on this
end_comment

begin_comment
comment|/// target, fill in Reason and return false.  Otherwise, return true.
end_comment

begin_decl_stmt
name|bool
name|canPatternMatch
argument_list|(
name|std
operator|::
name|string
operator|&
name|Reason
argument_list|,
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|TreePatternNode
operator|&
name|TPN
operator|)
block|{
name|TPN
operator|.
name|print
argument_list|(
name|OS
argument_list|)
block|;
return|return
name|OS
return|;
block|}
end_expr_stmt

begin_comment
comment|/// TreePattern - Represent a pattern, used for instructions, pattern
end_comment

begin_comment
comment|/// fragments, etc.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|TreePattern
block|{
comment|/// Trees - The list of pattern trees which corresponds to this pattern.
comment|/// Note that PatFrag's only have a single tree.
comment|///
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|Trees
expr_stmt|;
comment|/// NamedNodes - This is all of the nodes that have names in the trees in this
comment|/// pattern.
name|StringMap
operator|<
name|SmallVector
operator|<
name|TreePatternNode
operator|*
operator|,
literal|1
operator|>
expr|>
name|NamedNodes
expr_stmt|;
comment|/// TheRecord - The actual TableGen record corresponding to this pattern.
comment|///
name|Record
modifier|*
name|TheRecord
decl_stmt|;
comment|/// Args - This is a list of all of the arguments to this pattern (for
comment|/// PatFrag patterns), which are the 'node' markers in this pattern.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|Args
expr_stmt|;
comment|/// CDP - the top-level object coordinating this madness.
comment|///
name|CodeGenDAGPatterns
modifier|&
name|CDP
decl_stmt|;
comment|/// isInputPattern - True if this is an input pattern, something to match.
comment|/// False if this is an output pattern, something to emit.
name|bool
name|isInputPattern
decl_stmt|;
name|public
label|:
comment|/// TreePattern constructor - Parse the specified DagInits into the
comment|/// current record.
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|ListInit *RawPat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|DagInit *Pat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|TreePatternNode *Pat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
comment|/// getTrees - Return the tree patterns which corresponds to this pattern.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
operator|&
name|getTrees
argument_list|()
specifier|const
block|{
return|return
name|Trees
return|;
block|}
name|unsigned
name|getNumTrees
argument_list|()
specifier|const
block|{
return|return
name|Trees
operator|.
name|size
argument_list|()
return|;
block|}
name|TreePatternNode
modifier|*
name|getTree
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|Trees
index|[
name|i
index|]
return|;
block|}
name|TreePatternNode
operator|*
name|getOnlyTree
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Trees
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Doesn't have exactly one pattern!"
argument_list|)
block|;
return|return
name|Trees
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|StringMap
operator|<
name|SmallVector
operator|<
name|TreePatternNode
operator|*
operator|,
literal|1
operator|>
expr|>
operator|&
name|getNamedNodesMap
argument_list|()
block|{
if|if
condition|(
name|NamedNodes
operator|.
name|empty
argument_list|()
condition|)
name|ComputeNamedNodes
argument_list|()
expr_stmt|;
return|return
name|NamedNodes
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getRecord - Return the actual TableGen record corresponding to this
end_comment

begin_comment
comment|/// pattern.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|TheRecord
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|std
operator|::
name|string
operator|&
name|getArgName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|Args
operator|.
name|size
argument_list|()
operator|&&
literal|"Argument reference out of range!"
argument_list|)
block|;
return|return
name|Args
index|[
name|i
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|getArgList
argument_list|()
block|{
return|return
name|Args
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CodeGenDAGPatterns
operator|&
name|getDAGPatterns
argument_list|()
specifier|const
block|{
return|return
name|CDP
return|;
block|}
end_expr_stmt

begin_comment
comment|/// InlinePatternFragments - If this pattern refers to any pattern
end_comment

begin_comment
comment|/// fragments, inline them into place, giving us a pattern without any
end_comment

begin_comment
comment|/// PatFrag references.
end_comment

begin_function
name|void
name|InlinePatternFragments
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Trees
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Trees
index|[
name|i
index|]
operator|=
name|Trees
index|[
name|i
index|]
operator|->
name|InlinePatternFragments
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// InferAllTypes - Infer/propagate as many types throughout the expression
end_comment

begin_comment
comment|/// patterns as possible.  Return true if all types are inferred, false
end_comment

begin_comment
comment|/// otherwise.  Throw an exception if a type contradiction is found.
end_comment

begin_decl_stmt
name|bool
name|InferAllTypes
argument_list|(
specifier|const
name|StringMap
operator|<
name|SmallVector
operator|<
name|TreePatternNode
operator|*
argument_list|,
literal|1
operator|>
expr|>
operator|*
name|NamedTypes
operator|=
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// error - Throw an exception, prefixing it with information about this
end_comment

begin_comment
comment|/// pattern.
end_comment

begin_decl_stmt
name|void
name|error
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Msg
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function_decl
name|TreePatternNode
modifier|*
name|ParseTreePattern
parameter_list|(
name|Init
modifier|*
name|DI
parameter_list|,
name|StringRef
name|OpName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ComputeNamedNodes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ComputeNamedNodes
parameter_list|(
name|TreePatternNode
modifier|*
name|N
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|/// DAGDefaultOperand - One of these is created for each PredicateOperand
end_comment

begin_comment
comment|/// or OptionalDefOperand that has a set ExecuteAlways / DefaultOps field.
end_comment

begin_struct
struct|struct
name|DAGDefaultOperand
block|{
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|DefaultOps
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|DAGInstruction
block|{
name|TreePattern
modifier|*
name|Pattern
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Results
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Operands
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|ImpResults
expr_stmt|;
name|TreePatternNode
modifier|*
name|ResultPattern
decl_stmt|;
name|public
label|:
name|DAGInstruction
argument_list|(
name|TreePattern
operator|*
name|TP
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|results
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|operands
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|impresults
argument_list|)
operator|:
name|Pattern
argument_list|(
name|TP
argument_list|)
operator|,
name|Results
argument_list|(
name|results
argument_list|)
operator|,
name|Operands
argument_list|(
name|operands
argument_list|)
operator|,
name|ImpResults
argument_list|(
name|impresults
argument_list|)
operator|,
name|ResultPattern
argument_list|(
literal|0
argument_list|)
block|{}
specifier|const
name|TreePattern
operator|*
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
name|unsigned
name|getNumResults
argument_list|()
specifier|const
block|{
return|return
name|Results
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNumImpResults
argument_list|()
specifier|const
block|{
return|return
name|ImpResults
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getImpResults
argument_list|()
specifier|const
block|{
return|return
name|ImpResults
return|;
block|}
name|void
name|setResultPattern
parameter_list|(
name|TreePatternNode
modifier|*
name|R
parameter_list|)
block|{
name|ResultPattern
operator|=
name|R
expr_stmt|;
block|}
name|Record
modifier|*
name|getResult
argument_list|(
name|unsigned
name|RN
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|RN
operator|<
name|Results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Results
index|[
name|RN
index|]
return|;
block|}
name|Record
modifier|*
name|getOperand
argument_list|(
name|unsigned
name|ON
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ON
operator|<
name|Operands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Operands
index|[
name|ON
index|]
return|;
block|}
name|Record
modifier|*
name|getImpResult
argument_list|(
name|unsigned
name|RN
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|RN
operator|<
name|ImpResults
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ImpResults
index|[
name|RN
index|]
return|;
block|}
name|TreePatternNode
operator|*
name|getResultPattern
argument_list|()
specifier|const
block|{
return|return
name|ResultPattern
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// PatternToMatch - Used by CodeGenDAGPatterns to keep tab of patterns
end_comment

begin_comment
comment|/// processed to produce isel.
end_comment

begin_decl_stmt
name|class
name|PatternToMatch
block|{
name|public
label|:
name|PatternToMatch
argument_list|(
argument|Record *srcrecord
argument_list|,
argument|ListInit *preds
argument_list|,
argument|TreePatternNode *src
argument_list|,
argument|TreePatternNode *dst
argument_list|,
argument|const std::vector<Record*>&dstregs
argument_list|,
argument|unsigned complexity
argument_list|,
argument|unsigned uid
argument_list|)
block|:
name|SrcRecord
argument_list|(
name|srcrecord
argument_list|)
operator|,
name|Predicates
argument_list|(
name|preds
argument_list|)
operator|,
name|SrcPattern
argument_list|(
name|src
argument_list|)
operator|,
name|DstPattern
argument_list|(
name|dst
argument_list|)
operator|,
name|Dstregs
argument_list|(
name|dstregs
argument_list|)
operator|,
name|AddedComplexity
argument_list|(
name|complexity
argument_list|)
operator|,
name|ID
argument_list|(
argument|uid
argument_list|)
block|{}
name|Record
operator|*
name|SrcRecord
expr_stmt|;
comment|// Originating Record for the pattern.
name|ListInit
modifier|*
name|Predicates
decl_stmt|;
comment|// Top level predicate conditions to match.
name|TreePatternNode
modifier|*
name|SrcPattern
decl_stmt|;
comment|// Source pattern to match.
name|TreePatternNode
modifier|*
name|DstPattern
decl_stmt|;
comment|// Resulting pattern.
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Dstregs
expr_stmt|;
comment|// Physical register defs being matched.
name|unsigned
name|AddedComplexity
decl_stmt|;
comment|// Add to matching pattern complexity.
name|unsigned
name|ID
decl_stmt|;
comment|// Unique ID for the record.
name|Record
operator|*
name|getSrcRecord
argument_list|()
specifier|const
block|{
return|return
name|SrcRecord
return|;
block|}
name|ListInit
operator|*
name|getPredicates
argument_list|()
specifier|const
block|{
return|return
name|Predicates
return|;
block|}
name|TreePatternNode
operator|*
name|getSrcPattern
argument_list|()
specifier|const
block|{
return|return
name|SrcPattern
return|;
block|}
name|TreePatternNode
operator|*
name|getDstPattern
argument_list|()
specifier|const
block|{
return|return
name|DstPattern
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getDstRegs
argument_list|()
specifier|const
block|{
return|return
name|Dstregs
return|;
block|}
name|unsigned
name|getAddedComplexity
argument_list|()
specifier|const
block|{
return|return
name|AddedComplexity
return|;
block|}
name|std
operator|::
name|string
name|getPredicateCheck
argument_list|()
specifier|const
expr_stmt|;
comment|/// Compute the complexity metric for the input pattern.  This roughly
comment|/// corresponds to the number of nodes that are covered.
name|unsigned
name|getPatternComplexity
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CGP
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Deterministic comparison of Record*.
end_comment

begin_struct
struct|struct
name|RecordPtrCmp
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Record
operator|*
name|LHS
operator|,
specifier|const
name|Record
operator|*
name|RHS
operator|)
specifier|const
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|CodeGenDAGPatterns
block|{
name|RecordKeeper
modifier|&
name|Records
decl_stmt|;
name|CodeGenTarget
name|Target
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenIntrinsic
operator|>
name|Intrinsics
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenIntrinsic
operator|>
name|TgtIntrinsics
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|SDNodeInfo
operator|,
name|RecordPtrCmp
operator|>
name|SDNodes
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|string
operator|>
operator|,
name|RecordPtrCmp
operator|>
name|SDNodeXForms
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|ComplexPattern
operator|,
name|RecordPtrCmp
operator|>
name|ComplexPatterns
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|TreePattern
operator|*
operator|,
name|RecordPtrCmp
operator|>
name|PatternFragments
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|DAGDefaultOperand
operator|,
name|RecordPtrCmp
operator|>
name|DefaultOperands
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|DAGInstruction
operator|,
name|RecordPtrCmp
operator|>
name|Instructions
expr_stmt|;
comment|// Specific SDNode definitions:
name|Record
modifier|*
name|intrinsic_void_sdnode
decl_stmt|;
name|Record
modifier|*
name|intrinsic_w_chain_sdnode
decl_stmt|,
modifier|*
name|intrinsic_wo_chain_sdnode
decl_stmt|;
comment|/// PatternsToMatch - All of the things we are matching on the DAG.  The first
comment|/// value is the pattern to match, the second pattern is the result to
comment|/// emit.
name|std
operator|::
name|vector
operator|<
name|PatternToMatch
operator|>
name|PatternsToMatch
expr_stmt|;
name|public
label|:
name|CodeGenDAGPatterns
argument_list|(
name|RecordKeeper
operator|&
name|R
argument_list|)
expr_stmt|;
operator|~
name|CodeGenDAGPatterns
argument_list|()
expr_stmt|;
name|CodeGenTarget
modifier|&
name|getTargetInfo
parameter_list|()
block|{
return|return
name|Target
return|;
block|}
specifier|const
name|CodeGenTarget
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|Target
return|;
block|}
name|Record
modifier|*
name|getSDNodeNamed
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|SDNodeInfo
modifier|&
name|getSDNodeInfo
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|SDNodes
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown node!"
argument_list|)
expr_stmt|;
return|return
name|SDNodes
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
comment|// Node transformation lookups.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|NodeXForm
expr_stmt|;
specifier|const
name|NodeXForm
modifier|&
name|getSDNodeTransform
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|SDNodeXForms
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Invalid transform!"
argument_list|)
expr_stmt|;
return|return
name|SDNodeXForms
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
typedef|typedef
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|NodeXForm
operator|,
name|RecordPtrCmp
operator|>
operator|::
name|const_iterator
name|nx_iterator
expr_stmt|;
name|nx_iterator
name|nx_begin
argument_list|()
specifier|const
block|{
return|return
name|SDNodeXForms
operator|.
name|begin
argument_list|()
return|;
block|}
name|nx_iterator
name|nx_end
argument_list|()
specifier|const
block|{
return|return
name|SDNodeXForms
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|ComplexPattern
modifier|&
name|getComplexPattern
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ComplexPatterns
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown addressing mode!"
argument_list|)
expr_stmt|;
return|return
name|ComplexPatterns
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
specifier|const
name|CodeGenIntrinsic
modifier|&
name|getIntrinsic
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Intrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Intrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|Intrinsics
index|[
name|i
index|]
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TgtIntrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TgtIntrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|TgtIntrinsics
index|[
name|i
index|]
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown intrinsic!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
specifier|const
name|CodeGenIntrinsic
modifier|&
name|getIntrinsicInfo
argument_list|(
name|unsigned
name|IID
argument_list|)
decl|const
block|{
if|if
condition|(
name|IID
operator|-
literal|1
operator|<
name|Intrinsics
operator|.
name|size
argument_list|()
condition|)
return|return
name|Intrinsics
index|[
name|IID
operator|-
literal|1
index|]
return|;
if|if
condition|(
name|IID
operator|-
name|Intrinsics
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|<
name|TgtIntrinsics
operator|.
name|size
argument_list|()
condition|)
return|return
name|TgtIntrinsics
index|[
name|IID
operator|-
name|Intrinsics
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Bad intrinsic ID!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|getIntrinsicID
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Intrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Intrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|i
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TgtIntrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TgtIntrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|i
operator|+
name|Intrinsics
operator|.
name|size
argument_list|()
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown intrinsic!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
specifier|const
name|DAGDefaultOperand
modifier|&
name|getDefaultOperand
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|DefaultOperands
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Isn't an analyzed default operand!"
argument_list|)
expr_stmt|;
return|return
name|DefaultOperands
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
comment|// Pattern Fragment information.
name|TreePattern
modifier|*
name|getPatternFragment
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|PatternFragments
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Invalid pattern fragment request!"
argument_list|)
expr_stmt|;
return|return
name|PatternFragments
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
name|TreePattern
modifier|*
name|getPatternFragmentIfRead
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
if|if
condition|(
operator|!
name|PatternFragments
operator|.
name|count
argument_list|(
name|R
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|PatternFragments
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
typedef|typedef
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|TreePattern
operator|*
operator|,
name|RecordPtrCmp
operator|>
operator|::
name|const_iterator
name|pf_iterator
expr_stmt|;
name|pf_iterator
name|pf_begin
argument_list|()
specifier|const
block|{
return|return
name|PatternFragments
operator|.
name|begin
argument_list|()
return|;
block|}
name|pf_iterator
name|pf_end
argument_list|()
specifier|const
block|{
return|return
name|PatternFragments
operator|.
name|end
argument_list|()
return|;
block|}
comment|// Patterns to match information.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|PatternToMatch
operator|>
operator|::
name|const_iterator
name|ptm_iterator
expr_stmt|;
name|ptm_iterator
name|ptm_begin
argument_list|()
specifier|const
block|{
return|return
name|PatternsToMatch
operator|.
name|begin
argument_list|()
return|;
block|}
name|ptm_iterator
name|ptm_end
argument_list|()
specifier|const
block|{
return|return
name|PatternsToMatch
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|DAGInstruction
modifier|&
name|getInstruction
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Instructions
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown instruction!"
argument_list|)
expr_stmt|;
return|return
name|Instructions
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
name|Record
operator|*
name|get_intrinsic_void_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_void_sdnode
return|;
block|}
name|Record
operator|*
name|get_intrinsic_w_chain_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_w_chain_sdnode
return|;
block|}
name|Record
operator|*
name|get_intrinsic_wo_chain_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_wo_chain_sdnode
return|;
block|}
name|bool
name|hasTargetIntrinsics
parameter_list|()
block|{
return|return
operator|!
name|TgtIntrinsics
operator|.
name|empty
argument_list|()
return|;
block|}
name|private
label|:
name|void
name|ParseNodeInfo
parameter_list|()
function_decl|;
name|void
name|ParseNodeTransforms
parameter_list|()
function_decl|;
name|void
name|ParseComplexPatterns
parameter_list|()
function_decl|;
name|void
name|ParsePatternFragments
parameter_list|()
function_decl|;
name|void
name|ParseDefaultOperands
parameter_list|()
function_decl|;
name|void
name|ParseInstructions
parameter_list|()
function_decl|;
name|void
name|ParsePatterns
parameter_list|()
function_decl|;
name|void
name|InferInstructionFlags
parameter_list|()
function_decl|;
name|void
name|GenerateVariants
parameter_list|()
function_decl|;
name|void
name|AddPatternToMatch
parameter_list|(
specifier|const
name|TreePattern
modifier|*
name|Pattern
parameter_list|,
specifier|const
name|PatternToMatch
modifier|&
name|PTM
parameter_list|)
function_decl|;
name|void
name|FindPatternInputsAndOutputs
argument_list|(
name|TreePattern
operator|*
name|I
argument_list|,
name|TreePatternNode
operator|*
name|Pat
argument_list|,
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|InstInputs
argument_list|,
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|InstResults
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|InstImpResults
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

