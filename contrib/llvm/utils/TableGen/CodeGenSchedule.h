begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGenSchedule.h - Scheduling Machine Models ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines structures to encapsulate the machine model as decribed in
end_comment

begin_comment
comment|// the target description.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CODEGEN_SCHEDULE_H
end_ifndef

begin_define
define|#
directive|define
name|CODEGEN_SCHEDULE_H
end_define

begin_include
include|#
directive|include
file|"SetTheory.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/TableGen/Record.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CodeGenTarget
decl_stmt|;
name|class
name|CodeGenSchedModels
decl_stmt|;
name|class
name|CodeGenInstruction
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|RecVec
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|::
name|const_iterator
name|RecIter
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|IdxVec
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|::
name|const_iterator
name|IdxIter
expr_stmt|;
name|void
name|splitSchedReadWrites
parameter_list|(
specifier|const
name|RecVec
modifier|&
name|RWDefs
parameter_list|,
name|RecVec
modifier|&
name|WriteDefs
parameter_list|,
name|RecVec
modifier|&
name|ReadDefs
parameter_list|)
function_decl|;
comment|/// We have two kinds of SchedReadWrites. Explicitly defined and inferred
comment|/// sequences.  TheDef is nonnull for explicit SchedWrites, but Sequence may or
comment|/// may not be empty. TheDef is null for inferred sequences, and Sequence must
comment|/// be nonempty.
comment|///
comment|/// IsVariadic controls whether the variants are expanded into multiple operands
comment|/// or a sequence of writes on one operand.
struct|struct
name|CodeGenSchedRW
block|{
name|unsigned
name|Index
decl_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|Record
modifier|*
name|TheDef
decl_stmt|;
name|bool
name|IsRead
decl_stmt|;
name|bool
name|IsAlias
decl_stmt|;
name|bool
name|HasVariants
decl_stmt|;
name|bool
name|IsVariadic
decl_stmt|;
name|bool
name|IsSequence
decl_stmt|;
name|IdxVec
name|Sequence
decl_stmt|;
name|RecVec
name|Aliases
decl_stmt|;
name|CodeGenSchedRW
argument_list|()
operator|:
name|Index
argument_list|(
literal|0
argument_list|)
operator|,
name|TheDef
argument_list|(
literal|0
argument_list|)
operator|,
name|IsRead
argument_list|(
name|false
argument_list|)
operator|,
name|IsAlias
argument_list|(
name|false
argument_list|)
operator|,
name|HasVariants
argument_list|(
name|false
argument_list|)
operator|,
name|IsVariadic
argument_list|(
name|false
argument_list|)
operator|,
name|IsSequence
argument_list|(
argument|false
argument_list|)
block|{}
name|CodeGenSchedRW
argument_list|(
argument|unsigned Idx
argument_list|,
argument|Record *Def
argument_list|)
operator|:
name|Index
argument_list|(
name|Idx
argument_list|)
operator|,
name|TheDef
argument_list|(
name|Def
argument_list|)
operator|,
name|IsAlias
argument_list|(
name|false
argument_list|)
operator|,
name|IsVariadic
argument_list|(
argument|false
argument_list|)
block|{
name|Name
operator|=
name|Def
operator|->
name|getName
argument_list|()
block|;
name|IsRead
operator|=
name|Def
operator|->
name|isSubClassOf
argument_list|(
literal|"SchedRead"
argument_list|)
block|;
name|HasVariants
operator|=
name|Def
operator|->
name|isSubClassOf
argument_list|(
literal|"SchedVariant"
argument_list|)
block|;
if|if
condition|(
name|HasVariants
condition|)
name|IsVariadic
operator|=
name|Def
operator|->
name|getValueAsBit
argument_list|(
literal|"Variadic"
argument_list|)
expr_stmt|;
comment|// Read records don't currently have sequences, but it can be easily
comment|// added. Note that implicit Reads (from ReadVariant) may have a Sequence
comment|// (but no record).
name|IsSequence
operator|=
name|Def
operator|->
name|isSubClassOf
argument_list|(
literal|"WriteSequence"
argument_list|)
expr_stmt|;
block|}
name|CodeGenSchedRW
argument_list|(
name|unsigned
name|Idx
argument_list|,
name|bool
name|Read
argument_list|,
specifier|const
name|IdxVec
operator|&
name|Seq
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
range|:
name|Index
argument_list|(
name|Idx
argument_list|)
struct|,
name|Name
argument_list|(
name|Name
argument_list|)
struct|,
name|TheDef
argument_list|(
literal|0
argument_list|)
struct|,
name|IsRead
argument_list|(
name|Read
argument_list|)
struct|,
name|IsAlias
argument_list|(
name|false
argument_list|)
struct|,
name|HasVariants
argument_list|(
name|false
argument_list|)
struct|,
name|IsVariadic
argument_list|(
name|false
argument_list|)
struct|,
name|IsSequence
argument_list|(
name|true
argument_list|)
struct|,
name|Sequence
argument_list|(
name|Seq
argument_list|)
block|{
name|assert
argument_list|(
name|Sequence
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
literal|"implied sequence needs>1 RWs"
argument_list|)
expr_stmt|;
block|}
name|bool
name|isValid
argument_list|()
decl|const
block|{
name|assert
argument_list|(
operator|(
operator|!
name|HasVariants
operator|||
name|TheDef
operator|)
operator|&&
literal|"Variant write needs record def"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|!
name|IsVariadic
operator|||
name|HasVariants
operator|)
operator|&&
literal|"Variadic write needs variants"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|!
name|IsSequence
operator|||
operator|!
name|HasVariants
operator|)
operator|&&
literal|"Sequence can't have variant"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|!
name|IsSequence
operator|||
operator|!
name|Sequence
operator|.
name|empty
argument_list|()
operator|)
operator|&&
literal|"Sequence should be nonempty"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|!
name|IsAlias
operator|||
name|Aliases
operator|.
name|empty
argument_list|()
operator|)
operator|&&
literal|"Alias cannot have aliases"
argument_list|)
expr_stmt|;
return|return
name|TheDef
operator|||
operator|!
name|Sequence
operator|.
name|empty
argument_list|()
return|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|void
name|dump
argument_list|()
decl|const
struct|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Represent a transition between SchedClasses induced by SchedVariant.
end_comment

begin_struct
struct|struct
name|CodeGenSchedTransition
block|{
name|unsigned
name|ToClassIdx
decl_stmt|;
name|IdxVec
name|ProcIndices
decl_stmt|;
name|RecVec
name|PredTerm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// Scheduling class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Each instruction description will be mapped to a scheduling class. There are
end_comment

begin_comment
comment|/// four types of classes:
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// 1) An explicitly defined itinerary class with ItinClassDef set.
end_comment

begin_comment
comment|/// Writes and ReadDefs are empty. ProcIndices contains 0 for any processor.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// 2) An implied class with a list of SchedWrites and SchedReads that are
end_comment

begin_comment
comment|/// defined in an instruction definition and which are common across all
end_comment

begin_comment
comment|/// subtargets. ProcIndices contains 0 for any processor.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// 3) An implied class with a list of InstRW records that map instructions to
end_comment

begin_comment
comment|/// SchedWrites and SchedReads per-processor. InstrClassMap should map the same
end_comment

begin_comment
comment|/// instructions to this class. ProcIndices contains all the processors that
end_comment

begin_comment
comment|/// provided InstrRW records for this class. ItinClassDef or Writes/Reads may
end_comment

begin_comment
comment|/// still be defined for processors with no InstRW entry.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// 4) An inferred class represents a variant of another class that may be
end_comment

begin_comment
comment|/// resolved at runtime. ProcIndices contains the set of processors that may
end_comment

begin_comment
comment|/// require the class. ProcIndices are propagated through SchedClasses as
end_comment

begin_comment
comment|/// variants are expanded. Multiple SchedClasses may be inferred from an
end_comment

begin_comment
comment|/// itinerary class. Each inherits the processor index from the ItinRW record
end_comment

begin_comment
comment|/// that mapped the itinerary class to the variant Writes or Reads.
end_comment

begin_struct
struct|struct
name|CodeGenSchedClass
block|{
name|unsigned
name|Index
decl_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|Record
modifier|*
name|ItinClassDef
decl_stmt|;
name|IdxVec
name|Writes
decl_stmt|;
name|IdxVec
name|Reads
decl_stmt|;
comment|// Sorted list of ProcIdx, where ProcIdx==0 implies any processor.
name|IdxVec
name|ProcIndices
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenSchedTransition
operator|>
name|Transitions
expr_stmt|;
comment|// InstRW records associated with this class. These records may refer to an
comment|// Instruction no longer mapped to this class by InstrClassMap. These
comment|// Instructions should be ignored by this class because they have been split
comment|// off to join another inferred class.
name|RecVec
name|InstRWs
decl_stmt|;
name|CodeGenSchedClass
argument_list|()
operator|:
name|Index
argument_list|(
literal|0
argument_list|)
operator|,
name|ItinClassDef
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|isKeyEqual
argument_list|(
argument|Record *IC
argument_list|,
argument|const IdxVec&W
argument_list|,
argument|const IdxVec&R
argument_list|)
block|{
return|return
name|ItinClassDef
operator|==
name|IC
operator|&&
name|Writes
operator|==
name|W
operator|&&
name|Reads
operator|==
name|R
return|;
block|}
comment|// Is this class generated from a variants if existing classes? Instructions
comment|// are never mapped directly to inferred scheduling classes.
name|bool
name|isInferred
argument_list|()
specifier|const
block|{
return|return
operator|!
name|ItinClassDef
return|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|void
name|dump
argument_list|(
specifier|const
name|CodeGenSchedModels
operator|*
name|SchedModels
argument_list|)
decl|const
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|// Processor model.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ModelName is a unique name used to name an instantiation of MCSchedModel.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ModelDef is NULL for inferred Models. This happens when a processor defines
end_comment

begin_comment
comment|// an itinerary but no machine model. If the processer defines neither a machine
end_comment

begin_comment
comment|// model nor itinerary, then ModelDef remains pointing to NoModel. NoModel has
end_comment

begin_comment
comment|// the special "NoModel" field set to true.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ItinsDef always points to a valid record definition, but may point to the
end_comment

begin_comment
comment|// default NoItineraries. NoItineraries has an empty list of InstrItinData
end_comment

begin_comment
comment|// records.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ItinDefList orders this processor's InstrItinData records by SchedClass idx.
end_comment

begin_struct
struct|struct
name|CodeGenProcModel
block|{
name|unsigned
name|Index
decl_stmt|;
name|std
operator|::
name|string
name|ModelName
expr_stmt|;
name|Record
modifier|*
name|ModelDef
decl_stmt|;
name|Record
modifier|*
name|ItinsDef
decl_stmt|;
comment|// Derived members...
comment|// Array of InstrItinData records indexed by a CodeGenSchedClass index.
comment|// This list is empty if the Processor has no value for Itineraries.
comment|// Initialized by collectProcItins().
name|RecVec
name|ItinDefList
decl_stmt|;
comment|// Map itinerary classes to per-operand resources.
comment|// This list is empty if no ItinRW refers to this Processor.
name|RecVec
name|ItinRWDefs
decl_stmt|;
comment|// All read/write resources associated with this processor.
name|RecVec
name|WriteResDefs
decl_stmt|;
name|RecVec
name|ReadAdvanceDefs
decl_stmt|;
comment|// Per-operand machine model resources associated with this processor.
name|RecVec
name|ProcResourceDefs
decl_stmt|;
name|RecVec
name|ProcResGroupDefs
decl_stmt|;
name|CodeGenProcModel
argument_list|(
argument|unsigned Idx
argument_list|,
argument|const std::string&Name
argument_list|,
argument|Record *MDef
argument_list|,
argument|Record *IDef
argument_list|)
block|:
name|Index
argument_list|(
name|Idx
argument_list|)
operator|,
name|ModelName
argument_list|(
name|Name
argument_list|)
operator|,
name|ModelDef
argument_list|(
name|MDef
argument_list|)
operator|,
name|ItinsDef
argument_list|(
argument|IDef
argument_list|)
block|{}
name|bool
name|hasItineraries
argument_list|()
specifier|const
block|{
return|return
operator|!
name|ItinsDef
operator|->
name|getValueAsListOfDefs
argument_list|(
literal|"IID"
argument_list|)
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|hasInstrSchedModel
argument_list|()
specifier|const
block|{
return|return
operator|!
name|WriteResDefs
operator|.
name|empty
argument_list|()
operator|||
operator|!
name|ItinRWDefs
operator|.
name|empty
argument_list|()
return|;
block|}
name|unsigned
name|getProcResourceIdx
argument_list|(
name|Record
operator|*
name|PRDef
argument_list|)
decl|const
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/// Top level container for machine model data.
end_comment

begin_decl_stmt
name|class
name|CodeGenSchedModels
block|{
name|RecordKeeper
modifier|&
name|Records
decl_stmt|;
specifier|const
name|CodeGenTarget
modifier|&
name|Target
decl_stmt|;
comment|// Map dag expressions to Instruction lists.
name|SetTheory
name|Sets
decl_stmt|;
comment|// List of unique processor models.
name|std
operator|::
name|vector
operator|<
name|CodeGenProcModel
operator|>
name|ProcModels
expr_stmt|;
comment|// Map Processor's MachineModel or ProcItin to a CodeGenProcModel index.
typedef|typedef
name|DenseMap
operator|<
name|Record
operator|*
operator|,
name|unsigned
operator|>
name|ProcModelMapTy
expr_stmt|;
name|ProcModelMapTy
name|ProcModelMap
decl_stmt|;
comment|// Per-operand SchedReadWrite types.
name|std
operator|::
name|vector
operator|<
name|CodeGenSchedRW
operator|>
name|SchedWrites
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenSchedRW
operator|>
name|SchedReads
expr_stmt|;
comment|// List of unique SchedClasses.
name|std
operator|::
name|vector
operator|<
name|CodeGenSchedClass
operator|>
name|SchedClasses
expr_stmt|;
comment|// Any inferred SchedClass has an index greater than NumInstrSchedClassses.
name|unsigned
name|NumInstrSchedClasses
decl_stmt|;
comment|// Map each instruction to its unique SchedClass index considering the
comment|// combination of it's itinerary class, SchedRW list, and InstRW records.
typedef|typedef
name|DenseMap
operator|<
name|Record
operator|*
operator|,
name|unsigned
operator|>
name|InstClassMapTy
expr_stmt|;
name|InstClassMapTy
name|InstrClassMap
decl_stmt|;
name|public
label|:
name|CodeGenSchedModels
argument_list|(
name|RecordKeeper
operator|&
name|RK
argument_list|,
specifier|const
name|CodeGenTarget
operator|&
name|TGT
argument_list|)
expr_stmt|;
name|Record
modifier|*
name|getModelOrItinDef
argument_list|(
name|Record
operator|*
name|ProcDef
argument_list|)
decl|const
block|{
name|Record
modifier|*
name|ModelDef
init|=
name|ProcDef
operator|->
name|getValueAsDef
argument_list|(
literal|"SchedModel"
argument_list|)
decl_stmt|;
name|Record
modifier|*
name|ItinsDef
init|=
name|ProcDef
operator|->
name|getValueAsDef
argument_list|(
literal|"ProcItin"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ItinsDef
operator|->
name|getValueAsListOfDefs
argument_list|(
literal|"IID"
argument_list|)
operator|.
name|empty
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|ModelDef
operator|->
name|getValueAsBit
argument_list|(
literal|"NoModel"
argument_list|)
operator|&&
literal|"Itineraries must be defined within SchedMachineModel"
argument_list|)
expr_stmt|;
return|return
name|ItinsDef
return|;
block|}
return|return
name|ModelDef
return|;
block|}
specifier|const
name|CodeGenProcModel
modifier|&
name|getModelForProc
argument_list|(
name|Record
operator|*
name|ProcDef
argument_list|)
decl|const
block|{
name|Record
modifier|*
name|ModelDef
init|=
name|getModelOrItinDef
argument_list|(
name|ProcDef
argument_list|)
decl_stmt|;
name|ProcModelMapTy
operator|::
name|const_iterator
name|I
operator|=
name|ProcModelMap
operator|.
name|find
argument_list|(
name|ModelDef
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|ProcModelMap
operator|.
name|end
argument_list|()
operator|&&
literal|"missing machine model"
argument_list|)
expr_stmt|;
return|return
name|ProcModels
index|[
name|I
operator|->
name|second
index|]
return|;
block|}
name|CodeGenProcModel
modifier|&
name|getProcModel
parameter_list|(
name|Record
modifier|*
name|ModelDef
parameter_list|)
block|{
name|ProcModelMapTy
operator|::
name|const_iterator
name|I
operator|=
name|ProcModelMap
operator|.
name|find
argument_list|(
name|ModelDef
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|ProcModelMap
operator|.
name|end
argument_list|()
operator|&&
literal|"missing machine model"
argument_list|)
expr_stmt|;
return|return
name|ProcModels
index|[
name|I
operator|->
name|second
index|]
return|;
block|}
specifier|const
name|CodeGenProcModel
modifier|&
name|getProcModel
argument_list|(
name|Record
operator|*
name|ModelDef
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|CodeGenSchedModels
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getProcModel
argument_list|(
name|ModelDef
argument_list|)
return|;
block|}
comment|// Iterate over the unique processor models.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CodeGenProcModel
operator|>
operator|::
name|const_iterator
name|ProcIter
expr_stmt|;
name|ProcIter
name|procModelBegin
argument_list|()
specifier|const
block|{
return|return
name|ProcModels
operator|.
name|begin
argument_list|()
return|;
block|}
name|ProcIter
name|procModelEnd
argument_list|()
specifier|const
block|{
return|return
name|ProcModels
operator|.
name|end
argument_list|()
return|;
block|}
comment|// Return true if any processors have itineraries.
name|bool
name|hasItineraries
argument_list|()
specifier|const
expr_stmt|;
comment|// Get a SchedWrite from its index.
specifier|const
name|CodeGenSchedRW
modifier|&
name|getSchedWrite
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|SchedWrites
operator|.
name|size
argument_list|()
operator|&&
literal|"bad SchedWrite index"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SchedWrites
index|[
name|Idx
index|]
operator|.
name|isValid
argument_list|()
operator|&&
literal|"invalid SchedWrite"
argument_list|)
expr_stmt|;
return|return
name|SchedWrites
index|[
name|Idx
index|]
return|;
block|}
comment|// Get a SchedWrite from its index.
specifier|const
name|CodeGenSchedRW
modifier|&
name|getSchedRead
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|SchedReads
operator|.
name|size
argument_list|()
operator|&&
literal|"bad SchedRead index"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SchedReads
index|[
name|Idx
index|]
operator|.
name|isValid
argument_list|()
operator|&&
literal|"invalid SchedRead"
argument_list|)
expr_stmt|;
return|return
name|SchedReads
index|[
name|Idx
index|]
return|;
block|}
specifier|const
name|CodeGenSchedRW
modifier|&
name|getSchedRW
argument_list|(
name|unsigned
name|Idx
argument_list|,
name|bool
name|IsRead
argument_list|)
decl|const
block|{
return|return
name|IsRead
condition|?
name|getSchedRead
argument_list|(
name|Idx
argument_list|)
else|:
name|getSchedWrite
argument_list|(
name|Idx
argument_list|)
return|;
block|}
name|CodeGenSchedRW
modifier|&
name|getSchedRW
parameter_list|(
name|Record
modifier|*
name|Def
parameter_list|)
block|{
name|bool
name|IsRead
init|=
name|Def
operator|->
name|isSubClassOf
argument_list|(
literal|"SchedRead"
argument_list|)
decl_stmt|;
name|unsigned
name|Idx
init|=
name|getSchedRWIdx
argument_list|(
name|Def
argument_list|,
name|IsRead
argument_list|)
decl_stmt|;
return|return
name|const_cast
operator|<
name|CodeGenSchedRW
operator|&
operator|>
operator|(
name|IsRead
condition|?
name|getSchedRead
argument_list|(
name|Idx
argument_list|)
else|:
name|getSchedWrite
argument_list|(
name|Idx
argument_list|)
operator|)
return|;
block|}
specifier|const
name|CodeGenSchedRW
modifier|&
name|getSchedRW
argument_list|(
name|Record
operator|*
name|Def
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|CodeGenSchedModels
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
operator|.
name|getSchedRW
argument_list|(
name|Def
argument_list|)
return|;
block|}
name|unsigned
name|getSchedRWIdx
argument_list|(
name|Record
operator|*
name|Def
argument_list|,
name|bool
name|IsRead
argument_list|,
name|unsigned
name|After
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|// Return true if the given write record is referenced by a ReadAdvance.
name|bool
name|hasReadOfWrite
argument_list|(
name|Record
operator|*
name|WriteDef
argument_list|)
decl|const
decl_stmt|;
comment|// Get a SchedClass from its index.
name|CodeGenSchedClass
modifier|&
name|getSchedClass
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|SchedClasses
operator|.
name|size
argument_list|()
operator|&&
literal|"bad SchedClass index"
argument_list|)
expr_stmt|;
return|return
name|SchedClasses
index|[
name|Idx
index|]
return|;
block|}
specifier|const
name|CodeGenSchedClass
modifier|&
name|getSchedClass
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|SchedClasses
operator|.
name|size
argument_list|()
operator|&&
literal|"bad SchedClass index"
argument_list|)
expr_stmt|;
return|return
name|SchedClasses
index|[
name|Idx
index|]
return|;
block|}
comment|// Get the SchedClass index for an instruction. Instructions with no
comment|// itinerary, no SchedReadWrites, and no InstrReadWrites references return 0
comment|// for NoItinerary.
name|unsigned
name|getSchedClassIdx
argument_list|(
specifier|const
name|CodeGenInstruction
operator|&
name|Inst
argument_list|)
decl|const
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CodeGenSchedClass
operator|>
operator|::
name|const_iterator
name|SchedClassIter
expr_stmt|;
name|SchedClassIter
name|schedClassBegin
argument_list|()
specifier|const
block|{
return|return
name|SchedClasses
operator|.
name|begin
argument_list|()
return|;
block|}
name|SchedClassIter
name|schedClassEnd
argument_list|()
specifier|const
block|{
return|return
name|SchedClasses
operator|.
name|end
argument_list|()
return|;
block|}
name|unsigned
name|numInstrSchedClasses
argument_list|()
specifier|const
block|{
return|return
name|NumInstrSchedClasses
return|;
block|}
name|void
name|findRWs
argument_list|(
specifier|const
name|RecVec
operator|&
name|RWDefs
argument_list|,
name|IdxVec
operator|&
name|Writes
argument_list|,
name|IdxVec
operator|&
name|Reads
argument_list|)
decl|const
decl_stmt|;
name|void
name|findRWs
argument_list|(
specifier|const
name|RecVec
operator|&
name|RWDefs
argument_list|,
name|IdxVec
operator|&
name|RWs
argument_list|,
name|bool
name|IsRead
argument_list|)
decl|const
decl_stmt|;
name|void
name|expandRWSequence
argument_list|(
name|unsigned
name|RWIdx
argument_list|,
name|IdxVec
operator|&
name|RWSeq
argument_list|,
name|bool
name|IsRead
argument_list|)
decl|const
decl_stmt|;
name|void
name|expandRWSeqForProc
argument_list|(
name|unsigned
name|RWIdx
argument_list|,
name|IdxVec
operator|&
name|RWSeq
argument_list|,
name|bool
name|IsRead
argument_list|,
specifier|const
name|CodeGenProcModel
operator|&
name|ProcModel
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|addSchedClass
parameter_list|(
name|Record
modifier|*
name|ItinDef
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|OperWrites
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|OperReads
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|ProcIndices
parameter_list|)
function_decl|;
name|unsigned
name|findOrInsertRW
argument_list|(
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Seq
argument_list|,
name|bool
name|IsRead
argument_list|)
decl_stmt|;
name|unsigned
name|findSchedClassIdx
argument_list|(
name|Record
operator|*
name|ItinClassDef
argument_list|,
specifier|const
name|IdxVec
operator|&
name|Writes
argument_list|,
specifier|const
name|IdxVec
operator|&
name|Reads
argument_list|)
decl|const
decl_stmt|;
name|Record
modifier|*
name|findProcResUnits
argument_list|(
name|Record
operator|*
name|ProcResKind
argument_list|,
specifier|const
name|CodeGenProcModel
operator|&
name|PM
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
name|void
name|collectProcModels
parameter_list|()
function_decl|;
comment|// Initialize a new processor model if it is unique.
name|void
name|addProcModel
parameter_list|(
name|Record
modifier|*
name|ProcDef
parameter_list|)
function_decl|;
name|void
name|collectSchedRW
parameter_list|()
function_decl|;
name|std
operator|::
name|string
name|genRWName
argument_list|(
argument|const IdxVec& Seq
argument_list|,
argument|bool IsRead
argument_list|)
expr_stmt|;
name|unsigned
name|findRWForSequence
parameter_list|(
specifier|const
name|IdxVec
modifier|&
name|Seq
parameter_list|,
name|bool
name|IsRead
parameter_list|)
function_decl|;
name|void
name|collectSchedClasses
parameter_list|()
function_decl|;
name|std
operator|::
name|string
name|createSchedClassName
argument_list|(
name|Record
operator|*
name|ItinClassDef
argument_list|,
specifier|const
name|IdxVec
operator|&
name|OperWrites
argument_list|,
specifier|const
name|IdxVec
operator|&
name|OperReads
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|createSchedClassName
argument_list|(
specifier|const
name|RecVec
operator|&
name|InstDefs
argument_list|)
expr_stmt|;
name|void
name|createInstRWClass
parameter_list|(
name|Record
modifier|*
name|InstRWDef
parameter_list|)
function_decl|;
name|void
name|collectProcItins
parameter_list|()
function_decl|;
name|void
name|collectProcItinRW
parameter_list|()
function_decl|;
name|void
name|inferSchedClasses
parameter_list|()
function_decl|;
name|void
name|inferFromRW
parameter_list|(
specifier|const
name|IdxVec
modifier|&
name|OperWrites
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|OperReads
parameter_list|,
name|unsigned
name|FromClassIdx
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|ProcIndices
parameter_list|)
function_decl|;
name|void
name|inferFromItinClass
parameter_list|(
name|Record
modifier|*
name|ItinClassDef
parameter_list|,
name|unsigned
name|FromClassIdx
parameter_list|)
function_decl|;
name|void
name|inferFromInstRWs
parameter_list|(
name|unsigned
name|SCIdx
parameter_list|)
function_decl|;
name|bool
name|hasSuperGroup
parameter_list|(
name|RecVec
modifier|&
name|SubUnits
parameter_list|,
name|CodeGenProcModel
modifier|&
name|PM
parameter_list|)
function_decl|;
name|void
name|verifyProcResourceGroups
parameter_list|(
name|CodeGenProcModel
modifier|&
name|PM
parameter_list|)
function_decl|;
name|void
name|collectProcResources
parameter_list|()
function_decl|;
name|void
name|collectItinProcResources
parameter_list|(
name|Record
modifier|*
name|ItinClassDef
parameter_list|)
function_decl|;
name|void
name|collectRWResources
parameter_list|(
name|unsigned
name|RWIdx
parameter_list|,
name|bool
name|IsRead
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|ProcIndices
parameter_list|)
function_decl|;
name|void
name|collectRWResources
parameter_list|(
specifier|const
name|IdxVec
modifier|&
name|Writes
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|Reads
parameter_list|,
specifier|const
name|IdxVec
modifier|&
name|ProcIndices
parameter_list|)
function_decl|;
name|void
name|addProcResource
parameter_list|(
name|Record
modifier|*
name|ProcResourceKind
parameter_list|,
name|CodeGenProcModel
modifier|&
name|PM
parameter_list|)
function_decl|;
name|void
name|addWriteRes
parameter_list|(
name|Record
modifier|*
name|ProcWriteResDef
parameter_list|,
name|unsigned
name|PIdx
parameter_list|)
function_decl|;
name|void
name|addReadAdvance
parameter_list|(
name|Record
modifier|*
name|ProcReadAdvanceDef
parameter_list|,
name|unsigned
name|PIdx
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

