begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------------------------------- unwind.h -----------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// C++ ABI Level 1 ABI documented at:
end_comment

begin_comment
comment|//   http://mentorembedded.github.io/cxx-abi/abi-eh.html
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__UNWIND_H__
end_ifndef

begin_define
define|#
directive|define
name|__UNWIND_H__
end_define

begin_include
include|#
directive|include
file|<__libunwind_config.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|LIBUNWIND_UNAVAIL
value|__attribute__ (( unavailable ))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBUNWIND_UNAVAIL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|_URC_NO_REASON
init|=
literal|0
block|,
name|_URC_OK
init|=
literal|0
block|,
name|_URC_FOREIGN_EXCEPTION_CAUGHT
init|=
literal|1
block|,
name|_URC_FATAL_PHASE2_ERROR
init|=
literal|2
block|,
name|_URC_FATAL_PHASE1_ERROR
init|=
literal|3
block|,
name|_URC_NORMAL_STOP
init|=
literal|4
block|,
name|_URC_END_OF_STACK
init|=
literal|5
block|,
name|_URC_HANDLER_FOUND
init|=
literal|6
block|,
name|_URC_INSTALL_CONTEXT
init|=
literal|7
block|,
name|_URC_CONTINUE_UNWIND
init|=
literal|8
block|,
if|#
directive|if
name|_LIBUNWIND_ARM_EHABI
name|_URC_FAILURE
init|=
literal|9
endif|#
directive|endif
block|}
name|_Unwind_Reason_Code
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|_UA_SEARCH_PHASE
init|=
literal|1
block|,
name|_UA_CLEANUP_PHASE
init|=
literal|2
block|,
name|_UA_HANDLER_FRAME
init|=
literal|4
block|,
name|_UA_FORCE_UNWIND
init|=
literal|8
block|,
name|_UA_END_OF_STACK
init|=
literal|16
comment|// gcc extension to C++ ABI
block|}
name|_Unwind_Action
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_Unwind_Context
name|_Unwind_Context
typedef|;
end_typedef

begin_comment
comment|// opaque
end_comment

begin_if
if|#
directive|if
name|_LIBUNWIND_ARM_EHABI
end_if

begin_typedef
typedef|typedef
name|uint32_t
name|_Unwind_State
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|_Unwind_State
name|_US_VIRTUAL_UNWIND_FRAME
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|_Unwind_State
name|_US_UNWIND_FRAME_STARTING
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|_Unwind_State
name|_US_UNWIND_FRAME_RESUME
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Undocumented flag for force unwinding. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|_Unwind_State
name|_US_FORCE_UNWIND
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|uint32_t
name|_Unwind_EHT_Header
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|_Unwind_Control_Block
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|_Unwind_Control_Block
name|_Unwind_Control_Block
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_Unwind_Control_Block
name|_Unwind_Exception
typedef|;
end_typedef

begin_comment
comment|/* Alias */
end_comment

begin_struct
struct|struct
name|_Unwind_Control_Block
block|{
name|uint64_t
name|exception_class
decl_stmt|;
name|void
function_decl|(
modifier|*
name|exception_cleanup
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|)
function_decl|;
comment|/* Unwinder cache, private fields for the unwinder's use */
struct|struct
block|{
name|uint32_t
name|reserved1
decl_stmt|;
comment|/* init reserved1 to 0, then don't touch */
name|uint32_t
name|reserved2
decl_stmt|;
name|uint32_t
name|reserved3
decl_stmt|;
name|uint32_t
name|reserved4
decl_stmt|;
name|uint32_t
name|reserved5
decl_stmt|;
block|}
name|unwinder_cache
struct|;
comment|/* Propagation barrier cache (valid after phase 1): */
struct|struct
block|{
name|uint32_t
name|sp
decl_stmt|;
name|uint32_t
name|bitpattern
index|[
literal|5
index|]
decl_stmt|;
block|}
name|barrier_cache
struct|;
comment|/* Cleanup cache (preserved over cleanup): */
struct|struct
block|{
name|uint32_t
name|bitpattern
index|[
literal|4
index|]
decl_stmt|;
block|}
name|cleanup_cache
struct|;
comment|/* Pr cache (for pr's benefit): */
struct|struct
block|{
name|uint32_t
name|fnstart
decl_stmt|;
comment|/* function start address */
name|_Unwind_EHT_Header
modifier|*
name|ehtp
decl_stmt|;
comment|/* pointer to EHT entry header word */
name|uint32_t
name|additional
decl_stmt|;
name|uint32_t
name|reserved1
decl_stmt|;
block|}
name|pr_cache
struct|;
name|long
name|long
name|int
range|:
literal|0
decl_stmt|;
comment|/* Enforce the 8-byte alignment */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Stop_Fn
function_decl|)
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exceptionObject
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|__personality_routine
function_decl|)
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exceptionObject
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_struct_decl
struct_decl|struct
name|_Unwind_Context
struct_decl|;
end_struct_decl

begin_comment
comment|// opaque
end_comment

begin_struct_decl
struct_decl|struct
name|_Unwind_Exception
struct_decl|;
end_struct_decl

begin_comment
comment|// forward declaration
end_comment

begin_typedef
typedef|typedef
name|struct
name|_Unwind_Exception
name|_Unwind_Exception
typedef|;
end_typedef

begin_struct
struct|struct
name|_Unwind_Exception
block|{
name|uint64_t
name|exception_class
decl_stmt|;
name|void
function_decl|(
modifier|*
name|exception_cleanup
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
name|reason
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exc
parameter_list|)
function_decl|;
name|uintptr_t
name|private_1
decl_stmt|;
comment|// non-zero means forced unwind
name|uintptr_t
name|private_2
decl_stmt|;
comment|// holds sp that phase1 found for phase2 to use
ifndef|#
directive|ifndef
name|__LP64__
comment|// The gcc implementation of _Unwind_Exception used attribute mode on the
comment|// above fields which had the side effect of causing this whole struct to
comment|// round up to 32 bytes in size. To be more explicit, we add pad fields
comment|// added for binary compatibility.
name|uint32_t
name|reserved
index|[
literal|3
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|__attribute__
argument_list|(
operator|(
name|__aligned__
operator|)
argument_list|)
struct|;
end_struct

begin_typedef
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Stop_Fn
function_decl|)
parameter_list|(
name|int
name|version
parameter_list|,
name|_Unwind_Action
name|actions
parameter_list|,
name|uint64_t
name|exceptionClass
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exceptionObject
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|stop_parameter
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|__personality_routine
function_decl|)
parameter_list|(
name|int
name|version
parameter_list|,
name|_Unwind_Action
name|actions
parameter_list|,
name|uint64_t
name|exceptionClass
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exceptionObject
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|//
comment|// The following are the base functions documented by the C++ ABI
comment|//
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_RaiseException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SjLj_Resume
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_RaiseException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_Resume
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|extern
name|void
name|_Unwind_DeleteException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
if|#
directive|if
name|_LIBUNWIND_ARM_EHABI
typedef|typedef
enum|enum
block|{
name|_UVRSC_CORE
init|=
literal|0
block|,
comment|/* integer register */
name|_UVRSC_VFP
init|=
literal|1
block|,
comment|/* vfp */
name|_UVRSC_WMMXD
init|=
literal|3
block|,
comment|/* Intel WMMX data register */
name|_UVRSC_WMMXC
init|=
literal|4
comment|/* Intel WMMX control register */
block|}
name|_Unwind_VRS_RegClass
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSD_UINT32
init|=
literal|0
block|,
name|_UVRSD_VFPX
init|=
literal|1
block|,
name|_UVRSD_UINT64
init|=
literal|3
block|,
name|_UVRSD_FLOAT
init|=
literal|4
block|,
name|_UVRSD_DOUBLE
init|=
literal|5
block|}
name|_Unwind_VRS_DataRepresentation
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSR_OK
init|=
literal|0
block|,
name|_UVRSR_NOT_IMPLEMENTED
init|=
literal|1
block|,
name|_UVRSR_FAILED
init|=
literal|2
block|}
name|_Unwind_VRS_Result
typedef|;
specifier|extern
name|void
name|_Unwind_Complete
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_VRS_Result
name|_Unwind_VRS_Get
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|uint32_t
name|regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_VRS_Result
name|_Unwind_VRS_Set
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|uint32_t
name|regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_VRS_Result
name|_Unwind_VRS_Pop
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|uint32_t
name|discriminator
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|)
function_decl|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|_LIBUNWIND_ARM_EHABI
specifier|extern
name|uintptr_t
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|new_value
parameter_list|)
function_decl|;
specifier|extern
name|uintptr_t
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|uintptr_t
name|new_value
parameter_list|)
function_decl|;
else|#
directive|else
comment|// _LIBUNWIND_ARM_EHABI
if|#
directive|if
name|defined
argument_list|(
name|_LIBUNWIND_UNWIND_LEVEL1_EXTERNAL_LINKAGE
argument_list|)
define|#
directive|define
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
value|extern
else|#
directive|else
define|#
directive|define
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
value|static __inline__
endif|#
directive|endif
comment|// These are de facto helper functions for ARM, which delegate the function
comment|// calls to _Unwind_VRS_Get/Set().  These are not a part of ARM EHABI
comment|// specification, thus these function MUST be inlined.  Please don't replace
comment|// these with the "extern" function declaration; otherwise, the program
comment|// including this<unwind.h> header won't be ABI compatible and will result in
comment|// link error when we are linking the program with libgcc.
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
name|uintptr_t
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|uintptr_t
name|value
init|=
literal|0
decl_stmt|;
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
operator|(
name|uint32_t
operator|)
name|index
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
operator|(
name|uint32_t
operator|)
name|index
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
name|uintptr_t
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
comment|// remove the thumb-bit before returning
return|return
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|)
return|;
block|}
name|_LIBUNWIND_EXPORT_UNWIND_LEVEL1
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|uintptr_t
name|thumb_bit
init|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|)
operator|&
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|)
decl_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|,
name|value
operator||
name|thumb_bit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// _LIBUNWIND_ARM_EHABI
specifier|extern
name|uintptr_t
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
specifier|extern
name|uintptr_t
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_ForcedUnwind
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|,
name|_Unwind_Stop_Fn
name|stop
parameter_list|,
name|void
modifier|*
name|stop_parameter
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|,
name|_Unwind_Stop_Fn
name|stop
parameter_list|,
name|void
modifier|*
name|stop_parameter
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
typedef|typedef
name|struct
name|_Unwind_FunctionContext
modifier|*
name|_Unwind_FunctionContext_t
typedef|;
specifier|extern
name|void
name|_Unwind_SjLj_Register
parameter_list|(
name|_Unwind_FunctionContext_t
name|fc
parameter_list|)
function_decl|;
specifier|extern
name|void
name|_Unwind_SjLj_Unregister
parameter_list|(
name|_Unwind_FunctionContext_t
name|fc
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|//
comment|// The following are semi-suppoted extensions to the C++ ABI
comment|//
comment|//
comment|//  called by __cxa_rethrow().
comment|//
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_SjLj_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|// _Unwind_Backtrace() is a gcc extension that walks the stack and calls the
comment|// _Unwind_Trace_Fn once per frame until it reaches the bottom of the stack
comment|// or the _Unwind_Trace_Fn function returns something other than _URC_NO_REASON.
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Trace_Fn
function_decl|)
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|_Unwind_Reason_Code
name|_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|// _Unwind_GetCFA is a gcc extension that can be called from within a
comment|// personality handler to get the CFA (stack pointer before call) of
comment|// current frame.
specifier|extern
name|uintptr_t
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|// _Unwind_GetIPInfo is a gcc extension that can be called from within a
comment|// personality handler.  Similar to _Unwind_GetIP() but also returns in
comment|// *ipBefore a non-zero value if the instruction pointer is at or before the
comment|// instruction causing the unwind. Normally, in a function call, the IP returned
comment|// is the return address which is after the call instruction and may be past the
comment|// end of the function containing the call instruction.
specifier|extern
name|uintptr_t
name|_Unwind_GetIPInfo
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
modifier|*
name|ipBefore
parameter_list|)
function_decl|;
comment|// __register_frame() is used with dynamically generated code to register the
comment|// FDE for a generated (JIT) code.  The FDE must use pc-rel addressing to point
comment|// to its function and optional LSDA.
comment|// __register_frame() has existed in all versions of Mac OS X, but in 10.4 and
comment|// 10.5 it was buggy and did not actually register the FDE with the unwinder.
comment|// In 10.6 and later it does register properly.
specifier|extern
name|void
name|__register_frame
parameter_list|(
specifier|const
name|void
modifier|*
name|fde
parameter_list|)
function_decl|;
specifier|extern
name|void
name|__deregister_frame
parameter_list|(
specifier|const
name|void
modifier|*
name|fde
parameter_list|)
function_decl|;
comment|// _Unwind_Find_FDE() will locate the FDE if the pc is in some function that has
comment|// an associated FDE. Note, Mac OS X 10.6 and later, introduces "compact unwind
comment|// info" which the runtime uses in preference to dwarf unwind info.  This
comment|// function will only work if the target function has an FDE but no compact
comment|// unwind info.
struct|struct
name|dwarf_eh_bases
block|{
name|uintptr_t
name|tbase
decl_stmt|;
name|uintptr_t
name|dbase
decl_stmt|;
name|uintptr_t
name|func
decl_stmt|;
block|}
struct|;
specifier|extern
specifier|const
name|void
modifier|*
name|_Unwind_Find_FDE
parameter_list|(
specifier|const
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
parameter_list|)
function_decl|;
comment|// This function attempts to find the start (address of first instruction) of
comment|// a function given an address inside the function.  It only works if the
comment|// function has an FDE (dwarf unwind info).
comment|// This function is unimplemented on Mac OS X 10.6 and later.  Instead, use
comment|// _Unwind_Find_FDE() and look at the dwarf_eh_bases.func result.
specifier|extern
name|void
modifier|*
name|_Unwind_FindEnclosingFunction
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|)
function_decl|;
comment|// Mac OS X does not support text-rel and data-rel addressing so these functions
comment|// are unimplemented
specifier|extern
name|uintptr_t
name|_Unwind_GetDataRelBase
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|uintptr_t
name|_Unwind_GetTextRelBase
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
comment|// Mac OS X 10.4 and 10.5 had implementations of these functions in
comment|// libgcc_s.dylib, but they never worked.
comment|/// These functions are no longer available on Mac OS X.
specifier|extern
name|void
name|__register_frame_info_bases
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|,
name|void
operator|*
name|ob
argument_list|,
name|void
operator|*
name|tb
argument_list|,
name|void
operator|*
name|db
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
name|__register_frame_info
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|,
name|void
operator|*
name|ob
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
name|__register_frame_info_table_bases
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|,
name|void
operator|*
name|ob
argument_list|,
name|void
operator|*
name|tb
argument_list|,
name|void
operator|*
name|db
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
name|__register_frame_info_table
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|,
name|void
operator|*
name|ob
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
name|__register_frame_table
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
modifier|*
name|__deregister_frame_info
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
specifier|extern
name|void
modifier|*
name|__deregister_frame_info_bases
argument_list|(
specifier|const
name|void
operator|*
name|fde
argument_list|)
name|LIBUNWIND_UNAVAIL
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// __UNWIND_H__
end_comment

end_unit

