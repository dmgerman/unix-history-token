begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------------------------- UnwindLevel1.c -----------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Implements C++ ABI Exception Handling Level 1 as documented at:
end_comment

begin_comment
comment|//      http://mentorembedded.github.io/cxx-abi/abi-eh.html
end_comment

begin_comment
comment|// using libunwind
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// ARM EHABI does not specify _Unwind_{Get,Set}{GR,IP}().  Thus, we are
end_comment

begin_comment
comment|// defining inline functions to delegate the function calls to
end_comment

begin_comment
comment|// _Unwind_VRS_{Get,Set}().  However, some applications might declare the
end_comment

begin_comment
comment|// function protetype directly (instead of including<unwind.h>), thus we need
end_comment

begin_comment
comment|// to export these functions from libunwind.so as well.
end_comment

begin_define
define|#
directive|define
name|_LIBUNWIND_UNWIND_LEVEL1_EXTERNAL_LINKAGE
value|1
end_define

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"libunwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
operator|!
name|_LIBUNWIND_ARM_EHABI
end_if

begin_function
specifier|static
name|_Unwind_Reason_Code
name|unwind_phase1
parameter_list|(
name|unw_context_t
modifier|*
name|uc
parameter_list|,
name|unw_cursor_t
modifier|*
name|cursor
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
block|{
name|unw_init_local
argument_list|(
name|cursor
argument_list|,
name|uc
argument_list|)
expr_stmt|;
comment|// Walk each frame looking for a place to stop.
name|bool
name|handlerNotFound
init|=
name|true
decl_stmt|;
while|while
condition|(
name|handlerNotFound
condition|)
block|{
comment|// Ask libuwind to get next frame (skip over first which is
comment|// _Unwind_RaiseException).
name|int
name|stepResult
init|=
name|unw_step
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|stepResult
operator|==
literal|0
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): unw_step() reached "
literal|"bottom => _URC_END_OF_STACK\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_END_OF_STACK
return|;
block|}
elseif|else
if|if
condition|(
name|stepResult
operator|<
literal|0
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): unw_step failed => "
literal|"_URC_FATAL_PHASE1_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
block|}
comment|// See if frame has code to run (has personality routine).
name|unw_proc_info_t
name|frameInfo
decl_stmt|;
name|unw_word_t
name|sp
decl_stmt|;
if|if
condition|(
name|unw_get_proc_info
argument_list|(
name|cursor
argument_list|,
operator|&
name|frameInfo
argument_list|)
operator|!=
name|UNW_ESUCCESS
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): unw_get_proc_info "
literal|"failed => _URC_FATAL_PHASE1_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
block|}
comment|// When tracing, print state information.
if|if
condition|(
name|_LIBUNWIND_TRACING_UNWINDING
condition|)
block|{
name|char
name|functionBuf
index|[
literal|512
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionName
init|=
name|functionBuf
decl_stmt|;
name|unw_word_t
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|unw_get_proc_name
argument_list|(
name|cursor
argument_list|,
name|functionBuf
argument_list|,
sizeof|sizeof
argument_list|(
name|functionBuf
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
name|UNW_ESUCCESS
operator|)
operator|||
operator|(
name|frameInfo
operator|.
name|start_ip
operator|+
name|offset
operator|>
name|frameInfo
operator|.
name|end_ip
operator|)
condition|)
name|functionName
operator|=
literal|".anonymous."
expr_stmt|;
name|unw_word_t
name|pc
decl_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_IP
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): pc=0x%"
name|PRIx64
literal|", start_ip=0x%"
name|PRIx64
literal|", func=%s, lsda=0x%"
name|PRIx64
literal|", personality=0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|pc
argument_list|,
name|frameInfo
operator|.
name|start_ip
argument_list|,
name|functionName
argument_list|,
name|frameInfo
operator|.
name|lsda
argument_list|,
name|frameInfo
operator|.
name|handler
argument_list|)
expr_stmt|;
block|}
comment|// If there is a personality routine, ask it if it will want to stop at
comment|// this frame.
if|if
condition|(
name|frameInfo
operator|.
name|handler
operator|!=
literal|0
condition|)
block|{
name|__personality_routine
name|p
init|=
call|(
name|__personality_routine
call|)
argument_list|(
name|long
argument_list|)
argument_list|(
name|frameInfo
operator|.
name|handler
argument_list|)
decl_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): calling personality function %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|p
argument_list|)
expr_stmt|;
name|_Unwind_Reason_Code
name|personalityResult
init|=
call|(
modifier|*
name|p
call|)
argument_list|(
literal|1
argument_list|,
name|_UA_SEARCH_PHASE
argument_list|,
name|exception_object
operator|->
name|exception_class
argument_list|,
name|exception_object
argument_list|,
operator|(
expr|struct
name|_Unwind_Context
operator|*
operator|)
operator|(
name|cursor
operator|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|personalityResult
condition|)
block|{
case|case
name|_URC_HANDLER_FOUND
case|:
comment|// found a catch clause or locals that need destructing in this frame
comment|// stop search and remember stack pointer at the frame
name|handlerNotFound
operator|=
name|false
expr_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_SP
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|exception_object
operator|->
name|private_2
operator|=
operator|(
name|uintptr_t
operator|)
name|sp
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): _URC_HANDLER_FOUND \n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
case|case
name|_URC_CONTINUE_UNWIND
case|:
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): _URC_CONTINUE_UNWIND\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
comment|// continue unwinding
break|break;
default|default:
comment|// something went wrong
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase1(ex_ojb=%p): _URC_FATAL_PHASE1_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
block|}
block|}
block|}
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_function
specifier|static
name|_Unwind_Reason_Code
name|unwind_phase2
parameter_list|(
name|unw_context_t
modifier|*
name|uc
parameter_list|,
name|unw_cursor_t
modifier|*
name|cursor
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
block|{
name|unw_init_local
argument_list|(
name|cursor
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
comment|// Walk each frame until we reach where search phase said to stop.
while|while
condition|(
name|true
condition|)
block|{
comment|// Ask libuwind to get next frame (skip over first which is
comment|// _Unwind_RaiseException).
name|int
name|stepResult
init|=
name|unw_step
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|stepResult
operator|==
literal|0
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): unw_step() reached "
literal|"bottom => _URC_END_OF_STACK\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_END_OF_STACK
return|;
block|}
elseif|else
if|if
condition|(
name|stepResult
operator|<
literal|0
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): unw_step failed => "
literal|"_URC_FATAL_PHASE1_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
comment|// Get info about this frame.
name|unw_word_t
name|sp
decl_stmt|;
name|unw_proc_info_t
name|frameInfo
decl_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_SP
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_get_proc_info
argument_list|(
name|cursor
argument_list|,
operator|&
name|frameInfo
argument_list|)
operator|!=
name|UNW_ESUCCESS
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): unw_get_proc_info "
literal|"failed => _URC_FATAL_PHASE1_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
comment|// When tracing, print state information.
if|if
condition|(
name|_LIBUNWIND_TRACING_UNWINDING
condition|)
block|{
name|char
name|functionBuf
index|[
literal|512
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionName
init|=
name|functionBuf
decl_stmt|;
name|unw_word_t
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|unw_get_proc_name
argument_list|(
name|cursor
argument_list|,
name|functionBuf
argument_list|,
sizeof|sizeof
argument_list|(
name|functionBuf
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
name|UNW_ESUCCESS
operator|)
operator|||
operator|(
name|frameInfo
operator|.
name|start_ip
operator|+
name|offset
operator|>
name|frameInfo
operator|.
name|end_ip
operator|)
condition|)
name|functionName
operator|=
literal|".anonymous."
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): start_ip=0x%"
name|PRIx64
literal|", func=%s, sp=0x%"
name|PRIx64
literal|", lsda=0x%"
name|PRIx64
literal|", personality=0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|frameInfo
operator|.
name|start_ip
argument_list|,
name|functionName
argument_list|,
name|sp
argument_list|,
name|frameInfo
operator|.
name|lsda
argument_list|,
name|frameInfo
operator|.
name|handler
argument_list|)
expr_stmt|;
block|}
comment|// If there is a personality routine, tell it we are unwinding.
if|if
condition|(
name|frameInfo
operator|.
name|handler
operator|!=
literal|0
condition|)
block|{
name|__personality_routine
name|p
init|=
call|(
name|__personality_routine
call|)
argument_list|(
name|long
argument_list|)
argument_list|(
name|frameInfo
operator|.
name|handler
argument_list|)
decl_stmt|;
name|_Unwind_Action
name|action
init|=
name|_UA_CLEANUP_PHASE
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|exception_object
operator|->
name|private_2
condition|)
block|{
comment|// Tell personality this was the frame it marked in phase 1.
name|action
operator|=
call|(
name|_Unwind_Action
call|)
argument_list|(
name|_UA_CLEANUP_PHASE
operator||
name|_UA_HANDLER_FRAME
argument_list|)
expr_stmt|;
block|}
name|_Unwind_Reason_Code
name|personalityResult
init|=
call|(
modifier|*
name|p
call|)
argument_list|(
literal|1
argument_list|,
name|action
argument_list|,
name|exception_object
operator|->
name|exception_class
argument_list|,
name|exception_object
argument_list|,
operator|(
expr|struct
name|_Unwind_Context
operator|*
operator|)
operator|(
name|cursor
operator|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|personalityResult
condition|)
block|{
case|case
name|_URC_CONTINUE_UNWIND
case|:
comment|// Continue unwinding
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): _URC_CONTINUE_UNWIND\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|exception_object
operator|->
name|private_2
condition|)
block|{
comment|// Phase 1 said we would stop at this frame, but we did not...
name|_LIBUNWIND_ABORT
argument_list|(
literal|"during phase1 personality function said it would "
literal|"stop here, but now in phase2 it did not stop here"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_URC_INSTALL_CONTEXT
case|:
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): _URC_INSTALL_CONTEXT\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
comment|// Personality routine says to transfer control to landing pad.
comment|// We may get control back if landing pad calls _Unwind_Resume().
if|if
condition|(
name|_LIBUNWIND_TRACING_UNWINDING
condition|)
block|{
name|unw_word_t
name|pc
decl_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_IP
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_SP
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2(ex_ojb=%p): re-entering "
literal|"user code with ip=0x%"
name|PRIx64
literal|", sp=0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|pc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|unw_resume
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
comment|// unw_resume() only returns if there was an error.
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
default|default:
comment|// Personality routine returned an unknown result code.
name|_LIBUNWIND_DEBUG_LOG
argument_list|(
literal|"personality function returned unknown result %d"
argument_list|,
name|personalityResult
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
block|}
block|}
comment|// Clean up phase did not resume at the frame that the search phase
comment|// said it would...
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|_Unwind_Reason_Code
name|unwind_phase2_forced
parameter_list|(
name|unw_context_t
modifier|*
name|uc
parameter_list|,
name|unw_cursor_t
modifier|*
name|cursor
parameter_list|,
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|,
name|_Unwind_Stop_Fn
name|stop
parameter_list|,
name|void
modifier|*
name|stop_parameter
parameter_list|)
block|{
name|unw_init_local
argument_list|(
name|cursor
argument_list|,
name|uc
argument_list|)
expr_stmt|;
comment|// Walk each frame until we reach where search phase said to stop
while|while
condition|(
name|unw_step
argument_list|(
name|cursor
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// Update info about this frame.
name|unw_proc_info_t
name|frameInfo
decl_stmt|;
if|if
condition|(
name|unw_get_proc_info
argument_list|(
name|cursor
argument_list|,
operator|&
name|frameInfo
argument_list|)
operator|!=
name|UNW_ESUCCESS
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): unw_step "
literal|"failed => _URC_END_OF_STACK\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
comment|// When tracing, print state information.
if|if
condition|(
name|_LIBUNWIND_TRACING_UNWINDING
condition|)
block|{
name|char
name|functionBuf
index|[
literal|512
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionName
init|=
name|functionBuf
decl_stmt|;
name|unw_word_t
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|unw_get_proc_name
argument_list|(
name|cursor
argument_list|,
name|functionBuf
argument_list|,
sizeof|sizeof
argument_list|(
name|functionBuf
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
name|UNW_ESUCCESS
operator|)
operator|||
operator|(
name|frameInfo
operator|.
name|start_ip
operator|+
name|offset
operator|>
name|frameInfo
operator|.
name|end_ip
operator|)
condition|)
name|functionName
operator|=
literal|".anonymous."
expr_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): start_ip=0x%"
name|PRIx64
literal|", func=%s, lsda=0x%"
name|PRIx64
literal|", personality=0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|frameInfo
operator|.
name|start_ip
argument_list|,
name|functionName
argument_list|,
name|frameInfo
operator|.
name|lsda
argument_list|,
name|frameInfo
operator|.
name|handler
argument_list|)
expr_stmt|;
block|}
comment|// Call stop function at each frame.
name|_Unwind_Action
name|action
init|=
call|(
name|_Unwind_Action
call|)
argument_list|(
name|_UA_FORCE_UNWIND
operator||
name|_UA_CLEANUP_PHASE
argument_list|)
decl_stmt|;
name|_Unwind_Reason_Code
name|stopResult
init|=
call|(
modifier|*
name|stop
call|)
argument_list|(
literal|1
argument_list|,
name|action
argument_list|,
name|exception_object
operator|->
name|exception_class
argument_list|,
name|exception_object
argument_list|,
operator|(
expr|struct
name|_Unwind_Context
operator|*
operator|)
operator|(
name|cursor
operator|)
argument_list|,
name|stop_parameter
argument_list|)
decl_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): stop function returned %d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|stopResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopResult
operator|!=
name|_URC_NO_REASON
condition|)
block|{
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): stopped by stop function\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
comment|// If there is a personality routine, tell it we are unwinding.
if|if
condition|(
name|frameInfo
operator|.
name|handler
operator|!=
literal|0
condition|)
block|{
name|__personality_routine
name|p
init|=
call|(
name|__personality_routine
call|)
argument_list|(
name|long
argument_list|)
argument_list|(
name|frameInfo
operator|.
name|handler
argument_list|)
decl_stmt|;
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): calling personality function %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|p
argument_list|)
expr_stmt|;
name|_Unwind_Reason_Code
name|personalityResult
init|=
call|(
modifier|*
name|p
call|)
argument_list|(
literal|1
argument_list|,
name|action
argument_list|,
name|exception_object
operator|->
name|exception_class
argument_list|,
name|exception_object
argument_list|,
operator|(
expr|struct
name|_Unwind_Context
operator|*
operator|)
operator|(
name|cursor
operator|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|personalityResult
condition|)
block|{
case|case
name|_URC_CONTINUE_UNWIND
case|:
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): "
literal|"personality returned "
literal|"_URC_CONTINUE_UNWIND\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
comment|// Destructors called, continue unwinding
break|break;
case|case
name|_URC_INSTALL_CONTEXT
case|:
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): "
literal|"personality returned "
literal|"_URC_INSTALL_CONTEXT\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
comment|// We may get control back if landing pad calls _Unwind_Resume().
name|unw_resume
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Personality routine returned an unknown result code.
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): "
literal|"personality returned %d, "
literal|"_URC_FATAL_PHASE2_ERROR\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
name|personalityResult
argument_list|)
expr_stmt|;
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
block|}
block|}
comment|// Call stop function one last time and tell it we've reached the end
comment|// of the stack.
name|_LIBUNWIND_TRACE_UNWINDING
argument_list|(
literal|"unwind_phase2_forced(ex_ojb=%p): calling stop "
literal|"function with _UA_END_OF_STACK\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
name|_Unwind_Action
name|lastAction
init|=
call|(
name|_Unwind_Action
call|)
argument_list|(
name|_UA_FORCE_UNWIND
operator||
name|_UA_CLEANUP_PHASE
operator||
name|_UA_END_OF_STACK
argument_list|)
decl_stmt|;
call|(
modifier|*
name|stop
call|)
argument_list|(
literal|1
argument_list|,
name|lastAction
argument_list|,
name|exception_object
operator|->
name|exception_class
argument_list|,
name|exception_object
argument_list|,
operator|(
expr|struct
name|_Unwind_Context
operator|*
operator|)
operator|(
name|cursor
operator|)
argument_list|,
name|stop_parameter
argument_list|)
expr_stmt|;
comment|// Clean up phase did not resume at the frame that the search phase said it
comment|// would.
return|return
name|_URC_FATAL_PHASE2_ERROR
return|;
block|}
end_function

begin_comment
comment|/// Called by __cxa_throw.  Only returns if there is a fatal error.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|_Unwind_Reason_Code
name|_Unwind_RaiseException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_RaiseException(ex_obj=%p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
name|unw_context_t
name|uc
decl_stmt|;
name|unw_cursor_t
name|cursor
decl_stmt|;
name|unw_getcontext
argument_list|(
operator|&
name|uc
argument_list|)
expr_stmt|;
comment|// Mark that this is a non-forced unwind, so _Unwind_Resume()
comment|// can do the right thing.
name|exception_object
operator|->
name|private_1
operator|=
literal|0
expr_stmt|;
name|exception_object
operator|->
name|private_2
operator|=
literal|0
expr_stmt|;
comment|// phase 1: the search phase
name|_Unwind_Reason_Code
name|phase1
init|=
name|unwind_phase1
argument_list|(
operator|&
name|uc
argument_list|,
operator|&
name|cursor
argument_list|,
name|exception_object
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase1
operator|!=
name|_URC_NO_REASON
condition|)
return|return
name|phase1
return|;
comment|// phase 2: the clean up phase
return|return
name|unwind_phase2
argument_list|(
operator|&
name|uc
argument_list|,
operator|&
name|cursor
argument_list|,
name|exception_object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// When _Unwind_RaiseException() is in phase2, it hands control
end_comment

begin_comment
comment|/// to the personality function at each frame.  The personality
end_comment

begin_comment
comment|/// may force a jump to a landing pad in that function, the landing
end_comment

begin_comment
comment|/// pad code may then call _Unwind_Resume() to continue with the
end_comment

begin_comment
comment|/// unwinding.  Note: the call to _Unwind_Resume() is from compiler
end_comment

begin_comment
comment|/// geneated user code.  All other _Unwind_* routines are called
end_comment

begin_comment
comment|/// by the C++ runtime __cxa_* routines.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note: re-throwing an exception (as opposed to continuing the unwind)
end_comment

begin_comment
comment|/// is implemented by having the code call __cxa_rethrow() which
end_comment

begin_comment
comment|/// in turn calls _Unwind_Resume_or_Rethrow().
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|void
name|_Unwind_Resume
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_Resume(ex_obj=%p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
name|unw_context_t
name|uc
decl_stmt|;
name|unw_cursor_t
name|cursor
decl_stmt|;
name|unw_getcontext
argument_list|(
operator|&
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception_object
operator|->
name|private_1
operator|!=
literal|0
condition|)
name|unwind_phase2_forced
argument_list|(
operator|&
name|uc
argument_list|,
operator|&
name|cursor
argument_list|,
name|exception_object
argument_list|,
operator|(
name|_Unwind_Stop_Fn
operator|)
name|exception_object
operator|->
name|private_1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
operator|->
name|private_2
argument_list|)
expr_stmt|;
else|else
name|unwind_phase2
argument_list|(
operator|&
name|uc
argument_list|,
operator|&
name|cursor
argument_list|,
name|exception_object
argument_list|)
expr_stmt|;
comment|// Clients assume _Unwind_Resume() does not return, so all we can do is abort.
name|_LIBUNWIND_ABORT
argument_list|(
literal|"_Unwind_Resume() can't return"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Not used by C++.
end_comment

begin_comment
comment|/// Unwinds stack, calling "stop" function at each frame.
end_comment

begin_comment
comment|/// Could be used to implement longjmp().
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|_Unwind_Reason_Code
name|_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|,
name|_Unwind_Stop_Fn
name|stop
parameter_list|,
name|void
modifier|*
name|stop_parameter
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_ForcedUnwind(ex_obj=%p, stop=%p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|stop
argument_list|)
expr_stmt|;
name|unw_context_t
name|uc
decl_stmt|;
name|unw_cursor_t
name|cursor
decl_stmt|;
name|unw_getcontext
argument_list|(
operator|&
name|uc
argument_list|)
expr_stmt|;
comment|// Mark that this is a forced unwind, so _Unwind_Resume() can do
comment|// the right thing.
name|exception_object
operator|->
name|private_1
operator|=
operator|(
name|uintptr_t
operator|)
name|stop
expr_stmt|;
name|exception_object
operator|->
name|private_2
operator|=
operator|(
name|uintptr_t
operator|)
name|stop_parameter
expr_stmt|;
comment|// do it
return|return
name|unwind_phase2_forced
argument_list|(
operator|&
name|uc
argument_list|,
operator|&
name|cursor
argument_list|,
name|exception_object
argument_list|,
name|stop
argument_list|,
name|stop_parameter
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to get LSDA for current frame.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|uintptr_t
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_proc_info_t
name|frameInfo
decl_stmt|;
name|uintptr_t
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unw_get_proc_info
argument_list|(
name|cursor
argument_list|,
operator|&
name|frameInfo
argument_list|)
operator|==
name|UNW_ESUCCESS
condition|)
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|frameInfo
operator|.
name|lsda
expr_stmt|;
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_GetLanguageSpecificData(context=%p) => 0x%"
name|PRIxPTR
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|)
operator|!=
literal|0xFF
condition|)
name|_LIBUNWIND_DEBUG_LOG
argument_list|(
literal|"lsda at 0x%"
name|PRIxPTR
literal|" does not start with 0xFF\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to find the start of the
end_comment

begin_comment
comment|/// function.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|uintptr_t
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_proc_info_t
name|frameInfo
decl_stmt|;
name|uintptr_t
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unw_get_proc_info
argument_list|(
name|cursor
argument_list|,
operator|&
name|frameInfo
argument_list|)
operator|==
name|UNW_ESUCCESS
condition|)
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|frameInfo
operator|.
name|start_ip
expr_stmt|;
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_GetRegionStart(context=%p) => 0x%"
name|PRIxPTR
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 if a foreign exception
end_comment

begin_comment
comment|// is caught.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|void
name|_Unwind_DeleteException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exception_object
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_DeleteException(ex_obj=%p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|exception_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception_object
operator|->
name|exception_cleanup
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|exception_object
operator|->
name|exception_cleanup
call|)
argument_list|(
name|_URC_FOREIGN_EXCEPTION_CAUGHT
argument_list|,
name|exception_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to get register values.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|uintptr_t
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_word_t
name|result
decl_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|index
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_GetGR(context=%p, reg=%d) => 0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
name|index
argument_list|,
operator|(
name|uint64_t
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|uintptr_t
operator|)
name|result
return|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to alter register values.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_SetGR(context=%p, reg=%d, value=0x%0"
name|PRIx64
literal|")\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
name|index
argument_list|,
operator|(
name|uint64_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_set_reg
argument_list|(
name|cursor
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to get instruction pointer.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|uintptr_t
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_word_t
name|result
decl_stmt|;
name|unw_get_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_IP
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_GetIP(context=%p) => 0x%"
name|PRIx64
literal|"\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
operator|(
name|uint64_t
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|uintptr_t
operator|)
name|result
return|;
block|}
end_function

begin_comment
comment|/// Called by personality handler during phase 2 to alter instruction pointer,
end_comment

begin_comment
comment|/// such as setting where the landing pad is, so _Unwind_Resume() will
end_comment

begin_comment
comment|/// start executing in the landing pad.
end_comment

begin_function
name|_LIBUNWIND_EXPORT
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|_LIBUNWIND_TRACE_API
argument_list|(
literal|"_Unwind_SetIP(context=%p, value=0x%0"
name|PRIx64
literal|")\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|context
argument_list|,
operator|(
name|uint64_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|unw_cursor_t
modifier|*
name|cursor
init|=
operator|(
name|unw_cursor_t
operator|*
operator|)
name|context
decl_stmt|;
name|unw_set_reg
argument_list|(
name|cursor
argument_list|,
name|UNW_REG_IP
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !_LIBUNWIND_ARM_EHABI
end_comment

end_unit

