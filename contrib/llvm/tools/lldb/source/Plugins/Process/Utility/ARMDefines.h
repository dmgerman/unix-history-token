begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- lldb_ARMDefines.h ---------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lldb_ARMDefines_h_
end_ifndef

begin_define
define|#
directive|define
name|lldb_ARMDefines_h_
end_define

begin_comment
comment|// Common definitions for the ARM/Thumb Instruction Set Architecture.
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
comment|// ARM shifter types
typedef|typedef
enum|enum
block|{
name|SRType_LSL
block|,
name|SRType_LSR
block|,
name|SRType_ASR
block|,
name|SRType_ROR
block|,
name|SRType_RRX
block|,
name|SRType_Invalid
block|}
name|ARM_ShifterType
typedef|;
comment|// ARM conditions          // Meaning (integer)         Meaning (floating-point)      Condition flags
define|#
directive|define
name|COND_EQ
value|0x0
comment|// Equal                     Equal                         Z == 1
define|#
directive|define
name|COND_NE
value|0x1
comment|// Not equal                 Not equal, or unordered       Z == 0
define|#
directive|define
name|COND_CS
value|0x2
comment|// Carry set>, ==, or unordered           C == 1
define|#
directive|define
name|COND_HS
value|0x2
define|#
directive|define
name|COND_CC
value|0x3
comment|// Carry clear               Less than                     C == 0
define|#
directive|define
name|COND_LO
value|0x3
define|#
directive|define
name|COND_MI
value|0x4
comment|// Minus, negative           Less than                     N == 1
define|#
directive|define
name|COND_PL
value|0x5
comment|// Plus, positive or zero>, ==, or unordered           N == 0
define|#
directive|define
name|COND_VS
value|0x6
comment|// Overflow                  Unordered                     V == 1
define|#
directive|define
name|COND_VC
value|0x7
comment|// No overflow               Not unordered                 V == 0
define|#
directive|define
name|COND_HI
value|0x8
comment|// Unsigned higher           Greater than, or unordered    C == 1 and Z == 0
define|#
directive|define
name|COND_LS
value|0x9
comment|// Unsigned lower or same    Less than or equal            C == 0 or Z == 1
define|#
directive|define
name|COND_GE
value|0xA
comment|// Greater than or equal     Greater than or equal         N == V
define|#
directive|define
name|COND_LT
value|0xB
comment|// Less than                 Less than, or unordered       N != V
define|#
directive|define
name|COND_GT
value|0xC
comment|// Greater than              Greater than                  Z == 0 and N == V
define|#
directive|define
name|COND_LE
value|0xD
comment|// Less than or equal<, ==, or unordered           Z == 1 or N != V
define|#
directive|define
name|COND_AL
value|0xE
comment|// Always (unconditional)    Always (unconditional)        Any
define|#
directive|define
name|COND_UNCOND
value|0xF
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ARMCondCodeToString
parameter_list|(
name|uint32_t
name|CC
parameter_list|)
block|{
switch|switch
condition|(
name|CC
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown condition code"
argument_list|)
expr_stmt|;
case|case
name|COND_EQ
case|:
return|return
literal|"eq"
return|;
case|case
name|COND_NE
case|:
return|return
literal|"ne"
return|;
case|case
name|COND_HS
case|:
return|return
literal|"hs"
return|;
case|case
name|COND_LO
case|:
return|return
literal|"lo"
return|;
case|case
name|COND_MI
case|:
return|return
literal|"mi"
return|;
case|case
name|COND_PL
case|:
return|return
literal|"pl"
return|;
case|case
name|COND_VS
case|:
return|return
literal|"vs"
return|;
case|case
name|COND_VC
case|:
return|return
literal|"vc"
return|;
case|case
name|COND_HI
case|:
return|return
literal|"hi"
return|;
case|case
name|COND_LS
case|:
return|return
literal|"ls"
return|;
case|case
name|COND_GE
case|:
return|return
literal|"ge"
return|;
case|case
name|COND_LT
case|:
return|return
literal|"lt"
return|;
case|case
name|COND_GT
case|:
return|return
literal|"gt"
return|;
case|case
name|COND_LE
case|:
return|return
literal|"le"
return|;
case|case
name|COND_AL
case|:
return|return
literal|"al"
return|;
block|}
block|}
specifier|static
specifier|inline
name|bool
name|ARMConditionPassed
parameter_list|(
specifier|const
name|uint32_t
name|condition
parameter_list|,
specifier|const
name|uint32_t
name|cpsr
parameter_list|)
block|{
specifier|const
name|uint32_t
name|cpsr_n
init|=
operator|(
name|cpsr
operator|>>
literal|31
operator|)
operator|&
literal|1u
decl_stmt|;
comment|// Negative condition code flag
specifier|const
name|uint32_t
name|cpsr_z
init|=
operator|(
name|cpsr
operator|>>
literal|30
operator|)
operator|&
literal|1u
decl_stmt|;
comment|// Zero condition code flag
specifier|const
name|uint32_t
name|cpsr_c
init|=
operator|(
name|cpsr
operator|>>
literal|29
operator|)
operator|&
literal|1u
decl_stmt|;
comment|// Carry condition code flag
specifier|const
name|uint32_t
name|cpsr_v
init|=
operator|(
name|cpsr
operator|>>
literal|28
operator|)
operator|&
literal|1u
decl_stmt|;
comment|// Overflow condition code flag
switch|switch
condition|(
name|condition
condition|)
block|{
case|case
name|COND_EQ
case|:
return|return
operator|(
name|cpsr_z
operator|==
literal|1
operator|)
return|;
case|case
name|COND_NE
case|:
return|return
operator|(
name|cpsr_z
operator|==
literal|0
operator|)
return|;
case|case
name|COND_CS
case|:
return|return
operator|(
name|cpsr_c
operator|==
literal|1
operator|)
return|;
case|case
name|COND_CC
case|:
return|return
operator|(
name|cpsr_c
operator|==
literal|0
operator|)
return|;
case|case
name|COND_MI
case|:
return|return
operator|(
name|cpsr_n
operator|==
literal|1
operator|)
return|;
case|case
name|COND_PL
case|:
return|return
operator|(
name|cpsr_n
operator|==
literal|0
operator|)
return|;
case|case
name|COND_VS
case|:
return|return
operator|(
name|cpsr_v
operator|==
literal|1
operator|)
return|;
case|case
name|COND_VC
case|:
return|return
operator|(
name|cpsr_v
operator|==
literal|0
operator|)
return|;
case|case
name|COND_HI
case|:
return|return
operator|(
operator|(
name|cpsr_c
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cpsr_z
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|COND_LS
case|:
return|return
operator|(
operator|(
name|cpsr_c
operator|==
literal|0
operator|)
operator|||
operator|(
name|cpsr_z
operator|==
literal|1
operator|)
operator|)
return|;
case|case
name|COND_GE
case|:
return|return
operator|(
name|cpsr_n
operator|==
name|cpsr_v
operator|)
return|;
case|case
name|COND_LT
case|:
return|return
operator|(
name|cpsr_n
operator|!=
name|cpsr_v
operator|)
return|;
case|case
name|COND_GT
case|:
return|return
operator|(
operator|(
name|cpsr_z
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cpsr_n
operator|==
name|cpsr_v
operator|)
operator|)
return|;
case|case
name|COND_LE
case|:
return|return
operator|(
operator|(
name|cpsr_z
operator|==
literal|1
operator|)
operator|||
operator|(
name|cpsr_n
operator|!=
name|cpsr_v
operator|)
operator|)
return|;
case|case
name|COND_AL
case|:
case|case
name|COND_UNCOND
case|:
default|default:
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|// Bit positions for CPSR
define|#
directive|define
name|CPSR_T_POS
value|5
define|#
directive|define
name|CPSR_F_POS
value|6
define|#
directive|define
name|CPSR_I_POS
value|7
define|#
directive|define
name|CPSR_A_POS
value|8
define|#
directive|define
name|CPSR_E_POS
value|9
define|#
directive|define
name|CPSR_J_POS
value|24
define|#
directive|define
name|CPSR_Q_POS
value|27
define|#
directive|define
name|CPSR_V_POS
value|28
define|#
directive|define
name|CPSR_C_POS
value|29
define|#
directive|define
name|CPSR_Z_POS
value|30
define|#
directive|define
name|CPSR_N_POS
value|31
comment|// CPSR mode definitions
define|#
directive|define
name|CPSR_MODE_USR
value|0x10u
define|#
directive|define
name|CPSR_MODE_FIQ
value|0x11u
define|#
directive|define
name|CPSR_MODE_IRQ
value|0x12u
define|#
directive|define
name|CPSR_MODE_SVC
value|0x13u
define|#
directive|define
name|CPSR_MODE_ABT
value|0x17u
define|#
directive|define
name|CPSR_MODE_UND
value|0x1bu
define|#
directive|define
name|CPSR_MODE_SYS
value|0x1fu
comment|// Masks for CPSR
define|#
directive|define
name|MASK_CPSR_MODE_MASK
value|(0x0000001fu)
define|#
directive|define
name|MASK_CPSR_IT_MASK
value|(0x0600fc00u)
define|#
directive|define
name|MASK_CPSR_T
value|(1u<< CPSR_T_POS)
define|#
directive|define
name|MASK_CPSR_F
value|(1u<< CPSR_F_POS)
define|#
directive|define
name|MASK_CPSR_I
value|(1u<< CPSR_I_POS)
define|#
directive|define
name|MASK_CPSR_A
value|(1u<< CPSR_A_POS)
define|#
directive|define
name|MASK_CPSR_E
value|(1u<< CPSR_E_POS)
define|#
directive|define
name|MASK_CPSR_GE_MASK
value|(0x000f0000u)
define|#
directive|define
name|MASK_CPSR_J
value|(1u<< CPSR_J_POS)
define|#
directive|define
name|MASK_CPSR_Q
value|(1u<< CPSR_Q_POS)
define|#
directive|define
name|MASK_CPSR_V
value|(1u<< CPSR_V_POS)
define|#
directive|define
name|MASK_CPSR_C
value|(1u<< CPSR_C_POS)
define|#
directive|define
name|MASK_CPSR_Z
value|(1u<< CPSR_Z_POS)
define|#
directive|define
name|MASK_CPSR_N
value|(1u<< CPSR_N_POS)
block|}
end_decl_stmt

begin_comment
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// lldb_ARMDefines_h_
end_comment

end_unit

