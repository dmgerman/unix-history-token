begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- HashedNameToDIE.h ---------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SymbolFileDWARF_HashedNameToDIE_h_
end_ifndef

begin_define
define|#
directive|define
name|SymbolFileDWARF_HashedNameToDIE_h_
end_define

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"DWARFDefines.h"
end_include

begin_include
include|#
directive|include
file|"DWARFFormValue.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-defines.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/dwarf.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/RegularExpression.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/MappedHash.h"
end_include

begin_decl_stmt
name|class
name|SymbolFileDWARF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|DWARFCompileUnit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|DWARFDebugInfoEntry
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|DWARFMappedHash
block|{
struct|struct
name|DIEInfo
block|{
name|dw_offset_t
name|offset
decl_stmt|;
comment|// The DIE offset
name|dw_tag_t
name|tag
decl_stmt|;
name|uint32_t
name|type_flags
decl_stmt|;
comment|// Any flags for this DIEInfo
name|uint32_t
name|qualified_name_hash
decl_stmt|;
comment|// A 32 bit hash of the fully qualified name
name|DIEInfo
argument_list|()
operator|:
name|offset
argument_list|(
name|DW_INVALID_OFFSET
argument_list|)
operator|,
name|tag
argument_list|(
literal|0
argument_list|)
operator|,
name|type_flags
argument_list|(
literal|0
argument_list|)
operator|,
name|qualified_name_hash
argument_list|(
literal|0
argument_list|)
block|{         }
name|DIEInfo
argument_list|(
argument|dw_offset_t o
argument_list|,
argument|dw_tag_t t
argument_list|,
argument|uint32_t f
argument_list|,
argument|uint32_t h
argument_list|)
operator|:
name|offset
argument_list|(
name|o
argument_list|)
operator|,
name|tag
argument_list|(
name|t
argument_list|)
operator|,
name|type_flags
argument_list|(
name|f
argument_list|)
operator|,
name|qualified_name_hash
argument_list|(
argument|h
argument_list|)
block|{         }
name|void
name|Clear
argument_list|()
block|{
name|offset
operator|=
name|DW_INVALID_OFFSET
block|;
name|tag
operator|=
literal|0
block|;
name|type_flags
operator|=
literal|0
block|;
name|qualified_name_hash
operator|=
literal|0
block|;         }
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|DIEInfo
operator|>
name|DIEInfoArray
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|DIEArray
expr_stmt|;
specifier|static
name|void
name|ExtractDIEArray
parameter_list|(
specifier|const
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
specifier|const
name|size_t
name|count
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|ExtractDIEArray
parameter_list|(
specifier|const
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|,
specifier|const
name|dw_tag_t
name|tag
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
name|ExtractDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|size_t
name|count
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|dw_tag_t
name|die_tag
init|=
name|die_info_array
index|[
name|i
index|]
operator|.
name|tag
decl_stmt|;
name|bool
name|tag_matches
init|=
name|die_tag
operator|==
literal|0
operator|||
name|tag
operator|==
name|die_tag
decl_stmt|;
if|if
condition|(
operator|!
name|tag_matches
condition|)
block|{
if|if
condition|(
name|die_tag
operator|==
name|DW_TAG_class_type
operator|||
name|die_tag
operator|==
name|DW_TAG_structure_type
condition|)
name|tag_matches
operator|=
name|tag
operator|==
name|DW_TAG_structure_type
operator|||
name|tag
operator|==
name|DW_TAG_class_type
expr_stmt|;
block|}
if|if
condition|(
name|tag_matches
condition|)
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|ExtractDIEArray
parameter_list|(
specifier|const
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|,
specifier|const
name|dw_tag_t
name|tag
parameter_list|,
specifier|const
name|uint32_t
name|qualified_name_hash
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
name|ExtractDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|size_t
name|count
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qualified_name_hash
operator|!=
name|die_info_array
index|[
name|i
index|]
operator|.
name|qualified_name_hash
condition|)
continue|continue;
specifier|const
name|dw_tag_t
name|die_tag
init|=
name|die_info_array
index|[
name|i
index|]
operator|.
name|tag
decl_stmt|;
name|bool
name|tag_matches
init|=
name|die_tag
operator|==
literal|0
operator|||
name|tag
operator|==
name|die_tag
decl_stmt|;
if|if
condition|(
operator|!
name|tag_matches
condition|)
block|{
if|if
condition|(
name|die_tag
operator|==
name|DW_TAG_class_type
operator|||
name|die_tag
operator|==
name|DW_TAG_structure_type
condition|)
name|tag_matches
operator|=
name|tag
operator|==
name|DW_TAG_structure_type
operator|||
name|tag
operator|==
name|DW_TAG_class_type
expr_stmt|;
block|}
if|if
condition|(
name|tag_matches
condition|)
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
enum|enum
name|AtomType
block|{
name|eAtomTypeNULL
init|=
literal|0u
block|,
name|eAtomTypeDIEOffset
init|=
literal|1u
block|,
comment|// DIE offset, check form for encoding
name|eAtomTypeCUOffset
init|=
literal|2u
block|,
comment|// DIE offset of the compiler unit header that contains the item in question
name|eAtomTypeTag
init|=
literal|3u
block|,
comment|// DW_TAG_xxx value, should be encoded as DW_FORM_data1 (if no tags exceed 255) or DW_FORM_data2
name|eAtomTypeNameFlags
init|=
literal|4u
block|,
comment|// Flags from enum NameFlags
name|eAtomTypeTypeFlags
init|=
literal|5u
block|,
comment|// Flags from enum TypeFlags,
name|eAtomTypeQualNameHash
init|=
literal|6u
comment|// A 32 bit hash of the full qualified name (since all hash entries are basename only)
comment|// For example a type like "std::vector<int>::iterator" would have a name of "iterator"
comment|// and a 32 bit hash for "std::vector<int>::iterator" to allow us to not have to pull
comment|// in debug info for a type when we know the fully qualified name.
block|}
enum|;
comment|// Bit definitions for the eAtomTypeTypeFlags flags
enum|enum
name|TypeFlags
block|{
comment|// Always set for C++, only set for ObjC if this is the
comment|// @implementation for class
name|eTypeFlagClassIsImplementation
init|=
operator|(
literal|1u
operator|<<
literal|1
operator|)
block|}
enum|;
specifier|static
name|void
name|ExtractClassOrStructDIEArray
parameter_list|(
specifier|const
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|,
name|bool
name|return_implementation_only_if_available
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
specifier|const
name|size_t
name|count
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|dw_tag_t
name|die_tag
init|=
name|die_info_array
index|[
name|i
index|]
operator|.
name|tag
decl_stmt|;
if|if
condition|(
name|die_tag
operator|==
literal|0
operator|||
name|die_tag
operator|==
name|DW_TAG_class_type
operator|||
name|die_tag
operator|==
name|DW_TAG_structure_type
condition|)
block|{
if|if
condition|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|type_flags
operator|&
name|eTypeFlagClassIsImplementation
condition|)
block|{
if|if
condition|(
name|return_implementation_only_if_available
condition|)
block|{
comment|// We found the one true definiton for this class, so
comment|// only return that
name|die_offsets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// Put the one true definition as the first entry so it
comment|// matches first
name|die_offsets
operator|.
name|insert
argument_list|(
name|die_offsets
operator|.
name|begin
argument_list|()
argument_list|,
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|static
name|void
name|ExtractTypesFromDIEArray
parameter_list|(
specifier|const
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|,
name|uint32_t
name|type_flag_mask
parameter_list|,
name|uint32_t
name|type_flag_value
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
specifier|const
name|size_t
name|count
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|type_flags
operator|&
name|type_flag_mask
operator|)
operator|==
name|type_flag_value
condition|)
name|die_offsets
operator|.
name|push_back
argument_list|(
name|die_info_array
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
struct|struct
name|Atom
block|{
name|uint16_t
name|type
decl_stmt|;
name|dw_form_t
name|form
decl_stmt|;
name|Atom
argument_list|(
argument|uint16_t t = eAtomTypeNULL
argument_list|,
argument|dw_form_t f =
literal|0
argument_list|)
block|:
name|type
argument_list|(
name|t
argument_list|)
operator|,
name|form
argument_list|(
argument|f
argument_list|)
block|{         }
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Atom
operator|>
name|AtomArray
expr_stmt|;
specifier|static
name|uint32_t
name|GetTypeFlags
parameter_list|(
name|SymbolFileDWARF
modifier|*
name|dwarf2Data
parameter_list|,
specifier|const
name|DWARFCompileUnit
modifier|*
name|cu
parameter_list|,
specifier|const
name|DWARFDebugInfoEntry
modifier|*
name|die
parameter_list|)
function_decl|;
specifier|static
specifier|const
name|char
modifier|*
name|GetAtomTypeName
parameter_list|(
name|uint16_t
name|atom
parameter_list|)
block|{
switch|switch
condition|(
name|atom
condition|)
block|{
case|case
name|eAtomTypeNULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|eAtomTypeDIEOffset
case|:
return|return
literal|"die-offset"
return|;
case|case
name|eAtomTypeCUOffset
case|:
return|return
literal|"cu-offset"
return|;
case|case
name|eAtomTypeTag
case|:
return|return
literal|"die-tag"
return|;
case|case
name|eAtomTypeNameFlags
case|:
return|return
literal|"name-flags"
return|;
case|case
name|eAtomTypeTypeFlags
case|:
return|return
literal|"type-flags"
return|;
case|case
name|eAtomTypeQualNameHash
case|:
return|return
literal|"qualified-name-hash"
return|;
block|}
return|return
literal|"<invalid>"
return|;
block|}
struct|struct
name|Prologue
block|{
comment|// DIE offset base so die offsets in hash_data can be CU relative
name|dw_offset_t
name|die_base_offset
decl_stmt|;
name|AtomArray
name|atoms
decl_stmt|;
name|uint32_t
name|atom_mask
decl_stmt|;
name|size_t
name|min_hash_data_byte_size
decl_stmt|;
name|bool
name|hash_data_has_fixed_byte_size
decl_stmt|;
name|Prologue
argument_list|(
argument|dw_offset_t _die_base_offset =
literal|0
argument_list|)
block|:
name|die_base_offset
argument_list|(
name|_die_base_offset
argument_list|)
operator|,
name|atoms
argument_list|()
operator|,
name|atom_mask
argument_list|(
literal|0
argument_list|)
operator|,
name|min_hash_data_byte_size
argument_list|(
literal|0
argument_list|)
operator|,
name|hash_data_has_fixed_byte_size
argument_list|(
argument|true
argument_list|)
block|{
comment|// Define an array of DIE offsets by first defining an array,
comment|// and then define the atom type for the array, in this case
comment|// we have an array of DIE offsets
name|AppendAtom
argument_list|(
name|eAtomTypeDIEOffset
argument_list|,
name|DW_FORM_data4
argument_list|)
block|;         }
name|virtual
operator|~
name|Prologue
argument_list|()
block|{         }
name|void
name|ClearAtoms
argument_list|()
block|{
name|hash_data_has_fixed_byte_size
operator|=
name|true
block|;
name|min_hash_data_byte_size
operator|=
literal|0
block|;
name|atom_mask
operator|=
literal|0
block|;
name|atoms
operator|.
name|clear
argument_list|()
block|;         }
name|bool
name|ContainsAtom
argument_list|(
argument|AtomType atom_type
argument_list|)
specifier|const
block|{
return|return
operator|(
name|atom_mask
operator|&
operator|(
literal|1u
operator|<<
name|atom_type
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
name|virtual
name|void
name|Clear
parameter_list|()
block|{
name|die_base_offset
operator|=
literal|0
expr_stmt|;
name|ClearAtoms
argument_list|()
expr_stmt|;
block|}
name|void
name|AppendAtom
parameter_list|(
name|AtomType
name|type
parameter_list|,
name|dw_form_t
name|form
parameter_list|)
block|{
name|atoms
operator|.
name|push_back
argument_list|(
name|Atom
argument_list|(
name|type
argument_list|,
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|atom_mask
operator||=
literal|1u
operator|<<
name|type
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_indirect
case|:
case|case
name|DW_FORM_exprloc
case|:
case|case
name|DW_FORM_flag_present
case|:
case|case
name|DW_FORM_ref_sig8
case|:
name|assert
argument_list|(
operator|!
literal|"Unhandled atom form"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_sdata
case|:
case|case
name|DW_FORM_udata
case|:
case|case
name|DW_FORM_ref_udata
case|:
name|hash_data_has_fixed_byte_size
operator|=
name|false
expr_stmt|;
comment|// Fall through to the cases below...
case|case
name|DW_FORM_flag
case|:
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_sec_offset
case|:
name|min_hash_data_byte_size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|hash_data_has_fixed_byte_size
operator|=
name|false
expr_stmt|;
comment|// Fall through to the cases below...
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_ref2
case|:
name|min_hash_data_byte_size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|hash_data_has_fixed_byte_size
operator|=
name|false
expr_stmt|;
comment|// Fall through to the cases below...
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_addr
case|:
case|case
name|DW_FORM_ref_addr
case|:
case|case
name|DW_FORM_strp
case|:
name|min_hash_data_byte_size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_ref8
case|:
name|min_hash_data_byte_size
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
block|}
comment|//        void
comment|//        Dump (std::ostream* ostrm_ptr);
name|lldb
operator|::
name|offset_t
name|Read
argument_list|(
argument|const lldb_private::DataExtractor&data
argument_list|,
argument|lldb::offset_t offset
argument_list|)
block|{
name|ClearAtoms
argument_list|()
block|;
name|die_base_offset
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
block|;
specifier|const
name|uint32_t
name|atom_count
operator|=
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
block|;
if|if
condition|(
name|atom_count
operator|==
literal|0x00060003u
condition|)
block|{
comment|// Old format, deal with contents of old pre-release format
while|while
condition|(
name|data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
condition|)
comment|/* do nothing */
empty_stmt|;
comment|// Hardcode to the only known value for now.
name|AppendAtom
argument_list|(
name|eAtomTypeDIEOffset
argument_list|,
name|DW_FORM_data4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atom_count
condition|;
operator|++
name|i
control|)
block|{
name|AtomType
name|type
init|=
operator|(
name|AtomType
operator|)
name|data
operator|.
name|GetU16
argument_list|(
operator|&
name|offset
argument_list|)
decl_stmt|;
name|dw_form_t
name|form
init|=
operator|(
name|dw_form_t
operator|)
name|data
operator|.
name|GetU16
argument_list|(
operator|&
name|offset
argument_list|)
decl_stmt|;
name|AppendAtom
argument_list|(
name|type
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
comment|//        virtual void
comment|//        Write (BinaryStreamBuf&s);
name|size_t
name|GetByteSize
argument_list|()
decl|const
block|{
comment|// Add an extra count to the atoms size for the zero termination Atom that gets
comment|// written to disk
return|return
sizeof|sizeof
argument_list|(
name|die_base_offset
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|atoms
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|Atom
argument_list|)
return|;
block|}
name|size_t
name|GetMinumumHashDataByteSize
argument_list|()
decl|const
block|{
return|return
name|min_hash_data_byte_size
return|;
block|}
name|bool
name|HashDataHasFixedByteSize
argument_list|()
decl|const
block|{
return|return
name|hash_data_has_fixed_byte_size
return|;
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|Header
range|:
name|public
name|MappedHash
operator|::
name|Header
operator|<
name|Prologue
operator|>
block|{
name|Header
argument_list|(
argument|dw_offset_t _die_base_offset =
literal|0
argument_list|)
block|{         }
name|virtual
operator|~
name|Header
argument_list|()
block|{         }
name|virtual
name|size_t
name|GetByteSize
argument_list|(
argument|const HeaderData&header_data
argument_list|)
block|{
return|return
name|header_data
operator|.
name|GetByteSize
argument_list|()
return|;
block|}
comment|//        virtual void
comment|//        Dump (std::ostream* ostrm_ptr);
comment|//
name|virtual
name|lldb
operator|::
name|offset_t
name|Read
argument_list|(
argument|lldb_private::DataExtractor&data
argument_list|,
argument|lldb::offset_t offset
argument_list|)
block|{
name|offset
operator|=
name|MappedHash
operator|::
name|Header
operator|<
name|Prologue
operator|>
operator|::
name|Read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
block|;
if|if
condition|(
name|offset
operator|!=
name|UINT32_MAX
condition|)
block|{
name|offset
operator|=
name|header_data
operator|.
name|Read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
name|bool
name|Read
argument_list|(
argument|const lldb_private::DWARFDataExtractor&data
argument_list|,
argument|lldb::offset_t *offset_ptr
argument_list|,
argument|DIEInfo&hash_data
argument_list|)
specifier|const
block|{
specifier|const
name|size_t
name|num_atoms
operator|=
name|header_data
operator|.
name|atoms
operator|.
name|size
argument_list|()
block|;
if|if
condition|(
name|num_atoms
operator|==
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_atoms
condition|;
operator|++
name|i
control|)
block|{
name|DWARFFormValue
name|form_value
argument_list|(
name|header_data
operator|.
name|atoms
index|[
name|i
index|]
operator|.
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|form_value
operator|.
name|ExtractValue
argument_list|(
name|data
argument_list|,
name|offset_ptr
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|header_data
operator|.
name|atoms
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|eAtomTypeDIEOffset
case|:
comment|// DIE offset, check form for encoding
name|hash_data
operator|.
name|offset
operator|=
operator|(
name|dw_offset_t
operator|)
name|form_value
operator|.
name|Reference
argument_list|(
name|header_data
operator|.
name|die_base_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|eAtomTypeTag
case|:
comment|// DW_TAG value for the DIE
name|hash_data
operator|.
name|tag
operator|=
operator|(
name|dw_tag_t
operator|)
name|form_value
operator|.
name|Unsigned
argument_list|()
expr_stmt|;
case|case
name|eAtomTypeTypeFlags
case|:
comment|// Flags from enum TypeFlags
name|hash_data
operator|.
name|type_flags
operator|=
operator|(
name|uint32_t
operator|)
name|form_value
operator|.
name|Unsigned
argument_list|()
expr_stmt|;
break|break;
case|case
name|eAtomTypeQualNameHash
case|:
comment|// Flags from enum TypeFlags
name|hash_data
operator|.
name|qualified_name_hash
operator|=
name|form_value
operator|.
name|Unsigned
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|// We can always skip atomes we don't know about
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|Dump
argument_list|(
name|lldb_private
operator|::
name|Stream
operator|&
name|strm
argument_list|,
specifier|const
name|DIEInfo
operator|&
name|hash_data
argument_list|)
decl|const
block|{
specifier|const
name|size_t
name|num_atoms
init|=
name|header_data
operator|.
name|atoms
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_atoms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|strm
operator|.
name|PutCString
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|DWARFFormValue
name|form_value
argument_list|(
name|header_data
operator|.
name|atoms
index|[
name|i
index|]
operator|.
name|form
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|header_data
operator|.
name|atoms
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|eAtomTypeDIEOffset
case|:
comment|// DIE offset, check form for encoding
name|strm
operator|.
name|Printf
argument_list|(
literal|"{0x%8.8x}"
argument_list|,
name|hash_data
operator|.
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|eAtomTypeTag
case|:
comment|// DW_TAG value for the DIE
block|{
specifier|const
name|char
modifier|*
name|tag_cstr
init|=
name|lldb_private
operator|::
name|DW_TAG_value_to_name
argument_list|(
name|hash_data
operator|.
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag_cstr
condition|)
name|strm
operator|.
name|PutCString
argument_list|(
name|tag_cstr
argument_list|)
expr_stmt|;
else|else
name|strm
operator|.
name|Printf
argument_list|(
literal|"DW_TAG_(0x%4.4x)"
argument_list|,
name|hash_data
operator|.
name|tag
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|eAtomTypeTypeFlags
case|:
comment|// Flags from enum TypeFlags
name|strm
operator|.
name|Printf
argument_list|(
literal|"0x%2.2x"
argument_list|,
name|hash_data
operator|.
name|type_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_data
operator|.
name|type_flags
condition|)
block|{
name|strm
operator|.
name|PutCString
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_data
operator|.
name|type_flags
operator|&
name|eTypeFlagClassIsImplementation
condition|)
name|strm
operator|.
name|PutCString
argument_list|(
literal|" implementation"
argument_list|)
expr_stmt|;
name|strm
operator|.
name|PutCString
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|eAtomTypeQualNameHash
case|:
comment|// Flags from enum TypeFlags
name|strm
operator|.
name|Printf
argument_list|(
literal|"0x%8.8x"
argument_list|,
name|hash_data
operator|.
name|qualified_name_hash
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strm
operator|.
name|Printf
argument_list|(
literal|"AtomType(0x%x)"
argument_list|,
name|header_data
operator|.
name|atoms
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_decl_stmt

begin_comment
unit|};
comment|//    class ExportTable
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//    public:
end_comment

begin_comment
comment|//        ExportTable ();
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        void
end_comment

begin_comment
comment|//        AppendNames (DWARFDebugPubnamesSet&pubnames_set,
end_comment

begin_comment
comment|//                     StringTable&string_table);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        void
end_comment

begin_comment
comment|//        AppendNamesEntry (SymbolFileDWARF *dwarf2Data,
end_comment

begin_comment
comment|//                          const DWARFCompileUnit* cu,
end_comment

begin_comment
comment|//                          const DWARFDebugInfoEntry* die,
end_comment

begin_comment
comment|//                          StringTable&string_table);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        void
end_comment

begin_comment
comment|//        AppendTypesEntry (DWARFData *dwarf2Data,
end_comment

begin_comment
comment|//                          const DWARFCompileUnit* cu,
end_comment

begin_comment
comment|//                          const DWARFDebugInfoEntry* die,
end_comment

begin_comment
comment|//                          StringTable&string_table);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        size_t
end_comment

begin_comment
comment|//        Save (BinaryStreamBuf&names_data, const StringTable&string_table);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        void
end_comment

begin_comment
comment|//        AppendName (const char *name,
end_comment

begin_comment
comment|//                    uint32_t die_offset,
end_comment

begin_comment
comment|//                    StringTable&string_table,
end_comment

begin_comment
comment|//                    dw_offset_t name_debug_str_offset = DW_INVALID_OFFSET); // If "name" has already been looked up, then it can be supplied
end_comment

begin_comment
comment|//        void
end_comment

begin_comment
comment|//        AppendType (const char *name,
end_comment

begin_comment
comment|//                    uint32_t die_offset,
end_comment

begin_comment
comment|//                    StringTable&string_table);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//    protected:
end_comment

begin_comment
comment|//        struct Entry
end_comment

begin_comment
comment|//        {
end_comment

begin_comment
comment|//            uint32_t hash;
end_comment

begin_comment
comment|//            uint32_t str_offset;
end_comment

begin_comment
comment|//            uint32_t die_offset;
end_comment

begin_comment
comment|//        };
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        // Map uniqued .debug_str offset to the corresponding DIE offsets
end_comment

begin_comment
comment|//        typedef std::map<uint32_t, DIEInfoArray> NameInfo;
end_comment

begin_comment
comment|//        // Map a name hash to one or more name infos
end_comment

begin_comment
comment|//        typedef std::map<uint32_t, NameInfo> BucketEntry;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        static uint32_t
end_comment

begin_comment
comment|//        GetByteSize (const NameInfo&name_info);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//        typedef std::vector<BucketEntry> BucketEntryColl;
end_comment

begin_comment
comment|//        typedef std::vector<Entry> EntryColl;
end_comment

begin_comment
comment|//        EntryColl m_entries;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//    };
end_comment

begin_comment
comment|// A class for reading and using a saved hash table from a block of data
end_comment

begin_comment
comment|// in memory
end_comment

begin_decl_stmt
name|class
name|MemoryTable
range|:
name|public
name|MappedHash
operator|::
name|MemoryTable
operator|<
name|uint32_t
decl_stmt|,
name|DWARFMappedHash
decl|::
name|Header
decl_stmt|,
name|DIEInfoArray
decl|>
block|{
name|public
label|:
name|MemoryTable
argument_list|(
name|lldb_private
operator|::
name|DWARFDataExtractor
operator|&
name|table_data
argument_list|,
specifier|const
name|lldb_private
operator|::
name|DWARFDataExtractor
operator|&
name|string_table
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|)
operator|:
name|MappedHash
operator|::
name|MemoryTable
operator|<
name|uint32_t
operator|,
name|Header
operator|,
name|DIEInfoArray
operator|>
operator|(
name|table_data
operator|)
operator|,
name|m_data
argument_list|(
name|table_data
argument_list|)
operator|,
name|m_string_table
argument_list|(
name|string_table
argument_list|)
operator|,
name|m_name
argument_list|(
argument|name
argument_list|)
block|{         }
name|virtual
operator|~
name|MemoryTable
argument_list|()
block|{         }
name|virtual
specifier|const
name|char
operator|*
name|GetStringForKeyType
argument_list|(
argument|KeyType key
argument_list|)
specifier|const
block|{
comment|// The key in the DWARF table is the .debug_str offset for the string
return|return
name|m_string_table
operator|.
name|PeekCStr
argument_list|(
name|key
argument_list|)
return|;
block|}
name|virtual
name|bool
name|ReadHashData
argument_list|(
name|uint32_t
name|hash_data_offset
argument_list|,
name|HashData
operator|&
name|hash_data
argument_list|)
decl|const
block|{
name|lldb
operator|::
name|offset_t
name|offset
operator|=
name|hash_data_offset
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
comment|// Skip string table offset that contains offset of hash name in .debug_str
specifier|const
name|uint32_t
name|count
init|=
name|m_data
operator|.
name|GetU32
argument_list|(
operator|&
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|hash_data
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|m_header
operator|.
name|Read
argument_list|(
name|m_data
argument_list|,
operator|&
name|offset
argument_list|,
name|hash_data
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
name|hash_data
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
name|virtual
name|Result
name|GetHashDataForName
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|lldb
operator|::
name|offset_t
operator|*
name|hash_data_offset_ptr
argument_list|,
name|Pair
operator|&
name|pair
argument_list|)
decl|const
block|{
name|pair
operator|.
name|key
operator|=
name|m_data
operator|.
name|GetU32
argument_list|(
name|hash_data_offset_ptr
argument_list|)
expr_stmt|;
name|pair
operator|.
name|value
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// If the key is zero, this terminates our chain of HashData objects
comment|// for this hash value.
if|if
condition|(
name|pair
operator|.
name|key
operator|==
literal|0
condition|)
return|return
name|eResultEndOfHashData
return|;
comment|// There definitely should be a string for this string offset, if
comment|// there isn't, there is something wrong, return and error
specifier|const
name|char
modifier|*
name|strp_cstr
init|=
name|m_string_table
operator|.
name|PeekCStr
argument_list|(
name|pair
operator|.
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|strp_cstr
operator|==
name|NULL
condition|)
block|{
operator|*
name|hash_data_offset_ptr
operator|=
name|UINT32_MAX
expr_stmt|;
return|return
name|eResultError
return|;
block|}
specifier|const
name|uint32_t
name|count
init|=
name|m_data
operator|.
name|GetU32
argument_list|(
name|hash_data_offset_ptr
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|min_total_hash_data_size
init|=
name|count
operator|*
name|m_header
operator|.
name|header_data
operator|.
name|GetMinumumHashDataByteSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|m_data
operator|.
name|ValidOffsetForDataOfSize
argument_list|(
operator|*
name|hash_data_offset_ptr
argument_list|,
name|min_total_hash_data_size
argument_list|)
condition|)
block|{
comment|// We have at least one HashData entry, and we have enough
comment|// data to parse at leats "count" HashData enties.
comment|// First make sure the entire C string matches...
specifier|const
name|bool
name|match
init|=
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp_cstr
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|match
operator|&&
name|m_header
operator|.
name|header_data
operator|.
name|HashDataHasFixedByteSize
argument_list|()
condition|)
block|{
comment|// If the string doesn't match and we have fixed size data,
comment|// we can just add the total byte size of all HashData objects
comment|// to the hash data offset and be done...
operator|*
name|hash_data_offset_ptr
operator|+=
name|min_total_hash_data_size
expr_stmt|;
block|}
else|else
block|{
comment|// If the string does match, or we don't have fixed size data
comment|// then we need to read the hash data as a stream. If the
comment|// string matches we also append all HashData objects to the
comment|// value array.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|DIEInfo
name|die_info
decl_stmt|;
if|if
condition|(
name|m_header
operator|.
name|Read
argument_list|(
name|m_data
argument_list|,
name|hash_data_offset_ptr
argument_list|,
name|die_info
argument_list|)
condition|)
block|{
comment|// Only happend the HashData if the string matched...
if|if
condition|(
name|match
condition|)
name|pair
operator|.
name|value
operator|.
name|push_back
argument_list|(
name|die_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Something went wrong while reading the data
operator|*
name|hash_data_offset_ptr
operator|=
name|UINT32_MAX
expr_stmt|;
return|return
name|eResultError
return|;
block|}
block|}
block|}
comment|// Return the correct response depending on if the string matched
comment|// or not...
if|if
condition|(
name|match
condition|)
return|return
name|eResultKeyMatch
return|;
comment|// The key (cstring) matches and we have lookup results!
else|else
return|return
name|eResultKeyMismatch
return|;
comment|// The key doesn't match, this function will get called
comment|// again for the next key/value or the key terminator
comment|// which in our case is a zero .debug_str offset.
block|}
else|else
block|{
operator|*
name|hash_data_offset_ptr
operator|=
name|UINT32_MAX
expr_stmt|;
return|return
name|eResultError
return|;
block|}
block|}
name|virtual
name|Result
name|AppendHashDataForRegularExpression
argument_list|(
specifier|const
name|lldb_private
operator|::
name|RegularExpression
operator|&
name|regex
argument_list|,
name|lldb
operator|::
name|offset_t
operator|*
name|hash_data_offset_ptr
argument_list|,
name|Pair
operator|&
name|pair
argument_list|)
decl|const
block|{
name|pair
operator|.
name|key
operator|=
name|m_data
operator|.
name|GetU32
argument_list|(
name|hash_data_offset_ptr
argument_list|)
expr_stmt|;
comment|// If the key is zero, this terminates our chain of HashData objects
comment|// for this hash value.
if|if
condition|(
name|pair
operator|.
name|key
operator|==
literal|0
condition|)
return|return
name|eResultEndOfHashData
return|;
comment|// There definitely should be a string for this string offset, if
comment|// there isn't, there is something wrong, return and error
specifier|const
name|char
modifier|*
name|strp_cstr
init|=
name|m_string_table
operator|.
name|PeekCStr
argument_list|(
name|pair
operator|.
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|strp_cstr
operator|==
name|NULL
condition|)
return|return
name|eResultError
return|;
specifier|const
name|uint32_t
name|count
init|=
name|m_data
operator|.
name|GetU32
argument_list|(
name|hash_data_offset_ptr
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|min_total_hash_data_size
init|=
name|count
operator|*
name|m_header
operator|.
name|header_data
operator|.
name|GetMinumumHashDataByteSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|m_data
operator|.
name|ValidOffsetForDataOfSize
argument_list|(
operator|*
name|hash_data_offset_ptr
argument_list|,
name|min_total_hash_data_size
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|match
init|=
name|regex
operator|.
name|Execute
argument_list|(
name|strp_cstr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
operator|&&
name|m_header
operator|.
name|header_data
operator|.
name|HashDataHasFixedByteSize
argument_list|()
condition|)
block|{
comment|// If the regex doesn't match and we have fixed size data,
comment|// we can just add the total byte size of all HashData objects
comment|// to the hash data offset and be done...
operator|*
name|hash_data_offset_ptr
operator|+=
name|min_total_hash_data_size
expr_stmt|;
block|}
else|else
block|{
comment|// If the string does match, or we don't have fixed size data
comment|// then we need to read the hash data as a stream. If the
comment|// string matches we also append all HashData objects to the
comment|// value array.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|DIEInfo
name|die_info
decl_stmt|;
if|if
condition|(
name|m_header
operator|.
name|Read
argument_list|(
name|m_data
argument_list|,
name|hash_data_offset_ptr
argument_list|,
name|die_info
argument_list|)
condition|)
block|{
comment|// Only happend the HashData if the string matched...
if|if
condition|(
name|match
condition|)
name|pair
operator|.
name|value
operator|.
name|push_back
argument_list|(
name|die_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Something went wrong while reading the data
operator|*
name|hash_data_offset_ptr
operator|=
name|UINT32_MAX
expr_stmt|;
return|return
name|eResultError
return|;
block|}
block|}
block|}
comment|// Return the correct response depending on if the string matched
comment|// or not...
if|if
condition|(
name|match
condition|)
return|return
name|eResultKeyMatch
return|;
comment|// The key (cstring) matches and we have lookup results!
else|else
return|return
name|eResultKeyMismatch
return|;
comment|// The key doesn't match, this function will get called
comment|// again for the next key/value or the key terminator
comment|// which in our case is a zero .debug_str offset.
block|}
else|else
block|{
operator|*
name|hash_data_offset_ptr
operator|=
name|UINT32_MAX
expr_stmt|;
return|return
name|eResultError
return|;
block|}
block|}
name|size_t
name|AppendAllDIEsThatMatchingRegex
argument_list|(
specifier|const
name|lldb_private
operator|::
name|RegularExpression
operator|&
name|regex
argument_list|,
name|DIEInfoArray
operator|&
name|die_info_array
argument_list|)
decl|const
block|{
specifier|const
name|uint32_t
name|hash_count
init|=
name|m_header
operator|.
name|hashes_count
decl_stmt|;
name|Pair
name|pair
decl_stmt|;
for|for
control|(
name|uint32_t
name|offset_idx
init|=
literal|0
init|;
name|offset_idx
operator|<
name|hash_count
condition|;
operator|++
name|offset_idx
control|)
block|{
name|lldb
operator|::
name|offset_t
name|hash_data_offset
operator|=
name|GetHashDataOffset
argument_list|(
name|offset_idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|hash_data_offset
operator|!=
name|UINT32_MAX
condition|)
block|{
specifier|const
name|lldb
operator|::
name|offset_t
name|prev_hash_data_offset
operator|=
name|hash_data_offset
expr_stmt|;
name|Result
name|hash_result
init|=
name|AppendHashDataForRegularExpression
argument_list|(
name|regex
argument_list|,
operator|&
name|hash_data_offset
argument_list|,
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev_hash_data_offset
operator|==
name|hash_data_offset
condition|)
break|break;
comment|// Check the result of getting our hash data
switch|switch
condition|(
name|hash_result
condition|)
block|{
case|case
name|eResultKeyMatch
case|:
case|case
name|eResultKeyMismatch
case|:
comment|// Whether we matches or not, it doesn't matter, we
comment|// keep looking.
break|break;
case|case
name|eResultEndOfHashData
case|:
case|case
name|eResultError
case|:
name|hash_data_offset
operator|=
name|UINT32_MAX
expr_stmt|;
break|break;
block|}
block|}
block|}
name|die_info_array
operator|.
name|swap
argument_list|(
name|pair
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
name|die_info_array
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|AppendAllDIEsInRange
argument_list|(
specifier|const
name|uint32_t
name|die_offset_start
argument_list|,
specifier|const
name|uint32_t
name|die_offset_end
argument_list|,
name|DIEInfoArray
operator|&
name|die_info_array
argument_list|)
decl|const
block|{
specifier|const
name|uint32_t
name|hash_count
init|=
name|m_header
operator|.
name|hashes_count
decl_stmt|;
for|for
control|(
name|uint32_t
name|offset_idx
init|=
literal|0
init|;
name|offset_idx
operator|<
name|hash_count
condition|;
operator|++
name|offset_idx
control|)
block|{
name|bool
name|done
init|=
name|false
decl_stmt|;
name|lldb
operator|::
name|offset_t
name|hash_data_offset
operator|=
name|GetHashDataOffset
argument_list|(
name|offset_idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|hash_data_offset
operator|!=
name|UINT32_MAX
condition|)
block|{
name|KeyType
name|key
init|=
name|m_data
operator|.
name|GetU32
argument_list|(
operator|&
name|hash_data_offset
argument_list|)
decl_stmt|;
comment|// If the key is zero, this terminates our chain of HashData objects
comment|// for this hash value.
if|if
condition|(
name|key
operator|==
literal|0
condition|)
break|break;
specifier|const
name|uint32_t
name|count
init|=
name|m_data
operator|.
name|GetU32
argument_list|(
operator|&
name|hash_data_offset
argument_list|)
decl_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|DIEInfo
name|die_info
decl_stmt|;
if|if
condition|(
name|m_header
operator|.
name|Read
argument_list|(
name|m_data
argument_list|,
operator|&
name|hash_data_offset
argument_list|,
name|die_info
argument_list|)
condition|)
block|{
if|if
condition|(
name|die_info
operator|.
name|offset
operator|==
literal|0
condition|)
name|done
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|die_offset_start
operator|<=
name|die_info
operator|.
name|offset
operator|&&
name|die_info
operator|.
name|offset
operator|<
name|die_offset_end
condition|)
name|die_info_array
operator|.
name|push_back
argument_list|(
name|die_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|die_info_array
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|FindByName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
name|DIEInfoArray
name|die_info_array
decl_stmt|;
if|if
condition|(
name|FindByName
argument_list|(
name|name
argument_list|,
name|die_info_array
argument_list|)
condition|)
name|DWARFMappedHash
operator|::
name|ExtractDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
return|return
name|die_info_array
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|FindByNameAndTag
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dw_tag_t
name|tag
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
name|DIEInfoArray
name|die_info_array
decl_stmt|;
if|if
condition|(
name|FindByName
argument_list|(
name|name
argument_list|,
name|die_info_array
argument_list|)
condition|)
name|DWARFMappedHash
operator|::
name|ExtractDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|tag
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
return|return
name|die_info_array
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|FindByNameAndTagAndQualifiedNameHash
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dw_tag_t
name|tag
parameter_list|,
specifier|const
name|uint32_t
name|qualified_name_hash
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|)
block|{
name|DIEInfoArray
name|die_info_array
decl_stmt|;
if|if
condition|(
name|FindByName
argument_list|(
name|name
argument_list|,
name|die_info_array
argument_list|)
condition|)
name|DWARFMappedHash
operator|::
name|ExtractDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|tag
argument_list|,
name|qualified_name_hash
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
return|return
name|die_info_array
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|FindCompleteObjCClassByName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DIEArray
modifier|&
name|die_offsets
parameter_list|,
name|bool
name|must_be_implementation
parameter_list|)
block|{
name|DIEInfoArray
name|die_info_array
decl_stmt|;
if|if
condition|(
name|FindByName
argument_list|(
name|name
argument_list|,
name|die_info_array
argument_list|)
condition|)
block|{
if|if
condition|(
name|must_be_implementation
operator|&&
name|GetHeader
argument_list|()
operator|.
name|header_data
operator|.
name|ContainsAtom
argument_list|(
name|eAtomTypeTypeFlags
argument_list|)
condition|)
block|{
comment|// If we have two atoms, then we have the DIE offset and
comment|// the type flags so we can find the objective C class
comment|// efficiently.
name|DWARFMappedHash
operator|::
name|ExtractTypesFromDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|UINT32_MAX
argument_list|,
name|eTypeFlagClassIsImplementation
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't only want the one true definition, so try and see
comment|// what we can find, and only return class or struct DIEs.
comment|// If we do have the full implementation, then return it alone,
comment|// else return all possible matches.
specifier|const
name|bool
name|return_implementation_only_if_available
init|=
name|true
decl_stmt|;
name|DWARFMappedHash
operator|::
name|ExtractClassOrStructDIEArray
argument_list|(
name|die_info_array
argument_list|,
name|return_implementation_only_if_available
argument_list|,
name|die_offsets
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|die_offsets
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|FindByName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DIEInfoArray
modifier|&
name|die_info_array
parameter_list|)
block|{
name|Pair
name|kv_pair
decl_stmt|;
name|size_t
name|old_size
init|=
name|die_info_array
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|Find
argument_list|(
name|name
argument_list|,
name|kv_pair
argument_list|)
condition|)
block|{
name|die_info_array
operator|.
name|swap
argument_list|(
name|kv_pair
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
name|die_info_array
operator|.
name|size
argument_list|()
operator|-
name|old_size
return|;
block|}
return|return
literal|0
return|;
block|}
name|protected
label|:
specifier|const
name|lldb_private
operator|::
name|DWARFDataExtractor
operator|&
name|m_data
expr_stmt|;
specifier|const
name|lldb_private
operator|::
name|DWARFDataExtractor
operator|&
name|m_string_table
expr_stmt|;
name|std
operator|::
name|string
name|m_name
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|// SymbolFileDWARF_HashedNameToDIE_h_
end_comment

end_unit

