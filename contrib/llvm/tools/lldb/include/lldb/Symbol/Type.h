begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Type.h --------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_Type_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_Type_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Core/ClangForward.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/CompilerDecl.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/CompilerType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/Declaration.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/ConstString.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/UserID.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APSInt.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
comment|//----------------------------------------------------------------------
comment|// CompilerContext allows an array of these items to be passed to
comment|// perform detailed lookups in SymbolVendor and SymbolFile functions.
comment|//----------------------------------------------------------------------
struct|struct
name|CompilerContext
block|{
name|CompilerContext
argument_list|(
argument|CompilerContextKind t
argument_list|,
argument|const ConstString&n
argument_list|)
block|:
name|type
argument_list|(
name|t
argument_list|)
operator|,
name|name
argument_list|(
argument|n
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|CompilerContext
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|type
operator|==
name|rhs
operator|.
name|type
operator|&&
name|name
operator|==
name|rhs
operator|.
name|name
return|;
block|}
name|void
name|Dump
argument_list|()
specifier|const
expr_stmt|;
name|CompilerContextKind
name|type
decl_stmt|;
name|ConstString
name|name
decl_stmt|;
block|}
struct|;
name|class
name|SymbolFileType
range|:
name|public
name|std
operator|::
name|enable_shared_from_this
operator|<
name|SymbolFileType
operator|>
decl_stmt|,
name|public
name|UserID
block|{
name|public
label|:
name|SymbolFileType
argument_list|(
argument|SymbolFile&symbol_file
argument_list|,
argument|lldb::user_id_t uid
argument_list|)
block|:
name|UserID
argument_list|(
name|uid
argument_list|)
operator|,
name|m_symbol_file
argument_list|(
argument|symbol_file
argument_list|)
block|{}
name|SymbolFileType
argument_list|(
name|SymbolFile
operator|&
name|symbol_file
argument_list|,
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
expr_stmt|;
operator|~
name|SymbolFileType
argument_list|()
block|{}
name|Type
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
name|GetType
argument_list|()
return|;
block|}
name|Type
modifier|*
name|GetType
parameter_list|()
function_decl|;
name|protected
label|:
name|SymbolFile
modifier|&
name|m_symbol_file
decl_stmt|;
name|lldb
operator|::
name|TypeSP
name|m_type_sp
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|Type
range|:
name|public
name|std
operator|::
name|enable_shared_from_this
operator|<
name|Type
operator|>
decl_stmt|,
name|public
name|UserID
block|{
name|public
label|:
typedef|typedef
enum|enum
name|EncodingDataTypeTag
block|{
name|eEncodingInvalid
block|,
name|eEncodingIsUID
block|,
comment|///< This type is the type whose UID is m_encoding_uid
name|eEncodingIsConstUID
block|,
comment|///< This type is the type whose UID is m_encoding_uid
comment|///with the const qualifier added
name|eEncodingIsRestrictUID
block|,
comment|///< This type is the type whose UID is
comment|///m_encoding_uid with the restrict qualifier added
name|eEncodingIsVolatileUID
block|,
comment|///< This type is the type whose UID is
comment|///m_encoding_uid with the volatile qualifier added
name|eEncodingIsTypedefUID
block|,
comment|///< This type is pointer to a type whose UID is
comment|///m_encoding_uid
name|eEncodingIsPointerUID
block|,
comment|///< This type is pointer to a type whose UID is
comment|///m_encoding_uid
name|eEncodingIsLValueReferenceUID
block|,
comment|///< This type is L value reference to a type
comment|///whose UID is m_encoding_uid
name|eEncodingIsRValueReferenceUID
block|,
comment|///< This type is R value reference to a type
comment|///whose UID is m_encoding_uid
name|eEncodingIsSyntheticUID
block|}
name|EncodingDataType
typedef|;
comment|// We must force the underlying type of the enum to be unsigned here.  Not all
comment|// compilers
comment|// behave the same with regards to the default underlying type of an enum, but
comment|// because
comment|// this enum is used in an enum bitfield and integer comparisons are done with
comment|// the value
comment|// we need to guarantee that it's always unsigned so that, for example,
comment|// eResolveStateFull
comment|// doesn't compare less than eResolveStateUnresolved when used in a 2-bit
comment|// bitfield.
typedef|typedef
enum|enum
name|ResolveStateTag
enum|:
name|unsigned
block|{
name|eResolveStateUnresolved
init|=
literal|0
block|,
name|eResolveStateForward
init|=
literal|1
block|,
name|eResolveStateLayout
init|=
literal|2
block|,
name|eResolveStateFull
init|=
literal|3
block|}
name|ResolveState
typedef|;
name|Type
argument_list|(
argument|lldb::user_id_t uid
argument_list|,
argument|SymbolFile *symbol_file
argument_list|,
argument|const ConstString&name
argument_list|,
argument|uint64_t byte_size
argument_list|,
argument|SymbolContextScope *context
argument_list|,
argument|lldb::user_id_t encoding_uid
argument_list|,
argument|EncodingDataType encoding_uid_type
argument_list|,
argument|const Declaration&decl
argument_list|,
argument|const CompilerType&compiler_qual_type
argument_list|,
argument|ResolveState compiler_type_resolve_state
argument_list|)
empty_stmt|;
comment|// This makes an invalid type.  Used for functions that return a Type when
comment|// they
comment|// get an error.
name|Type
argument_list|()
expr_stmt|;
name|Type
argument_list|(
specifier|const
name|Type
operator|&
name|rhs
argument_list|)
expr_stmt|;
specifier|const
name|Type
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Type
operator|&
name|rhs
operator|)
decl_stmt|;
name|void
name|Dump
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|,
name|bool
name|show_context
parameter_list|)
function_decl|;
name|void
name|DumpTypeName
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|)
function_decl|;
comment|// Since Type instances only keep a "SymbolFile *" internally, other classes
comment|// like TypeImpl need make sure the module is still around before playing with
comment|// Type instances. They can store a weak pointer to the Module;
name|lldb
operator|::
name|ModuleSP
name|GetModule
argument_list|()
expr_stmt|;
name|void
name|GetDescription
argument_list|(
name|Stream
operator|*
name|s
argument_list|,
name|lldb
operator|::
name|DescriptionLevel
name|level
argument_list|,
name|bool
name|show_name
argument_list|)
decl_stmt|;
name|SymbolFile
modifier|*
name|GetSymbolFile
parameter_list|()
block|{
return|return
name|m_symbol_file
return|;
block|}
specifier|const
name|SymbolFile
operator|*
name|GetSymbolFile
argument_list|()
specifier|const
block|{
return|return
name|m_symbol_file
return|;
block|}
name|TypeList
modifier|*
name|GetTypeList
parameter_list|()
function_decl|;
specifier|const
name|ConstString
modifier|&
name|GetName
parameter_list|()
function_decl|;
name|uint64_t
name|GetByteSize
parameter_list|()
function_decl|;
name|uint32_t
name|GetNumChildren
parameter_list|(
name|bool
name|omit_empty_base_classes
parameter_list|)
function_decl|;
name|bool
name|IsAggregateType
parameter_list|()
function_decl|;
name|bool
name|IsValidType
parameter_list|()
block|{
return|return
name|m_encoding_uid_type
operator|!=
name|eEncodingInvalid
return|;
block|}
name|bool
name|IsTypedef
parameter_list|()
block|{
return|return
name|m_encoding_uid_type
operator|==
name|eEncodingIsTypedefUID
return|;
block|}
name|lldb
operator|::
name|TypeSP
name|GetTypedefType
argument_list|()
expr_stmt|;
specifier|const
name|ConstString
operator|&
name|GetName
argument_list|()
specifier|const
block|{
return|return
name|m_name
return|;
block|}
name|ConstString
name|GetQualifiedName
parameter_list|()
function_decl|;
name|void
name|DumpValue
argument_list|(
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
name|Stream
operator|*
name|s
argument_list|,
specifier|const
name|DataExtractor
operator|&
name|data
argument_list|,
name|uint32_t
name|data_offset
argument_list|,
name|bool
name|show_type
argument_list|,
name|bool
name|show_summary
argument_list|,
name|bool
name|verbose
argument_list|,
name|lldb
operator|::
name|Format
name|format
operator|=
name|lldb
operator|::
name|eFormatDefault
argument_list|)
decl_stmt|;
name|bool
name|DumpValueInMemory
argument_list|(
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
name|Stream
operator|*
name|s
argument_list|,
name|lldb
operator|::
name|addr_t
name|address
argument_list|,
name|AddressType
name|address_type
argument_list|,
name|bool
name|show_types
argument_list|,
name|bool
name|show_summary
argument_list|,
name|bool
name|verbose
argument_list|)
decl_stmt|;
name|bool
name|ReadFromMemory
argument_list|(
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
name|lldb
operator|::
name|addr_t
name|address
argument_list|,
name|AddressType
name|address_type
argument_list|,
name|DataExtractor
operator|&
name|data
argument_list|)
decl_stmt|;
name|bool
name|WriteToMemory
argument_list|(
name|ExecutionContext
operator|*
name|exe_ctx
argument_list|,
name|lldb
operator|::
name|addr_t
name|address
argument_list|,
name|AddressType
name|address_type
argument_list|,
name|DataExtractor
operator|&
name|data
argument_list|)
decl_stmt|;
name|bool
name|GetIsDeclaration
argument_list|()
specifier|const
expr_stmt|;
name|void
name|SetIsDeclaration
parameter_list|(
name|bool
name|b
parameter_list|)
function_decl|;
name|bool
name|GetIsExternal
argument_list|()
specifier|const
expr_stmt|;
name|void
name|SetIsExternal
parameter_list|(
name|bool
name|b
parameter_list|)
function_decl|;
name|lldb
operator|::
name|Format
name|GetFormat
argument_list|()
expr_stmt|;
name|lldb
operator|::
name|Encoding
name|GetEncoding
argument_list|(
name|uint64_t
operator|&
name|count
argument_list|)
expr_stmt|;
name|SymbolContextScope
modifier|*
name|GetSymbolContextScope
parameter_list|()
block|{
return|return
name|m_context
return|;
block|}
specifier|const
name|SymbolContextScope
operator|*
name|GetSymbolContextScope
argument_list|()
specifier|const
block|{
return|return
name|m_context
return|;
block|}
name|void
name|SetSymbolContextScope
parameter_list|(
name|SymbolContextScope
modifier|*
name|context
parameter_list|)
block|{
name|m_context
operator|=
name|context
expr_stmt|;
block|}
specifier|const
name|lldb_private
operator|::
name|Declaration
operator|&
name|GetDeclaration
argument_list|()
specifier|const
expr_stmt|;
comment|// Get the clang type, and resolve definitions for any
comment|// class/struct/union/enum types completely.
name|CompilerType
name|GetFullCompilerType
parameter_list|()
function_decl|;
comment|// Get the clang type, and resolve definitions enough so that the type could
comment|// have layout performed. This allows ptrs and refs to class/struct/union/enum
comment|// types remain forward declarations.
name|CompilerType
name|GetLayoutCompilerType
parameter_list|()
function_decl|;
comment|// Get the clang type and leave class/struct/union/enum types as forward
comment|// declarations if they haven't already been fully defined.
name|CompilerType
name|GetForwardCompilerType
parameter_list|()
function_decl|;
specifier|static
name|int
name|Compare
parameter_list|(
specifier|const
name|Type
modifier|&
name|a
parameter_list|,
specifier|const
name|Type
modifier|&
name|b
parameter_list|)
function_decl|;
comment|// From a fully qualified typename, split the type into the type basename
comment|// and the remaining type scope (namespaces/classes).
specifier|static
name|bool
name|GetTypeScopeAndBasename
argument_list|(
specifier|const
name|llvm
operator|::
name|StringRef
operator|&
name|name
argument_list|,
name|llvm
operator|::
name|StringRef
operator|&
name|scope
argument_list|,
name|llvm
operator|::
name|StringRef
operator|&
name|basename
argument_list|,
name|lldb
operator|::
name|TypeClass
operator|&
name|type_class
argument_list|)
decl_stmt|;
name|void
name|SetEncodingType
parameter_list|(
name|Type
modifier|*
name|encoding_type
parameter_list|)
block|{
name|m_encoding_type
operator|=
name|encoding_type
expr_stmt|;
block|}
name|uint32_t
name|GetEncodingMask
parameter_list|()
function_decl|;
name|bool
name|IsCompleteObjCClass
parameter_list|()
block|{
return|return
name|m_flags
operator|.
name|is_complete_objc_class
return|;
block|}
name|void
name|SetIsCompleteObjCClass
parameter_list|(
name|bool
name|is_complete_objc_class
parameter_list|)
block|{
name|m_flags
operator|.
name|is_complete_objc_class
operator|=
name|is_complete_objc_class
expr_stmt|;
block|}
name|protected
label|:
name|ConstString
name|m_name
decl_stmt|;
name|SymbolFile
modifier|*
name|m_symbol_file
decl_stmt|;
name|SymbolContextScope
modifier|*
name|m_context
decl_stmt|;
comment|// The symbol context in which this type is defined
name|Type
modifier|*
name|m_encoding_type
decl_stmt|;
name|lldb
operator|::
name|user_id_t
name|m_encoding_uid
expr_stmt|;
name|EncodingDataType
name|m_encoding_uid_type
decl_stmt|;
name|uint64_t
name|m_byte_size
decl_stmt|;
name|Declaration
name|m_decl
decl_stmt|;
name|CompilerType
name|m_compiler_type
decl_stmt|;
struct|struct
name|Flags
block|{
ifdef|#
directive|ifdef
name|__GNUC__
comment|// using unsigned type here to work around a very noisy gcc warning
name|unsigned
name|compiler_type_resolve_state
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|ResolveState
name|compiler_type_resolve_state
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
name|bool
name|is_complete_objc_class
range|:
literal|1
decl_stmt|;
block|}
name|m_flags
struct|;
name|Type
modifier|*
name|GetEncodingType
parameter_list|()
function_decl|;
name|bool
name|ResolveClangType
parameter_list|(
name|ResolveState
name|compiler_type_resolve_state
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// these classes are used to back the SBType* objects
end_comment

begin_decl_stmt
name|class
name|TypePair
block|{
name|public
label|:
name|TypePair
argument_list|()
operator|:
name|compiler_type
argument_list|()
operator|,
name|type_sp
argument_list|()
block|{}
name|TypePair
argument_list|(
argument|CompilerType type
argument_list|)
operator|:
name|compiler_type
argument_list|(
name|type
argument_list|)
operator|,
name|type_sp
argument_list|()
block|{}
name|TypePair
argument_list|(
argument|lldb::TypeSP type
argument_list|)
operator|:
name|compiler_type
argument_list|()
operator|,
name|type_sp
argument_list|(
argument|type
argument_list|)
block|{
name|compiler_type
operator|=
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
block|;   }
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
name|compiler_type
operator|.
name|IsValid
argument_list|()
operator|||
operator|(
name|type_sp
operator|.
name|get
argument_list|()
operator|!=
name|nullptr
operator|)
return|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|IsValid
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypePair
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|compiler_type
operator|==
name|rhs
operator|.
name|compiler_type
operator|&&
name|type_sp
operator|.
name|get
argument_list|()
operator|==
name|rhs
operator|.
name|type_sp
operator|.
name|get
argument_list|()
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypePair
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|compiler_type
operator|!=
name|rhs
operator|.
name|compiler_type
operator|||
name|type_sp
operator|.
name|get
argument_list|()
operator|!=
name|rhs
operator|.
name|type_sp
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|Clear
parameter_list|()
block|{
name|compiler_type
operator|.
name|Clear
argument_list|()
expr_stmt|;
name|type_sp
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|ConstString
name|GetName
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetName
argument_list|()
return|;
if|if
condition|(
name|compiler_type
condition|)
return|return
name|compiler_type
operator|.
name|GetTypeName
argument_list|()
return|;
return|return
name|ConstString
argument_list|()
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|ConstString
name|GetDisplayTypeName
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetDisplayTypeName
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|compiler_type
condition|)
return|return
name|compiler_type
operator|.
name|GetDisplayTypeName
argument_list|()
return|;
end_if

begin_return
return|return
name|ConstString
argument_list|()
return|;
end_return

begin_macro
unit|}    void
name|SetType
argument_list|(
argument|CompilerType type
argument_list|)
end_macro

begin_block
block|{
name|type_sp
operator|.
name|reset
argument_list|()
expr_stmt|;
name|compiler_type
operator|=
name|type
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|SetType
argument_list|(
name|lldb
operator|::
name|TypeSP
name|type
argument_list|)
block|{
name|type_sp
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type_sp
condition|)
name|compiler_type
operator|=
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
expr_stmt|;
else|else
name|compiler_type
operator|.
name|Clear
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|lldb
operator|::
name|TypeSP
name|GetTypeSP
argument_list|()
specifier|const
block|{
return|return
name|type_sp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetCompilerType
argument_list|()
specifier|const
block|{
return|return
name|compiler_type
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetPointerType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetPointerType
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|compiler_type
operator|.
name|GetPointerType
argument_list|()
return|;
end_return

begin_macro
unit|}    CompilerType
name|GetPointeeType
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetPointeeType
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|compiler_type
operator|.
name|GetPointeeType
argument_list|()
return|;
end_return

begin_macro
unit|}    CompilerType
name|GetReferenceType
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetLValueReferenceType
argument_list|()
return|;
else|else
return|return
name|compiler_type
operator|.
name|GetLValueReferenceType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetTypedefedType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetTypedefedType
argument_list|()
return|;
else|else
return|return
name|compiler_type
operator|.
name|GetTypedefedType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetDereferencedType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetNonReferenceType
argument_list|()
return|;
else|else
return|return
name|compiler_type
operator|.
name|GetNonReferenceType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetUnqualifiedType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetFullyUnqualifiedType
argument_list|()
return|;
else|else
return|return
name|compiler_type
operator|.
name|GetFullyUnqualifiedType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|CompilerType
name|GetCanonicalType
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetForwardCompilerType
argument_list|()
operator|.
name|GetCanonicalType
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|compiler_type
operator|.
name|GetCanonicalType
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}    TypeSystem
operator|*
name|GetTypeSystem
argument_list|()
specifier|const
block|{
return|return
name|compiler_type
operator|.
name|GetTypeSystem
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|lldb
operator|::
name|ModuleSP
name|GetModule
argument_list|()
specifier|const
block|{
if|if
condition|(
name|type_sp
condition|)
return|return
name|type_sp
operator|->
name|GetModule
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|lldb
operator|::
name|ModuleSP
argument_list|()
return|;
end_return

begin_decl_stmt
unit|}  protected:
name|CompilerType
name|compiler_type
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lldb
operator|::
name|TypeSP
name|type_sp
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// the two classes here are used by the public API as a backend to
end_comment

begin_comment
comment|// the SBType and SBTypeList classes
end_comment

begin_decl_stmt
name|class
name|TypeImpl
block|{
name|public
label|:
name|TypeImpl
argument_list|()
expr_stmt|;
operator|~
name|TypeImpl
argument_list|()
block|{}
name|TypeImpl
argument_list|(
specifier|const
name|TypeImpl
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|TypeImpl
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
expr_stmt|;
name|TypeImpl
argument_list|(
specifier|const
name|CompilerType
operator|&
name|compiler_type
argument_list|)
expr_stmt|;
name|TypeImpl
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|,
specifier|const
name|CompilerType
operator|&
name|dynamic
argument_list|)
expr_stmt|;
name|TypeImpl
argument_list|(
specifier|const
name|CompilerType
operator|&
name|compiler_type
argument_list|,
specifier|const
name|CompilerType
operator|&
name|dynamic
argument_list|)
expr_stmt|;
name|TypeImpl
argument_list|(
specifier|const
name|TypePair
operator|&
name|pair
argument_list|,
specifier|const
name|CompilerType
operator|&
name|dynamic
argument_list|)
expr_stmt|;
name|void
name|SetType
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
decl_stmt|;
name|void
name|SetType
parameter_list|(
specifier|const
name|CompilerType
modifier|&
name|compiler_type
parameter_list|)
function_decl|;
name|void
name|SetType
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|,
specifier|const
name|CompilerType
operator|&
name|dynamic
argument_list|)
decl_stmt|;
name|void
name|SetType
parameter_list|(
specifier|const
name|CompilerType
modifier|&
name|compiler_type
parameter_list|,
specifier|const
name|CompilerType
modifier|&
name|dynamic
parameter_list|)
function_decl|;
name|void
name|SetType
parameter_list|(
specifier|const
name|TypePair
modifier|&
name|pair
parameter_list|,
specifier|const
name|CompilerType
modifier|&
name|dynamic
parameter_list|)
function_decl|;
name|TypeImpl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|TypeImpl
operator|&
name|rhs
operator|)
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypeImpl
operator|&
name|rhs
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypeImpl
operator|&
name|rhs
operator|)
specifier|const
expr_stmt|;
name|bool
name|IsValid
argument_list|()
specifier|const
expr_stmt|;
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
expr_stmt|;
name|void
name|Clear
parameter_list|()
function_decl|;
name|ConstString
name|GetName
argument_list|()
specifier|const
expr_stmt|;
name|ConstString
name|GetDisplayTypeName
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetPointerType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetPointeeType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetReferenceType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetTypedefedType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetDereferencedType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetUnqualifiedType
argument_list|()
specifier|const
expr_stmt|;
name|TypeImpl
name|GetCanonicalType
argument_list|()
specifier|const
expr_stmt|;
name|CompilerType
name|GetCompilerType
parameter_list|(
name|bool
name|prefer_dynamic
parameter_list|)
function_decl|;
name|TypeSystem
modifier|*
name|GetTypeSystem
parameter_list|(
name|bool
name|prefer_dynamic
parameter_list|)
function_decl|;
name|bool
name|GetDescription
argument_list|(
name|lldb_private
operator|::
name|Stream
operator|&
name|strm
argument_list|,
name|lldb
operator|::
name|DescriptionLevel
name|description_level
argument_list|)
decl_stmt|;
name|private
label|:
name|bool
name|CheckModule
argument_list|(
name|lldb
operator|::
name|ModuleSP
operator|&
name|module_sp
argument_list|)
decl|const
decl_stmt|;
name|lldb
operator|::
name|ModuleWP
name|m_module_wp
expr_stmt|;
name|TypePair
name|m_static_type
decl_stmt|;
name|CompilerType
name|m_dynamic_type
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|TypeListImpl
block|{
name|public
label|:
name|TypeListImpl
argument_list|()
operator|:
name|m_content
argument_list|()
block|{}
name|void
name|Append
argument_list|(
argument|const lldb::TypeImplSP&type
argument_list|)
block|{
name|m_content
operator|.
name|push_back
argument_list|(
name|type
argument_list|)
block|; }
name|class
name|AppendVisitor
block|{
name|public
operator|:
name|AppendVisitor
argument_list|(
name|TypeListImpl
operator|&
name|type_list
argument_list|)
operator|:
name|m_type_list
argument_list|(
argument|type_list
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|lldb
operator|::
name|TypeImplSP
operator|&
name|type
operator|)
block|{
name|m_type_list
operator|.
name|Append
argument_list|(
name|type
argument_list|)
block|; }
name|private
operator|:
name|TypeListImpl
operator|&
name|m_type_list
block|;   }
expr_stmt|;
name|void
name|Append
argument_list|(
specifier|const
name|lldb_private
operator|::
name|TypeList
operator|&
name|type_list
argument_list|)
decl_stmt|;
name|lldb
operator|::
name|TypeImplSP
name|GetTypeAtIndex
argument_list|(
argument|size_t idx
argument_list|)
block|{
name|lldb
operator|::
name|TypeImplSP
name|type_sp
block|;
if|if
condition|(
name|idx
operator|<
name|GetSize
argument_list|()
condition|)
name|type_sp
operator|=
name|m_content
index|[
name|idx
index|]
expr_stmt|;
return|return
name|type_sp
return|;
block|}
end_decl_stmt

begin_function
name|size_t
name|GetSize
parameter_list|()
block|{
return|return
name|m_content
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|lldb
operator|::
name|TypeImplSP
operator|>
name|m_content
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|};
name|class
name|TypeMemberImpl
block|{
name|public
label|:
name|TypeMemberImpl
argument_list|()
operator|:
name|m_type_impl_sp
argument_list|()
operator|,
name|m_bit_offset
argument_list|(
literal|0
argument_list|)
operator|,
name|m_name
argument_list|()
operator|,
name|m_bitfield_bit_size
argument_list|(
literal|0
argument_list|)
operator|,
name|m_is_bitfield
argument_list|(
argument|false
argument_list|)
block|{}
name|TypeMemberImpl
argument_list|(
argument|const lldb::TypeImplSP&type_impl_sp
argument_list|,
argument|uint64_t bit_offset
argument_list|,
argument|const ConstString&name
argument_list|,
argument|uint32_t bitfield_bit_size =
literal|0
argument_list|,
argument|bool is_bitfield = false
argument_list|)
operator|:
name|m_type_impl_sp
argument_list|(
name|type_impl_sp
argument_list|)
operator|,
name|m_bit_offset
argument_list|(
name|bit_offset
argument_list|)
operator|,
name|m_name
argument_list|(
name|name
argument_list|)
operator|,
name|m_bitfield_bit_size
argument_list|(
name|bitfield_bit_size
argument_list|)
operator|,
name|m_is_bitfield
argument_list|(
argument|is_bitfield
argument_list|)
block|{}
name|TypeMemberImpl
argument_list|(
argument|const lldb::TypeImplSP&type_impl_sp
argument_list|,
argument|uint64_t bit_offset
argument_list|)
operator|:
name|m_type_impl_sp
argument_list|(
name|type_impl_sp
argument_list|)
operator|,
name|m_bit_offset
argument_list|(
name|bit_offset
argument_list|)
operator|,
name|m_name
argument_list|()
operator|,
name|m_bitfield_bit_size
argument_list|(
literal|0
argument_list|)
operator|,
name|m_is_bitfield
argument_list|(
argument|false
argument_list|)
block|{
if|if
condition|(
name|m_type_impl_sp
condition|)
name|m_name
operator|=
name|m_type_impl_sp
operator|->
name|GetName
argument_list|()
expr_stmt|;
block|}
specifier|const
name|lldb
operator|::
name|TypeImplSP
operator|&
name|GetTypeImpl
argument_list|()
block|{
return|return
name|m_type_impl_sp
return|;
block|}
specifier|const
name|ConstString
operator|&
name|GetName
argument_list|()
specifier|const
block|{
return|return
name|m_name
return|;
block|}
name|uint64_t
name|GetBitOffset
argument_list|()
specifier|const
block|{
return|return
name|m_bit_offset
return|;
block|}
name|uint32_t
name|GetBitfieldBitSize
argument_list|()
specifier|const
block|{
return|return
name|m_bitfield_bit_size
return|;
block|}
name|void
name|SetBitfieldBitSize
parameter_list|(
name|uint32_t
name|bitfield_bit_size
parameter_list|)
block|{
name|m_bitfield_bit_size
operator|=
name|bitfield_bit_size
expr_stmt|;
block|}
name|bool
name|GetIsBitfield
argument_list|()
specifier|const
block|{
return|return
name|m_is_bitfield
return|;
block|}
name|void
name|SetIsBitfield
parameter_list|(
name|bool
name|is_bitfield
parameter_list|)
block|{
name|m_is_bitfield
operator|=
name|is_bitfield
expr_stmt|;
block|}
name|protected
label|:
name|lldb
operator|::
name|TypeImplSP
name|m_type_impl_sp
expr_stmt|;
name|uint64_t
name|m_bit_offset
decl_stmt|;
name|ConstString
name|m_name
decl_stmt|;
name|uint32_t
name|m_bitfield_bit_size
decl_stmt|;
comment|// Bit size for bitfield members only
name|bool
name|m_is_bitfield
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|///
end_comment

begin_comment
comment|/// Sometimes you can find the name of the type corresponding to an object, but
end_comment

begin_comment
comment|/// we don't have debug
end_comment

begin_comment
comment|/// information for it.  If that is the case, you can return one of these
end_comment

begin_comment
comment|/// objects, and then if it
end_comment

begin_comment
comment|/// has a full type, you can use that, but if not at least you can print the
end_comment

begin_comment
comment|/// name for informational
end_comment

begin_comment
comment|/// purposes.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|TypeAndOrName
block|{
name|public
label|:
name|TypeAndOrName
argument_list|()
expr_stmt|;
name|TypeAndOrName
argument_list|(
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
expr_stmt|;
name|TypeAndOrName
argument_list|(
specifier|const
name|CompilerType
operator|&
name|compiler_type
argument_list|)
expr_stmt|;
name|TypeAndOrName
argument_list|(
specifier|const
name|char
operator|*
name|type_str
argument_list|)
expr_stmt|;
name|TypeAndOrName
argument_list|(
specifier|const
name|TypeAndOrName
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|TypeAndOrName
argument_list|(
name|ConstString
operator|&
name|type_const_string
argument_list|)
expr_stmt|;
name|TypeAndOrName
modifier|&
name|operator
init|=
operator|(
specifier|const
name|TypeAndOrName
operator|&
name|rhs
operator|)
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TypeAndOrName
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TypeAndOrName
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
name|ConstString
name|GetName
argument_list|()
specifier|const
expr_stmt|;
name|lldb
operator|::
name|TypeSP
name|GetTypeSP
argument_list|()
specifier|const
block|{
return|return
name|m_type_pair
operator|.
name|GetTypeSP
argument_list|()
return|;
block|}
name|CompilerType
name|GetCompilerType
argument_list|()
specifier|const
block|{
return|return
name|m_type_pair
operator|.
name|GetCompilerType
argument_list|()
return|;
block|}
name|void
name|SetName
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|type_name
parameter_list|)
function_decl|;
name|void
name|SetName
parameter_list|(
specifier|const
name|char
modifier|*
name|type_name_cstr
parameter_list|)
function_decl|;
name|void
name|SetTypeSP
argument_list|(
name|lldb
operator|::
name|TypeSP
name|type_sp
argument_list|)
decl_stmt|;
name|void
name|SetCompilerType
parameter_list|(
name|CompilerType
name|compiler_type
parameter_list|)
function_decl|;
name|bool
name|IsEmpty
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|HasName
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|HasTypeSP
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|HasCompilerType
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|HasType
argument_list|()
specifier|const
block|{
return|return
name|HasTypeSP
argument_list|()
operator|||
name|HasCompilerType
argument_list|()
return|;
block|}
name|void
name|Clear
parameter_list|()
function_decl|;
name|explicit
name|operator
name|bool
parameter_list|()
block|{
return|return
operator|!
name|IsEmpty
argument_list|()
return|;
block|}
name|private
label|:
name|TypePair
name|m_type_pair
decl_stmt|;
name|ConstString
name|m_type_name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|TypeMemberFunctionImpl
block|{
name|public
label|:
name|TypeMemberFunctionImpl
argument_list|()
operator|:
name|m_type
argument_list|()
operator|,
name|m_decl
argument_list|()
operator|,
name|m_name
argument_list|()
operator|,
name|m_kind
argument_list|(
argument|lldb::eMemberFunctionKindUnknown
argument_list|)
block|{   }
name|TypeMemberFunctionImpl
argument_list|(
specifier|const
name|CompilerType
operator|&
name|type
argument_list|,
specifier|const
name|CompilerDecl
operator|&
name|decl
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|name
argument_list|,
specifier|const
name|lldb
operator|::
name|MemberFunctionKind
operator|&
name|kind
argument_list|)
operator|:
name|m_type
argument_list|(
name|type
argument_list|)
operator|,
name|m_decl
argument_list|(
name|decl
argument_list|)
operator|,
name|m_name
argument_list|(
name|name
argument_list|)
operator|,
name|m_kind
argument_list|(
argument|kind
argument_list|)
block|{}
name|bool
name|IsValid
argument_list|()
expr_stmt|;
name|ConstString
name|GetName
argument_list|()
specifier|const
expr_stmt|;
name|ConstString
name|GetMangledName
argument_list|()
specifier|const
expr_stmt|;
name|CompilerType
name|GetType
argument_list|()
specifier|const
expr_stmt|;
name|CompilerType
name|GetReturnType
argument_list|()
specifier|const
expr_stmt|;
name|size_t
name|GetNumArguments
argument_list|()
specifier|const
expr_stmt|;
name|CompilerType
name|GetArgumentAtIndex
argument_list|(
name|size_t
name|idx
argument_list|)
decl|const
decl_stmt|;
name|lldb
operator|::
name|MemberFunctionKind
name|GetKind
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|GetDescription
parameter_list|(
name|Stream
modifier|&
name|stream
parameter_list|)
function_decl|;
name|protected
label|:
name|std
operator|::
name|string
name|GetPrintableTypeName
argument_list|()
expr_stmt|;
name|private
label|:
name|CompilerType
name|m_type
decl_stmt|;
name|CompilerDecl
name|m_decl
decl_stmt|;
name|ConstString
name|m_name
decl_stmt|;
name|lldb
operator|::
name|MemberFunctionKind
name|m_kind
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|TypeEnumMemberImpl
block|{
name|public
label|:
name|TypeEnumMemberImpl
argument_list|()
operator|:
name|m_integer_type_sp
argument_list|()
operator|,
name|m_name
argument_list|(
literal|"<invalid>"
argument_list|)
operator|,
name|m_value
argument_list|()
operator|,
name|m_valid
argument_list|(
argument|false
argument_list|)
block|{}
name|TypeEnumMemberImpl
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeImplSP
operator|&
name|integer_type_sp
argument_list|,
specifier|const
name|ConstString
operator|&
name|name
argument_list|,
specifier|const
name|llvm
operator|::
name|APSInt
operator|&
name|value
argument_list|)
expr_stmt|;
name|TypeEnumMemberImpl
argument_list|(
specifier|const
name|TypeEnumMemberImpl
operator|&
name|rhs
argument_list|)
operator|:
name|m_integer_type_sp
argument_list|(
name|rhs
operator|.
name|m_integer_type_sp
argument_list|)
operator|,
name|m_name
argument_list|(
name|rhs
operator|.
name|m_name
argument_list|)
operator|,
name|m_value
argument_list|(
name|rhs
operator|.
name|m_value
argument_list|)
operator|,
name|m_valid
argument_list|(
argument|rhs.m_valid
argument_list|)
block|{}
name|TypeEnumMemberImpl
operator|&
name|operator
operator|=
operator|(
specifier|const
name|TypeEnumMemberImpl
operator|&
name|rhs
operator|)
expr_stmt|;
name|bool
name|IsValid
parameter_list|()
block|{
return|return
name|m_valid
return|;
block|}
specifier|const
name|ConstString
operator|&
name|GetName
argument_list|()
specifier|const
block|{
return|return
name|m_name
return|;
block|}
specifier|const
name|lldb
operator|::
name|TypeImplSP
operator|&
name|GetIntegerType
argument_list|()
specifier|const
block|{
return|return
name|m_integer_type_sp
return|;
block|}
name|uint64_t
name|GetValueAsUnsigned
argument_list|()
specifier|const
block|{
return|return
name|m_value
operator|.
name|getZExtValue
argument_list|()
return|;
block|}
name|int64_t
name|GetValueAsSigned
argument_list|()
specifier|const
block|{
return|return
name|m_value
operator|.
name|getSExtValue
argument_list|()
return|;
block|}
name|protected
label|:
name|lldb
operator|::
name|TypeImplSP
name|m_integer_type_sp
expr_stmt|;
name|ConstString
name|m_name
decl_stmt|;
name|llvm
operator|::
name|APSInt
name|m_value
expr_stmt|;
name|bool
name|m_valid
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|TypeEnumMemberListImpl
block|{
name|public
label|:
name|TypeEnumMemberListImpl
argument_list|()
operator|:
name|m_content
argument_list|()
block|{}
name|void
name|Append
argument_list|(
argument|const lldb::TypeEnumMemberImplSP&type
argument_list|)
block|{
name|m_content
operator|.
name|push_back
argument_list|(
name|type
argument_list|)
block|;   }
name|void
name|Append
argument_list|(
specifier|const
name|lldb_private
operator|::
name|TypeEnumMemberListImpl
operator|&
name|type_list
argument_list|)
expr_stmt|;
name|lldb
operator|::
name|TypeEnumMemberImplSP
name|GetTypeEnumMemberAtIndex
argument_list|(
argument|size_t idx
argument_list|)
block|{
name|lldb
operator|::
name|TypeEnumMemberImplSP
name|enum_member
block|;
if|if
condition|(
name|idx
operator|<
name|GetSize
argument_list|()
condition|)
name|enum_member
operator|=
name|m_content
index|[
name|idx
index|]
expr_stmt|;
return|return
name|enum_member
return|;
block|}
end_decl_stmt

begin_function
name|size_t
name|GetSize
parameter_list|()
block|{
return|return
name|m_content
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|lldb
operator|::
name|TypeEnumMemberImplSP
operator|>
name|m_content
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_Type_h_
end_comment

end_unit

