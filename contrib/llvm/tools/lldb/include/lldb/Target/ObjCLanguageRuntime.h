begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ObjCLanguageRuntime.h -----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_ObjCLanguageRuntime_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_ObjCLanguageRuntime_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<unordered_set>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/Core/PluginInterface.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ThreadSafeDenseMap.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/CompilerType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/DeclVendor.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/Type.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/LanguageRuntime.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_decl_stmt
name|class
name|CommandObjectObjC_ClassTable_Dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|UtilityFunction
decl_stmt|;
name|class
name|ObjCLanguageRuntime
range|:
name|public
name|LanguageRuntime
block|{
name|public
operator|:
expr|enum
name|class
name|ObjCRuntimeVersions
block|{
name|eObjC_VersionUnknown
operator|=
literal|0
block|,
name|eAppleObjC_V1
operator|=
literal|1
block|,
name|eAppleObjC_V2
operator|=
literal|2
block|}
block|;
typedef|typedef
name|lldb
operator|::
name|addr_t
name|ObjCISA
expr_stmt|;
name|class
name|ClassDescriptor
decl_stmt|;
typedef|typedef
name|std
operator|::
name|shared_ptr
operator|<
name|ClassDescriptor
operator|>
name|ClassDescriptorSP
expr_stmt|;
comment|// the information that we want to support retrieving from an ObjC class
comment|// this needs to be pure virtual since there are at least 2 different
comment|// implementations
comment|// of the runtime, and more might come
name|class
name|ClassDescriptor
block|{
name|public
label|:
name|ClassDescriptor
argument_list|()
operator|:
name|m_is_kvo
argument_list|(
name|eLazyBoolCalculate
argument_list|)
operator|,
name|m_is_cf
argument_list|(
name|eLazyBoolCalculate
argument_list|)
operator|,
name|m_type_wp
argument_list|()
block|{}
name|virtual
operator|~
name|ClassDescriptor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
name|ConstString
name|GetClassName
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetSuperclass
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetMetaclass
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|// virtual if any implementation has some other version-specific rules
comment|// but for the known v1/v2 this is all that needs to be done
name|virtual
name|bool
name|IsKVO
parameter_list|()
block|{
if|if
condition|(
name|m_is_kvo
operator|==
name|eLazyBoolCalculate
condition|)
block|{
specifier|const
name|char
modifier|*
name|class_name
init|=
name|GetClassName
argument_list|()
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
name|class_name
operator|&&
operator|*
name|class_name
condition|)
name|m_is_kvo
operator|=
call|(
name|LazyBool
call|)
argument_list|(
name|strstr
argument_list|(
name|class_name
argument_list|,
literal|"NSKVONotifying_"
argument_list|)
operator|==
name|class_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_is_kvo
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
comment|// virtual if any implementation has some other version-specific rules
comment|// but for the known v1/v2 this is all that needs to be done
name|virtual
name|bool
name|IsCFType
parameter_list|()
block|{
if|if
condition|(
name|m_is_cf
operator|==
name|eLazyBoolCalculate
condition|)
block|{
specifier|const
name|char
modifier|*
name|class_name
init|=
name|GetClassName
argument_list|()
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
name|class_name
operator|&&
operator|*
name|class_name
condition|)
name|m_is_cf
operator|=
call|(
name|LazyBool
call|)
argument_list|(
name|strcmp
argument_list|(
name|class_name
argument_list|,
literal|"__NSCFType"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|class_name
argument_list|,
literal|"NSCFType"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_is_cf
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
name|virtual
name|bool
name|IsValid
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|GetTaggedPointerInfo
parameter_list|(
name|uint64_t
modifier|*
name|info_bits
init|=
name|nullptr
parameter_list|,
name|uint64_t
modifier|*
name|value_bits
init|=
name|nullptr
parameter_list|,
name|uint64_t
modifier|*
name|payload
init|=
name|nullptr
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|uint64_t
name|GetInstanceSize
parameter_list|()
init|=
literal|0
function_decl|;
comment|// use to implement version-specific additional constraints on pointers
name|virtual
name|bool
name|CheckPointer
argument_list|(
name|lldb
operator|::
name|addr_t
name|value
argument_list|,
name|uint32_t
name|ptr_size
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|ObjCISA
name|GetISA
parameter_list|()
init|=
literal|0
function_decl|;
comment|// This should return true iff the interface could be completed
name|virtual
name|bool
name|Describe
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|ObjCISA
argument_list|)
operator|>
specifier|const
operator|&
name|superclass_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|>
specifier|const
operator|&
name|instance_method_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|>
specifier|const
operator|&
name|class_method_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|lldb
operator|::
name|addr_t
argument_list|,
name|uint64_t
argument_list|)
operator|>
specifier|const
operator|&
name|ivar_func
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
name|lldb
operator|::
name|TypeSP
name|GetType
argument_list|()
block|{
return|return
name|m_type_wp
operator|.
name|lock
argument_list|()
return|;
block|}
name|void
name|SetType
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
block|{
name|m_type_wp
operator|=
name|type_sp
expr_stmt|;
block|}
struct|struct
name|iVarDescriptor
block|{
name|ConstString
name|m_name
decl_stmt|;
name|CompilerType
name|m_type
decl_stmt|;
name|uint64_t
name|m_size
decl_stmt|;
name|int32_t
name|m_offset
decl_stmt|;
block|}
struct|;
name|virtual
name|size_t
name|GetNumIVars
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|iVarDescriptor
name|GetIVarAtIndex
parameter_list|(
name|size_t
name|idx
parameter_list|)
block|{
return|return
name|iVarDescriptor
argument_list|()
return|;
block|}
name|protected
label|:
name|bool
name|IsPointerValid
argument_list|(
name|lldb
operator|::
name|addr_t
name|value
argument_list|,
name|uint32_t
name|ptr_size
argument_list|,
name|bool
name|allow_NULLs
operator|=
name|false
argument_list|,
name|bool
name|allow_tagged
operator|=
name|false
argument_list|,
name|bool
name|check_version_specific
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
name|LazyBool
name|m_is_kvo
decl_stmt|;
name|LazyBool
name|m_is_cf
decl_stmt|;
name|lldb
operator|::
name|TypeWP
name|m_type_wp
expr_stmt|;
block|}
empty_stmt|;
name|class
name|EncodingToType
block|{
name|public
label|:
name|virtual
operator|~
name|EncodingToType
argument_list|()
expr_stmt|;
name|virtual
name|CompilerType
name|RealizeType
parameter_list|(
name|ClangASTContext
modifier|&
name|ast_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|for_expression
parameter_list|)
function_decl|;
name|virtual
name|CompilerType
name|RealizeType
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|for_expression
parameter_list|)
function_decl|;
name|virtual
name|CompilerType
name|RealizeType
argument_list|(
name|clang
operator|::
name|ASTContext
operator|&
name|ast_ctx
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|,
name|bool
name|for_expression
argument_list|)
init|=
literal|0
decl_stmt|;
name|protected
label|:
name|std
operator|::
name|unique_ptr
operator|<
name|ClangASTContext
operator|>
name|m_scratch_ast_ctx_ap
expr_stmt|;
block|}
empty_stmt|;
name|class
name|ObjCExceptionPrecondition
range|:
name|public
name|Breakpoint
operator|::
name|BreakpointPrecondition
block|{
name|public
operator|:
name|ObjCExceptionPrecondition
argument_list|()
block|;
operator|~
name|ObjCExceptionPrecondition
argument_list|()
name|override
operator|=
expr|default
block|;
name|bool
name|EvaluatePrecondition
argument_list|(
argument|StoppointCallbackContext&context
argument_list|)
name|override
block|;
name|void
name|GetDescription
argument_list|(
argument|Stream&stream
argument_list|,
argument|lldb::DescriptionLevel level
argument_list|)
name|override
block|;
name|Status
name|ConfigurePrecondition
argument_list|(
argument|Args&args
argument_list|)
name|override
block|;
name|protected
operator|:
name|void
name|AddClassName
argument_list|(
specifier|const
name|char
operator|*
name|class_name
argument_list|)
block|;
name|private
operator|:
name|std
operator|::
name|unordered_set
operator|<
name|std
operator|::
name|string
operator|>
name|m_class_names
block|;   }
decl_stmt|;
name|class
name|TaggedPointerVendor
block|{
name|public
label|:
name|virtual
operator|~
name|TaggedPointerVendor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
name|bool
name|IsPossibleTaggedPointer
argument_list|(
name|lldb
operator|::
name|addr_t
name|ptr
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|ObjCLanguageRuntime
operator|::
name|ClassDescriptorSP
name|GetClassDescriptor
argument_list|(
argument|lldb::addr_t ptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|protected
label|:
name|TaggedPointerVendor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|TaggedPointerVendor
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|~
name|ObjCLanguageRuntime
argument_list|()
name|override
expr_stmt|;
name|virtual
name|TaggedPointerVendor
modifier|*
name|GetTaggedPointerVendor
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
typedef|typedef
name|std
operator|::
name|shared_ptr
operator|<
name|EncodingToType
operator|>
name|EncodingToTypeSP
expr_stmt|;
name|virtual
name|EncodingToTypeSP
name|GetEncodingToType
parameter_list|()
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptor
parameter_list|(
name|ValueObject
modifier|&
name|in_value
parameter_list|)
function_decl|;
name|ClassDescriptorSP
name|GetNonKVOClassDescriptor
parameter_list|(
name|ValueObject
modifier|&
name|in_value
parameter_list|)
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptorFromClassName
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|class_name
parameter_list|)
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptorFromISA
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|ClassDescriptorSP
name|GetNonKVOClassDescriptor
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|lldb
operator|::
name|LanguageType
name|GetLanguageType
argument_list|()
specifier|const
name|override
block|{
return|return
name|lldb
operator|::
name|eLanguageTypeObjC
return|;
block|}
name|virtual
name|bool
name|IsModuleObjCLibrary
argument_list|(
specifier|const
name|lldb
operator|::
name|ModuleSP
operator|&
name|module_sp
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|bool
name|ReadObjCLibrary
argument_list|(
specifier|const
name|lldb
operator|::
name|ModuleSP
operator|&
name|module_sp
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|bool
name|HasReadObjCLibrary
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|lldb
operator|::
name|ThreadPlanSP
name|GetStepThroughTrampolinePlan
argument_list|(
argument|Thread&thread
argument_list|,
argument|bool stop_others
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|LookupInMethodCache
argument_list|(
argument|lldb::addr_t class_addr
argument_list|,
argument|lldb::addr_t sel
argument_list|)
expr_stmt|;
name|void
name|AddToMethodCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
name|lldb
operator|::
name|addr_t
name|sel
argument_list|,
name|lldb
operator|::
name|addr_t
name|impl_addr
argument_list|)
decl_stmt|;
name|TypeAndOrName
name|LookupInClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|)
decl_stmt|;
name|void
name|AddToClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|,
name|lldb
operator|::
name|TypeSP
name|type_sp
argument_list|)
decl_stmt|;
name|void
name|AddToClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
specifier|const
name|TypeAndOrName
operator|&
name|class_or_type_name
argument_list|)
decl_stmt|;
name|lldb
operator|::
name|TypeSP
name|LookupInCompleteClassCache
argument_list|(
name|ConstString
operator|&
name|name
argument_list|)
expr_stmt|;
name|virtual
name|UtilityFunction
modifier|*
name|CreateObjectChecker
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|ObjCRuntimeVersions
name|GetRuntimeVersion
argument_list|()
specifier|const
block|{
return|return
name|ObjCRuntimeVersions
operator|::
name|eObjC_VersionUnknown
return|;
block|}
name|bool
name|IsValidISA
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
block|{
name|UpdateISAToDescriptorMap
argument_list|()
expr_stmt|;
return|return
name|m_isa_to_descriptor
operator|.
name|count
argument_list|(
name|isa
argument_list|)
operator|>
literal|0
return|;
block|}
name|virtual
name|void
name|UpdateISAToDescriptorMapIfNeeded
parameter_list|()
init|=
literal|0
function_decl|;
name|void
name|UpdateISAToDescriptorMap
parameter_list|()
block|{
if|if
condition|(
name|m_process
operator|&&
name|m_process
operator|->
name|GetStopID
argument_list|()
operator|!=
name|m_isa_to_descriptor_stop_id
condition|)
block|{
name|UpdateISAToDescriptorMapIfNeeded
argument_list|()
expr_stmt|;
block|}
block|}
name|virtual
name|ObjCISA
name|GetISA
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|)
function_decl|;
name|virtual
name|ConstString
name|GetActualTypeName
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|virtual
name|ObjCISA
name|GetParentClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|virtual
name|DeclVendor
modifier|*
name|GetDeclVendor
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|// Finds the byte offset of the child_type ivar in parent_type.  If it can't
comment|// find the
comment|// offset, returns LLDB_INVALID_IVAR_OFFSET.
name|virtual
name|size_t
name|GetByteOffsetForIvar
parameter_list|(
name|CompilerType
modifier|&
name|parent_qual_type
parameter_list|,
specifier|const
name|char
modifier|*
name|ivar_name
parameter_list|)
function_decl|;
comment|// Given the name of an Objective-C runtime symbol (e.g., ivar offset symbol),
comment|// try to determine from the runtime what the value of that symbol would be.
comment|// Useful when the underlying binary is stripped.
name|virtual
name|lldb
operator|::
name|addr_t
name|LookupRuntimeSymbol
argument_list|(
argument|const ConstString&name
argument_list|)
block|{
return|return
name|LLDB_INVALID_ADDRESS
return|;
block|}
name|bool
name|HasNewLiteralsAndIndexing
parameter_list|()
block|{
if|if
condition|(
name|m_has_new_literals_and_indexing
operator|==
name|eLazyBoolCalculate
condition|)
block|{
if|if
condition|(
name|CalculateHasNewLiteralsAndIndexing
argument_list|()
condition|)
name|m_has_new_literals_and_indexing
operator|=
name|eLazyBoolYes
expr_stmt|;
else|else
name|m_has_new_literals_and_indexing
operator|=
name|eLazyBoolNo
expr_stmt|;
block|}
return|return
operator|(
name|m_has_new_literals_and_indexing
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
name|virtual
name|void
name|SymbolsDidLoad
parameter_list|(
specifier|const
name|ModuleList
modifier|&
name|module_list
parameter_list|)
block|{
name|m_negative_complete_class_cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|GetTypeBitSize
argument_list|(
specifier|const
name|CompilerType
operator|&
name|compiler_type
argument_list|,
name|uint64_t
operator|&
name|size
argument_list|)
name|override
decl_stmt|;
name|protected
label|:
comment|//------------------------------------------------------------------
comment|// Classes that inherit from ObjCLanguageRuntime can see and modify these
comment|//------------------------------------------------------------------
name|ObjCLanguageRuntime
argument_list|(
name|Process
operator|*
name|process
argument_list|)
expr_stmt|;
name|virtual
name|bool
name|CalculateHasNewLiteralsAndIndexing
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|ISAIsCached
argument_list|(
name|ObjCISA
name|isa
argument_list|)
decl|const
block|{
return|return
name|m_isa_to_descriptor
operator|.
name|find
argument_list|(
name|isa
argument_list|)
operator|!=
name|m_isa_to_descriptor
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|!=
literal|0
condition|)
block|{
name|m_isa_to_descriptor
index|[
name|isa
index|]
operator|=
name|descriptor_sp
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|,
specifier|const
name|char
modifier|*
name|class_name
parameter_list|)
function_decl|;
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|,
name|uint32_t
name|class_name_hash
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|!=
literal|0
condition|)
block|{
name|m_isa_to_descriptor
index|[
name|isa
index|]
operator|=
name|descriptor_sp
expr_stmt|;
name|m_hash_to_isa_map
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|class_name_hash
argument_list|,
name|isa
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|private
label|:
comment|// We keep a map of<Class,Selector>->Implementation so we don't have to call
comment|// the resolver
comment|// function over and over.
comment|// FIXME: We need to watch for the loading of Protocols, and flush the cache
comment|// for any
comment|// class that we see so changed.
struct|struct
name|ClassAndSel
block|{
name|ClassAndSel
argument_list|()
block|{
name|sel_addr
operator|=
name|LLDB_INVALID_ADDRESS
expr_stmt|;
name|class_addr
operator|=
name|LLDB_INVALID_ADDRESS
expr_stmt|;
block|}
name|ClassAndSel
argument_list|(
argument|lldb::addr_t in_sel_addr
argument_list|,
argument|lldb::addr_t in_class_addr
argument_list|)
block|:
name|class_addr
argument_list|(
name|in_class_addr
argument_list|)
operator|,
name|sel_addr
argument_list|(
argument|in_sel_addr
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ClassAndSel
operator|&
name|rhs
operator|)
block|{
if|if
condition|(
name|class_addr
operator|==
name|rhs
operator|.
name|class_addr
operator|&&
name|sel_addr
operator|==
name|rhs
operator|.
name|sel_addr
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|ClassAndSel
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|class_addr
operator|<
name|rhs
operator|.
name|class_addr
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|class_addr
operator|>
name|rhs
operator|.
name|class_addr
condition|)
return|return
name|false
return|;
else|else
block|{
if|if
condition|(
name|sel_addr
operator|<
name|rhs
operator|.
name|sel_addr
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
block|}
name|lldb
operator|::
name|addr_t
name|class_addr
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|sel_addr
expr_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ClassAndSel
operator|,
name|lldb
operator|::
name|addr_t
operator|>
name|MsgImplMap
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ObjCISA
operator|,
name|ClassDescriptorSP
operator|>
name|ISAToDescriptorMap
expr_stmt|;
typedef|typedef
name|std
operator|::
name|multimap
operator|<
name|uint32_t
operator|,
name|ObjCISA
operator|>
name|HashToISAMap
expr_stmt|;
typedef|typedef
name|ISAToDescriptorMap
operator|::
name|iterator
name|ISAToDescriptorIterator
expr_stmt|;
typedef|typedef
name|HashToISAMap
operator|::
name|iterator
name|HashToISAIterator
expr_stmt|;
typedef|typedef
name|ThreadSafeDenseMap
operator|<
name|void
operator|*
operator|,
name|uint64_t
operator|>
name|TypeSizeCache
expr_stmt|;
name|MsgImplMap
name|m_impl_cache
decl_stmt|;
name|LazyBool
name|m_has_new_literals_and_indexing
decl_stmt|;
name|ISAToDescriptorMap
name|m_isa_to_descriptor
decl_stmt|;
name|HashToISAMap
name|m_hash_to_isa_map
decl_stmt|;
name|TypeSizeCache
name|m_type_size_cache
decl_stmt|;
name|protected
label|:
name|uint32_t
name|m_isa_to_descriptor_stop_id
decl_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ConstString
operator|,
name|lldb
operator|::
name|TypeWP
operator|>
name|CompleteClassMap
expr_stmt|;
name|CompleteClassMap
name|m_complete_class_cache
decl_stmt|;
struct|struct
name|ConstStringSetHelpers
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|ConstString
operator|&
name|arg
operator|)
specifier|const
comment|// for hashing
block|{
return|return
operator|(
name|size_t
operator|)
name|arg
operator|.
name|GetCString
argument_list|()
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|ConstString
operator|&
name|arg1
operator|,
specifier|const
name|ConstString
operator|&
name|arg2
operator|)
specifier|const
comment|// for equality
block|{
return|return
name|arg1
operator|.
name|operator
operator|==
operator|(
name|arg2
operator|)
return|;
block|}
block|}
struct|;
typedef|typedef
name|std
operator|::
name|unordered_set
operator|<
name|ConstString
operator|,
name|ConstStringSetHelpers
operator|,
name|ConstStringSetHelpers
operator|>
name|CompleteClassSet
expr_stmt|;
name|CompleteClassSet
name|m_negative_complete_class_cache
decl_stmt|;
name|ISAToDescriptorIterator
name|GetDescriptorIterator
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|)
function_decl|;
name|friend
name|class
operator|::
name|CommandObjectObjC_ClassTable_Dump
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|ISAToDescriptorIterator
operator|,
name|ISAToDescriptorIterator
operator|>
name|GetDescriptorIteratorPair
argument_list|(
argument|bool update_if_needed = true
argument_list|)
expr_stmt|;
name|void
name|ReadObjCLibraryIfNeeded
parameter_list|(
specifier|const
name|ModuleList
modifier|&
name|module_list
parameter_list|)
function_decl|;
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|ObjCLanguageRuntime
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_ObjCLanguageRuntime_h_
end_comment

end_unit

