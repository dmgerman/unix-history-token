begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ObjCLanguageRuntime.h ---------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_ObjCLanguageRuntime_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_ObjCLanguageRuntime_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<unordered_set>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/PluginInterface.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ThreadSafeDenseMap.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/ClangASTType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/DeclVendor.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/Type.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/LanguageRuntime.h"
end_include

begin_decl_stmt
name|class
name|CommandObjectObjC_ClassTable_Dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|ClangUtilityFunction
decl_stmt|;
name|class
name|ObjCLanguageRuntime
range|:
name|public
name|LanguageRuntime
block|{
name|public
operator|:
name|class
name|MethodName
block|{
name|public
operator|:
expr|enum
name|Type
block|{
name|eTypeUnspecified
block|,
name|eTypeClassMethod
block|,
name|eTypeInstanceMethod
block|}
block|;
name|MethodName
argument_list|()
operator|:
name|m_full
argument_list|()
block|,
name|m_class
argument_list|()
block|,
name|m_category
argument_list|()
block|,
name|m_selector
argument_list|()
block|,
name|m_type
argument_list|(
name|eTypeUnspecified
argument_list|)
block|,
name|m_category_is_valid
argument_list|(
argument|false
argument_list|)
block|{         }
name|MethodName
argument_list|(
argument|const char *name
argument_list|,
argument|bool strict
argument_list|)
operator|:
name|m_full
argument_list|()
block|,
name|m_class
argument_list|()
block|,
name|m_category
argument_list|()
block|,
name|m_selector
argument_list|()
block|,
name|m_type
argument_list|(
name|eTypeUnspecified
argument_list|)
block|,
name|m_category_is_valid
argument_list|(
argument|false
argument_list|)
block|{
name|SetName
argument_list|(
name|name
argument_list|,
name|strict
argument_list|)
block|;         }
name|void
name|Clear
argument_list|()
block|;
name|bool
name|IsValid
argument_list|(
argument|bool strict
argument_list|)
specifier|const
block|{
comment|// If "strict" is true, the name must have everything specified including
comment|// the leading "+" or "-" on the method name
if|if
condition|(
name|strict
operator|&&
name|m_type
operator|==
name|eTypeUnspecified
condition|)
return|return
name|false
return|;
comment|// Other than that, m_full will only be filled in if the objective C
comment|// name is valid.
return|return
operator|(
name|bool
operator|)
name|m_full
return|;
block|}
name|bool
name|HasCategory
argument_list|()
block|{
return|return
operator|(
name|bool
operator|)
name|GetCategory
argument_list|()
return|;
block|}
name|Type
name|GetType
argument_list|()
specifier|const
block|{
return|return
name|m_type
return|;
block|}
specifier|const
name|ConstString
operator|&
name|GetFullName
argument_list|()
specifier|const
block|{
return|return
name|m_full
return|;
block|}
name|ConstString
name|GetFullNameWithoutCategory
argument_list|(
argument|bool empty_if_no_category
argument_list|)
block|;
name|bool
name|SetName
argument_list|(
argument|const char *name
argument_list|,
argument|bool strict
argument_list|)
block|;
specifier|const
name|ConstString
operator|&
name|GetClassName
argument_list|()
block|;
specifier|const
name|ConstString
operator|&
name|GetClassNameWithCategory
argument_list|()
block|;
specifier|const
name|ConstString
operator|&
name|GetCategory
argument_list|()
block|;
specifier|const
name|ConstString
operator|&
name|GetSelector
argument_list|()
block|;
comment|// Get all possible names for a method. Examples:
comment|// If name is "+[NSString(my_additions) myStringWithCString:]"
comment|//  names[0] => "+[NSString(my_additions) myStringWithCString:]"
comment|//  names[1] => "+[NSString myStringWithCString:]"
comment|// If name is specified without the leading '+' or '-' like "[NSString(my_additions) myStringWithCString:]"
comment|//  names[0] => "+[NSString(my_additions) myStringWithCString:]"
comment|//  names[1] => "-[NSString(my_additions) myStringWithCString:]"
comment|//  names[2] => "+[NSString myStringWithCString:]"
comment|//  names[3] => "-[NSString myStringWithCString:]"
name|size_t
name|GetFullNames
argument_list|(
argument|std::vector<ConstString>&names
argument_list|,
argument|bool append
argument_list|)
block|;
name|protected
operator|:
name|ConstString
name|m_full
block|;
comment|// Full name:   "+[NSString(my_additions) myStringWithCString:]"
name|ConstString
name|m_class
block|;
comment|// Class name:  "NSString"
name|ConstString
name|m_class_category
block|;
comment|// Class with category: "NSString(my_additions)"
name|ConstString
name|m_category
block|;
comment|// Category:    "my_additions"
name|ConstString
name|m_selector
block|;
comment|// Selector:    "myStringWithCString:"
name|Type
name|m_type
block|;
name|bool
name|m_category_is_valid
block|;      }
decl_stmt|;
typedef|typedef
name|lldb
operator|::
name|addr_t
name|ObjCISA
expr_stmt|;
name|class
name|ClassDescriptor
decl_stmt|;
typedef|typedef
name|std
operator|::
name|shared_ptr
operator|<
name|ClassDescriptor
operator|>
name|ClassDescriptorSP
expr_stmt|;
comment|// the information that we want to support retrieving from an ObjC class
comment|// this needs to be pure virtual since there are at least 2 different implementations
comment|// of the runtime, and more might come
name|class
name|ClassDescriptor
block|{
name|public
label|:
name|ClassDescriptor
argument_list|()
operator|:
name|m_is_kvo
argument_list|(
name|eLazyBoolCalculate
argument_list|)
operator|,
name|m_is_cf
argument_list|(
name|eLazyBoolCalculate
argument_list|)
operator|,
name|m_type_wp
argument_list|()
block|{         }
name|virtual
operator|~
name|ClassDescriptor
argument_list|()
block|{         }
name|virtual
name|ConstString
name|GetClassName
argument_list|()
operator|=
literal|0
expr_stmt|;
name|virtual
name|ClassDescriptorSP
name|GetSuperclass
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetMetaclass
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
comment|// virtual if any implementation has some other version-specific rules
comment|// but for the known v1/v2 this is all that needs to be done
name|virtual
name|bool
name|IsKVO
parameter_list|()
block|{
if|if
condition|(
name|m_is_kvo
operator|==
name|eLazyBoolCalculate
condition|)
block|{
specifier|const
name|char
modifier|*
name|class_name
init|=
name|GetClassName
argument_list|()
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
name|class_name
operator|&&
operator|*
name|class_name
condition|)
name|m_is_kvo
operator|=
call|(
name|LazyBool
call|)
argument_list|(
name|strstr
argument_list|(
name|class_name
argument_list|,
literal|"NSKVONotifying_"
argument_list|)
operator|==
name|class_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_is_kvo
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
comment|// virtual if any implementation has some other version-specific rules
comment|// but for the known v1/v2 this is all that needs to be done
name|virtual
name|bool
name|IsCFType
parameter_list|()
block|{
if|if
condition|(
name|m_is_cf
operator|==
name|eLazyBoolCalculate
condition|)
block|{
specifier|const
name|char
modifier|*
name|class_name
init|=
name|GetClassName
argument_list|()
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
name|class_name
operator|&&
operator|*
name|class_name
condition|)
name|m_is_cf
operator|=
call|(
name|LazyBool
call|)
argument_list|(
name|strcmp
argument_list|(
name|class_name
argument_list|,
literal|"__NSCFType"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|class_name
argument_list|,
literal|"NSCFType"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_is_cf
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
name|virtual
name|bool
name|IsValid
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|GetTaggedPointerInfo
parameter_list|(
name|uint64_t
modifier|*
name|info_bits
init|=
name|NULL
parameter_list|,
name|uint64_t
modifier|*
name|value_bits
init|=
name|NULL
parameter_list|,
name|uint64_t
modifier|*
name|payload
init|=
name|NULL
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|uint64_t
name|GetInstanceSize
parameter_list|()
init|=
literal|0
function_decl|;
comment|// use to implement version-specific additional constraints on pointers
name|virtual
name|bool
name|CheckPointer
argument_list|(
name|lldb
operator|::
name|addr_t
name|value
argument_list|,
name|uint32_t
name|ptr_size
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|ObjCISA
name|GetISA
parameter_list|()
init|=
literal|0
function_decl|;
comment|// This should return true iff the interface could be completed
name|virtual
name|bool
name|Describe
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|ObjCISA
argument_list|)
operator|>
specifier|const
operator|&
name|superclass_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|>
specifier|const
operator|&
name|instance_method_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|>
specifier|const
operator|&
name|class_method_func
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|lldb
operator|::
name|addr_t
argument_list|,
name|uint64_t
argument_list|)
operator|>
specifier|const
operator|&
name|ivar_func
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
name|lldb
operator|::
name|TypeSP
name|GetType
argument_list|()
block|{
return|return
name|m_type_wp
operator|.
name|lock
argument_list|()
return|;
block|}
name|void
name|SetType
argument_list|(
specifier|const
name|lldb
operator|::
name|TypeSP
operator|&
name|type_sp
argument_list|)
block|{
name|m_type_wp
operator|=
name|type_sp
expr_stmt|;
block|}
struct|struct
name|iVarDescriptor
block|{
name|ConstString
name|m_name
decl_stmt|;
name|ClangASTType
name|m_type
decl_stmt|;
name|uint64_t
name|m_size
decl_stmt|;
name|int32_t
name|m_offset
decl_stmt|;
block|}
struct|;
name|virtual
name|size_t
name|GetNumIVars
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|virtual
name|iVarDescriptor
name|GetIVarAtIndex
parameter_list|(
name|size_t
name|idx
parameter_list|)
block|{
return|return
name|iVarDescriptor
argument_list|()
return|;
block|}
name|protected
label|:
name|bool
name|IsPointerValid
argument_list|(
name|lldb
operator|::
name|addr_t
name|value
argument_list|,
name|uint32_t
name|ptr_size
argument_list|,
name|bool
name|allow_NULLs
operator|=
name|false
argument_list|,
name|bool
name|allow_tagged
operator|=
name|false
argument_list|,
name|bool
name|check_version_specific
operator|=
name|false
argument_list|)
decl|const
decl_stmt|;
name|private
label|:
name|LazyBool
name|m_is_kvo
decl_stmt|;
name|LazyBool
name|m_is_cf
decl_stmt|;
name|lldb
operator|::
name|TypeWP
name|m_type_wp
expr_stmt|;
block|}
empty_stmt|;
name|class
name|EncodingToType
block|{
name|public
label|:
name|virtual
name|ClangASTType
name|RealizeType
parameter_list|(
name|ClangASTContext
modifier|&
name|ast_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|for_expression
parameter_list|)
function_decl|;
name|virtual
name|ClangASTType
name|RealizeType
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|for_expression
parameter_list|)
function_decl|;
name|virtual
name|ClangASTType
name|RealizeType
argument_list|(
name|clang
operator|::
name|ASTContext
operator|&
name|ast_ctx
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|,
name|bool
name|for_expression
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
operator|~
name|EncodingToType
argument_list|()
expr_stmt|;
name|protected
label|:
name|std
operator|::
name|unique_ptr
operator|<
name|ClangASTContext
operator|>
name|m_scratch_ast_ctx_ap
expr_stmt|;
block|}
empty_stmt|;
name|class
name|ObjCExceptionPrecondition
range|:
name|public
name|Breakpoint
operator|::
name|BreakpointPrecondition
block|{
name|public
operator|:
name|ObjCExceptionPrecondition
argument_list|()
block|;
name|virtual
operator|~
name|ObjCExceptionPrecondition
argument_list|()
block|{}
name|bool
name|EvaluatePrecondition
argument_list|(
argument|StoppointCallbackContext&context
argument_list|)
name|override
block|;
name|void
name|DescribePrecondition
argument_list|(
argument|Stream&stream
argument_list|,
argument|lldb::DescriptionLevel level
argument_list|)
name|override
block|;
name|Error
name|ConfigurePrecondition
argument_list|(
argument|Args&args
argument_list|)
name|override
block|;
name|protected
operator|:
name|void
name|AddClassName
argument_list|(
specifier|const
name|char
operator|*
name|class_name
argument_list|)
block|;
name|private
operator|:
name|std
operator|::
name|unordered_set
operator|<
name|std
operator|::
name|string
operator|>
name|m_class_names
block|;     }
decl_stmt|;
name|class
name|TaggedPointerVendor
block|{
name|public
label|:
name|virtual
name|bool
name|IsPossibleTaggedPointer
argument_list|(
name|lldb
operator|::
name|addr_t
name|ptr
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|ObjCLanguageRuntime
operator|::
name|ClassDescriptorSP
name|GetClassDescriptor
argument_list|(
argument|lldb::addr_t ptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|virtual
operator|~
name|TaggedPointerVendor
argument_list|()
block|{ }
name|protected
operator|:
name|TaggedPointerVendor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|private
label|:
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|TaggedPointerVendor
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|virtual
name|TaggedPointerVendor
modifier|*
name|GetTaggedPointerVendor
parameter_list|()
block|{
return|return
name|nullptr
return|;
block|}
typedef|typedef
name|std
operator|::
name|shared_ptr
operator|<
name|EncodingToType
operator|>
name|EncodingToTypeSP
expr_stmt|;
name|virtual
name|EncodingToTypeSP
name|GetEncodingToType
parameter_list|()
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptor
parameter_list|(
name|ValueObject
modifier|&
name|in_value
parameter_list|)
function_decl|;
name|ClassDescriptorSP
name|GetNonKVOClassDescriptor
parameter_list|(
name|ValueObject
modifier|&
name|in_value
parameter_list|)
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptorFromClassName
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|class_name
parameter_list|)
function_decl|;
name|virtual
name|ClassDescriptorSP
name|GetClassDescriptorFromISA
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|ClassDescriptorSP
name|GetNonKVOClassDescriptor
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|virtual
operator|~
name|ObjCLanguageRuntime
argument_list|()
expr_stmt|;
name|lldb
operator|::
name|LanguageType
name|GetLanguageType
argument_list|()
specifier|const
name|override
block|{
return|return
name|lldb
operator|::
name|eLanguageTypeObjC
return|;
block|}
name|virtual
name|bool
name|IsModuleObjCLibrary
argument_list|(
specifier|const
name|lldb
operator|::
name|ModuleSP
operator|&
name|module_sp
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|bool
name|ReadObjCLibrary
argument_list|(
specifier|const
name|lldb
operator|::
name|ModuleSP
operator|&
name|module_sp
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|bool
name|HasReadObjCLibrary
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|lldb
operator|::
name|ThreadPlanSP
name|GetStepThroughTrampolinePlan
argument_list|(
argument|Thread&thread
argument_list|,
argument|bool stop_others
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|LookupInMethodCache
argument_list|(
argument|lldb::addr_t class_addr
argument_list|,
argument|lldb::addr_t sel
argument_list|)
expr_stmt|;
name|void
name|AddToMethodCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
name|lldb
operator|::
name|addr_t
name|sel
argument_list|,
name|lldb
operator|::
name|addr_t
name|impl_addr
argument_list|)
decl_stmt|;
name|TypeAndOrName
name|LookupInClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|)
decl_stmt|;
name|void
name|AddToClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|,
name|lldb
operator|::
name|TypeSP
name|type_sp
argument_list|)
decl_stmt|;
name|void
name|AddToClassNameCache
argument_list|(
name|lldb
operator|::
name|addr_t
name|class_addr
argument_list|,
specifier|const
name|TypeAndOrName
operator|&
name|class_or_type_name
argument_list|)
decl_stmt|;
name|lldb
operator|::
name|TypeSP
name|LookupInCompleteClassCache
argument_list|(
name|ConstString
operator|&
name|name
argument_list|)
expr_stmt|;
name|virtual
name|ClangUtilityFunction
modifier|*
name|CreateObjectChecker
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|ObjCRuntimeVersions
name|GetRuntimeVersion
parameter_list|()
block|{
return|return
name|eObjC_VersionUnknown
return|;
block|}
name|bool
name|IsValidISA
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
block|{
name|UpdateISAToDescriptorMap
argument_list|()
expr_stmt|;
return|return
name|m_isa_to_descriptor
operator|.
name|count
argument_list|(
name|isa
argument_list|)
operator|>
literal|0
return|;
block|}
name|virtual
name|void
name|UpdateISAToDescriptorMapIfNeeded
parameter_list|()
init|=
literal|0
function_decl|;
name|void
name|UpdateISAToDescriptorMap
parameter_list|()
block|{
if|if
condition|(
name|m_process
operator|&&
name|m_process
operator|->
name|GetStopID
argument_list|()
operator|!=
name|m_isa_to_descriptor_stop_id
condition|)
block|{
name|UpdateISAToDescriptorMapIfNeeded
argument_list|()
expr_stmt|;
block|}
block|}
name|virtual
name|ObjCISA
name|GetISA
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|)
function_decl|;
name|virtual
name|ConstString
name|GetActualTypeName
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|virtual
name|ObjCISA
name|GetParentClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|)
function_decl|;
name|virtual
name|DeclVendor
modifier|*
name|GetDeclVendor
parameter_list|()
block|{
return|return
name|NULL
return|;
block|}
comment|// Finds the byte offset of the child_type ivar in parent_type.  If it can't find the
comment|// offset, returns LLDB_INVALID_IVAR_OFFSET.
name|virtual
name|size_t
name|GetByteOffsetForIvar
parameter_list|(
name|ClangASTType
modifier|&
name|parent_qual_type
parameter_list|,
specifier|const
name|char
modifier|*
name|ivar_name
parameter_list|)
function_decl|;
comment|// Given the name of an Objective-C runtime symbol (e.g., ivar offset symbol),
comment|// try to determine from the runtime what the value of that symbol would be.
comment|// Useful when the underlying binary is stripped.
name|virtual
name|lldb
operator|::
name|addr_t
name|LookupRuntimeSymbol
argument_list|(
argument|const ConstString&name
argument_list|)
block|{
return|return
name|LLDB_INVALID_ADDRESS
return|;
block|}
comment|//------------------------------------------------------------------
comment|/// Chop up an objective C function prototype.
comment|///
comment|/// Chop up an objective C function fullname and optionally fill in
comment|/// any non-NULL ConstString objects. If a ConstString * is NULL,
comment|/// then this name doesn't get filled in
comment|///
comment|/// @param[in] name
comment|///     A fully specified objective C function name. The string might
comment|///     contain a category and it includes the leading "+" or "-" and
comment|///     the square brackets, no types for the arguments, just the plain
comment|///     selector. A few examples:
comment|///         "-[NSStringDrawingContext init]"
comment|///         "-[NSStringDrawingContext addString:inRect:]"
comment|///         "-[NSString(NSStringDrawing) sizeWithAttributes:]"
comment|///         "+[NSString(NSStringDrawing) usesFontLeading]"
comment|///
comment|/// @param[out] class_name
comment|///     If non-NULL, this string will be filled in with the class
comment|///     name including the category. The examples above would return:
comment|///         "NSStringDrawingContext"
comment|///         "NSStringDrawingContext"
comment|///         "NSString(NSStringDrawing)"
comment|///         "NSString(NSStringDrawing)"
comment|///
comment|/// @param[out] selector_name
comment|///     If non-NULL, this string will be filled in with the selector
comment|///     name. The examples above would return:
comment|///         "init"
comment|///         "addString:inRect:"
comment|///         "sizeWithAttributes:"
comment|///         "usesFontLeading"
comment|///
comment|/// @param[out] name_sans_category
comment|///     If non-NULL, this string will be filled in with the class
comment|///     name _without_ the category. If there is no category, and empty
comment|///     string will be returned (as the result would be normally returned
comment|///     in the "class_name" argument). The examples above would return:
comment|///<empty>
comment|///<empty>
comment|///         "-[NSString sizeWithAttributes:]"
comment|///         "+[NSString usesFontLeading]"
comment|///
comment|/// @param[out] class_name_sans_category
comment|///     If non-NULL, this string will be filled in with the prototype
comment|///     name _without_ the category. If there is no category, and empty
comment|///     string will be returned (as this is already the value that was
comment|///     passed in). The examples above would return:
comment|///<empty>
comment|///<empty>
comment|///         "NSString"
comment|///         "NSString"
comment|///
comment|/// @return
comment|///     Returns the number of strings that were successfully filled
comment|///     in.
comment|//------------------------------------------------------------------
comment|//    static uint32_t
comment|//    ParseMethodName (const char *name,
comment|//                     ConstString *class_name,               // Class name (with category if there is one)
comment|//                     ConstString *selector_name,            // selector only
comment|//                     ConstString *name_sans_category,       // full function name with no category (empty if no category)
comment|//                     ConstString *class_name_sans_category);// Class name without category (empty if no category)
specifier|static
name|bool
name|IsPossibleObjCMethodName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
name|bool
name|starts_right
init|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'['
decl_stmt|;
name|bool
name|ends_right
init|=
operator|(
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
decl_stmt|;
return|return
operator|(
name|starts_right
operator|&&
name|ends_right
operator|)
return|;
block|}
specifier|static
name|bool
name|IsPossibleObjCSelector
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|bool
name|HasNewLiteralsAndIndexing
parameter_list|()
block|{
if|if
condition|(
name|m_has_new_literals_and_indexing
operator|==
name|eLazyBoolCalculate
condition|)
block|{
if|if
condition|(
name|CalculateHasNewLiteralsAndIndexing
argument_list|()
condition|)
name|m_has_new_literals_and_indexing
operator|=
name|eLazyBoolYes
expr_stmt|;
else|else
name|m_has_new_literals_and_indexing
operator|=
name|eLazyBoolNo
expr_stmt|;
block|}
return|return
operator|(
name|m_has_new_literals_and_indexing
operator|==
name|eLazyBoolYes
operator|)
return|;
block|}
name|virtual
name|void
name|SymbolsDidLoad
parameter_list|(
specifier|const
name|ModuleList
modifier|&
name|module_list
parameter_list|)
block|{
name|m_negative_complete_class_cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|GetTypeBitSize
argument_list|(
specifier|const
name|ClangASTType
operator|&
name|clang_type
argument_list|,
name|uint64_t
operator|&
name|size
argument_list|)
name|override
decl_stmt|;
name|protected
label|:
comment|//------------------------------------------------------------------
comment|// Classes that inherit from ObjCLanguageRuntime can see and modify these
comment|//------------------------------------------------------------------
name|ObjCLanguageRuntime
argument_list|(
name|Process
operator|*
name|process
argument_list|)
expr_stmt|;
name|virtual
name|bool
name|CalculateHasNewLiteralsAndIndexing
parameter_list|()
block|{
return|return
name|false
return|;
block|}
name|bool
name|ISAIsCached
argument_list|(
name|ObjCISA
name|isa
argument_list|)
decl|const
block|{
return|return
name|m_isa_to_descriptor
operator|.
name|find
argument_list|(
name|isa
argument_list|)
operator|!=
name|m_isa_to_descriptor
operator|.
name|end
argument_list|()
return|;
block|}
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|!=
literal|0
condition|)
block|{
name|m_isa_to_descriptor
index|[
name|isa
index|]
operator|=
name|descriptor_sp
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|,
specifier|const
name|char
modifier|*
name|class_name
parameter_list|)
function_decl|;
name|bool
name|AddClass
parameter_list|(
name|ObjCISA
name|isa
parameter_list|,
specifier|const
name|ClassDescriptorSP
modifier|&
name|descriptor_sp
parameter_list|,
name|uint32_t
name|class_name_hash
parameter_list|)
block|{
if|if
condition|(
name|isa
operator|!=
literal|0
condition|)
block|{
name|m_isa_to_descriptor
index|[
name|isa
index|]
operator|=
name|descriptor_sp
expr_stmt|;
name|m_hash_to_isa_map
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|class_name_hash
argument_list|,
name|isa
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|private
label|:
comment|// We keep a map of<Class,Selector>->Implementation so we don't have to call the resolver
comment|// function over and over.
comment|// FIXME: We need to watch for the loading of Protocols, and flush the cache for any
comment|// class that we see so changed.
struct|struct
name|ClassAndSel
block|{
name|ClassAndSel
argument_list|()
block|{
name|sel_addr
operator|=
name|LLDB_INVALID_ADDRESS
expr_stmt|;
name|class_addr
operator|=
name|LLDB_INVALID_ADDRESS
expr_stmt|;
block|}
name|ClassAndSel
argument_list|(
argument|lldb::addr_t in_sel_addr
argument_list|,
argument|lldb::addr_t in_class_addr
argument_list|)
block|:
name|class_addr
argument_list|(
name|in_class_addr
argument_list|)
operator|,
name|sel_addr
argument_list|(
argument|in_sel_addr
argument_list|)
block|{         }
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ClassAndSel
operator|&
name|rhs
operator|)
block|{
if|if
condition|(
name|class_addr
operator|==
name|rhs
operator|.
name|class_addr
operator|&&
name|sel_addr
operator|==
name|rhs
operator|.
name|sel_addr
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|ClassAndSel
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|class_addr
operator|<
name|rhs
operator|.
name|class_addr
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|class_addr
operator|>
name|rhs
operator|.
name|class_addr
condition|)
return|return
name|false
return|;
else|else
block|{
if|if
condition|(
name|sel_addr
operator|<
name|rhs
operator|.
name|sel_addr
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
block|}
name|lldb
operator|::
name|addr_t
name|class_addr
expr_stmt|;
name|lldb
operator|::
name|addr_t
name|sel_addr
expr_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ClassAndSel
operator|,
name|lldb
operator|::
name|addr_t
operator|>
name|MsgImplMap
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ObjCISA
operator|,
name|ClassDescriptorSP
operator|>
name|ISAToDescriptorMap
expr_stmt|;
typedef|typedef
name|std
operator|::
name|multimap
operator|<
name|uint32_t
operator|,
name|ObjCISA
operator|>
name|HashToISAMap
expr_stmt|;
typedef|typedef
name|ISAToDescriptorMap
operator|::
name|iterator
name|ISAToDescriptorIterator
expr_stmt|;
typedef|typedef
name|HashToISAMap
operator|::
name|iterator
name|HashToISAIterator
expr_stmt|;
typedef|typedef
name|ThreadSafeDenseMap
operator|<
name|void
operator|*
operator|,
name|uint64_t
operator|>
name|TypeSizeCache
expr_stmt|;
name|MsgImplMap
name|m_impl_cache
decl_stmt|;
name|LazyBool
name|m_has_new_literals_and_indexing
decl_stmt|;
name|ISAToDescriptorMap
name|m_isa_to_descriptor
decl_stmt|;
name|HashToISAMap
name|m_hash_to_isa_map
decl_stmt|;
name|TypeSizeCache
name|m_type_size_cache
decl_stmt|;
name|protected
label|:
name|uint32_t
name|m_isa_to_descriptor_stop_id
decl_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|ConstString
operator|,
name|lldb
operator|::
name|TypeWP
operator|>
name|CompleteClassMap
expr_stmt|;
name|CompleteClassMap
name|m_complete_class_cache
decl_stmt|;
struct|struct
name|ConstStringSetHelpers
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|ConstString
operator|&
name|arg
operator|)
specifier|const
comment|// for hashing
block|{
return|return
operator|(
name|size_t
operator|)
name|arg
operator|.
name|GetCString
argument_list|()
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|ConstString
operator|&
name|arg1
operator|,
specifier|const
name|ConstString
operator|&
name|arg2
operator|)
specifier|const
comment|// for equality
block|{
return|return
name|arg1
operator|.
name|operator
operator|==
operator|(
name|arg2
operator|)
return|;
block|}
block|}
struct|;
typedef|typedef
name|std
operator|::
name|unordered_set
operator|<
name|ConstString
operator|,
name|ConstStringSetHelpers
operator|,
name|ConstStringSetHelpers
operator|>
name|CompleteClassSet
expr_stmt|;
name|CompleteClassSet
name|m_negative_complete_class_cache
decl_stmt|;
name|ISAToDescriptorIterator
name|GetDescriptorIterator
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|name
parameter_list|)
function_decl|;
name|friend
name|class
operator|::
name|CommandObjectObjC_ClassTable_Dump
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|ISAToDescriptorIterator
operator|,
name|ISAToDescriptorIterator
operator|>
name|GetDescriptorIteratorPair
argument_list|(
argument|bool update_if_needed = true
argument_list|)
expr_stmt|;
name|void
name|ReadObjCLibraryIfNeeded
parameter_list|(
specifier|const
name|ModuleList
modifier|&
name|module_list
parameter_list|)
function_decl|;
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|ObjCLanguageRuntime
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_ObjCLanguageRuntime_h_
end_comment

end_unit

