begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- FormattersContainer.h -----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lldb_FormattersContainer_h_
end_ifndef

begin_define
define|#
directive|define
name|lldb_FormattersContainer_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-public.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ValueObject.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/FormatClasses.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/TypeFormat.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/TypeSummary.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/TypeSynthetic.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/TypeValidator.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/CompilerType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/RegularExpression.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/StringLexer.h"
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|IFormatChangeListener
block|{
name|public
label|:
name|virtual
operator|~
name|IFormatChangeListener
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
name|void
name|Changed
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|uint32_t
name|GetCurrentRevision
parameter_list|()
init|=
literal|0
function_decl|;
block|}
empty_stmt|;
comment|// if the user tries to add formatters for, say, "struct Foo"
comment|// those will not match any type because of the way we strip qualifiers from
comment|// typenames
comment|// this method looks for the case where the user is adding a
comment|// "class","struct","enum" or "union" Foo
comment|// and strips the unnecessary qualifier
specifier|static
specifier|inline
name|ConstString
name|GetValidTypeName_Impl
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|IsEmpty
argument_list|()
condition|)
return|return
name|type
return|;
name|std
operator|::
name|string
name|type_cstr
argument_list|(
name|type
operator|.
name|AsCString
argument_list|()
argument_list|)
expr_stmt|;
name|lldb_utility
operator|::
name|StringLexer
name|type_lexer
argument_list|(
name|type_cstr
argument_list|)
expr_stmt|;
name|type_lexer
operator|.
name|AdvanceIf
argument_list|(
literal|"class "
argument_list|)
expr_stmt|;
name|type_lexer
operator|.
name|AdvanceIf
argument_list|(
literal|"enum "
argument_list|)
expr_stmt|;
name|type_lexer
operator|.
name|AdvanceIf
argument_list|(
literal|"struct "
argument_list|)
expr_stmt|;
name|type_lexer
operator|.
name|AdvanceIf
argument_list|(
literal|"union "
argument_list|)
expr_stmt|;
while|while
condition|(
name|type_lexer
operator|.
name|NextIf
argument_list|(
block|{
literal|' '
block|,
literal|'\t'
block|,
literal|'\v'
block|,
literal|'\f'
block|}
argument_list|)
operator|.
name|first
condition|)
empty_stmt|;
return|return
name|ConstString
argument_list|(
name|type_lexer
operator|.
name|GetUnlexed
argument_list|()
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormattersContainer
expr_stmt|;
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormatMap
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ValueType
operator|::
name|SharedPointer
name|ValueSP
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|KeyType
operator|,
name|ValueSP
operator|>
name|MapType
expr_stmt|;
typedef|typedef
name|typename
name|MapType
operator|::
name|iterator
name|MapIterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|function
operator|<
name|bool
argument_list|(
name|KeyType
argument_list|,
specifier|const
name|ValueSP
operator|&
argument_list|)
operator|>
name|ForEachCallback
expr_stmt|;
name|FormatMap
argument_list|(
name|IFormatChangeListener
operator|*
name|lst
argument_list|)
operator|:
name|m_map
argument_list|()
operator|,
name|m_map_mutex
argument_list|()
operator|,
name|listener
argument_list|(
argument|lst
argument_list|)
block|{}
name|void
name|Add
argument_list|(
argument|KeyType name
argument_list|,
argument|const ValueSP&entry
argument_list|)
block|{
if|if
condition|(
name|listener
condition|)
name|entry
operator|->
name|GetRevision
argument_list|()
operator|=
name|listener
operator|->
name|GetCurrentRevision
argument_list|()
expr_stmt|;
else|else
name|entry
operator|->
name|GetRevision
argument_list|()
operator|=
literal|0
expr_stmt|;
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|m_map
index|[
name|name
index|]
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|bool
name|Delete
parameter_list|(
name|KeyType
name|name
parameter_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|m_map
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
name|m_map
operator|.
name|erase
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|m_map
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Get
parameter_list|(
name|KeyType
name|name
parameter_list|,
name|ValueSP
modifier|&
name|entry
parameter_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|m_map
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
name|entry
operator|=
name|iter
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ForEach
parameter_list|(
name|ForEachCallback
name|callback
parameter_list|)
block|{
if|if
condition|(
name|callback
condition|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_map
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|KeyType
name|type
init|=
name|pos
operator|->
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|type
argument_list|,
name|pos
operator|->
name|second
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
name|uint32_t
name|GetCount
parameter_list|()
block|{
return|return
name|m_map
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
name|ValueSP
name|GetValueAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|begin
argument_list|()
decl_stmt|;
name|MapIterator
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|iter
operator|++
expr_stmt|;
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|iter
condition|)
return|return
name|ValueSP
argument_list|()
return|;
block|}
return|return
name|iter
operator|->
name|second
return|;
block|}
end_function

begin_function
name|KeyType
name|GetKeyAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|begin
argument_list|()
decl_stmt|;
name|MapIterator
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|iter
operator|++
expr_stmt|;
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|iter
condition|)
return|return
name|KeyType
argument_list|()
return|;
block|}
return|return
name|iter
operator|->
name|first
return|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|MapType
name|m_map
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|recursive_mutex
name|m_map_mutex
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|IFormatChangeListener
modifier|*
name|listener
decl_stmt|;
end_decl_stmt

begin_function
name|MapType
modifier|&
name|map
parameter_list|()
block|{
return|return
name|m_map
return|;
block|}
end_function

begin_expr_stmt
name|std
operator|::
name|recursive_mutex
operator|&
name|mutex
argument_list|()
block|{
return|return
name|m_map_mutex
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|FormattersContainer
operator|<
name|KeyType
operator|,
name|ValueType
operator|>
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|friend
name|class
name|FormatManager
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormattersContainer
block|{
name|protected
operator|:
typedef|typedef
name|FormatMap
operator|<
name|KeyType
operator|,
name|ValueType
operator|>
name|BackEndType
expr_stmt|;
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|BackEndType
operator|::
name|MapType
name|MapType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|iterator
name|MapIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|key_type
name|MapKeyType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|mapped_type
name|MapValueType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|BackEndType
operator|::
name|ForEachCallback
name|ForEachCallback
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|shared_ptr
operator|<
name|FormattersContainer
operator|<
name|KeyType
operator|,
name|ValueType
operator|>>
name|SharedPointer
expr_stmt|;
end_typedef

begin_decl_stmt
name|friend
name|class
name|TypeCategoryImpl
decl_stmt|;
end_decl_stmt

begin_macro
name|FormattersContainer
argument_list|(
argument|std::string name
argument_list|,
argument|IFormatChangeListener *lst
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|m_format_map
argument_list|(
name|lst
argument_list|)
operator|,
name|m_name
argument_list|(
argument|name
argument_list|)
block|{}
name|void
name|Add
argument_list|(
argument|const MapKeyType&type
argument_list|,
argument|const MapValueType&entry
argument_list|)
block|{
name|Add_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
block|;   }
name|bool
name|Delete
argument_list|(
argument|ConstString type
argument_list|)
block|{
return|return
name|Delete_Impl
argument_list|(
name|type
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|Get
argument_list|(
name|ValueObject
operator|&
name|valobj
argument_list|,
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|DynamicValueType
name|use_dynamic
argument_list|,
name|uint32_t
operator|*
name|why
operator|=
name|nullptr
argument_list|)
block|{
name|uint32_t
name|value
init|=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionDirectChoice
decl_stmt|;
name|CompilerType
name|ast_type
argument_list|(
name|valobj
operator|.
name|GetCompilerType
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|ret
init|=
name|Get
argument_list|(
name|valobj
argument_list|,
name|ast_type
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
name|entry
operator|=
name|MapValueType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
name|MapValueType
argument_list|()
expr_stmt|;
if|if
condition|(
name|why
condition|)
operator|*
name|why
operator|=
name|value
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|)
block|{
return|return
name|Get_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GetExact
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|)
block|{
return|return
name|GetExact_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|MapValueType
name|GetAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|GetValueAtIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex
argument_list|(
argument|size_t index
argument_list|)
block|{
return|return
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
name|index
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_format_map
operator|.
name|Clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForEach
parameter_list|(
name|ForEachCallback
name|callback
parameter_list|)
block|{
name|m_format_map
operator|.
name|ForEach
argument_list|(
name|callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|GetCount
parameter_list|()
block|{
return|return
name|m_format_map
operator|.
name|GetCount
argument_list|()
return|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|BackEndType
name|m_format_map
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|m_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|FormattersContainer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|Add_Impl
argument_list|(
specifier|const
name|MapKeyType
operator|&
name|type
argument_list|,
specifier|const
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|m_format_map
operator|.
name|Add
argument_list|(
name|type
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|Add_Impl
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|type
parameter_list|,
specifier|const
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
name|m_format_map
operator|.
name|Add
argument_list|(
name|GetValidTypeName_Impl
argument_list|(
name|type
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Delete_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|Delete
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|Delete_Impl
argument_list|(
name|ConstString
name|type
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_format_map
operator|.
name|mutex
argument_list|()
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|GetStringRef
argument_list|()
operator|==
name|regex
operator|->
name|GetText
argument_list|()
condition|)
block|{
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|erase
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_format_map
operator|.
name|listener
condition|)
name|m_format_map
operator|.
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|Get
argument_list|(
name|type
argument_list|,
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GetExact_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|Get_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
name|static_cast
operator|<
name|KeyType
operator|*
operator|>
operator|(
name|nullptr
operator|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
argument|size_t index
argument_list|,
argument|ConstString *dummy
argument_list|)
block|{
name|ConstString
name|key
operator|=
name|m_format_map
operator|.
name|GetKeyAtIndex
argument_list|(
name|index
argument_list|)
block|;
if|if
condition|(
name|key
condition|)
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|(
argument|new TypeNameSpecifierImpl(key.AsCString(), false)
argument_list|)
return|;
else|else
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
argument|size_t index
argument_list|,
argument|lldb::RegularExpressionSP *dummy
argument_list|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|m_format_map
operator|.
name|GetKeyAtIndex
argument_list|(
name|index
argument_list|)
block|;
if|if
condition|(
name|regex
operator|.
name|get
argument_list|()
operator|==
name|nullptr
condition|)
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|(
argument|new TypeNameSpecifierImpl(regex->GetText().str().c_str(), true)
argument_list|)
return|;
end_return

begin_macro
unit|}    bool
name|Get_Impl
argument_list|(
argument|ConstString key
argument_list|,
argument|MapValueType&value
argument_list|,
argument|lldb::RegularExpressionSP *dummy
argument_list|)
end_macro

begin_block
block|{
name|llvm
operator|::
name|StringRef
name|key_str
operator|=
name|key
operator|.
name|GetStringRef
argument_list|()
expr_stmt|;
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_format_map
operator|.
name|mutex
argument_list|()
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|regex
operator|->
name|Execute
argument_list|(
name|key_str
argument_list|)
condition|)
block|{
name|value
operator|=
name|pos
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_block

begin_decl_stmt
name|bool
name|GetExact_Impl
argument_list|(
name|ConstString
name|key
argument_list|,
name|MapValueType
operator|&
name|value
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|recursive_mutex
operator|>
name|guard
argument_list|(
name|m_format_map
operator|.
name|mutex
argument_list|()
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|regex
operator|->
name|GetText
argument_list|()
operator|==
name|key
operator|.
name|GetStringRef
argument_list|()
condition|)
block|{
name|value
operator|=
name|pos
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get
parameter_list|(
specifier|const
name|FormattersMatchVector
modifier|&
name|candidates
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|uint32_t
modifier|*
name|reason
parameter_list|)
block|{
for|for
control|(
specifier|const
name|FormattersMatchCandidate
modifier|&
name|candidate
range|:
name|candidates
control|)
block|{
if|if
condition|(
name|Get
argument_list|(
name|candidate
operator|.
name|GetTypeName
argument_list|()
argument_list|,
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|candidate
operator|.
name|IsMatch
argument_list|(
name|entry
argument_list|)
operator|==
name|false
condition|)
block|{
name|entry
operator|.
name|reset
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|candidate
operator|.
name|GetReason
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// lldb_FormattersContainer_h_
end_comment

end_unit

