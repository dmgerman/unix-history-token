begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- FormatNavigator.h ----------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lldb_FormatNavigator_h_
end_ifndef

begin_define
define|#
directive|define
name|lldb_FormatNavigator_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_include
include|#
directive|include
file|"clang/AST/DeclCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-public.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/Log.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/RegularExpression.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Core/ValueObject.h"
end_include

begin_include
include|#
directive|include
file|"lldb/DataFormatters/FormatClasses.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/ClangASTContext.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/ClangASTType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/ObjCLanguageRuntime.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/Process.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/StackFrame.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Target/TargetList.h"
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
comment|// this file (and its. cpp) contain the low-level implementation of LLDB Data Visualization
comment|// class DataVisualization is the high-level front-end of this feature
comment|// clients should refer to that class as the entry-point into the data formatters
comment|// unless they have a good reason to bypass it and prefer to use this file's objects directly
name|class
name|IFormatChangeListener
block|{
name|public
label|:
name|virtual
name|void
name|Changed
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
operator|~
name|IFormatChangeListener
argument_list|()
block|{}
name|virtual
name|uint32_t
name|GetCurrentRevision
argument_list|()
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
specifier|static
specifier|inline
name|bool
name|IsWhitespace
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\v'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|bool
name|HasPrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
return|return
operator|(
operator|::
name|strstr
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|==
name|str1
operator|)
return|;
block|}
comment|// if the user tries to add formatters for, say, "struct Foo"
comment|// those will not match any type because of the way we strip qualifiers from typenames
comment|// this method looks for the case where the user is adding a "class","struct","enum" or "union" Foo
comment|// and strips the unnecessary qualifier
specifier|static
specifier|inline
name|ConstString
name|GetValidTypeName_Impl
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|type
parameter_list|)
block|{
name|int
name|strip_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|false
condition|)
return|return
name|type
return|;
specifier|const
name|char
modifier|*
name|type_cstr
init|=
name|type
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
name|HasPrefix
argument_list|(
name|type_cstr
argument_list|,
literal|"class "
argument_list|)
condition|)
name|strip_len
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|HasPrefix
argument_list|(
name|type_cstr
argument_list|,
literal|"enum "
argument_list|)
condition|)
name|strip_len
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|HasPrefix
argument_list|(
name|type_cstr
argument_list|,
literal|"struct "
argument_list|)
condition|)
name|strip_len
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|HasPrefix
argument_list|(
name|type_cstr
argument_list|,
literal|"union "
argument_list|)
condition|)
name|strip_len
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|strip_len
operator|==
literal|0
condition|)
return|return
name|type
return|;
name|type_cstr
operator|+=
name|strip_len
expr_stmt|;
while|while
condition|(
name|IsWhitespace
argument_list|(
operator|*
name|type_cstr
argument_list|)
operator|&&
operator|++
name|type_cstr
condition|)
empty_stmt|;
return|return
name|ConstString
argument_list|(
name|type_cstr
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormatNavigator
expr_stmt|;
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormatMap
block|{
name|public
operator|:
typedef|typedef
name|typename
name|ValueType
operator|::
name|SharedPointer
name|ValueSP
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|KeyType
operator|,
name|ValueSP
operator|>
name|MapType
expr_stmt|;
typedef|typedef
name|typename
name|MapType
operator|::
name|iterator
name|MapIterator
expr_stmt|;
typedef|typedef
name|bool
function_decl|(
modifier|*
name|CallbackType
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|KeyType
parameter_list|,
specifier|const
name|ValueSP
modifier|&
parameter_list|)
function_decl|;
name|FormatMap
argument_list|(
name|IFormatChangeListener
operator|*
name|lst
argument_list|)
operator|:
name|m_map
argument_list|()
operator|,
name|m_map_mutex
argument_list|(
name|Mutex
operator|::
name|eMutexTypeRecursive
argument_list|)
operator|,
name|listener
argument_list|(
argument|lst
argument_list|)
block|{     }
name|void
name|Add
argument_list|(
argument|KeyType name
argument_list|,
argument|const ValueSP& entry
argument_list|)
block|{
if|if
condition|(
name|listener
condition|)
name|entry
operator|->
name|GetRevision
argument_list|()
operator|=
name|listener
operator|->
name|GetCurrentRevision
argument_list|()
expr_stmt|;
else|else
name|entry
operator|->
name|GetRevision
argument_list|()
operator|=
literal|0
expr_stmt|;
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|m_map
index|[
name|name
index|]
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|bool
name|Delete
parameter_list|(
name|KeyType
name|name
parameter_list|)
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|m_map
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
name|m_map
operator|.
name|erase
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|m_map
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|listener
condition|)
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Get
parameter_list|(
name|KeyType
name|name
parameter_list|,
name|ValueSP
modifier|&
name|entry
parameter_list|)
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|==
name|m_map
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
name|entry
operator|=
name|iter
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|LoopThrough
parameter_list|(
name|CallbackType
name|callback
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
if|if
condition|(
name|callback
condition|)
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_map
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|KeyType
name|type
init|=
name|pos
operator|->
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|callback
argument_list|(
name|param
argument_list|,
name|type
argument_list|,
name|pos
operator|->
name|second
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
name|uint32_t
name|GetCount
parameter_list|()
block|{
return|return
name|m_map
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
name|ValueSP
name|GetValueAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|begin
argument_list|()
decl_stmt|;
name|MapIterator
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|iter
operator|++
expr_stmt|;
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|iter
condition|)
return|return
name|ValueSP
argument_list|()
return|;
block|}
return|return
name|iter
operator|->
name|second
return|;
block|}
end_function

begin_function
name|KeyType
name|GetKeyAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|m_map_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|iter
init|=
name|m_map
operator|.
name|begin
argument_list|()
decl_stmt|;
name|MapIterator
name|end
init|=
name|m_map
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|iter
operator|++
expr_stmt|;
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|iter
condition|)
return|return
name|KeyType
argument_list|()
return|;
block|}
return|return
name|iter
operator|->
name|first
return|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|MapType
name|m_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Mutex
name|m_map_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFormatChangeListener
modifier|*
name|listener
decl_stmt|;
end_decl_stmt

begin_function
name|MapType
modifier|&
name|map
parameter_list|()
block|{
return|return
name|m_map
return|;
block|}
end_function

begin_function
name|Mutex
modifier|&
name|mutex
parameter_list|()
block|{
return|return
name|m_map_mutex
return|;
block|}
end_function

begin_expr_stmt
name|friend
name|class
name|FormatNavigator
operator|<
name|KeyType
operator|,
name|ValueType
operator|>
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|friend
name|class
name|FormatManager
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|KeyType
operator|,
name|typename
name|ValueType
operator|>
name|class
name|FormatNavigator
block|{
name|protected
operator|:
typedef|typedef
name|FormatMap
operator|<
name|KeyType
operator|,
name|ValueType
operator|>
name|BackEndType
expr_stmt|;
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|BackEndType
operator|::
name|MapType
name|MapType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|iterator
name|MapIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|key_type
name|MapKeyType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|MapType
operator|::
name|mapped_type
name|MapValueType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|BackEndType
operator|::
name|CallbackType
name|CallbackType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|shared_ptr
operator|<
name|FormatNavigator
operator|<
name|KeyType
operator|,
name|ValueType
operator|>
expr|>
name|SharedPointer
expr_stmt|;
end_typedef

begin_decl_stmt
name|friend
name|class
name|TypeCategoryImpl
decl_stmt|;
end_decl_stmt

begin_macro
name|FormatNavigator
argument_list|(
argument|std::string name
argument_list|,
argument|IFormatChangeListener* lst
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|m_format_map
argument_list|(
name|lst
argument_list|)
operator|,
name|m_name
argument_list|(
name|name
argument_list|)
operator|,
name|m_id_cs
argument_list|(
argument|ConstString(
literal|"id"
argument|)
argument_list|)
block|{     }
name|void
name|Add
argument_list|(
argument|const MapKeyType&type
argument_list|,
argument|const MapValueType& entry
argument_list|)
block|{
name|Add_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
name|NULL
argument_list|)
block|;     }
name|bool
name|Delete
argument_list|(
argument|ConstString type
argument_list|)
block|{
return|return
name|Delete_Impl
argument_list|(
name|type
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|Get
argument_list|(
name|ValueObject
operator|&
name|valobj
argument_list|,
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|DynamicValueType
name|use_dynamic
argument_list|,
name|uint32_t
operator|*
name|why
operator|=
name|NULL
argument_list|)
block|{
name|uint32_t
name|value
init|=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionDirectChoice
decl_stmt|;
name|ClangASTType
name|ast_type
argument_list|(
name|valobj
operator|.
name|GetClangType
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|ret
init|=
name|Get
argument_list|(
name|valobj
argument_list|,
name|ast_type
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
name|entry
operator|=
name|MapValueType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
name|MapValueType
argument_list|()
expr_stmt|;
if|if
condition|(
name|why
condition|)
operator|*
name|why
operator|=
name|value
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|)
block|{
return|return
name|Get_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GetExact
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|)
block|{
return|return
name|GetExact_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|MapValueType
name|GetAtIndex
parameter_list|(
name|size_t
name|index
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|GetValueAtIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex
argument_list|(
argument|size_t index
argument_list|)
block|{
return|return
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
name|index
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_format_map
operator|.
name|Clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LoopThrough
parameter_list|(
name|CallbackType
name|callback
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|m_format_map
operator|.
name|LoopThrough
argument_list|(
name|callback
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|GetCount
parameter_list|()
block|{
return|return
name|m_format_map
operator|.
name|GetCount
argument_list|()
return|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|BackEndType
name|m_format_map
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|m_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DISALLOW_COPY_AND_ASSIGN
argument_list|(
name|FormatNavigator
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ConstString
name|m_id_cs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|Add_Impl
argument_list|(
specifier|const
name|MapKeyType
operator|&
name|type
argument_list|,
specifier|const
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|m_format_map
operator|.
name|Add
argument_list|(
name|type
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|Add_Impl
parameter_list|(
specifier|const
name|ConstString
modifier|&
name|type
parameter_list|,
specifier|const
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
name|m_format_map
operator|.
name|Add
argument_list|(
name|GetValidTypeName_Impl
argument_list|(
name|type
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Delete_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|Delete
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|Delete_Impl
argument_list|(
name|ConstString
name|type
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|Mutex
modifier|&
name|x_mutex
init|=
name|m_format_map
operator|.
name|mutex
argument_list|()
decl_stmt|;
name|lldb_private
operator|::
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|x_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
operator|::
name|strcmp
argument_list|(
name|type
operator|.
name|AsCString
argument_list|()
argument_list|,
name|regex
operator|->
name|GetText
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|erase
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_format_map
operator|.
name|listener
condition|)
name|m_format_map
operator|.
name|listener
operator|->
name|Changed
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|m_format_map
operator|.
name|Get
argument_list|(
name|type
argument_list|,
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GetExact_Impl
parameter_list|(
name|ConstString
name|type
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|ConstString
modifier|*
name|dummy
parameter_list|)
block|{
return|return
name|Get_Impl
argument_list|(
name|type
argument_list|,
name|entry
argument_list|,
operator|(
name|KeyType
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
argument|size_t index
argument_list|,
argument|ConstString *dummy
argument_list|)
block|{
name|ConstString
name|key
operator|=
name|m_format_map
operator|.
name|GetKeyAtIndex
argument_list|(
name|index
argument_list|)
block|;
if|if
condition|(
name|key
condition|)
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|(
argument|new TypeNameSpecifierImpl(key.AsCString(),                                                                            false)
argument_list|)
return|;
else|else
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|lldb
operator|::
name|TypeNameSpecifierImplSP
name|GetTypeNameSpecifierAtIndex_Impl
argument_list|(
argument|size_t index
argument_list|,
argument|lldb::RegularExpressionSP *dummy
argument_list|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|m_format_map
operator|.
name|GetKeyAtIndex
argument_list|(
name|index
argument_list|)
block|;
if|if
condition|(
name|regex
operator|.
name|get
argument_list|()
operator|==
name|NULL
condition|)
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|lldb
operator|::
name|TypeNameSpecifierImplSP
argument_list|(
argument|new TypeNameSpecifierImpl(regex->GetText(),                                                                        true)
argument_list|)
return|;
end_return

begin_macro
unit|}      bool
name|Get_Impl
argument_list|(
argument|ConstString key
argument_list|,
argument|MapValueType& value
argument_list|,
argument|lldb::RegularExpressionSP *dummy
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|key_cstr
init|=
name|key
operator|.
name|AsCString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|key_cstr
condition|)
return|return
name|false
return|;
name|Mutex
modifier|&
name|x_mutex
init|=
name|m_format_map
operator|.
name|mutex
argument_list|()
decl_stmt|;
name|lldb_private
operator|::
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|x_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|regex
operator|->
name|Execute
argument_list|(
name|key_cstr
argument_list|)
condition|)
block|{
name|value
operator|=
name|pos
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_block

begin_decl_stmt
name|bool
name|GetExact_Impl
argument_list|(
name|ConstString
name|key
argument_list|,
name|MapValueType
operator|&
name|value
argument_list|,
name|lldb
operator|::
name|RegularExpressionSP
operator|*
name|dummy
argument_list|)
block|{
name|Mutex
modifier|&
name|x_mutex
init|=
name|m_format_map
operator|.
name|mutex
argument_list|()
decl_stmt|;
name|lldb_private
operator|::
name|Mutex
operator|::
name|Locker
name|locker
argument_list|(
name|x_mutex
argument_list|)
expr_stmt|;
name|MapIterator
name|pos
decl_stmt|,
name|end
init|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_format_map
operator|.
name|map
argument_list|()
operator|.
name|begin
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
name|pos
operator|++
control|)
block|{
name|lldb
operator|::
name|RegularExpressionSP
name|regex
operator|=
name|pos
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|regex
operator|->
name|GetText
argument_list|()
argument_list|,
name|key
operator|.
name|AsCString
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|pos
operator|->
name|second
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|Get_BitfieldMatch
parameter_list|(
name|ValueObject
modifier|&
name|valobj
parameter_list|,
name|ConstString
name|typeName
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|,
name|uint32_t
modifier|&
name|reason
parameter_list|)
block|{
name|Log
modifier|*
name|log
argument_list|(
name|lldb_private
operator|::
name|GetLogIfAllCategoriesSet
argument_list|(
name|LIBLLDB_LOG_TYPES
argument_list|)
argument_list|)
decl_stmt|;
comment|// for bitfields, append size to the typename so one can custom format them
name|StreamString
name|sstring
decl_stmt|;
name|sstring
operator|.
name|Printf
argument_list|(
literal|"%s:%d"
argument_list|,
name|typeName
operator|.
name|AsCString
argument_list|()
argument_list|,
name|valobj
operator|.
name|GetBitfieldBitSize
argument_list|()
argument_list|)
expr_stmt|;
name|ConstString
name|bitfieldname
init|=
name|ConstString
argument_list|(
name|sstring
operator|.
name|GetData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_BitfieldMatch] appended bitfield info, final result is %s"
argument_list|,
name|bitfieldname
operator|.
name|GetCString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get
argument_list|(
name|bitfieldname
argument_list|,
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_BitfieldMatch] bitfield direct match found, returning"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionStrippedBitField
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_BitfieldMatch] no bitfield direct match"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
name|bool
name|Get_ObjC
parameter_list|(
name|ValueObject
modifier|&
name|valobj
parameter_list|,
name|MapValueType
modifier|&
name|entry
parameter_list|)
block|{
name|Log
modifier|*
name|log
argument_list|(
name|lldb_private
operator|::
name|GetLogIfAllCategoriesSet
argument_list|(
name|LIBLLDB_LOG_TYPES
argument_list|)
argument_list|)
decl_stmt|;
name|lldb
operator|::
name|ProcessSP
name|process_sp
operator|=
name|valobj
operator|.
name|GetProcessSP
argument_list|()
expr_stmt|;
name|ObjCLanguageRuntime
modifier|*
name|runtime
init|=
name|process_sp
operator|->
name|GetObjCLanguageRuntime
argument_list|()
decl_stmt|;
if|if
condition|(
name|runtime
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_ObjC] no valid ObjC runtime, skipping dynamic"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ObjCLanguageRuntime
operator|::
name|ClassDescriptorSP
name|objc_class_sp
argument_list|(
name|runtime
operator|->
name|GetClassDescriptor
argument_list|(
name|valobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_class_sp
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_ObjC] invalid ISA, skipping dynamic"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ConstString
name|name
argument_list|(
name|objc_class_sp
operator|->
name|GetClassName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_ObjC] dynamic type inferred is %s - looking for direct dynamic match"
argument_list|,
name|name
operator|.
name|GetCString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get
argument_list|(
name|name
argument_list|,
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_ObjC] direct dynamic match found, returning"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_ObjC] no dynamic match"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|Get_Impl
argument_list|(
name|ValueObject
operator|&
name|valobj
argument_list|,
name|ClangASTType
name|clang_type
argument_list|,
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|DynamicValueType
name|use_dynamic
argument_list|,
name|uint32_t
operator|&
name|reason
argument_list|)
block|{
name|Log
modifier|*
name|log
argument_list|(
name|lldb_private
operator|::
name|GetLogIfAllCategoriesSet
argument_list|(
name|LIBLLDB_LOG_TYPES
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|clang_type
operator|.
name|IsValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] type is invalid, returning"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|clang_type
operator|=
name|clang_type
operator|.
name|RemoveFastQualifiers
argument_list|()
expr_stmt|;
name|ConstString
name|typeName
argument_list|(
name|clang_type
operator|.
name|GetConstTypeName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|valobj
operator|.
name|GetBitfieldBitSize
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|Get_BitfieldMatch
argument_list|(
name|valobj
argument_list|,
name|typeName
argument_list|,
name|entry
argument_list|,
name|reason
argument_list|)
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] trying to get %s for VO name %s of type %s"
argument_list|,
name|m_name
operator|.
name|c_str
argument_list|()
argument_list|,
name|valobj
operator|.
name|GetName
argument_list|()
operator|.
name|AsCString
argument_list|()
argument_list|,
name|typeName
operator|.
name|AsCString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get
argument_list|(
name|typeName
argument_list|,
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] direct match found, returning"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] no direct match"
argument_list|)
expr_stmt|;
comment|// strip pointers and references and see if that helps
if|if
condition|(
name|clang_type
operator|.
name|IsReferenceType
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] stripping reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|clang_type
operator|.
name|GetNonReferenceType
argument_list|()
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
operator|&&
operator|!
name|entry
operator|->
name|SkipsReferences
argument_list|()
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionStrippedPointerReference
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|clang_type
operator|.
name|IsPointerType
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] stripping pointer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|clang_type
operator|.
name|GetPointeeType
argument_list|()
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
operator|&&
operator|!
name|entry
operator|->
name|SkipsPointers
argument_list|()
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionStrippedPointerReference
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|bool
name|canBeObjCDynamic
init|=
name|valobj
operator|.
name|GetClangType
argument_list|()
operator|.
name|IsPossibleDynamicType
argument_list|(
name|NULL
argument_list|,
name|false
argument_list|,
comment|// no C++
name|true
argument_list|)
decl_stmt|;
comment|// yes ObjC
if|if
condition|(
name|canBeObjCDynamic
condition|)
block|{
if|if
condition|(
name|use_dynamic
operator|!=
name|lldb
operator|::
name|eNoDynamicValues
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] allowed to figure out dynamic ObjC type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_ObjC
argument_list|(
name|valobj
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionDynamicObjCDiscovery
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] dynamic disabled or failed - stripping ObjC pointer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|clang_type
operator|.
name|GetPointeeType
argument_list|()
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
operator|&&
operator|!
name|entry
operator|->
name|SkipsPointers
argument_list|()
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionStrippedPointerReference
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|// try to strip typedef chains
if|if
condition|(
name|clang_type
operator|.
name|IsTypedefType
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get_Impl] stripping typedef"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|clang_type
operator|.
name|GetTypedefedType
argument_list|()
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
operator|)
operator|&&
name|entry
operator|->
name|Cascades
argument_list|()
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionNavigatedTypedefs
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|// out of luck here
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// we are separately passing in valobj and type because the valobj is fixed (and is used for ObjC discovery and bitfield size)
end_comment

begin_comment
comment|// but the type can change (e.g. stripping pointers, ...)
end_comment

begin_decl_stmt
name|bool
name|Get
argument_list|(
name|ValueObject
operator|&
name|valobj
argument_list|,
name|ClangASTType
name|clang_type
argument_list|,
name|MapValueType
operator|&
name|entry
argument_list|,
name|lldb
operator|::
name|DynamicValueType
name|use_dynamic
argument_list|,
name|uint32_t
operator|&
name|reason
argument_list|)
block|{
name|Log
modifier|*
name|log
argument_list|(
name|lldb_private
operator|::
name|GetLogIfAllCategoriesSet
argument_list|(
name|LIBLLDB_LOG_TYPES
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|clang_type
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
condition|)
return|return
name|true
return|;
comment|// try going to the unqualified type
do|do
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] trying the unqualified type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clang_type
operator|.
name|IsValid
argument_list|()
condition|)
break|break;
name|ClangASTType
name|unqual_clang_ast_type
init|=
name|clang_type
operator|.
name|GetFullyUnqualifiedType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|unqual_clang_ast_type
operator|.
name|IsValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] could not get the unqual_clang_ast_type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unqual_clang_ast_type
operator|.
name|GetOpaqueQualType
argument_list|()
operator|!=
name|clang_type
operator|.
name|GetOpaqueQualType
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] unqualified type is there and is not the same, let's try"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get_Impl
argument_list|(
name|valobj
argument_list|,
name|unqual_clang_ast_type
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] unqualified type same as original type"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
comment|// if all else fails, go to static type
if|if
condition|(
name|valobj
operator|.
name|IsDynamic
argument_list|()
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] going to static value"
argument_list|)
expr_stmt|;
name|lldb
operator|::
name|ValueObjectSP
name|static_value_sp
argument_list|(
name|valobj
operator|.
name|GetStaticValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_value_sp
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|log
operator|->
name|Printf
argument_list|(
literal|"[Get] has a static value - actually use it"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Get
argument_list|(
operator|*
name|static_value_sp
operator|.
name|get
argument_list|()
argument_list|,
name|static_value_sp
operator|->
name|GetClangType
argument_list|()
argument_list|,
name|entry
argument_list|,
name|use_dynamic
argument_list|,
name|reason
argument_list|)
condition|)
block|{
name|reason
operator||=
name|lldb_private
operator|::
name|eFormatterChoiceCriterionWentToStaticValue
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
unit|};  }
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// lldb_FormatNavigator_h_
end_comment

end_unit

