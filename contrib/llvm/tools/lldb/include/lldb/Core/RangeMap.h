begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RangeMap.h ----------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_RangeMap_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_RangeMap_h_
end_define

begin_comment
comment|// C Includes
end_comment

begin_comment
comment|// C++ Includes
end_comment

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_comment
comment|// Uncomment to make sure all Range objects are sorted when needed
end_comment

begin_comment
comment|//#define ASSERT_RANGEMAP_ARE_SORTED
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
comment|//----------------------------------------------------------------------
comment|// Templatized classes for dealing with generic ranges and also
comment|// collections of ranges, or collections of ranges that have associated
comment|// data.
comment|//----------------------------------------------------------------------
comment|//----------------------------------------------------------------------
comment|// A simple range class where you get to define the type of the range
comment|// base "B", and the type used for the range byte size "S".
comment|//----------------------------------------------------------------------
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|>
expr|struct
name|Range
block|{
typedef|typedef
name|B
name|BaseType
typedef|;
typedef|typedef
name|S
name|SizeType
typedef|;
name|BaseType
name|base
decl_stmt|;
name|SizeType
name|size
decl_stmt|;
name|Range
argument_list|()
operator|:
name|base
argument_list|(
literal|0
argument_list|)
operator|,
name|size
argument_list|(
literal|0
argument_list|)
block|{         }
name|Range
argument_list|(
argument|BaseType b
argument_list|,
argument|SizeType s
argument_list|)
operator|:
name|base
argument_list|(
name|b
argument_list|)
operator|,
name|size
argument_list|(
argument|s
argument_list|)
block|{         }
name|void
name|Clear
argument_list|(
argument|BaseType b =
literal|0
argument_list|)
block|{
name|base
operator|=
name|b
block|;
name|size
operator|=
literal|0
block|;         }
comment|// Set the start value for the range, and keep the same size
name|BaseType
name|GetRangeBase
argument_list|()
specifier|const
block|{
return|return
name|base
return|;
block|}
name|void
name|SetRangeBase
parameter_list|(
name|BaseType
name|b
parameter_list|)
block|{
name|base
operator|=
name|b
expr_stmt|;
block|}
name|void
name|Slide
parameter_list|(
name|BaseType
name|slide
parameter_list|)
block|{
name|base
operator|+=
name|slide
expr_stmt|;
block|}
name|BaseType
name|GetRangeEnd
argument_list|()
specifier|const
block|{
return|return
name|base
operator|+
name|size
return|;
block|}
name|void
name|SetRangeEnd
parameter_list|(
name|BaseType
name|end
parameter_list|)
block|{
if|if
condition|(
name|end
operator|>
name|base
condition|)
name|size
operator|=
name|end
operator|-
name|base
expr_stmt|;
else|else
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|SizeType
name|GetByteSize
argument_list|()
specifier|const
block|{
return|return
name|size
return|;
block|}
name|void
name|SetByteSize
parameter_list|(
name|SizeType
name|s
parameter_list|)
block|{
name|size
operator|=
name|s
expr_stmt|;
block|}
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
name|size
operator|>
literal|0
return|;
block|}
name|bool
name|Contains
argument_list|(
name|BaseType
name|r
argument_list|)
decl|const
block|{
return|return
operator|(
name|GetRangeBase
argument_list|()
operator|<=
name|r
operator|)
operator|&&
operator|(
name|r
operator|<
name|GetRangeEnd
argument_list|()
operator|)
return|;
block|}
name|bool
name|ContainsEndInclusive
argument_list|(
name|BaseType
name|r
argument_list|)
decl|const
block|{
return|return
operator|(
name|GetRangeBase
argument_list|()
operator|<=
name|r
operator|)
operator|&&
operator|(
name|r
operator|<=
name|GetRangeEnd
argument_list|()
operator|)
return|;
block|}
name|bool
name|Contains
argument_list|(
specifier|const
name|Range
operator|&
name|range
argument_list|)
decl|const
block|{
return|return
name|Contains
argument_list|(
name|range
operator|.
name|GetRangeBase
argument_list|()
argument_list|)
operator|&&
name|ContainsEndInclusive
argument_list|(
name|range
operator|.
name|GetRangeEnd
argument_list|()
argument_list|)
return|;
block|}
comment|// Returns true if the two ranges adjoing or intersect
name|bool
name|DoesAdjoinOrIntersect
argument_list|(
specifier|const
name|Range
operator|&
name|rhs
argument_list|)
decl|const
block|{
specifier|const
name|BaseType
name|lhs_base
init|=
name|this
operator|->
name|GetRangeBase
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|rhs_base
init|=
name|rhs
operator|.
name|GetRangeBase
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|lhs_end
init|=
name|this
operator|->
name|GetRangeEnd
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|rhs_end
init|=
name|rhs
operator|.
name|GetRangeEnd
argument_list|()
decl_stmt|;
name|bool
name|result
init|=
operator|(
name|lhs_base
operator|<=
name|rhs_end
operator|)
operator|&&
operator|(
name|lhs_end
operator|>=
name|rhs_base
operator|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|// Returns true if the two ranges intersect
name|bool
name|DoesIntersect
argument_list|(
specifier|const
name|Range
operator|&
name|rhs
argument_list|)
decl|const
block|{
specifier|const
name|BaseType
name|lhs_base
init|=
name|this
operator|->
name|GetRangeBase
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|rhs_base
init|=
name|rhs
operator|.
name|GetRangeBase
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|lhs_end
init|=
name|this
operator|->
name|GetRangeEnd
argument_list|()
decl_stmt|;
specifier|const
name|BaseType
name|rhs_end
init|=
name|rhs
operator|.
name|GetRangeEnd
argument_list|()
decl_stmt|;
name|bool
name|result
init|=
operator|(
name|lhs_base
operator|<
name|rhs_end
operator|)
operator|&&
operator|(
name|lhs_end
operator|>
name|rhs_base
operator|)
decl_stmt|;
return|return
name|result
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|Range
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|base
operator|==
name|rhs
operator|.
name|base
condition|)
return|return
name|size
operator|<
name|rhs
operator|.
name|size
return|;
return|return
name|base
operator|<
name|rhs
operator|.
name|base
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Range
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|base
operator|==
name|rhs
operator|.
name|base
operator|&&
name|size
operator|==
name|rhs
operator|.
name|size
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Range
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|base
operator|!=
name|rhs
operator|.
name|base
operator|||
name|size
operator|!=
name|rhs
operator|.
name|size
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// A range array class where you get to define the type of the ranges
end_comment

begin_comment
comment|// that the collection contains.
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|,
name|unsigned
name|N
operator|>
name|class
name|RangeArray
block|{
name|public
operator|:
typedef|typedef
name|B
name|BaseType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|S
name|SizeType
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Range
operator|<
name|B
operator|,
name|S
operator|>
name|Entry
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Entry
operator|,
name|N
operator|>
name|Collection
expr_stmt|;
end_typedef

begin_expr_stmt
name|RangeArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|RangeArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Append
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|)
block|{
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Append
parameter_list|(
name|B
name|base
parameter_list|,
name|S
name|size
parameter_list|)
block|{
name|m_entries
operator|.
name|emplace_back
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|RemoveEntrtAtIndex
parameter_list|(
name|uint32_t
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
name|m_entries
operator|.
name|size
argument_list|()
condition|)
block|{
name|m_entries
operator|.
name|erase
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
operator|+
name|idx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|Sort
parameter_list|()
block|{
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|std
operator|::
name|stable_sort
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
argument_list|,
name|m_entries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
end_ifdef

begin_expr_stmt
name|bool
name|IsSorted
argument_list|()
specifier|const
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
block|,
name|end
block|,
name|prev
block|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
operator|*
name|pos
operator|<
operator|*
name|prev
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|void
name|CombineConsecutiveRanges
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Can't combine if ranges if we have zero or one range
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// The list should be sorted prior to calling this function
name|typename
name|Collection
operator|::
name|iterator
name|pos
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|prev
expr_stmt|;
name|bool
name|can_combine
init|=
name|false
decl_stmt|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|DoesAdjoinOrIntersect
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
block|{
name|can_combine
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We we can combine at least one entry, then we make a new collection
comment|// and populate it accordingly, and then swap it into place.
if|if
condition|(
name|can_combine
condition|)
block|{
name|Collection
name|minimal_ranges
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|DoesAdjoinOrIntersect
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
name|minimal_ranges
operator|.
name|back
argument_list|()
operator|.
name|SetRangeEnd
argument_list|(
name|std
operator|::
name|max
operator|<
name|BaseType
operator|>
operator|(
name|prev
operator|->
name|GetRangeEnd
argument_list|()
operator|,
name|pos
operator|->
name|GetRangeEnd
argument_list|()
operator|)
argument_list|)
expr_stmt|;
else|else
name|minimal_ranges
operator|.
name|push_back
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// Use the swap technique in case our new vector is much smaller.
comment|// We must swap when using the STL because std::vector objects never
comment|// release or reduce the memory once it has been allocated/reserved.
name|m_entries
operator|.
name|swap
argument_list|(
name|minimal_ranges
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|BaseType
name|GetMinRangeBase
argument_list|(
name|BaseType
name|fail_value
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
return|return
name|fail_value
return|;
comment|// m_entries must be sorted, so if we aren't empty, we grab the
comment|// first range's base
return|return
name|m_entries
operator|.
name|front
argument_list|()
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|BaseType
name|GetMaxRangeEnd
argument_list|(
name|BaseType
name|fail_value
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
return|return
name|fail_value
return|;
comment|// m_entries must be sorted, so if we aren't empty, we grab the
comment|// last range's end
return|return
name|m_entries
operator|.
name|back
argument_list|()
operator|.
name|GetRangeEnd
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|void
name|Slide
parameter_list|(
name|BaseType
name|slide
parameter_list|)
block|{
name|typename
name|Collection
operator|::
name|iterator
name|pos
operator|,
name|end
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
operator|++
name|pos
control|)
name|pos
operator|->
name|Slide
argument_list|(
name|slide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_entries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|GetEntryAtIndex
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Clients must ensure that "i" is a valid index prior to calling this function
end_comment

begin_decl_stmt
specifier|const
name|Entry
modifier|&
name|GetEntryRef
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
name|m_entries
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|Back
parameter_list|()
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Entry
operator|*
name|Back
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|BaseLessThan
parameter_list|(
specifier|const
name|Entry
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Entry
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|GetRangeBase
argument_list|()
operator|<
name|rhs
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|uint32_t
name|FindEntryIndexThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
specifier|const
name|Entry
operator|&
name|range
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|range
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|Collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|>
name|class
name|RangeVector
block|{
name|public
operator|:
typedef|typedef
name|B
name|BaseType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|S
name|SizeType
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Range
operator|<
name|B
operator|,
name|S
operator|>
name|Entry
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Entry
operator|>
name|Collection
expr_stmt|;
end_typedef

begin_expr_stmt
name|RangeVector
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|RangeVector
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Append
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|)
block|{
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Append
parameter_list|(
name|B
name|base
parameter_list|,
name|S
name|size
parameter_list|)
block|{
name|m_entries
operator|.
name|emplace_back
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|RemoveEntrtAtIndex
parameter_list|(
name|uint32_t
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
name|m_entries
operator|.
name|size
argument_list|()
condition|)
block|{
name|m_entries
operator|.
name|erase
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
operator|+
name|idx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|Sort
parameter_list|()
block|{
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|std
operator|::
name|stable_sort
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
argument_list|,
name|m_entries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
end_ifdef

begin_expr_stmt
name|bool
name|IsSorted
argument_list|()
specifier|const
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
block|,
name|end
block|,
name|prev
block|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
operator|*
name|pos
operator|<
operator|*
name|prev
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|void
name|CombineConsecutiveRanges
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Can't combine if ranges if we have zero or one range
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// The list should be sorted prior to calling this function
name|typename
name|Collection
operator|::
name|iterator
name|pos
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|prev
expr_stmt|;
name|bool
name|can_combine
init|=
name|false
decl_stmt|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|DoesAdjoinOrIntersect
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
block|{
name|can_combine
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We we can combine at least one entry, then we make a new collection
comment|// and populate it accordingly, and then swap it into place.
if|if
condition|(
name|can_combine
condition|)
block|{
name|Collection
name|minimal_ranges
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|DoesAdjoinOrIntersect
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
name|minimal_ranges
operator|.
name|back
argument_list|()
operator|.
name|SetRangeEnd
argument_list|(
name|std
operator|::
name|max
operator|<
name|BaseType
operator|>
operator|(
name|prev
operator|->
name|GetRangeEnd
argument_list|()
operator|,
name|pos
operator|->
name|GetRangeEnd
argument_list|()
operator|)
argument_list|)
expr_stmt|;
else|else
name|minimal_ranges
operator|.
name|push_back
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// Use the swap technique in case our new vector is much smaller.
comment|// We must swap when using the STL because std::vector objects never
comment|// release or reduce the memory once it has been allocated/reserved.
name|m_entries
operator|.
name|swap
argument_list|(
name|minimal_ranges
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|BaseType
name|GetMinRangeBase
argument_list|(
name|BaseType
name|fail_value
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
return|return
name|fail_value
return|;
comment|// m_entries must be sorted, so if we aren't empty, we grab the
comment|// first range's base
return|return
name|m_entries
operator|.
name|front
argument_list|()
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|BaseType
name|GetMaxRangeEnd
argument_list|(
name|BaseType
name|fail_value
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
return|return
name|fail_value
return|;
comment|// m_entries must be sorted, so if we aren't empty, we grab the
comment|// last range's end
return|return
name|m_entries
operator|.
name|back
argument_list|()
operator|.
name|GetRangeEnd
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|void
name|Slide
parameter_list|(
name|BaseType
name|slide
parameter_list|)
block|{
name|typename
name|Collection
operator|::
name|iterator
name|pos
operator|,
name|end
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
operator|++
name|pos
control|)
name|pos
operator|->
name|Slide
argument_list|(
name|slide
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_entries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|Reserve
argument_list|(
name|typename
name|Collection
operator|::
name|size_type
name|size
argument_list|)
block|{
name|m_entries
operator|.
name|reserve
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|GetEntryAtIndex
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Clients must ensure that "i" is a valid index prior to calling this function
end_comment

begin_decl_stmt
specifier|const
name|Entry
modifier|&
name|GetEntryRef
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
name|m_entries
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|Back
parameter_list|()
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Entry
operator|*
name|Back
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|BaseLessThan
parameter_list|(
specifier|const
name|Entry
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Entry
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|GetRangeBase
argument_list|()
operator|<
name|rhs
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|uint32_t
name|FindEntryIndexThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
specifier|const
name|Entry
operator|&
name|range
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|range
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|Collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// A simple range  with data class where you get to define the type of
end_comment

begin_comment
comment|// the range base "B", the type used for the range byte size "S", and
end_comment

begin_comment
comment|// the type for the associated data "T".
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|,
name|typename
name|T
operator|>
expr|struct
name|RangeData
operator|:
name|public
name|Range
operator|<
name|B
operator|,
name|S
operator|>
block|{
typedef|typedef
name|T
name|DataType
typedef|;
name|DataType
name|data
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RangeData
argument_list|()
operator|:
name|Range
operator|<
name|B
operator|,
name|S
operator|>
operator|(
operator|)
operator|,
name|data
argument_list|()
block|{         }
name|RangeData
argument_list|(
argument|B base
argument_list|,
argument|S size
argument_list|)
operator|:
name|Range
operator|<
name|B
operator|,
name|S
operator|>
operator|(
name|base
operator|,
name|size
operator|)
operator|,
name|data
argument_list|()
block|{         }
name|RangeData
argument_list|(
argument|B base
argument_list|,
argument|S size
argument_list|,
argument|DataType d
argument_list|)
operator|:
name|Range
operator|<
name|B
operator|,
name|S
operator|>
operator|(
name|base
operator|,
name|size
operator|)
operator|,
name|data
argument_list|(
argument|d
argument_list|)
block|{         }
name|bool
name|operator
operator|<
operator|(
specifier|const
name|RangeData
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|this
operator|->
name|base
operator|==
name|rhs
operator|.
name|base
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|size
operator|==
name|rhs
operator|.
name|size
condition|)
return|return
name|this
operator|->
name|data
operator|<
name|rhs
operator|.
name|data
return|;
else|else
return|return
name|this
operator|->
name|size
operator|<
name|rhs
operator|.
name|size
return|;
block|}
end_expr_stmt

begin_return
return|return
name|this
operator|->
name|base
operator|<
name|rhs
operator|.
name|base
return|;
end_return

begin_expr_stmt
unit|}                  bool
name|operator
operator|==
operator|(
specifier|const
name|RangeData
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|GetRangeBase
argument_list|()
operator|==
name|rhs
operator|.
name|GetRangeBase
argument_list|()
operator|&&
name|this
operator|->
name|GetByteSize
argument_list|()
operator|==
name|rhs
operator|.
name|GetByteSize
argument_list|()
operator|&&
name|this
operator|->
name|data
operator|==
name|rhs
operator|.
name|data
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|RangeData
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|GetRangeBase
argument_list|()
operator|!=
name|rhs
operator|.
name|GetRangeBase
argument_list|()
operator|||
name|this
operator|->
name|GetByteSize
argument_list|()
operator|!=
name|rhs
operator|.
name|GetByteSize
argument_list|()
operator|||
name|this
operator|->
name|data
operator|!=
name|rhs
operator|.
name|data
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|,
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|RangeDataArray
block|{
name|public
operator|:
typedef|typedef
name|RangeData
operator|<
name|B
operator|,
name|S
operator|,
name|T
operator|>
name|Entry
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Entry
operator|,
name|N
operator|>
name|Collection
expr_stmt|;
end_typedef

begin_expr_stmt
name|RangeDataArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|RangeDataArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Append
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|)
block|{
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Sort
parameter_list|()
block|{
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|std
operator|::
name|stable_sort
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
argument_list|,
name|m_entries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
end_ifdef

begin_expr_stmt
name|bool
name|IsSorted
argument_list|()
specifier|const
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
block|,
name|end
block|,
name|prev
block|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
operator|*
name|pos
operator|<
operator|*
name|prev
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|void
name|CombineConsecutiveEntriesWithEqualData
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|typename
name|Collection
operator|::
name|iterator
name|pos
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|prev
expr_stmt|;
name|bool
name|can_combine
init|=
name|false
decl_stmt|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|data
operator|==
name|pos
operator|->
name|data
condition|)
block|{
name|can_combine
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We we can combine at least one entry, then we make a new collection
comment|// and populate it accordingly, and then swap it into place.
if|if
condition|(
name|can_combine
condition|)
block|{
name|Collection
name|minimal_ranges
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|data
operator|==
name|pos
operator|->
name|data
condition|)
name|minimal_ranges
operator|.
name|back
argument_list|()
operator|.
name|SetRangeEnd
argument_list|(
name|pos
operator|->
name|GetRangeEnd
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|minimal_ranges
operator|.
name|push_back
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// Use the swap technique in case our new vector is much smaller.
comment|// We must swap when using the STL because std::vector objects never
comment|// release or reduce the memory once it has been allocated/reserved.
name|m_entries
operator|.
name|swap
argument_list|(
name|minimal_ranges
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_entries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|GetEntryAtIndex
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Clients must ensure that "i" is a valid index prior to calling this function
end_comment

begin_decl_stmt
specifier|const
name|Entry
modifier|&
name|GetEntryRef
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
name|m_entries
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|BaseLessThan
parameter_list|(
specifier|const
name|Entry
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Entry
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|GetRangeBase
argument_list|()
operator|<
name|rhs
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|uint32_t
name|FindEntryIndexThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|FindEntryThatContains
parameter_list|(
name|B
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|SetRangeBase
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|SetByteSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|SetRangeBase
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|SetByteSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
specifier|const
name|Entry
operator|&
name|range
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|range
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
name|begin
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
block|{
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|Back
parameter_list|()
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Entry
operator|*
name|Back
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|Collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Same as RangeDataArray, but uses std::vector as to not
end_comment

begin_comment
comment|// require static storage of N items in the class itself
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|S
operator|,
name|typename
name|T
operator|>
name|class
name|RangeDataVector
block|{
name|public
operator|:
typedef|typedef
name|RangeData
operator|<
name|B
operator|,
name|S
operator|,
name|T
operator|>
name|Entry
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Entry
operator|>
name|Collection
expr_stmt|;
end_typedef

begin_expr_stmt
name|RangeDataVector
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|RangeDataVector
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Append
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|)
block|{
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Sort
parameter_list|()
block|{
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|std
operator|::
name|stable_sort
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
argument_list|,
name|m_entries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
end_ifdef

begin_expr_stmt
name|bool
name|IsSorted
argument_list|()
specifier|const
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
block|,
name|end
block|,
name|prev
block|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
operator|*
name|pos
operator|<
operator|*
name|prev
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|void
name|CombineConsecutiveEntriesWithEqualData
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|typename
name|Collection
operator|::
name|iterator
name|pos
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|prev
expr_stmt|;
name|bool
name|can_combine
init|=
name|false
decl_stmt|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|data
operator|==
name|pos
operator|->
name|data
condition|)
block|{
name|can_combine
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|// We we can combine at least one entry, then we make a new collection
comment|// and populate it accordingly, and then swap it into place.
if|if
condition|(
name|can_combine
condition|)
block|{
name|Collection
name|minimal_ranges
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
name|prev
operator|->
name|data
operator|==
name|pos
operator|->
name|data
condition|)
name|minimal_ranges
operator|.
name|back
argument_list|()
operator|.
name|SetRangeEnd
argument_list|(
name|pos
operator|->
name|GetRangeEnd
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|minimal_ranges
operator|.
name|push_back
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// Use the swap technique in case our new vector is much smaller.
comment|// We must swap when using the STL because std::vector objects never
comment|// release or reduce the memory once it has been allocated/reserved.
name|m_entries
operator|.
name|swap
argument_list|(
name|minimal_ranges
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|// Calculate the byte size of ranges with zero byte sizes by finding
end_comment

begin_comment
comment|// the next entry with a base address> the current base address
end_comment

begin_function
name|void
name|CalculateSizesOfZeroByteSizeRanges
parameter_list|(
name|S
name|full_size
init|=
literal|0
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|typename
name|Collection
operator|::
name|iterator
name|pos
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|next
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
init|;
name|pos
operator|!=
name|end
condition|;
operator|++
name|pos
control|)
block|{
if|if
condition|(
name|pos
operator|->
name|GetByteSize
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Watch out for multiple entries with same address and make sure
comment|// we find an entry that is greater than the current base address
comment|// before we use that for the size
name|auto
name|curr_base
init|=
name|pos
operator|->
name|GetRangeBase
argument_list|()
decl_stmt|;
for|for
control|(
name|next
operator|=
name|pos
operator|+
literal|1
init|;
name|next
operator|!=
name|end
condition|;
operator|++
name|next
control|)
block|{
name|auto
name|next_base
init|=
name|next
operator|->
name|GetRangeBase
argument_list|()
decl_stmt|;
if|if
condition|(
name|next_base
operator|>
name|curr_base
condition|)
block|{
name|pos
operator|->
name|SetByteSize
argument_list|(
name|next_base
operator|-
name|curr_base
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|next
operator|==
name|end
operator|&&
name|full_size
operator|>
name|curr_base
condition|)
name|pos
operator|->
name|SetByteSize
argument_list|(
name|full_size
operator|-
name|curr_base
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|Clear
parameter_list|()
block|{
name|m_entries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|Reserve
argument_list|(
name|typename
name|Collection
operator|::
name|size_type
name|size
argument_list|)
block|{
name|m_entries
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|GetEntryAtIndex
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|GetMutableEntryAtIndex
parameter_list|(
name|size_t
name|i
parameter_list|)
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_function

begin_comment
comment|// Clients must ensure that "i" is a valid index prior to calling this function
end_comment

begin_decl_stmt
specifier|const
name|Entry
modifier|&
name|GetEntryRef
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
name|m_entries
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|BaseLessThan
parameter_list|(
specifier|const
name|Entry
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Entry
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|GetRangeBase
argument_list|()
operator|<
name|rhs
operator|.
name|GetRangeBase
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|uint32_t
name|FindEntryIndexThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
name|begin
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|.
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|std
operator|::
name|distance
argument_list|(
name|begin
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|UINT32_MAX
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|FindEntryIndexesThatContain
argument_list|(
name|B
name|addr
argument_list|,
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
operator|&
name|indexes
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|entry
range|:
name|m_entries
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
name|indexes
operator|.
name|push_back
argument_list|(
name|entry
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|indexes
operator|.
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|FindEntryThatContains
parameter_list|(
name|B
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|SetRangeBase
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|SetByteSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
name|begin
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|.
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
return|return
name|nullptr
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|SetRangeBase
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|entry
operator|.
name|SetByteSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
name|begin
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|.
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContains
argument_list|(
specifier|const
name|Entry
operator|&
name|range
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|range
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
name|begin
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|.
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|Contains
argument_list|(
name|range
argument_list|)
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryStartsAt
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|auto
name|begin
init|=
name|m_entries
operator|.
name|begin
argument_list|()
decl_stmt|,
name|end
init|=
name|m_entries
operator|.
name|end
argument_list|()
decl_stmt|;
name|auto
name|pos
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|Entry
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BaseLessThan
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
operator|&&
name|pos
operator|->
name|base
operator|==
name|addr
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|FindEntryThatContainsOrFollows
argument_list|(
name|B
name|addr
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
argument|m_entries.begin()
argument_list|,
argument|end
argument_list|,
argument|addr
argument_list|,
argument|[](const Entry&lhs, B rhs_base) -> bool {                         return lhs.GetRangeEnd()<= rhs_base;                     }
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_function
name|Entry
modifier|*
name|Back
parameter_list|()
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Entry
operator|*
name|Back
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|Collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// A simple range  with data class where you get to define the type of
end_comment

begin_comment
comment|// the range base "B", the type used for the range byte size "S", and
end_comment

begin_comment
comment|// the type for the associated data "T".
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|T
operator|>
expr|struct
name|AddressData
block|{
typedef|typedef
name|B
name|BaseType
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|T
name|DataType
typedef|;
end_typedef

begin_decl_stmt
name|BaseType
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DataType
name|data
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AddressData
argument_list|()
operator|:
name|addr
argument_list|()
operator|,
name|data
argument_list|()
block|{         }
name|AddressData
argument_list|(
argument|B a
argument_list|,
argument|DataType d
argument_list|)
operator|:
name|addr
argument_list|(
name|a
argument_list|)
operator|,
name|data
argument_list|(
argument|d
argument_list|)
block|{         }
name|bool
name|operator
operator|<
operator|(
specifier|const
name|AddressData
operator|&
name|rhs
operator|)
specifier|const
block|{
if|if
condition|(
name|this
operator|->
name|addr
operator|==
name|rhs
operator|.
name|addr
condition|)
return|return
name|this
operator|->
name|data
operator|<
name|rhs
operator|.
name|data
return|;
end_expr_stmt

begin_return
return|return
name|this
operator|->
name|addr
operator|<
name|rhs
operator|.
name|addr
return|;
end_return

begin_expr_stmt
unit|}                  bool
name|operator
operator|==
operator|(
specifier|const
name|AddressData
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|addr
operator|==
name|rhs
operator|.
name|addr
operator|&&
name|this
operator|->
name|data
operator|==
name|rhs
operator|.
name|data
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|AddressData
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|addr
operator|!=
name|rhs
operator|.
name|addr
operator|||
name|this
operator|->
name|data
operator|==
name|rhs
operator|.
name|data
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|B
operator|,
name|typename
name|T
operator|,
name|unsigned
name|N
operator|>
name|class
name|AddressDataArray
block|{
name|public
operator|:
typedef|typedef
name|AddressData
operator|<
name|B
operator|,
name|T
operator|>
name|Entry
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Entry
operator|,
name|N
operator|>
name|Collection
expr_stmt|;
end_typedef

begin_expr_stmt
name|AddressDataArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|AddressDataArray
argument_list|()
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Append
parameter_list|(
specifier|const
name|Entry
modifier|&
name|entry
parameter_list|)
block|{
name|m_entries
operator|.
name|push_back
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Sort
parameter_list|()
block|{
if|if
condition|(
name|m_entries
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|std
operator|::
name|stable_sort
argument_list|(
name|m_entries
operator|.
name|begin
argument_list|()
argument_list|,
name|m_entries
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
end_ifdef

begin_expr_stmt
name|bool
name|IsSorted
argument_list|()
specifier|const
block|{
name|typename
name|Collection
operator|::
name|const_iterator
name|pos
block|,
name|end
block|,
name|prev
block|;
comment|// First we determine if we can combine any of the Entry objects so we
comment|// don't end up allocating and making a new collection for no reason
for|for
control|(
name|pos
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
operator|,
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
operator|,
name|prev
operator|=
name|end
init|;
name|pos
operator|!=
name|end
condition|;
name|prev
operator|=
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|end
operator|&&
operator|*
name|pos
operator|<
operator|*
name|prev
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_macro
unit|void
name|Clear
argument_list|()
end_macro

begin_block
block|{
name|m_entries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bool
name|IsEmpty
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|m_entries
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Entry
modifier|*
name|GetEntryAtIndex
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|i
operator|<
name|m_entries
operator|.
name|size
argument_list|()
operator|)
condition|?
operator|&
name|m_entries
index|[
name|i
index|]
else|:
name|nullptr
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Clients must ensure that "i" is a valid index prior to calling this function
end_comment

begin_decl_stmt
specifier|const
name|Entry
modifier|&
name|GetEntryRef
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
return|return
name|m_entries
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|BaseLessThan
parameter_list|(
specifier|const
name|Entry
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Entry
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|addr
operator|<
name|rhs
operator|.
name|addr
return|;
block|}
end_function

begin_function
name|Entry
modifier|*
name|FindEntry
parameter_list|(
name|B
name|addr
parameter_list|,
name|bool
name|exact_match_only
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASSERT_RANGEMAP_ARE_SORTED
name|assert
argument_list|(
name|IsSorted
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_entries
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Entry
name|entry
decl_stmt|;
name|entry
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|begin
operator|=
name|m_entries
operator|.
name|begin
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|end
operator|=
name|m_entries
operator|.
name|end
argument_list|()
expr_stmt|;
name|typename
name|Collection
operator|::
name|iterator
name|pos
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|entry
argument_list|,
name|BaseLessThan
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
name|begin
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|.
name|addr
operator|==
name|addr
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|pos
operator|->
name|addr
operator|==
name|addr
operator|||
operator|!
name|exact_match_only
condition|)
return|return
operator|&
operator|(
operator|*
name|pos
operator|)
return|;
block|}
block|}
return|return
name|nullptr
return|;
block|}
end_function

begin_function
specifier|const
name|Entry
modifier|*
name|FindNextEntry
parameter_list|(
specifier|const
name|Entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|>=
operator|&
operator|*
name|m_entries
operator|.
name|begin
argument_list|()
operator|&&
name|entry
operator|+
literal|1
operator|<
operator|&
operator|*
name|m_entries
operator|.
name|end
argument_list|()
condition|)
return|return
name|entry
operator|+
literal|1
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_function
name|Entry
modifier|*
name|Back
parameter_list|()
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
condition|?
name|nullptr
else|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Entry
operator|*
name|Back
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_entries
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
operator|&
name|m_entries
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|Collection
name|m_entries
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_RangeMap_h_
end_comment

end_unit

