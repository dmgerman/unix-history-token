begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- RegisterValue.h ------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lldb_RegisterValue_h
end_ifndef

begin_define
define|#
directive|define
name|lldb_RegisterValue_h
end_define

begin_comment
comment|// C Includes
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|// C++ Includes
end_comment

begin_comment
comment|// Other libraries and framework includes
end_comment

begin_comment
comment|// Project includes
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-public.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-private.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Host/Endian.h"
end_include

begin_comment
comment|//#define ENABLE_128_BIT_SUPPORT 1
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|RegisterValue
block|{
name|public
label|:
enum|enum
block|{
name|kMaxRegisterByteSize
init|=
literal|32u
block|}
enum|;
enum|enum
name|Type
block|{
name|eTypeInvalid
block|,
name|eTypeUInt8
block|,
name|eTypeUInt16
block|,
name|eTypeUInt32
block|,
name|eTypeUInt64
block|,
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|eTypeUInt128
block|,
endif|#
directive|endif
name|eTypeFloat
block|,
name|eTypeDouble
block|,
name|eTypeLongDouble
block|,
name|eTypeBytes
block|}
enum|;
name|RegisterValue
argument_list|()
operator|:
name|m_type
argument_list|(
argument|eTypeInvalid
argument_list|)
block|{         }
name|explicit
name|RegisterValue
argument_list|(
argument|uint8_t inst
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeUInt8
argument_list|)
block|{
name|m_data
operator|.
name|uint8
operator|=
name|inst
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|uint16_t inst
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeUInt16
argument_list|)
block|{
name|m_data
operator|.
name|uint16
operator|=
name|inst
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|uint32_t inst
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeUInt32
argument_list|)
block|{
name|m_data
operator|.
name|uint32
operator|=
name|inst
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|uint64_t inst
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeUInt64
argument_list|)
block|{
name|m_data
operator|.
name|uint64
operator|=
name|inst
block|;         }
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|explicit
name|RegisterValue
argument_list|(
argument|__uint128_t inst
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeUInt128
argument_list|)
block|{
name|m_data
operator|.
name|uint128
operator|=
name|inst
block|;         }
endif|#
directive|endif
name|explicit
name|RegisterValue
argument_list|(
argument|float value
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeFloat
argument_list|)
block|{
name|m_data
operator|.
name|ieee_float
operator|=
name|value
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|double value
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeDouble
argument_list|)
block|{
name|m_data
operator|.
name|ieee_double
operator|=
name|value
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|long double value
argument_list|)
operator|:
name|m_type
argument_list|(
argument|eTypeLongDouble
argument_list|)
block|{
name|m_data
operator|.
name|ieee_long_double
operator|=
name|value
block|;         }
name|explicit
name|RegisterValue
argument_list|(
argument|uint8_t *bytes
argument_list|,
argument|size_t length
argument_list|,
argument|lldb::ByteOrder byte_order
argument_list|)
block|{
name|SetBytes
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|,
name|byte_order
argument_list|)
block|;         }
name|RegisterValue
operator|::
name|Type
name|GetType
argument_list|()
specifier|const
block|{
return|return
name|m_type
return|;
block|}
name|bool
name|CopyValue
parameter_list|(
specifier|const
name|RegisterValue
modifier|&
name|rhs
parameter_list|)
function_decl|;
name|void
name|SetType
argument_list|(
name|RegisterValue
operator|::
name|Type
name|type
argument_list|)
block|{
name|m_type
operator|=
name|type
expr_stmt|;
block|}
name|RegisterValue
operator|::
name|Type
name|SetType
argument_list|(
specifier|const
name|RegisterInfo
operator|*
name|reg_info
argument_list|)
expr_stmt|;
name|bool
name|GetData
argument_list|(
name|DataExtractor
operator|&
name|data
argument_list|)
decl|const
decl_stmt|;
comment|// Copy the register value from this object into a buffer in "dst"
comment|// and obey the "dst_byte_order" when copying the data. Also watch out
comment|// in case "dst_len" is longer or shorter than the register value
comment|// described by "reg_info" and only copy the least significant bytes
comment|// of the register value, or pad the destination with zeroes if the
comment|// register byte size is shorter that "dst_len" (all while correctly
comment|// abiding the "dst_byte_order"). Returns the number of bytes copied
comment|// into "dst".
name|uint32_t
name|GetAsMemoryData
argument_list|(
specifier|const
name|RegisterInfo
operator|*
name|reg_info
argument_list|,
name|void
operator|*
name|dst
argument_list|,
name|uint32_t
name|dst_len
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|dst_byte_order
argument_list|,
name|Error
operator|&
name|error
argument_list|)
decl|const
decl_stmt|;
name|uint32_t
name|SetFromMemoryData
argument_list|(
specifier|const
name|RegisterInfo
operator|*
name|reg_info
argument_list|,
specifier|const
name|void
operator|*
name|src
argument_list|,
name|uint32_t
name|src_len
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|src_byte_order
argument_list|,
name|Error
operator|&
name|error
argument_list|)
decl_stmt|;
name|bool
name|GetScalarValue
argument_list|(
name|Scalar
operator|&
name|scalar
argument_list|)
decl|const
decl_stmt|;
name|uint8_t
name|GetAsUInt8
argument_list|(
name|uint8_t
name|fail_value
operator|=
name|UINT8_MAX
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
block|{
if|if
condition|(
name|m_type
operator|==
name|eTypeUInt8
condition|)
block|{
if|if
condition|(
name|success_ptr
condition|)
operator|*
name|success_ptr
operator|=
name|true
expr_stmt|;
return|return
name|m_data
operator|.
name|uint8
return|;
block|}
if|if
condition|(
name|success_ptr
condition|)
operator|*
name|success_ptr
operator|=
name|true
expr_stmt|;
return|return
name|fail_value
return|;
block|}
name|uint16_t
name|GetAsUInt16
argument_list|(
name|uint16_t
name|fail_value
operator|=
name|UINT16_MAX
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
name|uint32_t
name|GetAsUInt32
argument_list|(
name|uint32_t
name|fail_value
operator|=
name|UINT32_MAX
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
name|uint64_t
name|GetAsUInt64
argument_list|(
name|uint64_t
name|fail_value
operator|=
name|UINT64_MAX
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|__uint128_t
name|GetAsUInt128
argument_list|(
name|__uint128_t
name|fail_value
operator|=
operator|~
operator|(
operator|(
name|__uint128_t
operator|)
literal|0
operator|)
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
endif|#
directive|endif
name|float
name|GetAsFloat
argument_list|(
name|float
name|fail_value
operator|=
literal|0.0f
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
name|double
name|GetAsDouble
argument_list|(
name|double
name|fail_value
operator|=
literal|0.0
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
name|long
name|double
name|GetAsLongDouble
argument_list|(
name|long
name|double
name|fail_value
operator|=
literal|0.0
argument_list|,
name|bool
operator|*
name|success_ptr
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
name|void
name|SetValueToInvalid
parameter_list|()
block|{
name|m_type
operator|=
name|eTypeInvalid
expr_stmt|;
block|}
name|bool
name|ClearBit
parameter_list|(
name|uint32_t
name|bit
parameter_list|)
function_decl|;
name|bool
name|SetBit
parameter_list|(
name|uint32_t
name|bit
parameter_list|)
function_decl|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|RegisterValue
operator|&
name|rhs
operator|)
specifier|const
expr_stmt|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|RegisterValue
operator|&
name|rhs
operator|)
specifier|const
expr_stmt|;
name|void
name|operator
init|=
operator|(
name|uint8_t
name|uint
operator|)
block|{
name|m_type
operator|=
name|eTypeUInt8
block|;
name|m_data
operator|.
name|uint8
operator|=
name|uint
block|;         }
name|void
name|operator
operator|=
operator|(
name|uint16_t
name|uint
operator|)
block|{
name|m_type
operator|=
name|eTypeUInt16
block|;
name|m_data
operator|.
name|uint16
operator|=
name|uint
block|;         }
name|void
name|operator
operator|=
operator|(
name|uint32_t
name|uint
operator|)
block|{
name|m_type
operator|=
name|eTypeUInt32
block|;
name|m_data
operator|.
name|uint32
operator|=
name|uint
block|;         }
name|void
name|operator
operator|=
operator|(
name|uint64_t
name|uint
operator|)
block|{
name|m_type
operator|=
name|eTypeUInt64
block|;
name|m_data
operator|.
name|uint64
operator|=
name|uint
block|;         }
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|void
name|operator
operator|=
operator|(
name|__uint128_t
name|uint
operator|)
block|{
name|m_type
operator|=
name|eTypeUInt128
block|;
name|m_data
operator|.
name|uint128
operator|=
name|uint
block|;         }
endif|#
directive|endif
name|void
name|operator
operator|=
operator|(
name|float
name|f
operator|)
block|{
name|m_type
operator|=
name|eTypeFloat
block|;
name|m_data
operator|.
name|ieee_float
operator|=
name|f
block|;         }
name|void
name|operator
operator|=
operator|(
name|double
name|f
operator|)
block|{
name|m_type
operator|=
name|eTypeDouble
block|;
name|m_data
operator|.
name|ieee_double
operator|=
name|f
block|;         }
name|void
name|operator
operator|=
operator|(
name|long
name|double
name|f
operator|)
block|{
name|m_type
operator|=
name|eTypeLongDouble
block|;
name|m_data
operator|.
name|ieee_long_double
operator|=
name|f
block|;         }
name|void
name|SetUInt8
argument_list|(
argument|uint8_t uint
argument_list|)
block|{
name|m_type
operator|=
name|eTypeUInt8
block|;
name|m_data
operator|.
name|uint8
operator|=
name|uint
block|;         }
name|void
name|SetUInt16
argument_list|(
argument|uint16_t uint
argument_list|)
block|{
name|m_type
operator|=
name|eTypeUInt16
block|;
name|m_data
operator|.
name|uint16
operator|=
name|uint
block|;         }
name|void
name|SetUInt32
argument_list|(
argument|uint32_t uint
argument_list|,
argument|Type t = eTypeUInt32
argument_list|)
block|{
name|m_type
operator|=
name|t
block|;
name|m_data
operator|.
name|uint32
operator|=
name|uint
block|;         }
name|void
name|SetUInt64
argument_list|(
argument|uint64_t uint
argument_list|,
argument|Type t = eTypeUInt64
argument_list|)
block|{
name|m_type
operator|=
name|t
block|;
name|m_data
operator|.
name|uint64
operator|=
name|uint
block|;         }
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|void
name|SetUInt128
argument_list|(
argument|__uint128_t uint
argument_list|)
block|{
name|m_type
operator|=
name|eTypeUInt128
block|;
name|m_data
operator|.
name|uint128
operator|=
name|uint
block|;         }
endif|#
directive|endif
name|bool
name|SetUInt
argument_list|(
argument|uint64_t uint
argument_list|,
argument|uint32_t byte_size
argument_list|)
decl_stmt|;
name|void
name|SetFloat
parameter_list|(
name|float
name|f
parameter_list|)
block|{
name|m_type
operator|=
name|eTypeFloat
expr_stmt|;
name|m_data
operator|.
name|ieee_float
operator|=
name|f
expr_stmt|;
block|}
name|void
name|SetDouble
parameter_list|(
name|double
name|f
parameter_list|)
block|{
name|m_type
operator|=
name|eTypeDouble
expr_stmt|;
name|m_data
operator|.
name|ieee_double
operator|=
name|f
expr_stmt|;
block|}
name|void
name|SetLongDouble
parameter_list|(
name|long
name|double
name|f
parameter_list|)
block|{
name|m_type
operator|=
name|eTypeLongDouble
expr_stmt|;
name|m_data
operator|.
name|ieee_long_double
operator|=
name|f
expr_stmt|;
block|}
name|void
name|SetBytes
argument_list|(
specifier|const
name|void
operator|*
name|bytes
argument_list|,
name|size_t
name|length
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|byte_order
argument_list|)
decl_stmt|;
name|bool
name|SignExtend
parameter_list|(
name|uint32_t
name|sign_bitpos
parameter_list|)
function_decl|;
name|Error
name|SetValueFromCString
parameter_list|(
specifier|const
name|RegisterInfo
modifier|*
name|reg_info
parameter_list|,
specifier|const
name|char
modifier|*
name|value_str
parameter_list|)
function_decl|;
name|Error
name|SetValueFromData
argument_list|(
specifier|const
name|RegisterInfo
operator|*
name|reg_info
argument_list|,
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|offset_t
name|offset
argument_list|,
name|bool
name|partial_data_ok
argument_list|)
decl_stmt|;
comment|// The default value of 0 for reg_name_right_align_at means no alignment at all.
name|bool
name|Dump
argument_list|(
name|Stream
operator|*
name|s
argument_list|,
specifier|const
name|RegisterInfo
operator|*
name|reg_info
argument_list|,
name|bool
name|prefix_with_name
argument_list|,
name|bool
name|prefix_with_alt_name
argument_list|,
name|lldb
operator|::
name|Format
name|format
argument_list|,
name|uint32_t
name|reg_name_right_align_at
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|void
modifier|*
name|GetBytes
parameter_list|()
function_decl|;
specifier|const
name|void
operator|*
name|GetBytes
argument_list|()
specifier|const
expr_stmt|;
name|lldb
operator|::
name|ByteOrder
name|GetByteOrder
argument_list|()
specifier|const
block|{
if|if
condition|(
name|m_type
operator|==
name|eTypeBytes
condition|)
return|return
name|m_data
operator|.
name|buffer
operator|.
name|byte_order
return|;
return|return
name|lldb
operator|::
name|endian
operator|::
name|InlHostByteOrder
argument_list|()
return|;
block|}
name|uint32_t
name|GetByteSize
argument_list|()
specifier|const
expr_stmt|;
specifier|static
name|uint32_t
name|GetMaxByteSize
parameter_list|()
block|{
return|return
name|kMaxRegisterByteSize
return|;
block|}
name|void
name|Clear
parameter_list|()
function_decl|;
name|protected
label|:
name|RegisterValue
operator|::
name|Type
name|m_type
expr_stmt|;
union|union
block|{
name|uint8_t
name|uint8
decl_stmt|;
name|uint16_t
name|uint16
decl_stmt|;
name|uint32_t
name|uint32
decl_stmt|;
name|uint64_t
name|uint64
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_128_BIT_SUPPORT
argument_list|)
name|__uint128_t
name|uint128
decl_stmt|;
endif|#
directive|endif
name|float
name|ieee_float
decl_stmt|;
name|double
name|ieee_double
decl_stmt|;
name|long
name|double
name|ieee_long_double
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|bytes
index|[
name|kMaxRegisterByteSize
index|]
decl_stmt|;
comment|// This must be big enough to hold any register for any supported target.
name|uint8_t
name|length
decl_stmt|;
name|lldb
operator|::
name|ByteOrder
name|byte_order
expr_stmt|;
block|}
name|buffer
struct|;
block|}
name|m_data
union|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// lldb_RegisterValue_h
end_comment

end_unit

