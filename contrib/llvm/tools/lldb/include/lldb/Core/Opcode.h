begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Opcode.h ------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lldb_Opcode_h
end_ifndef

begin_define
define|#
directive|define
name|lldb_Opcode_h
end_define

begin_include
include|#
directive|include
file|"lldb/Utility/Endian.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-enumerations.h"
end_include

begin_comment
comment|// for ByteOrder, ByteOrder::eByteOrde...
end_comment

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|// for assert
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint32_t, uint8_t, uint16_t
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|DataExtractor
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Stream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb
block|{
name|class
name|SBInstruction
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Opcode
block|{
name|public
label|:
enum|enum
name|Type
block|{
name|eTypeInvalid
block|,
name|eType8
block|,
name|eType16
block|,
name|eType16_2
block|,
comment|// a 32-bit Thumb instruction, made up of two words
name|eType32
block|,
name|eType64
block|,
name|eTypeBytes
block|}
enum|;
name|Opcode
argument_list|()
operator|:
name|m_byte_order
argument_list|(
name|lldb
operator|::
name|eByteOrderInvalid
argument_list|)
operator|,
name|m_type
argument_list|(
argument|eTypeInvalid
argument_list|)
block|{}
name|Opcode
argument_list|(
argument|uint8_t inst
argument_list|,
argument|lldb::ByteOrder order
argument_list|)
operator|:
name|m_byte_order
argument_list|(
name|order
argument_list|)
operator|,
name|m_type
argument_list|(
argument|eType8
argument_list|)
block|{
name|m_data
operator|.
name|inst8
operator|=
name|inst
block|;   }
name|Opcode
argument_list|(
argument|uint16_t inst
argument_list|,
argument|lldb::ByteOrder order
argument_list|)
operator|:
name|m_byte_order
argument_list|(
name|order
argument_list|)
operator|,
name|m_type
argument_list|(
argument|eType16
argument_list|)
block|{
name|m_data
operator|.
name|inst16
operator|=
name|inst
block|;   }
name|Opcode
argument_list|(
argument|uint32_t inst
argument_list|,
argument|lldb::ByteOrder order
argument_list|)
operator|:
name|m_byte_order
argument_list|(
name|order
argument_list|)
operator|,
name|m_type
argument_list|(
argument|eType32
argument_list|)
block|{
name|m_data
operator|.
name|inst32
operator|=
name|inst
block|;   }
name|Opcode
argument_list|(
argument|uint64_t inst
argument_list|,
argument|lldb::ByteOrder order
argument_list|)
operator|:
name|m_byte_order
argument_list|(
name|order
argument_list|)
operator|,
name|m_type
argument_list|(
argument|eType64
argument_list|)
block|{
name|m_data
operator|.
name|inst64
operator|=
name|inst
block|;   }
name|Opcode
argument_list|(
argument|uint8_t *bytes
argument_list|,
argument|size_t length
argument_list|)
operator|:
name|m_byte_order
argument_list|(
argument|lldb::eByteOrderInvalid
argument_list|)
block|{
name|SetOpcodeBytes
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|)
block|;   }
name|void
name|Clear
argument_list|()
block|{
name|m_byte_order
operator|=
name|lldb
operator|::
name|eByteOrderInvalid
block|;
name|m_type
operator|=
name|Opcode
operator|::
name|eTypeInvalid
block|;   }
name|Opcode
operator|::
name|Type
name|GetType
argument_list|()
specifier|const
block|{
return|return
name|m_type
return|;
block|}
name|uint8_t
name|GetOpcode8
argument_list|(
name|uint8_t
name|invalid_opcode
operator|=
name|UINT8_MAX
argument_list|)
decl|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
name|m_data
operator|.
name|inst8
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType32
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType64
case|:
break|break;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
break|break;
block|}
return|return
name|invalid_opcode
return|;
block|}
name|uint16_t
name|GetOpcode16
argument_list|(
name|uint16_t
name|invalid_opcode
operator|=
name|UINT16_MAX
argument_list|)
decl|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
name|m_data
operator|.
name|inst8
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_16
argument_list|(
name|m_data
operator|.
name|inst16
argument_list|)
else|:
name|m_data
operator|.
name|inst16
return|;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType32
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType64
case|:
break|break;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
break|break;
block|}
return|return
name|invalid_opcode
return|;
block|}
name|uint32_t
name|GetOpcode32
argument_list|(
name|uint32_t
name|invalid_opcode
operator|=
name|UINT32_MAX
argument_list|)
decl|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
name|m_data
operator|.
name|inst8
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_16
argument_list|(
name|m_data
operator|.
name|inst16
argument_list|)
else|:
name|m_data
operator|.
name|inst16
return|;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
comment|// passthrough
case|case
name|Opcode
operator|::
name|eType32
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_32
argument_list|(
name|m_data
operator|.
name|inst32
argument_list|)
else|:
name|m_data
operator|.
name|inst32
return|;
case|case
name|Opcode
operator|::
name|eType64
case|:
break|break;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
break|break;
block|}
return|return
name|invalid_opcode
return|;
block|}
name|uint64_t
name|GetOpcode64
argument_list|(
name|uint64_t
name|invalid_opcode
operator|=
name|UINT64_MAX
argument_list|)
decl|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
name|m_data
operator|.
name|inst8
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_16
argument_list|(
name|m_data
operator|.
name|inst16
argument_list|)
else|:
name|m_data
operator|.
name|inst16
return|;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
comment|// passthrough
case|case
name|Opcode
operator|::
name|eType32
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_32
argument_list|(
name|m_data
operator|.
name|inst32
argument_list|)
else|:
name|m_data
operator|.
name|inst32
return|;
case|case
name|Opcode
operator|::
name|eType64
case|:
return|return
name|GetEndianSwap
argument_list|()
condition|?
name|llvm
operator|::
name|ByteSwap_64
argument_list|(
name|m_data
operator|.
name|inst64
argument_list|)
else|:
name|m_data
operator|.
name|inst64
return|;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
break|break;
block|}
return|return
name|invalid_opcode
return|;
block|}
name|void
name|SetOpcode8
argument_list|(
name|uint8_t
name|inst
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|order
argument_list|)
block|{
name|m_type
operator|=
name|eType8
expr_stmt|;
name|m_data
operator|.
name|inst8
operator|=
name|inst
expr_stmt|;
name|m_byte_order
operator|=
name|order
expr_stmt|;
block|}
name|void
name|SetOpcode16
argument_list|(
name|uint16_t
name|inst
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|order
argument_list|)
block|{
name|m_type
operator|=
name|eType16
expr_stmt|;
name|m_data
operator|.
name|inst16
operator|=
name|inst
expr_stmt|;
name|m_byte_order
operator|=
name|order
expr_stmt|;
block|}
name|void
name|SetOpcode16_2
argument_list|(
name|uint32_t
name|inst
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|order
argument_list|)
block|{
name|m_type
operator|=
name|eType16_2
expr_stmt|;
name|m_data
operator|.
name|inst32
operator|=
name|inst
expr_stmt|;
name|m_byte_order
operator|=
name|order
expr_stmt|;
block|}
name|void
name|SetOpcode32
argument_list|(
name|uint32_t
name|inst
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|order
argument_list|)
block|{
name|m_type
operator|=
name|eType32
expr_stmt|;
name|m_data
operator|.
name|inst32
operator|=
name|inst
expr_stmt|;
name|m_byte_order
operator|=
name|order
expr_stmt|;
block|}
name|void
name|SetOpcode64
argument_list|(
name|uint64_t
name|inst
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|order
argument_list|)
block|{
name|m_type
operator|=
name|eType64
expr_stmt|;
name|m_data
operator|.
name|inst64
operator|=
name|inst
expr_stmt|;
name|m_byte_order
operator|=
name|order
expr_stmt|;
block|}
name|void
name|SetOpcodeBytes
parameter_list|(
specifier|const
name|void
modifier|*
name|bytes
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|!=
name|nullptr
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|m_type
operator|=
name|eTypeBytes
expr_stmt|;
name|m_data
operator|.
name|inst
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|assert
argument_list|(
name|length
operator|<
sizeof|sizeof
argument_list|(
name|m_data
operator|.
name|inst
operator|.
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|m_data
operator|.
name|inst
operator|.
name|bytes
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|m_byte_order
operator|=
name|lldb
operator|::
name|eByteOrderInvalid
expr_stmt|;
block|}
else|else
block|{
name|m_type
operator|=
name|eTypeInvalid
expr_stmt|;
name|m_data
operator|.
name|inst
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|int
name|Dump
parameter_list|(
name|Stream
modifier|*
name|s
parameter_list|,
name|uint32_t
name|min_byte_width
parameter_list|)
function_decl|;
specifier|const
name|void
operator|*
name|GetOpcodeBytes
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|(
name|m_type
operator|==
name|Opcode
operator|::
name|eTypeBytes
operator|)
operator|?
name|m_data
operator|.
name|inst
operator|.
name|bytes
operator|:
name|nullptr
operator|)
return|;
block|}
name|uint32_t
name|GetByteSize
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
sizeof|sizeof
argument_list|(
name|m_data
operator|.
name|inst8
argument_list|)
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
return|return
sizeof|sizeof
argument_list|(
name|m_data
operator|.
name|inst16
argument_list|)
return|;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
comment|// passthrough
case|case
name|Opcode
operator|::
name|eType32
case|:
return|return
sizeof|sizeof
argument_list|(
name|m_data
operator|.
name|inst32
argument_list|)
return|;
case|case
name|Opcode
operator|::
name|eType64
case|:
return|return
sizeof|sizeof
argument_list|(
name|m_data
operator|.
name|inst64
argument_list|)
return|;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
return|return
name|m_data
operator|.
name|inst
operator|.
name|length
return|;
block|}
return|return
literal|0
return|;
block|}
comment|// Get the opcode exactly as it would be laid out in memory.
name|uint32_t
name|GetData
argument_list|(
argument|DataExtractor&data
argument_list|)
specifier|const
expr_stmt|;
name|protected
label|:
name|friend
name|class
name|lldb
operator|::
name|SBInstruction
expr_stmt|;
specifier|const
name|void
operator|*
name|GetOpcodeDataBytes
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|m_type
condition|)
block|{
case|case
name|Opcode
operator|::
name|eTypeInvalid
case|:
break|break;
case|case
name|Opcode
operator|::
name|eType8
case|:
return|return
operator|&
name|m_data
operator|.
name|inst8
return|;
case|case
name|Opcode
operator|::
name|eType16
case|:
return|return
operator|&
name|m_data
operator|.
name|inst16
return|;
case|case
name|Opcode
operator|::
name|eType16_2
case|:
comment|// passthrough
case|case
name|Opcode
operator|::
name|eType32
case|:
return|return
operator|&
name|m_data
operator|.
name|inst32
return|;
case|case
name|Opcode
operator|::
name|eType64
case|:
return|return
operator|&
name|m_data
operator|.
name|inst64
return|;
case|case
name|Opcode
operator|::
name|eTypeBytes
case|:
return|return
name|m_data
operator|.
name|inst
operator|.
name|bytes
return|;
block|}
return|return
name|nullptr
return|;
block|}
name|lldb
operator|::
name|ByteOrder
name|GetDataByteOrder
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|GetEndianSwap
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_byte_order
operator|==
name|lldb
operator|::
name|eByteOrderBig
operator|&&
name|endian
operator|::
name|InlHostByteOrder
argument_list|()
operator|==
name|lldb
operator|::
name|eByteOrderLittle
operator|)
operator|||
operator|(
name|m_byte_order
operator|==
name|lldb
operator|::
name|eByteOrderLittle
operator|&&
name|endian
operator|::
name|InlHostByteOrder
argument_list|()
operator|==
name|lldb
operator|::
name|eByteOrderBig
operator|)
return|;
block|}
name|lldb
operator|::
name|ByteOrder
name|m_byte_order
expr_stmt|;
name|Opcode
operator|::
name|Type
name|m_type
expr_stmt|;
union|union
block|{
name|uint8_t
name|inst8
decl_stmt|;
name|uint16_t
name|inst16
decl_stmt|;
name|uint32_t
name|inst32
decl_stmt|;
name|uint64_t
name|inst64
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|bytes
index|[
literal|16
index|]
decl_stmt|;
comment|// This must be big enough to handle any opcode for any
comment|// supported target.
name|uint8_t
name|length
decl_stmt|;
block|}
name|inst
struct|;
block|}
name|m_data
union|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// lldb_Opcode_h
end_comment

end_unit

