begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Value.h -------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_Value_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_Value_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Core/Scalar.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Symbol/CompilerType.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/DataBufferHeap.h"
end_include

begin_include
include|#
directive|include
file|"lldb/Utility/Status.h"
end_include

begin_include
include|#
directive|include
file|"lldb/lldb-enumerations.h"
end_include

begin_comment
comment|// for ByteOrder, ByteOrder::eB...
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private-enumerations.h"
end_include

begin_comment
comment|// for AddressType
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private-types.h"
end_include

begin_comment
comment|// for type128, RegisterInfo
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_comment
comment|// for APInt
end_comment

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint8_t, uint32_t, uint64_t
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|// for size_t, memcpy
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|DataExtractor
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|ExecutionContext
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Module
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Stream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Type
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Variable
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Value
block|{
name|public
label|:
comment|// Values Less than zero are an error, greater than or equal to zero
comment|// returns what the Scalar result is.
enum|enum
name|ValueType
block|{
comment|// m_value contains...
comment|// ============================
name|eValueTypeScalar
block|,
comment|// raw scalar value
name|eValueTypeVector
block|,
comment|// byte array of m_vector.length with endianness of
comment|// m_vector.byte_order
name|eValueTypeFileAddress
block|,
comment|// file address value
name|eValueTypeLoadAddress
block|,
comment|// load address value
name|eValueTypeHostAddress
comment|// host address value (for memory in the process that
comment|// is using liblldb)
block|}
enum|;
enum|enum
name|ContextType
comment|// Type that describes Value::m_context
block|{
comment|// m_context contains...
comment|// ====================
name|eContextTypeInvalid
block|,
comment|// undefined
name|eContextTypeRegisterInfo
block|,
comment|// RegisterInfo * (can be a scalar or a vector
comment|// register)
name|eContextTypeLLDBType
block|,
comment|// lldb_private::Type *
name|eContextTypeVariable
comment|// lldb_private::Variable *
block|}
enum|;
specifier|const
specifier|static
name|size_t
name|kMaxByteSize
init|=
literal|32u
decl_stmt|;
struct|struct
name|Vector
block|{
comment|// The byte array must be big enough to hold vector registers for any
comment|// supported target.
name|uint8_t
name|bytes
index|[
name|kMaxByteSize
index|]
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|lldb
operator|::
name|ByteOrder
name|byte_order
expr_stmt|;
name|Vector
argument_list|()
operator|:
name|length
argument_list|(
literal|0
argument_list|)
operator|,
name|byte_order
argument_list|(
argument|lldb::eByteOrderInvalid
argument_list|)
block|{}
name|Vector
argument_list|(
argument|const Vector&vector
argument_list|)
block|{
operator|*
name|this
operator|=
name|vector
block|; }
specifier|const
name|Vector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|Vector
operator|&
name|vector
operator|)
block|{
name|SetBytes
argument_list|(
name|vector
operator|.
name|bytes
argument_list|,
name|vector
operator|.
name|length
argument_list|,
name|vector
operator|.
name|byte_order
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|void
name|Clear
parameter_list|()
block|{
name|length
operator|=
literal|0
expr_stmt|;
block|}
name|bool
name|SetBytes
argument_list|(
specifier|const
name|void
operator|*
name|bytes
argument_list|,
name|size_t
name|length
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|byte_order
argument_list|)
block|{
name|this
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|this
operator|->
name|byte_order
operator|=
name|byte_order
expr_stmt|;
if|if
condition|(
name|length
condition|)
operator|::
name|memcpy
argument_list|(
name|this
operator|->
name|bytes
argument_list|,
name|bytes
argument_list|,
name|length
operator|<
name|kMaxByteSize
condition|?
name|length
else|:
name|kMaxByteSize
argument_list|)
expr_stmt|;
return|return
name|IsValid
argument_list|()
return|;
block|}
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
operator|(
name|length
operator|>
literal|0
operator|&&
name|length
operator|<
name|kMaxByteSize
operator|&&
name|byte_order
operator|!=
name|lldb
operator|::
name|eByteOrderInvalid
operator|)
return|;
block|}
comment|// Casts a vector, if valid, to an unsigned int of matching or largest
comment|// supported size.
comment|// Truncates to the beginning of the vector if required.
comment|// Returns a default constructed Scalar if the Vector data is internally
comment|// inconsistent.
name|llvm
operator|::
name|APInt
name|rhs
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
name|BITWIDTH_INT128
argument_list|,
name|NUM_OF_WORDS_INT128
argument_list|,
operator|(
operator|(
name|type128
operator|*
operator|)
name|bytes
operator|)
operator|->
name|x
argument_list|)
expr_stmt|;
name|Scalar
name|GetAsScalar
argument_list|()
specifier|const
block|{
name|Scalar
name|scalar
block|;
if|if
condition|(
name|IsValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|1
condition|)
name|scalar
operator|=
operator|*
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
condition|)
name|scalar
operator|=
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|==
literal|4
condition|)
name|scalar
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|==
literal|8
condition|)
name|scalar
operator|=
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|bytes
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|>=
literal|16
condition|)
name|scalar
operator|=
name|rhs
expr_stmt|;
block|}
return|return
name|scalar
return|;
block|}
block|}
struct|;
name|Value
argument_list|()
expr_stmt|;
name|Value
argument_list|(
specifier|const
name|Scalar
operator|&
name|scalar
argument_list|)
expr_stmt|;
name|Value
argument_list|(
specifier|const
name|Vector
operator|&
name|vector
argument_list|)
expr_stmt|;
name|Value
argument_list|(
argument|const void *bytes
argument_list|,
argument|int len
argument_list|)
empty_stmt|;
name|Value
argument_list|(
specifier|const
name|Value
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|void
name|SetBytes
parameter_list|(
specifier|const
name|void
modifier|*
name|bytes
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|AppendBytes
parameter_list|(
specifier|const
name|void
modifier|*
name|bytes
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|Value
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Value
operator|&
name|rhs
operator|)
decl_stmt|;
specifier|const
name|CompilerType
modifier|&
name|GetCompilerType
parameter_list|()
function_decl|;
name|void
name|SetCompilerType
parameter_list|(
specifier|const
name|CompilerType
modifier|&
name|compiler_type
parameter_list|)
function_decl|;
name|ValueType
name|GetValueType
argument_list|()
specifier|const
expr_stmt|;
name|AddressType
name|GetValueAddressType
argument_list|()
specifier|const
expr_stmt|;
name|ContextType
name|GetContextType
argument_list|()
specifier|const
block|{
return|return
name|m_context_type
return|;
block|}
name|void
name|SetValueType
parameter_list|(
name|ValueType
name|value_type
parameter_list|)
block|{
name|m_value_type
operator|=
name|value_type
expr_stmt|;
block|}
name|void
name|ClearContext
parameter_list|()
block|{
name|m_context
operator|=
name|nullptr
expr_stmt|;
name|m_context_type
operator|=
name|eContextTypeInvalid
expr_stmt|;
block|}
name|void
name|SetContext
parameter_list|(
name|ContextType
name|context_type
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|m_context_type
operator|=
name|context_type
expr_stmt|;
name|m_context
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|m_context_type
operator|==
name|eContextTypeRegisterInfo
condition|)
block|{
name|RegisterInfo
modifier|*
name|reg_info
init|=
name|GetRegisterInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|reg_info
operator|->
name|encoding
operator|==
name|lldb
operator|::
name|eEncodingVector
operator|&&
name|m_vector
operator|.
name|byte_order
operator|!=
name|lldb
operator|::
name|eByteOrderInvalid
condition|)
name|SetValueType
argument_list|(
name|eValueTypeScalar
argument_list|)
expr_stmt|;
block|}
block|}
name|RegisterInfo
operator|*
name|GetRegisterInfo
argument_list|()
specifier|const
expr_stmt|;
name|Type
modifier|*
name|GetType
parameter_list|()
function_decl|;
name|Scalar
modifier|&
name|ResolveValue
parameter_list|(
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
specifier|const
name|Scalar
operator|&
name|GetScalar
argument_list|()
specifier|const
block|{
return|return
name|m_value
return|;
block|}
specifier|const
name|Vector
operator|&
name|GetVector
argument_list|()
specifier|const
block|{
return|return
name|m_vector
return|;
block|}
name|Scalar
modifier|&
name|GetScalar
parameter_list|()
block|{
return|return
name|m_value
return|;
block|}
name|Vector
modifier|&
name|GetVector
parameter_list|()
block|{
return|return
name|m_vector
return|;
block|}
name|bool
name|SetVectorBytes
parameter_list|(
specifier|const
name|Vector
modifier|&
name|vector
parameter_list|)
block|{
name|m_vector
operator|=
name|vector
expr_stmt|;
return|return
name|m_vector
operator|.
name|IsValid
argument_list|()
return|;
block|}
name|bool
name|SetVectorBytes
argument_list|(
name|uint8_t
operator|*
name|bytes
argument_list|,
name|size_t
name|length
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|byte_order
argument_list|)
block|{
return|return
name|m_vector
operator|.
name|SetBytes
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|,
name|byte_order
argument_list|)
return|;
block|}
name|bool
name|SetScalarFromVector
parameter_list|()
block|{
if|if
condition|(
name|m_vector
operator|.
name|IsValid
argument_list|()
condition|)
block|{
name|m_value
operator|=
name|m_vector
operator|.
name|GetAsScalar
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|size_t
name|ResizeData
parameter_list|(
name|size_t
name|len
parameter_list|)
function_decl|;
name|size_t
name|AppendDataToHostBuffer
parameter_list|(
specifier|const
name|Value
modifier|&
name|rhs
parameter_list|)
function_decl|;
name|DataBufferHeap
modifier|&
name|GetBuffer
parameter_list|()
block|{
return|return
name|m_data_buffer
return|;
block|}
specifier|const
name|DataBufferHeap
operator|&
name|GetBuffer
argument_list|()
specifier|const
block|{
return|return
name|m_data_buffer
return|;
block|}
name|bool
name|ValueOf
parameter_list|(
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
name|Variable
modifier|*
name|GetVariable
parameter_list|()
function_decl|;
name|void
name|Dump
parameter_list|(
name|Stream
modifier|*
name|strm
parameter_list|)
function_decl|;
name|lldb
operator|::
name|Format
name|GetValueDefaultFormat
argument_list|()
expr_stmt|;
name|uint64_t
name|GetValueByteSize
parameter_list|(
name|Status
modifier|*
name|error_ptr
parameter_list|,
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|)
function_decl|;
name|Status
name|GetValueAsData
parameter_list|(
name|ExecutionContext
modifier|*
name|exe_ctx
parameter_list|,
name|DataExtractor
modifier|&
name|data
parameter_list|,
name|uint32_t
name|data_offset
parameter_list|,
name|Module
modifier|*
name|module
parameter_list|)
function_decl|;
comment|// Can be nullptr
specifier|static
specifier|const
name|char
modifier|*
name|GetValueTypeAsCString
parameter_list|(
name|ValueType
name|context_type
parameter_list|)
function_decl|;
specifier|static
specifier|const
name|char
modifier|*
name|GetContextTypeAsCString
parameter_list|(
name|ContextType
name|context_type
parameter_list|)
function_decl|;
name|bool
name|GetData
parameter_list|(
name|DataExtractor
modifier|&
name|data
parameter_list|)
function_decl|;
name|void
name|Clear
parameter_list|()
function_decl|;
name|protected
label|:
name|Scalar
name|m_value
decl_stmt|;
name|Vector
name|m_vector
decl_stmt|;
name|CompilerType
name|m_compiler_type
decl_stmt|;
name|void
modifier|*
name|m_context
decl_stmt|;
name|ValueType
name|m_value_type
decl_stmt|;
name|ContextType
name|m_context_type
decl_stmt|;
name|DataBufferHeap
name|m_data_buffer
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ValueList
block|{
name|public
label|:
name|ValueList
argument_list|()
operator|:
name|m_values
argument_list|()
block|{}
name|ValueList
argument_list|(
specifier|const
name|ValueList
operator|&
name|rhs
argument_list|)
expr_stmt|;
operator|~
name|ValueList
argument_list|()
operator|=
expr|default
expr_stmt|;
specifier|const
name|ValueList
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ValueList
operator|&
name|rhs
operator|)
decl_stmt|;
comment|// void InsertValue (Value *value, size_t idx);
name|void
name|PushValue
parameter_list|(
specifier|const
name|Value
modifier|&
name|value
parameter_list|)
function_decl|;
name|size_t
name|GetSize
parameter_list|()
function_decl|;
name|Value
modifier|*
name|GetValueAtIndex
parameter_list|(
name|size_t
name|idx
parameter_list|)
function_decl|;
name|void
name|Clear
parameter_list|()
function_decl|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Value
operator|>
name|collection
expr_stmt|;
name|collection
name|m_values
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_Value_h_
end_comment

end_unit

