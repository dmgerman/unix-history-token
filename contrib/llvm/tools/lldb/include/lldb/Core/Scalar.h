begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Scalar.h ------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|liblldb_Scalar_h_
end_ifndef

begin_define
define|#
directive|define
name|liblldb_Scalar_h_
end_define

begin_include
include|#
directive|include
file|"lldb/Utility/Error.h"
end_include

begin_comment
comment|// for Error
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-enumerations.h"
end_include

begin_comment
comment|// for Encoding, ByteOrder
end_comment

begin_include
include|#
directive|include
file|"lldb/lldb-private-types.h"
end_include

begin_comment
comment|// for type128
end_comment

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|// for size_t
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|// for uint32_t, uint64_t, int64_t
end_comment

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|DataExtractor
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|lldb_private
block|{
name|class
name|Stream
decl_stmt|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_OF_WORDS_INT128
value|2
end_define

begin_define
define|#
directive|define
name|BITWIDTH_INT128
value|128
end_define

begin_define
define|#
directive|define
name|NUM_OF_WORDS_INT256
value|4
end_define

begin_define
define|#
directive|define
name|BITWIDTH_INT256
value|256
end_define

begin_decl_stmt
name|namespace
name|lldb_private
block|{
comment|//----------------------------------------------------------------------
comment|// A class designed to hold onto values and their corresponding types.
comment|// Operators are defined and Scalar objects will correctly promote
comment|// their types and values before performing these operations. Type
comment|// promotion currently follows the ANSI C type promotion rules.
comment|//----------------------------------------------------------------------
name|class
name|Scalar
block|{
name|public
label|:
enum|enum
name|Type
block|{
name|e_void
init|=
literal|0
block|,
name|e_sint
block|,
name|e_uint
block|,
name|e_slong
block|,
name|e_ulong
block|,
name|e_slonglong
block|,
name|e_ulonglong
block|,
name|e_float
block|,
name|e_double
block|,
name|e_long_double
block|,
name|e_uint128
block|,
name|e_sint128
block|,
name|e_uint256
block|,
name|e_sint256
block|}
enum|;
comment|//------------------------------------------------------------------
comment|// Constructors and Destructors
comment|//------------------------------------------------------------------
name|Scalar
argument_list|()
expr_stmt|;
name|Scalar
argument_list|(
argument|int v
argument_list|)
block|:
name|m_type
argument_list|(
name|e_sint
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
argument_list|,
name|v
argument_list|,
name|true
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|unsigned int v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_uint
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
argument_list|,
name|v
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|long v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_slong
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
argument_list|,
name|v
argument_list|,
name|true
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|unsigned long v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_ulong
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
argument_list|,
name|v
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|long long v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_slonglong
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
expr|sizeof
operator|(
name|long
name|long
operator|)
operator|*
literal|8
argument_list|,
name|v
argument_list|,
name|true
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|unsigned long long v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_ulonglong
argument_list|)
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
expr|sizeof
operator|(
name|long
name|long
operator|)
operator|*
literal|8
argument_list|,
name|v
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|float v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_float
argument_list|)
operator|,
name|m_float
argument_list|(
argument|v
argument_list|)
block|{
name|m_float
operator|=
name|llvm
operator|::
name|APFloat
argument_list|(
name|v
argument_list|)
block|; }
name|Scalar
argument_list|(
argument|double v
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_double
argument_list|)
operator|,
name|m_float
argument_list|(
argument|v
argument_list|)
block|{
name|m_float
operator|=
name|llvm
operator|::
name|APFloat
argument_list|(
name|v
argument_list|)
block|;   }
name|Scalar
argument_list|(
argument|long double v
argument_list|,
argument|bool ieee_quad
argument_list|)
operator|:
name|m_type
argument_list|(
name|e_long_double
argument_list|)
operator|,
name|m_float
argument_list|(
operator|(
name|float
operator|)
literal|0
argument_list|)
operator|,
name|m_ieee_quad
argument_list|(
argument|ieee_quad
argument_list|)
block|{
if|if
condition|(
name|ieee_quad
condition|)
name|m_float
operator|=
name|llvm
operator|::
name|APFloat
argument_list|(
name|llvm
operator|::
name|APFloat
operator|::
name|IEEEquad
argument_list|()
argument_list|,
name|llvm
operator|::
name|APInt
argument_list|(
name|BITWIDTH_INT128
argument_list|,
name|NUM_OF_WORDS_INT128
argument_list|,
operator|(
operator|(
name|type128
operator|*
operator|)
operator|&
name|v
operator|)
operator|->
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m_float
operator|=
name|llvm
operator|::
name|APFloat
argument_list|(
name|llvm
operator|::
name|APFloat
operator|::
name|x87DoubleExtended
argument_list|()
argument_list|,
name|llvm
operator|::
name|APInt
argument_list|(
name|BITWIDTH_INT128
argument_list|,
name|NUM_OF_WORDS_INT128
argument_list|,
operator|(
operator|(
name|type128
operator|*
operator|)
operator|&
name|v
operator|)
operator|->
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Scalar
argument_list|(
argument|llvm::APInt v
argument_list|)
block|:
name|m_type
argument_list|()
operator|,
name|m_float
argument_list|(
argument|(float)
literal|0
argument_list|)
block|{
name|m_integer
operator|=
name|llvm
operator|::
name|APInt
argument_list|(
name|v
argument_list|)
block|;
switch|switch
condition|(
name|m_integer
operator|.
name|getBitWidth
argument_list|()
condition|)
block|{
case|case
literal|8
case|:
case|case
literal|16
case|:
case|case
literal|32
case|:
if|if
condition|(
name|m_integer
operator|.
name|isSignedIntN
argument_list|(
sizeof|sizeof
argument_list|(
name|sint_t
argument_list|)
operator|*
literal|8
argument_list|)
condition|)
name|m_type
operator|=
name|e_sint
expr_stmt|;
else|else
name|m_type
operator|=
name|e_uint
expr_stmt|;
break|break;
case|case
literal|64
case|:
if|if
condition|(
name|m_integer
operator|.
name|isSignedIntN
argument_list|(
sizeof|sizeof
argument_list|(
name|slonglong_t
argument_list|)
operator|*
literal|8
argument_list|)
condition|)
name|m_type
operator|=
name|e_slonglong
expr_stmt|;
else|else
name|m_type
operator|=
name|e_ulonglong
expr_stmt|;
break|break;
case|case
literal|128
case|:
if|if
condition|(
name|m_integer
operator|.
name|isSignedIntN
argument_list|(
name|BITWIDTH_INT128
argument_list|)
condition|)
name|m_type
operator|=
name|e_sint128
expr_stmt|;
else|else
name|m_type
operator|=
name|e_uint128
expr_stmt|;
break|break;
case|case
literal|256
case|:
if|if
condition|(
name|m_integer
operator|.
name|isSignedIntN
argument_list|(
name|BITWIDTH_INT256
argument_list|)
condition|)
name|m_type
operator|=
name|e_sint256
expr_stmt|;
else|else
name|m_type
operator|=
name|e_uint256
expr_stmt|;
break|break;
block|}
block|}
name|Scalar
argument_list|(
specifier|const
name|Scalar
operator|&
name|rhs
argument_list|)
expr_stmt|;
comment|// Scalar(const RegisterValue& reg_value);
name|virtual
operator|~
name|Scalar
argument_list|()
expr_stmt|;
name|bool
name|SignExtend
parameter_list|(
name|uint32_t
name|bit_pos
parameter_list|)
function_decl|;
name|bool
name|ExtractBitfield
parameter_list|(
name|uint32_t
name|bit_size
parameter_list|,
name|uint32_t
name|bit_offset
parameter_list|)
function_decl|;
name|bool
name|SetBit
parameter_list|(
name|uint32_t
name|bit
parameter_list|)
function_decl|;
name|bool
name|ClearBit
parameter_list|(
name|uint32_t
name|bit
parameter_list|)
function_decl|;
specifier|const
name|void
operator|*
name|GetBytes
argument_list|()
specifier|const
expr_stmt|;
name|size_t
name|GetByteSize
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|GetData
argument_list|(
name|DataExtractor
operator|&
name|data
argument_list|,
name|size_t
name|limit_byte_size
operator|=
name|UINT32_MAX
argument_list|)
decl|const
decl_stmt|;
name|size_t
name|GetAsMemoryData
argument_list|(
name|void
operator|*
name|dst
argument_list|,
name|size_t
name|dst_len
argument_list|,
name|lldb
operator|::
name|ByteOrder
name|dst_byte_order
argument_list|,
name|Error
operator|&
name|error
argument_list|)
decl|const
decl_stmt|;
name|bool
name|IsZero
argument_list|()
specifier|const
expr_stmt|;
name|void
name|Clear
parameter_list|()
block|{
name|m_type
operator|=
name|e_void
expr_stmt|;
name|m_integer
operator|.
name|clearAllBits
argument_list|()
expr_stmt|;
block|}
specifier|const
name|char
operator|*
name|GetTypeAsCString
argument_list|()
specifier|const
expr_stmt|;
name|void
name|GetValue
argument_list|(
name|Stream
operator|*
name|s
argument_list|,
name|bool
name|show_type
argument_list|)
decl|const
decl_stmt|;
name|bool
name|IsValid
argument_list|()
specifier|const
block|{
return|return
operator|(
name|m_type
operator|>=
name|e_sint
operator|)
operator|&&
operator|(
name|m_type
operator|<=
name|e_long_double
operator|)
return|;
block|}
name|bool
name|Promote
argument_list|(
name|Scalar
operator|::
name|Type
name|type
argument_list|)
decl_stmt|;
name|bool
name|Cast
argument_list|(
name|Scalar
operator|::
name|Type
name|type
argument_list|)
decl_stmt|;
name|bool
name|MakeSigned
parameter_list|()
function_decl|;
name|bool
name|MakeUnsigned
parameter_list|()
function_decl|;
specifier|static
specifier|const
name|char
modifier|*
name|GetValueTypeAsCString
argument_list|(
name|Scalar
operator|::
name|Type
name|value_type
argument_list|)
decl_stmt|;
specifier|static
name|Scalar
operator|::
name|Type
name|GetValueTypeForSignedIntegerWithByteSize
argument_list|(
argument|size_t byte_size
argument_list|)
expr_stmt|;
specifier|static
name|Scalar
operator|::
name|Type
name|GetValueTypeForUnsignedIntegerWithByteSize
argument_list|(
argument|size_t byte_size
argument_list|)
expr_stmt|;
specifier|static
name|Scalar
operator|::
name|Type
name|GetValueTypeForFloatWithByteSize
argument_list|(
argument|size_t byte_size
argument_list|)
expr_stmt|;
comment|//----------------------------------------------------------------------
comment|// All operators can benefits from the implicit conversions that will
comment|// happen automagically by the compiler, so no temporary objects will
comment|// need to be created. As a result, we currently don't need a variety of
comment|// overloaded set value accessors.
comment|//----------------------------------------------------------------------
name|Scalar
modifier|&
name|operator
init|=
operator|(
specifier|const
name|int
name|i
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|unsigned
name|int
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|long
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|unsigned
name|long
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|long
name|long
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|unsigned
name|long
name|long
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|float
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|double
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|long
name|double
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
name|llvm
operator|::
name|APInt
name|v
operator|)
decl_stmt|;
name|Scalar
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
decl_stmt|;
comment|// Assignment operator
name|Scalar
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|Scalar
operator|&
name|operator
operator|<<=
operator|(
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
comment|// Shift left
name|Scalar
operator|&
name|operator
operator|>>=
operator|(
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
comment|// Shift right (arithmetic)
name|Scalar
operator|&
name|operator
operator|&=
operator|(
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
comment|//----------------------------------------------------------------------
comment|// Shifts the current value to the right without maintaining the current
comment|// sign of the value (if it is signed).
comment|//----------------------------------------------------------------------
name|bool
name|ShiftRightLogical
parameter_list|(
specifier|const
name|Scalar
modifier|&
name|rhs
parameter_list|)
function_decl|;
comment|// Returns true on success
comment|//----------------------------------------------------------------------
comment|// Takes the absolute value of the current value if it is signed, else
comment|// the value remains unchanged.
comment|// Returns false if the contained value has a void type.
comment|//----------------------------------------------------------------------
name|bool
name|AbsoluteValue
parameter_list|()
function_decl|;
comment|// Returns true on success
comment|//----------------------------------------------------------------------
comment|// Negates the current value (even for unsigned values).
comment|// Returns false if the contained value has a void type.
comment|//----------------------------------------------------------------------
name|bool
name|UnaryNegate
parameter_list|()
function_decl|;
comment|// Returns true on success
comment|//----------------------------------------------------------------------
comment|// Inverts all bits in the current value as long as it isn't void or
comment|// a float/double/long double type.
comment|// Returns false if the contained value has a void/float/double/long
comment|// double type, else the value is inverted and true is returned.
comment|//----------------------------------------------------------------------
name|bool
name|OnesComplement
parameter_list|()
function_decl|;
comment|// Returns true on success
comment|//----------------------------------------------------------------------
comment|// Access the type of the current value.
comment|//----------------------------------------------------------------------
name|Scalar
operator|::
name|Type
name|GetType
argument_list|()
specifier|const
block|{
return|return
name|m_type
return|;
block|}
comment|//----------------------------------------------------------------------
comment|// Returns a casted value of the current contained data without
comment|// modifying the current value. FAIL_VALUE will be returned if the type
comment|// of the value is void or invalid.
comment|//----------------------------------------------------------------------
name|int
name|SInt
argument_list|(
name|int
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|char
name|UChar
argument_list|(
name|unsigned
name|char
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|signed
name|char
name|SChar
argument_list|(
name|char
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|short
name|UShort
argument_list|(
name|unsigned
name|short
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|short
name|SShort
argument_list|(
name|short
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|int
name|UInt
argument_list|(
name|unsigned
name|int
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|long
name|SLong
argument_list|(
name|long
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|long
name|ULong
argument_list|(
name|unsigned
name|long
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|long
name|long
name|SLongLong
argument_list|(
name|long
name|long
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|long
name|long
name|ULongLong
argument_list|(
name|unsigned
name|long
name|long
name|fail_value
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
name|llvm
operator|::
name|APInt
name|SInt128
argument_list|(
argument|llvm::APInt&fail_value
argument_list|)
specifier|const
expr_stmt|;
name|llvm
operator|::
name|APInt
name|UInt128
argument_list|(
argument|const llvm::APInt&fail_value
argument_list|)
specifier|const
expr_stmt|;
name|llvm
operator|::
name|APInt
name|SInt256
argument_list|(
argument|llvm::APInt&fail_value
argument_list|)
specifier|const
expr_stmt|;
name|llvm
operator|::
name|APInt
name|UInt256
argument_list|(
argument|const llvm::APInt&fail_value
argument_list|)
specifier|const
expr_stmt|;
name|float
name|Float
argument_list|(
name|float
name|fail_value
operator|=
literal|0.0f
argument_list|)
decl|const
decl_stmt|;
name|double
name|Double
argument_list|(
name|double
name|fail_value
operator|=
literal|0.0
argument_list|)
decl|const
decl_stmt|;
name|long
name|double
name|LongDouble
argument_list|(
name|long
name|double
name|fail_value
operator|=
literal|0.0
argument_list|)
decl|const
decl_stmt|;
name|Error
name|SetValueFromCString
argument_list|(
specifier|const
name|char
operator|*
name|s
argument_list|,
name|lldb
operator|::
name|Encoding
name|encoding
argument_list|,
name|size_t
name|byte_size
argument_list|)
decl_stmt|;
name|Error
name|SetValueFromData
argument_list|(
name|DataExtractor
operator|&
name|data
argument_list|,
name|lldb
operator|::
name|Encoding
name|encoding
argument_list|,
name|size_t
name|byte_size
argument_list|)
decl_stmt|;
specifier|static
name|bool
name|UIntValueIsValidForSize
parameter_list|(
name|uint64_t
name|uval64
parameter_list|,
name|size_t
name|total_byte_size
parameter_list|)
block|{
if|if
condition|(
name|total_byte_size
operator|>
literal|8
condition|)
return|return
name|false
return|;
if|if
condition|(
name|total_byte_size
operator|==
literal|8
condition|)
return|return
name|true
return|;
specifier|const
name|uint64_t
name|max
init|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
call|(
name|uint64_t
call|)
argument_list|(
name|total_byte_size
operator|*
literal|8
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
return|return
name|uval64
operator|<=
name|max
return|;
block|}
specifier|static
name|bool
name|SIntValueIsValidForSize
parameter_list|(
name|int64_t
name|sval64
parameter_list|,
name|size_t
name|total_byte_size
parameter_list|)
block|{
if|if
condition|(
name|total_byte_size
operator|>
literal|8
condition|)
return|return
name|false
return|;
if|if
condition|(
name|total_byte_size
operator|==
literal|8
condition|)
return|return
name|true
return|;
specifier|const
name|int64_t
name|max
init|=
operator|(
operator|(
name|int64_t
operator|)
literal|1
operator|<<
call|(
name|uint64_t
call|)
argument_list|(
name|total_byte_size
operator|*
literal|8
operator|-
literal|1
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|int64_t
name|min
init|=
operator|~
operator|(
name|max
operator|)
decl_stmt|;
return|return
name|min
operator|<=
name|sval64
operator|&&
name|sval64
operator|<=
name|max
return|;
block|}
name|protected
label|:
typedef|typedef
name|char
name|schar_t
typedef|;
typedef|typedef
name|unsigned
name|char
name|uchar_t
typedef|;
typedef|typedef
name|short
name|sshort_t
typedef|;
typedef|typedef
name|unsigned
name|short
name|ushort_t
typedef|;
typedef|typedef
name|int
name|sint_t
typedef|;
typedef|typedef
name|unsigned
name|int
name|uint_t
typedef|;
typedef|typedef
name|long
name|slong_t
typedef|;
typedef|typedef
name|unsigned
name|long
name|ulong_t
typedef|;
typedef|typedef
name|long
name|long
name|slonglong_t
typedef|;
typedef|typedef
name|unsigned
name|long
name|long
name|ulonglong_t
typedef|;
typedef|typedef
name|float
name|float_t
typedef|;
typedef|typedef
name|double
name|double_t
typedef|;
typedef|typedef
name|long
name|double
name|long_double_t
typedef|;
comment|//------------------------------------------------------------------
comment|// Classes that inherit from Scalar can see and modify these
comment|//------------------------------------------------------------------
name|Scalar
operator|::
name|Type
name|m_type
expr_stmt|;
name|llvm
operator|::
name|APInt
name|m_integer
expr_stmt|;
name|llvm
operator|::
name|APFloat
name|m_float
expr_stmt|;
name|bool
name|m_ieee_quad
init|=
name|false
decl_stmt|;
name|private
label|:
name|friend
specifier|const
name|Scalar
name|operator
operator|+
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
operator|-
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
operator|/
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
modifier|*
parameter_list|(
specifier|const
name|Scalar
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Scalar
modifier|&
name|rhs
parameter_list|)
function_decl|;
name|friend
specifier|const
name|Scalar
name|operator
function_decl|&(const
name|Scalar
function_decl|&lhs
operator|,
function_decl|const Scalar&rhs
block|)
decl_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
operator||
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
operator|%
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
modifier|^
parameter_list|(
specifier|const
name|Scalar
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Scalar
modifier|&
name|rhs
parameter_list|)
function_decl|;
name|friend
specifier|const
name|Scalar
name|operator
operator|<<
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
specifier|const
name|Scalar
name|operator
operator|>>
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|<
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|>
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
name|friend
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// Split out the operators into a format where the compiler will be able
end_comment

begin_comment
comment|// to implicitly convert numbers into Scalar objects.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This allows code like:
end_comment

begin_comment
comment|//      Scalar two(2);
end_comment

begin_comment
comment|//      Scalar four = two * 2;
end_comment

begin_comment
comment|//      Scalar eight = 2 * four;    // This would cause an error if the
end_comment

begin_comment
comment|//                                  // operator* was implemented as a
end_comment

begin_comment
comment|//                                  // member function.
end_comment

begin_comment
comment|// SEE:
end_comment

begin_comment
comment|//  Item 19 of "Effective C++ Second Edition" by Scott Meyers
end_comment

begin_comment
comment|//  Differentiate among members functions, non-member functions, and
end_comment

begin_comment
comment|//  friend functions
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|+
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|-
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|/
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|const
name|Scalar
name|operator
modifier|*
parameter_list|(
specifier|const
name|Scalar
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Scalar
modifier|&
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|Scalar
name|operator
function_decl|&(const
name|Scalar
function_decl|&lhs
operator|,
function_decl|const Scalar&rhs
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator||
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|%
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|const
name|Scalar
name|operator
modifier|^
parameter_list|(
specifier|const
name|Scalar
modifier|&
name|lhs
parameter_list|,
specifier|const
name|Scalar
modifier|&
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|<<
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|Scalar
name|operator
operator|>>
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|Scalar
operator|&
name|lhs
operator|,
specifier|const
name|Scalar
operator|&
name|rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// namespace lldb_private
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// liblldb_Scalar_h_
end_comment

end_unit

