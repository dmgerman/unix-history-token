begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_ANALYSIS_FORMATSTRINGPARSING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_ANALYSIS_FORMATSTRINGPARSING_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/Analyses/FormatString.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|LangOptions
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|UpdateOnReturn
block|{
name|T
operator|&
name|ValueToUpdate
block|;
specifier|const
name|T
operator|&
name|ValueToCopy
block|;
name|public
operator|:
name|UpdateOnReturn
argument_list|(
name|T
operator|&
name|valueToUpdate
argument_list|,
specifier|const
name|T
operator|&
name|valueToCopy
argument_list|)
operator|:
name|ValueToUpdate
argument_list|(
name|valueToUpdate
argument_list|)
block|,
name|ValueToCopy
argument_list|(
argument|valueToCopy
argument_list|)
block|{}
operator|~
name|UpdateOnReturn
argument_list|()
block|{
name|ValueToUpdate
operator|=
name|ValueToCopy
block|;   }
block|}
expr_stmt|;
name|namespace
name|analyze_format_string
block|{
name|OptionalAmount
name|ParseAmount
parameter_list|(
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|)
function_decl|;
name|OptionalAmount
name|ParseNonPositionAmount
parameter_list|(
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|,
name|unsigned
modifier|&
name|argIndex
parameter_list|)
function_decl|;
name|OptionalAmount
name|ParsePositionAmount
parameter_list|(
name|FormatStringHandler
modifier|&
name|H
parameter_list|,
specifier|const
name|char
modifier|*
name|Start
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|,
name|PositionContext
name|p
parameter_list|)
function_decl|;
name|bool
name|ParseFieldWidth
parameter_list|(
name|FormatStringHandler
modifier|&
name|H
parameter_list|,
name|FormatSpecifier
modifier|&
name|CS
parameter_list|,
specifier|const
name|char
modifier|*
name|Start
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|,
name|unsigned
modifier|*
name|argIndex
parameter_list|)
function_decl|;
name|bool
name|ParseArgPosition
parameter_list|(
name|FormatStringHandler
modifier|&
name|H
parameter_list|,
name|FormatSpecifier
modifier|&
name|CS
parameter_list|,
specifier|const
name|char
modifier|*
name|Start
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|)
function_decl|;
comment|/// Returns true if a LengthModifier was parsed and installed in the
comment|/// FormatSpecifier& argument, and false otherwise.
name|bool
name|ParseLengthModifier
parameter_list|(
name|FormatSpecifier
modifier|&
name|FS
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|Beg
parameter_list|,
specifier|const
name|char
modifier|*
name|E
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|LO
parameter_list|,
name|bool
name|IsScanf
init|=
name|false
parameter_list|)
function_decl|;
comment|/// Returns true if the invalid specifier in \p SpecifierBegin is a UTF-8
comment|/// string; check that it won't go further than \p FmtStrEnd and write
comment|/// up the total size in \p Len.
name|bool
name|ParseUTF8InvalidSpecifier
parameter_list|(
specifier|const
name|char
modifier|*
name|SpecifierBegin
parameter_list|,
specifier|const
name|char
modifier|*
name|FmtStrEnd
parameter_list|,
name|unsigned
modifier|&
name|Len
parameter_list|)
function_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|SpecifierResult
block|{
name|T
name|FS
block|;
specifier|const
name|char
operator|*
name|Start
block|;
name|bool
name|Stop
block|;
name|public
operator|:
name|SpecifierResult
argument_list|(
argument|bool stop = false
argument_list|)
operator|:
name|Start
argument_list|(
name|nullptr
argument_list|)
block|,
name|Stop
argument_list|(
argument|stop
argument_list|)
block|{}
name|SpecifierResult
argument_list|(
specifier|const
name|char
operator|*
name|start
argument_list|,
specifier|const
name|T
operator|&
name|fs
argument_list|)
operator|:
name|FS
argument_list|(
name|fs
argument_list|)
block|,
name|Start
argument_list|(
name|start
argument_list|)
block|,
name|Stop
argument_list|(
argument|false
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Start
return|;
block|}
name|bool
name|shouldStop
argument_list|()
specifier|const
block|{
return|return
name|Stop
return|;
block|}
name|bool
name|hasValue
argument_list|()
specifier|const
block|{
return|return
name|Start
operator|!=
name|nullptr
return|;
block|}
specifier|const
name|T
operator|&
name|getValue
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasValue
argument_list|()
argument_list|)
block|;
return|return
name|FS
return|;
block|}
specifier|const
name|T
operator|&
name|getValue
argument_list|()
block|{
return|return
name|FS
return|;
block|}
expr|}
block|;    }
comment|// end analyze_format_string namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

