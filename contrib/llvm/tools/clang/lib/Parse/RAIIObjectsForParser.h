begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- RAIIObjectsForParser.h - RAII helpers for the parser ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines and implements the some simple RAII objects that are used
end_comment

begin_comment
comment|// by the parser to manage bits in recursion.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_RAII_OBJECTS_FOR_PARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_RAII_OBJECTS_FOR_PARSER_H
end_define

begin_include
include|#
directive|include
file|"clang/Parse/ParseDiagnostic.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/Parser.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/DelayedDiagnostic.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|// TODO: move ParsingClassDefinition here.
comment|// TODO: move TentativeParsingAction here.
comment|/// \brief A RAII object used to temporarily suppress access-like
comment|/// checking.  Access-like checks are those associated with
comment|/// controlling the use of a declaration, like C++ access control
comment|/// errors and deprecation warnings.  They are contextually
comment|/// dependent, in that they can only be resolved with full
comment|/// information about what's being declared.  They are also
comment|/// suppressed in certain contexts, like the template arguments of
comment|/// an explicit instantiation.  However, those suppression contexts
comment|/// cannot necessarily be fully determined in advance;  for
comment|/// example, something starting like this:
comment|///   template<> class std::vector<A::PrivateType>
comment|/// might be the entirety of an explicit instantiation:
comment|///   template<> class std::vector<A::PrivateType>;
comment|/// or just an elaborated type specifier:
comment|///   template<> class std::vector<A::PrivateType> make_vector<>();
comment|/// Therefore this class collects all the diagnostics and permits
comment|/// them to be re-delayed in a new context.
name|class
name|SuppressAccessChecks
block|{
name|Sema
modifier|&
name|S
decl_stmt|;
name|sema
operator|::
name|DelayedDiagnosticPool
name|DiagnosticPool
expr_stmt|;
name|Sema
operator|::
name|ParsingDeclState
name|State
expr_stmt|;
name|bool
name|Active
decl_stmt|;
name|public
label|:
comment|/// Begin suppressing access-like checks
name|SuppressAccessChecks
argument_list|(
argument|Parser&P
argument_list|,
argument|bool activate = true
argument_list|)
block|:
name|S
argument_list|(
name|P
operator|.
name|getActions
argument_list|()
argument_list|)
operator|,
name|DiagnosticPool
argument_list|(
argument|nullptr
argument_list|)
block|{
if|if
condition|(
name|activate
condition|)
block|{
name|State
operator|=
name|S
operator|.
name|PushParsingDeclaration
argument_list|(
name|DiagnosticPool
argument_list|)
expr_stmt|;
name|Active
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|Active
operator|=
name|false
expr_stmt|;
block|}
block|}
name|void
name|done
argument_list|()
block|{
name|assert
argument_list|(
name|Active
operator|&&
literal|"trying to end an inactive suppression"
argument_list|)
block|;
name|S
operator|.
name|PopParsingDeclaration
argument_list|(
name|State
argument_list|,
name|nullptr
argument_list|)
block|;
name|Active
operator|=
name|false
block|;     }
name|void
name|redelay
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Active
operator|&&
literal|"redelaying without having ended first"
argument_list|)
block|;
if|if
condition|(
operator|!
name|DiagnosticPool
operator|.
name|pool_empty
argument_list|()
condition|)
name|S
operator|.
name|redelayDiagnostics
argument_list|(
name|DiagnosticPool
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DiagnosticPool
operator|.
name|pool_empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|~
name|SuppressAccessChecks
argument_list|()
block|{
if|if
condition|(
name|Active
condition|)
name|done
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief RAII object used to inform the actions that we're
end_comment

begin_comment
comment|/// currently parsing a declaration.  This is active when parsing a
end_comment

begin_comment
comment|/// variable's initializer, but not when parsing the body of a
end_comment

begin_comment
comment|/// class or function definition.
end_comment

begin_decl_stmt
name|class
name|ParsingDeclRAIIObject
block|{
name|Sema
modifier|&
name|Actions
decl_stmt|;
name|sema
operator|::
name|DelayedDiagnosticPool
name|DiagnosticPool
expr_stmt|;
name|Sema
operator|::
name|ParsingDeclState
name|State
expr_stmt|;
name|bool
name|Popped
decl_stmt|;
name|ParsingDeclRAIIObject
argument_list|(
argument|const ParsingDeclRAIIObject&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|ParsingDeclRAIIObject
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|public
label|:
enum|enum
name|NoParent_t
block|{
name|NoParent
block|}
enum|;
name|ParsingDeclRAIIObject
argument_list|(
argument|Parser&P
argument_list|,
argument|NoParent_t _
argument_list|)
block|:
name|Actions
argument_list|(
name|P
operator|.
name|getActions
argument_list|()
argument_list|)
operator|,
name|DiagnosticPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|push
argument_list|()
block|;     }
comment|/// Creates a RAII object whose pool is optionally parented by another.
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
specifier|const
name|sema
operator|::
name|DelayedDiagnosticPool
operator|*
name|parentPool
argument_list|)
operator|:
name|Actions
argument_list|(
name|P
operator|.
name|getActions
argument_list|()
argument_list|)
operator|,
name|DiagnosticPool
argument_list|(
argument|parentPool
argument_list|)
block|{
name|push
argument_list|()
block|;     }
comment|/// Creates a RAII object and, optionally, initialize its
comment|/// diagnostics pool by stealing the diagnostics from another
comment|/// RAII object (which is assumed to be the current top pool).
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|other
argument_list|)
operator|:
name|Actions
argument_list|(
name|P
operator|.
name|getActions
argument_list|()
argument_list|)
operator|,
name|DiagnosticPool
argument_list|(
argument|other ? other->DiagnosticPool.getParent() : nullptr
argument_list|)
block|{
if|if
condition|(
name|other
condition|)
block|{
name|DiagnosticPool
operator|.
name|steal
argument_list|(
name|other
operator|->
name|DiagnosticPool
argument_list|)
expr_stmt|;
name|other
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
name|push
argument_list|()
expr_stmt|;
block|}
operator|~
name|ParsingDeclRAIIObject
argument_list|()
block|{
name|abort
argument_list|()
block|;     }
name|sema
operator|::
name|DelayedDiagnosticPool
operator|&
name|getDelayedDiagnosticPool
argument_list|()
block|{
return|return
name|DiagnosticPool
return|;
block|}
specifier|const
name|sema
operator|::
name|DelayedDiagnosticPool
operator|&
name|getDelayedDiagnosticPool
argument_list|()
specifier|const
block|{
return|return
name|DiagnosticPool
return|;
block|}
comment|/// Resets the RAII object for a new declaration.
name|void
name|reset
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
block|}
comment|/// Signals that the context was completed without an appropriate
comment|/// declaration being parsed.
name|void
name|abort
parameter_list|()
block|{
name|pop
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
block|}
name|void
name|complete
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"ParsingDeclaration has already been popped!"
argument_list|)
expr_stmt|;
name|pop
argument_list|(
name|D
argument_list|)
expr_stmt|;
block|}
comment|/// Unregister this object from Sema, but remember all the
comment|/// diagnostics that were emitted into it.
name|void
name|abortAndRemember
parameter_list|()
block|{
name|pop
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|void
name|push
parameter_list|()
block|{
name|State
operator|=
name|Actions
operator|.
name|PushParsingDeclaration
argument_list|(
name|DiagnosticPool
argument_list|)
expr_stmt|;
name|Popped
operator|=
name|false
expr_stmt|;
block|}
name|void
name|pop
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
block|{
name|Actions
operator|.
name|PopParsingDeclaration
argument_list|(
name|State
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|Popped
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// A class for parsing a DeclSpec.
end_comment

begin_decl_stmt
name|class
name|ParsingDeclSpec
range|:
name|public
name|DeclSpec
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|DeclSpec
argument_list|(
name|P
operator|.
name|getAttrFactory
argument_list|()
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|ParsingDeclRAIIObject::NoParent
argument_list|)
block|{}
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|RAII
argument_list|)
operator|:
name|DeclSpec
argument_list|(
name|P
operator|.
name|getAttrFactory
argument_list|()
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|RAII
argument_list|)
block|{}
specifier|const
name|sema
operator|::
name|DelayedDiagnosticPool
operator|&
name|getDelayedDiagnosticPool
argument_list|()
specifier|const
block|{
return|return
name|ParsingRAII
operator|.
name|getDelayedDiagnosticPool
argument_list|()
return|;
block|}
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
name|void
name|abort
argument_list|()
block|{
name|ParsingRAII
operator|.
name|abort
argument_list|()
block|;     }
expr|}
block|;
comment|/// A class for parsing a declarator.
name|class
name|ParsingDeclarator
operator|:
name|public
name|Declarator
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclarator
argument_list|(
argument|Parser&P
argument_list|,
argument|const ParsingDeclSpec&DS
argument_list|,
argument|TheContext C
argument_list|)
operator|:
name|Declarator
argument_list|(
name|DS
argument_list|,
name|C
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|&DS.getDelayedDiagnosticPool()
argument_list|)
block|{     }
specifier|const
name|ParsingDeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|Declarator
operator|::
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|ParsingDeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|Declarator
operator|::
name|clear
argument_list|()
block|;
name|ParsingRAII
operator|.
name|reset
argument_list|()
block|;     }
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
expr|}
block|;
comment|/// A class for parsing a field declarator.
name|class
name|ParsingFieldDeclarator
operator|:
name|public
name|FieldDeclarator
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingFieldDeclarator
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
specifier|const
name|ParsingDeclSpec
operator|&
name|DS
argument_list|)
operator|:
name|FieldDeclarator
argument_list|(
name|DS
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|&DS.getDelayedDiagnosticPool()
argument_list|)
block|{     }
specifier|const
name|ParsingDeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|D
operator|.
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|ParsingDeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
expr|}
block|;
comment|/// ExtensionRAIIObject - This saves the state of extension warnings when
comment|/// constructed and disables them.  When destructed, it restores them back to
comment|/// the way they used to be.  This is used to handle __extension__ in the
comment|/// parser.
name|class
name|ExtensionRAIIObject
block|{
name|ExtensionRAIIObject
argument_list|(
argument|const ExtensionRAIIObject&
argument_list|)
name|LLVM_DELETED_FUNCTION
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|ExtensionRAIIObject
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
block|;
name|DiagnosticsEngine
operator|&
name|Diags
block|;
name|public
operator|:
name|ExtensionRAIIObject
argument_list|(
name|DiagnosticsEngine
operator|&
name|diags
argument_list|)
operator|:
name|Diags
argument_list|(
argument|diags
argument_list|)
block|{
name|Diags
operator|.
name|IncrementAllExtensionsSilenced
argument_list|()
block|;     }
operator|~
name|ExtensionRAIIObject
argument_list|()
block|{
name|Diags
operator|.
name|DecrementAllExtensionsSilenced
argument_list|()
block|;     }
block|}
block|;
comment|/// ColonProtectionRAIIObject - This sets the Parser::ColonIsSacred bool and
comment|/// restores it when destroyed.  This says that "foo:" should not be
comment|/// considered a possible typo for "foo::" for error recovery purposes.
name|class
name|ColonProtectionRAIIObject
block|{
name|Parser
operator|&
name|P
block|;
name|bool
name|OldVal
block|;
name|public
operator|:
name|ColonProtectionRAIIObject
argument_list|(
argument|Parser&p
argument_list|,
argument|bool Value = true
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
block|,
name|OldVal
argument_list|(
argument|P.ColonIsSacred
argument_list|)
block|{
name|P
operator|.
name|ColonIsSacred
operator|=
name|Value
block|;     }
comment|/// restore - This can be used to restore the state early, before the dtor
comment|/// is run.
name|void
name|restore
argument_list|()
block|{
name|P
operator|.
name|ColonIsSacred
operator|=
name|OldVal
block|;     }
operator|~
name|ColonProtectionRAIIObject
argument_list|()
block|{
name|restore
argument_list|()
block|;     }
block|}
block|;
comment|/// \brief RAII object that makes '>' behave either as an operator
comment|/// or as the closing angle bracket for a template argument list.
name|class
name|GreaterThanIsOperatorScope
block|{
name|bool
operator|&
name|GreaterThanIsOperator
block|;
name|bool
name|OldGreaterThanIsOperator
block|;
name|public
operator|:
name|GreaterThanIsOperatorScope
argument_list|(
argument|bool&GTIO
argument_list|,
argument|bool Val
argument_list|)
operator|:
name|GreaterThanIsOperator
argument_list|(
name|GTIO
argument_list|)
block|,
name|OldGreaterThanIsOperator
argument_list|(
argument|GTIO
argument_list|)
block|{
name|GreaterThanIsOperator
operator|=
name|Val
block|;     }
operator|~
name|GreaterThanIsOperatorScope
argument_list|()
block|{
name|GreaterThanIsOperator
operator|=
name|OldGreaterThanIsOperator
block|;     }
block|}
block|;
name|class
name|InMessageExpressionRAIIObject
block|{
name|bool
operator|&
name|InMessageExpression
block|;
name|bool
name|OldValue
block|;
name|public
operator|:
name|InMessageExpressionRAIIObject
argument_list|(
argument|Parser&P
argument_list|,
argument|bool Value
argument_list|)
operator|:
name|InMessageExpression
argument_list|(
name|P
operator|.
name|InMessageExpression
argument_list|)
block|,
name|OldValue
argument_list|(
argument|P.InMessageExpression
argument_list|)
block|{
name|InMessageExpression
operator|=
name|Value
block|;     }
operator|~
name|InMessageExpressionRAIIObject
argument_list|()
block|{
name|InMessageExpression
operator|=
name|OldValue
block|;     }
block|}
block|;
comment|/// \brief RAII object that makes sure paren/bracket/brace count is correct
comment|/// after declaration/statement parsing, even when there's a parsing error.
name|class
name|ParenBraceBracketBalancer
block|{
name|Parser
operator|&
name|P
block|;
name|unsigned
name|short
name|ParenCount
block|,
name|BracketCount
block|,
name|BraceCount
block|;
name|public
operator|:
name|ParenBraceBracketBalancer
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
block|,
name|ParenCount
argument_list|(
name|p
operator|.
name|ParenCount
argument_list|)
block|,
name|BracketCount
argument_list|(
name|p
operator|.
name|BracketCount
argument_list|)
block|,
name|BraceCount
argument_list|(
argument|p.BraceCount
argument_list|)
block|{ }
operator|~
name|ParenBraceBracketBalancer
argument_list|()
block|{
name|P
operator|.
name|ParenCount
operator|=
name|ParenCount
block|;
name|P
operator|.
name|BracketCount
operator|=
name|BracketCount
block|;
name|P
operator|.
name|BraceCount
operator|=
name|BraceCount
block|;     }
block|}
block|;
name|class
name|PoisonSEHIdentifiersRAIIObject
block|{
name|PoisonIdentifierRAIIObject
name|Ident_AbnormalTermination
block|;
name|PoisonIdentifierRAIIObject
name|Ident_GetExceptionCode
block|;
name|PoisonIdentifierRAIIObject
name|Ident_GetExceptionInfo
block|;
name|PoisonIdentifierRAIIObject
name|Ident__abnormal_termination
block|;
name|PoisonIdentifierRAIIObject
name|Ident__exception_code
block|;
name|PoisonIdentifierRAIIObject
name|Ident__exception_info
block|;
name|PoisonIdentifierRAIIObject
name|Ident___abnormal_termination
block|;
name|PoisonIdentifierRAIIObject
name|Ident___exception_code
block|;
name|PoisonIdentifierRAIIObject
name|Ident___exception_info
block|;
name|public
operator|:
name|PoisonSEHIdentifiersRAIIObject
argument_list|(
argument|Parser&Self
argument_list|,
argument|bool NewValue
argument_list|)
operator|:
name|Ident_AbnormalTermination
argument_list|(
name|Self
operator|.
name|Ident_AbnormalTermination
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident_GetExceptionCode
argument_list|(
name|Self
operator|.
name|Ident_GetExceptionCode
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident_GetExceptionInfo
argument_list|(
name|Self
operator|.
name|Ident_GetExceptionInfo
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident__abnormal_termination
argument_list|(
name|Self
operator|.
name|Ident__abnormal_termination
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident__exception_code
argument_list|(
name|Self
operator|.
name|Ident__exception_code
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident__exception_info
argument_list|(
name|Self
operator|.
name|Ident__exception_info
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident___abnormal_termination
argument_list|(
name|Self
operator|.
name|Ident___abnormal_termination
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident___exception_code
argument_list|(
name|Self
operator|.
name|Ident___exception_code
argument_list|,
name|NewValue
argument_list|)
block|,
name|Ident___exception_info
argument_list|(
argument|Self.Ident___exception_info
argument_list|,
argument|NewValue
argument_list|)
block|{     }
block|}
block|;
comment|/// \brief RAII class that helps handle the parsing of an open/close delimiter
comment|/// pair, such as braces { ... } or parentheses ( ... ).
name|class
name|BalancedDelimiterTracker
operator|:
name|public
name|GreaterThanIsOperatorScope
block|{
name|Parser
operator|&
name|P
block|;
name|tok
operator|::
name|TokenKind
name|Kind
block|,
name|Close
block|,
name|FinalToken
block|;
name|SourceLocation
argument_list|(
name|Parser
operator|::
operator|*
name|Consumer
argument_list|)
argument_list|()
block|;
name|SourceLocation
name|LOpen
block|,
name|LClose
block|;
name|unsigned
name|short
operator|&
name|getDepth
argument_list|()
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
case|case
name|tok
operator|::
name|l_brace
case|:
return|return
name|P
operator|.
name|BraceCount
return|;
case|case
name|tok
operator|::
name|l_square
case|:
return|return
name|P
operator|.
name|BracketCount
return|;
case|case
name|tok
operator|::
name|l_paren
case|:
return|return
name|P
operator|.
name|ParenCount
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Wrong token kind"
argument_list|)
expr_stmt|;
block|}
block|}
expr|enum
block|{
name|MaxDepth
operator|=
literal|256
block|}
block|;
name|bool
name|diagnoseOverflow
argument_list|()
block|;
name|bool
name|diagnoseMissingClose
argument_list|()
block|;
name|public
operator|:
name|BalancedDelimiterTracker
argument_list|(
argument|Parser& p
argument_list|,
argument|tok::TokenKind k
argument_list|,
argument|tok::TokenKind FinalToken = tok::semi
argument_list|)
operator|:
name|GreaterThanIsOperatorScope
argument_list|(
name|p
operator|.
name|GreaterThanIsOperator
argument_list|,
name|true
argument_list|)
block|,
name|P
argument_list|(
name|p
argument_list|)
block|,
name|Kind
argument_list|(
name|k
argument_list|)
block|,
name|FinalToken
argument_list|(
argument|FinalToken
argument_list|)
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unexpected balanced token"
argument_list|)
expr_stmt|;
case|case
name|tok
operator|::
name|l_brace
case|:
name|Close
operator|=
name|tok
operator|::
name|r_brace
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeBrace
expr_stmt|;
break|break;
case|case
name|tok
operator|::
name|l_paren
case|:
name|Close
operator|=
name|tok
operator|::
name|r_paren
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeParen
expr_stmt|;
break|break;
case|case
name|tok
operator|::
name|l_square
case|:
name|Close
operator|=
name|tok
operator|::
name|r_square
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeBracket
expr_stmt|;
break|break;
block|}
block|}
name|SourceLocation
name|getOpenLocation
argument_list|()
specifier|const
block|{
return|return
name|LOpen
return|;
block|}
name|SourceLocation
name|getCloseLocation
argument_list|()
specifier|const
block|{
return|return
name|LClose
return|;
block|}
name|SourceRange
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|LOpen
argument_list|,
name|LClose
argument_list|)
return|;
block|}
name|bool
name|consumeOpen
argument_list|()
block|{
if|if
condition|(
operator|!
name|P
operator|.
name|Tok
operator|.
name|is
argument_list|(
name|Kind
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|getDepth
argument_list|()
operator|<
name|P
operator|.
name|getLangOpts
argument_list|()
operator|.
name|BracketDepth
condition|)
block|{
name|LOpen
operator|=
operator|(
name|P
operator|.*
name|Consumer
operator|)
operator|(
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|diagnoseOverflow
argument_list|()
return|;
block|}
name|bool
name|expectAndConsume
argument_list|(
argument|unsigned DiagID = diag::err_expected
argument_list|,
argument|const char *Msg =
literal|""
argument_list|,
argument|tok::TokenKind SkipToTok = tok::unknown
argument_list|)
block|;
name|bool
name|consumeClose
argument_list|()
block|{
if|if
condition|(
name|P
operator|.
name|Tok
operator|.
name|is
argument_list|(
name|Close
argument_list|)
condition|)
block|{
name|LClose
operator|=
operator|(
name|P
operator|.*
name|Consumer
operator|)
operator|(
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|diagnoseMissingClose
argument_list|()
return|;
block|}
name|void
name|skipToEnd
argument_list|()
block|;   }
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

