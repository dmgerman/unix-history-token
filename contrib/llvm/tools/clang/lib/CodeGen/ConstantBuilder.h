begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----- ConstantBuilder.h - Builder for LLVM IR constants ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class provides a convenient interface for building complex
end_comment

begin_comment
comment|// global initializers.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_CODEGEN_CONSTANTBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_CODEGEN_CONSTANTBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenModule.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|CodeGen
block|{
name|class
name|ConstantStructBuilder
decl_stmt|;
name|class
name|ConstantArrayBuilder
decl_stmt|;
comment|/// A convenience builder class for complex constant initializers,
comment|/// especially for anonymous global structures used by various language
comment|/// runtimes.
comment|///
comment|/// The basic usage pattern is expected to be something like:
comment|///    ConstantInitBuilder builder(CGM);
comment|///    auto toplevel = builder.beginStruct();
comment|///    toplevel.addInt(CGM.SizeTy, widgets.size());
comment|///    auto widgetArray = builder.beginArray();
comment|///    for (auto&widget : widgets) {
comment|///      auto widgetDesc = widgetArray.beginStruct();
comment|///      widgetDesc.addInt(CGM.SizeTy, widget.getPower());
comment|///      widgetDesc.add(CGM.GetAddrOfConstantString(widget.getName()));
comment|///      widgetDesc.add(CGM.GetAddrOfGlobal(widget.getInitializerDecl()));
comment|///      widgetArray.add(widgetDesc.finish());
comment|///    }
comment|///    toplevel.add(widgetArray.finish());
comment|///    auto global = toplevel.finishAndCreateGlobal("WIDGET_LIST", Align,
comment|///                                                 /*constant*/ true);
name|class
name|ConstantInitBuilder
block|{
struct|struct
name|SelfReference
block|{
name|llvm
operator|::
name|GlobalVariable
operator|*
name|Dummy
expr_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|,
literal|4
operator|>
name|Indices
expr_stmt|;
name|SelfReference
argument_list|(
name|llvm
operator|::
name|GlobalVariable
operator|*
name|dummy
argument_list|)
operator|:
name|Dummy
argument_list|(
argument|dummy
argument_list|)
block|{}
block|}
struct|;
name|CodeGenModule
modifier|&
name|CGM
decl_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|,
literal|16
operator|>
name|Buffer
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SelfReference
operator|>
name|SelfReferences
expr_stmt|;
name|bool
name|Frozen
init|=
name|false
decl_stmt|;
name|public
label|:
name|explicit
name|ConstantInitBuilder
argument_list|(
name|CodeGenModule
operator|&
name|CGM
argument_list|)
operator|:
name|CGM
argument_list|(
argument|CGM
argument_list|)
block|{}
operator|~
name|ConstantInitBuilder
argument_list|()
block|{
name|assert
argument_list|(
name|Buffer
operator|.
name|empty
argument_list|()
operator|&&
literal|"didn't claim all values out of buffer"
argument_list|)
block|;   }
name|class
name|AggregateBuilderBase
block|{
name|protected
operator|:
name|ConstantInitBuilder
operator|&
name|Builder
block|;
name|AggregateBuilderBase
operator|*
name|Parent
block|;
name|size_t
name|Begin
block|;
name|bool
name|Finished
operator|=
name|false
block|;
name|bool
name|Frozen
operator|=
name|false
block|;
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
operator|&
name|getBuffer
argument_list|()
block|{
return|return
name|Builder
operator|.
name|Buffer
return|;
block|}
specifier|const
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
operator|&
name|getBuffer
argument_list|()
specifier|const
block|{
return|return
name|Builder
operator|.
name|Buffer
return|;
block|}
name|AggregateBuilderBase
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|)
operator|:
name|Builder
argument_list|(
name|builder
argument_list|)
block|,
name|Parent
argument_list|(
name|parent
argument_list|)
block|,
name|Begin
argument_list|(
argument|builder.Buffer.size()
argument_list|)
block|{
if|if
condition|(
name|parent
condition|)
block|{
name|assert
argument_list|(
operator|!
name|parent
operator|->
name|Frozen
operator|&&
literal|"parent already has child builder active"
argument_list|)
expr_stmt|;
name|parent
operator|->
name|Frozen
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|!
name|builder
operator|.
name|Frozen
operator|&&
literal|"builder already has child builder active"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|Frozen
operator|=
name|true
expr_stmt|;
block|}
block|}
operator|~
name|AggregateBuilderBase
argument_list|()
block|{
name|assert
argument_list|(
name|Finished
operator|&&
literal|"didn't finish aggregate builder"
argument_list|)
block|;     }
name|void
name|markFinished
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"child builder still active"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"builder already finished"
argument_list|)
block|;
name|Finished
operator|=
name|true
block|;
if|if
condition|(
name|Parent
condition|)
block|{
name|assert
argument_list|(
name|Parent
operator|->
name|Frozen
operator|&&
literal|"parent not frozen while child builder active"
argument_list|)
expr_stmt|;
name|Parent
operator|->
name|Frozen
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|Builder
operator|.
name|Frozen
operator|&&
literal|"builder not frozen while child builder active"
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Frozen
operator|=
name|false
expr_stmt|;
block|}
block|}
name|public
operator|:
comment|// Not copyable.
name|AggregateBuilderBase
argument_list|(
specifier|const
name|AggregateBuilderBase
operator|&
argument_list|)
operator|=
name|delete
block|;
name|AggregateBuilderBase
operator|&
name|operator
operator|=
operator|(
specifier|const
name|AggregateBuilderBase
operator|&
operator|)
operator|=
name|delete
block|;
comment|// Movable, mostly to allow returning.  But we have to write this out
comment|// properly to satisfy the assert in the destructor.
name|AggregateBuilderBase
argument_list|(
name|AggregateBuilderBase
operator|&&
name|other
argument_list|)
operator|:
name|Builder
argument_list|(
name|other
operator|.
name|Builder
argument_list|)
block|,
name|Parent
argument_list|(
name|other
operator|.
name|Parent
argument_list|)
block|,
name|Begin
argument_list|(
name|other
operator|.
name|Begin
argument_list|)
block|,
name|Finished
argument_list|(
name|other
operator|.
name|Finished
argument_list|)
block|,
name|Frozen
argument_list|(
argument|other.Frozen
argument_list|)
block|{
name|other
operator|.
name|Finished
operator|=
name|false
block|;     }
name|AggregateBuilderBase
operator|&
name|operator
operator|=
operator|(
name|AggregateBuilderBase
operator|&&
name|other
operator|)
operator|=
name|delete
block|;
comment|/// Abandon this builder completely.
name|void
name|abandon
argument_list|()
block|{
name|markFinished
argument_list|()
block|;
name|auto
operator|&
name|buffer
operator|=
name|Builder
operator|.
name|Buffer
block|;
name|buffer
operator|.
name|erase
argument_list|(
name|buffer
operator|.
name|begin
argument_list|()
operator|+
name|Begin
argument_list|,
name|buffer
operator|.
name|end
argument_list|()
argument_list|)
block|;     }
comment|/// Add a new value to this initializer.
name|void
name|add
argument_list|(
argument|llvm::Constant *value
argument_list|)
block|{
name|assert
argument_list|(
name|value
operator|&&
literal|"adding null value to constant initializer"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
block|;
name|Builder
operator|.
name|Buffer
operator|.
name|push_back
argument_list|(
name|value
argument_list|)
block|;     }
comment|/// Add an integer value of type size_t.
name|void
name|addSize
argument_list|(
argument|CharUnits size
argument_list|)
block|{
name|add
argument_list|(
name|Builder
operator|.
name|CGM
operator|.
name|getSize
argument_list|(
name|size
argument_list|)
argument_list|)
block|;     }
comment|/// Add an integer value of a specific type.
name|void
name|addInt
argument_list|(
argument|llvm::IntegerType *intTy
argument_list|,
argument|uint64_t value
argument_list|,
argument|bool isSigned = false
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|intTy
argument_list|,
name|value
argument_list|,
name|isSigned
argument_list|)
argument_list|)
block|;     }
comment|/// Add a null pointer of a specific type.
name|void
name|addNullPointer
argument_list|(
argument|llvm::PointerType *ptrTy
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantPointerNull
operator|::
name|get
argument_list|(
name|ptrTy
argument_list|)
argument_list|)
block|;     }
comment|/// Add a bitcast of a value to a specific type.
name|void
name|addBitCast
argument_list|(
argument|llvm::Constant *value
argument_list|,
argument|llvm::Type *type
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantExpr
operator|::
name|getBitCast
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
argument_list|)
block|;     }
comment|/// Add a bunch of new values to this initializer.
name|void
name|addAll
argument_list|(
argument|ArrayRef<llvm::Constant *> values
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
block|;
name|Builder
operator|.
name|Buffer
operator|.
name|append
argument_list|(
name|values
operator|.
name|begin
argument_list|()
argument_list|,
name|values
operator|.
name|end
argument_list|()
argument_list|)
block|;     }
comment|/// An opaque class to hold the abstract position of a placeholder.
name|class
name|PlaceholderPosition
block|{
name|size_t
name|Index
block|;
name|friend
name|class
name|AggregateBuilderBase
block|;
name|PlaceholderPosition
argument_list|(
argument|size_t index
argument_list|)
operator|:
name|Index
argument_list|(
argument|index
argument_list|)
block|{}
block|}
block|;
comment|/// Add a placeholder value to the structure.  The returned position
comment|/// can be used to set the value later; it will not be invalidated by
comment|/// any intermediate operations except (1) filling the same position or
comment|/// (2) finishing the entire builder.
comment|///
comment|/// This is useful for emitting certain kinds of structure which
comment|/// contain some sort of summary field, generaly a count, before any
comment|/// of the data.  By emitting a placeholder first, the structure can
comment|/// be emitted eagerly.
name|PlaceholderPosition
name|addPlaceholder
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
block|;
name|Builder
operator|.
name|Buffer
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
block|;
return|return
name|Builder
operator|.
name|Buffer
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/// Fill a previously-added placeholder.
name|void
name|fillPlaceholderWithInt
argument_list|(
argument|PlaceholderPosition position
argument_list|,
argument|llvm::IntegerType *type
argument_list|,
argument|uint64_t value
argument_list|,
argument|bool isSigned = false
argument_list|)
block|{
name|fillPlaceholder
argument_list|(
name|position
argument_list|,
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|isSigned
argument_list|)
argument_list|)
block|;     }
comment|/// Fill a previously-added placeholder.
name|void
name|fillPlaceholder
argument_list|(
argument|PlaceholderPosition position
argument_list|,
argument|llvm::Constant *value
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot change values after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
block|;
name|llvm
operator|::
name|Constant
operator|*
operator|&
name|slot
operator|=
name|Builder
operator|.
name|Buffer
index|[
name|position
operator|.
name|Index
index|]
block|;
name|assert
argument_list|(
name|slot
operator|==
name|nullptr
operator|&&
literal|"placeholder already filled"
argument_list|)
block|;
name|slot
operator|=
name|value
block|;     }
comment|/// Produce an address which will eventually point to the the next
comment|/// position to be filled.  This is computed with an indexed
comment|/// getelementptr rather than by computing offsets.
comment|///
comment|/// The returned pointer will have type T*, where T is the given
comment|/// position.
name|llvm
operator|::
name|Constant
operator|*
name|getAddrOfCurrentPosition
argument_list|(
argument|llvm::Type *type
argument_list|)
block|{
comment|// Make a global variable.  We will replace this with a GEP to this
comment|// position after installing the initializer.
name|auto
name|dummy
operator|=
name|new
name|llvm
operator|::
name|GlobalVariable
argument_list|(
name|Builder
operator|.
name|CGM
operator|.
name|getModule
argument_list|()
argument_list|,
name|type
argument_list|,
name|true
argument_list|,
name|llvm
operator|::
name|GlobalVariable
operator|::
name|PrivateLinkage
argument_list|,
name|nullptr
argument_list|,
literal|""
argument_list|)
block|;
name|Builder
operator|.
name|SelfReferences
operator|.
name|emplace_back
argument_list|(
name|dummy
argument_list|)
block|;
name|auto
operator|&
name|entry
operator|=
name|Builder
operator|.
name|SelfReferences
operator|.
name|back
argument_list|()
block|;
operator|(
name|void
operator|)
name|getGEPIndicesToCurrentPosition
argument_list|(
name|entry
operator|.
name|Indices
argument_list|)
block|;
return|return
name|dummy
return|;
block|}
name|ArrayRef
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
name|getGEPIndicesToCurrentPosition
argument_list|(
argument|llvm::SmallVectorImpl<llvm::Constant*>&indices
argument_list|)
block|{
name|getGEPIndicesTo
argument_list|(
name|indices
argument_list|,
name|Builder
operator|.
name|Buffer
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|indices
return|;
block|}
name|ConstantArrayBuilder
name|beginArray
argument_list|(
name|llvm
operator|::
name|Type
operator|*
name|eltTy
operator|=
name|nullptr
argument_list|)
block|;
name|ConstantStructBuilder
name|beginStruct
argument_list|(
name|llvm
operator|::
name|StructType
operator|*
name|structTy
operator|=
name|nullptr
argument_list|)
block|;
name|private
operator|:
name|void
name|getGEPIndicesTo
argument_list|(
argument|llvm::SmallVectorImpl<llvm::Constant*>&indices
argument_list|,
argument|size_t position
argument_list|)
specifier|const
block|{
comment|// Recurse on the parent builder if present.
if|if
condition|(
name|Parent
condition|)
block|{
name|Parent
operator|->
name|getGEPIndicesTo
argument_list|(
name|indices
argument_list|,
name|Begin
argument_list|)
expr_stmt|;
comment|// Otherwise, add an index to drill into the first level of pointer.
block|}
else|else
block|{
name|assert
argument_list|(
name|indices
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|.
name|push_back
argument_list|(
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|Builder
operator|.
name|CGM
operator|.
name|Int32Ty
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|position
operator|>=
name|Begin
argument_list|)
expr_stmt|;
comment|// We have to use i32 here because struct GEPs demand i32 indices.
comment|// It's rather unlikely to matter in practice.
name|indices
operator|.
name|push_back
argument_list|(
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|Builder
operator|.
name|CGM
operator|.
name|Int32Ty
argument_list|,
name|position
operator|-
name|Begin
argument_list|)
argument_list|)
block|;     }
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Impl
operator|>
name|class
name|AggregateBuilder
operator|:
name|public
name|AggregateBuilderBase
block|{
name|protected
operator|:
name|AggregateBuilder
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|)
operator|:
name|AggregateBuilderBase
argument_list|(
argument|builder
argument_list|,
argument|parent
argument_list|)
block|{}
name|Impl
operator|&
name|asImpl
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|Impl
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|public
operator|:
comment|/// Given that this builder was created by beginning an array or struct
comment|/// component on the given parent builder, finish the array/struct
comment|/// component and add it to the parent.
comment|///
comment|/// It is an intentional choice that the parent is passed in explicitly
comment|/// despite it being redundant with information already kept in the
comment|/// builder.  This aids in readability by making it easier to find the
comment|/// places that add components to a builder, as well as "bookending"
comment|/// the sub-builder more explicitly.
name|void
name|finishAndAddTo
argument_list|(
argument|AggregateBuilderBase&parent
argument_list|)
block|{
name|assert
argument_list|(
name|Parent
operator|==
operator|&
name|parent
operator|&&
literal|"adding to non-parent builder"
argument_list|)
block|;
name|parent
operator|.
name|add
argument_list|(
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|)
block|;     }
comment|/// Given that this builder was created by beginning an array or struct
comment|/// directly on a ConstantInitBuilder, finish the array/struct and
comment|/// create a global variable with it as the initializer.
name|template
operator|<
name|class
operator|...
name|As
operator|>
name|llvm
operator|::
name|GlobalVariable
operator|*
name|finishAndCreateGlobal
argument_list|(
argument|As&&...args
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Parent
operator|&&
literal|"finishing non-root builder"
argument_list|)
block|;
return|return
name|Builder
operator|.
name|createGlobal
argument_list|(
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|,
name|std
operator|::
name|forward
operator|<
name|As
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
return|;
block|}
comment|/// Given that this builder was created by beginning an array or struct
comment|/// directly on a ConstantInitBuilder, finish the array/struct and
comment|/// set it as the initializer of the given global variable.
name|void
name|finishAndSetAsInitializer
argument_list|(
argument|llvm::GlobalVariable *global
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Parent
operator|&&
literal|"finishing non-root builder"
argument_list|)
block|;
return|return
name|Builder
operator|.
name|setGlobalInitializer
argument_list|(
name|global
argument_list|,
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|ConstantArrayBuilder
name|beginArray
argument_list|(
name|llvm
operator|::
name|Type
operator|*
name|eltTy
operator|=
name|nullptr
argument_list|)
block|;
name|ConstantStructBuilder
name|beginStruct
argument_list|(
name|llvm
operator|::
name|StructType
operator|*
name|structTy
operator|=
name|nullptr
argument_list|)
block|;
name|private
operator|:
name|llvm
operator|::
name|GlobalVariable
operator|*
name|createGlobal
argument_list|(
argument|llvm::Constant *initializer
argument_list|,
argument|const llvm::Twine&name
argument_list|,
argument|CharUnits alignment
argument_list|,
argument|bool constant = false
argument_list|,
argument|llvm::GlobalValue::LinkageTypes linkage                                        = llvm::GlobalValue::InternalLinkage
argument_list|,
argument|unsigned addressSpace =
literal|0
argument_list|)
block|{
name|auto
name|GV
operator|=
name|new
name|llvm
operator|::
name|GlobalVariable
argument_list|(
name|CGM
operator|.
name|getModule
argument_list|()
argument_list|,
name|initializer
operator|->
name|getType
argument_list|()
argument_list|,
name|constant
argument_list|,
name|linkage
argument_list|,
name|initializer
argument_list|,
name|name
argument_list|,
comment|/*insert before*/
name|nullptr
argument_list|,
name|llvm
operator|::
name|GlobalValue
operator|::
name|NotThreadLocal
argument_list|,
name|addressSpace
argument_list|)
block|;
name|GV
operator|->
name|setAlignment
argument_list|(
name|alignment
operator|.
name|getQuantity
argument_list|()
argument_list|)
block|;
name|resolveSelfReferences
argument_list|(
name|GV
argument_list|)
block|;
return|return
name|GV
return|;
block|}
name|void
name|setGlobalInitializer
argument_list|(
argument|llvm::GlobalVariable *GV
argument_list|,
argument|llvm::Constant *initializer
argument_list|)
block|{
name|GV
operator|->
name|setInitializer
argument_list|(
name|initializer
argument_list|)
block|;
name|resolveSelfReferences
argument_list|(
name|GV
argument_list|)
block|;   }
name|void
name|resolveSelfReferences
argument_list|(
argument|llvm::GlobalVariable *GV
argument_list|)
block|{
for|for
control|(
name|auto
operator|&
name|entry
operator|:
name|SelfReferences
control|)
block|{
name|llvm
operator|::
name|Constant
operator|*
name|resolvedReference
operator|=
name|llvm
operator|::
name|ConstantExpr
operator|::
name|getInBoundsGetElementPtr
argument_list|(
name|GV
operator|->
name|getValueType
argument_list|()
argument_list|,
name|GV
argument_list|,
name|entry
operator|.
name|Indices
argument_list|)
expr_stmt|;
name|entry
operator|.
name|Dummy
operator|->
name|replaceAllUsesWith
argument_list|(
name|resolvedReference
argument_list|)
expr_stmt|;
name|entry
operator|.
name|Dummy
operator|->
name|eraseFromParent
argument_list|()
expr_stmt|;
block|}
block|}
expr|}
block|;
comment|/// A helper class of ConstantInitBuilder, used for building constant
comment|/// array initializers.
name|class
name|ConstantArrayBuilder
operator|:
name|public
name|ConstantInitBuilder
operator|::
name|AggregateBuilder
operator|<
name|ConstantArrayBuilder
operator|>
block|{
name|llvm
operator|::
name|Type
operator|*
name|EltTy
block|;
name|friend
name|class
name|ConstantInitBuilder
block|;
name|template
operator|<
name|class
name|Impl
operator|>
name|friend
name|class
name|ConstantInitBuilder
operator|::
name|AggregateBuilder
block|;
name|ConstantArrayBuilder
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|Type
operator|*
name|eltTy
argument_list|)
operator|:
name|AggregateBuilder
argument_list|(
name|builder
argument_list|,
name|parent
argument_list|)
block|,
name|EltTy
argument_list|(
argument|eltTy
argument_list|)
block|{}
name|public
operator|:
name|size_t
name|size
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|Finished
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
argument_list|)
block|;
name|assert
argument_list|(
name|Begin
operator|<=
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|Begin
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
name|private
operator|:
comment|/// Form an array constant from the values that have been added to this
comment|/// builder.
name|llvm
operator|::
name|Constant
operator|*
name|finishImpl
argument_list|()
block|{
name|markFinished
argument_list|()
block|;
name|auto
operator|&
name|buffer
operator|=
name|getBuffer
argument_list|()
block|;
name|assert
argument_list|(
operator|(
name|Begin
operator|<
name|buffer
operator|.
name|size
argument_list|()
operator|||
operator|(
name|Begin
operator|==
name|buffer
operator|.
name|size
argument_list|()
operator|&&
name|EltTy
operator|)
operator|)
operator|&&
literal|"didn't add any array elements without element type"
argument_list|)
block|;
name|auto
name|elts
operator|=
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|buffer
argument_list|)
operator|.
name|slice
argument_list|(
name|Begin
argument_list|)
block|;
name|auto
name|eltTy
operator|=
name|EltTy
condition|?
name|EltTy
else|:
name|elts
index|[
literal|0
index|]
operator|->
name|getType
argument_list|()
block|;
name|auto
name|type
operator|=
name|llvm
operator|::
name|ArrayType
operator|::
name|get
argument_list|(
name|eltTy
argument_list|,
name|elts
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|auto
name|constant
operator|=
name|llvm
operator|::
name|ConstantArray
operator|::
name|get
argument_list|(
name|type
argument_list|,
name|elts
argument_list|)
block|;
name|buffer
operator|.
name|erase
argument_list|(
name|buffer
operator|.
name|begin
argument_list|()
operator|+
name|Begin
argument_list|,
name|buffer
operator|.
name|end
argument_list|()
argument_list|)
block|;
return|return
name|constant
return|;
block|}
expr|}
block|;
specifier|inline
name|ConstantArrayBuilder
name|ConstantInitBuilder
operator|::
name|beginArray
argument_list|(
argument|llvm::Type *eltTy
argument_list|)
block|{
return|return
name|ConstantArrayBuilder
argument_list|(
operator|*
name|this
argument_list|,
name|nullptr
argument_list|,
name|eltTy
argument_list|)
return|;
block|}
specifier|inline
name|ConstantArrayBuilder
name|ConstantInitBuilder
operator|::
name|AggregateBuilderBase
operator|::
name|beginArray
argument_list|(
argument|llvm::Type *eltTy
argument_list|)
block|{
return|return
name|ConstantArrayBuilder
argument_list|(
name|Builder
argument_list|,
name|this
argument_list|,
name|eltTy
argument_list|)
return|;
block|}
comment|/// A helper class of ConstantInitBuilder, used for building constant
comment|/// struct initializers.
name|class
name|ConstantStructBuilder
operator|:
name|public
name|ConstantInitBuilder
operator|::
name|AggregateBuilder
operator|<
name|ConstantStructBuilder
operator|>
block|{
name|llvm
operator|::
name|StructType
operator|*
name|Ty
block|;
name|friend
name|class
name|ConstantInitBuilder
block|;
name|template
operator|<
name|class
name|Impl
operator|>
name|friend
name|class
name|ConstantInitBuilder
operator|::
name|AggregateBuilder
block|;
name|ConstantStructBuilder
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|StructType
operator|*
name|ty
argument_list|)
operator|:
name|AggregateBuilder
argument_list|(
name|builder
argument_list|,
name|parent
argument_list|)
block|,
name|Ty
argument_list|(
argument|ty
argument_list|)
block|{}
comment|/// Finish the struct.
name|llvm
operator|::
name|Constant
operator|*
name|finishImpl
argument_list|()
block|{
name|markFinished
argument_list|()
block|;
name|auto
operator|&
name|buffer
operator|=
name|getBuffer
argument_list|()
block|;
name|assert
argument_list|(
name|Begin
operator|<
name|buffer
operator|.
name|size
argument_list|()
operator|&&
literal|"didn't add any struct elements?"
argument_list|)
block|;
name|auto
name|elts
operator|=
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|buffer
argument_list|)
operator|.
name|slice
argument_list|(
name|Begin
argument_list|)
block|;
name|llvm
operator|::
name|Constant
operator|*
name|constant
block|;
if|if
condition|(
name|Ty
condition|)
block|{
name|constant
operator|=
name|llvm
operator|::
name|ConstantStruct
operator|::
name|get
argument_list|(
name|Ty
argument_list|,
name|elts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constant
operator|=
name|llvm
operator|::
name|ConstantStruct
operator|::
name|getAnon
argument_list|(
name|elts
argument_list|,
comment|/*packed*/
name|false
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|erase
argument_list|(
name|buffer
operator|.
name|begin
argument_list|()
operator|+
name|Begin
argument_list|,
name|buffer
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|constant
return|;
block|}
expr|}
block|;
specifier|inline
name|ConstantStructBuilder
name|ConstantInitBuilder
operator|::
name|beginStruct
argument_list|(
argument|llvm::StructType *structTy
argument_list|)
block|{
return|return
name|ConstantStructBuilder
argument_list|(
operator|*
name|this
argument_list|,
name|nullptr
argument_list|,
name|structTy
argument_list|)
return|;
block|}
specifier|inline
name|ConstantStructBuilder
name|ConstantInitBuilder
operator|::
name|AggregateBuilderBase
operator|::
name|beginStruct
argument_list|(
argument|llvm::StructType *structTy
argument_list|)
block|{
return|return
name|ConstantStructBuilder
argument_list|(
name|Builder
argument_list|,
name|this
argument_list|,
name|structTy
argument_list|)
return|;
block|}
expr|}
comment|// end namespace CodeGen
expr|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

