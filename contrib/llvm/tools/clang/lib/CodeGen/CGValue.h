begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CGValue.h - LLVM CodeGen wrappers for llvm::Value* ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// These classes implement wrappers around llvm::Value in order to
end_comment

begin_comment
comment|// fully represent the range of values for C L- and R- values.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_CODEGEN_CGVALUE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_CODEGEN_CGVALUE_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Value.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Type.h"
end_include

begin_include
include|#
directive|include
file|"Address.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Constant
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|CodeGen
block|{
name|class
name|AggValueSlot
decl_stmt|;
struct_decl|struct
name|CGBitFieldInfo
struct_decl|;
comment|/// RValue - This trivial value class is used to represent the result of an
comment|/// expression that is evaluated.  It can be one of three things: either a
comment|/// simple LLVM SSA value, a pair of SSA values for complex numbers, or the
comment|/// address of an aggregate value in memory.
name|class
name|RValue
block|{
enum|enum
name|Flavor
block|{
name|Scalar
block|,
name|Complex
block|,
name|Aggregate
block|}
enum|;
comment|// The shift to make to an aggregate's alignment to make it look
comment|// like a pointer.
enum|enum
block|{
name|AggAlignShift
init|=
literal|4
block|}
enum|;
comment|// Stores first value and flavor.
name|llvm
operator|::
name|PointerIntPair
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|,
literal|2
operator|,
name|Flavor
operator|>
name|V1
expr_stmt|;
comment|// Stores second value and volatility.
name|llvm
operator|::
name|PointerIntPair
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|,
literal|1
operator|,
name|bool
operator|>
name|V2
expr_stmt|;
name|public
label|:
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|V1
operator|.
name|getInt
argument_list|()
operator|==
name|Scalar
return|;
block|}
name|bool
name|isComplex
argument_list|()
specifier|const
block|{
return|return
name|V1
operator|.
name|getInt
argument_list|()
operator|==
name|Complex
return|;
block|}
name|bool
name|isAggregate
argument_list|()
specifier|const
block|{
return|return
name|V1
operator|.
name|getInt
argument_list|()
operator|==
name|Aggregate
return|;
block|}
name|bool
name|isVolatileQualified
argument_list|()
specifier|const
block|{
return|return
name|V2
operator|.
name|getInt
argument_list|()
return|;
block|}
comment|/// getScalarVal() - Return the Value* of this scalar value.
name|llvm
operator|::
name|Value
operator|*
name|getScalarVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isScalar
argument_list|()
operator|&&
literal|"Not a scalar!"
argument_list|)
block|;
return|return
name|V1
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// getComplexVal - Return the real/imag components of this complex value.
comment|///
name|std
operator|::
name|pair
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|,
name|llvm
operator|::
name|Value
operator|*
operator|>
name|getComplexVal
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|V1
operator|.
name|getPointer
argument_list|()
argument_list|,
name|V2
operator|.
name|getPointer
argument_list|()
argument_list|)
return|;
block|}
comment|/// getAggregateAddr() - Return the Value* of the address of the aggregate.
name|Address
name|getAggregateAddress
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isAggregate
argument_list|()
operator|&&
literal|"Not an aggregate!"
argument_list|)
block|;
name|auto
name|align
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|V2
operator|.
name|getPointer
argument_list|()
operator|)
operator|>>
name|AggAlignShift
block|;
return|return
name|Address
argument_list|(
name|V1
operator|.
name|getPointer
argument_list|()
argument_list|,
name|CharUnits
operator|::
name|fromQuantity
argument_list|(
name|align
argument_list|)
argument_list|)
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getAggregatePointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isAggregate
argument_list|()
operator|&&
literal|"Not an aggregate!"
argument_list|)
block|;
return|return
name|V1
operator|.
name|getPointer
argument_list|()
return|;
block|}
specifier|static
name|RValue
name|getIgnored
parameter_list|()
block|{
comment|// FIXME: should we make this a more explicit state?
return|return
name|get
argument_list|(
name|nullptr
argument_list|)
return|;
block|}
specifier|static
name|RValue
name|get
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setPointer
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setInt
argument_list|(
name|Scalar
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V2
operator|.
name|setInt
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
name|ER
return|;
block|}
specifier|static
name|RValue
name|getComplex
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V1
argument_list|,
name|llvm
operator|::
name|Value
operator|*
name|V2
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setPointer
argument_list|(
name|V1
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V2
operator|.
name|setPointer
argument_list|(
name|V2
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setInt
argument_list|(
name|Complex
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V2
operator|.
name|setInt
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
name|ER
return|;
block|}
specifier|static
name|RValue
name|getComplex
argument_list|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|llvm
operator|::
name|Value
operator|*
argument_list|,
name|llvm
operator|::
name|Value
operator|*
operator|>
operator|&
name|C
argument_list|)
block|{
return|return
name|getComplex
argument_list|(
name|C
operator|.
name|first
argument_list|,
name|C
operator|.
name|second
argument_list|)
return|;
block|}
comment|// FIXME: Aggregate rvalues need to retain information about whether they are
comment|// volatile or not.  Remove default to find all places that probably get this
comment|// wrong.
specifier|static
name|RValue
name|getAggregate
parameter_list|(
name|Address
name|addr
parameter_list|,
name|bool
name|isVolatile
init|=
name|false
parameter_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setPointer
argument_list|(
name|addr
operator|.
name|getPointer
argument_list|()
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V1
operator|.
name|setInt
argument_list|(
name|Aggregate
argument_list|)
expr_stmt|;
name|auto
name|align
init|=
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|addr
operator|.
name|getAlignment
argument_list|()
operator|.
name|getQuantity
argument_list|()
operator|)
decl_stmt|;
name|ER
operator|.
name|V2
operator|.
name|setPointer
argument_list|(
name|reinterpret_cast
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|>
operator|(
name|align
operator|<<
name|AggAlignShift
operator|)
argument_list|)
expr_stmt|;
name|ER
operator|.
name|V2
operator|.
name|setInt
argument_list|(
name|isVolatile
argument_list|)
expr_stmt|;
return|return
name|ER
return|;
block|}
block|}
empty_stmt|;
comment|/// Does an ARC strong l-value have precise lifetime?
enum|enum
name|ARCPreciseLifetime_t
block|{
name|ARCImpreciseLifetime
block|,
name|ARCPreciseLifetime
block|}
enum|;
comment|/// The source of the alignment of an l-value; an expression of
comment|/// confidence in the alignment actually matching the estimate.
name|enum
name|class
name|AlignmentSource
block|{
comment|/// The l-value was an access to a declared entity or something
comment|/// equivalently strong, like the address of an array allocated by a
comment|/// language runtime.
name|Decl
operator|,
comment|/// The l-value was considered opaque, so the alignment was
comment|/// determined from a type, but that type was an explicitly-aligned
comment|/// typedef.
name|AttributedType
operator|,
comment|/// The l-value was considered opaque, so the alignment was
comment|/// determined from a type.
name|Type
block|}
empty_stmt|;
comment|/// Given that the base address has the given alignment source, what's
comment|/// our confidence in the alignment of the field?
specifier|static
specifier|inline
name|AlignmentSource
name|getFieldAlignmentSource
parameter_list|(
name|AlignmentSource
name|Source
parameter_list|)
block|{
comment|// For now, we don't distinguish fields of opaque pointers from
comment|// top-level declarations, but maybe we should.
return|return
name|AlignmentSource
operator|::
name|Decl
return|;
block|}
name|class
name|LValueBaseInfo
block|{
name|AlignmentSource
name|AlignSource
decl_stmt|;
name|bool
name|MayAlias
decl_stmt|;
name|public
label|:
name|explicit
name|LValueBaseInfo
argument_list|(
argument|AlignmentSource Source = AlignmentSource::Type
argument_list|,
argument|bool Alias = false
argument_list|)
block|:
name|AlignSource
argument_list|(
name|Source
argument_list|)
operator|,
name|MayAlias
argument_list|(
argument|Alias
argument_list|)
block|{}
name|AlignmentSource
name|getAlignmentSource
argument_list|()
specifier|const
block|{
return|return
name|AlignSource
return|;
block|}
name|void
name|setAlignmentSource
parameter_list|(
name|AlignmentSource
name|Source
parameter_list|)
block|{
name|AlignSource
operator|=
name|Source
expr_stmt|;
block|}
name|bool
name|getMayAlias
argument_list|()
specifier|const
block|{
return|return
name|MayAlias
return|;
block|}
name|void
name|setMayAlias
parameter_list|(
name|bool
name|Alias
parameter_list|)
block|{
name|MayAlias
operator|=
name|Alias
expr_stmt|;
block|}
name|void
name|mergeForCast
parameter_list|(
specifier|const
name|LValueBaseInfo
modifier|&
name|Info
parameter_list|)
block|{
name|setAlignmentSource
argument_list|(
name|Info
operator|.
name|getAlignmentSource
argument_list|()
argument_list|)
expr_stmt|;
name|setMayAlias
argument_list|(
name|getMayAlias
argument_list|()
operator|||
name|Info
operator|.
name|getMayAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// LValue - This represents an lvalue references.  Because C/C++ allow
comment|/// bitfields, this is not a simple LLVM pointer, it may be a pointer plus a
comment|/// bitrange.
name|class
name|LValue
block|{
enum|enum
block|{
name|Simple
block|,
comment|// This is a normal l-value, use getAddress().
name|VectorElt
block|,
comment|// This is a vector element l-value (V[i]), use getVector*
name|BitField
block|,
comment|// This is a bitfield l-value, use getBitfield*.
name|ExtVectorElt
block|,
comment|// This is an extended vector subset, use getExtVectorComp
name|GlobalReg
comment|// This is a register l-value, use getGlobalReg()
block|}
name|LVType
enum|;
name|llvm
operator|::
name|Value
operator|*
name|V
expr_stmt|;
union|union
block|{
comment|// Index into a vector subscript: V[i]
name|llvm
operator|::
name|Value
operator|*
name|VectorIdx
expr_stmt|;
comment|// ExtVector element subset: V.xyx
name|llvm
operator|::
name|Constant
operator|*
name|VectorElts
expr_stmt|;
comment|// BitField start bit and size
specifier|const
name|CGBitFieldInfo
modifier|*
name|BitFieldInfo
decl_stmt|;
block|}
union|;
name|QualType
name|Type
decl_stmt|;
comment|// 'const' is unused here
name|Qualifiers
name|Quals
decl_stmt|;
comment|// The alignment to use when accessing this lvalue.  (For vector elements,
comment|// this is the alignment of the whole vector.)
name|int64_t
name|Alignment
decl_stmt|;
comment|// objective-c's ivar
name|bool
name|Ivar
range|:
literal|1
decl_stmt|;
comment|// objective-c's ivar is an array
name|bool
name|ObjIsArray
range|:
literal|1
decl_stmt|;
comment|// LValue is non-gc'able for any reason, including being a parameter or local
comment|// variable.
name|bool
name|NonGC
range|:
literal|1
decl_stmt|;
comment|// Lvalue is a global reference of an objective-c object
name|bool
name|GlobalObjCRef
range|:
literal|1
decl_stmt|;
comment|// Lvalue is a thread local reference
name|bool
name|ThreadLocalRef
range|:
literal|1
decl_stmt|;
comment|// Lvalue has ARC imprecise lifetime.  We store this inverted to try
comment|// to make the default bitfield pattern all-zeroes.
name|bool
name|ImpreciseLifetime
range|:
literal|1
decl_stmt|;
name|LValueBaseInfo
name|BaseInfo
decl_stmt|;
comment|// This flag shows if a nontemporal load/stores should be used when accessing
comment|// this lvalue.
name|bool
name|Nontemporal
range|:
literal|1
decl_stmt|;
name|Expr
modifier|*
name|BaseIvarExp
decl_stmt|;
comment|/// Used by struct-path-aware TBAA.
name|QualType
name|TBAABaseType
decl_stmt|;
comment|/// Offset relative to the base type.
name|uint64_t
name|TBAAOffset
decl_stmt|;
comment|/// TBAAInfo - TBAA information to attach to dereferences of this LValue.
name|llvm
operator|::
name|MDNode
operator|*
name|TBAAInfo
expr_stmt|;
name|private
label|:
name|void
name|Initialize
argument_list|(
name|QualType
name|Type
argument_list|,
name|Qualifiers
name|Quals
argument_list|,
name|CharUnits
name|Alignment
argument_list|,
name|LValueBaseInfo
name|BaseInfo
argument_list|,
name|llvm
operator|::
name|MDNode
operator|*
name|TBAAInfo
operator|=
name|nullptr
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|Alignment
operator|.
name|isZero
argument_list|()
operator|||
name|Type
operator|->
name|isIncompleteType
argument_list|()
operator|)
operator|&&
literal|"initializing l-value with zero alignment!"
argument_list|)
expr_stmt|;
name|this
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|this
operator|->
name|Quals
operator|=
name|Quals
expr_stmt|;
name|this
operator|->
name|Alignment
operator|=
name|Alignment
operator|.
name|getQuantity
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|this
operator|->
name|Alignment
operator|==
name|Alignment
operator|.
name|getQuantity
argument_list|()
operator|&&
literal|"Alignment exceeds allowed max!"
argument_list|)
expr_stmt|;
name|this
operator|->
name|BaseInfo
operator|=
name|BaseInfo
expr_stmt|;
comment|// Initialize Objective-C flags.
name|this
operator|->
name|Ivar
operator|=
name|this
operator|->
name|ObjIsArray
operator|=
name|this
operator|->
name|NonGC
operator|=
name|this
operator|->
name|GlobalObjCRef
operator|=
name|false
expr_stmt|;
name|this
operator|->
name|ImpreciseLifetime
operator|=
name|false
expr_stmt|;
name|this
operator|->
name|Nontemporal
operator|=
name|false
expr_stmt|;
name|this
operator|->
name|ThreadLocalRef
operator|=
name|false
expr_stmt|;
name|this
operator|->
name|BaseIvarExp
operator|=
name|nullptr
expr_stmt|;
comment|// Initialize fields for TBAA.
name|this
operator|->
name|TBAABaseType
operator|=
name|Type
expr_stmt|;
name|this
operator|->
name|TBAAOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|TBAAInfo
operator|=
name|TBAAInfo
expr_stmt|;
block|}
name|public
label|:
name|bool
name|isSimple
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|Simple
return|;
block|}
name|bool
name|isVectorElt
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|VectorElt
return|;
block|}
name|bool
name|isBitField
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|BitField
return|;
block|}
name|bool
name|isExtVectorElt
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|ExtVectorElt
return|;
block|}
name|bool
name|isGlobalReg
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|GlobalReg
return|;
block|}
name|bool
name|isVolatileQualified
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasVolatile
argument_list|()
return|;
block|}
name|bool
name|isRestrictQualified
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasRestrict
argument_list|()
return|;
block|}
name|unsigned
name|getVRQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getCVRQualifiers
argument_list|()
operator|&
operator|~
name|Qualifiers
operator|::
name|Const
return|;
block|}
name|QualType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
name|Qualifiers
operator|::
name|ObjCLifetime
name|getObjCLifetime
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getObjCLifetime
argument_list|()
return|;
block|}
name|bool
name|isObjCIvar
argument_list|()
specifier|const
block|{
return|return
name|Ivar
return|;
block|}
name|void
name|setObjCIvar
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|Ivar
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isObjCArray
argument_list|()
specifier|const
block|{
return|return
name|ObjIsArray
return|;
block|}
name|void
name|setObjCArray
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|ObjIsArray
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isNonGC
argument_list|()
specifier|const
block|{
return|return
name|NonGC
return|;
block|}
name|void
name|setNonGC
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|NonGC
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isGlobalObjCRef
argument_list|()
specifier|const
block|{
return|return
name|GlobalObjCRef
return|;
block|}
name|void
name|setGlobalObjCRef
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|GlobalObjCRef
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isThreadLocalRef
argument_list|()
specifier|const
block|{
return|return
name|ThreadLocalRef
return|;
block|}
name|void
name|setThreadLocalRef
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|ThreadLocalRef
operator|=
name|Value
expr_stmt|;
block|}
name|ARCPreciseLifetime_t
name|isARCPreciseLifetime
argument_list|()
specifier|const
block|{
return|return
name|ARCPreciseLifetime_t
argument_list|(
operator|!
name|ImpreciseLifetime
argument_list|)
return|;
block|}
name|void
name|setARCPreciseLifetime
parameter_list|(
name|ARCPreciseLifetime_t
name|value
parameter_list|)
block|{
name|ImpreciseLifetime
operator|=
operator|(
name|value
operator|==
name|ARCImpreciseLifetime
operator|)
expr_stmt|;
block|}
name|bool
name|isNontemporal
argument_list|()
specifier|const
block|{
return|return
name|Nontemporal
return|;
block|}
name|void
name|setNontemporal
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|Nontemporal
operator|=
name|Value
expr_stmt|;
block|}
name|bool
name|isObjCWeak
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getObjCGCAttr
argument_list|()
operator|==
name|Qualifiers
operator|::
name|Weak
return|;
block|}
name|bool
name|isObjCStrong
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getObjCGCAttr
argument_list|()
operator|==
name|Qualifiers
operator|::
name|Strong
return|;
block|}
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasVolatile
argument_list|()
return|;
block|}
name|Expr
operator|*
name|getBaseIvarExp
argument_list|()
specifier|const
block|{
return|return
name|BaseIvarExp
return|;
block|}
name|void
name|setBaseIvarExp
parameter_list|(
name|Expr
modifier|*
name|V
parameter_list|)
block|{
name|BaseIvarExp
operator|=
name|V
expr_stmt|;
block|}
name|QualType
name|getTBAABaseType
argument_list|()
specifier|const
block|{
return|return
name|TBAABaseType
return|;
block|}
name|void
name|setTBAABaseType
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
name|TBAABaseType
operator|=
name|T
expr_stmt|;
block|}
name|uint64_t
name|getTBAAOffset
argument_list|()
specifier|const
block|{
return|return
name|TBAAOffset
return|;
block|}
name|void
name|setTBAAOffset
parameter_list|(
name|uint64_t
name|O
parameter_list|)
block|{
name|TBAAOffset
operator|=
name|O
expr_stmt|;
block|}
name|llvm
operator|::
name|MDNode
operator|*
name|getTBAAInfo
argument_list|()
specifier|const
block|{
return|return
name|TBAAInfo
return|;
block|}
name|void
name|setTBAAInfo
argument_list|(
name|llvm
operator|::
name|MDNode
operator|*
name|N
argument_list|)
block|{
name|TBAAInfo
operator|=
name|N
expr_stmt|;
block|}
specifier|const
name|Qualifiers
operator|&
name|getQuals
argument_list|()
specifier|const
block|{
return|return
name|Quals
return|;
block|}
name|Qualifiers
modifier|&
name|getQuals
parameter_list|()
block|{
return|return
name|Quals
return|;
block|}
name|unsigned
name|getAddressSpace
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getAddressSpace
argument_list|()
return|;
block|}
name|CharUnits
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|CharUnits
operator|::
name|fromQuantity
argument_list|(
name|Alignment
argument_list|)
return|;
block|}
name|void
name|setAlignment
parameter_list|(
name|CharUnits
name|A
parameter_list|)
block|{
name|Alignment
operator|=
name|A
operator|.
name|getQuantity
argument_list|()
expr_stmt|;
block|}
name|LValueBaseInfo
name|getBaseInfo
argument_list|()
specifier|const
block|{
return|return
name|BaseInfo
return|;
block|}
name|void
name|setBaseInfo
parameter_list|(
name|LValueBaseInfo
name|Info
parameter_list|)
block|{
name|BaseInfo
operator|=
name|Info
expr_stmt|;
block|}
comment|// simple lvalue
name|llvm
operator|::
name|Value
operator|*
name|getPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isSimple
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|Address
name|getAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
argument_list|(
name|getPointer
argument_list|()
argument_list|,
name|getAlignment
argument_list|()
argument_list|)
return|;
block|}
name|void
name|setAddress
parameter_list|(
name|Address
name|address
parameter_list|)
block|{
name|assert
argument_list|(
name|isSimple
argument_list|()
argument_list|)
expr_stmt|;
name|V
operator|=
name|address
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|Alignment
operator|=
name|address
operator|.
name|getAlignment
argument_list|()
operator|.
name|getQuantity
argument_list|()
expr_stmt|;
block|}
comment|// vector elt lvalue
name|Address
name|getVectorAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
argument_list|(
name|getVectorPointer
argument_list|()
argument_list|,
name|getAlignment
argument_list|()
argument_list|)
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getVectorPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getVectorIdx
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|VectorIdx
return|;
block|}
comment|// extended vector elements.
name|Address
name|getExtVectorAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
argument_list|(
name|getExtVectorPointer
argument_list|()
argument_list|,
name|getAlignment
argument_list|()
argument_list|)
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getExtVectorPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExtVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|llvm
operator|::
name|Constant
operator|*
name|getExtVectorElts
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExtVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|VectorElts
return|;
block|}
comment|// bitfield lvalue
name|Address
name|getBitFieldAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
argument_list|(
name|getBitFieldPointer
argument_list|()
argument_list|,
name|getAlignment
argument_list|()
argument_list|)
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getBitFieldPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitField
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
specifier|const
name|CGBitFieldInfo
operator|&
name|getBitFieldInfo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitField
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|BitFieldInfo
return|;
block|}
comment|// global register lvalue
name|llvm
operator|::
name|Value
operator|*
name|getGlobalReg
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isGlobalReg
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
specifier|static
name|LValue
name|MakeAddr
argument_list|(
name|Address
name|address
argument_list|,
name|QualType
name|type
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|LValueBaseInfo
name|BaseInfo
argument_list|,
name|llvm
operator|::
name|MDNode
operator|*
name|TBAAInfo
operator|=
name|nullptr
argument_list|)
block|{
name|Qualifiers
name|qs
init|=
name|type
operator|.
name|getQualifiers
argument_list|()
decl_stmt|;
name|qs
operator|.
name|setObjCGCAttr
argument_list|(
name|Context
operator|.
name|getObjCGCAttrKind
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|Simple
expr_stmt|;
name|assert
argument_list|(
name|address
operator|.
name|getPointer
argument_list|()
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
argument_list|)
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|address
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|R
operator|.
name|Initialize
argument_list|(
name|type
argument_list|,
name|qs
argument_list|,
name|address
operator|.
name|getAlignment
argument_list|()
argument_list|,
name|BaseInfo
argument_list|,
name|TBAAInfo
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeVectorElt
argument_list|(
name|Address
name|vecAddress
argument_list|,
name|llvm
operator|::
name|Value
operator|*
name|Idx
argument_list|,
name|QualType
name|type
argument_list|,
name|LValueBaseInfo
name|BaseInfo
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|VectorElt
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|vecAddress
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|R
operator|.
name|VectorIdx
operator|=
name|Idx
expr_stmt|;
name|R
operator|.
name|Initialize
argument_list|(
name|type
argument_list|,
name|type
operator|.
name|getQualifiers
argument_list|()
argument_list|,
name|vecAddress
operator|.
name|getAlignment
argument_list|()
argument_list|,
name|BaseInfo
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeExtVectorElt
argument_list|(
name|Address
name|vecAddress
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|Elts
argument_list|,
name|QualType
name|type
argument_list|,
name|LValueBaseInfo
name|BaseInfo
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|ExtVectorElt
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|vecAddress
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|R
operator|.
name|VectorElts
operator|=
name|Elts
expr_stmt|;
name|R
operator|.
name|Initialize
argument_list|(
name|type
argument_list|,
name|type
operator|.
name|getQualifiers
argument_list|()
argument_list|,
name|vecAddress
operator|.
name|getAlignment
argument_list|()
argument_list|,
name|BaseInfo
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
comment|/// \brief Create a new object to represent a bit-field access.
comment|///
comment|/// \param Addr - The base address of the bit-field sequence this
comment|/// bit-field refers to.
comment|/// \param Info - The information describing how to perform the bit-field
comment|/// access.
specifier|static
name|LValue
name|MakeBitfield
parameter_list|(
name|Address
name|Addr
parameter_list|,
specifier|const
name|CGBitFieldInfo
modifier|&
name|Info
parameter_list|,
name|QualType
name|type
parameter_list|,
name|LValueBaseInfo
name|BaseInfo
parameter_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|BitField
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|Addr
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|R
operator|.
name|BitFieldInfo
operator|=
operator|&
name|Info
expr_stmt|;
name|R
operator|.
name|Initialize
argument_list|(
name|type
argument_list|,
name|type
operator|.
name|getQualifiers
argument_list|()
argument_list|,
name|Addr
operator|.
name|getAlignment
argument_list|()
argument_list|,
name|BaseInfo
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeGlobalReg
parameter_list|(
name|Address
name|Reg
parameter_list|,
name|QualType
name|type
parameter_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|GlobalReg
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|Reg
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|R
operator|.
name|Initialize
argument_list|(
name|type
argument_list|,
name|type
operator|.
name|getQualifiers
argument_list|()
argument_list|,
name|Reg
operator|.
name|getAlignment
argument_list|()
argument_list|,
name|LValueBaseInfo
argument_list|(
name|AlignmentSource
operator|::
name|Decl
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
name|RValue
name|asAggregateRValue
argument_list|()
specifier|const
block|{
return|return
name|RValue
operator|::
name|getAggregate
argument_list|(
name|getAddress
argument_list|()
argument_list|,
name|isVolatileQualified
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// An aggregate value slot.
name|class
name|AggValueSlot
block|{
comment|/// The address.
name|llvm
operator|::
name|Value
operator|*
name|Addr
expr_stmt|;
comment|// Qualifiers
name|Qualifiers
name|Quals
decl_stmt|;
name|unsigned
name|Alignment
decl_stmt|;
comment|/// DestructedFlag - This is set to true if some external code is
comment|/// responsible for setting up a destructor for the slot.  Otherwise
comment|/// the code which constructs it should push the appropriate cleanup.
name|bool
name|DestructedFlag
range|:
literal|1
decl_stmt|;
comment|/// ObjCGCFlag - This is set to true if writing to the memory in the
comment|/// slot might require calling an appropriate Objective-C GC
comment|/// barrier.  The exact interaction here is unnecessarily mysterious.
name|bool
name|ObjCGCFlag
range|:
literal|1
decl_stmt|;
comment|/// ZeroedFlag - This is set to true if the memory in the slot is
comment|/// known to be zero before the assignment into it.  This means that
comment|/// zero fields don't need to be set.
name|bool
name|ZeroedFlag
range|:
literal|1
decl_stmt|;
comment|/// AliasedFlag - This is set to true if the slot might be aliased
comment|/// and it's not undefined behavior to access it through such an
comment|/// alias.  Note that it's always undefined behavior to access a C++
comment|/// object that's under construction through an alias derived from
comment|/// outside the construction process.
comment|///
comment|/// This flag controls whether calls that produce the aggregate
comment|/// value may be evaluated directly into the slot, or whether they
comment|/// must be evaluated into an unaliased temporary and then memcpy'ed
comment|/// over.  Since it's invalid in general to memcpy a non-POD C++
comment|/// object, it's important that this flag never be set when
comment|/// evaluating an expression which constructs such an object.
name|bool
name|AliasedFlag
range|:
literal|1
decl_stmt|;
name|public
label|:
enum|enum
name|IsAliased_t
block|{
name|IsNotAliased
block|,
name|IsAliased
block|}
enum|;
enum|enum
name|IsDestructed_t
block|{
name|IsNotDestructed
block|,
name|IsDestructed
block|}
enum|;
enum|enum
name|IsZeroed_t
block|{
name|IsNotZeroed
block|,
name|IsZeroed
block|}
enum|;
enum|enum
name|NeedsGCBarriers_t
block|{
name|DoesNotNeedGCBarriers
block|,
name|NeedsGCBarriers
block|}
enum|;
comment|/// ignored - Returns an aggregate value slot indicating that the
comment|/// aggregate value is being ignored.
specifier|static
name|AggValueSlot
name|ignored
parameter_list|()
block|{
return|return
name|forAddr
argument_list|(
name|Address
operator|::
name|invalid
argument_list|()
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|IsNotDestructed
argument_list|,
name|DoesNotNeedGCBarriers
argument_list|,
name|IsNotAliased
argument_list|)
return|;
block|}
comment|/// forAddr - Make a slot for an aggregate value.
comment|///
comment|/// \param quals - The qualifiers that dictate how the slot should
comment|/// be initialied. Only 'volatile' and the Objective-C lifetime
comment|/// qualifiers matter.
comment|///
comment|/// \param isDestructed - true if something else is responsible
comment|///   for calling destructors on this object
comment|/// \param needsGC - true if the slot is potentially located
comment|///   somewhere that ObjC GC calls should be emitted for
specifier|static
name|AggValueSlot
name|forAddr
parameter_list|(
name|Address
name|addr
parameter_list|,
name|Qualifiers
name|quals
parameter_list|,
name|IsDestructed_t
name|isDestructed
parameter_list|,
name|NeedsGCBarriers_t
name|needsGC
parameter_list|,
name|IsAliased_t
name|isAliased
parameter_list|,
name|IsZeroed_t
name|isZeroed
init|=
name|IsNotZeroed
parameter_list|)
block|{
name|AggValueSlot
name|AV
decl_stmt|;
if|if
condition|(
name|addr
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|AV
operator|.
name|Addr
operator|=
name|addr
operator|.
name|getPointer
argument_list|()
expr_stmt|;
name|AV
operator|.
name|Alignment
operator|=
name|addr
operator|.
name|getAlignment
argument_list|()
operator|.
name|getQuantity
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|AV
operator|.
name|Addr
operator|=
name|nullptr
expr_stmt|;
name|AV
operator|.
name|Alignment
operator|=
literal|0
expr_stmt|;
block|}
name|AV
operator|.
name|Quals
operator|=
name|quals
expr_stmt|;
name|AV
operator|.
name|DestructedFlag
operator|=
name|isDestructed
expr_stmt|;
name|AV
operator|.
name|ObjCGCFlag
operator|=
name|needsGC
expr_stmt|;
name|AV
operator|.
name|ZeroedFlag
operator|=
name|isZeroed
expr_stmt|;
name|AV
operator|.
name|AliasedFlag
operator|=
name|isAliased
expr_stmt|;
return|return
name|AV
return|;
block|}
specifier|static
name|AggValueSlot
name|forLValue
parameter_list|(
specifier|const
name|LValue
modifier|&
name|LV
parameter_list|,
name|IsDestructed_t
name|isDestructed
parameter_list|,
name|NeedsGCBarriers_t
name|needsGC
parameter_list|,
name|IsAliased_t
name|isAliased
parameter_list|,
name|IsZeroed_t
name|isZeroed
init|=
name|IsNotZeroed
parameter_list|)
block|{
return|return
name|forAddr
argument_list|(
name|LV
operator|.
name|getAddress
argument_list|()
argument_list|,
name|LV
operator|.
name|getQuals
argument_list|()
argument_list|,
name|isDestructed
argument_list|,
name|needsGC
argument_list|,
name|isAliased
argument_list|,
name|isZeroed
argument_list|)
return|;
block|}
name|IsDestructed_t
name|isExternallyDestructed
argument_list|()
specifier|const
block|{
return|return
name|IsDestructed_t
argument_list|(
name|DestructedFlag
argument_list|)
return|;
block|}
name|void
name|setExternallyDestructed
parameter_list|(
name|bool
name|destructed
init|=
name|true
parameter_list|)
block|{
name|DestructedFlag
operator|=
name|destructed
expr_stmt|;
block|}
name|Qualifiers
name|getQualifiers
argument_list|()
specifier|const
block|{
return|return
name|Quals
return|;
block|}
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|hasVolatile
argument_list|()
return|;
block|}
name|void
name|setVolatile
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|Quals
operator|.
name|setVolatile
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
name|Qualifiers
operator|::
name|ObjCLifetime
name|getObjCLifetime
argument_list|()
specifier|const
block|{
return|return
name|Quals
operator|.
name|getObjCLifetime
argument_list|()
return|;
block|}
name|NeedsGCBarriers_t
name|requiresGCollection
argument_list|()
specifier|const
block|{
return|return
name|NeedsGCBarriers_t
argument_list|(
name|ObjCGCFlag
argument_list|)
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getPointer
argument_list|()
specifier|const
block|{
return|return
name|Addr
return|;
block|}
name|Address
name|getAddress
argument_list|()
specifier|const
block|{
return|return
name|Address
argument_list|(
name|Addr
argument_list|,
name|getAlignment
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isIgnored
argument_list|()
specifier|const
block|{
return|return
name|Addr
operator|==
name|nullptr
return|;
block|}
name|CharUnits
name|getAlignment
argument_list|()
specifier|const
block|{
return|return
name|CharUnits
operator|::
name|fromQuantity
argument_list|(
name|Alignment
argument_list|)
return|;
block|}
name|IsAliased_t
name|isPotentiallyAliased
argument_list|()
specifier|const
block|{
return|return
name|IsAliased_t
argument_list|(
name|AliasedFlag
argument_list|)
return|;
block|}
name|RValue
name|asRValue
argument_list|()
specifier|const
block|{
if|if
condition|(
name|isIgnored
argument_list|()
condition|)
block|{
return|return
name|RValue
operator|::
name|getIgnored
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|RValue
operator|::
name|getAggregate
argument_list|(
name|getAddress
argument_list|()
argument_list|,
name|isVolatile
argument_list|()
argument_list|)
return|;
block|}
block|}
name|void
name|setZeroed
argument_list|(
argument|bool V = true
argument_list|)
block|{
name|ZeroedFlag
operator|=
name|V
block|; }
name|IsZeroed_t
name|isZeroed
argument_list|()
specifier|const
block|{
return|return
name|IsZeroed_t
argument_list|(
name|ZeroedFlag
argument_list|)
return|;
block|}
block|}
empty_stmt|;
block|}
comment|// end namespace CodeGen
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

