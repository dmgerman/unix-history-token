begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Marshallers.h - Generic matcher function marshallers -*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Functions templates and classes to wrap matcher construct functions.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// A collection of template function and classes that provide a generic
end_comment

begin_comment
comment|/// marshalling layer on top of matcher construct functions.
end_comment

begin_comment
comment|/// These are used by the registry to export all marshaller constructors with
end_comment

begin_comment
comment|/// the same generic interface.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_ASTMATCHERS_DYNAMIC_MARSHALLERS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_ASTMATCHERS_DYNAMIC_MARSHALLERS_H
end_define

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchers.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/Dynamic/Diagnostics.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/Dynamic/VariantValue.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|ast_matchers
block|{
name|namespace
name|dynamic
block|{
name|namespace
name|internal
block|{
comment|/// \brief Helper template class to just from argument type to the right is/get
comment|///   functions in VariantValue.
comment|/// Used to verify and extract the matcher arguments below.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
operator|<
specifier|const
name|T
operator|&
operator|>
operator|:
name|public
name|ArgTypeTraits
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|std
operator|::
name|string
operator|>
block|{
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isString
argument_list|()
return|;
block|}
specifier|static
specifier|const
name|std
operator|::
name|string
operator|&
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getString
argument_list|()
return|;
block|}
specifier|static
name|ArgKind
name|getKind
argument_list|()
block|{
return|return
name|ArgKind
argument_list|(
name|ArgKind
operator|::
name|AK_String
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|StringRef
operator|>
operator|:
name|public
name|ArgTypeTraits
operator|<
name|std
operator|::
name|string
operator|>
block|{ }
block|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|ast_matchers
operator|::
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isMatcher
argument_list|()
operator|&&
name|Value
operator|.
name|getMatcher
argument_list|()
operator|.
name|hasTypedMatcher
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
specifier|static
name|ast_matchers
operator|::
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getMatcher
argument_list|()
operator|.
name|getTypedMatcher
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
specifier|static
name|ArgKind
name|getKind
argument_list|()
block|{
return|return
name|ArgKind
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|unsigned
operator|>
block|{
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isUnsigned
argument_list|()
return|;
block|}
specifier|static
name|unsigned
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|getUnsigned
argument_list|()
return|;
block|}
specifier|static
name|ArgKind
name|getKind
argument_list|()
block|{
return|return
name|ArgKind
argument_list|(
name|ArgKind
operator|::
name|AK_Unsigned
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
operator|>
expr|struct
name|ArgTypeTraits
operator|<
name|attr
operator|::
name|Kind
operator|>
block|{
name|private
operator|:
specifier|static
name|attr
operator|::
name|Kind
name|getAttrKind
argument_list|(
argument|llvm::StringRef AttrKind
argument_list|)
block|{
return|return
name|llvm
operator|::
name|StringSwitch
operator|<
name|attr
operator|::
name|Kind
operator|>
operator|(
name|AttrKind
operator|)
define|#
directive|define
name|ATTR
parameter_list|(
name|X
parameter_list|)
value|.Case("attr::" #X, attr:: X)
include|#
directive|include
file|"clang/Basic/AttrList.inc"
operator|.
name|Default
argument_list|(
name|attr
operator|::
name|Kind
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|public
operator|:
specifier|static
name|bool
name|is
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|Value
operator|.
name|isString
argument_list|()
operator|&&
name|getAttrKind
argument_list|(
name|Value
operator|.
name|getString
argument_list|()
argument_list|)
operator|!=
name|attr
operator|::
name|Kind
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|static
name|attr
operator|::
name|Kind
name|get
argument_list|(
argument|const VariantValue&Value
argument_list|)
block|{
return|return
name|getAttrKind
argument_list|(
name|Value
operator|.
name|getString
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|ArgKind
name|getKind
argument_list|()
block|{
return|return
name|ArgKind
argument_list|(
name|ArgKind
operator|::
name|AK_String
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief Matcher descriptor interface.
comment|///
comment|/// Provides a \c create() method that constructs the matcher from the provided
comment|/// arguments, and various other methods for type introspection.
name|class
name|MatcherDescriptor
block|{
name|public
operator|:
name|virtual
operator|~
name|MatcherDescriptor
argument_list|()
block|{}
name|virtual
name|VariantMatcher
name|create
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|/// Returns whether the matcher is variadic. Variadic matchers can take any
comment|/// number of arguments, but they must be of the same type.
name|virtual
name|bool
name|isVariadic
argument_list|()
specifier|const
operator|=
literal|0
block|;
comment|/// Returns the number of arguments accepted by the matcher if not variadic.
name|virtual
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
operator|=
literal|0
block|;
comment|/// Given that the matcher is being converted to type \p ThisKind, append the
comment|/// set of argument types accepted for argument \p ArgNo to \p ArgKinds.
comment|// FIXME: We should provide the ability to constrain the output of this
comment|// function based on the types of other matcher arguments.
name|virtual
name|void
name|getArgKinds
argument_list|(
argument|ast_type_traits::ASTNodeKind ThisKind
argument_list|,
argument|unsigned ArgNo
argument_list|,
argument|std::vector<ArgKind>&ArgKinds
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|/// Returns whether this matcher is convertible to the given type.  If it is
comment|/// so convertible, store in *Specificity a value corresponding to the
comment|/// "specificity" of the converted matcher to the given context, and in
comment|/// *LeastDerivedKind the least derived matcher kind which would result in the
comment|/// same matcher overload.  Zero specificity indicates that this conversion
comment|/// would produce a trivial matcher that will either always or never match.
comment|/// Such matchers are excluded from code completion results.
name|virtual
name|bool
name|isConvertibleTo
argument_list|(
argument|ast_type_traits::ASTNodeKind Kind
argument_list|,
argument|unsigned *Specificity = nullptr
argument_list|,
argument|ast_type_traits::ASTNodeKind *LeastDerivedKind = nullptr
argument_list|)
specifier|const
operator|=
literal|0
block|;
comment|/// Returns whether the matcher will, given a matcher of any type T, yield a
comment|/// matcher of type T.
name|virtual
name|bool
name|isPolymorphic
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
expr|}
block|;
specifier|inline
name|bool
name|isRetKindConvertibleTo
argument_list|(
argument|ArrayRef<ast_type_traits::ASTNodeKind> RetKinds
argument_list|,
argument|ast_type_traits::ASTNodeKind Kind
argument_list|,
argument|unsigned *Specificity
argument_list|,
argument|ast_type_traits::ASTNodeKind *LeastDerivedKind
argument_list|)
block|{
for|for
control|(
specifier|const
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|&
name|NodeKind
operator|:
name|RetKinds
control|)
block|{
if|if
condition|(
name|ArgKind
argument_list|(
name|NodeKind
argument_list|)
operator|.
name|isConvertibleTo
argument_list|(
name|Kind
argument_list|,
name|Specificity
argument_list|)
condition|)
block|{
if|if
condition|(
name|LeastDerivedKind
condition|)
operator|*
name|LeastDerivedKind
operator|=
name|NodeKind
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Simple callback implementation. Marshaller and function are provided.
comment|///
comment|/// This class wraps a function of arbitrary signature and a marshaller
comment|/// function into a MatcherDescriptor.
comment|/// The marshaller is in charge of taking the VariantValue arguments, checking
comment|/// their types, unpacking them and calling the underlying function.
name|class
name|FixedArgCountMatcherDescriptor
operator|:
name|public
name|MatcherDescriptor
block|{
name|public
operator|:
typedef|typedef
name|VariantMatcher
argument_list|(
argument|*MarshallerType
argument_list|)
operator|(
name|void
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|()
operator|,
name|StringRef
name|MatcherName
operator|,
specifier|const
name|SourceRange
operator|&
name|NameRange
operator|,
name|ArrayRef
operator|<
name|ParserValue
operator|>
name|Args
operator|,
name|Diagnostics
operator|*
name|Error
operator|)
expr_stmt|;
comment|/// \param Marshaller Function to unpack the arguments and call \c Func
comment|/// \param Func Matcher construct function. This is the function that
comment|///   compile-time matcher expressions would use to create the matcher.
comment|/// \param RetKinds The list of matcher types to which the matcher is
comment|///   convertible.
comment|/// \param ArgKinds The types of the arguments this matcher takes.
name|FixedArgCountMatcherDescriptor
argument_list|(
argument|MarshallerType Marshaller
argument_list|,
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|ArrayRef<ast_type_traits::ASTNodeKind> RetKinds
argument_list|,
argument|ArrayRef<ArgKind> ArgKinds
argument_list|)
operator|:
name|Marshaller
argument_list|(
name|Marshaller
argument_list|)
operator|,
name|Func
argument_list|(
name|Func
argument_list|)
operator|,
name|MatcherName
argument_list|(
name|MatcherName
argument_list|)
operator|,
name|RetKinds
argument_list|(
name|RetKinds
operator|.
name|begin
argument_list|()
argument_list|,
name|RetKinds
operator|.
name|end
argument_list|()
argument_list|)
operator|,
name|ArgKinds
argument_list|(
argument|ArgKinds.begin()
argument_list|,
argument|ArgKinds.end()
argument_list|)
block|{}
name|VariantMatcher
name|create
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
name|override
block|{
return|return
name|Marshaller
argument_list|(
name|Func
argument_list|,
name|MatcherName
argument_list|,
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
return|;
block|}
name|bool
name|isVariadic
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArgKinds
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|getArgKinds
argument_list|(
argument|ast_type_traits::ASTNodeKind ThisKind
argument_list|,
argument|unsigned ArgNo
argument_list|,
argument|std::vector<ArgKind>&Kinds
argument_list|)
specifier|const
name|override
block|{
name|Kinds
operator|.
name|push_back
argument_list|(
name|ArgKinds
index|[
name|ArgNo
index|]
argument_list|)
block|;   }
name|bool
name|isConvertibleTo
argument_list|(
argument|ast_type_traits::ASTNodeKind Kind
argument_list|,
argument|unsigned *Specificity
argument_list|,
argument|ast_type_traits::ASTNodeKind *LeastDerivedKind
argument_list|)
specifier|const
name|override
block|{
return|return
name|isRetKindConvertibleTo
argument_list|(
name|RetKinds
argument_list|,
name|Kind
argument_list|,
name|Specificity
argument_list|,
name|LeastDerivedKind
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|MarshallerType
name|Marshaller
block|;
name|void
argument_list|(
operator|*
specifier|const
name|Func
argument_list|)
argument_list|()
block|;
specifier|const
name|std
operator|::
name|string
name|MatcherName
block|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
name|RetKinds
block|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|ArgKind
operator|>
name|ArgKinds
block|; }
block|;
comment|/// \brief Helper methods to extract and merge all possible typed matchers
comment|/// out of the polymorphic object.
name|template
operator|<
name|class
name|PolyMatcher
operator|>
specifier|static
name|void
name|mergePolyMatchers
argument_list|(
argument|const PolyMatcher&Poly
argument_list|,
argument|std::vector<DynTypedMatcher>&Out
argument_list|,
argument|ast_matchers::internal::EmptyTypeList
argument_list|)
block|{}
name|template
operator|<
name|class
name|PolyMatcher
block|,
name|class
name|TypeList
operator|>
specifier|static
name|void
name|mergePolyMatchers
argument_list|(
argument|const PolyMatcher&Poly
argument_list|,
argument|std::vector<DynTypedMatcher>&Out
argument_list|,
argument|TypeList
argument_list|)
block|{
name|Out
operator|.
name|push_back
argument_list|(
argument|ast_matchers::internal::Matcher<typename TypeList::head>(Poly)
argument_list|)
block|;
name|mergePolyMatchers
argument_list|(
argument|Poly
argument_list|,
argument|Out
argument_list|,
argument|typename TypeList::tail()
argument_list|)
block|; }
comment|/// \brief Convert the return values of the functions into a VariantMatcher.
comment|///
comment|/// There are 2 cases right now: The return value is a Matcher<T> or is a
comment|/// polymorphic matcher. For the former, we just construct the VariantMatcher.
comment|/// For the latter, we instantiate all the possible Matcher<T> of the poly
comment|/// matcher.
specifier|static
name|VariantMatcher
name|outvalueToVariantMatcher
argument_list|(
argument|const DynTypedMatcher&Matcher
argument_list|)
block|{
return|return
name|VariantMatcher
operator|::
name|SingleMatcher
argument_list|(
name|Matcher
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|VariantMatcher
name|outvalueToVariantMatcher
argument_list|(
argument|const T&PolyMatcher
argument_list|,
argument|typename T::ReturnTypes * =                                                    NULL
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|DynTypedMatcher
operator|>
name|Matchers
block|;
name|mergePolyMatchers
argument_list|(
argument|PolyMatcher
argument_list|,
argument|Matchers
argument_list|,
argument|typename T::ReturnTypes()
argument_list|)
block|;
name|VariantMatcher
name|Out
operator|=
name|VariantMatcher
operator|::
name|PolymorphicMatcher
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Matchers
argument_list|)
argument_list|)
block|;
return|return
name|Out
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|void
name|buildReturnTypeVectorFromTypeList
argument_list|(
argument|std::vector<ast_type_traits::ASTNodeKind>&RetTypes
argument_list|)
block|{
name|RetTypes
operator|.
name|push_back
argument_list|(
argument|ast_type_traits::ASTNodeKind::getFromNodeKind<typename T::head>()
argument_list|)
block|;
name|buildReturnTypeVectorFromTypeList
operator|<
name|typename
name|T
operator|::
name|tail
operator|>
operator|(
name|RetTypes
operator|)
block|; }
name|template
operator|<
operator|>
specifier|inline
name|void
name|buildReturnTypeVectorFromTypeList
operator|<
name|ast_matchers
operator|::
name|internal
operator|::
name|EmptyTypeList
operator|>
operator|(
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
operator|&
name|RetTypes
operator|)
block|{}
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|BuildReturnTypeVector
block|{
specifier|static
name|void
name|build
argument_list|(
argument|std::vector<ast_type_traits::ASTNodeKind>&RetTypes
argument_list|)
block|{
name|buildReturnTypeVectorFromTypeList
operator|<
name|typename
name|T
operator|::
name|ReturnTypes
operator|>
operator|(
name|RetTypes
operator|)
block|;   }
block|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|BuildReturnTypeVector
operator|<
name|ast_matchers
operator|::
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
name|void
name|build
argument_list|(
argument|std::vector<ast_type_traits::ASTNodeKind>&RetTypes
argument_list|)
block|{
name|RetTypes
operator|.
name|push_back
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
block|;   }
block|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|BuildReturnTypeVector
operator|<
name|ast_matchers
operator|::
name|internal
operator|::
name|BindableMatcher
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
name|void
name|build
argument_list|(
argument|std::vector<ast_type_traits::ASTNodeKind>&RetTypes
argument_list|)
block|{
name|RetTypes
operator|.
name|push_back
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
block|;   }
block|}
block|;
comment|/// \brief Variadic marshaller function.
name|template
operator|<
name|typename
name|ResultT
block|,
name|typename
name|ArgT
block|,
name|ResultT
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
argument_list|)
operator|>
name|VariantMatcher
name|variadicMatcherDescriptor
argument_list|(
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
name|ArgT
operator|*
operator|*
name|InnerArgs
operator|=
name|new
name|ArgT
operator|*
index|[
name|Args
operator|.
name|size
argument_list|()
index|]
operator|(
operator|)
block|;
name|bool
name|HasError
operator|=
name|false
block|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
typedef|typedef
name|ArgTypeTraits
operator|<
name|ArgT
operator|>
name|ArgTraits
expr_stmt|;
specifier|const
name|ParserValue
modifier|&
name|Arg
init|=
name|Args
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|VariantValue
modifier|&
name|Value
init|=
name|Arg
operator|.
name|Value
decl_stmt|;
if|if
condition|(
operator|!
name|ArgTraits
operator|::
name|is
argument_list|(
name|Value
argument_list|)
condition|)
block|{
name|Error
operator|->
name|addError
argument_list|(
name|Arg
operator|.
name|Range
argument_list|,
name|Error
operator|->
name|ET_RegistryWrongArgType
argument_list|)
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|ArgTraits
operator|::
name|getKind
argument_list|()
operator|.
name|asString
argument_list|()
operator|<<
name|Value
operator|.
name|getTypeAsString
argument_list|()
expr_stmt|;
name|HasError
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|InnerArgs
index|[
name|i
index|]
operator|=
name|new
name|ArgT
argument_list|(
name|ArgTraits
operator|::
name|get
argument_list|(
name|Value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VariantMatcher
name|Out
decl_stmt|;
if|if
condition|(
operator|!
name|HasError
condition|)
block|{
name|Out
operator|=
name|outvalueToVariantMatcher
argument_list|(
name|Func
argument_list|(
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|InnerArgs
argument_list|,
name|Args
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|delete
name|InnerArgs
index|[
name|i
index|]
decl_stmt|;
block|}
name|delete
index|[]
name|InnerArgs
decl_stmt|;
return|return
name|Out
return|;
block|}
comment|/// \brief Matcher descriptor for variadic functions.
comment|///
comment|/// This class simply wraps a VariadicFunction with the right signature to export
comment|/// it as a MatcherDescriptor.
comment|/// This allows us to have one implementation of the interface for as many free
comment|/// functions as we want, reducing the number of symbols and size of the
comment|/// object file.
name|class
name|VariadicFuncMatcherDescriptor
operator|:
name|public
name|MatcherDescriptor
block|{
name|public
operator|:
typedef|typedef
name|VariantMatcher
argument_list|(
argument|*RunFunc
argument_list|)
operator|(
name|StringRef
name|MatcherName
operator|,
specifier|const
name|SourceRange
operator|&
name|NameRange
operator|,
name|ArrayRef
operator|<
name|ParserValue
operator|>
name|Args
operator|,
name|Diagnostics
operator|*
name|Error
operator|)
expr_stmt|;
name|template
operator|<
name|typename
name|ResultT
operator|,
name|typename
name|ArgT
operator|,
name|ResultT
argument_list|(
operator|*
name|F
argument_list|)
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
argument_list|)
operator|>
name|VariadicFuncMatcherDescriptor
argument_list|(
argument|llvm::VariadicFunction<ResultT
argument_list|,
argument|ArgT
argument_list|,
argument|F> Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|Func
argument_list|(
operator|&
name|variadicMatcherDescriptor
operator|<
name|ResultT
argument_list|,
name|ArgT
argument_list|,
name|F
operator|>
argument_list|)
operator|,
name|MatcherName
argument_list|(
name|MatcherName
operator|.
name|str
argument_list|()
argument_list|)
operator|,
name|ArgsKind
argument_list|(
argument|ArgTypeTraits<ArgT>::getKind()
argument_list|)
block|{
name|BuildReturnTypeVector
operator|<
name|ResultT
operator|>
operator|::
name|build
argument_list|(
name|RetKinds
argument_list|)
block|;   }
name|VariantMatcher
name|create
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
name|override
block|{
return|return
name|Func
argument_list|(
name|MatcherName
argument_list|,
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
return|;
block|}
name|bool
name|isVariadic
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
name|void
name|getArgKinds
argument_list|(
argument|ast_type_traits::ASTNodeKind ThisKind
argument_list|,
argument|unsigned ArgNo
argument_list|,
argument|std::vector<ArgKind>&Kinds
argument_list|)
specifier|const
name|override
block|{
name|Kinds
operator|.
name|push_back
argument_list|(
name|ArgsKind
argument_list|)
block|;   }
name|bool
name|isConvertibleTo
argument_list|(
argument|ast_type_traits::ASTNodeKind Kind
argument_list|,
argument|unsigned *Specificity
argument_list|,
argument|ast_type_traits::ASTNodeKind *LeastDerivedKind
argument_list|)
specifier|const
name|override
block|{
return|return
name|isRetKindConvertibleTo
argument_list|(
name|RetKinds
argument_list|,
name|Kind
argument_list|,
name|Specificity
argument_list|,
name|LeastDerivedKind
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|RunFunc
name|Func
block|;
specifier|const
name|std
operator|::
name|string
name|MatcherName
block|;
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
name|RetKinds
block|;
specifier|const
name|ArgKind
name|ArgsKind
block|; }
block|;
comment|/// \brief Return CK_Trivial when appropriate for VariadicDynCastAllOfMatchers.
name|class
name|DynCastAllOfMatcherDescriptor
operator|:
name|public
name|VariadicFuncMatcherDescriptor
block|{
name|public
operator|:
name|template
operator|<
name|typename
name|BaseT
block|,
name|typename
name|DerivedT
operator|>
name|DynCastAllOfMatcherDescriptor
argument_list|(
argument|ast_matchers::internal::VariadicDynCastAllOfMatcher<BaseT
argument_list|,
argument|DerivedT> Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|VariadicFuncMatcherDescriptor
argument_list|(
name|Func
argument_list|,
name|MatcherName
argument_list|)
block|,
name|DerivedKind
argument_list|(
argument|ast_type_traits::ASTNodeKind::getFromNodeKind<DerivedT>()
argument_list|)
block|{   }
name|bool
name|isConvertibleTo
argument_list|(
argument|ast_type_traits::ASTNodeKind Kind
argument_list|,
argument|unsigned *Specificity
argument_list|,
argument|ast_type_traits::ASTNodeKind *LeastDerivedKind
argument_list|)
specifier|const
name|override
block|{
comment|// If Kind is not a base of DerivedKind, either DerivedKind is a base of
comment|// Kind (in which case the match will always succeed) or Kind and
comment|// DerivedKind are unrelated (in which case it will always fail), so set
comment|// Specificity to 0.
if|if
condition|(
name|VariadicFuncMatcherDescriptor
operator|::
name|isConvertibleTo
argument_list|(
name|Kind
argument_list|,
name|Specificity
argument_list|,
name|LeastDerivedKind
argument_list|)
condition|)
block|{
if|if
condition|(
name|Kind
operator|.
name|isSame
argument_list|(
name|DerivedKind
argument_list|)
operator|||
operator|!
name|Kind
operator|.
name|isBaseOf
argument_list|(
name|DerivedKind
argument_list|)
condition|)
block|{
if|if
condition|(
name|Specificity
condition|)
operator|*
name|Specificity
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
name|private
operator|:
specifier|const
name|ast_type_traits
operator|::
name|ASTNodeKind
name|DerivedKind
block|; }
block|;
comment|/// \brief Helper macros to check the arguments on all marshaller functions.
define|#
directive|define
name|CHECK_ARG_COUNT
parameter_list|(
name|count
parameter_list|)
define|\
value|if (Args.size() != count) {                                                  \     Error->addError(NameRange, Error->ET_RegistryWrongArgCount)                \<< count<< Args.size();                                               \     return VariantMatcher();                                                   \   }
define|#
directive|define
name|CHECK_ARG_TYPE
parameter_list|(
name|index
parameter_list|,
name|type
parameter_list|)
define|\
value|if (!ArgTypeTraits<type>::is(Args[index].Value)) {                           \     Error->addError(Args[index].Range, Error->ET_RegistryWrongArgType)         \<< (index + 1)<< ArgTypeTraits<type>::getKind().asString()            \<< Args[index].Value.getTypeAsString();                                \     return VariantMatcher();                                                   \   }
comment|/// \brief 0-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall0
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|()
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief 1-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall1
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|(
name|ArgType1
parameter_list|)
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|0
argument_list|,
name|ArgType1
argument_list|)
expr_stmt|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|(
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|0
index|]
operator|.
name|Value
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief 2-arg marshaller function.
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|,
name|typename
name|ArgType2
operator|>
specifier|static
name|VariantMatcher
name|matcherMarshall2
argument_list|(
argument|void (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|,
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
block|{
typedef|typedef
name|ReturnType
function_decl|(
modifier|*
name|FuncType
function_decl|)
parameter_list|(
name|ArgType1
parameter_list|,
name|ArgType2
parameter_list|)
function_decl|;
name|CHECK_ARG_COUNT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|0
argument_list|,
name|ArgType1
argument_list|)
expr_stmt|;
name|CHECK_ARG_TYPE
argument_list|(
literal|1
argument_list|,
name|ArgType2
argument_list|)
expr_stmt|;
return|return
name|outvalueToVariantMatcher
argument_list|(
name|reinterpret_cast
operator|<
name|FuncType
operator|>
call|(
name|Func
call|)
argument_list|(
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|0
index|]
operator|.
name|Value
argument_list|)
argument_list|,
name|ArgTypeTraits
operator|<
name|ArgType2
operator|>
operator|::
name|get
argument_list|(
name|Args
index|[
literal|1
index|]
operator|.
name|Value
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
undef|#
directive|undef
name|CHECK_ARG_COUNT
undef|#
directive|undef
name|CHECK_ARG_TYPE
comment|/// \brief Helper class used to collect all the possible overloads of an
comment|///   argument adaptative matcher function.
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|class
name|AdaptativeOverloadCollector
block|{
name|public
operator|:
name|AdaptativeOverloadCollector
argument_list|(
argument|StringRef Name
argument_list|,
argument|std::vector<MatcherDescriptor *>&Out
argument_list|)
operator|:
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Out
argument_list|(
argument|Out
argument_list|)
block|{
name|collect
argument_list|(
name|FromTypes
argument_list|()
argument_list|)
block|;   }
name|private
operator|:
typedef|typedef
name|ast_matchers
operator|::
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|ArgumentAdapterT
operator|,
name|FromTypes
operator|,
name|ToTypes
operator|>
name|AdaptativeFunc
expr_stmt|;
comment|/// \brief End case for the recursion
specifier|static
name|void
name|collect
argument_list|(
argument|ast_matchers::internal::EmptyTypeList
argument_list|)
block|{}
comment|/// \brief Recursive case. Get the overload for the head of the list, and
comment|///   recurse to the tail.
name|template
operator|<
name|typename
name|FromTypeList
operator|>
specifier|inline
name|void
name|collect
argument_list|(
name|FromTypeList
argument_list|)
expr_stmt|;
name|StringRef
name|Name
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|MatcherDescriptor
operator|*
operator|>
operator|&
name|Out
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief MatcherDescriptor that wraps multiple "overloads" of the same
comment|///   matcher.
comment|///
comment|/// It will try every overload and generate appropriate errors for when none or
comment|/// more than one overloads match the arguments.
name|class
name|OverloadedMatcherDescriptor
range|:
name|public
name|MatcherDescriptor
block|{
name|public
operator|:
name|OverloadedMatcherDescriptor
argument_list|(
name|ArrayRef
operator|<
name|MatcherDescriptor
operator|*
operator|>
name|Callbacks
argument_list|)
operator|:
name|Overloads
argument_list|(
argument|Callbacks.begin()
argument_list|,
argument|Callbacks.end()
argument_list|)
block|{}
operator|~
name|OverloadedMatcherDescriptor
argument_list|()
name|override
block|{}
name|VariantMatcher
name|create
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
name|override
block|{
name|std
operator|::
name|vector
operator|<
name|VariantMatcher
operator|>
name|Constructed
block|;
name|Diagnostics
operator|::
name|OverloadContext
name|Ctx
argument_list|(
name|Error
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|O
range|:
name|Overloads
control|)
block|{
name|VariantMatcher
name|SubMatcher
init|=
name|O
operator|->
name|create
argument_list|(
name|NameRange
argument_list|,
name|Args
argument_list|,
name|Error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SubMatcher
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|Constructed
operator|.
name|push_back
argument_list|(
name|SubMatcher
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Constructed
operator|.
name|empty
argument_list|()
condition|)
return|return
name|VariantMatcher
argument_list|()
return|;
comment|// No overload matched.
comment|// We ignore the errors if any matcher succeeded.
name|Ctx
operator|.
name|revertErrors
argument_list|()
block|;
if|if
condition|(
name|Constructed
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// More than one constructed. It is ambiguous.
name|Error
operator|->
name|addError
argument_list|(
name|NameRange
argument_list|,
name|Error
operator|->
name|ET_RegistryAmbiguousOverload
argument_list|)
expr_stmt|;
return|return
name|VariantMatcher
argument_list|()
return|;
block|}
return|return
name|Constructed
index|[
literal|0
index|]
return|;
block|}
name|bool
name|isVariadic
argument_list|()
specifier|const
name|override
block|{
name|bool
name|Overload0Variadic
operator|=
name|Overloads
index|[
literal|0
index|]
operator|->
name|isVariadic
argument_list|()
block|;
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|O
range|:
name|Overloads
control|)
block|{
name|assert
argument_list|(
name|Overload0Variadic
operator|==
name|O
operator|->
name|isVariadic
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|Overload0Variadic
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
name|override
block|{
name|unsigned
name|Overload0NumArgs
operator|=
name|Overloads
index|[
literal|0
index|]
operator|->
name|getNumArgs
argument_list|()
block|;
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|O
range|:
name|Overloads
control|)
block|{
name|assert
argument_list|(
name|Overload0NumArgs
operator|==
name|O
operator|->
name|getNumArgs
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|Overload0NumArgs
return|;
block|}
name|void
name|getArgKinds
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
name|ThisKind
argument_list|,
name|unsigned
name|ArgNo
argument_list|,
name|std
operator|::
name|vector
operator|<
name|ArgKind
operator|>
operator|&
name|Kinds
argument_list|)
decl|const
name|override
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|O
range|:
name|Overloads
control|)
block|{
if|if
condition|(
name|O
operator|->
name|isConvertibleTo
argument_list|(
name|ThisKind
argument_list|)
condition|)
name|O
operator|->
name|getArgKinds
argument_list|(
name|ThisKind
argument_list|,
name|ArgNo
argument_list|,
name|Kinds
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|isConvertibleTo
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
name|Kind
argument_list|,
name|unsigned
operator|*
name|Specificity
argument_list|,
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|*
name|LeastDerivedKind
argument_list|)
decl|const
name|override
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|O
range|:
name|Overloads
control|)
block|{
if|if
condition|(
name|O
operator|->
name|isConvertibleTo
argument_list|(
name|Kind
argument_list|,
name|Specificity
argument_list|,
name|LeastDerivedKind
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|MatcherDescriptor
operator|>>
name|Overloads
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Variadic operator marshaller function.
end_comment

begin_decl_stmt
name|class
name|VariadicOperatorMatcherDescriptor
range|:
name|public
name|MatcherDescriptor
block|{
name|public
operator|:
typedef|typedef
name|DynTypedMatcher
operator|::
name|VariadicOperator
name|VarOp
expr_stmt|;
name|VariadicOperatorMatcherDescriptor
argument_list|(
argument|unsigned MinCount
argument_list|,
argument|unsigned MaxCount
argument_list|,
argument|VarOp Op
argument_list|,
argument|StringRef MatcherName
argument_list|)
operator|:
name|MinCount
argument_list|(
name|MinCount
argument_list|)
block|,
name|MaxCount
argument_list|(
name|MaxCount
argument_list|)
block|,
name|Op
argument_list|(
name|Op
argument_list|)
block|,
name|MatcherName
argument_list|(
argument|MatcherName
argument_list|)
block|{}
name|VariantMatcher
name|create
argument_list|(
argument|const SourceRange&NameRange
argument_list|,
argument|ArrayRef<ParserValue> Args
argument_list|,
argument|Diagnostics *Error
argument_list|)
specifier|const
name|override
block|{
if|if
condition|(
name|Args
operator|.
name|size
argument_list|()
operator|<
name|MinCount
operator|||
name|MaxCount
operator|<
name|Args
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|const
name|std
operator|::
name|string
name|MaxStr
operator|=
operator|(
name|MaxCount
operator|==
name|UINT_MAX
condition|?
literal|""
else|:
name|Twine
argument_list|(
name|MaxCount
argument_list|)
operator|)
operator|.
name|str
argument_list|()
expr_stmt|;
name|Error
operator|->
name|addError
argument_list|(
name|NameRange
argument_list|,
name|Error
operator|->
name|ET_RegistryWrongArgCount
argument_list|)
operator|<<
operator|(
literal|"("
operator|+
name|Twine
argument_list|(
name|MinCount
argument_list|)
operator|+
literal|", "
operator|+
name|MaxStr
operator|+
literal|")"
operator|)
operator|<<
name|Args
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|VariantMatcher
argument_list|()
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|VariantMatcher
operator|>
name|InnerArgs
expr_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|Args
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ParserValue
modifier|&
name|Arg
init|=
name|Args
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|VariantValue
modifier|&
name|Value
init|=
name|Arg
operator|.
name|Value
decl_stmt|;
if|if
condition|(
operator|!
name|Value
operator|.
name|isMatcher
argument_list|()
condition|)
block|{
name|Error
operator|->
name|addError
argument_list|(
name|Arg
operator|.
name|Range
argument_list|,
name|Error
operator|->
name|ET_RegistryWrongArgType
argument_list|)
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
literal|"Matcher<>"
operator|<<
name|Value
operator|.
name|getTypeAsString
argument_list|()
expr_stmt|;
return|return
name|VariantMatcher
argument_list|()
return|;
block|}
name|InnerArgs
operator|.
name|push_back
argument_list|(
name|Value
operator|.
name|getMatcher
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|VariantMatcher
operator|::
name|VariadicOperatorMatcher
argument_list|(
name|Op
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|InnerArgs
argument_list|)
argument_list|)
return|;
end_return

begin_macro
unit|}    bool
name|isVariadic
argument_list|()
end_macro

begin_expr_stmt
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|getArgKinds
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
name|ThisKind
argument_list|,
name|unsigned
name|ArgNo
argument_list|,
name|std
operator|::
name|vector
operator|<
name|ArgKind
operator|>
operator|&
name|Kinds
argument_list|)
decl|const
name|override
block|{
name|Kinds
operator|.
name|push_back
argument_list|(
name|ThisKind
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isConvertibleTo
argument_list|(
name|ast_type_traits
operator|::
name|ASTNodeKind
name|Kind
argument_list|,
name|unsigned
operator|*
name|Specificity
argument_list|,
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|*
name|LeastDerivedKind
argument_list|)
decl|const
name|override
block|{
if|if
condition|(
name|Specificity
condition|)
operator|*
name|Specificity
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|LeastDerivedKind
condition|)
operator|*
name|LeastDerivedKind
operator|=
name|Kind
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|isPolymorphic
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|const
name|unsigned
name|MinCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|unsigned
name|MaxCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|VarOp
name|Op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|StringRef
name|MatcherName
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Helper functions to select the appropriate marshaller functions.
end_comment

begin_comment
comment|/// They detect the number of arguments, arguments types and return type.
end_comment

begin_comment
comment|/// \brief 0-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)()
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
name|RetTypes
block|;
name|BuildReturnTypeVector
operator|<
name|ReturnType
operator|>
operator|::
name|build
argument_list|(
name|RetTypes
argument_list|)
block|;
return|return
name|new
name|FixedArgCountMatcherDescriptor
argument_list|(
name|matcherMarshall0
operator|<
name|ReturnType
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|,
name|RetTypes
argument_list|,
name|None
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief 1-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)(ArgType1)
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
name|RetTypes
block|;
name|BuildReturnTypeVector
operator|<
name|ReturnType
operator|>
operator|::
name|build
argument_list|(
name|RetTypes
argument_list|)
block|;
name|ArgKind
name|AK
operator|=
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|getKind
argument_list|()
block|;
return|return
name|new
name|FixedArgCountMatcherDescriptor
argument_list|(
name|matcherMarshall1
operator|<
name|ReturnType
argument_list|,
name|ArgType1
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|,
name|RetTypes
argument_list|,
name|AK
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief 2-arg overload
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ReturnType
operator|,
name|typename
name|ArgType1
operator|,
name|typename
name|ArgType2
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ReturnType (*Func)(ArgType1, ArgType2)
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
name|RetTypes
block|;
name|BuildReturnTypeVector
operator|<
name|ReturnType
operator|>
operator|::
name|build
argument_list|(
name|RetTypes
argument_list|)
block|;
name|ArgKind
name|AKs
index|[]
operator|=
block|{
name|ArgTypeTraits
operator|<
name|ArgType1
operator|>
operator|::
name|getKind
argument_list|()
block|,
name|ArgTypeTraits
operator|<
name|ArgType2
operator|>
operator|::
name|getKind
argument_list|()
block|}
block|;
return|return
name|new
name|FixedArgCountMatcherDescriptor
argument_list|(
name|matcherMarshall2
operator|<
name|ReturnType
argument_list|,
name|ArgType1
argument_list|,
name|ArgType2
operator|>
argument_list|,
name|reinterpret_cast
operator|<
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|>
operator|(
name|Func
operator|)
argument_list|,
name|MatcherName
argument_list|,
name|RetTypes
argument_list|,
name|AKs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Variadic overload.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|ResultT
operator|,
name|typename
name|ArgT
operator|,
name|ResultT
argument_list|(
operator|*
name|Func
argument_list|)
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|ArgT
operator|*
operator|>
argument_list|)
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|llvm::VariadicFunction<ResultT
argument_list|,
argument|ArgT
argument_list|,
argument|Func> VarFunc
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|VariadicFuncMatcherDescriptor
argument_list|(
name|VarFunc
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Overload for VariadicDynCastAllOfMatchers.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Not strictly necessary, but DynCastAllOfMatcherDescriptor gives us better
end_comment

begin_comment
comment|/// completion results for that type of matcher.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|BaseT
operator|,
name|typename
name|DerivedT
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ast_matchers::internal::VariadicDynCastAllOfMatcher<                             BaseT
argument_list|,
argument|DerivedT> VarFunc
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|DynCastAllOfMatcherDescriptor
argument_list|(
name|VarFunc
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Argument adaptative overload.
end_comment

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ast_matchers::internal::ArgumentAdaptingMatcherFunc<                             ArgumentAdapterT
argument_list|,
argument|FromTypes
argument_list|,
argument|ToTypes>
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|MatcherDescriptor
operator|*
operator|>
name|Overloads
block|;
name|AdaptativeOverloadCollector
operator|<
name|ArgumentAdapterT
block|,
name|FromTypes
block|,
name|ToTypes
operator|>
operator|(
name|MatcherName
operator|,
name|Overloads
operator|)
block|;
return|return
name|new
name|OverloadedMatcherDescriptor
argument_list|(
name|Overloads
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|template
operator|<
name|typename
name|ToArg
operator|,
name|typename
name|FromArg
operator|>
name|class
name|ArgumentAdapterT
operator|,
name|typename
name|FromTypes
operator|,
name|typename
name|ToTypes
operator|>
name|template
operator|<
name|typename
name|FromTypeList
operator|>
specifier|inline
name|void
name|AdaptativeOverloadCollector
operator|<
name|ArgumentAdapterT
operator|,
name|FromTypes
operator|,
name|ToTypes
operator|>
operator|::
name|collect
argument_list|(
argument|FromTypeList
argument_list|)
block|{
name|Out
operator|.
name|push_back
argument_list|(
name|makeMatcherAutoMarshall
argument_list|(
argument|&AdaptativeFunc::template create<typename FromTypeList::head>
argument_list|,
argument|Name
argument_list|)
argument_list|)
block|;
name|collect
argument_list|(
argument|typename FromTypeList::tail()
argument_list|)
block|; }
comment|/// \brief Variadic operator overload.
name|template
operator|<
name|unsigned
name|MinCount
operator|,
name|unsigned
name|MaxCount
operator|>
name|MatcherDescriptor
operator|*
name|makeMatcherAutoMarshall
argument_list|(
argument|ast_matchers::internal::VariadicOperatorMatcherFunc<                             MinCount
argument_list|,
argument|MaxCount> Func
argument_list|,
argument|StringRef MatcherName
argument_list|)
block|{
return|return
name|new
name|VariadicOperatorMatcherDescriptor
argument_list|(
name|MinCount
argument_list|,
name|MaxCount
argument_list|,
name|Func
operator|.
name|Op
argument_list|,
name|MatcherName
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace internal
end_comment

begin_comment
unit|}
comment|// namespace dynamic
end_comment

begin_comment
unit|}
comment|// namespace ast_matchers
end_comment

begin_comment
unit|}
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_AST_MATCHERS_DYNAMIC_MARSHALLERS_H
end_comment

end_unit

