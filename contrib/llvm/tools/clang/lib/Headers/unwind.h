begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===---- unwind.h - Stack unwinding ----------------------------------------===  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  *  *===-----------------------------------------------------------------------===  */
end_comment

begin_comment
comment|/* See "Data Definitions for libgcc_s" in the Linux Standard Base.*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CLANG_UNWIND_H
end_ifndef

begin_define
define|#
directive|define
name|__CLANG_UNWIND_H
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|__has_include_next
argument_list|(
operator|<
name|unwind
operator|.
name|h
operator|>
argument_list|)
end_if

begin_comment
comment|/* Darwin (from 11.x on) provide an unwind.h. If that's available,  * use it. libunwind wraps some of its definitions in #ifdef _GNU_SOURCE,  * so define that around the include.*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_SHOULD_UNDEFINE_GNU_SOURCE
end_define

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// libunwind's unwind.h reflects the current visibility.  However, Mozilla
end_comment

begin_comment
comment|// builds with -fvisibility=hidden and relies on gcc's unwind.h to reset the
end_comment

begin_comment
comment|// visibility to default and export its contents.  gcc also allows users to
end_comment

begin_comment
comment|// override its override by #defining HIDE_EXPORTS (but note, this only obeys
end_comment

begin_comment
comment|// the user's -fvisibility setting; it doesn't hide any exports on its own).  We
end_comment

begin_comment
comment|// imitate gcc's header here:
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HIDE_EXPORTS
end_ifdef

begin_empty
empty|#  include_next<unwind.h>
end_empty

begin_else
else|#
directive|else
end_else

begin_pragma
pragma|#
directive|pragma
name|GCC
name|visibility
name|push
name|(
name|default
name|)
end_pragma

begin_empty
empty|#  include_next<unwind.h>
end_empty

begin_pragma
pragma|#
directive|pragma
name|GCC
name|visibility
name|pop
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_SHOULD_UNDEFINE_GNU_SOURCE
end_ifdef

begin_undef
undef|#
directive|undef
name|_GNU_SOURCE
end_undef

begin_undef
undef|#
directive|undef
name|_SHOULD_UNDEFINE_GNU_SOURCE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* It is a bit strange for a header to play with the visibility of the    symbols it declares, but this matches gcc's behavior and some programs    depend on it */
ifndef|#
directive|ifndef
name|HIDE_EXPORTS
pragma|#
directive|pragma
name|GCC
name|visibility
name|push
name|(
name|default
name|)
endif|#
directive|endif
typedef|typedef
name|uintptr_t
name|_Unwind_Word
typedef|;
typedef|typedef
name|intptr_t
name|_Unwind_Sword
typedef|;
typedef|typedef
name|uintptr_t
name|_Unwind_Ptr
typedef|;
typedef|typedef
name|uintptr_t
name|_Unwind_Internal_Ptr
typedef|;
typedef|typedef
name|uint64_t
name|_Unwind_Exception_Class
typedef|;
typedef|typedef
name|intptr_t
name|_sleb128_t
typedef|;
typedef|typedef
name|uintptr_t
name|_uleb128_t
typedef|;
struct_decl|struct
name|_Unwind_Context
struct_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_DWARF_EH___
argument_list|)
operator|)
struct_decl|struct
name|_Unwind_Control_Block
struct_decl|;
typedef|typedef
name|struct
name|_Unwind_Control_Block
name|_Unwind_Exception
typedef|;
comment|/* Alias */
else|#
directive|else
struct_decl|struct
name|_Unwind_Exception
struct_decl|;
typedef|typedef
name|struct
name|_Unwind_Exception
name|_Unwind_Exception
typedef|;
endif|#
directive|endif
typedef|typedef
enum|enum
block|{
name|_URC_NO_REASON
init|=
literal|0
block|,
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__ARM_DWARF_EH__
argument_list|)
name|_URC_OK
init|=
literal|0
block|,
comment|/* used by ARM EHABI */
endif|#
directive|endif
name|_URC_FOREIGN_EXCEPTION_CAUGHT
init|=
literal|1
block|,
name|_URC_FATAL_PHASE2_ERROR
init|=
literal|2
block|,
name|_URC_FATAL_PHASE1_ERROR
init|=
literal|3
block|,
name|_URC_NORMAL_STOP
init|=
literal|4
block|,
name|_URC_END_OF_STACK
init|=
literal|5
block|,
name|_URC_HANDLER_FOUND
init|=
literal|6
block|,
name|_URC_INSTALL_CONTEXT
init|=
literal|7
block|,
name|_URC_CONTINUE_UNWIND
init|=
literal|8
block|,
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__ARM_DWARF_EH__
argument_list|)
name|_URC_FAILURE
init|=
literal|9
comment|/* used by ARM EHABI */
endif|#
directive|endif
block|}
name|_Unwind_Reason_Code
typedef|;
typedef|typedef
enum|enum
block|{
name|_UA_SEARCH_PHASE
init|=
literal|1
block|,
name|_UA_CLEANUP_PHASE
init|=
literal|2
block|,
name|_UA_HANDLER_FRAME
init|=
literal|4
block|,
name|_UA_FORCE_UNWIND
init|=
literal|8
block|,
name|_UA_END_OF_STACK
init|=
literal|16
comment|/* gcc extension to C++ ABI */
block|}
name|_Unwind_Action
typedef|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|_Unwind_Exception_Cleanup_Fn
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
parameter_list|,
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_DWARF_EH___
argument_list|)
operator|)
typedef|typedef
name|struct
name|_Unwind_Control_Block
name|_Unwind_Control_Block
typedef|;
typedef|typedef
name|uint32_t
name|_Unwind_EHT_Header
typedef|;
struct|struct
name|_Unwind_Control_Block
block|{
name|uint64_t
name|exception_class
decl_stmt|;
name|void
function_decl|(
modifier|*
name|exception_cleanup
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|)
function_decl|;
comment|/* unwinder cache (private fields for the unwinder's use) */
struct|struct
block|{
name|uint32_t
name|reserved1
decl_stmt|;
comment|/* forced unwind stop function, 0 if not forced */
name|uint32_t
name|reserved2
decl_stmt|;
comment|/* personality routine */
name|uint32_t
name|reserved3
decl_stmt|;
comment|/* callsite */
name|uint32_t
name|reserved4
decl_stmt|;
comment|/* forced unwind stop argument */
name|uint32_t
name|reserved5
decl_stmt|;
block|}
name|unwinder_cache
struct|;
comment|/* propagation barrier cache (valid after phase 1) */
struct|struct
block|{
name|uint32_t
name|sp
decl_stmt|;
name|uint32_t
name|bitpattern
index|[
literal|5
index|]
decl_stmt|;
block|}
name|barrier_cache
struct|;
comment|/* cleanup cache (preserved over cleanup) */
struct|struct
block|{
name|uint32_t
name|bitpattern
index|[
literal|4
index|]
decl_stmt|;
block|}
name|cleanup_cache
struct|;
comment|/* personality cache (for personality's benefit) */
struct|struct
block|{
name|uint32_t
name|fnstart
decl_stmt|;
comment|/* function start address */
name|_Unwind_EHT_Header
modifier|*
name|ehtp
decl_stmt|;
comment|/* pointer to EHT entry header word */
name|uint32_t
name|additional
decl_stmt|;
comment|/* additional data */
name|uint32_t
name|reserved1
decl_stmt|;
block|}
name|pr_cache
struct|;
name|long
name|long
name|int
range|:
literal|0
decl_stmt|;
comment|/* force alignment of next item to 8-byte boundary */
block|}
struct|;
else|#
directive|else
struct|struct
name|_Unwind_Exception
block|{
name|_Unwind_Exception_Class
name|exception_class
decl_stmt|;
name|_Unwind_Exception_Cleanup_Fn
name|exception_cleanup
decl_stmt|;
name|_Unwind_Word
name|private_1
decl_stmt|;
name|_Unwind_Word
name|private_2
decl_stmt|;
comment|/* The Itanium ABI requires that _Unwind_Exception objects are "double-word    * aligned".  GCC has interpreted this to mean "use the maximum useful    * alignment for the target"; so do we. */
block|}
name|__attribute__
argument_list|(
operator|(
name|__aligned__
operator|)
argument_list|)
struct|;
endif|#
directive|endif
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Stop_Fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Personality_Fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|_Unwind_Personality_Fn
name|__personality_routine
typedef|;
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Trace_Fn
function_decl|)
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_DWARF_EH___
argument_list|)
operator|)
typedef|typedef
enum|enum
block|{
name|_UVRSC_CORE
init|=
literal|0
block|,
comment|/* integer register */
name|_UVRSC_VFP
init|=
literal|1
block|,
comment|/* vfp */
name|_UVRSC_WMMXD
init|=
literal|3
block|,
comment|/* Intel WMMX data register */
name|_UVRSC_WMMXC
init|=
literal|4
comment|/* Intel WMMX control register */
block|}
name|_Unwind_VRS_RegClass
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSD_UINT32
init|=
literal|0
block|,
name|_UVRSD_VFPX
init|=
literal|1
block|,
name|_UVRSD_UINT64
init|=
literal|3
block|,
name|_UVRSD_FLOAT
init|=
literal|4
block|,
name|_UVRSD_DOUBLE
init|=
literal|5
block|}
name|_Unwind_VRS_DataRepresentation
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSR_OK
init|=
literal|0
block|,
name|_UVRSR_NOT_IMPLEMENTED
init|=
literal|1
block|,
name|_UVRSR_FAILED
init|=
literal|2
block|}
name|_Unwind_VRS_Result
typedef|;
typedef|typedef
name|uint32_t
name|_Unwind_State
typedef|;
define|#
directive|define
name|_US_VIRTUAL_UNWIND_FRAME
value|((_Unwind_State)0)
define|#
directive|define
name|_US_UNWIND_FRAME_STARTING
value|((_Unwind_State)1)
define|#
directive|define
name|_US_UNWIND_FRAME_RESUME
value|((_Unwind_State)2)
define|#
directive|define
name|_US_ACTION_MASK
value|((_Unwind_State)3)
define|#
directive|define
name|_US_FORCE_UNWIND
value|((_Unwind_State)8)
name|_Unwind_VRS_Result
name|_Unwind_VRS_Get
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|,
name|_Unwind_VRS_RegClass
name|__regclass
parameter_list|,
name|uint32_t
name|__regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|__representation
parameter_list|,
name|void
modifier|*
name|__valuep
parameter_list|)
function_decl|;
name|_Unwind_VRS_Result
name|_Unwind_VRS_Set
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|,
name|_Unwind_VRS_RegClass
name|__regclass
parameter_list|,
name|uint32_t
name|__regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|__representation
parameter_list|,
name|void
modifier|*
name|__valuep
parameter_list|)
function_decl|;
specifier|static
name|__inline__
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|,
name|int
name|__index
parameter_list|)
block|{
name|_Unwind_Word
name|__value
decl_stmt|;
name|_Unwind_VRS_Get
argument_list|(
name|__context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|__index
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|__value
argument_list|)
expr_stmt|;
return|return
name|__value
return|;
block|}
specifier|static
name|__inline__
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|,
name|int
name|__index
parameter_list|,
name|_Unwind_Word
name|__value
parameter_list|)
block|{
name|_Unwind_VRS_Set
argument_list|(
name|__context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|__index
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|__value
argument_list|)
expr_stmt|;
block|}
specifier|static
name|__inline__
name|_Unwind_Word
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|)
block|{
name|_Unwind_Word
name|__ip
init|=
name|_Unwind_GetGR
argument_list|(
name|__context
argument_list|,
literal|15
argument_list|)
decl_stmt|;
return|return
name|__ip
operator|&
operator|~
call|(
name|_Unwind_Word
call|)
argument_list|(
literal|0x1
argument_list|)
return|;
comment|/* Remove thumb mode bit. */
block|}
specifier|static
name|__inline__
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|__context
parameter_list|,
name|_Unwind_Word
name|__value
parameter_list|)
block|{
name|_Unwind_Word
name|__thumb_mode_bit
init|=
name|_Unwind_GetGR
argument_list|(
name|__context
argument_list|,
literal|15
argument_list|)
operator|&
literal|0x1
decl_stmt|;
name|_Unwind_SetGR
argument_list|(
name|__context
argument_list|,
literal|15
argument_list|,
name|__value
operator||
name|__thumb_mode_bit
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
parameter_list|,
name|_Unwind_Word
parameter_list|)
function_decl|;
name|_Unwind_Word
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_Word
parameter_list|)
function_decl|;
endif|#
directive|endif
name|_Unwind_Word
name|_Unwind_GetIPInfo
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Word
name|_Unwind_GetBSP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|/* DWARF EH functions; currently not available on Darwin/ARM */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|__arm__
argument_list|)
name|_Unwind_Reason_Code
name|_Unwind_RaiseException
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
name|_Unwind_DeleteException
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|void
name|_Unwind_Resume
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|_Unwind_Reason_Code
name|_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* setjmp(3)/longjmp(3) stuff */
typedef|typedef
name|struct
name|SjLj_Function_Context
modifier|*
name|_Unwind_FunctionContext_t
typedef|;
name|void
name|_Unwind_SjLj_Register
parameter_list|(
name|_Unwind_FunctionContext_t
parameter_list|)
function_decl|;
name|void
name|_Unwind_SjLj_Unregister
parameter_list|(
name|_Unwind_FunctionContext_t
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_SjLj_RaiseException
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_SjLj_ForcedUnwind
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
name|_Unwind_SjLj_Resume
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_SjLj_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|_Unwind_FindEnclosingFunction
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__APPLE__
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
block|)
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Darwin-specific functions */
end_comment

begin_function_decl
name|void
name|__register_frame
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__deregister_frame
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|dwarf_eh_bases
block|{
name|uintptr_t
name|tbase
decl_stmt|;
name|uintptr_t
name|dbase
decl_stmt|;
name|uintptr_t
name|func
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
modifier|*
name|_Unwind_Find_FDE
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__register_frame_info_bases
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__register_frame_info
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__register_frame_info_table_bases
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__register_frame_info_table
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__register_frame_table
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__deregister_frame_info
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|__deregister_frame_info_bases
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__unavailable__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HIDE_EXPORTS
end_ifndef

begin_pragma
pragma|#
directive|pragma
name|GCC
name|visibility
name|pop
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CLANG_UNWIND_H */
end_comment

end_unit

