begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===---- htmxlintrin.h - XL compiler HTM execution intrinsics-------------===*\  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  * \*===----------------------------------------------------------------------===*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__HTMXLINTRIN_H
end_ifndef

begin_define
define|#
directive|define
name|__HTMXLINTRIN_H
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__HTM__
end_ifndef

begin_error
error|#
directive|error
literal|"HTM instruction set not enabled"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<htmintrin.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|_TEXASR_PTR
parameter_list|(
name|TM_BUF
parameter_list|)
value|((texasr_t *)((char *)(TM_BUF) + 0))
define|#
directive|define
name|_TEXASRU_PTR
parameter_list|(
name|TM_BUF
parameter_list|)
value|((texasru_t *)((char *)(TM_BUF) + 0))
define|#
directive|define
name|_TEXASRL_PTR
parameter_list|(
name|TM_BUF
parameter_list|)
value|((texasrl_t *)((char *)(TM_BUF) + 4))
define|#
directive|define
name|_TFIAR_PTR
parameter_list|(
name|TM_BUF
parameter_list|)
value|((tfiar_t *)((char *)(TM_BUF) + 8))
typedef|typedef
name|char
name|TM_buff_type
index|[
literal|16
index|]
typedef|;
comment|/* This macro can be used to determine whether a transaction was successfully    started from the __TM_begin() and __TM_simple_begin() intrinsic functions    below.  */
define|#
directive|define
name|_HTM_TBEGIN_STARTED
value|1
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_simple_begin
argument_list|(
name|void
argument_list|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__builtin_tbegin
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|_HTM_TBEGIN_STARTED
return|;
return|return
literal|0
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_begin
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
operator|*
name|_TEXASRL_PTR
argument_list|(
name|__TM_buff
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__builtin_tbegin
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|_HTM_TBEGIN_STARTED
return|;
ifdef|#
directive|ifdef
name|__powerpc64__
operator|*
name|_TEXASR_PTR
argument_list|(
name|__TM_buff
argument_list|)
operator|=
name|__builtin_get_texasr
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
operator|=
name|__builtin_get_texasru
argument_list|()
expr_stmt|;
operator|*
name|_TEXASRL_PTR
argument_list|(
name|__TM_buff
argument_list|)
operator|=
name|__builtin_get_texasr
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|*
name|_TFIAR_PTR
argument_list|(
name|__TM_buff
argument_list|)
operator|=
name|__builtin_get_tfiar
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_end
argument_list|(
name|void
argument_list|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__builtin_tend
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
specifier|extern
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_abort
argument_list|(
name|void
argument_list|)
block|{
name|__builtin_tabort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|extern
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_named_abort
argument_list|(
name|unsigned
name|char
specifier|const
name|__code
argument_list|)
block|{
name|__builtin_tabort
argument_list|(
name|__code
argument_list|)
expr_stmt|;
block|}
specifier|extern
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_resume
argument_list|(
name|void
argument_list|)
block|{
name|__builtin_tresume
argument_list|()
expr_stmt|;
block|}
specifier|extern
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_suspend
argument_list|(
name|void
argument_list|)
block|{
name|__builtin_tsuspend
argument_list|()
expr_stmt|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_user_abort
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
return|return
name|_TEXASRU_ABORT
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_named_user_abort
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|,
name|unsigned
name|char
operator|*
name|__code
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
operator|*
name|__code
operator|=
name|_TEXASRU_FAILURE_CODE
argument_list|(
name|texasru
argument_list|)
expr_stmt|;
return|return
name|_TEXASRU_ABORT
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_illegal
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
return|return
name|_TEXASRU_DISALLOWED
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_footprint_exceeded
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
return|return
name|_TEXASRU_FOOTPRINT_OVERFLOW
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_nesting_depth
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasrl_t
name|texasrl
decl_stmt|;
if|if
condition|(
name|_HTM_STATE
argument_list|(
name|__builtin_ttest
argument_list|()
argument_list|)
operator|==
name|_HTM_NONTRANSACTIONAL
condition|)
block|{
name|texasrl
operator|=
operator|*
name|_TEXASRL_PTR
argument_list|(
name|__TM_buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_TEXASR_FAILURE_SUMMARY
argument_list|(
name|texasrl
argument_list|)
condition|)
name|texasrl
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|texasrl
operator|=
operator|(
name|texasrl_t
operator|)
name|__builtin_get_texasr
argument_list|()
expr_stmt|;
return|return
name|_TEXASR_TRANSACTION_LEVEL
argument_list|(
name|texasrl
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_nested_too_deep
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
return|return
name|_TEXASRU_NESTING_OVERFLOW
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_conflict
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
comment|/* Return TEXASR bits 11 (Self-Induced Conflict) through      14 (Translation Invalidation Conflict).  */
return|return
operator|(
name|_TEXASRU_EXTRACT_BITS
argument_list|(
name|texasru
argument_list|,
literal|14
argument_list|,
literal|4
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_is_failure_persistent
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
name|texasru_t
name|texasru
init|=
operator|*
name|_TEXASRU_PTR
argument_list|(
name|__TM_buff
argument_list|)
decl_stmt|;
return|return
name|_TEXASRU_FAILURE_PERSISTENT
argument_list|(
name|texasru
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_failure_address
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
return|return
operator|*
name|_TFIAR_PTR
argument_list|(
name|__TM_buff
argument_list|)
return|;
block|}
specifier|extern
name|__inline
name|long
name|long
name|__attribute__
argument_list|(
operator|(
name|__gnu_inline__
operator|,
name|__always_inline__
operator|,
name|__artificial__
operator|)
argument_list|)
name|__TM_failure_code
argument_list|(
name|void
operator|*
specifier|const
name|__TM_buff
argument_list|)
block|{
return|return
operator|*
name|_TEXASR_PTR
argument_list|(
name|__TM_buff
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __powerpc__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__s390__
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|/* These intrinsics are being made available for compatibility with    the IBM XL compiler.  For documentation please see the "z/OS XL    C/C++ Programming Guide" publically available on the web.  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_simple_begin
argument_list|()
block|{
return|return
name|__builtin_tbegin_nofloat
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_begin
argument_list|(
name|void
operator|*
specifier|const
name|__tdb
argument_list|)
block|{
return|return
name|__builtin_tbegin_nofloat
argument_list|(
name|__tdb
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_end
argument_list|()
block|{
return|return
name|__builtin_tend
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|)
argument_list|)
name|__TM_abort
argument_list|()
block|{
return|return
name|__builtin_tabort
argument_list|(
name|_HTM_FIRST_USER_ABORT_CODE
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_named_abort
argument_list|(
name|unsigned
name|char
specifier|const
name|__code
argument_list|)
block|{
return|return
name|__builtin_tabort
argument_list|(
operator|(
name|int
operator|)
name|_HTM_FIRST_USER_ABORT_CODE
operator|+
name|__code
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_non_transactional_store
argument_list|(
name|void
operator|*
specifier|const
name|__addr
argument_list|,
name|long
name|long
specifier|const
name|__value
argument_list|)
block|{
name|__builtin_non_tx_store
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|__addr
argument_list|,
operator|(
name|uint64_t
operator|)
name|__value
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_nesting_depth
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|int
name|depth
init|=
name|__builtin_tx_nesting_depth
argument_list|()
decl_stmt|;
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|0
condition|)
return|return
name|depth
return|;
if|if
condition|(
name|tdb
operator|->
name|format
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|tdb
operator|->
name|nesting_depth
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Transaction failure diagnostics */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_user_abort
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
if|if
condition|(
name|tdb
operator|->
name|format
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|!
operator|!
operator|(
name|tdb
operator|->
name|abort_code
operator|>=
name|_HTM_FIRST_USER_ABORT_CODE
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_named_user_abort
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|,
name|unsigned
name|char
operator|*
name|__code
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
if|if
condition|(
name|tdb
operator|->
name|format
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tdb
operator|->
name|abort_code
operator|>=
name|_HTM_FIRST_USER_ABORT_CODE
condition|)
block|{
operator|*
name|__code
operator|=
name|tdb
operator|->
name|abort_code
operator|-
name|_HTM_FIRST_USER_ABORT_CODE
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_illegal
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
operator|(
name|tdb
operator|->
name|format
operator|==
literal|1
operator|&&
operator|(
name|tdb
operator|->
name|abort_code
operator|==
literal|4
comment|/* unfiltered program interruption */
operator|||
name|tdb
operator|->
name|abort_code
operator|==
literal|11
comment|/* restricted instruction */
operator|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_footprint_exceeded
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
operator|(
name|tdb
operator|->
name|format
operator|==
literal|1
operator|&&
operator|(
name|tdb
operator|->
name|abort_code
operator|==
literal|7
comment|/* fetch overflow */
operator|||
name|tdb
operator|->
name|abort_code
operator|==
literal|8
comment|/* store overflow */
operator|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_nested_too_deep
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
name|tdb
operator|->
name|format
operator|==
literal|1
operator|&&
name|tdb
operator|->
name|abort_code
operator|==
literal|13
return|;
comment|/* depth exceeded */
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_conflict
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
operator|(
name|tdb
operator|->
name|format
operator|==
literal|1
operator|&&
operator|(
name|tdb
operator|->
name|abort_code
operator|==
literal|9
comment|/* fetch conflict */
operator|||
name|tdb
operator|->
name|abort_code
operator|==
literal|10
comment|/* store conflict */
operator|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_is_failure_persistent
argument_list|(
name|long
specifier|const
name|__result
argument_list|)
block|{
return|return
name|__result
operator|==
name|_HTM_TBEGIN_PERSISTENT
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_failure_address
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
name|tdb
operator|->
name|atia
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|long
name|__attribute__
argument_list|(
operator|(
name|__always_inline__
operator|,
name|__nodebug__
operator|)
argument_list|)
name|__TM_failure_code
argument_list|(
name|void
operator|*
specifier|const
name|__tdb_ptr
argument_list|)
block|{
name|struct
name|__htm_tdb
modifier|*
name|tdb
init|=
operator|(
expr|struct
name|__htm_tdb
operator|*
operator|)
name|__tdb_ptr
decl_stmt|;
return|return
name|tdb
operator|->
name|abort_code
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __s390__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HTMXLINTRIN_H  */
end_comment

end_unit

