begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ToolChains.h - ToolChain Implementations ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_H
end_define

begin_include
include|#
directive|include
file|"Tools.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Cuda.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/Action.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/Multilib.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/ToolChain.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|driver
block|{
name|namespace
name|toolchains
block|{
comment|/// Generic_GCC - A tool chain using the 'gcc' command to perform
comment|/// all subcommands; this relies on gcc translating the majority of
comment|/// command line options.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Generic_GCC
range|:
name|public
name|ToolChain
block|{
name|public
operator|:
comment|/// \brief Struct to store and manipulate GCC versions.
comment|///
comment|/// We rely on assumptions about the form and structure of GCC version
comment|/// numbers: they consist of at most three '.'-separated components, and each
comment|/// component is a non-negative integer except for the last component. For
comment|/// the last component we are very flexible in order to tolerate release
comment|/// candidates or 'x' wildcards.
comment|///
comment|/// Note that the ordering established among GCCVersions is based on the
comment|/// preferred version string to use. For example we prefer versions without
comment|/// a hard-coded patch number to those with a hard coded patch number.
comment|///
comment|/// Currently this doesn't provide any logic for textual suffixes to patches
comment|/// in the way that (for example) Debian's version format does. If that ever
comment|/// becomes necessary, it can be added.
expr|struct
name|GCCVersion
block|{
comment|/// \brief The unparsed text of the version.
name|std
operator|::
name|string
name|Text
block|;
comment|/// \brief The parsed major, minor, and patch numbers.
name|int
name|Major
block|,
name|Minor
block|,
name|Patch
block|;
comment|/// \brief The text of the parsed major, and major+minor versions.
name|std
operator|::
name|string
name|MajorStr
block|,
name|MinorStr
block|;
comment|/// \brief Any textual suffix on the patch number.
name|std
operator|::
name|string
name|PatchSuffix
block|;
specifier|static
name|GCCVersion
name|Parse
argument_list|(
argument|StringRef VersionText
argument_list|)
block|;
name|bool
name|isOlderThan
argument_list|(
argument|int RHSMajor
argument_list|,
argument|int RHSMinor
argument_list|,
argument|int RHSPatch
argument_list|,
argument|StringRef RHSPatchSuffix = StringRef()
argument_list|)
specifier|const
block|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|isOlderThan
argument_list|(
name|RHS
operator|.
name|Major
argument_list|,
name|RHS
operator|.
name|Minor
argument_list|,
name|RHS
operator|.
name|Patch
argument_list|,
name|RHS
operator|.
name|PatchSuffix
argument_list|)
return|;
block|}
name|bool
name|operator
operator|>
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|RHS
operator|<
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|>
name|RHS
operator|)
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|RHS
operator|)
return|;
block|}
expr|}
block|;
comment|/// \brief This is a class to find a viable GCC installation for Clang to
comment|/// use.
comment|///
comment|/// This class tries to find a GCC installation on the system, and report
comment|/// information about it. It starts from the host information provided to the
comment|/// Driver, and has logic for fuzzing that where appropriate.
name|class
name|GCCInstallationDetector
block|{
name|bool
name|IsValid
block|;
name|llvm
operator|::
name|Triple
name|GCCTriple
block|;
specifier|const
name|Driver
operator|&
name|D
block|;
comment|// FIXME: These might be better as path objects.
name|std
operator|::
name|string
name|GCCInstallPath
block|;
name|std
operator|::
name|string
name|GCCParentLibPath
block|;
comment|/// The primary multilib appropriate for the given flags.
name|Multilib
name|SelectedMultilib
block|;
comment|/// On Biarch systems, this corresponds to the default multilib when
comment|/// targeting the non-default multilib. Otherwise, it is empty.
name|llvm
operator|::
name|Optional
operator|<
name|Multilib
operator|>
name|BiarchSibling
block|;
name|GCCVersion
name|Version
block|;
comment|// We retain the list of install paths that were considered and rejected in
comment|// order to print out detailed information in verbose mode.
name|std
operator|::
name|set
operator|<
name|std
operator|::
name|string
operator|>
name|CandidateGCCInstallPaths
block|;
comment|/// The set of multilibs that the detected installation supports.
name|MultilibSet
name|Multilibs
block|;
name|public
operator|:
name|explicit
name|GCCInstallationDetector
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|)
operator|:
name|IsValid
argument_list|(
name|false
argument_list|)
block|,
name|D
argument_list|(
argument|D
argument_list|)
block|{}
name|void
name|init
argument_list|(
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|TargetTriple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|,
name|ArrayRef
operator|<
name|std
operator|::
name|string
operator|>
name|ExtraTripleAliases
operator|=
name|None
argument_list|)
block|;
comment|/// \brief Check whether we detected a valid GCC install.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|IsValid
return|;
block|}
comment|/// \brief Get the GCC triple for the detected install.
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|getTriple
argument_list|()
specifier|const
block|{
return|return
name|GCCTriple
return|;
block|}
comment|/// \brief Get the detected GCC installation path.
name|StringRef
name|getInstallPath
argument_list|()
specifier|const
block|{
return|return
name|GCCInstallPath
return|;
block|}
comment|/// \brief Get the detected GCC parent lib path.
name|StringRef
name|getParentLibPath
argument_list|()
specifier|const
block|{
return|return
name|GCCParentLibPath
return|;
block|}
comment|/// \brief Get the detected Multilib
specifier|const
name|Multilib
operator|&
name|getMultilib
argument_list|()
specifier|const
block|{
return|return
name|SelectedMultilib
return|;
block|}
comment|/// \brief Get the whole MultilibSet
specifier|const
name|MultilibSet
operator|&
name|getMultilibs
argument_list|()
specifier|const
block|{
return|return
name|Multilibs
return|;
block|}
comment|/// Get the biarch sibling multilib (if it exists).
comment|/// \return true iff such a sibling exists
name|bool
name|getBiarchSibling
argument_list|(
argument|Multilib&M
argument_list|)
specifier|const
block|;
comment|/// \brief Get the detected GCC version string.
specifier|const
name|GCCVersion
operator|&
name|getVersion
argument_list|()
specifier|const
block|{
return|return
name|Version
return|;
block|}
comment|/// \brief Print information about the detected GCC installation.
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|private
operator|:
specifier|static
name|void
name|CollectLibDirsAndTriples
argument_list|(
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|TargetTriple
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|BiarchTriple
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|LibDirs
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|TripleAliases
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|BiarchLibDirs
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|BiarchTripleAliases
argument_list|)
block|;
name|void
name|ScanLibDirForGCCTriple
argument_list|(
argument|const llvm::Triple&TargetArch
argument_list|,
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|const std::string&LibDir
argument_list|,
argument|StringRef CandidateTriple
argument_list|,
argument|bool NeedsBiarchSuffix = false
argument_list|)
block|;
name|void
name|scanLibDirForGCCTripleSolaris
argument_list|(
argument|const llvm::Triple&TargetArch
argument_list|,
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|const std::string&LibDir
argument_list|,
argument|StringRef CandidateTriple
argument_list|,
argument|bool NeedsBiarchSuffix = false
argument_list|)
block|;   }
block|;
name|protected
operator|:
name|GCCInstallationDetector
name|GCCInstallation
block|;
comment|// \brief A class to find a viable CUDA installation
name|class
name|CudaInstallationDetector
block|{
name|private
operator|:
specifier|const
name|Driver
operator|&
name|D
block|;
name|bool
name|IsValid
operator|=
name|false
block|;
name|CudaVersion
name|Version
operator|=
name|CudaVersion
operator|::
name|UNKNOWN
block|;
name|std
operator|::
name|string
name|InstallPath
block|;
name|std
operator|::
name|string
name|BinPath
block|;
name|std
operator|::
name|string
name|LibPath
block|;
name|std
operator|::
name|string
name|LibDevicePath
block|;
name|std
operator|::
name|string
name|IncludePath
block|;
name|llvm
operator|::
name|StringMap
operator|<
name|std
operator|::
name|string
operator|>
name|LibDeviceMap
block|;
comment|// CUDA architectures for which we have raised an error in
comment|// CheckCudaVersionSupportsArch.
name|mutable
name|llvm
operator|::
name|SmallSet
operator|<
name|CudaArch
block|,
literal|4
operator|>
name|ArchsWithVersionTooLowErrors
block|;
name|public
operator|:
name|CudaInstallationDetector
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|)
operator|:
name|D
argument_list|(
argument|D
argument_list|)
block|{}
name|void
name|init
argument_list|(
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|TargetTriple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
comment|/// \brief Emit an error if Version does not support the given Arch.
comment|///
comment|/// If either Version or Arch is unknown, does not emit an error.  Emits at
comment|/// most one error per Arch.
name|void
name|CheckCudaVersionSupportsArch
argument_list|(
argument|CudaArch Arch
argument_list|)
specifier|const
block|;
comment|/// \brief Check whether we detected a valid Cuda install.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|IsValid
return|;
block|}
comment|/// \brief Print information about the detected CUDA installation.
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
comment|/// \brief Get the deteced Cuda install's version.
name|CudaVersion
name|version
argument_list|()
specifier|const
block|{
return|return
name|Version
return|;
block|}
comment|/// \brief Get the detected Cuda installation path.
name|StringRef
name|getInstallPath
argument_list|()
specifier|const
block|{
return|return
name|InstallPath
return|;
block|}
comment|/// \brief Get the detected path to Cuda's bin directory.
name|StringRef
name|getBinPath
argument_list|()
specifier|const
block|{
return|return
name|BinPath
return|;
block|}
comment|/// \brief Get the detected Cuda Include path.
name|StringRef
name|getIncludePath
argument_list|()
specifier|const
block|{
return|return
name|IncludePath
return|;
block|}
comment|/// \brief Get the detected Cuda library path.
name|StringRef
name|getLibPath
argument_list|()
specifier|const
block|{
return|return
name|LibPath
return|;
block|}
comment|/// \brief Get the detected Cuda device library path.
name|StringRef
name|getLibDevicePath
argument_list|()
specifier|const
block|{
return|return
name|LibDevicePath
return|;
block|}
comment|/// \brief Get libdevice file for given architecture
name|std
operator|::
name|string
name|getLibDeviceFile
argument_list|(
argument|StringRef Gpu
argument_list|)
specifier|const
block|{
return|return
name|LibDeviceMap
operator|.
name|lookup
argument_list|(
name|Gpu
argument_list|)
return|;
block|}
expr|}
block|;
name|CudaInstallationDetector
name|CudaInstallation
block|;
name|public
operator|:
name|Generic_GCC
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|Generic_GCC
argument_list|()
name|override
block|;
name|void
name|printVerboseInfo
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
comment|/// \name ToolChain Implementation Helper Functions
comment|/// @{
comment|/// \brief Check whether the target triple's architecture is 64-bits.
name|bool
name|isTarget64Bit
argument_list|()
specifier|const
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|isArch64Bit
argument_list|()
return|;
block|}
comment|/// \brief Check whether the target triple's architecture is 32-bits.
name|bool
name|isTarget32Bit
argument_list|()
specifier|const
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|isArch32Bit
argument_list|()
return|;
block|}
name|bool
name|addLibStdCXXIncludePaths
argument_list|(
argument|Twine Base
argument_list|,
argument|Twine Suffix
argument_list|,
argument|StringRef GCCTriple
argument_list|,
argument|StringRef GCCMultiarchTriple
argument_list|,
argument|StringRef TargetMultiarchTriple
argument_list|,
argument|Twine IncludeSuffix
argument_list|,
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
block|;
comment|/// @}
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Preprocessor
operator|>
name|Preprocess
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Compiler
operator|>
name|Compile
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MachO
operator|:
name|public
name|ToolChain
block|{
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|Lipo
operator|>
name|Lipo
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|Dsymutil
operator|>
name|Dsymutil
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|VerifyDebug
operator|>
name|VerifyDebug
block|;
name|public
operator|:
name|MachO
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|MachO
argument_list|()
name|override
block|;
comment|/// @name MachO specific toolchain API
comment|/// {
comment|/// Get the "MachO" arch name for a particular compiler invocation. For
comment|/// example, Apple treats different ARM variations as distinct architectures.
name|StringRef
name|getMachOArchName
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
block|;
comment|/// Add the linker arguments to link the ARC runtime library.
name|virtual
name|void
name|AddLinkARCArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{}
comment|/// Add the linker arguments to link the compiler runtime library.
name|virtual
name|void
name|AddLinkRuntimeLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|addStartObjectFileArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{   }
name|virtual
name|void
name|addMinVersionArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{}
comment|/// On some iOS platforms, kernel and kernel modules were built statically. Is
comment|/// this such a target?
name|virtual
name|bool
name|isKernelStatic
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// Is the target either iOS or an iOS simulator?
name|bool
name|isTargetIOSBased
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|void
name|AddLinkRuntimeLib
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|,
argument|StringRef DarwinLibName
argument_list|,
argument|bool AlwaysLink = false
argument_list|,
argument|bool IsEmbedded = false
argument_list|,
argument|bool AddRPath = false
argument_list|)
specifier|const
block|;
comment|/// Add any profiling runtime libraries that are needed. This is essentially a
comment|/// MachO specific version of addProfileRT in Tools.cpp.
name|void
name|addProfileRTLibs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|{
comment|// There aren't any profiling libs for embedded targets currently.
block|}
comment|/// }
comment|/// @name ToolChain Implementation
comment|/// {
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|types
operator|::
name|ID
name|LookupTypeForExtension
argument_list|(
argument|const char *Ext
argument_list|)
specifier|const
name|override
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsBlocksDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Always allow blocks on Apple; users interested in versioning are
comment|// expected to use /usr/include/Block.h.
return|return
name|true
return|;
block|}
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Default integrated assembler to on for Apple's MachO targets.
return|return
name|true
return|;
block|}
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsEncodeExtendedBlockSignatureDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Non-fragile ABI is default for everything but i386.
return|return
name|getTriple
argument_list|()
operator|.
name|getArch
argument_list|()
operator|!=
name|llvm
operator|::
name|Triple
operator|::
name|x86
return|;
block|}
name|bool
name|UseObjCMixedDispatch
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|RuntimeLibType
name|GetDefaultRuntimeLibType
argument_list|()
specifier|const
name|override
block|{
return|return
name|ToolChain
operator|::
name|RLT_CompilerRT
return|;
block|}
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsProfiling
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsObjCGC
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|UseDwarfDebugFlags
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
comment|/// }
expr|}
block|;
comment|/// Darwin - The base Darwin tool chain.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Darwin
operator|:
name|public
name|MachO
block|{
name|public
operator|:
comment|/// Whether the information on the target has been initialized.
comment|//
comment|// FIXME: This should be eliminated. What we want to do is make this part of
comment|// the "default target for arguments" selection process, once we get out of
comment|// the argument translation business.
name|mutable
name|bool
name|TargetInitialized
block|;    enum
name|DarwinPlatformKind
block|{
name|MacOS
block|,
name|IPhoneOS
block|,
name|IPhoneOSSimulator
block|,
name|TvOS
block|,
name|TvOSSimulator
block|,
name|WatchOS
block|,
name|WatchOSSimulator
block|}
block|;
name|mutable
name|DarwinPlatformKind
name|TargetPlatform
block|;
comment|/// The OS version we are targeting.
name|mutable
name|VersionTuple
name|TargetVersion
block|;
name|private
operator|:
name|void
name|AddDeploymentTarget
argument_list|(
argument|llvm::opt::DerivedArgList&Args
argument_list|)
specifier|const
block|;
name|public
operator|:
name|Darwin
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|Darwin
argument_list|()
name|override
block|;
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
comment|/// @name Apple Specific Toolchain Implementation
comment|/// {
name|void
name|addMinVersionArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|addStartObjectFileArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isKernelStatic
argument_list|()
specifier|const
name|override
block|{
return|return
operator|(
operator|!
operator|(
name|isTargetIPhoneOS
argument_list|()
operator|&&
operator|!
name|isIPhoneOSVersionLT
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|isTargetWatchOS
argument_list|()
operator|)
return|;
block|}
name|void
name|addProfileRTLibs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
comment|/// }
comment|/// @name Darwin specific Toolchain functions
comment|/// {
comment|// FIXME: Eliminate these ...Target functions and derive separate tool chains
comment|// for these targets and put version in constructor.
name|void
name|setTarget
argument_list|(
argument|DarwinPlatformKind Platform
argument_list|,
argument|unsigned Major
argument_list|,
argument|unsigned Minor
argument_list|,
argument|unsigned Micro
argument_list|)
specifier|const
block|{
comment|// FIXME: For now, allow reinitialization as long as values don't
comment|// change. This will go away when we move away from argument translation.
if|if
condition|(
name|TargetInitialized
operator|&&
name|TargetPlatform
operator|==
name|Platform
operator|&&
name|TargetVersion
operator|==
name|VersionTuple
argument_list|(
name|Major
argument_list|,
name|Minor
argument_list|,
name|Micro
argument_list|)
condition|)
return|return;
name|assert
argument_list|(
operator|!
name|TargetInitialized
operator|&&
literal|"Target already initialized!"
argument_list|)
block|;
name|TargetInitialized
operator|=
name|true
block|;
name|TargetPlatform
operator|=
name|Platform
block|;
name|TargetVersion
operator|=
name|VersionTuple
argument_list|(
name|Major
argument_list|,
name|Minor
argument_list|,
name|Micro
argument_list|)
block|;   }
name|bool
name|isTargetIPhoneOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|IPhoneOS
operator|||
name|TargetPlatform
operator|==
name|TvOS
return|;
block|}
name|bool
name|isTargetIOSSimulator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|IPhoneOSSimulator
operator|||
name|TargetPlatform
operator|==
name|TvOSSimulator
return|;
block|}
name|bool
name|isTargetIOSBased
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|isTargetIPhoneOS
argument_list|()
operator|||
name|isTargetIOSSimulator
argument_list|()
return|;
block|}
name|bool
name|isTargetTvOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|TvOS
return|;
block|}
name|bool
name|isTargetTvOSSimulator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|TvOSSimulator
return|;
block|}
name|bool
name|isTargetTvOSBased
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|TvOS
operator|||
name|TargetPlatform
operator|==
name|TvOSSimulator
return|;
block|}
name|bool
name|isTargetWatchOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|WatchOS
return|;
block|}
name|bool
name|isTargetWatchOSSimulator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|WatchOSSimulator
return|;
block|}
name|bool
name|isTargetWatchOSBased
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|WatchOS
operator|||
name|TargetPlatform
operator|==
name|WatchOSSimulator
return|;
block|}
name|bool
name|isTargetMacOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|MacOS
return|;
block|}
name|bool
name|isTargetInitialized
argument_list|()
specifier|const
block|{
return|return
name|TargetInitialized
return|;
block|}
name|VersionTuple
name|getTargetVersion
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetVersion
return|;
block|}
name|bool
name|isIPhoneOSVersionLT
argument_list|(
argument|unsigned V0
argument_list|,
argument|unsigned V1 =
literal|0
argument_list|,
argument|unsigned V2 =
literal|0
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|isTargetIOSBased
argument_list|()
operator|&&
literal|"Unexpected call for non iOS target!"
argument_list|)
block|;
return|return
name|TargetVersion
operator|<
name|VersionTuple
argument_list|(
name|V0
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|)
return|;
block|}
name|bool
name|isMacosxVersionLT
argument_list|(
argument|unsigned V0
argument_list|,
argument|unsigned V1 =
literal|0
argument_list|,
argument|unsigned V2 =
literal|0
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|isTargetMacOS
argument_list|()
operator|&&
literal|"Unexpected call for non OS X target!"
argument_list|)
block|;
return|return
name|TargetVersion
operator|<
name|VersionTuple
argument_list|(
name|V0
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|)
return|;
block|}
name|StringRef
name|getPlatformFamily
argument_list|()
specifier|const
block|;
specifier|static
name|StringRef
name|getSDKName
argument_list|(
argument|StringRef isysroot
argument_list|)
block|;
name|StringRef
name|getOSLibraryNameSuffix
argument_list|()
specifier|const
block|;
name|public
operator|:
comment|/// }
comment|/// @name ToolChain Implementation
comment|/// {
comment|// Darwin tools support multiple architecture (e.g., i386 and x86_64) and
comment|// most development is done against SDKs, so compiling for a different
comment|// architecture should not get any special treatment.
name|bool
name|isCrossCompiling
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetDefaultCXXStdlibType
argument_list|()
specifier|const
name|override
block|;
name|ObjCRuntime
name|getDefaultObjCRuntime
argument_list|(
argument|bool isNonFragile
argument_list|)
specifier|const
name|override
block|;
name|bool
name|hasBlocksRuntime
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseObjCMixedDispatch
argument_list|()
specifier|const
name|override
block|{
comment|// This is only used with the non-fragile ABI and non-legacy dispatch.
comment|// Mixed dispatch is used everywhere except OS X before 10.6.
return|return
operator|!
operator|(
name|isTargetMacOS
argument_list|()
operator|&&
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|)
operator|)
return|;
block|}
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
comment|// Stack protectors default to on for user code on 10.5,
comment|// and for everything in 10.6 and beyond
if|if
condition|(
name|isTargetIOSBased
argument_list|()
operator|||
name|isTargetWatchOSBased
argument_list|()
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|isTargetMacOS
argument_list|()
operator|&&
operator|!
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|isTargetMacOS
argument_list|()
operator|&&
operator|!
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|5
argument_list|)
operator|&&
operator|!
name|KernelOrKext
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
name|bool
name|SupportsObjCGC
argument_list|()
specifier|const
name|override
block|;
name|void
name|CheckObjCARC
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|SupportsEmbeddedBitcode
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|; }
block|;
comment|/// DarwinClang - The Darwin toolchain used by Clang.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|DarwinClang
operator|:
name|public
name|Darwin
block|{
name|public
operator|:
name|DarwinClang
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
comment|/// @name Apple ToolChain Implementation
comment|/// {
name|void
name|AddLinkRuntimeLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCCKextLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|addClangWarningOptions
argument_list|(
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddLinkARCArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
comment|// Until dtrace (via CTF) and LLDB can deal with distributed debug info,
comment|// Darwin defaults to standalone/full debug info.
name|bool
name|GetDefaultStandaloneDebug
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|llvm
operator|::
name|DebuggerKind
name|getDefaultDebuggerTuning
argument_list|()
specifier|const
name|override
block|{
return|return
name|llvm
operator|::
name|DebuggerKind
operator|::
name|LLDB
return|;
block|}
comment|/// }
name|private
operator|:
name|void
name|AddLinkSanitizerLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|,
argument|StringRef Sanitizer
argument_list|)
specifier|const
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Generic_ELF
operator|:
name|public
name|Generic_GCC
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|Generic_ELF
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
operator|:
name|Generic_GCC
argument_list|(
argument|D
argument_list|,
argument|Triple
argument_list|,
argument|Args
argument_list|)
block|{}
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CloudABI
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|CloudABI
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|{
return|return
name|ToolChain
operator|::
name|CST_Libcxx
return|;
block|}
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getDefaultSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Solaris
operator|:
name|public
name|Generic_GCC
block|{
name|public
operator|:
name|Solaris
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MinGW
operator|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|MinGW
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSEHExceptions
argument_list|()
specifier|const
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
name|std
operator|::
name|string
name|Base
block|;
name|std
operator|::
name|string
name|GccLibDir
block|;
name|std
operator|::
name|string
name|Ver
block|;
name|std
operator|::
name|string
name|Arch
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Preprocessor
operator|>
name|Preprocessor
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Compiler
operator|>
name|Compiler
block|;
name|void
name|findGccLibDir
argument_list|()
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Haiku
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Haiku
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|getArch
argument_list|()
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|x86_64
return|;
block|}
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|OpenBSD
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|OpenBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Bitrig
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Bitrig
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetDefaultCXXStdlibType
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|FreeBSD
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|FreeBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetDefaultCXXStdlibType
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
comment|// Until dtrace (via CTF) and LLDB can deal with distributed debug info,
comment|// FreeBSD defaults to standalone/full debug info.
name|bool
name|GetDefaultStandaloneDebug
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|NetBSD
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|NetBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetDefaultCXXStdlibType
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Minix
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Minix
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|DragonFly
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|DragonFly
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Linux
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Linux
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCudaIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddIAMCUIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|void
name|addProfileRTLibs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|virtual
name|std
operator|::
name|string
name|computeSysRoot
argument_list|()
specifier|const
block|;
name|virtual
name|std
operator|::
name|string
name|getDynamicLinker
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|ExtraOpts
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CudaToolChain
operator|:
name|public
name|Linux
block|{
name|public
operator|:
name|CudaToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
comment|// Never try to use the integrated assembler with CUDA; always fork out to
comment|// ptxas.
name|bool
name|useIntegratedAs
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|void
name|AddCudaIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
specifier|const
name|Generic_GCC
operator|::
name|CudaInstallationDetector
operator|&
name|cudaInstallation
argument_list|()
specifier|const
block|{
return|return
name|CudaInstallation
return|;
block|}
name|Generic_GCC
operator|::
name|CudaInstallationDetector
operator|&
name|cudaInstallation
argument_list|()
block|{
return|return
name|CudaInstallation
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
comment|// ptxas
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
comment|// fatbinary (ok, not really a linker)
block|}
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MipsLLVMToolChain
operator|:
name|public
name|Linux
block|{
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|MipsLLVMToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|getCompilerRT
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|StringRef Component
argument_list|,
argument|bool Shared = false
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|computeSysRoot
argument_list|()
specifier|const
name|override
block|;
name|RuntimeLibType
name|GetDefaultRuntimeLibType
argument_list|()
specifier|const
name|override
block|{
return|return
name|GCCInstallation
operator|.
name|isValid
argument_list|()
operator|?
name|RuntimeLibType
operator|::
name|RLT_Libgcc
operator|:
name|RuntimeLibType
operator|::
name|RLT_CompilerRT
return|;
block|}
name|private
operator|:
name|Multilib
name|SelectedMultilib
block|;
name|std
operator|::
name|string
name|LibSuffix
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|LanaiToolChain
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|LanaiToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
operator|:
name|Generic_ELF
argument_list|(
argument|D
argument_list|,
argument|Triple
argument_list|,
argument|Args
argument_list|)
block|{}
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|HexagonToolChain
operator|:
name|public
name|Linux
block|{
name|protected
operator|:
name|GCCVersion
name|GCCLibAndIncVersion
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|HexagonToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|HexagonToolChain
argument_list|()
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|StringRef
name|GetGCCLibAndIncVersion
argument_list|()
specifier|const
block|{
return|return
name|GCCLibAndIncVersion
operator|.
name|Text
return|;
block|}
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|std
operator|::
name|string
name|getHexagonTargetDir
argument_list|(
argument|const std::string&InstalledDir
argument_list|,
argument|const SmallVectorImpl<std::string>&PrefixDirs
argument_list|)
specifier|const
block|;
name|void
name|getHexagonLibraryPaths
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|ToolChain::path_list&LibPaths
argument_list|)
specifier|const
block|;
specifier|static
specifier|const
name|StringRef
name|GetDefaultCPU
argument_list|()
block|;
specifier|static
specifier|const
name|StringRef
name|GetTargetCPUVersion
argument_list|(
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
specifier|static
name|Optional
operator|<
name|unsigned
operator|>
name|getSmallDataThreshold
argument_list|(
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|AMDGPUToolChain
operator|:
name|public
name|Generic_ELF
block|{
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|AMDGPUToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|NaClToolChain
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|NaClToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|getArch
argument_list|()
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|mipsel
return|;
block|}
comment|// Get the path to the file containing NaCl's ARM macros.
comment|// It lives in NaClToolChain because the ARMAssembler tool needs a
comment|// const char * that it can pass around,
specifier|const
name|char
operator|*
name|GetNaClArmMacrosPath
argument_list|()
specifier|const
block|{
return|return
name|NaClArmMacrosPath
operator|.
name|c_str
argument_list|()
return|;
block|}
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
name|std
operator|::
name|string
name|NaClArmMacrosPath
block|; }
block|;
comment|/// TCEToolChain - A tool chain using the llvm bitcode tools to perform
comment|/// all subcommands. See http://tce.cs.tut.fi for our peculiar target.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|TCEToolChain
operator|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|TCEToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|TCEToolChain
argument_list|()
name|override
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MSVCToolChain
operator|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|MSVCToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|getWindowsSDKDir
argument_list|(
argument|std::string&path
argument_list|,
argument|int&major
argument_list|,
argument|std::string&windowsSDKIncludeVersion
argument_list|,
argument|std::string&windowsSDKLibVersion
argument_list|)
specifier|const
block|;
name|bool
name|getWindowsSDKLibraryPath
argument_list|(
argument|std::string&path
argument_list|)
specifier|const
block|;
comment|/// \brief Check if Universal CRT should be used if available
name|bool
name|useUniversalCRT
argument_list|(
argument|std::string&visualStudioDir
argument_list|)
specifier|const
block|;
name|bool
name|getUniversalCRTSdkDir
argument_list|(
argument|std::string&path
argument_list|,
argument|std::string&ucrtVersion
argument_list|)
specifier|const
block|;
name|bool
name|getUniversalCRTLibraryPath
argument_list|(
argument|std::string&path
argument_list|)
specifier|const
block|;
name|bool
name|getVisualStudioInstallDir
argument_list|(
argument|std::string&path
argument_list|)
specifier|const
block|;
name|bool
name|getVisualStudioBinariesFolder
argument_list|(
argument|const char *clangProgramPath
argument_list|,
argument|std::string&path
argument_list|)
specifier|const
block|;
name|VersionTuple
name|getMSVCVersionFromExe
argument_list|()
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|void
name|AddSystemIncludeWithSubfolder
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|,
argument|const std::string&folder
argument_list|,
argument|const Twine&subfolder1
argument_list|,
argument|const Twine&subfolder2 =
literal|""
argument_list|,
argument|const Twine&subfolder3 =
literal|""
argument_list|)
specifier|const
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CrossWindowsToolChain
operator|:
name|public
name|Generic_GCC
block|{
name|public
operator|:
name|CrossWindowsToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|T
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|unsigned
name|int
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|XCoreToolChain
operator|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|XCoreToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsProfiling
argument_list|()
specifier|const
name|override
block|;
name|bool
name|hasBlocksRuntime
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// MyriadToolChain - A tool chain using either clang or the external compiler
comment|/// installed by the Movidius SDK to perform all subcommands.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MyriadToolChain
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|MyriadToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|MyriadToolChain
argument_list|()
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|SelectTool
argument_list|(
argument|const JobAction&JA
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultDwarfVersion
argument_list|()
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isShaveCompilation
argument_list|(
argument|const llvm::Triple&T
argument_list|)
specifier|const
block|{
return|return
name|T
operator|.
name|getArch
argument_list|()
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|shave
return|;
block|}
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|Tool
operator|>
name|Compiler
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|Tool
operator|>
name|Assembler
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|WebAssembly
name|final
operator|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|WebAssembly
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|private
operator|:
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseObjCMixedDispatch
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|hasBlocksRuntime
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsObjCGC
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsProfiling
argument_list|()
specifier|const
name|override
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|RuntimeLibType
name|GetDefaultRuntimeLibType
argument_list|()
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|PS4CPU
operator|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|PS4CPU
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|2
return|;
comment|// SSPStrong
block|}
name|llvm
operator|::
name|DebuggerKind
name|getDefaultDebuggerTuning
argument_list|()
specifier|const
name|override
block|{
return|return
name|llvm
operator|::
name|DebuggerKind
operator|::
name|SCE
return|;
block|}
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
block|;  }
comment|// end namespace toolchains
block|}
comment|// end namespace driver
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_H
end_comment

end_unit

