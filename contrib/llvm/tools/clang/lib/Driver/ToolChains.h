begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ToolChains.h - ToolChain Implementations ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_H
end_define

begin_include
include|#
directive|include
file|"Tools.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/Action.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/Multilib.h"
end_include

begin_include
include|#
directive|include
file|"clang/Driver/ToolChain.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|driver
block|{
name|namespace
name|toolchains
block|{
comment|/// Generic_GCC - A tool chain using the 'gcc' command to perform
comment|/// all subcommands; this relies on gcc translating the majority of
comment|/// command line options.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Generic_GCC
range|:
name|public
name|ToolChain
block|{
name|protected
operator|:
comment|/// \brief Struct to store and manipulate GCC versions.
comment|///
comment|/// We rely on assumptions about the form and structure of GCC version
comment|/// numbers: they consist of at most three '.'-separated components, and each
comment|/// component is a non-negative integer except for the last component. For
comment|/// the last component we are very flexible in order to tolerate release
comment|/// candidates or 'x' wildcards.
comment|///
comment|/// Note that the ordering established among GCCVersions is based on the
comment|/// preferred version string to use. For example we prefer versions without
comment|/// a hard-coded patch number to those with a hard coded patch number.
comment|///
comment|/// Currently this doesn't provide any logic for textual suffixes to patches
comment|/// in the way that (for example) Debian's version format does. If that ever
comment|/// becomes necessary, it can be added.
expr|struct
name|GCCVersion
block|{
comment|/// \brief The unparsed text of the version.
name|std
operator|::
name|string
name|Text
block|;
comment|/// \brief The parsed major, minor, and patch numbers.
name|int
name|Major
block|,
name|Minor
block|,
name|Patch
block|;
comment|/// \brief The text of the parsed major, and major+minor versions.
name|std
operator|::
name|string
name|MajorStr
block|,
name|MinorStr
block|;
comment|/// \brief Any textual suffix on the patch number.
name|std
operator|::
name|string
name|PatchSuffix
block|;
specifier|static
name|GCCVersion
name|Parse
argument_list|(
argument|StringRef VersionText
argument_list|)
block|;
name|bool
name|isOlderThan
argument_list|(
argument|int RHSMajor
argument_list|,
argument|int RHSMinor
argument_list|,
argument|int RHSPatch
argument_list|,
argument|StringRef RHSPatchSuffix = StringRef()
argument_list|)
specifier|const
block|;
name|bool
name|operator
operator|<
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|isOlderThan
argument_list|(
name|RHS
operator|.
name|Major
argument_list|,
name|RHS
operator|.
name|Minor
argument_list|,
name|RHS
operator|.
name|Patch
argument_list|,
name|RHS
operator|.
name|PatchSuffix
argument_list|)
return|;
block|}
name|bool
name|operator
operator|>
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|RHS
operator|<
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|>
name|RHS
operator|)
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|GCCVersion
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|RHS
operator|)
return|;
block|}
expr|}
block|;
comment|/// \brief This is a class to find a viable GCC installation for Clang to
comment|/// use.
comment|///
comment|/// This class tries to find a GCC installation on the system, and report
comment|/// information about it. It starts from the host information provided to the
comment|/// Driver, and has logic for fuzzing that where appropriate.
name|class
name|GCCInstallationDetector
block|{
name|bool
name|IsValid
block|;
name|llvm
operator|::
name|Triple
name|GCCTriple
block|;
comment|// FIXME: These might be better as path objects.
name|std
operator|::
name|string
name|GCCInstallPath
block|;
name|std
operator|::
name|string
name|GCCParentLibPath
block|;
comment|/// The primary multilib appropriate for the given flags.
name|Multilib
name|SelectedMultilib
block|;
comment|/// On Biarch systems, this corresponds to the default multilib when
comment|/// targeting the non-default multilib. Otherwise, it is empty.
name|llvm
operator|::
name|Optional
operator|<
name|Multilib
operator|>
name|BiarchSibling
block|;
name|GCCVersion
name|Version
block|;
comment|// We retain the list of install paths that were considered and rejected in
comment|// order to print out detailed information in verbose mode.
name|std
operator|::
name|set
operator|<
name|std
operator|::
name|string
operator|>
name|CandidateGCCInstallPaths
block|;
comment|/// The set of multilibs that the detected installation supports.
name|MultilibSet
name|Multilibs
block|;
name|public
operator|:
name|GCCInstallationDetector
argument_list|()
operator|:
name|IsValid
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|init
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|TargetTriple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
comment|/// \brief Check whether we detected a valid GCC install.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|IsValid
return|;
block|}
comment|/// \brief Get the GCC triple for the detected install.
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|getTriple
argument_list|()
specifier|const
block|{
return|return
name|GCCTriple
return|;
block|}
comment|/// \brief Get the detected GCC installation path.
name|StringRef
name|getInstallPath
argument_list|()
specifier|const
block|{
return|return
name|GCCInstallPath
return|;
block|}
comment|/// \brief Get the detected GCC parent lib path.
name|StringRef
name|getParentLibPath
argument_list|()
specifier|const
block|{
return|return
name|GCCParentLibPath
return|;
block|}
comment|/// \brief Get the detected Multilib
specifier|const
name|Multilib
operator|&
name|getMultilib
argument_list|()
specifier|const
block|{
return|return
name|SelectedMultilib
return|;
block|}
comment|/// \brief Get the whole MultilibSet
specifier|const
name|MultilibSet
operator|&
name|getMultilibs
argument_list|()
specifier|const
block|{
return|return
name|Multilibs
return|;
block|}
comment|/// Get the biarch sibling multilib (if it exists).
comment|/// \return true iff such a sibling exists
name|bool
name|getBiarchSibling
argument_list|(
argument|Multilib&M
argument_list|)
specifier|const
block|;
comment|/// \brief Get the detected GCC version string.
specifier|const
name|GCCVersion
operator|&
name|getVersion
argument_list|()
specifier|const
block|{
return|return
name|Version
return|;
block|}
comment|/// \brief Print information about the detected GCC installation.
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|;
name|private
operator|:
specifier|static
name|void
name|CollectLibDirsAndTriples
argument_list|(
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|TargetTriple
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|BiarchTriple
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|LibDirs
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|TripleAliases
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|BiarchLibDirs
argument_list|,
name|SmallVectorImpl
operator|<
name|StringRef
operator|>
operator|&
name|BiarchTripleAliases
argument_list|)
block|;
name|void
name|ScanLibDirForGCCTriple
argument_list|(
argument|const llvm::Triple&TargetArch
argument_list|,
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|const std::string&LibDir
argument_list|,
argument|StringRef CandidateTriple
argument_list|,
argument|bool NeedsBiarchSuffix = false
argument_list|)
block|;   }
block|;
name|GCCInstallationDetector
name|GCCInstallation
block|;
name|public
operator|:
name|Generic_GCC
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|Generic_GCC
argument_list|()
name|override
block|;
name|void
name|printVerboseInfo
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
comment|/// \name ToolChain Implementation Helper Functions
comment|/// @{
comment|/// \brief Check whether the target triple's architecture is 64-bits.
name|bool
name|isTarget64Bit
argument_list|()
specifier|const
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|isArch64Bit
argument_list|()
return|;
block|}
comment|/// \brief Check whether the target triple's architecture is 32-bits.
name|bool
name|isTarget32Bit
argument_list|()
specifier|const
block|{
return|return
name|getTriple
argument_list|()
operator|.
name|isArch32Bit
argument_list|()
return|;
block|}
comment|/// @}
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Preprocessor
operator|>
name|Preprocess
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Compiler
operator|>
name|Compile
block|; }
block|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MachO
operator|:
name|public
name|ToolChain
block|{
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|Lipo
operator|>
name|Lipo
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|Dsymutil
operator|>
name|Dsymutil
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|darwin
operator|::
name|VerifyDebug
operator|>
name|VerifyDebug
block|;
name|public
operator|:
name|MachO
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|MachO
argument_list|()
name|override
block|;
comment|/// @name MachO specific toolchain API
comment|/// {
comment|/// Get the "MachO" arch name for a particular compiler invocation. For
comment|/// example, Apple treats different ARM variations as distinct architectures.
name|StringRef
name|getMachOArchName
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
block|;
comment|/// Add the linker arguments to link the ARC runtime library.
name|virtual
name|void
name|AddLinkARCArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{}
comment|/// Add the linker arguments to link the compiler runtime library.
name|virtual
name|void
name|AddLinkRuntimeLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|addStartObjectFileArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{   }
name|virtual
name|void
name|addMinVersionArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{}
comment|/// On some iOS platforms, kernel and kernel modules were built statically. Is
comment|/// this such a target?
name|virtual
name|bool
name|isKernelStatic
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// Is the target either iOS or an iOS simulator?
name|bool
name|isTargetIOSBased
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|void
name|AddLinkRuntimeLib
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|,
argument|StringRef DarwinLibName
argument_list|,
argument|bool AlwaysLink = false
argument_list|,
argument|bool IsEmbedded = false
argument_list|,
argument|bool AddRPath = false
argument_list|)
specifier|const
block|;
comment|/// Add any profiling runtime libraries that are needed. This is essentially a
comment|/// MachO specific version of addProfileRT in Tools.cpp.
name|virtual
name|void
name|addProfileRTLibs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
block|{
comment|// There aren't any profiling libs for embedded targets currently.
block|}
comment|/// }
comment|/// @name ToolChain Implementation
comment|/// {
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|types
operator|::
name|ID
name|LookupTypeForExtension
argument_list|(
argument|const char *Ext
argument_list|)
specifier|const
name|override
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsBlocksDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Always allow blocks on Apple; users interested in versioning are
comment|// expected to use /usr/include/Block.h.
return|return
name|true
return|;
block|}
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Default integrated assembler to on for Apple's MachO targets.
return|return
name|true
return|;
block|}
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsEncodeExtendedBlockSignatureDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
comment|// Non-fragile ABI is default for everything but i386.
return|return
name|getTriple
argument_list|()
operator|.
name|getArch
argument_list|()
operator|!=
name|llvm
operator|::
name|Triple
operator|::
name|x86
return|;
block|}
name|bool
name|UseObjCMixedDispatch
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|RuntimeLibType
name|GetDefaultRuntimeLibType
argument_list|()
specifier|const
name|override
block|{
return|return
name|ToolChain
operator|::
name|RLT_CompilerRT
return|;
block|}
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsProfiling
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsObjCGC
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|UseDwarfDebugFlags
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
comment|/// }
expr|}
block|;
comment|/// Darwin - The base Darwin tool chain.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Darwin
operator|:
name|public
name|MachO
block|{
name|public
operator|:
comment|/// Whether the information on the target has been initialized.
comment|//
comment|// FIXME: This should be eliminated. What we want to do is make this part of
comment|// the "default target for arguments" selection process, once we get out of
comment|// the argument translation business.
name|mutable
name|bool
name|TargetInitialized
block|;    enum
name|DarwinPlatformKind
block|{
name|MacOS
block|,
name|IPhoneOS
block|,
name|IPhoneOSSimulator
block|}
block|;
name|mutable
name|DarwinPlatformKind
name|TargetPlatform
block|;
comment|/// The OS version we are targeting.
name|mutable
name|VersionTuple
name|TargetVersion
block|;
name|private
operator|:
name|void
name|AddDeploymentTarget
argument_list|(
argument|llvm::opt::DerivedArgList&Args
argument_list|)
specifier|const
block|;
name|public
operator|:
name|Darwin
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|Darwin
argument_list|()
name|override
block|;
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
comment|/// @name Apple Specific Toolchain Implementation
comment|/// {
name|void
name|addMinVersionArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|addStartObjectFileArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isKernelStatic
argument_list|()
specifier|const
name|override
block|{
return|return
operator|!
name|isTargetIPhoneOS
argument_list|()
operator|||
name|isIPhoneOSVersionLT
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|addProfileRTLibs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
comment|/// }
comment|/// @name Darwin specific Toolchain functions
comment|/// {
comment|// FIXME: Eliminate these ...Target functions and derive separate tool chains
comment|// for these targets and put version in constructor.
name|void
name|setTarget
argument_list|(
argument|DarwinPlatformKind Platform
argument_list|,
argument|unsigned Major
argument_list|,
argument|unsigned Minor
argument_list|,
argument|unsigned Micro
argument_list|)
specifier|const
block|{
comment|// FIXME: For now, allow reinitialization as long as values don't
comment|// change. This will go away when we move away from argument translation.
if|if
condition|(
name|TargetInitialized
operator|&&
name|TargetPlatform
operator|==
name|Platform
operator|&&
name|TargetVersion
operator|==
name|VersionTuple
argument_list|(
name|Major
argument_list|,
name|Minor
argument_list|,
name|Micro
argument_list|)
condition|)
return|return;
name|assert
argument_list|(
operator|!
name|TargetInitialized
operator|&&
literal|"Target already initialized!"
argument_list|)
block|;
name|TargetInitialized
operator|=
name|true
block|;
name|TargetPlatform
operator|=
name|Platform
block|;
name|TargetVersion
operator|=
name|VersionTuple
argument_list|(
name|Major
argument_list|,
name|Minor
argument_list|,
name|Micro
argument_list|)
block|;   }
name|bool
name|isTargetIPhoneOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|IPhoneOS
return|;
block|}
name|bool
name|isTargetIOSSimulator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|IPhoneOSSimulator
return|;
block|}
name|bool
name|isTargetIOSBased
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|isTargetIPhoneOS
argument_list|()
operator|||
name|isTargetIOSSimulator
argument_list|()
return|;
block|}
name|bool
name|isTargetMacOS
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetPlatform
operator|==
name|MacOS
return|;
block|}
name|bool
name|isTargetInitialized
argument_list|()
specifier|const
block|{
return|return
name|TargetInitialized
return|;
block|}
name|VersionTuple
name|getTargetVersion
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|TargetInitialized
operator|&&
literal|"Target not initialized!"
argument_list|)
block|;
return|return
name|TargetVersion
return|;
block|}
name|bool
name|isIPhoneOSVersionLT
argument_list|(
argument|unsigned V0
argument_list|,
argument|unsigned V1 =
literal|0
argument_list|,
argument|unsigned V2 =
literal|0
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|isTargetIOSBased
argument_list|()
operator|&&
literal|"Unexpected call for non iOS target!"
argument_list|)
block|;
return|return
name|TargetVersion
operator|<
name|VersionTuple
argument_list|(
name|V0
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|)
return|;
block|}
name|bool
name|isMacosxVersionLT
argument_list|(
argument|unsigned V0
argument_list|,
argument|unsigned V1 =
literal|0
argument_list|,
argument|unsigned V2 =
literal|0
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|isTargetMacOS
argument_list|()
operator|&&
literal|"Unexpected call for non OS X target!"
argument_list|)
block|;
return|return
name|TargetVersion
operator|<
name|VersionTuple
argument_list|(
name|V0
argument_list|,
name|V1
argument_list|,
name|V2
argument_list|)
return|;
block|}
name|public
operator|:
comment|/// }
comment|/// @name ToolChain Implementation
comment|/// {
comment|// Darwin tools support multiple architecture (e.g., i386 and x86_64) and
comment|// most development is done against SDKs, so compiling for a different
comment|// architecture should not get any special treatment.
name|bool
name|isCrossCompiling
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|llvm
operator|::
name|opt
operator|::
name|DerivedArgList
operator|*
name|TranslateArgs
argument_list|(
argument|const llvm::opt::DerivedArgList&Args
argument_list|,
argument|const char *BoundArch
argument_list|)
specifier|const
name|override
block|;
name|ObjCRuntime
name|getDefaultObjCRuntime
argument_list|(
argument|bool isNonFragile
argument_list|)
specifier|const
name|override
block|;
name|bool
name|hasBlocksRuntime
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseObjCMixedDispatch
argument_list|()
specifier|const
name|override
block|{
comment|// This is only used with the non-fragile ABI and non-legacy dispatch.
comment|// Mixed dispatch is used everywhere except OS X before 10.6.
return|return
operator|!
operator|(
name|isTargetMacOS
argument_list|()
operator|&&
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|)
operator|)
return|;
block|}
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
comment|// Stack protectors default to on for user code on 10.5,
comment|// and for everything in 10.6 and beyond
if|if
condition|(
name|isTargetIOSBased
argument_list|()
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|isTargetMacOS
argument_list|()
operator|&&
operator|!
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|isTargetMacOS
argument_list|()
operator|&&
operator|!
name|isMacosxVersionLT
argument_list|(
literal|10
argument_list|,
literal|5
argument_list|)
operator|&&
operator|!
name|KernelOrKext
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
name|bool
name|SupportsObjCGC
argument_list|()
specifier|const
name|override
block|;
name|void
name|CheckObjCARC
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// DarwinClang - The Darwin toolchain used by Clang.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|DarwinClang
range|:
name|public
name|Darwin
block|{
name|public
operator|:
name|DarwinClang
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
comment|/// @name Apple ToolChain Implementation
comment|/// {
name|void
name|AddLinkRuntimeLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCCKextLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|void
name|addClangWarningOptions
argument_list|(
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddLinkARCArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
comment|/// }
name|private
operator|:
name|void
name|AddLinkSanitizerLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|,
argument|StringRef Sanitizer
argument_list|)
specifier|const
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Generic_ELF
range|:
name|public
name|Generic_GCC
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|public
operator|:
name|Generic_ELF
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
operator|:
name|Generic_GCC
argument_list|(
argument|D
argument_list|,
argument|Triple
argument_list|,
argument|Args
argument_list|)
block|{}
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CloudABI
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|CloudABI
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|{
return|return
name|ToolChain
operator|::
name|CST_Libcxx
return|;
block|}
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Solaris
range|:
name|public
name|Generic_GCC
block|{
name|public
operator|:
name|Solaris
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MinGW
range|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|MinGW
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|UseSEHExceptions
argument_list|()
specifier|const
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
name|std
operator|::
name|string
name|Base
block|;
name|std
operator|::
name|string
name|GccLibDir
block|;
name|std
operator|::
name|string
name|Arch
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Preprocessor
operator|>
name|Preprocessor
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|tools
operator|::
name|gcc
operator|::
name|Compiler
operator|>
name|Compiler
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|OpenBSD
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|OpenBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|2
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Bitrig
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Bitrig
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|FreeBSD
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|FreeBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|UseSjLjExceptions
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|NetBSD
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|NetBSD
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|bool
name|IsObjCNonFragileABIDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Minix
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Minix
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|DragonFly
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|DragonFly
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Linux
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|Linux
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|HasNativeLLVMSupport
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|Linker
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|ExtraOpts
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
specifier|static
name|bool
name|addLibStdCXXIncludePaths
argument_list|(
argument|Twine Base
argument_list|,
argument|Twine Suffix
argument_list|,
argument|StringRef GCCTriple
argument_list|,
argument|StringRef GCCMultiarchTriple
argument_list|,
argument|StringRef TargetMultiarchTriple
argument_list|,
argument|Twine IncludeSuffix
argument_list|,
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
block|;
name|std
operator|::
name|string
name|computeSysRoot
argument_list|()
specifier|const
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|Hexagon_TC
range|:
name|public
name|Linux
block|{
name|protected
operator|:
name|GCCVersion
name|GCCLibAndIncVersion
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|Hexagon_TC
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|Hexagon_TC
argument_list|()
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|StringRef
name|GetGCCLibAndIncVersion
argument_list|()
specifier|const
block|{
return|return
name|GCCLibAndIncVersion
operator|.
name|Text
return|;
block|}
specifier|static
name|std
operator|::
name|string
name|GetGnuDir
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|InstalledDir
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
specifier|static
name|StringRef
name|GetTargetCPU
argument_list|(
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
specifier|static
specifier|const
name|char
operator|*
name|GetSmallDataThreshold
argument_list|(
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
specifier|static
name|bool
name|UsesG0
argument_list|(
specifier|const
name|char
operator|*
name|smallDataThreshold
argument_list|)
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|NaCl_TC
range|:
name|public
name|Generic_ELF
block|{
name|public
operator|:
name|NaCl_TC
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|CXXStdlibType
name|GetCXXStdlibType
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
comment|// Get the path to the file containing NaCl's ARM macros. It lives in NaCl_TC
comment|// because the AssembleARM tool needs a const char * that it can pass around
comment|// and the toolchain outlives all the jobs.
specifier|const
name|char
operator|*
name|GetNaClArmMacrosPath
argument_list|()
specifier|const
block|{
return|return
name|NaClArmMacrosPath
operator|.
name|c_str
argument_list|()
return|;
block|}
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|std
operator|::
name|string
name|Linker
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
name|std
operator|::
name|string
name|NaClArmMacrosPath
block|; }
decl_stmt|;
comment|/// TCEToolChain - A tool chain using the llvm bitcode tools to perform
comment|/// all subcommands. See http://tce.cs.tut.fi for our peculiar target.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|TCEToolChain
range|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|TCEToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|TCEToolChain
argument_list|()
name|override
block|;
name|bool
name|IsMathErrnoDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|MSVCToolChain
range|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|MSVCToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|bool
name|getWindowsSDKDir
argument_list|(
argument|std::string&path
argument_list|,
argument|int&major
argument_list|,
argument|int&minor
argument_list|)
specifier|const
block|;
name|bool
name|getWindowsSDKLibraryPath
argument_list|(
argument|std::string&path
argument_list|)
specifier|const
block|;
name|bool
name|getVisualStudioInstallDir
argument_list|(
argument|std::string&path
argument_list|)
specifier|const
block|;
name|bool
name|getVisualStudioBinariesFolder
argument_list|(
argument|const char *clangProgramPath
argument_list|,
argument|std::string&path
argument_list|)
specifier|const
block|;
name|std
operator|::
name|string
name|ComputeEffectiveClangTriple
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|types::ID InputType
argument_list|)
specifier|const
name|override
block|;
name|SanitizerMask
name|getSupportedSanitizers
argument_list|()
specifier|const
name|override
block|;
name|protected
operator|:
name|void
name|AddSystemIncludeWithSubfolder
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|,
argument|const std::string&folder
argument_list|,
argument|const char *subfolder
argument_list|)
specifier|const
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|CrossWindowsToolChain
range|:
name|public
name|Generic_GCC
block|{
name|public
operator|:
name|CrossWindowsToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|T
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|bool
name|IsIntegratedAssemblerDefault
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|bool
name|IsUnwindTablesDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|unsigned
name|int
name|GetDefaultStackProtectorLevel
argument_list|(
argument|bool KernelOrKext
argument_list|)
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|; }
decl_stmt|;
name|class
name|LLVM_LIBRARY_VISIBILITY
name|XCore
range|:
name|public
name|ToolChain
block|{
name|public
operator|:
name|XCore
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
name|protected
operator|:
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|public
operator|:
name|bool
name|isPICDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPIEDefault
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isPICDefaultForced
argument_list|()
specifier|const
name|override
block|;
name|bool
name|SupportsProfiling
argument_list|()
specifier|const
name|override
block|;
name|bool
name|hasBlocksRuntime
argument_list|()
specifier|const
name|override
block|;
name|void
name|AddClangSystemIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|addClangTargetOptions
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddClangCXXStdlibIncludeArgs
argument_list|(
argument|const llvm::opt::ArgList&DriverArgs
argument_list|,
argument|llvm::opt::ArgStringList&CC1Args
argument_list|)
specifier|const
name|override
block|;
name|void
name|AddCXXStdlibLibArgs
argument_list|(
argument|const llvm::opt::ArgList&Args
argument_list|,
argument|llvm::opt::ArgStringList&CmdArgs
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
comment|/// SHAVEToolChain - A tool chain using the compiler installed by the the
comment|// Movidius SDK into MV_TOOLS_DIR (which we assume will be copied to llvm's
comment|// installation dir) to perform all subcommands.
name|class
name|LLVM_LIBRARY_VISIBILITY
name|SHAVEToolChain
range|:
name|public
name|Generic_GCC
block|{
name|public
operator|:
name|SHAVEToolChain
argument_list|(
specifier|const
name|Driver
operator|&
name|D
argument_list|,
specifier|const
name|llvm
operator|::
name|Triple
operator|&
name|Triple
argument_list|,
specifier|const
name|llvm
operator|::
name|opt
operator|::
name|ArgList
operator|&
name|Args
argument_list|)
block|;
operator|~
name|SHAVEToolChain
argument_list|()
name|override
block|;
name|virtual
name|Tool
operator|*
name|SelectTool
argument_list|(
argument|const JobAction&JA
argument_list|)
specifier|const
name|override
block|;
name|protected
operator|:
name|Tool
operator|*
name|getTool
argument_list|(
argument|Action::ActionClass AC
argument_list|)
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildAssembler
argument_list|()
specifier|const
name|override
block|;
name|Tool
operator|*
name|buildLinker
argument_list|()
specifier|const
name|override
block|;
name|private
operator|:
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|Tool
operator|>
name|Compiler
block|;
name|mutable
name|std
operator|::
name|unique_ptr
operator|<
name|Tool
operator|>
name|Assembler
block|; }
decl_stmt|;
block|}
comment|// end namespace toolchains
block|}
comment|// end namespace driver
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

