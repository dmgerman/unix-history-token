begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===--- ConvertUTF.c - Universal Character Names conversions ---------------===  *  *                     The LLVM Compiler Infrastructure  *  * This file is distributed under the University of Illinois Open Source  * License. See LICENSE.TXT for details.  *  *===------------------------------------------------------------------------=*/
end_comment

begin_comment
comment|/*  * Copyright 2001-2004 Unicode, Inc.  *   * Disclaimer  *   * This source code is provided as is by Unicode, Inc. No claims are  * made as to fitness for any particular purpose. No warranties of any  * kind are expressed or implied. The recipient agrees to determine  * applicability of information provided. If this file has been  * purchased on magnetic or optical media from Unicode, Inc., the  * sole remedy for any claim will be exchange of defective media  * within 90 days of receipt.  *   * Limitations on Rights to Redistribute This Code  *   * Unicode, Inc. hereby grants the right to freely use the information  * supplied in this file in the creation of products supporting the  * Unicode Standard, and to make copies of this file in any form  * for internal or external distribution as long as this notice  * remains attached.  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------      Conversions between UTF32, UTF-16, and UTF-8. Source code file.     Author: Mark E. Davis, 1994.     Rev History: Rick McGowan, fixes& updates May 2001.     Sept 2001: fixed const& error conditions per         mods suggested by S. Parent& A. Lillich.     June 2002: Tim Dodd added detection and handling of incomplete         source sequences, enhanced error detection, added casts         to eliminate compiler warnings.     July 2003: slight mods to back out aggressive FFFE detection.     Jan 2004: updated switches in from-UTF8 conversions.     Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.      See the header file "ConvertUTF.h" for complete documentation.  ------------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|"clang/Basic/ConvertUTF.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVTUTF_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|int
name|halfShift
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for shifting by 10 bits */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|UTF32
name|halfBase
init|=
literal|0x0010000UL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|UTF32
name|halfMask
init|=
literal|0x3FFUL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNI_SUR_HIGH_START
value|(UTF32)0xD800
end_define

begin_define
define|#
directive|define
name|UNI_SUR_HIGH_END
value|(UTF32)0xDBFF
end_define

begin_define
define|#
directive|define
name|UNI_SUR_LOW_START
value|(UTF32)0xDC00
end_define

begin_define
define|#
directive|define
name|UNI_SUR_LOW_END
value|(UTF32)0xDFFF
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Index into the table below with the first byte of a UTF-8 sequence to  * get the number of trailing bytes that are supposed to follow it.  * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is  * left as-is for anyone who may want to do such conversion, which was  * allowed in earlier algorithms.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|trailingBytesForUTF8
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Magic values subtracted from a buffer value during UTF8 conversion.  * This table contains as many values as there might be trailing bytes  * in a UTF-8 sequence.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|UTF32
name|offsetsFromUTF8
index|[
literal|6
index|]
init|=
block|{
literal|0x00000000UL
block|,
literal|0x00003080UL
block|,
literal|0x000E2080UL
block|,
literal|0x03C82080UL
block|,
literal|0xFA082080UL
block|,
literal|0x82082080UL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed  * into the first byte, depending on how many bytes follow.  There are  * as many entries in this table as there are UTF-8 sequence types.  * (I.e., one byte sequence, two byte... etc.). Remember that sequencs  * for *legal* UTF-8 will be 4 or fewer bytes total.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|UTF8
name|firstByteMark
index|[
literal|7
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xC0
block|,
literal|0xE0
block|,
literal|0xF0
block|,
literal|0xF8
block|,
literal|0xFC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The interface converts a whole buffer to avoid function-call overhead.  * Constants have been gathered. Loops& conditionals have been removed as  * much as possible for efficiency, in favor of drop-through switches.  * (See "Note A" at the bottom of the file for equivalent code.)  * If your compiler supports it, the "isLegalUTF8" call can be turned  * into an inline function.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLANG_NEEDS_THESE_ONE_DAY
end_ifdef

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
name|ConversionResult
name|ConvertUTF32toUTF16
parameter_list|(
specifier|const
name|UTF32
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF32
modifier|*
name|sourceEnd
parameter_list|,
name|UTF16
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF16
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF32
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF16
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch
decl_stmt|;
if|if
condition|(
name|target
operator|>=
name|targetEnd
condition|)
block|{
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
name|ch
operator|=
operator|*
name|source
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|<=
name|UNI_MAX_BMP
condition|)
block|{
comment|/* Target is a character<= 0xFFFF */
comment|/* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
operator|(
name|UTF16
operator|)
name|ch
expr_stmt|;
comment|/* normal case */
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
name|UNI_MAX_LEGAL_UTF32
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
name|result
operator|=
name|sourceIllegal
expr_stmt|;
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* target is a character in range 0xFFFF - 0x10FFFF. */
if|if
condition|(
name|target
operator|+
literal|1
operator|>=
name|targetEnd
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* Back up source pointer! */
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
name|ch
operator|-=
name|halfBase
expr_stmt|;
operator|*
name|target
operator|++
operator|=
call|(
name|UTF16
call|)
argument_list|(
operator|(
name|ch
operator|>>
name|halfShift
operator|)
operator|+
name|UNI_SUR_HIGH_START
argument_list|)
expr_stmt|;
operator|*
name|target
operator|++
operator|=
call|(
name|UTF16
call|)
argument_list|(
operator|(
name|ch
operator|&
name|halfMask
operator|)
operator|+
name|UNI_SUR_LOW_START
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
name|ConversionResult
name|ConvertUTF16toUTF32
parameter_list|(
specifier|const
name|UTF16
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF16
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF32
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF16
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF32
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
name|UTF32
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
specifier|const
name|UTF16
modifier|*
name|oldSource
init|=
name|source
decl_stmt|;
comment|/*  In case we have to back up because of target overflow. */
name|ch
operator|=
operator|*
name|source
operator|++
expr_stmt|;
comment|/* If we have a surrogate pair, convert to UTF32 first. */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_HIGH_END
condition|)
block|{
comment|/* If the 16 bits following the high surrogate are in the source buffer... */
if|if
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|ch2
operator|=
operator|*
name|source
expr_stmt|;
comment|/* If it's a low surrogate, convert to UTF32. */
if|if
condition|(
name|ch2
operator|>=
name|UNI_SUR_LOW_START
operator|&&
name|ch2
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
name|ch
operator|=
operator|(
operator|(
name|ch
operator|-
name|UNI_SUR_HIGH_START
operator|)
operator|<<
name|halfShift
operator|)
operator|+
operator|(
name|ch2
operator|-
name|UNI_SUR_LOW_START
operator|)
operator|+
name|halfBase
expr_stmt|;
operator|++
name|source
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
comment|/* it's an unpaired high surrogate */
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We don't have the 16 bits following the high surrogate. */
operator|--
name|source
expr_stmt|;
comment|/* return to the high surrogate */
name|result
operator|=
name|sourceExhausted
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
comment|/* UTF-16 surrogate values are illegal in UTF-32 */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_LOW_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target
operator|>=
name|targetEnd
condition|)
block|{
name|source
operator|=
name|oldSource
expr_stmt|;
comment|/* Back up source pointer! */
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
operator|*
name|target
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
ifdef|#
directive|ifdef
name|CVTUTF_DEBUG
if|if
condition|(
name|result
operator|==
name|sourceIllegal
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n"
argument_list|,
name|ch
argument_list|,
name|ch2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
name|ConversionResult
name|ConvertUTF16toUTF8
parameter_list|(
specifier|const
name|UTF16
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF16
modifier|*
name|sourceEnd
parameter_list|,
name|UTF8
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF8
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF16
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF8
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch
decl_stmt|;
name|unsigned
name|short
name|bytesToWrite
init|=
literal|0
decl_stmt|;
specifier|const
name|UTF32
name|byteMask
init|=
literal|0xBF
decl_stmt|;
specifier|const
name|UTF32
name|byteMark
init|=
literal|0x80
decl_stmt|;
specifier|const
name|UTF16
modifier|*
name|oldSource
init|=
name|source
decl_stmt|;
comment|/* In case we have to back up because of target overflow. */
name|ch
operator|=
operator|*
name|source
operator|++
expr_stmt|;
comment|/* If we have a surrogate pair, convert to UTF32 first. */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_HIGH_END
condition|)
block|{
comment|/* If the 16 bits following the high surrogate are in the source buffer... */
if|if
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch2
init|=
operator|*
name|source
decl_stmt|;
comment|/* If it's a low surrogate, convert to UTF32. */
if|if
condition|(
name|ch2
operator|>=
name|UNI_SUR_LOW_START
operator|&&
name|ch2
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
name|ch
operator|=
operator|(
operator|(
name|ch
operator|-
name|UNI_SUR_HIGH_START
operator|)
operator|<<
name|halfShift
operator|)
operator|+
operator|(
name|ch2
operator|-
name|UNI_SUR_LOW_START
operator|)
operator|+
name|halfBase
expr_stmt|;
operator|++
name|source
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
comment|/* it's an unpaired high surrogate */
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We don't have the 16 bits following the high surrogate. */
operator|--
name|source
expr_stmt|;
comment|/* return to the high surrogate */
name|result
operator|=
name|sourceExhausted
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
comment|/* UTF-16 surrogate values are illegal in UTF-32 */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_LOW_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
block|}
comment|/* Figure out how many bytes the result will require */
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x80
condition|)
block|{
name|bytesToWrite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x800
condition|)
block|{
name|bytesToWrite
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x10000
condition|)
block|{
name|bytesToWrite
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x110000
condition|)
block|{
name|bytesToWrite
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bytesToWrite
operator|=
literal|3
expr_stmt|;
name|ch
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
name|target
operator|+=
name|bytesToWrite
expr_stmt|;
if|if
condition|(
name|target
operator|>
name|targetEnd
condition|)
block|{
name|source
operator|=
name|oldSource
expr_stmt|;
comment|/* Back up source pointer! */
name|target
operator|-=
name|bytesToWrite
expr_stmt|;
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bytesToWrite
condition|)
block|{
comment|/* note: everything falls through. */
case|case
literal|4
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|3
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|2
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|1
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
name|ch
operator||
name|firstByteMark
index|[
name|bytesToWrite
index|]
argument_list|)
expr_stmt|;
block|}
name|target
operator|+=
name|bytesToWrite
expr_stmt|;
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
name|ConversionResult
name|ConvertUTF32toUTF8
parameter_list|(
specifier|const
name|UTF32
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF32
modifier|*
name|sourceEnd
parameter_list|,
name|UTF8
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF8
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF32
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF8
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch
decl_stmt|;
name|unsigned
name|short
name|bytesToWrite
init|=
literal|0
decl_stmt|;
specifier|const
name|UTF32
name|byteMask
init|=
literal|0xBF
decl_stmt|;
specifier|const
name|UTF32
name|byteMark
init|=
literal|0x80
decl_stmt|;
name|ch
operator|=
operator|*
name|source
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
comment|/* UTF-16 surrogate values are illegal in UTF-32 */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
block|}
comment|/*          * Figure out how many bytes the result will require. Turn any          * illegally large UTF32 things (> Plane 17) into replacement chars.          */
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x80
condition|)
block|{
name|bytesToWrite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x800
condition|)
block|{
name|bytesToWrite
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
operator|(
name|UTF32
operator|)
literal|0x10000
condition|)
block|{
name|bytesToWrite
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<=
name|UNI_MAX_LEGAL_UTF32
condition|)
block|{
name|bytesToWrite
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bytesToWrite
operator|=
literal|3
expr_stmt|;
name|ch
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
name|result
operator|=
name|sourceIllegal
expr_stmt|;
block|}
name|target
operator|+=
name|bytesToWrite
expr_stmt|;
if|if
condition|(
name|target
operator|>
name|targetEnd
condition|)
block|{
operator|--
name|source
expr_stmt|;
comment|/* Back up source pointer! */
name|target
operator|-=
name|bytesToWrite
expr_stmt|;
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bytesToWrite
condition|)
block|{
comment|/* note: everything falls through. */
case|case
literal|4
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|3
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|2
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
operator|(
name|ch
operator||
name|byteMark
operator|)
operator|&
name|byteMask
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|6
expr_stmt|;
case|case
literal|1
case|:
operator|*
operator|--
name|target
operator|=
call|(
name|UTF8
call|)
argument_list|(
name|ch
operator||
name|firstByteMark
index|[
name|bytesToWrite
index|]
argument_list|)
expr_stmt|;
block|}
name|target
operator|+=
name|bytesToWrite
expr_stmt|;
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
name|ConversionResult
name|ConvertUTF8toUTF32
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF32
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF32
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF8
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF32
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|extraBytesToRead
init|=
name|trailingBytesForUTF8
index|[
operator|*
name|source
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|+
name|extraBytesToRead
operator|>=
name|sourceEnd
condition|)
block|{
name|result
operator|=
name|sourceExhausted
expr_stmt|;
break|break;
block|}
comment|/* Do this check whether lenient or strict */
if|if
condition|(
operator|!
name|isLegalUTF8
argument_list|(
name|source
argument_list|,
name|extraBytesToRead
operator|+
literal|1
argument_list|)
condition|)
block|{
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
comment|/*          * The cases all fall through. See "Note A" below.          */
switch|switch
condition|(
name|extraBytesToRead
condition|)
block|{
case|case
literal|5
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|4
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|3
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|2
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|1
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|0
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
block|}
name|ch
operator|-=
name|offsetsFromUTF8
index|[
name|extraBytesToRead
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|>=
name|targetEnd
condition|)
block|{
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Back up the source pointer! */
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|<=
name|UNI_MAX_LEGAL_UTF32
condition|)
block|{
comment|/*              * UTF-16 surrogate values are illegal in UTF-32, and anything              * over Plane 17 (> 0x10FFFF) is illegal.              */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* i.e., ch> UNI_MAX_LEGAL_UTF32 */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Utility routine to tell whether a sequence of bytes is legal UTF-8.  * This must be called with the length pre-determined by the first byte.  * If not calling this from ConvertUTF8to*, then the length can be set by:  *  length = trailingBytesForUTF8[*source]+1;  * and the sequence is illegal right away if there aren't that many bytes  * available.  * If presented with a length> 4, this returns false.  The Unicode  * definition of UTF-8 goes up to 4-byte sequences.  */
end_comment

begin_function
specifier|static
name|Boolean
name|isLegalUTF8
parameter_list|(
specifier|const
name|UTF8
modifier|*
name|source
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|UTF8
name|a
decl_stmt|;
specifier|const
name|UTF8
modifier|*
name|srcptr
init|=
name|source
operator|+
name|length
decl_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
default|default:
return|return
name|false
return|;
comment|/* Everything else falls through when "true"... */
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|a
operator|=
operator|(
operator|*
operator|--
name|srcptr
operator|)
operator|)
operator|<
literal|0x80
operator|||
name|a
operator|>
literal|0xBF
condition|)
return|return
name|false
return|;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|a
operator|=
operator|(
operator|*
operator|--
name|srcptr
operator|)
operator|)
operator|<
literal|0x80
operator|||
name|a
operator|>
literal|0xBF
condition|)
return|return
name|false
return|;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|a
operator|=
operator|(
operator|*
operator|--
name|srcptr
operator|)
operator|)
operator|>
literal|0xBF
condition|)
return|return
name|false
return|;
switch|switch
condition|(
operator|*
name|source
condition|)
block|{
comment|/* no fall-through in this inner switch */
case|case
literal|0xE0
case|:
if|if
condition|(
name|a
operator|<
literal|0xA0
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|0xED
case|:
if|if
condition|(
name|a
operator|>
literal|0x9F
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|0xF0
case|:
if|if
condition|(
name|a
operator|<
literal|0x90
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|0xF4
case|:
if|if
condition|(
name|a
operator|>
literal|0x8F
condition|)
return|return
name|false
return|;
break|break;
default|default:
if|if
condition|(
name|a
operator|<
literal|0x80
condition|)
return|return
name|false
return|;
block|}
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|source
operator|>=
literal|0x80
operator|&&
operator|*
name|source
operator|<
literal|0xC2
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
name|source
operator|>
literal|0xF4
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Exported function to return whether a UTF-8 sequence is legal or not.  * This is not used here; it's just exported.  */
end_comment

begin_function
name|Boolean
name|isLegalUTF8Sequence
parameter_list|(
specifier|const
name|UTF8
modifier|*
name|source
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|)
block|{
name|int
name|length
init|=
name|trailingBytesForUTF8
index|[
operator|*
name|source
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|source
operator|+
name|length
operator|>
name|sourceEnd
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|isLegalUTF8
argument_list|(
name|source
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
name|ConversionResult
name|ConvertUTF8toUTF16
parameter_list|(
specifier|const
name|UTF8
modifier|*
modifier|*
name|sourceStart
parameter_list|,
specifier|const
name|UTF8
modifier|*
name|sourceEnd
parameter_list|,
name|UTF16
modifier|*
modifier|*
name|targetStart
parameter_list|,
name|UTF16
modifier|*
name|targetEnd
parameter_list|,
name|ConversionFlags
name|flags
parameter_list|)
block|{
name|ConversionResult
name|result
init|=
name|conversionOK
decl_stmt|;
specifier|const
name|UTF8
modifier|*
name|source
init|=
operator|*
name|sourceStart
decl_stmt|;
name|UTF16
modifier|*
name|target
init|=
operator|*
name|targetStart
decl_stmt|;
while|while
condition|(
name|source
operator|<
name|sourceEnd
condition|)
block|{
name|UTF32
name|ch
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|extraBytesToRead
init|=
name|trailingBytesForUTF8
index|[
operator|*
name|source
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|+
name|extraBytesToRead
operator|>=
name|sourceEnd
condition|)
block|{
name|result
operator|=
name|sourceExhausted
expr_stmt|;
break|break;
block|}
comment|/* Do this check whether lenient or strict */
if|if
condition|(
operator|!
name|isLegalUTF8
argument_list|(
name|source
argument_list|,
name|extraBytesToRead
operator|+
literal|1
argument_list|)
condition|)
block|{
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
comment|/*          * The cases all fall through. See "Note A" below.          */
switch|switch
condition|(
name|extraBytesToRead
condition|)
block|{
case|case
literal|5
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
comment|/* remember, illegal UTF-8 */
case|case
literal|4
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
comment|/* remember, illegal UTF-8 */
case|case
literal|3
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|2
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|1
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|0
case|:
name|ch
operator|+=
operator|*
name|source
operator|++
expr_stmt|;
block|}
name|ch
operator|-=
name|offsetsFromUTF8
index|[
name|extraBytesToRead
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|>=
name|targetEnd
condition|)
block|{
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Back up source pointer! */
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|<=
name|UNI_MAX_BMP
condition|)
block|{
comment|/* Target is a character<= 0xFFFF */
comment|/* UTF-16 surrogate values are illegal in UTF-32 */
if|if
condition|(
name|ch
operator|>=
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UNI_SUR_LOW_END
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* return to the illegal value itself */
name|result
operator|=
name|sourceIllegal
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
operator|(
name|UTF16
operator|)
name|ch
expr_stmt|;
comment|/* normal case */
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
name|UNI_MAX_UTF16
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|strictConversion
condition|)
block|{
name|result
operator|=
name|sourceIllegal
expr_stmt|;
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* return to the start */
break|break;
comment|/* Bail out; shouldn't continue */
block|}
else|else
block|{
operator|*
name|target
operator|++
operator|=
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* target is a character in range 0xFFFF - 0x10FFFF. */
if|if
condition|(
name|target
operator|+
literal|1
operator|>=
name|targetEnd
condition|)
block|{
name|source
operator|-=
operator|(
name|extraBytesToRead
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Back up source pointer! */
name|result
operator|=
name|targetExhausted
expr_stmt|;
break|break;
block|}
name|ch
operator|-=
name|halfBase
expr_stmt|;
operator|*
name|target
operator|++
operator|=
call|(
name|UTF16
call|)
argument_list|(
operator|(
name|ch
operator|>>
name|halfShift
operator|)
operator|+
name|UNI_SUR_HIGH_START
argument_list|)
expr_stmt|;
operator|*
name|target
operator|++
operator|=
call|(
name|UTF16
call|)
argument_list|(
operator|(
name|ch
operator|&
name|halfMask
operator|)
operator|+
name|UNI_SUR_LOW_START
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sourceStart
operator|=
name|source
expr_stmt|;
operator|*
name|targetStart
operator|=
name|target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------      Note A.     The fall-through switches in UTF-8 reading code save a     temp variable, some decrements& conditionals.  The switches     are equivalent to the following loop:         {             int tmpBytesToRead = extraBytesToRead+1;             do {                 ch += *source++;                 --tmpBytesToRead;                 if (tmpBytesToRead) ch<<= 6;             } while (tmpBytesToRead> 0);         }     In UTF-8 writing code, the switches on "bytesToWrite" are     similarly unrolled loops.     --------------------------------------------------------------------- */
end_comment

end_unit

