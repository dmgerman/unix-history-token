begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- FormatToken.h - Format C++ code ------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief This file contains the declaration of the FormatToken, a wrapper
end_comment

begin_comment
comment|/// around Token with additional information related to formatting.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/IdentifierTable.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorPrecedence.h"
end_include

begin_include
include|#
directive|include
file|"clang/Format/Format.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Lexer.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|format
block|{
enum|enum
name|TokenType
block|{
name|TT_ArrayInitializerLSquare
block|,
name|TT_ArraySubscriptLSquare
block|,
name|TT_AttributeParen
block|,
name|TT_BinaryOperator
block|,
name|TT_BitFieldColon
block|,
name|TT_BlockComment
block|,
name|TT_CastRParen
block|,
name|TT_ConditionalExpr
block|,
name|TT_ConflictAlternative
block|,
name|TT_ConflictEnd
block|,
name|TT_ConflictStart
block|,
name|TT_CtorInitializerColon
block|,
name|TT_CtorInitializerComma
block|,
name|TT_DesignatedInitializerPeriod
block|,
name|TT_DictLiteral
block|,
name|TT_ForEachMacro
block|,
name|TT_FunctionAnnotationRParen
block|,
name|TT_FunctionDeclarationName
block|,
name|TT_FunctionLBrace
block|,
name|TT_FunctionTypeLParen
block|,
name|TT_ImplicitStringLiteral
block|,
name|TT_InheritanceColon
block|,
name|TT_InlineASMBrace
block|,
name|TT_InlineASMColon
block|,
name|TT_JavaAnnotation
block|,
name|TT_JsFatArrow
block|,
name|TT_JsTypeColon
block|,
name|TT_JsTypeOptionalQuestion
block|,
name|TT_LambdaArrow
block|,
name|TT_LambdaLSquare
block|,
name|TT_LeadingJavaAnnotation
block|,
name|TT_LineComment
block|,
name|TT_ObjCBlockLBrace
block|,
name|TT_ObjCBlockLParen
block|,
name|TT_ObjCDecl
block|,
name|TT_ObjCForIn
block|,
name|TT_ObjCMethodExpr
block|,
name|TT_ObjCMethodSpecifier
block|,
name|TT_ObjCProperty
block|,
name|TT_ObjCStringLiteral
block|,
name|TT_OverloadedOperator
block|,
name|TT_OverloadedOperatorLParen
block|,
name|TT_PointerOrReference
block|,
name|TT_PureVirtualSpecifier
block|,
name|TT_RangeBasedForLoopColon
block|,
name|TT_RegexLiteral
block|,
name|TT_SelectorName
block|,
name|TT_StartOfName
block|,
name|TT_TemplateCloser
block|,
name|TT_TemplateOpener
block|,
name|TT_TemplateString
block|,
name|TT_TrailingAnnotation
block|,
name|TT_TrailingReturnArrow
block|,
name|TT_TrailingUnaryOperator
block|,
name|TT_UnaryOperator
block|,
name|TT_Unknown
block|}
enum|;
comment|// Represents what type of block a set of braces open.
enum|enum
name|BraceBlockKind
block|{
name|BK_Unknown
block|,
name|BK_Block
block|,
name|BK_BracedInit
block|}
enum|;
comment|// The packing kind of a function's parameters.
enum|enum
name|ParameterPackingKind
block|{
name|PPK_BinPacked
block|,
name|PPK_OnePerLine
block|,
name|PPK_Inconclusive
block|}
enum|;
enum|enum
name|FormatDecision
block|{
name|FD_Unformatted
block|,
name|FD_Continue
block|,
name|FD_Break
block|}
enum|;
name|class
name|TokenRole
decl_stmt|;
name|class
name|AnnotatedLine
decl_stmt|;
comment|/// \brief A wrapper around a \c Token storing information about the
comment|/// whitespace characters preceding it.
struct|struct
name|FormatToken
block|{
name|FormatToken
argument_list|()
block|{}
comment|/// \brief The \c Token.
name|Token
name|Tok
decl_stmt|;
comment|/// \brief The number of newlines immediately before the \c Token.
comment|///
comment|/// This can be used to determine what the user wrote in the original code
comment|/// and thereby e.g. leave an empty line between two function definitions.
name|unsigned
name|NewlinesBefore
init|=
literal|0
decl_stmt|;
comment|/// \brief Whether there is at least one unescaped newline before the \c
comment|/// Token.
name|bool
name|HasUnescapedNewline
init|=
name|false
decl_stmt|;
comment|/// \brief The range of the whitespace immediately preceding the \c Token.
name|SourceRange
name|WhitespaceRange
decl_stmt|;
comment|/// \brief The offset just past the last '\n' in this token's leading
comment|/// whitespace (relative to \c WhiteSpaceStart). 0 if there is no '\n'.
name|unsigned
name|LastNewlineOffset
init|=
literal|0
decl_stmt|;
comment|/// \brief The width of the non-whitespace parts of the token (or its first
comment|/// line for multi-line tokens) in columns.
comment|/// We need this to correctly measure number of columns a token spans.
name|unsigned
name|ColumnWidth
init|=
literal|0
decl_stmt|;
comment|/// \brief Contains the width in columns of the last line of a multi-line
comment|/// token.
name|unsigned
name|LastLineColumnWidth
init|=
literal|0
decl_stmt|;
comment|/// \brief Whether the token text contains newlines (escaped or not).
name|bool
name|IsMultiline
init|=
name|false
decl_stmt|;
comment|/// \brief Indicates that this is the first token.
name|bool
name|IsFirst
init|=
name|false
decl_stmt|;
comment|/// \brief Whether there must be a line break before this token.
comment|///
comment|/// This happens for example when a preprocessor directive ended directly
comment|/// before the token.
name|bool
name|MustBreakBefore
init|=
name|false
decl_stmt|;
comment|/// \brief The raw text of the token.
comment|///
comment|/// Contains the raw token text without leading whitespace and without leading
comment|/// escaped newlines.
name|StringRef
name|TokenText
decl_stmt|;
comment|/// \brief Set to \c true if this token is an unterminated literal.
name|bool
name|IsUnterminatedLiteral
init|=
literal|0
decl_stmt|;
comment|/// \brief Contains the kind of block if this token is a brace.
name|BraceBlockKind
name|BlockKind
init|=
name|BK_Unknown
decl_stmt|;
name|TokenType
name|Type
init|=
name|TT_Unknown
decl_stmt|;
comment|/// \brief The number of spaces that should be inserted before this token.
name|unsigned
name|SpacesRequiredBefore
init|=
literal|0
decl_stmt|;
comment|/// \brief \c true if it is allowed to break before this token.
name|bool
name|CanBreakBefore
init|=
name|false
decl_stmt|;
comment|/// \brief \c true if this is the ">" of "template<..>".
name|bool
name|ClosesTemplateDeclaration
init|=
name|false
decl_stmt|;
comment|/// \brief Number of parameters, if this is "(", "[" or "<".
comment|///
comment|/// This is initialized to 1 as we don't need to distinguish functions with
comment|/// 0 parameters from functions with 1 parameter. Thus, we can simply count
comment|/// the number of commas.
name|unsigned
name|ParameterCount
init|=
literal|0
decl_stmt|;
comment|/// \brief Number of parameters that are nested blocks,
comment|/// if this is "(", "[" or "<".
name|unsigned
name|BlockParameterCount
init|=
literal|0
decl_stmt|;
comment|/// \brief If this is a bracket ("<", "(", "[" or "{"), contains the kind of
comment|/// the surrounding bracket.
name|tok
operator|::
name|TokenKind
name|ParentBracket
operator|=
name|tok
operator|::
name|unknown
expr_stmt|;
comment|/// \brief A token can have a special role that can carry extra information
comment|/// about the token's formatting.
name|std
operator|::
name|unique_ptr
operator|<
name|TokenRole
operator|>
name|Role
expr_stmt|;
comment|/// \brief If this is an opening parenthesis, how are the parameters packed?
name|ParameterPackingKind
name|PackingKind
init|=
name|PPK_Inconclusive
decl_stmt|;
comment|/// \brief The total length of the unwrapped line up to and including this
comment|/// token.
name|unsigned
name|TotalLength
init|=
literal|0
decl_stmt|;
comment|/// \brief The original 0-based column of this token, including expanded tabs.
comment|/// The configured TabWidth is used as tab width.
name|unsigned
name|OriginalColumn
init|=
literal|0
decl_stmt|;
comment|/// \brief The length of following tokens until the next natural split point,
comment|/// or the next token that can be broken.
name|unsigned
name|UnbreakableTailLength
init|=
literal|0
decl_stmt|;
comment|// FIXME: Come up with a 'cleaner' concept.
comment|/// \brief The binding strength of a token. This is a combined value of
comment|/// operator precedence, parenthesis nesting, etc.
name|unsigned
name|BindingStrength
init|=
literal|0
decl_stmt|;
comment|/// \brief The nesting level of this token, i.e. the number of surrounding (),
comment|/// [], {} or<>.
name|unsigned
name|NestingLevel
init|=
literal|0
decl_stmt|;
comment|/// \brief Penalty for inserting a line break before this token.
name|unsigned
name|SplitPenalty
init|=
literal|0
decl_stmt|;
comment|/// \brief If this is the first ObjC selector name in an ObjC method
comment|/// definition or call, this contains the length of the longest name.
comment|///
comment|/// This being set to 0 means that the selectors should not be colon-aligned,
comment|/// e.g. because several of them are block-type.
name|unsigned
name|LongestObjCSelectorName
init|=
literal|0
decl_stmt|;
comment|/// \brief Stores the number of required fake parentheses and the
comment|/// corresponding operator precedence.
comment|///
comment|/// If multiple fake parentheses start at a token, this vector stores them in
comment|/// reverse order, i.e. inner fake parenthesis first.
name|SmallVector
operator|<
name|prec
operator|::
name|Level
operator|,
literal|4
operator|>
name|FakeLParens
expr_stmt|;
comment|/// \brief Insert this many fake ) after this token for correct indentation.
name|unsigned
name|FakeRParens
init|=
literal|0
decl_stmt|;
comment|/// \brief \c true if this token starts a binary expression, i.e. has at least
comment|/// one fake l_paren with a precedence greater than prec::Unknown.
name|bool
name|StartsBinaryExpression
init|=
name|false
decl_stmt|;
comment|/// \brief \c true if this token ends a binary expression.
name|bool
name|EndsBinaryExpression
init|=
name|false
decl_stmt|;
comment|/// \brief Is this is an operator (or "."/"->") in a sequence of operators
comment|/// with the same precedence, contains the 0-based operator index.
name|unsigned
name|OperatorIndex
init|=
literal|0
decl_stmt|;
comment|/// \brief Is this the last operator (or "."/"->") in a sequence of operators
comment|/// with the same precedence?
name|bool
name|LastOperator
init|=
name|false
decl_stmt|;
comment|/// \brief Is this token part of a \c DeclStmt defining multiple variables?
comment|///
comment|/// Only set if \c Type == \c TT_StartOfName.
name|bool
name|PartOfMultiVariableDeclStmt
init|=
name|false
decl_stmt|;
comment|/// \brief If this is a bracket, this points to the matching one.
name|FormatToken
modifier|*
name|MatchingParen
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The previous token in the unwrapped line.
name|FormatToken
modifier|*
name|Previous
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The next token in the unwrapped line.
name|FormatToken
modifier|*
name|Next
init|=
name|nullptr
decl_stmt|;
comment|/// \brief If this token starts a block, this contains all the unwrapped lines
comment|/// in it.
name|SmallVector
operator|<
name|AnnotatedLine
operator|*
operator|,
literal|1
operator|>
name|Children
expr_stmt|;
comment|/// \brief Stores the formatting decision for the token once it was made.
name|FormatDecision
name|Decision
init|=
name|FD_Unformatted
decl_stmt|;
comment|/// \brief If \c true, this token has been fully formatted (indented and
comment|/// potentially re-formatted inside), and we do not allow further formatting
comment|/// changes.
name|bool
name|Finalized
init|=
name|false
decl_stmt|;
name|bool
name|is
argument_list|(
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|Tok
operator|.
name|is
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|is
argument_list|(
name|TokenType
name|TT
argument_list|)
decl|const
block|{
return|return
name|Type
operator|==
name|TT
return|;
block|}
name|bool
name|is
argument_list|(
specifier|const
name|IdentifierInfo
operator|*
name|II
argument_list|)
decl|const
block|{
return|return
name|II
operator|&&
name|II
operator|==
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
name|bool
name|isOneOf
argument_list|(
argument|A K1
argument_list|,
argument|B K2
argument_list|)
specifier|const
block|{
return|return
name|is
argument_list|(
name|K1
argument_list|)
operator|||
name|is
argument_list|(
name|K2
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|,
name|typename
operator|...
name|Ts
operator|>
name|bool
name|isOneOf
argument_list|(
argument|A K1
argument_list|,
argument|B K2
argument_list|,
argument|Ts... Ks
argument_list|)
specifier|const
block|{
return|return
name|is
argument_list|(
name|K1
argument_list|)
operator|||
name|isOneOf
argument_list|(
name|K2
argument_list|,
name|Ks
operator|...
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|isNot
argument_list|(
argument|T Kind
argument_list|)
specifier|const
block|{
return|return
operator|!
name|is
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|isStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|tok
operator|::
name|isStringLiteral
argument_list|(
name|Tok
operator|.
name|getKind
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|Tok
operator|.
name|isObjCAtKeyword
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|isAccessSpecifier
argument_list|(
name|bool
name|ColonRequired
operator|=
name|true
argument_list|)
decl|const
block|{
return|return
name|isOneOf
argument_list|(
name|tok
operator|::
name|kw_public
argument_list|,
name|tok
operator|::
name|kw_protected
argument_list|,
name|tok
operator|::
name|kw_private
argument_list|)
operator|&&
operator|(
operator|!
name|ColonRequired
operator|||
operator|(
name|Next
operator|&&
name|Next
operator|->
name|is
argument_list|(
name|tok
operator|::
name|colon
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/// \brief Determine whether the token is a simple-type-specifier.
name|bool
name|isSimpleTypeSpecifier
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isObjCAccessSpecifier
argument_list|()
specifier|const
block|{
return|return
name|is
argument_list|(
name|tok
operator|::
name|at
argument_list|)
operator|&&
name|Next
operator|&&
operator|(
name|Next
operator|->
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_public
argument_list|)
operator|||
name|Next
operator|->
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_protected
argument_list|)
operator|||
name|Next
operator|->
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_package
argument_list|)
operator|||
name|Next
operator|->
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_private
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Returns whether \p Tok is ([{ or a template opening<.
name|bool
name|opensScope
argument_list|()
specifier|const
block|{
return|return
name|isOneOf
argument_list|(
name|tok
operator|::
name|l_paren
argument_list|,
name|tok
operator|::
name|l_brace
argument_list|,
name|tok
operator|::
name|l_square
argument_list|,
name|TT_TemplateOpener
argument_list|)
return|;
block|}
comment|/// \brief Returns whether \p Tok is )]} or a template closing>.
name|bool
name|closesScope
argument_list|()
specifier|const
block|{
return|return
name|isOneOf
argument_list|(
name|tok
operator|::
name|r_paren
argument_list|,
name|tok
operator|::
name|r_brace
argument_list|,
name|tok
operator|::
name|r_square
argument_list|,
name|TT_TemplateCloser
argument_list|)
return|;
block|}
comment|/// \brief Returns \c true if this is a "." or "->" accessing a member.
name|bool
name|isMemberAccess
argument_list|()
specifier|const
block|{
return|return
name|isOneOf
argument_list|(
name|tok
operator|::
name|arrow
argument_list|,
name|tok
operator|::
name|period
argument_list|,
name|tok
operator|::
name|arrowstar
argument_list|)
operator|&&
operator|!
name|isOneOf
argument_list|(
name|TT_DesignatedInitializerPeriod
argument_list|,
name|TT_TrailingReturnArrow
argument_list|,
name|TT_LambdaArrow
argument_list|)
return|;
block|}
name|bool
name|isUnaryOperator
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|tok
operator|::
name|plus
case|:
case|case
name|tok
operator|::
name|plusplus
case|:
case|case
name|tok
operator|::
name|minus
case|:
case|case
name|tok
operator|::
name|minusminus
case|:
case|case
name|tok
operator|::
name|exclaim
case|:
case|case
name|tok
operator|::
name|tilde
case|:
case|case
name|tok
operator|::
name|kw_sizeof
case|:
case|case
name|tok
operator|::
name|kw_alignof
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
name|bool
name|isBinaryOperator
argument_list|()
specifier|const
block|{
comment|// Comma is a binary operator, but does not behave as such wrt. formatting.
return|return
name|getPrecedence
argument_list|()
operator|>
name|prec
operator|::
name|Comma
return|;
block|}
name|bool
name|isTrailingComment
argument_list|()
specifier|const
block|{
return|return
name|is
argument_list|(
name|tok
operator|::
name|comment
argument_list|)
operator|&&
operator|(
name|is
argument_list|(
name|TT_LineComment
argument_list|)
operator|||
operator|!
name|Next
operator|||
name|Next
operator|->
name|NewlinesBefore
operator|>
literal|0
operator|)
return|;
block|}
comment|/// \brief Returns \c true if this is a keyword that can be used
comment|/// like a function call (e.g. sizeof, typeid, ...).
name|bool
name|isFunctionLikeKeyword
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|tok
operator|::
name|kw_throw
case|:
case|case
name|tok
operator|::
name|kw_typeid
case|:
case|case
name|tok
operator|::
name|kw_return
case|:
case|case
name|tok
operator|::
name|kw_sizeof
case|:
case|case
name|tok
operator|::
name|kw_alignof
case|:
case|case
name|tok
operator|::
name|kw_alignas
case|:
case|case
name|tok
operator|::
name|kw_decltype
case|:
case|case
name|tok
operator|::
name|kw_noexcept
case|:
case|case
name|tok
operator|::
name|kw_static_assert
case|:
case|case
name|tok
operator|::
name|kw___attribute
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// \brief Returns actual token start location without leading escaped
comment|/// newlines and whitespace.
comment|///
comment|/// This can be different to Tok.getLocation(), which includes leading escaped
comment|/// newlines.
name|SourceLocation
name|getStartOfNonWhitespace
argument_list|()
specifier|const
block|{
return|return
name|WhitespaceRange
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|prec
operator|::
name|Level
name|getPrecedence
argument_list|()
specifier|const
block|{
return|return
name|getBinOpPrecedence
argument_list|(
name|Tok
operator|.
name|getKind
argument_list|()
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/// \brief Returns the previous token ignoring comments.
name|FormatToken
operator|*
name|getPreviousNonComment
argument_list|()
specifier|const
block|{
name|FormatToken
operator|*
name|Tok
operator|=
name|Previous
block|;
while|while
condition|(
name|Tok
operator|&&
name|Tok
operator|->
name|is
argument_list|(
name|tok
operator|::
name|comment
argument_list|)
condition|)
name|Tok
operator|=
name|Tok
operator|->
name|Previous
expr_stmt|;
return|return
name|Tok
return|;
block|}
comment|/// \brief Returns the next token ignoring comments.
decl|const
name|FormatToken
modifier|*
name|getNextNonComment
argument_list|()
decl|const
block|{
specifier|const
name|FormatToken
modifier|*
name|Tok
init|=
name|Next
decl_stmt|;
while|while
condition|(
name|Tok
operator|&&
name|Tok
operator|->
name|is
argument_list|(
name|tok
operator|::
name|comment
argument_list|)
condition|)
name|Tok
operator|=
name|Tok
operator|->
name|Next
expr_stmt|;
return|return
name|Tok
return|;
block|}
comment|/// \brief Returns \c true if this tokens starts a block-type list, i.e. a
comment|/// list that should be indented with a block indent.
name|bool
name|opensBlockTypeList
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|)
decl|const
block|{
return|return
name|is
argument_list|(
name|TT_ArrayInitializerLSquare
argument_list|)
operator|||
operator|(
name|is
argument_list|(
name|tok
operator|::
name|l_brace
argument_list|)
operator|&&
operator|(
name|BlockKind
operator|==
name|BK_Block
operator|||
name|is
argument_list|(
name|TT_DictLiteral
argument_list|)
operator|||
operator|(
operator|!
name|Style
operator|.
name|Cpp11BracedListStyle
operator|&&
name|NestingLevel
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
comment|/// \brief Same as opensBlockTypeList, but for the closing token.
name|bool
name|closesBlockTypeList
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|)
decl|const
block|{
return|return
name|MatchingParen
operator|&&
name|MatchingParen
operator|->
name|opensBlockTypeList
argument_list|(
name|Style
argument_list|)
return|;
block|}
name|private
range|:
comment|// Disallow copying.
name|FormatToken
argument_list|(
specifier|const
name|FormatToken
operator|&
argument_list|)
operator|=
name|delete
struct|;
name|void
name|operator
init|=
operator|(
specifier|const
name|FormatToken
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ContinuationIndenter
decl_stmt|;
struct_decl|struct
name|LineState
struct_decl|;
name|class
name|TokenRole
block|{
name|public
label|:
name|TokenRole
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|)
operator|:
name|Style
argument_list|(
argument|Style
argument_list|)
block|{}
name|virtual
operator|~
name|TokenRole
argument_list|()
expr_stmt|;
comment|/// \brief After the \c TokenAnnotator has finished annotating all the tokens,
comment|/// this function precomputes required information for formatting.
name|virtual
name|void
name|precomputeFormattingInfos
parameter_list|(
specifier|const
name|FormatToken
modifier|*
name|Token
parameter_list|)
function_decl|;
comment|/// \brief Apply the special formatting that the given role demands.
comment|///
comment|/// Assumes that the token having this role is already formatted.
comment|///
comment|/// Continues formatting from \p State leaving indentation to \p Indenter and
comment|/// returns the total penalty that this formatting incurs.
name|virtual
name|unsigned
name|formatFromToken
parameter_list|(
name|LineState
modifier|&
name|State
parameter_list|,
name|ContinuationIndenter
modifier|*
name|Indenter
parameter_list|,
name|bool
name|DryRun
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Same as \c formatFromToken, but assumes that the first token has
comment|/// already been set thereby deciding on the first line break.
name|virtual
name|unsigned
name|formatAfterToken
parameter_list|(
name|LineState
modifier|&
name|State
parameter_list|,
name|ContinuationIndenter
modifier|*
name|Indenter
parameter_list|,
name|bool
name|DryRun
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
comment|/// \brief Notifies the \c Role that a comma was found.
name|virtual
name|void
name|CommaFound
parameter_list|(
specifier|const
name|FormatToken
modifier|*
name|Token
parameter_list|)
block|{}
name|protected
label|:
specifier|const
name|FormatStyle
modifier|&
name|Style
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CommaSeparatedList
range|:
name|public
name|TokenRole
block|{
name|public
operator|:
name|CommaSeparatedList
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|)
operator|:
name|TokenRole
argument_list|(
name|Style
argument_list|)
block|,
name|HasNestedBracedList
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|precomputeFormattingInfos
argument_list|(
argument|const FormatToken *Token
argument_list|)
name|override
block|;
name|unsigned
name|formatAfterToken
argument_list|(
argument|LineState&State
argument_list|,
argument|ContinuationIndenter *Indenter
argument_list|,
argument|bool DryRun
argument_list|)
name|override
block|;
name|unsigned
name|formatFromToken
argument_list|(
argument|LineState&State
argument_list|,
argument|ContinuationIndenter *Indenter
argument_list|,
argument|bool DryRun
argument_list|)
name|override
block|;
comment|/// \brief Adds \p Token as the next comma to the \c CommaSeparated list.
name|void
name|CommaFound
argument_list|(
argument|const FormatToken *Token
argument_list|)
name|override
block|{
name|Commas
operator|.
name|push_back
argument_list|(
name|Token
argument_list|)
block|;   }
name|private
operator|:
comment|/// \brief A struct that holds information on how to format a given list with
comment|/// a specific number of columns.
expr|struct
name|ColumnFormat
block|{
comment|/// \brief The number of columns to use.
name|unsigned
name|Columns
block|;
comment|/// \brief The total width in characters.
name|unsigned
name|TotalWidth
block|;
comment|/// \brief The number of lines required for this format.
name|unsigned
name|LineCount
block|;
comment|/// \brief The size of each column in characters.
name|SmallVector
operator|<
name|unsigned
block|,
literal|8
operator|>
name|ColumnSizes
block|;   }
block|;
comment|/// \brief Calculate which \c ColumnFormat fits best into
comment|/// \p RemainingCharacters.
specifier|const
name|ColumnFormat
operator|*
name|getColumnFormat
argument_list|(
argument|unsigned RemainingCharacters
argument_list|)
specifier|const
block|;
comment|/// \brief The ordered \c FormatTokens making up the commas of this list.
name|SmallVector
operator|<
specifier|const
name|FormatToken
operator|*
block|,
literal|8
operator|>
name|Commas
block|;
comment|/// \brief The length of each of the list's items in characters including the
comment|/// trailing comma.
name|SmallVector
operator|<
name|unsigned
block|,
literal|8
operator|>
name|ItemLengths
block|;
comment|/// \brief Precomputed formats that can be used for this list.
name|SmallVector
operator|<
name|ColumnFormat
block|,
literal|4
operator|>
name|Formats
block|;
name|bool
name|HasNestedBracedList
block|; }
decl_stmt|;
comment|/// \brief Encapsulates keywords that are context sensitive or for languages not
comment|/// properly supported by Clang's lexer.
struct|struct
name|AdditionalKeywords
block|{
name|AdditionalKeywords
argument_list|(
argument|IdentifierTable&IdentTable
argument_list|)
block|{
name|kw_in
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|kw_CF_ENUM
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"CF_ENUM"
argument_list|)
expr_stmt|;
name|kw_CF_OPTIONS
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"CF_OPTIONS"
argument_list|)
expr_stmt|;
name|kw_NS_ENUM
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"NS_ENUM"
argument_list|)
expr_stmt|;
name|kw_NS_OPTIONS
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"NS_OPTIONS"
argument_list|)
expr_stmt|;
name|kw_finally
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"finally"
argument_list|)
expr_stmt|;
name|kw_function
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
name|kw_import
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"import"
argument_list|)
expr_stmt|;
name|kw_var
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"var"
argument_list|)
expr_stmt|;
name|kw_abstract
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"abstract"
argument_list|)
expr_stmt|;
name|kw_extends
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"extends"
argument_list|)
expr_stmt|;
name|kw_final
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"final"
argument_list|)
expr_stmt|;
name|kw_implements
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"implements"
argument_list|)
expr_stmt|;
name|kw_instanceof
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"instanceof"
argument_list|)
expr_stmt|;
name|kw_interface
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"interface"
argument_list|)
expr_stmt|;
name|kw_native
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"native"
argument_list|)
expr_stmt|;
name|kw_package
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"package"
argument_list|)
expr_stmt|;
name|kw_synchronized
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"synchronized"
argument_list|)
expr_stmt|;
name|kw_throws
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"throws"
argument_list|)
expr_stmt|;
name|kw___except
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"__except"
argument_list|)
expr_stmt|;
name|kw_mark
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"mark"
argument_list|)
expr_stmt|;
name|kw_option
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"option"
argument_list|)
expr_stmt|;
name|kw_optional
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"optional"
argument_list|)
expr_stmt|;
name|kw_repeated
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"repeated"
argument_list|)
expr_stmt|;
name|kw_required
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
expr_stmt|;
name|kw_returns
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"returns"
argument_list|)
expr_stmt|;
name|kw_signals
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"signals"
argument_list|)
expr_stmt|;
name|kw_slots
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"slots"
argument_list|)
expr_stmt|;
name|kw_qslots
operator|=
operator|&
name|IdentTable
operator|.
name|get
argument_list|(
literal|"Q_SLOTS"
argument_list|)
expr_stmt|;
block|}
comment|// Context sensitive keywords.
name|IdentifierInfo
modifier|*
name|kw_in
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_CF_ENUM
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_CF_OPTIONS
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_NS_ENUM
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_NS_OPTIONS
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw___except
decl_stmt|;
comment|// JavaScript keywords.
name|IdentifierInfo
modifier|*
name|kw_finally
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_function
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_import
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_var
decl_stmt|;
comment|// Java keywords.
name|IdentifierInfo
modifier|*
name|kw_abstract
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_extends
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_final
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_implements
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_instanceof
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_interface
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_native
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_package
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_synchronized
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_throws
decl_stmt|;
comment|// Pragma keywords.
name|IdentifierInfo
modifier|*
name|kw_mark
decl_stmt|;
comment|// Proto keywords.
name|IdentifierInfo
modifier|*
name|kw_option
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_optional
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_repeated
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_required
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_returns
decl_stmt|;
comment|// QT keywords.
name|IdentifierInfo
modifier|*
name|kw_signals
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_slots
decl_stmt|;
name|IdentifierInfo
modifier|*
name|kw_qslots
decl_stmt|;
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// namespace format
end_comment

begin_comment
unit|}
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

