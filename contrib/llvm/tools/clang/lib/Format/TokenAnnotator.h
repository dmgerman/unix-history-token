begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TokenAnnotator.h - Format C++ code ---------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief This file implements a token annotator, i.e. creates
end_comment

begin_comment
comment|/// \c AnnotatedTokens out of \c FormatTokens with required extra information.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_FORMAT_TOKENANNOTATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_FORMAT_TOKENANNOTATOR_H
end_define

begin_include
include|#
directive|include
file|"UnwrappedLineParser.h"
end_include

begin_include
include|#
directive|include
file|"clang/Format/Format.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|SourceManager
decl_stmt|;
name|namespace
name|format
block|{
enum|enum
name|LineType
block|{
name|LT_Invalid
block|,
name|LT_ImportStatement
block|,
name|LT_ObjCDecl
block|,
comment|// An @interface, @implementation, or @protocol line.
name|LT_ObjCMethodDecl
block|,
name|LT_ObjCProperty
block|,
comment|// An @property line.
name|LT_Other
block|,
name|LT_PreprocessorDirective
block|,
name|LT_VirtualFunctionDecl
block|}
enum|;
name|class
name|AnnotatedLine
block|{
name|public
label|:
name|AnnotatedLine
argument_list|(
specifier|const
name|UnwrappedLine
operator|&
name|Line
argument_list|)
operator|:
name|First
argument_list|(
name|Line
operator|.
name|Tokens
operator|.
name|front
argument_list|()
operator|.
name|Tok
argument_list|)
operator|,
name|Level
argument_list|(
name|Line
operator|.
name|Level
argument_list|)
operator|,
name|InPPDirective
argument_list|(
name|Line
operator|.
name|InPPDirective
argument_list|)
operator|,
name|MustBeDeclaration
argument_list|(
name|Line
operator|.
name|MustBeDeclaration
argument_list|)
operator|,
name|MightBeFunctionDecl
argument_list|(
name|false
argument_list|)
operator|,
name|IsMultiVariableDeclStmt
argument_list|(
name|false
argument_list|)
operator|,
name|Affected
argument_list|(
name|false
argument_list|)
operator|,
name|LeadingEmptyLinesAffected
argument_list|(
name|false
argument_list|)
operator|,
name|ChildrenAffected
argument_list|(
argument|false
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Line
operator|.
name|Tokens
operator|.
name|empty
argument_list|()
argument_list|)
block|;
comment|// Calculate Next and Previous for all tokens. Note that we must overwrite
comment|// Next and Previous for every token, as previous formatting runs might have
comment|// left them in a different state.
name|First
operator|->
name|Previous
operator|=
name|nullptr
block|;
name|FormatToken
operator|*
name|Current
operator|=
name|First
block|;
for|for
control|(
name|std
operator|::
name|list
operator|<
name|UnwrappedLineNode
operator|>
operator|::
name|const_iterator
name|I
operator|=
operator|++
name|Line
operator|.
name|Tokens
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Line
operator|.
name|Tokens
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
specifier|const
name|UnwrappedLineNode
modifier|&
name|Node
init|=
operator|*
name|I
decl_stmt|;
name|Current
operator|->
name|Next
operator|=
name|I
operator|->
name|Tok
expr_stmt|;
name|I
operator|->
name|Tok
operator|->
name|Previous
operator|=
name|Current
expr_stmt|;
name|Current
operator|=
name|Current
operator|->
name|Next
expr_stmt|;
name|Current
operator|->
name|Children
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Child
range|:
name|Node
operator|.
name|Children
control|)
block|{
name|Children
operator|.
name|push_back
argument_list|(
argument|new AnnotatedLine(Child)
argument_list|)
expr_stmt|;
name|Current
operator|->
name|Children
operator|.
name|push_back
argument_list|(
name|Children
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Last
operator|=
name|Current
expr_stmt|;
name|Last
operator|->
name|Next
operator|=
name|nullptr
expr_stmt|;
block|}
operator|~
name|AnnotatedLine
argument_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Children
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|delete
name|Children
index|[
name|i
index|]
decl_stmt|;
block|}
name|FormatToken
modifier|*
name|Current
init|=
name|First
decl_stmt|;
while|while
condition|(
name|Current
condition|)
block|{
name|Current
operator|->
name|Children
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Current
operator|->
name|Role
operator|.
name|reset
argument_list|()
expr_stmt|;
name|Current
operator|=
name|Current
operator|->
name|Next
expr_stmt|;
block|}
block|}
comment|/// \c true if this line starts with the given tokens in order, ignoring
comment|/// comments.
name|template
operator|<
name|typename
operator|...
name|Ts
operator|>
name|bool
name|startsWith
argument_list|(
argument|Ts... Tokens
argument_list|)
specifier|const
block|{
return|return
name|First
operator|&&
name|First
operator|->
name|startsSequence
argument_list|(
name|Tokens
operator|...
argument_list|)
return|;
block|}
comment|/// \c true if this line ends with the given tokens in reversed order,
comment|/// ignoring comments.
comment|/// For example, given tokens [T1, T2, T3, ...], the function returns true if
comment|/// this line is like "... T3 T2 T1".
name|template
operator|<
name|typename
operator|...
name|Ts
operator|>
name|bool
name|endsWith
argument_list|(
argument|Ts... Tokens
argument_list|)
specifier|const
block|{
return|return
name|Last
operator|&&
name|Last
operator|->
name|endsSequence
argument_list|(
name|Tokens
operator|...
argument_list|)
return|;
block|}
comment|/// \c true if this line looks like a function definition instead of a
comment|/// function declaration. Asserts MightBeFunctionDecl.
name|bool
name|mightBeFunctionDefinition
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|MightBeFunctionDecl
argument_list|)
block|;
comment|// FIXME: Line.Last points to other characters than tok::semi
comment|// and tok::lbrace.
return|return
operator|!
name|Last
operator|->
name|isOneOf
argument_list|(
name|tok
operator|::
name|semi
argument_list|,
name|tok
operator|::
name|comment
argument_list|)
return|;
block|}
name|FormatToken
modifier|*
name|First
decl_stmt|;
name|FormatToken
modifier|*
name|Last
decl_stmt|;
name|SmallVector
operator|<
name|AnnotatedLine
operator|*
operator|,
literal|0
operator|>
name|Children
expr_stmt|;
name|LineType
name|Type
decl_stmt|;
name|unsigned
name|Level
decl_stmt|;
name|bool
name|InPPDirective
decl_stmt|;
name|bool
name|MustBeDeclaration
decl_stmt|;
name|bool
name|MightBeFunctionDecl
decl_stmt|;
name|bool
name|IsMultiVariableDeclStmt
decl_stmt|;
comment|/// \c True if this line should be formatted, i.e. intersects directly or
comment|/// indirectly with one of the input ranges.
name|bool
name|Affected
decl_stmt|;
comment|/// \c True if the leading empty lines of this line intersect with one of the
comment|/// input ranges.
name|bool
name|LeadingEmptyLinesAffected
decl_stmt|;
comment|/// \c True if a one of this line's children intersects with an input range.
name|bool
name|ChildrenAffected
decl_stmt|;
name|private
label|:
comment|// Disallow copying.
name|AnnotatedLine
argument_list|(
specifier|const
name|AnnotatedLine
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|AnnotatedLine
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Determines extra information about the tokens comprising an
end_comment

begin_comment
comment|/// \c UnwrappedLine.
end_comment

begin_decl_stmt
name|class
name|TokenAnnotator
block|{
name|public
label|:
name|TokenAnnotator
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|,
specifier|const
name|AdditionalKeywords
operator|&
name|Keywords
argument_list|)
operator|:
name|Style
argument_list|(
name|Style
argument_list|)
operator|,
name|Keywords
argument_list|(
argument|Keywords
argument_list|)
block|{}
comment|/// \brief Adapts the indent levels of comment lines to the indent of the
comment|/// subsequent line.
comment|// FIXME: Can/should this be done in the UnwrappedLineParser?
name|void
name|setCommentLineLevels
argument_list|(
name|SmallVectorImpl
operator|<
name|AnnotatedLine
operator|*
operator|>
operator|&
name|Lines
argument_list|)
expr_stmt|;
name|void
name|annotate
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|void
name|calculateFormattingInformation
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|private
label|:
comment|/// \brief Calculate the penalty for splitting before \c Tok.
name|unsigned
name|splitPenalty
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Tok
parameter_list|,
name|bool
name|InFunctionDecl
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBetween
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Left
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Tok
parameter_list|)
function_decl|;
name|bool
name|mustBreakBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|canBreakBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|mustBreakForReturnType
argument_list|(
specifier|const
name|AnnotatedLine
operator|&
name|Line
argument_list|)
decl|const
decl_stmt|;
name|void
name|printDebugInfo
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|void
name|calculateUnbreakableTailLengths
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
specifier|const
name|FormatStyle
modifier|&
name|Style
decl_stmt|;
specifier|const
name|AdditionalKeywords
modifier|&
name|Keywords
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace format
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

