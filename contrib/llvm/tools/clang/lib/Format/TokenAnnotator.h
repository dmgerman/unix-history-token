begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TokenAnnotator.h - Format C++ code ---------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief This file implements a token annotator, i.e. creates
end_comment

begin_comment
comment|/// \c AnnotatedTokens out of \c FormatTokens with required extra information.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_define

begin_include
include|#
directive|include
file|"UnwrappedLineParser.h"
end_include

begin_include
include|#
directive|include
file|"clang/Format/Format.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|SourceManager
decl_stmt|;
name|namespace
name|format
block|{
enum|enum
name|LineType
block|{
name|LT_Invalid
block|,
name|LT_Other
block|,
name|LT_PreprocessorDirective
block|,
name|LT_VirtualFunctionDecl
block|,
name|LT_ObjCDecl
block|,
comment|// An @interface, @implementation, or @protocol line.
name|LT_ObjCMethodDecl
block|,
name|LT_ObjCProperty
comment|// An @property line.
block|}
enum|;
name|class
name|AnnotatedLine
block|{
name|public
label|:
name|AnnotatedLine
argument_list|(
specifier|const
name|UnwrappedLine
operator|&
name|Line
argument_list|)
operator|:
name|First
argument_list|(
name|Line
operator|.
name|Tokens
operator|.
name|front
argument_list|()
operator|.
name|Tok
argument_list|)
operator|,
name|Level
argument_list|(
name|Line
operator|.
name|Level
argument_list|)
operator|,
name|InPPDirective
argument_list|(
name|Line
operator|.
name|InPPDirective
argument_list|)
operator|,
name|MustBeDeclaration
argument_list|(
name|Line
operator|.
name|MustBeDeclaration
argument_list|)
operator|,
name|MightBeFunctionDecl
argument_list|(
name|false
argument_list|)
operator|,
name|StartsDefinition
argument_list|(
argument|false
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Line
operator|.
name|Tokens
operator|.
name|empty
argument_list|()
argument_list|)
block|;
comment|// Calculate Next and Previous for all tokens. Note that we must overwrite
comment|// Next and Previous for every token, as previous formatting runs might have
comment|// left them in a different state.
name|First
operator|->
name|Previous
operator|=
name|NULL
block|;
name|FormatToken
operator|*
name|Current
operator|=
name|First
block|;
for|for
control|(
name|std
operator|::
name|list
operator|<
name|UnwrappedLineNode
operator|>
operator|::
name|const_iterator
name|I
operator|=
operator|++
name|Line
operator|.
name|Tokens
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Line
operator|.
name|Tokens
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
specifier|const
name|UnwrappedLineNode
modifier|&
name|Node
init|=
operator|*
name|I
decl_stmt|;
name|Current
operator|->
name|Next
operator|=
name|I
operator|->
name|Tok
expr_stmt|;
name|I
operator|->
name|Tok
operator|->
name|Previous
operator|=
name|Current
expr_stmt|;
name|Current
operator|=
name|Current
operator|->
name|Next
expr_stmt|;
name|Current
operator|->
name|Children
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SmallVectorImpl
operator|<
name|UnwrappedLine
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|Node
operator|.
name|Children
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Node
operator|.
name|Children
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Children
operator|.
name|push_back
argument_list|(
argument|new AnnotatedLine(*I)
argument_list|)
expr_stmt|;
name|Current
operator|->
name|Children
operator|.
name|push_back
argument_list|(
name|Children
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Last
operator|=
name|Current
expr_stmt|;
name|Last
operator|->
name|Next
operator|=
name|NULL
expr_stmt|;
block|}
operator|~
name|AnnotatedLine
argument_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Children
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|delete
name|Children
index|[
name|i
index|]
decl_stmt|;
block|}
block|}
name|FormatToken
operator|*
name|First
expr_stmt|;
name|FormatToken
modifier|*
name|Last
decl_stmt|;
name|SmallVector
operator|<
name|AnnotatedLine
operator|*
operator|,
literal|0
operator|>
name|Children
expr_stmt|;
name|LineType
name|Type
decl_stmt|;
name|unsigned
name|Level
decl_stmt|;
name|bool
name|InPPDirective
decl_stmt|;
name|bool
name|MustBeDeclaration
decl_stmt|;
name|bool
name|MightBeFunctionDecl
decl_stmt|;
name|bool
name|StartsDefinition
decl_stmt|;
name|private
label|:
comment|// Disallow copying.
name|AnnotatedLine
argument_list|(
argument|const AnnotatedLine&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|AnnotatedLine
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief Determines extra information about the tokens comprising an
comment|/// \c UnwrappedLine.
name|class
name|TokenAnnotator
block|{
name|public
label|:
name|TokenAnnotator
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|,
name|IdentifierInfo
operator|&
name|Ident_in
argument_list|)
operator|:
name|Style
argument_list|(
name|Style
argument_list|)
operator|,
name|Ident_in
argument_list|(
argument|Ident_in
argument_list|)
block|{}
comment|/// \brief Adapts the indent levels of comment lines to the indent of the
comment|/// subsequent line.
comment|// FIXME: Can/should this be done in the UnwrappedLineParser?
name|void
name|setCommentLineLevels
argument_list|(
name|SmallVectorImpl
operator|<
name|AnnotatedLine
operator|*
operator|>
operator|&
name|Lines
argument_list|)
expr_stmt|;
name|void
name|annotate
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|void
name|calculateFormattingInformation
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|private
label|:
comment|/// \brief Calculate the penalty for splitting before \c Tok.
name|unsigned
name|splitPenalty
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Tok
parameter_list|,
name|bool
name|InFunctionDecl
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBetween
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Left
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Tok
parameter_list|)
function_decl|;
name|bool
name|mustBreakBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|canBreakBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|FormatToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|void
name|printDebugInfo
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|void
name|calculateUnbreakableTailLengths
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
specifier|const
name|FormatStyle
modifier|&
name|Style
decl_stmt|;
comment|// Contextual keywords:
name|IdentifierInfo
modifier|&
name|Ident_in
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace format
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_comment

end_unit

