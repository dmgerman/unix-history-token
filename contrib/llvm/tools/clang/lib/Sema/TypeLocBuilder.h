begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TypeLocBuilder.h - Type Source Info collector ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This files defines TypeLocBuilder, a class for building TypeLocs
end_comment

begin_comment
comment|//  bottom-up.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_TYPELOCBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_TYPELOCBUILDER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/TypeLoc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|TypeLocBuilder
block|{
enum|enum
block|{
name|InlineCapacity
init|=
literal|8
operator|*
expr|sizeof
operator|(
name|SourceLocation
operator|)
block|}
enum|;
comment|/// The underlying location-data buffer.  Data grows from the end
comment|/// of the buffer backwards.
name|char
modifier|*
name|Buffer
decl_stmt|;
comment|/// The capacity of the current buffer.
name|size_t
name|Capacity
decl_stmt|;
comment|/// The index of the first occupied byte in the buffer.
name|size_t
name|Index
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
comment|/// The last type pushed on this builder.
name|QualType
name|LastTy
decl_stmt|;
endif|#
directive|endif
comment|/// The inline buffer.
name|char
name|InlineBuffer
index|[
name|InlineCapacity
index|]
decl_stmt|;
name|public
label|:
name|TypeLocBuilder
argument_list|()
operator|:
name|Buffer
argument_list|(
name|InlineBuffer
argument_list|)
operator|,
name|Capacity
argument_list|(
name|InlineCapacity
argument_list|)
operator|,
name|Index
argument_list|(
argument|InlineCapacity
argument_list|)
block|{}
operator|~
name|TypeLocBuilder
argument_list|()
block|{
if|if
condition|(
name|Buffer
operator|!=
name|InlineBuffer
condition|)
name|delete
index|[]
name|Buffer
decl_stmt|;
block|}
comment|/// Ensures that this buffer has at least as much capacity as described.
name|void
name|reserve
parameter_list|(
name|size_t
name|Requested
parameter_list|)
block|{
if|if
condition|(
name|Requested
operator|>
name|Capacity
condition|)
comment|// For now, match the request exactly.
name|grow
argument_list|(
name|Requested
argument_list|)
expr_stmt|;
block|}
comment|/// Pushes a copy of the given TypeLoc onto this builder.  The builder
comment|/// must be empty for this to work.
name|void
name|pushFullCopy
parameter_list|(
name|TypeLoc
name|L
parameter_list|)
block|{
name|size_t
name|Size
init|=
name|L
operator|.
name|getFullDataSize
argument_list|()
decl_stmt|;
name|TypeLoc
name|Copy
init|=
name|pushFullUninitializedImpl
argument_list|(
name|L
operator|.
name|getType
argument_list|()
argument_list|,
name|Size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|Copy
operator|.
name|getOpaqueData
argument_list|()
argument_list|,
name|L
operator|.
name|getOpaqueData
argument_list|()
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
comment|/// Pushes uninitialized space for the given type.  The builder must
comment|/// be empty.
name|TypeLoc
name|pushFullUninitialized
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|pushFullUninitializedImpl
argument_list|(
name|T
argument_list|,
name|TypeLoc
operator|::
name|getFullDataSizeForType
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
comment|/// Pushes space for a typespec TypeLoc.  Invalidates any TypeLocs
comment|/// previously retrieved from this builder.
name|TypeSpecTypeLoc
name|pushTypeSpec
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
name|size_t
name|LocalSize
init|=
name|TypeSpecTypeLoc
operator|::
name|LocalDataSize
decl_stmt|;
return|return
name|cast
operator|<
name|TypeSpecTypeLoc
operator|>
operator|(
name|pushImpl
argument_list|(
name|T
argument_list|,
name|LocalSize
argument_list|)
operator|)
return|;
block|}
comment|/// Resets this builder to the newly-initialized state.
name|void
name|clear
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|LastTy
operator|=
name|QualType
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Index
operator|=
name|Capacity
expr_stmt|;
block|}
comment|/// Pushes space for a new TypeLoc of the given type.  Invalidates
comment|/// any TypeLocs previously retrieved from this builder.
name|template
operator|<
name|class
name|TyLocType
operator|>
name|TyLocType
name|push
argument_list|(
argument|QualType T
argument_list|)
block|{
name|size_t
name|LocalSize
operator|=
name|cast
operator|<
name|TyLocType
operator|>
operator|(
name|TypeLoc
argument_list|(
name|T
argument_list|,
literal|0
argument_list|)
operator|)
operator|.
name|getLocalDataSize
argument_list|()
block|;
return|return
name|cast
operator|<
name|TyLocType
operator|>
operator|(
name|pushImpl
argument_list|(
name|T
argument_list|,
name|LocalSize
argument_list|)
operator|)
return|;
block|}
comment|/// Creates a TypeSourceInfo for the given type.
name|TypeSourceInfo
modifier|*
name|getTypeSourceInfo
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|QualType
name|T
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|T
operator|==
name|LastTy
operator|&&
literal|"type doesn't match last type pushed!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size_t
name|FullDataSize
init|=
name|Capacity
operator|-
name|Index
decl_stmt|;
name|TypeSourceInfo
modifier|*
name|DI
init|=
name|Context
operator|.
name|CreateTypeSourceInfo
argument_list|(
name|T
argument_list|,
name|FullDataSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|DI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getOpaqueData
argument_list|()
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|,
name|FullDataSize
argument_list|)
expr_stmt|;
return|return
name|DI
return|;
block|}
comment|/// \brief Copies the type-location information to the given AST context and
comment|/// returns a \c TypeLoc referring into the AST context.
name|TypeLoc
name|getTypeLocInContext
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|QualType
name|T
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|T
operator|==
name|LastTy
operator|&&
literal|"type doesn't match last type pushed!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size_t
name|FullDataSize
init|=
name|Capacity
operator|-
name|Index
decl_stmt|;
name|void
modifier|*
name|Mem
init|=
name|Context
operator|.
name|Allocate
argument_list|(
name|FullDataSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|Mem
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|,
name|FullDataSize
argument_list|)
expr_stmt|;
return|return
name|TypeLoc
argument_list|(
name|T
argument_list|,
name|Mem
argument_list|)
return|;
block|}
name|private
label|:
name|TypeLoc
name|pushImpl
parameter_list|(
name|QualType
name|T
parameter_list|,
name|size_t
name|LocalSize
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|QualType
name|TLast
init|=
name|TypeLoc
argument_list|(
name|T
argument_list|,
literal|0
argument_list|)
operator|.
name|getNextTypeLoc
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|TLast
operator|==
name|LastTy
operator|&&
literal|"mismatch between last type and new type's inner type"
argument_list|)
expr_stmt|;
name|LastTy
operator|=
name|T
expr_stmt|;
endif|#
directive|endif
comment|// If we need to grow, grow by a factor of 2.
if|if
condition|(
name|LocalSize
operator|>
name|Index
condition|)
block|{
name|size_t
name|RequiredCapacity
init|=
name|Capacity
operator|+
operator|(
name|LocalSize
operator|-
name|Index
operator|)
decl_stmt|;
name|size_t
name|NewCapacity
init|=
name|Capacity
operator|*
literal|2
decl_stmt|;
while|while
condition|(
name|RequiredCapacity
operator|>
name|NewCapacity
condition|)
name|NewCapacity
operator|*=
literal|2
expr_stmt|;
name|grow
argument_list|(
name|NewCapacity
argument_list|)
expr_stmt|;
block|}
name|Index
operator|-=
name|LocalSize
expr_stmt|;
return|return
name|getTypeLoc
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|/// Grow to the given capacity.
name|void
name|grow
parameter_list|(
name|size_t
name|NewCapacity
parameter_list|)
block|{
name|assert
argument_list|(
name|NewCapacity
operator|>
name|Capacity
argument_list|)
expr_stmt|;
comment|// Allocate the new buffer and copy the old data into it.
name|char
modifier|*
name|NewBuffer
init|=
name|new
name|char
index|[
name|NewCapacity
index|]
decl_stmt|;
name|unsigned
name|NewIndex
init|=
name|Index
operator|+
name|NewCapacity
operator|-
name|Capacity
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|NewBuffer
index|[
name|NewIndex
index|]
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|,
name|Capacity
operator|-
name|Index
argument_list|)
expr_stmt|;
if|if
condition|(
name|Buffer
operator|!=
name|InlineBuffer
condition|)
name|delete
index|[]
name|Buffer
decl_stmt|;
name|Buffer
operator|=
name|NewBuffer
expr_stmt|;
name|Capacity
operator|=
name|NewCapacity
expr_stmt|;
name|Index
operator|=
name|NewIndex
expr_stmt|;
block|}
name|TypeLoc
name|pushFullUninitializedImpl
parameter_list|(
name|QualType
name|T
parameter_list|,
name|size_t
name|Size
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|LastTy
operator|.
name|isNull
argument_list|()
operator|&&
literal|"pushing full on non-empty TypeLocBuilder"
argument_list|)
expr_stmt|;
name|LastTy
operator|=
name|T
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|Index
operator|==
name|Capacity
operator|&&
literal|"pushing full on non-empty TypeLocBuilder"
argument_list|)
expr_stmt|;
name|reserve
argument_list|(
name|Size
argument_list|)
expr_stmt|;
name|Index
operator|-=
name|Size
expr_stmt|;
return|return
name|getTypeLoc
argument_list|(
name|T
argument_list|)
return|;
block|}
comment|// This is private because, when we kill off TypeSourceInfo in favor
comment|// of TypeLoc, we'll want an interface that creates a TypeLoc given
comment|// an ASTContext, and we don't want people to think they can just
comment|// use this as an equivalent.
name|TypeLoc
name|getTypeLoc
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|assert
argument_list|(
name|LastTy
operator|==
name|T
operator|&&
literal|"type doesn't match last type pushed!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TypeLoc
argument_list|(
name|T
argument_list|,
operator|&
name|Buffer
index|[
name|Index
index|]
argument_list|)
return|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

