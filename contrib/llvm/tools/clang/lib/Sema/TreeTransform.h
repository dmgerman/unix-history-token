begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------- TreeTransform.h - Semantic Tree Transformation -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file implements a semantic tree transformation that takes a given
end_comment

begin_comment
comment|//  AST and rebuilds it, possibly transforming some nodes in the process.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_TREETRANSFORM_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_TREETRANSFORM_H
end_define

begin_include
include|#
directive|include
file|"TypeLocBuilder.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Stmt.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtOpenMP.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Designator.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Lookup.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/ParsedTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/ScopeInfo.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/SemaDiagnostic.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/SemaInternal.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|using
name|namespace
name|sema
decl_stmt|;
comment|/// \brief A semantic tree transformation that allows one to transform one
comment|/// abstract syntax tree into another.
comment|///
comment|/// A new tree transformation is defined by creating a new subclass \c X of
comment|/// \c TreeTransform<X> and then overriding certain operations to provide
comment|/// behavior specific to that transformation. For example, template
comment|/// instantiation is implemented as a tree transformation where the
comment|/// transformation of TemplateTypeParmType nodes involves substituting the
comment|/// template arguments for their corresponding template parameters; a similar
comment|/// transformation is performed for non-type template parameters and
comment|/// template template parameters.
comment|///
comment|/// This tree-transformation template uses static polymorphism to allow
comment|/// subclasses to customize any of its operations. Thus, a subclass can
comment|/// override any of the transformation or rebuild operators by providing an
comment|/// operation with the same signature as the default implementation. The
comment|/// overridding function should not be virtual.
comment|///
comment|/// Semantic tree transformations are split into two stages, either of which
comment|/// can be replaced by a subclass. The "transform" step transforms an AST node
comment|/// or the parts of an AST node using the various transformation functions,
comment|/// then passes the pieces on to the "rebuild" step, which constructs a new AST
comment|/// node of the appropriate kind from the pieces. The default transformation
comment|/// routines recursively transform the operands to composite AST nodes (e.g.,
comment|/// the pointee type of a PointerType node) and, if any of those operand nodes
comment|/// were changed by the transformation, invokes the rebuild operation to create
comment|/// a new AST node.
comment|///
comment|/// Subclasses can customize the transformation at various levels. The
comment|/// most coarse-grained transformations involve replacing TransformType(),
comment|/// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),
comment|/// TransformTemplateName(), or TransformTemplateArgument() with entirely
comment|/// new implementations.
comment|///
comment|/// For more fine-grained transformations, subclasses can replace any of the
comment|/// \c TransformXXX functions (where XXX is the name of an AST node, e.g.,
comment|/// PointerType, StmtExpr) to alter the transformation. As mentioned previously,
comment|/// replacing TransformTemplateTypeParmType() allows template instantiation
comment|/// to substitute template arguments for their corresponding template
comment|/// parameters. Additionally, subclasses can override the \c RebuildXXX
comment|/// functions to control how AST nodes are rebuilt when their operands change.
comment|/// By default, \c TreeTransform will invoke semantic analysis to rebuild
comment|/// AST nodes. However, certain other tree transformations (e.g, cloning) may
comment|/// be able to use more efficient rebuild steps.
comment|///
comment|/// There are a handful of other functions that can be overridden, allowing one
comment|/// to avoid traversing nodes that don't need any transformation
comment|/// (\c AlreadyTransformed()), force rebuilding AST nodes even when their
comment|/// operands have not changed (\c AlwaysRebuild()), and customize the
comment|/// default locations and entity names used for type-checking
comment|/// (\c getBaseLocation(), \c getBaseEntity()).
name|template
operator|<
name|typename
name|Derived
operator|>
name|class
name|TreeTransform
block|{
comment|/// \brief Private RAII object that helps us forget and then re-remember
comment|/// the template argument corresponding to a partially-substituted parameter
comment|/// pack.
name|class
name|ForgetPartiallySubstitutedPackRAII
block|{
name|Derived
operator|&
name|Self
block|;
name|TemplateArgument
name|Old
block|;
name|public
operator|:
name|ForgetPartiallySubstitutedPackRAII
argument_list|(
name|Derived
operator|&
name|Self
argument_list|)
operator|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
name|Old
operator|=
name|Self
operator|.
name|ForgetPartiallySubstitutedPack
argument_list|()
block|;     }
operator|~
name|ForgetPartiallySubstitutedPackRAII
argument_list|()
block|{
name|Self
operator|.
name|RememberPartiallySubstitutedPack
argument_list|(
name|Old
argument_list|)
block|;     }
block|}
block|;
name|protected
operator|:
name|Sema
operator|&
name|SemaRef
block|;
comment|/// \brief The set of local declarations that have been transformed, for
comment|/// cases where we are forced to build new declarations within the transformer
comment|/// rather than in the subclass (e.g., lambda closure types).
name|llvm
operator|::
name|DenseMap
operator|<
name|Decl
operator|*
block|,
name|Decl
operator|*
operator|>
name|TransformedLocalDecls
block|;
name|public
operator|:
comment|/// \brief Initializes a new tree transformer.
name|TreeTransform
argument_list|(
name|Sema
operator|&
name|SemaRef
argument_list|)
operator|:
name|SemaRef
argument_list|(
argument|SemaRef
argument_list|)
block|{ }
comment|/// \brief Retrieves a reference to the derived class.
name|Derived
operator|&
name|getDerived
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|Derived
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
comment|/// \brief Retrieves a reference to the derived class.
specifier|const
name|Derived
operator|&
name|getDerived
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|Derived
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
specifier|static
specifier|inline
name|ExprResult
name|Owned
argument_list|(
argument|Expr *E
argument_list|)
block|{
return|return
name|E
return|;
block|}
specifier|static
specifier|inline
name|StmtResult
name|Owned
argument_list|(
argument|Stmt *S
argument_list|)
block|{
return|return
name|S
return|;
block|}
comment|/// \brief Retrieves a reference to the semantic analysis object used for
comment|/// this tree transform.
name|Sema
operator|&
name|getSema
argument_list|()
specifier|const
block|{
return|return
name|SemaRef
return|;
block|}
comment|/// \brief Whether the transformation should always rebuild AST nodes, even
comment|/// if none of the children have changed.
comment|///
comment|/// Subclasses may override this function to specify when the transformation
comment|/// should rebuild all AST nodes.
comment|///
comment|/// We must always rebuild all AST nodes when performing variadic template
comment|/// pack expansion, in order to avoid violating the AST invariant that each
comment|/// statement node appears at most once in its containing declaration.
name|bool
name|AlwaysRebuild
argument_list|()
block|{
return|return
name|SemaRef
operator|.
name|ArgumentPackSubstitutionIndex
operator|!=
operator|-
literal|1
return|;
block|}
comment|/// \brief Returns the location of the entity being transformed, if that
comment|/// information was not available elsewhere in the AST.
comment|///
comment|/// By default, returns no source-location information. Subclasses can
comment|/// provide an alternative implementation that provides better location
comment|/// information.
name|SourceLocation
name|getBaseLocation
argument_list|()
block|{
return|return
name|SourceLocation
argument_list|()
return|;
block|}
comment|/// \brief Returns the name of the entity being transformed, if that
comment|/// information was not available elsewhere in the AST.
comment|///
comment|/// By default, returns an empty name. Subclasses can provide an alternative
comment|/// implementation with a more precise name.
name|DeclarationName
name|getBaseEntity
argument_list|()
block|{
return|return
name|DeclarationName
argument_list|()
return|;
block|}
comment|/// \brief Sets the "base" location and entity when that
comment|/// information is known based on another transformation.
comment|///
comment|/// By default, the source location and entity are ignored. Subclasses can
comment|/// override this function to provide a customized implementation.
name|void
name|setBase
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|DeclarationName Entity
argument_list|)
block|{ }
comment|/// \brief RAII object that temporarily sets the base location and entity
comment|/// used for reporting diagnostics in types.
name|class
name|TemporaryBase
block|{
name|TreeTransform
operator|&
name|Self
block|;
name|SourceLocation
name|OldLocation
block|;
name|DeclarationName
name|OldEntity
block|;
name|public
operator|:
name|TemporaryBase
argument_list|(
argument|TreeTransform&Self
argument_list|,
argument|SourceLocation Location
argument_list|,
argument|DeclarationName Entity
argument_list|)
operator|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
name|OldLocation
operator|=
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
block|;
name|OldEntity
operator|=
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
block|;
if|if
condition|(
name|Location
operator|.
name|isValid
argument_list|()
condition|)
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|setBase
argument_list|(
name|Location
argument_list|,
name|Entity
argument_list|)
expr_stmt|;
block|}
operator|~
name|TemporaryBase
argument_list|()
block|{
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|setBase
argument_list|(
name|OldLocation
argument_list|,
name|OldEntity
argument_list|)
block|;     }
expr|}
block|;
comment|/// \brief Determine whether the given type \p T has already been
comment|/// transformed.
comment|///
comment|/// Subclasses can provide an alternative implementation of this routine
comment|/// to short-circuit evaluation when it is known that a given type will
comment|/// not change. For example, template instantiation need not traverse
comment|/// non-dependent types.
name|bool
name|AlreadyTransformed
argument_list|(
argument|QualType T
argument_list|)
block|{
return|return
name|T
operator|.
name|isNull
argument_list|()
return|;
block|}
comment|/// \brief Determine whether the given call argument should be dropped, e.g.,
comment|/// because it is a default argument.
comment|///
comment|/// Subclasses can provide an alternative implementation of this routine to
comment|/// determine which kinds of call arguments get dropped. By default,
comment|/// CXXDefaultArgument nodes are dropped (prior to transformation).
name|bool
name|DropCallArgument
argument_list|(
argument|Expr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|isDefaultArgument
argument_list|()
return|;
block|}
comment|/// \brief Determine whether we should expand a pack expansion with the
comment|/// given set of parameter packs into separate arguments by repeatedly
comment|/// transforming the pattern.
comment|///
comment|/// By default, the transformer never tries to expand pack expansions.
comment|/// Subclasses can override this routine to provide different behavior.
comment|///
comment|/// \param EllipsisLoc The location of the ellipsis that identifies the
comment|/// pack expansion.
comment|///
comment|/// \param PatternRange The source range that covers the entire pattern of
comment|/// the pack expansion.
comment|///
comment|/// \param Unexpanded The set of unexpanded parameter packs within the
comment|/// pattern.
comment|///
comment|/// \param ShouldExpand Will be set to \c true if the transformer should
comment|/// expand the corresponding pack expansions into separate arguments. When
comment|/// set, \c NumExpansions must also be set.
comment|///
comment|/// \param RetainExpansion Whether the caller should add an unexpanded
comment|/// pack expansion after all of the expanded arguments. This is used
comment|/// when extending explicitly-specified template argument packs per
comment|/// C++0x [temp.arg.explicit]p9.
comment|///
comment|/// \param NumExpansions The number of separate arguments that will be in
comment|/// the expanded form of the corresponding pack expansion. This is both an
comment|/// input and an output parameter, which can be set by the caller if the
comment|/// number of expansions is known a priori (e.g., due to a prior substitution)
comment|/// and will be set by the callee when the number of expansions is known.
comment|/// The callee must set this value when \c ShouldExpand is \c true; it may
comment|/// set this value in other cases.
comment|///
comment|/// \returns true if an error occurred (e.g., because the parameter packs
comment|/// are to be instantiated with arguments of different lengths), false
comment|/// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions)
comment|/// must be set.
name|bool
name|TryExpandParameterPacks
argument_list|(
argument|SourceLocation EllipsisLoc
argument_list|,
argument|SourceRange PatternRange
argument_list|,
argument|ArrayRef<UnexpandedParameterPack> Unexpanded
argument_list|,
argument|bool&ShouldExpand
argument_list|,
argument|bool&RetainExpansion
argument_list|,
argument|Optional<unsigned>&NumExpansions
argument_list|)
block|{
name|ShouldExpand
operator|=
name|false
block|;
return|return
name|false
return|;
block|}
comment|/// \brief "Forget" about the partially-substituted pack template argument,
comment|/// when performing an instantiation that must preserve the parameter pack
comment|/// use.
comment|///
comment|/// This routine is meant to be overridden by the template instantiator.
name|TemplateArgument
name|ForgetPartiallySubstitutedPack
argument_list|()
block|{
return|return
name|TemplateArgument
argument_list|()
return|;
block|}
comment|/// \brief "Remember" the partially-substituted pack template argument
comment|/// after performing an instantiation that must preserve the parameter pack
comment|/// use.
comment|///
comment|/// This routine is meant to be overridden by the template instantiator.
name|void
name|RememberPartiallySubstitutedPack
argument_list|(
argument|TemplateArgument Arg
argument_list|)
block|{ }
comment|/// \brief Note to the derived class when a function parameter pack is
comment|/// being expanded.
name|void
name|ExpandingFunctionParameterPack
argument_list|(
argument|ParmVarDecl *Pack
argument_list|)
block|{ }
comment|/// \brief Transforms the given type into another type.
comment|///
comment|/// By default, this routine transforms a type by creating a
comment|/// TypeSourceInfo for it and delegating to the appropriate
comment|/// function.  This is expensive, but we don't mind, because
comment|/// this method is deprecated anyway;  all users should be
comment|/// switched to storing TypeSourceInfos.
comment|///
comment|/// \returns the transformed type.
name|QualType
name|TransformType
argument_list|(
argument|QualType T
argument_list|)
block|;
comment|/// \brief Transforms the given type-with-location into a new
comment|/// type-with-location.
comment|///
comment|/// By default, this routine transforms a type by delegating to the
comment|/// appropriate TransformXXXType to build a new type.  Subclasses
comment|/// may override this function (to take over all type
comment|/// transformations) or some set of the TransformXXXType functions
comment|/// to alter the transformation.
name|TypeSourceInfo
operator|*
name|TransformType
argument_list|(
name|TypeSourceInfo
operator|*
name|DI
argument_list|)
block|;
comment|/// \brief Transform the given type-with-location into a new
comment|/// type, collecting location information in the given builder
comment|/// as necessary.
comment|///
name|QualType
name|TransformType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeLoc TL
argument_list|)
block|;
comment|/// \brief Transform the given statement.
comment|///
comment|/// By default, this routine transforms a statement by delegating to the
comment|/// appropriate TransformXXXStmt function to transform a specific kind of
comment|/// statement or the TransformExpr() function to transform an expression.
comment|/// Subclasses may override this function to transform statements using some
comment|/// other mechanism.
comment|///
comment|/// \returns the transformed statement.
name|StmtResult
name|TransformStmt
argument_list|(
name|Stmt
operator|*
name|S
argument_list|)
block|;
comment|/// \brief Transform the given statement.
comment|///
comment|/// By default, this routine transforms a statement by delegating to the
comment|/// appropriate TransformOMPXXXClause function to transform a specific kind
comment|/// of clause. Subclasses may override this function to transform statements
comment|/// using some other mechanism.
comment|///
comment|/// \returns the transformed OpenMP clause.
name|OMPClause
operator|*
name|TransformOMPClause
argument_list|(
name|OMPClause
operator|*
name|S
argument_list|)
block|;
comment|/// \brief Transform the given expression.
comment|///
comment|/// By default, this routine transforms an expression by delegating to the
comment|/// appropriate TransformXXXExpr function to build a new expression.
comment|/// Subclasses may override this function to transform expressions using some
comment|/// other mechanism.
comment|///
comment|/// \returns the transformed expression.
name|ExprResult
name|TransformExpr
argument_list|(
name|Expr
operator|*
name|E
argument_list|)
block|;
comment|/// \brief Transform the given initializer.
comment|///
comment|/// By default, this routine transforms an initializer by stripping off the
comment|/// semantic nodes added by initialization, then passing the result to
comment|/// TransformExpr or TransformExprs.
comment|///
comment|/// \returns the transformed initializer.
name|ExprResult
name|TransformInitializer
argument_list|(
argument|Expr *Init
argument_list|,
argument|bool CXXDirectInit
argument_list|)
block|;
comment|/// \brief Transform the given list of expressions.
comment|///
comment|/// This routine transforms a list of expressions by invoking
comment|/// \c TransformExpr() for each subexpression. However, it also provides
comment|/// support for variadic templates by expanding any pack expansions (if the
comment|/// derived class permits such expansion) along the way. When pack expansions
comment|/// are present, the number of outputs may not equal the number of inputs.
comment|///
comment|/// \param Inputs The set of expressions to be transformed.
comment|///
comment|/// \param NumInputs The number of expressions in \c Inputs.
comment|///
comment|/// \param IsCall If \c true, then this transform is being performed on
comment|/// function-call arguments, and any arguments that should be dropped, will
comment|/// be.
comment|///
comment|/// \param Outputs The transformed input expressions will be added to this
comment|/// vector.
comment|///
comment|/// \param ArgChanged If non-NULL, will be set \c true if any argument changed
comment|/// due to transformation.
comment|///
comment|/// \returns true if an error occurred, false otherwise.
name|bool
name|TransformExprs
argument_list|(
argument|Expr **Inputs
argument_list|,
argument|unsigned NumInputs
argument_list|,
argument|bool IsCall
argument_list|,
argument|SmallVectorImpl<Expr *>&Outputs
argument_list|,
argument|bool *ArgChanged =
literal|0
argument_list|)
block|;
comment|/// \brief Transform the given declaration, which is referenced from a type
comment|/// or expression.
comment|///
comment|/// By default, acts as the identity function on declarations, unless the
comment|/// transformer has had to transform the declaration itself. Subclasses
comment|/// may override this function to provide alternate behavior.
name|Decl
operator|*
name|TransformDecl
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Decl *D
argument_list|)
block|{
name|llvm
operator|::
name|DenseMap
operator|<
name|Decl
operator|*
block|,
name|Decl
operator|*
operator|>
operator|::
name|iterator
name|Known
operator|=
name|TransformedLocalDecls
operator|.
name|find
argument_list|(
name|D
argument_list|)
block|;
if|if
condition|(
name|Known
operator|!=
name|TransformedLocalDecls
operator|.
name|end
argument_list|()
condition|)
return|return
name|Known
operator|->
name|second
return|;
return|return
name|D
return|;
block|}
comment|/// \brief Transform the attributes associated with the given declaration and
comment|/// place them on the new declaration.
comment|///
comment|/// By default, this operation does nothing. Subclasses may override this
comment|/// behavior to transform attributes.
name|void
name|transformAttrs
argument_list|(
argument|Decl *Old
argument_list|,
argument|Decl *New
argument_list|)
block|{ }
comment|/// \brief Note that a local declaration has been transformed by this
comment|/// transformer.
comment|///
comment|/// Local declarations are typically transformed via a call to
comment|/// TransformDefinition. However, in some cases (e.g., lambda expressions),
comment|/// the transformer itself has to transform the declarations. This routine
comment|/// can be overridden by a subclass that keeps track of such mappings.
name|void
name|transformedLocalDecl
argument_list|(
argument|Decl *Old
argument_list|,
argument|Decl *New
argument_list|)
block|{
name|TransformedLocalDecls
index|[
name|Old
index|]
operator|=
name|New
block|;   }
comment|/// \brief Transform the definition of the given declaration.
comment|///
comment|/// By default, invokes TransformDecl() to transform the declaration.
comment|/// Subclasses may override this function to provide alternate behavior.
name|Decl
operator|*
name|TransformDefinition
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Decl *D
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|D
argument_list|)
return|;
block|}
comment|/// \brief Transform the given declaration, which was the first part of a
comment|/// nested-name-specifier in a member access expression.
comment|///
comment|/// This specific declaration transformation only applies to the first
comment|/// identifier in a nested-name-specifier of a member access expression, e.g.,
comment|/// the \c T in \c x->T::member
comment|///
comment|/// By default, invokes TransformDecl() to transform the declaration.
comment|/// Subclasses may override this function to provide alternate behavior.
name|NamedDecl
operator|*
name|TransformFirstQualifierInScope
argument_list|(
argument|NamedDecl *D
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
return|return
name|cast_or_null
operator|<
name|NamedDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|D
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Transform the given nested-name-specifier with source-location
comment|/// information.
comment|///
comment|/// By default, transforms all of the types and declarations within the
comment|/// nested-name-specifier. Subclasses may override this function to provide
comment|/// alternate behavior.
name|NestedNameSpecifierLoc
name|TransformNestedNameSpecifierLoc
argument_list|(
argument|NestedNameSpecifierLoc NNS
argument_list|,
argument|QualType ObjectType = QualType()
argument_list|,
argument|NamedDecl *FirstQualifierInScope =
literal|0
argument_list|)
block|;
comment|/// \brief Transform the given declaration name.
comment|///
comment|/// By default, transforms the types of conversion function, constructor,
comment|/// and destructor names and then (if needed) rebuilds the declaration name.
comment|/// Identifiers and selectors are returned unmodified. Sublcasses may
comment|/// override this function to provide alternate behavior.
name|DeclarationNameInfo
name|TransformDeclarationNameInfo
argument_list|(
specifier|const
name|DeclarationNameInfo
operator|&
name|NameInfo
argument_list|)
block|;
comment|/// \brief Transform the given template name.
comment|///
comment|/// \param SS The nested-name-specifier that qualifies the template
comment|/// name. This nested-name-specifier must already have been transformed.
comment|///
comment|/// \param Name The template name to transform.
comment|///
comment|/// \param NameLoc The source location of the template name.
comment|///
comment|/// \param ObjectType If we're translating a template name within a member
comment|/// access expression, this is the type of the object whose member template
comment|/// is being referenced.
comment|///
comment|/// \param FirstQualifierInScope If the first part of a nested-name-specifier
comment|/// also refers to a name within the current (lexical) scope, this is the
comment|/// declaration it refers to.
comment|///
comment|/// By default, transforms the template name by transforming the declarations
comment|/// and nested-name-specifiers that occur within the template name.
comment|/// Subclasses may override this function to provide alternate behavior.
name|TemplateName
name|TransformTemplateName
argument_list|(
argument|CXXScopeSpec&SS
argument_list|,
argument|TemplateName Name
argument_list|,
argument|SourceLocation NameLoc
argument_list|,
argument|QualType ObjectType = QualType()
argument_list|,
argument|NamedDecl *FirstQualifierInScope =
literal|0
argument_list|)
block|;
comment|/// \brief Transform the given template argument.
comment|///
comment|/// By default, this operation transforms the type, expression, or
comment|/// declaration stored within the template argument and constructs a
comment|/// new template argument from the transformed result. Subclasses may
comment|/// override this function to provide alternate behavior.
comment|///
comment|/// Returns true if there was an error.
name|bool
name|TransformTemplateArgument
argument_list|(
specifier|const
name|TemplateArgumentLoc
operator|&
name|Input
argument_list|,
name|TemplateArgumentLoc
operator|&
name|Output
argument_list|)
block|;
comment|/// \brief Transform the given set of template arguments.
comment|///
comment|/// By default, this operation transforms all of the template arguments
comment|/// in the input set using \c TransformTemplateArgument(), and appends
comment|/// the transformed arguments to the output list.
comment|///
comment|/// Note that this overload of \c TransformTemplateArguments() is merely
comment|/// a convenience function. Subclasses that wish to override this behavior
comment|/// should override the iterator-based member template version.
comment|///
comment|/// \param Inputs The set of template arguments to be transformed.
comment|///
comment|/// \param NumInputs The number of template arguments in \p Inputs.
comment|///
comment|/// \param Outputs The set of transformed template arguments output by this
comment|/// routine.
comment|///
comment|/// Returns true if an error occurred.
name|bool
name|TransformTemplateArguments
argument_list|(
argument|const TemplateArgumentLoc *Inputs
argument_list|,
argument|unsigned NumInputs
argument_list|,
argument|TemplateArgumentListInfo&Outputs
argument_list|)
block|{
return|return
name|TransformTemplateArguments
argument_list|(
name|Inputs
argument_list|,
name|Inputs
operator|+
name|NumInputs
argument_list|,
name|Outputs
argument_list|)
return|;
block|}
comment|/// \brief Transform the given set of template arguments.
comment|///
comment|/// By default, this operation transforms all of the template arguments
comment|/// in the input set using \c TransformTemplateArgument(), and appends
comment|/// the transformed arguments to the output list.
comment|///
comment|/// \param First An iterator to the first template argument.
comment|///
comment|/// \param Last An iterator one step past the last template argument.
comment|///
comment|/// \param Outputs The set of transformed template arguments output by this
comment|/// routine.
comment|///
comment|/// Returns true if an error occurred.
name|template
operator|<
name|typename
name|InputIterator
operator|>
name|bool
name|TransformTemplateArguments
argument_list|(
argument|InputIterator First
argument_list|,
argument|InputIterator Last
argument_list|,
argument|TemplateArgumentListInfo&Outputs
argument_list|)
block|;
comment|/// \brief Fakes up a TemplateArgumentLoc for a given TemplateArgument.
name|void
name|InventTemplateArgumentLoc
argument_list|(
specifier|const
name|TemplateArgument
operator|&
name|Arg
argument_list|,
name|TemplateArgumentLoc
operator|&
name|ArgLoc
argument_list|)
block|;
comment|/// \brief Fakes up a TypeSourceInfo for a type.
name|TypeSourceInfo
operator|*
name|InventTypeSourceInfo
argument_list|(
argument|QualType T
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|T
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
return|;
block|}
define|#
directive|define
name|ABSTRACT_TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|#
directive|define
name|TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|QualType Transform##CLASS##Type(TypeLocBuilder&TLB, CLASS##TypeLoc T);
include|#
directive|include
file|"clang/AST/TypeLocNodes.def"
name|QualType
name|TransformFunctionProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionProtoTypeLoc TL
argument_list|,
argument|CXXRecordDecl *ThisContext
argument_list|,
argument|unsigned ThisTypeQuals
argument_list|)
block|;
name|StmtResult
name|TransformSEHHandler
argument_list|(
name|Stmt
operator|*
name|Handler
argument_list|)
block|;
name|QualType
name|TransformTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateSpecializationTypeLoc TL
argument_list|,
argument|TemplateName Template
argument_list|)
block|;
name|QualType
name|TransformDependentTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentTemplateSpecializationTypeLoc TL
argument_list|,
argument|TemplateName Template
argument_list|,
argument|CXXScopeSpec&SS
argument_list|)
block|;
name|QualType
name|TransformDependentTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentTemplateSpecializationTypeLoc TL
argument_list|,
argument|NestedNameSpecifierLoc QualifierLoc
argument_list|)
block|;
comment|/// \brief Transforms the parameters of a function type into the
comment|/// given vectors.
comment|///
comment|/// The result vectors should be kept in sync; null entries in the
comment|/// variables vector are acceptable.
comment|///
comment|/// Return true on error.
name|bool
name|TransformFunctionTypeParams
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|ParmVarDecl **Params
argument_list|,
argument|unsigned NumParams
argument_list|,
argument|const QualType *ParamTypes
argument_list|,
argument|SmallVectorImpl<QualType>&PTypes
argument_list|,
argument|SmallVectorImpl<ParmVarDecl*> *PVars
argument_list|)
block|;
comment|/// \brief Transforms a single function-type parameter.  Return null
comment|/// on error.
comment|///
comment|/// \param indexAdjustment - A number to add to the parameter's
comment|///   scope index;  can be negative
name|ParmVarDecl
operator|*
name|TransformFunctionTypeParam
argument_list|(
argument|ParmVarDecl *OldParm
argument_list|,
argument|int indexAdjustment
argument_list|,
argument|Optional<unsigned> NumExpansions
argument_list|,
argument|bool ExpectParameterPack
argument_list|)
block|;
name|QualType
name|TransformReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ReferenceTypeLoc TL
argument_list|)
block|;
name|StmtResult
name|TransformCompoundStmt
argument_list|(
argument|CompoundStmt *S
argument_list|,
argument|bool IsStmtExpr
argument_list|)
block|;
name|ExprResult
name|TransformCXXNamedCastExpr
argument_list|(
name|CXXNamedCastExpr
operator|*
name|E
argument_list|)
block|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|ExprResult
operator|,
name|QualType
operator|>
name|InitCaptureInfoTy
expr_stmt|;
comment|/// \brief Transform the captures and body of a lambda expression.
name|ExprResult
name|TransformLambdaScope
argument_list|(
name|LambdaExpr
operator|*
name|E
argument_list|,
name|CXXMethodDecl
operator|*
name|CallOperator
argument_list|,
name|ArrayRef
operator|<
name|InitCaptureInfoTy
operator|>
name|InitCaptureExprsAndTypes
argument_list|)
expr_stmt|;
name|TemplateParameterList
modifier|*
name|TransformTemplateParameterList
parameter_list|(
name|TemplateParameterList
modifier|*
name|TPL
parameter_list|)
block|{
return|return
name|TPL
return|;
block|}
name|ExprResult
name|TransformAddressOfOperand
parameter_list|(
name|Expr
modifier|*
name|E
parameter_list|)
function_decl|;
name|ExprResult
name|TransformDependentScopeDeclRefExpr
parameter_list|(
name|DependentScopeDeclRefExpr
modifier|*
name|E
parameter_list|,
name|bool
name|IsAddressOfOperand
parameter_list|)
function_decl|;
comment|// FIXME: We use LLVM_ATTRIBUTE_NOINLINE because inlining causes a ridiculous
comment|// amount of stack usage with clang.
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|LLVM_ATTRIBUTE_NOINLINE \   StmtResult Transform##Node(Node *S);
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|LLVM_ATTRIBUTE_NOINLINE \   ExprResult Transform##Node(Node *E);
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|Stmt
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
define|#
directive|define
name|OPENMP_CLAUSE
parameter_list|(
name|Name
parameter_list|,
name|Class
parameter_list|)
define|\
value|LLVM_ATTRIBUTE_NOINLINE \   OMPClause *Transform ## Class(Class *S);
include|#
directive|include
file|"clang/Basic/OpenMPKinds.def"
comment|/// \brief Build a new pointer type given its pointee type.
comment|///
comment|/// By default, performs semantic analysis when building the pointer type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new block pointer type given its pointee type.
comment|///
comment|/// By default, performs semantic analysis when building the block pointer
comment|/// type. Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildBlockPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new reference type given the type it references.
comment|///
comment|/// By default, performs semantic analysis when building the
comment|/// reference type. Subclasses may override this routine to provide
comment|/// different behavior.
comment|///
comment|/// \param LValue whether the type was written with an lvalue sigil
comment|/// or an rvalue sigil.
name|QualType
name|RebuildReferenceType
parameter_list|(
name|QualType
name|ReferentType
parameter_list|,
name|bool
name|LValue
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new member pointer type given the pointee type and the
comment|/// class type it refers into.
comment|///
comment|/// By default, performs semantic analysis when building the member pointer
comment|/// type. Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildMemberPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|QualType
name|ClassType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new array type given the element type, size
comment|/// modifier, size of the array (if known), size expression, and index type
comment|/// qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
comment|/// Also by default, all of the other Rebuild*Array
name|QualType
name|RebuildArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
specifier|const
name|llvm
operator|::
name|APInt
operator|*
name|Size
argument_list|,
name|Expr
operator|*
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new constant array type given the element type, size
comment|/// modifier, (known) size of the array, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildConstantArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
specifier|const
name|llvm
operator|::
name|APInt
operator|&
name|Size
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new incomplete array type given the element type, size
comment|/// modifier, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildIncompleteArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new variable-length array type given the element type,
comment|/// size modifier, size expression, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildVariableArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|Expr
operator|*
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new dependent-sized array type given the element type,
comment|/// size modifier, size expression, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDependentSizedArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|Expr
operator|*
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new vector type given the element type and
comment|/// number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildVectorType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|unsigned
name|NumElements
argument_list|,
name|VectorType
operator|::
name|VectorKind
name|VecKind
argument_list|)
decl_stmt|;
comment|/// \brief Build a new extended vector type given the element type and
comment|/// number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildExtVectorType
parameter_list|(
name|QualType
name|ElementType
parameter_list|,
name|unsigned
name|NumElements
parameter_list|,
name|SourceLocation
name|AttributeLoc
parameter_list|)
function_decl|;
comment|/// \brief Build a new potentially dependently-sized extended vector type
comment|/// given the element type and number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDependentSizedExtVectorType
parameter_list|(
name|QualType
name|ElementType
parameter_list|,
name|Expr
modifier|*
name|SizeExpr
parameter_list|,
name|SourceLocation
name|AttributeLoc
parameter_list|)
function_decl|;
comment|/// \brief Build a new function type.
comment|///
comment|/// By default, performs semantic analysis when building the function type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildFunctionProtoType
argument_list|(
name|QualType
name|T
argument_list|,
name|llvm
operator|::
name|MutableArrayRef
operator|<
name|QualType
operator|>
name|ParamTypes
argument_list|,
specifier|const
name|FunctionProtoType
operator|::
name|ExtProtoInfo
operator|&
name|EPI
argument_list|)
decl_stmt|;
comment|/// \brief Build a new unprototyped function type.
name|QualType
name|RebuildFunctionNoProtoType
parameter_list|(
name|QualType
name|ResultType
parameter_list|)
function_decl|;
comment|/// \brief Rebuild an unresolved typename type, given the decl that
comment|/// the UnresolvedUsingTypenameDecl was transformed to.
name|QualType
name|RebuildUnresolvedUsingType
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|/// \brief Build a new typedef type.
name|QualType
name|RebuildTypedefType
parameter_list|(
name|TypedefNameDecl
modifier|*
name|Typedef
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Typedef
argument_list|)
return|;
block|}
comment|/// \brief Build a new class/struct/union type.
name|QualType
name|RebuildRecordType
parameter_list|(
name|RecordDecl
modifier|*
name|Record
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Build a new Enum type.
name|QualType
name|RebuildEnumType
parameter_list|(
name|EnumDecl
modifier|*
name|Enum
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Enum
argument_list|)
return|;
block|}
comment|/// \brief Build a new typeof(expr) type.
comment|///
comment|/// By default, performs semantic analysis when building the typeof type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildTypeOfExprType
parameter_list|(
name|Expr
modifier|*
name|Underlying
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
comment|/// \brief Build a new typeof(type) type.
comment|///
comment|/// By default, builds a new TypeOfType with the given underlying type.
name|QualType
name|RebuildTypeOfType
parameter_list|(
name|QualType
name|Underlying
parameter_list|)
function_decl|;
comment|/// \brief Build a new unary transform type.
name|QualType
name|RebuildUnaryTransformType
argument_list|(
name|QualType
name|BaseType
argument_list|,
name|UnaryTransformType
operator|::
name|UTTKind
name|UKind
argument_list|,
name|SourceLocation
name|Loc
argument_list|)
decl_stmt|;
comment|/// \brief Build a new C++11 decltype type.
comment|///
comment|/// By default, performs semantic analysis when building the decltype type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDecltypeType
parameter_list|(
name|Expr
modifier|*
name|Underlying
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
comment|/// \brief Build a new C++11 auto type.
comment|///
comment|/// By default, builds a new AutoType with the given deduced type.
name|QualType
name|RebuildAutoType
parameter_list|(
name|QualType
name|Deduced
parameter_list|,
name|bool
name|IsDecltypeAuto
parameter_list|)
block|{
comment|// Note, IsDependent is always false here: we implicitly convert an 'auto'
comment|// which has been deduced to a dependent type into an undeduced 'auto', so
comment|// that we'll retry deduction after the transformation.
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getAutoType
argument_list|(
name|Deduced
argument_list|,
name|IsDecltypeAuto
argument_list|,
comment|/*IsDependent*/
name|false
argument_list|)
return|;
block|}
comment|/// \brief Build a new template specialization type.
comment|///
comment|/// By default, performs semantic analysis when building the template
comment|/// specialization type. Subclasses may override this routine to provide
comment|/// different behavior.
name|QualType
name|RebuildTemplateSpecializationType
parameter_list|(
name|TemplateName
name|Template
parameter_list|,
name|SourceLocation
name|TemplateLoc
parameter_list|,
name|TemplateArgumentListInfo
modifier|&
name|Args
parameter_list|)
function_decl|;
comment|/// \brief Build a new parenthesized type.
comment|///
comment|/// By default, builds a new ParenType type from the inner type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildParenType
parameter_list|(
name|QualType
name|InnerType
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getParenType
argument_list|(
name|InnerType
argument_list|)
return|;
block|}
comment|/// \brief Build a new qualified name type.
comment|///
comment|/// By default, builds a new ElaboratedType type from the keyword,
comment|/// the nested-name-specifier and the named type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildElaboratedType
parameter_list|(
name|SourceLocation
name|KeywordLoc
parameter_list|,
name|ElaboratedTypeKeyword
name|Keyword
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|QualType
name|Named
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getElaboratedType
argument_list|(
name|Keyword
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|Named
argument_list|)
return|;
block|}
comment|/// \brief Build a new typename type that refers to a template-id.
comment|///
comment|/// By default, builds a new DependentNameType type from the
comment|/// nested-name-specifier and the given type. Subclasses may override
comment|/// this routine to provide different behavior.
name|QualType
name|RebuildDependentTemplateSpecializationType
parameter_list|(
name|ElaboratedTypeKeyword
name|Keyword
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|TemplateArgumentListInfo
modifier|&
name|Args
parameter_list|)
block|{
comment|// Rebuild the template name.
comment|// TODO: avoid TemplateName abstraction
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
name|TemplateName
name|InstName
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
operator|*
name|Name
argument_list|,
name|NameLoc
argument_list|,
name|QualType
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|InstName
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// If it's still dependent, make a dependent specialization.
if|if
condition|(
name|InstName
operator|.
name|getAsDependentTemplateName
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getDependentTemplateSpecializationType
argument_list|(
name|Keyword
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|Name
argument_list|,
name|Args
argument_list|)
return|;
comment|// Otherwise, make an elaborated type wrapping a non-dependent
comment|// specialization.
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateSpecializationType
argument_list|(
name|InstName
argument_list|,
name|NameLoc
argument_list|,
name|Args
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
if|if
condition|(
name|Keyword
operator|==
name|ETK_None
operator|&&
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
operator|==
literal|0
condition|)
return|return
name|T
return|;
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getElaboratedType
argument_list|(
name|Keyword
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|T
argument_list|)
return|;
block|}
comment|/// \brief Build a new typename type that refers to an identifier.
comment|///
comment|/// By default, performs semantic analysis when building the typename type
comment|/// (or elaborated type). Subclasses may override this routine to provide
comment|/// different behavior.
name|QualType
name|RebuildDependentNameType
parameter_list|(
name|ElaboratedTypeKeyword
name|Keyword
parameter_list|,
name|SourceLocation
name|KeywordLoc
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
operator|->
name|isDependent
argument_list|()
condition|)
block|{
comment|// If the name is still dependent, just build a new dependent name type.
if|if
condition|(
operator|!
name|SemaRef
operator|.
name|computeDeclContext
argument_list|(
name|SS
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getDependentNameType
argument_list|(
name|Keyword
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|Id
argument_list|)
return|;
block|}
if|if
condition|(
name|Keyword
operator|==
name|ETK_None
operator|||
name|Keyword
operator|==
name|ETK_Typename
condition|)
return|return
name|SemaRef
operator|.
name|CheckTypenameType
argument_list|(
name|Keyword
argument_list|,
name|KeywordLoc
argument_list|,
name|QualifierLoc
argument_list|,
operator|*
name|Id
argument_list|,
name|IdLoc
argument_list|)
return|;
name|TagTypeKind
name|Kind
init|=
name|TypeWithKeyword
operator|::
name|getTagTypeKindForKeyword
argument_list|(
name|Keyword
argument_list|)
decl_stmt|;
comment|// We had a dependent elaborated-type-specifier that has been transformed
comment|// into a non-dependent elaborated-type-specifier. Find the tag we're
comment|// referring to.
name|LookupResult
name|Result
argument_list|(
name|SemaRef
argument_list|,
name|Id
argument_list|,
name|IdLoc
argument_list|,
name|Sema
operator|::
name|LookupTagName
argument_list|)
decl_stmt|;
name|DeclContext
modifier|*
name|DC
init|=
name|SemaRef
operator|.
name|computeDeclContext
argument_list|(
name|SS
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DC
condition|)
return|return
name|QualType
argument_list|()
return|;
if|if
condition|(
name|SemaRef
operator|.
name|RequireCompleteDeclContext
argument_list|(
name|SS
argument_list|,
name|DC
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
name|TagDecl
modifier|*
name|Tag
init|=
literal|0
decl_stmt|;
name|SemaRef
operator|.
name|LookupQualifiedName
argument_list|(
name|Result
argument_list|,
name|DC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Result
operator|.
name|getResultKind
argument_list|()
condition|)
block|{
case|case
name|LookupResult
operator|::
name|NotFound
case|:
case|case
name|LookupResult
operator|::
name|NotFoundInCurrentInstantiation
case|:
break|break;
case|case
name|LookupResult
operator|::
name|Found
case|:
name|Tag
operator|=
name|Result
operator|.
name|getAsSingle
operator|<
name|TagDecl
operator|>
operator|(
operator|)
expr_stmt|;
break|break;
case|case
name|LookupResult
operator|::
name|FoundOverloaded
case|:
case|case
name|LookupResult
operator|::
name|FoundUnresolvedValue
case|:
name|llvm_unreachable
argument_list|(
literal|"Tag lookup cannot find non-tags"
argument_list|)
expr_stmt|;
case|case
name|LookupResult
operator|::
name|Ambiguous
case|:
comment|// Let the LookupResult structure handle ambiguities.
return|return
name|QualType
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|Tag
condition|)
block|{
comment|// Check where the name exists but isn't a tag type and use that to emit
comment|// better diagnostics.
name|LookupResult
name|Result
argument_list|(
name|SemaRef
argument_list|,
name|Id
argument_list|,
name|IdLoc
argument_list|,
name|Sema
operator|::
name|LookupTagName
argument_list|)
decl_stmt|;
name|SemaRef
operator|.
name|LookupQualifiedName
argument_list|(
name|Result
argument_list|,
name|DC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Result
operator|.
name|getResultKind
argument_list|()
condition|)
block|{
case|case
name|LookupResult
operator|::
name|Found
case|:
case|case
name|LookupResult
operator|::
name|FoundOverloaded
case|:
case|case
name|LookupResult
operator|::
name|FoundUnresolvedValue
case|:
block|{
name|NamedDecl
modifier|*
name|SomeDecl
init|=
name|Result
operator|.
name|getRepresentativeDecl
argument_list|()
decl_stmt|;
name|unsigned
name|Kind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isa
operator|<
name|TypedefDecl
operator|>
operator|(
name|SomeDecl
operator|)
condition|)
name|Kind
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isa
operator|<
name|TypeAliasDecl
operator|>
operator|(
name|SomeDecl
operator|)
condition|)
name|Kind
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|isa
operator|<
name|ClassTemplateDecl
operator|>
operator|(
name|SomeDecl
operator|)
condition|)
name|Kind
operator|=
literal|3
expr_stmt|;
name|SemaRef
operator|.
name|Diag
argument_list|(
name|IdLoc
argument_list|,
name|diag
operator|::
name|err_tag_reference_non_tag
argument_list|)
operator|<<
name|Kind
expr_stmt|;
name|SemaRef
operator|.
name|Diag
argument_list|(
name|SomeDecl
operator|->
name|getLocation
argument_list|()
argument_list|,
name|diag
operator|::
name|note_declared_at
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|// FIXME: Would be nice to highlight just the source range.
name|SemaRef
operator|.
name|Diag
argument_list|(
name|IdLoc
argument_list|,
name|diag
operator|::
name|err_not_tag_in_scope
argument_list|)
operator|<<
name|Kind
operator|<<
name|Id
operator|<<
name|DC
expr_stmt|;
break|break;
block|}
return|return
name|QualType
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|SemaRef
operator|.
name|isAcceptableTagRedeclaration
argument_list|(
name|Tag
argument_list|,
name|Kind
argument_list|,
comment|/*isDefinition*/
name|false
argument_list|,
name|IdLoc
argument_list|,
operator|*
name|Id
argument_list|)
condition|)
block|{
name|SemaRef
operator|.
name|Diag
argument_list|(
name|KeywordLoc
argument_list|,
name|diag
operator|::
name|err_use_with_wrong_tag
argument_list|)
operator|<<
name|Id
expr_stmt|;
name|SemaRef
operator|.
name|Diag
argument_list|(
name|Tag
operator|->
name|getLocation
argument_list|()
argument_list|,
name|diag
operator|::
name|note_previous_use
argument_list|)
expr_stmt|;
return|return
name|QualType
argument_list|()
return|;
block|}
comment|// Build the elaborated-type-specifier type.
name|QualType
name|T
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Tag
argument_list|)
decl_stmt|;
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getElaboratedType
argument_list|(
name|Keyword
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|T
argument_list|)
return|;
block|}
comment|/// \brief Build a new pack expansion type.
comment|///
comment|/// By default, builds a new PackExpansionType type from the given pattern.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildPackExpansionType
argument_list|(
name|QualType
name|Pattern
argument_list|,
name|SourceRange
name|PatternRange
argument_list|,
name|SourceLocation
name|EllipsisLoc
argument_list|,
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|CheckPackExpansion
argument_list|(
name|Pattern
argument_list|,
name|PatternRange
argument_list|,
name|EllipsisLoc
argument_list|,
name|NumExpansions
argument_list|)
return|;
block|}
comment|/// \brief Build a new atomic type given its value type.
comment|///
comment|/// By default, performs semantic analysis when building the atomic type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildAtomicType
parameter_list|(
name|QualType
name|ValueType
parameter_list|,
name|SourceLocation
name|KWLoc
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier, a flag
comment|/// indicating whether the "template" keyword was provided, and the template
comment|/// that the template name refers to.
comment|///
comment|/// By default, builds the new template name directly. Subclasses may override
comment|/// this routine to provide different behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|TemplateKW
parameter_list|,
name|TemplateDecl
modifier|*
name|Template
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier and the
comment|/// name that is referred to as a template.
comment|///
comment|/// By default, performs semantic analysis to determine whether the name can
comment|/// be resolved to a specific template, then builds the appropriate kind of
comment|/// template name. Subclasses may override this routine to provide different
comment|/// behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|&
name|Name
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|QualType
name|ObjectType
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier and the
comment|/// overloaded operator name that is referred to as a template.
comment|///
comment|/// By default, performs semantic analysis to determine whether the name can
comment|/// be resolved to a specific template, then builds the appropriate kind of
comment|/// template name. Subclasses may override this routine to provide different
comment|/// behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|OverloadedOperatorKind
name|Operator
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|QualType
name|ObjectType
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a template template parameter pack
comment|/// and the
comment|///
comment|/// By default, performs semantic analysis to determine whether the name can
comment|/// be resolved to a specific template, then builds the appropriate kind of
comment|/// template name. Subclasses may override this routine to provide different
comment|/// behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|TemplateTemplateParmDecl
modifier|*
name|Param
parameter_list|,
specifier|const
name|TemplateArgument
modifier|&
name|ArgPack
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|getSubstTemplateTemplateParmPack
argument_list|(
name|Param
argument_list|,
name|ArgPack
argument_list|)
return|;
block|}
comment|/// \brief Build a new compound statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCompoundStmt
parameter_list|(
name|SourceLocation
name|LBraceLoc
parameter_list|,
name|MultiStmtArg
name|Statements
parameter_list|,
name|SourceLocation
name|RBraceLoc
parameter_list|,
name|bool
name|IsStmtExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCompoundStmt
argument_list|(
name|LBraceLoc
argument_list|,
name|RBraceLoc
argument_list|,
name|Statements
argument_list|,
name|IsStmtExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new case statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCaseStmt
parameter_list|(
name|SourceLocation
name|CaseLoc
parameter_list|,
name|Expr
modifier|*
name|LHS
parameter_list|,
name|SourceLocation
name|EllipsisLoc
parameter_list|,
name|Expr
modifier|*
name|RHS
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCaseStmt
argument_list|(
name|CaseLoc
argument_list|,
name|LHS
argument_list|,
name|EllipsisLoc
argument_list|,
name|RHS
argument_list|,
name|ColonLoc
argument_list|)
return|;
block|}
comment|/// \brief Attach the body to a new case statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCaseStmtBody
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnCaseStmtBody
argument_list|(
name|S
argument_list|,
name|Body
argument_list|)
expr_stmt|;
return|return
name|S
return|;
block|}
comment|/// \brief Build a new default statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildDefaultStmt
parameter_list|(
name|SourceLocation
name|DefaultLoc
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|Stmt
modifier|*
name|SubStmt
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDefaultStmt
argument_list|(
name|DefaultLoc
argument_list|,
name|ColonLoc
argument_list|,
name|SubStmt
argument_list|,
comment|/*CurScope=*/
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new label statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildLabelStmt
parameter_list|(
name|SourceLocation
name|IdentLoc
parameter_list|,
name|LabelDecl
modifier|*
name|L
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|Stmt
modifier|*
name|SubStmt
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|ActOnLabelStmt
argument_list|(
name|IdentLoc
argument_list|,
name|L
argument_list|,
name|ColonLoc
argument_list|,
name|SubStmt
argument_list|)
return|;
block|}
comment|/// \brief Build a new label statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildAttributedStmt
argument_list|(
name|SourceLocation
name|AttrLoc
argument_list|,
name|ArrayRef
operator|<
specifier|const
name|Attr
operator|*
operator|>
name|Attrs
argument_list|,
name|Stmt
operator|*
name|SubStmt
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|ActOnAttributedStmt
argument_list|(
name|AttrLoc
argument_list|,
name|Attrs
argument_list|,
name|SubStmt
argument_list|)
return|;
block|}
comment|/// \brief Build a new "if" statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildIfStmt
argument_list|(
name|SourceLocation
name|IfLoc
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|Stmt
operator|*
name|Then
argument_list|,
name|SourceLocation
name|ElseLoc
argument_list|,
name|Stmt
operator|*
name|Else
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnIfStmt
argument_list|(
name|IfLoc
argument_list|,
name|Cond
argument_list|,
name|CondVar
argument_list|,
name|Then
argument_list|,
name|ElseLoc
argument_list|,
name|Else
argument_list|)
return|;
block|}
comment|/// \brief Start building a new switch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildSwitchStmtStart
parameter_list|(
name|SourceLocation
name|SwitchLoc
parameter_list|,
name|Expr
modifier|*
name|Cond
parameter_list|,
name|VarDecl
modifier|*
name|CondVar
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnStartOfSwitchStmt
argument_list|(
name|SwitchLoc
argument_list|,
name|Cond
argument_list|,
name|CondVar
argument_list|)
return|;
block|}
comment|/// \brief Attach the body to the switch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildSwitchStmtBody
parameter_list|(
name|SourceLocation
name|SwitchLoc
parameter_list|,
name|Stmt
modifier|*
name|Switch
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnFinishSwitchStmt
argument_list|(
name|SwitchLoc
argument_list|,
name|Switch
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new while statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildWhileStmt
argument_list|(
name|SourceLocation
name|WhileLoc
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|Stmt
operator|*
name|Body
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnWhileStmt
argument_list|(
name|WhileLoc
argument_list|,
name|Cond
argument_list|,
name|CondVar
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new do-while statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildDoStmt
parameter_list|(
name|SourceLocation
name|DoLoc
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|,
name|SourceLocation
name|WhileLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|Cond
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDoStmt
argument_list|(
name|DoLoc
argument_list|,
name|Body
argument_list|,
name|WhileLoc
argument_list|,
name|LParenLoc
argument_list|,
name|Cond
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new for statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildForStmt
argument_list|(
name|SourceLocation
name|ForLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|Stmt
operator|*
name|Init
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Inc
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|,
name|Stmt
operator|*
name|Body
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnForStmt
argument_list|(
name|ForLoc
argument_list|,
name|LParenLoc
argument_list|,
name|Init
argument_list|,
name|Cond
argument_list|,
name|CondVar
argument_list|,
name|Inc
argument_list|,
name|RParenLoc
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new goto statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildGotoStmt
parameter_list|(
name|SourceLocation
name|GotoLoc
parameter_list|,
name|SourceLocation
name|LabelLoc
parameter_list|,
name|LabelDecl
modifier|*
name|Label
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnGotoStmt
argument_list|(
name|GotoLoc
argument_list|,
name|LabelLoc
argument_list|,
name|Label
argument_list|)
return|;
block|}
comment|/// \brief Build a new indirect goto statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildIndirectGotoStmt
parameter_list|(
name|SourceLocation
name|GotoLoc
parameter_list|,
name|SourceLocation
name|StarLoc
parameter_list|,
name|Expr
modifier|*
name|Target
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnIndirectGotoStmt
argument_list|(
name|GotoLoc
argument_list|,
name|StarLoc
argument_list|,
name|Target
argument_list|)
return|;
block|}
comment|/// \brief Build a new return statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildReturnStmt
parameter_list|(
name|SourceLocation
name|ReturnLoc
parameter_list|,
name|Expr
modifier|*
name|Result
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnReturnStmt
argument_list|(
name|ReturnLoc
argument_list|,
name|Result
argument_list|)
return|;
block|}
comment|/// \brief Build a new declaration statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildDeclStmt
argument_list|(
name|llvm
operator|::
name|MutableArrayRef
operator|<
name|Decl
operator|*
operator|>
name|Decls
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
name|Sema
operator|::
name|DeclGroupPtrTy
name|DG
operator|=
name|getSema
argument_list|()
operator|.
name|BuildDeclaratorGroup
argument_list|(
name|Decls
argument_list|)
expr_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDeclStmt
argument_list|(
name|DG
argument_list|,
name|StartLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new inline asm statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildGCCAsmStmt
parameter_list|(
name|SourceLocation
name|AsmLoc
parameter_list|,
name|bool
name|IsSimple
parameter_list|,
name|bool
name|IsVolatile
parameter_list|,
name|unsigned
name|NumOutputs
parameter_list|,
name|unsigned
name|NumInputs
parameter_list|,
name|IdentifierInfo
modifier|*
modifier|*
name|Names
parameter_list|,
name|MultiExprArg
name|Constraints
parameter_list|,
name|MultiExprArg
name|Exprs
parameter_list|,
name|Expr
modifier|*
name|AsmString
parameter_list|,
name|MultiExprArg
name|Clobbers
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnGCCAsmStmt
argument_list|(
name|AsmLoc
argument_list|,
name|IsSimple
argument_list|,
name|IsVolatile
argument_list|,
name|NumOutputs
argument_list|,
name|NumInputs
argument_list|,
name|Names
argument_list|,
name|Constraints
argument_list|,
name|Exprs
argument_list|,
name|AsmString
argument_list|,
name|Clobbers
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new MS style inline asm statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildMSAsmStmt
argument_list|(
name|SourceLocation
name|AsmLoc
argument_list|,
name|SourceLocation
name|LBraceLoc
argument_list|,
name|ArrayRef
operator|<
name|Token
operator|>
name|AsmToks
argument_list|,
name|StringRef
name|AsmString
argument_list|,
name|unsigned
name|NumOutputs
argument_list|,
name|unsigned
name|NumInputs
argument_list|,
name|ArrayRef
operator|<
name|StringRef
operator|>
name|Constraints
argument_list|,
name|ArrayRef
operator|<
name|StringRef
operator|>
name|Clobbers
argument_list|,
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|Exprs
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnMSAsmStmt
argument_list|(
name|AsmLoc
argument_list|,
name|LBraceLoc
argument_list|,
name|AsmToks
argument_list|,
name|AsmString
argument_list|,
name|NumOutputs
argument_list|,
name|NumInputs
argument_list|,
name|Constraints
argument_list|,
name|Clobbers
argument_list|,
name|Exprs
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@try statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAtTryStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|Stmt
modifier|*
name|TryBody
parameter_list|,
name|MultiStmtArg
name|CatchStmts
parameter_list|,
name|Stmt
modifier|*
name|Finally
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAtTryStmt
argument_list|(
name|AtLoc
argument_list|,
name|TryBody
argument_list|,
name|CatchStmts
argument_list|,
name|Finally
argument_list|)
return|;
block|}
comment|/// \brief Rebuild an Objective-C exception declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new declaration.
comment|/// Subclasses may override this routine to provide different behavior.
name|VarDecl
modifier|*
name|RebuildObjCExceptionDecl
parameter_list|(
name|VarDecl
modifier|*
name|ExceptionDecl
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|QualType
name|T
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCExceptionDecl
argument_list|(
name|TInfo
argument_list|,
name|T
argument_list|,
name|ExceptionDecl
operator|->
name|getInnerLocStart
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getLocation
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getIdentifier
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@catch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAtCatchStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|VarDecl
modifier|*
name|Var
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAtCatchStmt
argument_list|(
name|AtLoc
argument_list|,
name|RParenLoc
argument_list|,
name|Var
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@finally statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAtFinallyStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAtFinallyStmt
argument_list|(
name|AtLoc
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@throw statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAtThrowStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|Expr
modifier|*
name|Operand
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCAtThrowStmt
argument_list|(
name|AtLoc
argument_list|,
name|Operand
argument_list|)
return|;
block|}
comment|/// \brief Build a new OpenMP parallel directive.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildOMPParallelDirective
argument_list|(
name|ArrayRef
operator|<
name|OMPClause
operator|*
operator|>
name|Clauses
argument_list|,
name|Stmt
operator|*
name|AStmt
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnOpenMPParallelDirective
argument_list|(
name|Clauses
argument_list|,
name|AStmt
argument_list|,
name|StartLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new OpenMP 'default' clause.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OMPClause
modifier|*
name|RebuildOMPDefaultClause
parameter_list|(
name|OpenMPDefaultClauseKind
name|Kind
parameter_list|,
name|SourceLocation
name|KindKwLoc
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnOpenMPDefaultClause
argument_list|(
name|Kind
argument_list|,
name|KindKwLoc
argument_list|,
name|StartLoc
argument_list|,
name|LParenLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new OpenMP 'private' clause.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OMPClause
modifier|*
name|RebuildOMPPrivateClause
argument_list|(
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|VarList
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnOpenMPPrivateClause
argument_list|(
name|VarList
argument_list|,
name|StartLoc
argument_list|,
name|LParenLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new OpenMP 'firstprivate' clause.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OMPClause
modifier|*
name|RebuildOMPFirstprivateClause
argument_list|(
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|VarList
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnOpenMPFirstprivateClause
argument_list|(
name|VarList
argument_list|,
name|StartLoc
argument_list|,
name|LParenLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
name|OMPClause
modifier|*
name|RebuildOMPSharedClause
argument_list|(
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|VarList
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|SourceLocation
name|EndLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnOpenMPSharedClause
argument_list|(
name|VarList
argument_list|,
name|StartLoc
argument_list|,
name|LParenLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
comment|/// \brief Rebuild the operand to an Objective-C \@synchronized statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCAtSynchronizedOperand
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|,
name|Expr
modifier|*
name|object
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAtSynchronizedOperand
argument_list|(
name|atLoc
argument_list|,
name|object
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@synchronized statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAtSynchronizedStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|Expr
modifier|*
name|Object
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAtSynchronizedStmt
argument_list|(
name|AtLoc
argument_list|,
name|Object
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@autoreleasepool statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCAutoreleasePoolStmt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCAutoreleasePoolStmt
argument_list|(
name|AtLoc
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C fast enumeration statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildObjCForCollectionStmt
parameter_list|(
name|SourceLocation
name|ForLoc
parameter_list|,
name|Stmt
modifier|*
name|Element
parameter_list|,
name|Expr
modifier|*
name|Collection
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
name|StmtResult
name|ForEachStmt
init|=
name|getSema
argument_list|()
operator|.
name|ActOnObjCForCollectionStmt
argument_list|(
name|ForLoc
argument_list|,
name|Element
argument_list|,
name|Collection
argument_list|,
name|RParenLoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ForEachStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
return|return
name|getSema
argument_list|()
operator|.
name|FinishObjCForCollectionStmt
argument_list|(
name|ForEachStmt
operator|.
name|take
argument_list|()
argument_list|,
name|Body
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ exception declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new decaration.
comment|/// Subclasses may override this routine to provide different behavior.
name|VarDecl
modifier|*
name|RebuildExceptionDecl
parameter_list|(
name|VarDecl
modifier|*
name|ExceptionDecl
parameter_list|,
name|TypeSourceInfo
modifier|*
name|Declarator
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Id
parameter_list|)
block|{
name|VarDecl
modifier|*
name|Var
init|=
name|getSema
argument_list|()
operator|.
name|BuildExceptionDeclaration
argument_list|(
literal|0
argument_list|,
name|Declarator
argument_list|,
name|StartLoc
argument_list|,
name|IdLoc
argument_list|,
name|Id
argument_list|)
decl_stmt|;
if|if
condition|(
name|Var
condition|)
name|getSema
argument_list|()
operator|.
name|CurContext
operator|->
name|addDecl
argument_list|(
name|Var
argument_list|)
expr_stmt|;
return|return
name|Var
return|;
block|}
comment|/// \brief Build a new C++ catch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCXXCatchStmt
parameter_list|(
name|SourceLocation
name|CatchLoc
parameter_list|,
name|VarDecl
modifier|*
name|ExceptionDecl
parameter_list|,
name|Stmt
modifier|*
name|Handler
parameter_list|)
block|{
return|return
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|CXXCatchStmt
argument_list|(
name|CatchLoc
argument_list|,
name|ExceptionDecl
argument_list|,
name|Handler
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ try statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCXXTryStmt
argument_list|(
name|SourceLocation
name|TryLoc
argument_list|,
name|Stmt
operator|*
name|TryBlock
argument_list|,
name|ArrayRef
operator|<
name|Stmt
operator|*
operator|>
name|Handlers
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTryBlock
argument_list|(
name|TryLoc
argument_list|,
name|TryBlock
argument_list|,
name|Handlers
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++0x range-based for statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildCXXForRangeStmt
parameter_list|(
name|SourceLocation
name|ForLoc
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|Stmt
modifier|*
name|Range
parameter_list|,
name|Stmt
modifier|*
name|BeginEnd
parameter_list|,
name|Expr
modifier|*
name|Cond
parameter_list|,
name|Expr
modifier|*
name|Inc
parameter_list|,
name|Stmt
modifier|*
name|LoopVar
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
comment|// If we've just learned that the range is actually an Objective-C
comment|// collection, treat this as an Objective-C fast enumeration loop.
if|if
condition|(
name|DeclStmt
modifier|*
name|RangeStmt
init|=
name|dyn_cast
operator|<
name|DeclStmt
operator|>
operator|(
name|Range
operator|)
condition|)
block|{
if|if
condition|(
name|RangeStmt
operator|->
name|isSingleDecl
argument_list|()
condition|)
block|{
if|if
condition|(
name|VarDecl
modifier|*
name|RangeVar
init|=
name|dyn_cast
operator|<
name|VarDecl
operator|>
operator|(
name|RangeStmt
operator|->
name|getSingleDecl
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|RangeVar
operator|->
name|isInvalidDecl
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Expr
modifier|*
name|RangeExpr
init|=
name|RangeVar
operator|->
name|getInit
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RangeExpr
operator|->
name|isTypeDependent
argument_list|()
operator|&&
name|RangeExpr
operator|->
name|getType
argument_list|()
operator|->
name|isObjCObjectPointerType
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|ActOnObjCForCollectionStmt
argument_list|(
name|ForLoc
argument_list|,
name|LoopVar
argument_list|,
name|RangeExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXForRangeStmt
argument_list|(
name|ForLoc
argument_list|,
name|ColonLoc
argument_list|,
name|Range
argument_list|,
name|BeginEnd
argument_list|,
name|Cond
argument_list|,
name|Inc
argument_list|,
name|LoopVar
argument_list|,
name|RParenLoc
argument_list|,
name|Sema
operator|::
name|BFRK_Rebuild
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++0x range-based for statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|RebuildMSDependentExistsStmt
parameter_list|(
name|SourceLocation
name|KeywordLoc
parameter_list|,
name|bool
name|IsIfExists
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|DeclarationNameInfo
name|NameInfo
parameter_list|,
name|Stmt
modifier|*
name|Nested
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildMSDependentExistsStmt
argument_list|(
name|KeywordLoc
argument_list|,
name|IsIfExists
argument_list|,
name|QualifierLoc
argument_list|,
name|NameInfo
argument_list|,
name|Nested
argument_list|)
return|;
block|}
comment|/// \brief Attach body to a C++0x range-based for statement.
comment|///
comment|/// By default, performs semantic analysis to finish the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|StmtResult
name|FinishCXXForRangeStmt
parameter_list|(
name|Stmt
modifier|*
name|ForRange
parameter_list|,
name|Stmt
modifier|*
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|FinishCXXForRangeStmt
argument_list|(
name|ForRange
argument_list|,
name|Body
argument_list|)
return|;
block|}
name|StmtResult
name|RebuildSEHTryStmt
parameter_list|(
name|bool
name|IsCXXTry
parameter_list|,
name|SourceLocation
name|TryLoc
parameter_list|,
name|Stmt
modifier|*
name|TryBlock
parameter_list|,
name|Stmt
modifier|*
name|Handler
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnSEHTryBlock
argument_list|(
name|IsCXXTry
argument_list|,
name|TryLoc
argument_list|,
name|TryBlock
argument_list|,
name|Handler
argument_list|)
return|;
block|}
name|StmtResult
name|RebuildSEHExceptStmt
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|Expr
modifier|*
name|FilterExpr
parameter_list|,
name|Stmt
modifier|*
name|Block
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnSEHExceptBlock
argument_list|(
name|Loc
argument_list|,
name|FilterExpr
argument_list|,
name|Block
argument_list|)
return|;
block|}
name|StmtResult
name|RebuildSEHFinallyStmt
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|Stmt
modifier|*
name|Block
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnSEHFinallyBlock
argument_list|(
name|Loc
argument_list|,
name|Block
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression that references a declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildDeclarationNameExpr
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
name|bool
name|RequiresADL
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|RequiresADL
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression that references a declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildDeclRefExpr
parameter_list|(
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|ValueDecl
modifier|*
name|VD
parameter_list|,
specifier|const
name|DeclarationNameInfo
modifier|&
name|NameInfo
parameter_list|,
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
comment|// FIXME: loses template args.
return|return
name|getSema
argument_list|()
operator|.
name|BuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|NameInfo
argument_list|,
name|VD
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression in parentheses.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildParenExpr
parameter_list|(
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|LParen
parameter_list|,
name|SourceLocation
name|RParen
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnParenExpr
argument_list|(
name|LParen
argument_list|,
name|RParen
argument_list|,
name|SubExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new pseudo-destructor expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXPseudoDestructorExpr
parameter_list|(
name|Expr
modifier|*
name|Base
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|bool
name|isArrow
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|TypeSourceInfo
modifier|*
name|ScopeType
parameter_list|,
name|SourceLocation
name|CCLoc
parameter_list|,
name|SourceLocation
name|TildeLoc
parameter_list|,
name|PseudoDestructorTypeStorage
name|Destroyed
parameter_list|)
function_decl|;
comment|/// \brief Build a new unary operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildUnaryOperator
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|UnaryOperatorKind
name|Opc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildUnaryOp
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|SubExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new builtin offsetof expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildOffsetOfExpr
argument_list|(
name|SourceLocation
name|OperatorLoc
argument_list|,
name|TypeSourceInfo
operator|*
name|Type
argument_list|,
name|Sema
operator|::
name|OffsetOfComponent
operator|*
name|Components
argument_list|,
name|unsigned
name|NumComponents
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildBuiltinOffsetOf
argument_list|(
name|OperatorLoc
argument_list|,
name|Type
argument_list|,
name|Components
argument_list|,
name|NumComponents
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new sizeof, alignof or vec_step expression with a
comment|/// type argument.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildUnaryExprOrTypeTrait
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|UnaryExprOrTypeTrait
name|ExprKind
parameter_list|,
name|SourceRange
name|R
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|CreateUnaryExprOrTypeTraitExpr
argument_list|(
name|TInfo
argument_list|,
name|OpLoc
argument_list|,
name|ExprKind
argument_list|,
name|R
argument_list|)
return|;
block|}
comment|/// \brief Build a new sizeof, alignof or vec step expression with an
comment|/// expression argument.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildUnaryExprOrTypeTrait
parameter_list|(
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|UnaryExprOrTypeTrait
name|ExprKind
parameter_list|,
name|SourceRange
name|R
parameter_list|)
block|{
name|ExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|CreateUnaryExprOrTypeTraitExpr
argument_list|(
name|SubExpr
argument_list|,
name|OpLoc
argument_list|,
name|ExprKind
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
return|return
name|Result
return|;
block|}
comment|/// \brief Build a new array subscript expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildArraySubscriptExpr
parameter_list|(
name|Expr
modifier|*
name|LHS
parameter_list|,
name|SourceLocation
name|LBracketLoc
parameter_list|,
name|Expr
modifier|*
name|RHS
parameter_list|,
name|SourceLocation
name|RBracketLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnArraySubscriptExpr
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|LHS
argument_list|,
name|LBracketLoc
argument_list|,
name|RHS
argument_list|,
name|RBracketLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new call expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCallExpr
parameter_list|(
name|Expr
modifier|*
name|Callee
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|Expr
modifier|*
name|ExecConfig
init|=
literal|0
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCallExpr
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|Callee
argument_list|,
name|LParenLoc
argument_list|,
name|Args
argument_list|,
name|RParenLoc
argument_list|,
name|ExecConfig
argument_list|)
return|;
block|}
comment|/// \brief Build a new member access expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildMemberExpr
parameter_list|(
name|Expr
modifier|*
name|Base
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|bool
name|isArrow
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
specifier|const
name|DeclarationNameInfo
modifier|&
name|MemberNameInfo
parameter_list|,
name|ValueDecl
modifier|*
name|Member
parameter_list|,
name|NamedDecl
modifier|*
name|FoundDecl
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|ExplicitTemplateArgs
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|)
block|{
name|ExprResult
name|BaseResult
init|=
name|getSema
argument_list|()
operator|.
name|PerformMemberExprBaseConversion
argument_list|(
name|Base
argument_list|,
name|isArrow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Member
operator|->
name|getDeclName
argument_list|()
condition|)
block|{
comment|// We have a reference to an unnamed field.  This is always the
comment|// base of an anonymous struct/union member access, i.e. the
comment|// field is always of record type.
name|assert
argument_list|(
operator|!
name|QualifierLoc
operator|&&
literal|"Can't have an unnamed field with a qualifier!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Member
operator|->
name|getType
argument_list|()
operator|->
name|isRecordType
argument_list|()
operator|&&
literal|"unnamed member not of record type?"
argument_list|)
expr_stmt|;
name|BaseResult
operator|=
name|getSema
argument_list|()
operator|.
name|PerformObjectMemberConversion
argument_list|(
name|BaseResult
operator|.
name|take
argument_list|()
argument_list|,
name|QualifierLoc
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|FoundDecl
argument_list|,
name|Member
argument_list|)
expr_stmt|;
if|if
condition|(
name|BaseResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Base
operator|=
name|BaseResult
operator|.
name|take
argument_list|()
expr_stmt|;
name|ExprValueKind
name|VK
init|=
name|isArrow
condition|?
name|VK_LValue
else|:
name|Base
operator|->
name|getValueKind
argument_list|()
decl_stmt|;
name|MemberExpr
modifier|*
name|ME
init|=
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|MemberExpr
argument_list|(
name|Base
argument_list|,
name|isArrow
argument_list|,
name|Member
argument_list|,
name|MemberNameInfo
argument_list|,
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|Member
operator|)
operator|->
name|getType
argument_list|()
argument_list|,
name|VK
argument_list|,
name|OK_Ordinary
argument_list|)
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|ME
argument_list|)
return|;
block|}
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
name|Base
operator|=
name|BaseResult
operator|.
name|take
argument_list|()
expr_stmt|;
name|QualType
name|BaseType
init|=
name|Base
operator|->
name|getType
argument_list|()
decl_stmt|;
comment|// FIXME: this involves duplicating earlier analysis in a lot of
comment|// cases; we should avoid this when possible.
name|LookupResult
name|R
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|MemberNameInfo
argument_list|,
name|Sema
operator|::
name|LookupMemberName
argument_list|)
decl_stmt|;
name|R
operator|.
name|addDecl
argument_list|(
name|FoundDecl
argument_list|)
expr_stmt|;
name|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
argument_list|,
name|BaseType
argument_list|,
name|OpLoc
argument_list|,
name|isArrow
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
name|ExplicitTemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new binary operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildBinaryOperator
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|BinaryOperatorKind
name|Opc
parameter_list|,
name|Expr
modifier|*
name|LHS
parameter_list|,
name|Expr
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildBinOp
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|/// \brief Build a new conditional operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildConditionalOperator
parameter_list|(
name|Expr
modifier|*
name|Cond
parameter_list|,
name|SourceLocation
name|QuestionLoc
parameter_list|,
name|Expr
modifier|*
name|LHS
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|Expr
modifier|*
name|RHS
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnConditionalOp
argument_list|(
name|QuestionLoc
argument_list|,
name|ColonLoc
argument_list|,
name|Cond
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|)
return|;
block|}
comment|/// \brief Build a new C-style cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCStyleCastExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCStyleCastExpr
argument_list|(
name|LParenLoc
argument_list|,
name|TInfo
argument_list|,
name|RParenLoc
argument_list|,
name|SubExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new compound literal expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCompoundLiteralExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|Expr
modifier|*
name|Init
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCompoundLiteralExpr
argument_list|(
name|LParenLoc
argument_list|,
name|TInfo
argument_list|,
name|RParenLoc
argument_list|,
name|Init
argument_list|)
return|;
block|}
comment|/// \brief Build a new extended vector element access expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildExtVectorElementExpr
parameter_list|(
name|Expr
modifier|*
name|Base
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|AccessorLoc
parameter_list|,
name|IdentifierInfo
modifier|&
name|Accessor
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|DeclarationNameInfo
name|NameInfo
argument_list|(
operator|&
name|Accessor
argument_list|,
name|AccessorLoc
argument_list|)
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
argument_list|,
name|Base
operator|->
name|getType
argument_list|()
argument_list|,
name|OpLoc
argument_list|,
comment|/*IsArrow*/
name|false
argument_list|,
name|SS
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
comment|/*FirstQualifierInScope*/
literal|0
argument_list|,
name|NameInfo
argument_list|,
comment|/* TemplateArgs */
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new initializer list expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildInitList
parameter_list|(
name|SourceLocation
name|LBraceLoc
parameter_list|,
name|MultiExprArg
name|Inits
parameter_list|,
name|SourceLocation
name|RBraceLoc
parameter_list|,
name|QualType
name|ResultTy
parameter_list|)
block|{
name|ExprResult
name|Result
init|=
name|SemaRef
operator|.
name|ActOnInitList
argument_list|(
name|LBraceLoc
argument_list|,
name|Inits
argument_list|,
name|RBraceLoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
operator|||
name|ResultTy
operator|->
name|isDependentType
argument_list|()
condition|)
return|return
name|Result
return|;
comment|// Patch in the result type we were given, which may have been computed
comment|// when the initial InitListExpr was built.
name|InitListExpr
modifier|*
name|ILE
init|=
name|cast
operator|<
name|InitListExpr
operator|>
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Result
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
name|ILE
operator|->
name|setType
argument_list|(
name|ResultTy
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|/// \brief Build a new designated initializer expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildDesignatedInitExpr
parameter_list|(
name|Designation
modifier|&
name|Desig
parameter_list|,
name|MultiExprArg
name|ArrayExprs
parameter_list|,
name|SourceLocation
name|EqualOrColonLoc
parameter_list|,
name|bool
name|GNUSyntax
parameter_list|,
name|Expr
modifier|*
name|Init
parameter_list|)
block|{
name|ExprResult
name|Result
init|=
name|SemaRef
operator|.
name|ActOnDesignatedInitializer
argument_list|(
name|Desig
argument_list|,
name|EqualOrColonLoc
argument_list|,
name|GNUSyntax
argument_list|,
name|Init
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
return|return
name|Result
return|;
block|}
comment|/// \brief Build a new value-initialized expression.
comment|///
comment|/// By default, builds the implicit value initialization without performing
comment|/// any semantic analysis. Subclasses may override this routine to provide
comment|/// different behavior.
name|ExprResult
name|RebuildImplicitValueInitExpr
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|ImplicitValueInitExpr
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new \c va_arg expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildVAArgExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildVAArgExpr
argument_list|(
name|BuiltinLoc
argument_list|,
name|SubExpr
argument_list|,
name|TInfo
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression list in parentheses.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildParenListExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|SubExprs
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnParenListExpr
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|,
name|SubExprs
argument_list|)
return|;
block|}
comment|/// \brief Build a new address-of-label expression.
comment|///
comment|/// By default, performs semantic analysis, using the name of the label
comment|/// rather than attempting to map the label statement itself.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildAddrLabelExpr
parameter_list|(
name|SourceLocation
name|AmpAmpLoc
parameter_list|,
name|SourceLocation
name|LabelLoc
parameter_list|,
name|LabelDecl
modifier|*
name|Label
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnAddrLabel
argument_list|(
name|AmpAmpLoc
argument_list|,
name|LabelLoc
argument_list|,
name|Label
argument_list|)
return|;
block|}
comment|/// \brief Build a new GNU statement expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildStmtExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Stmt
modifier|*
name|SubStmt
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnStmtExpr
argument_list|(
name|LParenLoc
argument_list|,
name|SubStmt
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new __builtin_choose_expr expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildChooseExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|Expr
modifier|*
name|Cond
parameter_list|,
name|Expr
modifier|*
name|LHS
parameter_list|,
name|Expr
modifier|*
name|RHS
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|ActOnChooseExpr
argument_list|(
name|BuiltinLoc
argument_list|,
name|Cond
argument_list|,
name|LHS
argument_list|,
name|RHS
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new generic selection expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildGenericSelectionExpr
argument_list|(
name|SourceLocation
name|KeyLoc
argument_list|,
name|SourceLocation
name|DefaultLoc
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|,
name|Expr
operator|*
name|ControllingExpr
argument_list|,
name|ArrayRef
operator|<
name|TypeSourceInfo
operator|*
operator|>
name|Types
argument_list|,
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|Exprs
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|CreateGenericSelectionExpr
argument_list|(
name|KeyLoc
argument_list|,
name|DefaultLoc
argument_list|,
name|RParenLoc
argument_list|,
name|ControllingExpr
argument_list|,
name|Types
argument_list|,
name|Exprs
argument_list|)
return|;
block|}
comment|/// \brief Build a new overloaded operator call expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// The semantic analysis provides the behavior of template instantiation,
comment|/// copying with transformations that turn what looks like an overloaded
comment|/// operator call into a use of a builtin operator, performing
comment|/// argument-dependent lookup, etc. Subclasses may override this routine to
comment|/// provide different behavior.
name|ExprResult
name|RebuildCXXOperatorCallExpr
parameter_list|(
name|OverloadedOperatorKind
name|Op
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|Expr
modifier|*
name|Callee
parameter_list|,
name|Expr
modifier|*
name|First
parameter_list|,
name|Expr
modifier|*
name|Second
parameter_list|)
function_decl|;
comment|/// \brief Build a new C++ "named" cast expression, such as static_cast or
comment|/// reinterpret_cast.
comment|///
comment|/// By default, this routine dispatches to one of the more-specific routines
comment|/// for a particular named case, e.g., RebuildCXXStaticCastExpr().
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXNamedCastExpr
argument_list|(
name|SourceLocation
name|OpLoc
argument_list|,
name|Stmt
operator|::
name|StmtClass
name|Class
argument_list|,
name|SourceLocation
name|LAngleLoc
argument_list|,
name|TypeSourceInfo
operator|*
name|TInfo
argument_list|,
name|SourceLocation
name|RAngleLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|Expr
operator|*
name|SubExpr
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|)
block|{
switch|switch
condition|(
name|Class
condition|)
block|{
case|case
name|Stmt
operator|::
name|CXXStaticCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXStaticCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|SubExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXDynamicCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDynamicCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|SubExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXReinterpretCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXReinterpretCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|SubExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXConstCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXConstCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|SubExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Invalid C++ named cast"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// \brief Build a new C++ static_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXStaticCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_static_cast
argument_list|,
name|TInfo
argument_list|,
name|SubExpr
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ dynamic_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXDynamicCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_dynamic_cast
argument_list|,
name|TInfo
argument_list|,
name|SubExpr
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ reinterpret_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXReinterpretCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_reinterpret_cast
argument_list|,
name|TInfo
argument_list|,
name|SubExpr
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ const_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXConstCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_const_cast
argument_list|,
name|TInfo
argument_list|,
name|SubExpr
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ functional-style cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXFunctionalCastExpr
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Expr
modifier|*
name|Sub
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeConstructExpr
argument_list|(
name|TInfo
argument_list|,
name|LParenLoc
argument_list|,
name|MultiExprArg
argument_list|(
operator|&
name|Sub
argument_list|,
literal|1
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ typeid(type) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXTypeidExpr
parameter_list|(
name|QualType
name|TypeInfoType
parameter_list|,
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|Operand
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeId
argument_list|(
name|TypeInfoType
argument_list|,
name|TypeidLoc
argument_list|,
name|Operand
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ typeid(expr) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXTypeidExpr
parameter_list|(
name|QualType
name|TypeInfoType
parameter_list|,
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|Expr
modifier|*
name|Operand
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeId
argument_list|(
name|TypeInfoType
argument_list|,
name|TypeidLoc
argument_list|,
name|Operand
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ __uuidof(type) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXUuidofExpr
parameter_list|(
name|QualType
name|TypeInfoType
parameter_list|,
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|Operand
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXUuidof
argument_list|(
name|TypeInfoType
argument_list|,
name|TypeidLoc
argument_list|,
name|Operand
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ __uuidof(expr) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXUuidofExpr
parameter_list|(
name|QualType
name|TypeInfoType
parameter_list|,
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|Expr
modifier|*
name|Operand
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXUuidof
argument_list|(
name|TypeInfoType
argument_list|,
name|TypeidLoc
argument_list|,
name|Operand
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "this" expression.
comment|///
comment|/// By default, builds a new "this" expression without performing any
comment|/// semantic analysis. Subclasses may override this routine to provide
comment|/// different behavior.
name|ExprResult
name|RebuildCXXThisExpr
parameter_list|(
name|SourceLocation
name|ThisLoc
parameter_list|,
name|QualType
name|ThisType
parameter_list|,
name|bool
name|isImplicit
parameter_list|)
block|{
name|getSema
argument_list|()
operator|.
name|CheckCXXThisCapture
argument_list|(
name|ThisLoc
argument_list|)
expr_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|CXXThisExpr
argument_list|(
name|ThisLoc
argument_list|,
name|ThisType
argument_list|,
name|isImplicit
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ throw expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXThrowExpr
parameter_list|(
name|SourceLocation
name|ThrowLoc
parameter_list|,
name|Expr
modifier|*
name|Sub
parameter_list|,
name|bool
name|IsThrownVariableInScope
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXThrow
argument_list|(
name|ThrowLoc
argument_list|,
name|Sub
argument_list|,
name|IsThrownVariableInScope
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ default-argument expression.
comment|///
comment|/// By default, builds a new default-argument expression, which does not
comment|/// require any semantic analysis. Subclasses may override this routine to
comment|/// provide different behavior.
name|ExprResult
name|RebuildCXXDefaultArgExpr
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|ParmVarDecl
modifier|*
name|Param
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|CXXDefaultArgExpr
operator|::
name|Create
argument_list|(
name|getSema
argument_list|()
operator|.
name|Context
argument_list|,
name|Loc
argument_list|,
name|Param
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++11 default-initialization expression.
comment|///
comment|/// By default, builds a new default field initialization expression, which
comment|/// does not require any semantic analysis. Subclasses may override this
comment|/// routine to provide different behavior.
name|ExprResult
name|RebuildCXXDefaultInitExpr
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|FieldDecl
modifier|*
name|Field
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|CXXDefaultInitExpr
operator|::
name|Create
argument_list|(
name|getSema
argument_list|()
operator|.
name|Context
argument_list|,
name|Loc
argument_list|,
name|Field
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ zero-initialization expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXScalarValueInitExpr
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TSInfo
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeConstructExpr
argument_list|(
name|TSInfo
argument_list|,
name|LParenLoc
argument_list|,
name|None
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "new" expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXNewExpr
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|PlacementLParen
parameter_list|,
name|MultiExprArg
name|PlacementArgs
parameter_list|,
name|SourceLocation
name|PlacementRParen
parameter_list|,
name|SourceRange
name|TypeIdParens
parameter_list|,
name|QualType
name|AllocatedType
parameter_list|,
name|TypeSourceInfo
modifier|*
name|AllocatedTypeInfo
parameter_list|,
name|Expr
modifier|*
name|ArraySize
parameter_list|,
name|SourceRange
name|DirectInitRange
parameter_list|,
name|Expr
modifier|*
name|Initializer
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNew
argument_list|(
name|StartLoc
argument_list|,
name|UseGlobal
argument_list|,
name|PlacementLParen
argument_list|,
name|PlacementArgs
argument_list|,
name|PlacementRParen
argument_list|,
name|TypeIdParens
argument_list|,
name|AllocatedType
argument_list|,
name|AllocatedTypeInfo
argument_list|,
name|ArraySize
argument_list|,
name|DirectInitRange
argument_list|,
name|Initializer
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "delete" expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXDeleteExpr
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|bool
name|IsGlobalDelete
parameter_list|,
name|bool
name|IsArrayForm
parameter_list|,
name|Expr
modifier|*
name|Operand
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXDelete
argument_list|(
name|StartLoc
argument_list|,
name|IsGlobalDelete
argument_list|,
name|IsArrayForm
argument_list|,
name|Operand
argument_list|)
return|;
block|}
comment|/// \brief Build a new unary type trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildUnaryTypeTrait
parameter_list|(
name|UnaryTypeTrait
name|Trait
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildUnaryTypeTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|T
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new binary type trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildBinaryTypeTrait
parameter_list|(
name|BinaryTypeTrait
name|Trait
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|LhsT
parameter_list|,
name|TypeSourceInfo
modifier|*
name|RhsT
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildBinaryTypeTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|LhsT
argument_list|,
name|RhsT
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new type trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildTypeTrait
argument_list|(
name|TypeTrait
name|Trait
argument_list|,
name|SourceLocation
name|StartLoc
argument_list|,
name|ArrayRef
operator|<
name|TypeSourceInfo
operator|*
operator|>
name|Args
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildTypeTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|Args
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new array type trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildArrayTypeTrait
parameter_list|(
name|ArrayTypeTrait
name|Trait
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TSInfo
parameter_list|,
name|Expr
modifier|*
name|DimExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildArrayTypeTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|TSInfo
argument_list|,
name|DimExpr
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildExpressionTrait
parameter_list|(
name|ExpressionTrait
name|Trait
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|Expr
modifier|*
name|Queried
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildExpressionTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|Queried
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new (previously unresolved) declaration reference
comment|/// expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildDependentScopeDeclRefExpr
parameter_list|(
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
specifier|const
name|DeclarationNameInfo
modifier|&
name|NameInfo
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|,
name|bool
name|IsAddressOfOperand
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TemplateArgs
operator|||
name|TemplateKWLoc
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|BuildQualifiedTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|NameInfo
argument_list|,
name|TemplateArgs
argument_list|)
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildQualifiedDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|NameInfo
argument_list|,
name|IsAddressOfOperand
argument_list|)
return|;
block|}
comment|/// \brief Build a new template-id expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildTemplateIdExpr
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
name|bool
name|RequiresADL
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|R
argument_list|,
name|RequiresADL
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXConstructExpr
argument_list|(
name|QualType
name|T
argument_list|,
name|SourceLocation
name|Loc
argument_list|,
name|CXXConstructorDecl
operator|*
name|Constructor
argument_list|,
name|bool
name|IsElidable
argument_list|,
name|MultiExprArg
name|Args
argument_list|,
name|bool
name|HadMultipleCandidates
argument_list|,
name|bool
name|ListInitialization
argument_list|,
name|bool
name|RequiresZeroInit
argument_list|,
name|CXXConstructExpr
operator|::
name|ConstructionKind
name|ConstructKind
argument_list|,
name|SourceRange
name|ParenRange
argument_list|)
block|{
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|ConvertedArgs
expr_stmt|;
if|if
condition|(
name|getSema
argument_list|()
operator|.
name|CompleteConstructorCall
argument_list|(
name|Constructor
argument_list|,
name|Args
argument_list|,
name|Loc
argument_list|,
name|ConvertedArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXConstructExpr
argument_list|(
name|Loc
argument_list|,
name|T
argument_list|,
name|Constructor
argument_list|,
name|IsElidable
argument_list|,
name|ConvertedArgs
argument_list|,
name|HadMultipleCandidates
argument_list|,
name|ListInitialization
argument_list|,
name|RequiresZeroInit
argument_list|,
name|ConstructKind
argument_list|,
name|ParenRange
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXTemporaryObjectExpr
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TSInfo
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeConstructExpr
argument_list|(
name|TSInfo
argument_list|,
name|LParenLoc
argument_list|,
name|Args
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXUnresolvedConstructExpr
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TSInfo
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXTypeConstructExpr
argument_list|(
name|TSInfo
argument_list|,
name|LParenLoc
argument_list|,
name|Args
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new member reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXDependentScopeMemberExpr
parameter_list|(
name|Expr
modifier|*
name|BaseE
parameter_list|,
name|QualType
name|BaseType
parameter_list|,
name|bool
name|IsArrow
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
specifier|const
name|DeclarationNameInfo
modifier|&
name|MemberNameInfo
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|BaseE
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|MemberNameInfo
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new member reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildUnresolvedMemberExpr
parameter_list|(
name|Expr
modifier|*
name|BaseE
parameter_list|,
name|QualType
name|BaseType
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|bool
name|IsArrow
parameter_list|,
name|NestedNameSpecifierLoc
name|QualifierLoc
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|BaseE
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new noexcept expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildCXXNoexceptExpr
parameter_list|(
name|SourceRange
name|Range
parameter_list|,
name|Expr
modifier|*
name|Arg
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildCXXNoexceptExpr
argument_list|(
name|Range
operator|.
name|getBegin
argument_list|()
argument_list|,
name|Arg
argument_list|,
name|Range
operator|.
name|getEnd
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression to compute the length of a parameter pack.
name|ExprResult
name|RebuildSizeOfPackExpr
argument_list|(
name|SourceLocation
name|OperatorLoc
argument_list|,
name|NamedDecl
operator|*
name|Pack
argument_list|,
name|SourceLocation
name|PackLoc
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|,
name|Optional
operator|<
name|unsigned
operator|>
name|Length
argument_list|)
block|{
if|if
condition|(
name|Length
condition|)
return|return
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|SizeOfPackExpr
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getSizeType
argument_list|()
argument_list|,
name|OperatorLoc
argument_list|,
name|Pack
argument_list|,
name|PackLoc
argument_list|,
name|RParenLoc
argument_list|,
operator|*
name|Length
argument_list|)
return|;
return|return
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|SizeOfPackExpr
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getSizeType
argument_list|()
argument_list|,
name|OperatorLoc
argument_list|,
name|Pack
argument_list|,
name|PackLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C boxed expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCBoxedExpr
parameter_list|(
name|SourceRange
name|SR
parameter_list|,
name|Expr
modifier|*
name|ValueExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCBoxedExpr
argument_list|(
name|SR
argument_list|,
name|ValueExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C array literal.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCArrayLiteral
parameter_list|(
name|SourceRange
name|Range
parameter_list|,
name|Expr
modifier|*
modifier|*
name|Elements
parameter_list|,
name|unsigned
name|NumElements
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCArrayLiteral
argument_list|(
name|Range
argument_list|,
name|MultiExprArg
argument_list|(
name|Elements
argument_list|,
name|NumElements
argument_list|)
argument_list|)
return|;
block|}
name|ExprResult
name|RebuildObjCSubscriptRefExpr
parameter_list|(
name|SourceLocation
name|RB
parameter_list|,
name|Expr
modifier|*
name|Base
parameter_list|,
name|Expr
modifier|*
name|Key
parameter_list|,
name|ObjCMethodDecl
modifier|*
name|getterMethod
parameter_list|,
name|ObjCMethodDecl
modifier|*
name|setterMethod
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCSubscriptExpression
argument_list|(
name|RB
argument_list|,
name|Base
argument_list|,
name|Key
argument_list|,
name|getterMethod
argument_list|,
name|setterMethod
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C dictionary literal.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCDictionaryLiteral
parameter_list|(
name|SourceRange
name|Range
parameter_list|,
name|ObjCDictionaryElement
modifier|*
name|Elements
parameter_list|,
name|unsigned
name|NumElements
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildObjCDictionaryLiteral
argument_list|(
name|Range
argument_list|,
name|Elements
argument_list|,
name|NumElements
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C \@encode expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCEncodeExpr
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|EncodeTypeInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|SemaRef
operator|.
name|BuildObjCEncodeExpression
argument_list|(
name|AtLoc
argument_list|,
name|EncodeTypeInfo
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C class message.
name|ExprResult
name|RebuildObjCMessageExpr
argument_list|(
name|TypeSourceInfo
operator|*
name|ReceiverTypeInfo
argument_list|,
name|Selector
name|Sel
argument_list|,
name|ArrayRef
operator|<
name|SourceLocation
operator|>
name|SelectorLocs
argument_list|,
name|ObjCMethodDecl
operator|*
name|Method
argument_list|,
name|SourceLocation
name|LBracLoc
argument_list|,
name|MultiExprArg
name|Args
argument_list|,
name|SourceLocation
name|RBracLoc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildClassMessage
argument_list|(
name|ReceiverTypeInfo
argument_list|,
name|ReceiverTypeInfo
operator|->
name|getType
argument_list|()
argument_list|,
comment|/*SuperLoc=*/
name|SourceLocation
argument_list|()
argument_list|,
name|Sel
argument_list|,
name|Method
argument_list|,
name|LBracLoc
argument_list|,
name|SelectorLocs
argument_list|,
name|RBracLoc
argument_list|,
name|Args
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C instance message.
name|ExprResult
name|RebuildObjCMessageExpr
argument_list|(
name|Expr
operator|*
name|Receiver
argument_list|,
name|Selector
name|Sel
argument_list|,
name|ArrayRef
operator|<
name|SourceLocation
operator|>
name|SelectorLocs
argument_list|,
name|ObjCMethodDecl
operator|*
name|Method
argument_list|,
name|SourceLocation
name|LBracLoc
argument_list|,
name|MultiExprArg
name|Args
argument_list|,
name|SourceLocation
name|RBracLoc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildInstanceMessage
argument_list|(
name|Receiver
argument_list|,
name|Receiver
operator|->
name|getType
argument_list|()
argument_list|,
comment|/*SuperLoc=*/
name|SourceLocation
argument_list|()
argument_list|,
name|Sel
argument_list|,
name|Method
argument_list|,
name|LBracLoc
argument_list|,
name|SelectorLocs
argument_list|,
name|RBracLoc
argument_list|,
name|Args
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C ivar reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCIvarRefExpr
parameter_list|(
name|Expr
modifier|*
name|BaseArg
parameter_list|,
name|ObjCIvarDecl
modifier|*
name|Ivar
parameter_list|,
name|SourceLocation
name|IvarLoc
parameter_list|,
name|bool
name|IsArrow
parameter_list|,
name|bool
name|IsFreeIvar
parameter_list|)
block|{
comment|// FIXME: We lose track of the IsFreeIvar bit.
name|CXXScopeSpec
name|SS
decl_stmt|;
name|ExprResult
name|Base
init|=
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|BaseArg
argument_list|)
decl_stmt|;
name|LookupResult
name|R
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Ivar
operator|->
name|getDeclName
argument_list|()
argument_list|,
name|IvarLoc
argument_list|,
name|Sema
operator|::
name|LookupMemberName
argument_list|)
decl_stmt|;
name|ExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|LookupMemberExpr
argument_list|(
name|R
argument_list|,
name|Base
argument_list|,
name|IsArrow
argument_list|,
comment|/*FIME:*/
name|IvarLoc
argument_list|,
name|SS
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
operator|||
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|Result
operator|.
name|get
argument_list|()
condition|)
return|return
name|Result
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|Base
operator|.
name|get
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|IvarLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
comment|/*FirstQualifierInScope=*/
literal|0
argument_list|,
name|R
argument_list|,
comment|/*TemplateArgs=*/
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C property reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCPropertyRefExpr
parameter_list|(
name|Expr
modifier|*
name|BaseArg
parameter_list|,
name|ObjCPropertyDecl
modifier|*
name|Property
parameter_list|,
name|SourceLocation
name|PropertyLoc
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|ExprResult
name|Base
init|=
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|BaseArg
argument_list|)
decl_stmt|;
name|LookupResult
name|R
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Property
operator|->
name|getDeclName
argument_list|()
argument_list|,
name|PropertyLoc
argument_list|,
name|Sema
operator|::
name|LookupMemberName
argument_list|)
decl_stmt|;
name|bool
name|IsArrow
init|=
name|false
decl_stmt|;
name|ExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|LookupMemberExpr
argument_list|(
name|R
argument_list|,
name|Base
argument_list|,
name|IsArrow
argument_list|,
comment|/*FIME:*/
name|PropertyLoc
argument_list|,
name|SS
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
operator|||
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|Result
operator|.
name|get
argument_list|()
condition|)
return|return
name|Result
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|Base
operator|.
name|get
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|PropertyLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
comment|/*FirstQualifierInScope=*/
literal|0
argument_list|,
name|R
argument_list|,
comment|/*TemplateArgs=*/
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C property reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCPropertyRefExpr
parameter_list|(
name|Expr
modifier|*
name|Base
parameter_list|,
name|QualType
name|T
parameter_list|,
name|ObjCMethodDecl
modifier|*
name|Getter
parameter_list|,
name|ObjCMethodDecl
modifier|*
name|Setter
parameter_list|,
name|SourceLocation
name|PropertyLoc
parameter_list|)
block|{
comment|// Since these expressions can only be value-dependent, we do not
comment|// need to perform semantic analysis again.
return|return
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|ObjCPropertyRefExpr
argument_list|(
name|Getter
argument_list|,
name|Setter
argument_list|,
name|T
argument_list|,
name|VK_LValue
argument_list|,
name|OK_ObjCProperty
argument_list|,
name|PropertyLoc
argument_list|,
name|Base
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C "isa" expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildObjCIsaExpr
parameter_list|(
name|Expr
modifier|*
name|BaseArg
parameter_list|,
name|SourceLocation
name|IsaLoc
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|bool
name|IsArrow
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|ExprResult
name|Base
init|=
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|BaseArg
argument_list|)
decl_stmt|;
name|LookupResult
name|R
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|&
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|Idents
operator|.
name|get
argument_list|(
literal|"isa"
argument_list|)
argument_list|,
name|IsaLoc
argument_list|,
name|Sema
operator|::
name|LookupMemberName
argument_list|)
decl_stmt|;
name|ExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|LookupMemberExpr
argument_list|(
name|R
argument_list|,
name|Base
argument_list|,
name|IsArrow
argument_list|,
name|OpLoc
argument_list|,
name|SS
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
operator|||
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|Result
operator|.
name|get
argument_list|()
condition|)
return|return
name|Result
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|Base
operator|.
name|get
argument_list|()
operator|->
name|getType
argument_list|()
argument_list|,
name|OpLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
comment|/*FirstQualifierInScope=*/
literal|0
argument_list|,
name|R
argument_list|,
comment|/*TemplateArgs=*/
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new shuffle vector expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildShuffleVectorExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|MultiExprArg
name|SubExprs
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
comment|// Find the declaration for __builtin_shufflevector
specifier|const
name|IdentifierInfo
modifier|&
name|Name
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|Idents
operator|.
name|get
argument_list|(
literal|"__builtin_shufflevector"
argument_list|)
decl_stmt|;
name|TranslationUnitDecl
modifier|*
name|TUDecl
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTranslationUnitDecl
argument_list|()
decl_stmt|;
name|DeclContext
operator|::
name|lookup_result
name|Lookup
operator|=
name|TUDecl
operator|->
name|lookup
argument_list|(
name|DeclarationName
argument_list|(
operator|&
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Lookup
operator|.
name|empty
argument_list|()
operator|&&
literal|"No __builtin_shufflevector?"
argument_list|)
expr_stmt|;
comment|// Build a reference to the __builtin_shufflevector builtin
name|FunctionDecl
modifier|*
name|Builtin
init|=
name|cast
operator|<
name|FunctionDecl
operator|>
operator|(
name|Lookup
operator|.
name|front
argument_list|()
operator|)
decl_stmt|;
name|Expr
modifier|*
name|Callee
init|=
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|DeclRefExpr
argument_list|(
name|Builtin
argument_list|,
name|false
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|BuiltinFnTy
argument_list|,
name|VK_RValue
argument_list|,
name|BuiltinLoc
argument_list|)
decl_stmt|;
name|QualType
name|CalleePtrTy
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getPointerType
argument_list|(
name|Builtin
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|Callee
operator|=
name|SemaRef
operator|.
name|ImpCastExprToType
argument_list|(
name|Callee
argument_list|,
name|CalleePtrTy
argument_list|,
name|CK_BuiltinFnToFnPtr
argument_list|)
operator|.
name|take
argument_list|()
expr_stmt|;
comment|// Build the CallExpr
name|ExprResult
name|TheCall
init|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|CallExpr
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Callee
argument_list|,
name|SubExprs
argument_list|,
name|Builtin
operator|->
name|getCallResultType
argument_list|()
argument_list|,
name|Expr
operator|::
name|getValueKindForType
argument_list|(
name|Builtin
operator|->
name|getResultType
argument_list|()
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
decl_stmt|;
comment|// Type-check the __builtin_shufflevector expression.
return|return
name|SemaRef
operator|.
name|SemaBuiltinShuffleVector
argument_list|(
name|cast
operator|<
name|CallExpr
operator|>
operator|(
name|TheCall
operator|.
name|take
argument_list|()
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new convert vector expression.
name|ExprResult
name|RebuildConvertVectorExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|Expr
modifier|*
name|SrcExpr
parameter_list|,
name|TypeSourceInfo
modifier|*
name|DstTInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|SemaConvertVectorExpr
argument_list|(
name|SrcExpr
argument_list|,
name|DstTInfo
argument_list|,
name|BuiltinLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new template argument pack expansion.
comment|///
comment|/// By default, performs semantic analysis to build a new pack expansion
comment|/// for a template argument. Subclasses may override this routine to provide
comment|/// different behavior.
name|TemplateArgumentLoc
name|RebuildPackExpansion
argument_list|(
name|TemplateArgumentLoc
name|Pattern
argument_list|,
name|SourceLocation
name|EllipsisLoc
argument_list|,
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
argument_list|)
block|{
switch|switch
condition|(
name|Pattern
operator|.
name|getArgument
argument_list|()
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
block|{
name|ExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|CheckPackExpansion
argument_list|(
name|Pattern
operator|.
name|getSourceExpression
argument_list|()
argument_list|,
name|EllipsisLoc
argument_list|,
name|NumExpansions
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|TemplateArgumentLoc
argument_list|()
return|;
return|return
name|TemplateArgumentLoc
argument_list|(
name|Result
operator|.
name|get
argument_list|()
argument_list|,
name|Result
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
case|case
name|TemplateArgument
operator|::
name|Template
case|:
return|return
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|Pattern
operator|.
name|getArgument
argument_list|()
operator|.
name|getAsTemplate
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
argument_list|,
name|Pattern
operator|.
name|getTemplateQualifierLoc
argument_list|()
argument_list|,
name|Pattern
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|EllipsisLoc
argument_list|)
return|;
case|case
name|TemplateArgument
operator|::
name|Null
case|:
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
case|case
name|TemplateArgument
operator|::
name|TemplateExpansion
case|:
case|case
name|TemplateArgument
operator|::
name|NullPtr
case|:
name|llvm_unreachable
argument_list|(
literal|"Pack expansion pattern has no parameter packs"
argument_list|)
expr_stmt|;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
if|if
condition|(
name|TypeSourceInfo
modifier|*
name|Expansion
init|=
name|getSema
argument_list|()
operator|.
name|CheckPackExpansion
argument_list|(
name|Pattern
operator|.
name|getTypeSourceInfo
argument_list|()
argument_list|,
name|EllipsisLoc
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|Expansion
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
name|Expansion
argument_list|)
return|;
break|break;
block|}
return|return
name|TemplateArgumentLoc
argument_list|()
return|;
block|}
comment|/// \brief Build a new expression pack expansion.
comment|///
comment|/// By default, performs semantic analysis to build a new pack expansion
comment|/// for an expression. Subclasses may override this routine to provide
comment|/// different behavior.
name|ExprResult
name|RebuildPackExpansion
argument_list|(
name|Expr
operator|*
name|Pattern
argument_list|,
name|SourceLocation
name|EllipsisLoc
argument_list|,
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|CheckPackExpansion
argument_list|(
name|Pattern
argument_list|,
name|EllipsisLoc
argument_list|,
name|NumExpansions
argument_list|)
return|;
block|}
comment|/// \brief Build a new atomic operation expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|ExprResult
name|RebuildAtomicExpr
argument_list|(
name|SourceLocation
name|BuiltinLoc
argument_list|,
name|MultiExprArg
name|SubExprs
argument_list|,
name|QualType
name|RetTy
argument_list|,
name|AtomicExpr
operator|::
name|AtomicOp
name|Op
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|)
block|{
comment|// Just create the expression; there is not any interesting semantic
comment|// analysis here because we can't actually build an AtomicExpr until
comment|// we are sure it is semantically sound.
return|return
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|AtomicExpr
argument_list|(
name|BuiltinLoc
argument_list|,
name|SubExprs
argument_list|,
name|RetTy
argument_list|,
name|Op
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
name|private
label|:
name|TypeLoc
name|TransformTypeInObjectScope
parameter_list|(
name|TypeLoc
name|TL
parameter_list|,
name|QualType
name|ObjectType
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|)
function_decl|;
name|TypeSourceInfo
modifier|*
name|TransformTypeInObjectScope
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TSInfo
parameter_list|,
name|QualType
name|ObjectType
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
if|if
condition|(
operator|!
name|S
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|S
operator|->
name|getStmtClass
argument_list|()
condition|)
block|{
case|case
name|Stmt
operator|::
name|NoStmtClass
case|:
break|break;
comment|// Transform individual statement nodes
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|case Stmt::Node##Class: return getDerived().Transform##Node(cast<Node>(S));
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|Node
parameter_list|)
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
comment|// Transform expressions by calling TransformExpr.
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|Stmt
parameter_list|)
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
value|case Stmt::Node##Class:
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|{
name|ExprResult
name|E
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|cast
operator|<
name|Expr
operator|>
operator|(
name|S
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnExprStmt
argument_list|(
name|E
argument_list|)
return|;
block|}
block|}
end_switch

begin_return
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|OMPClause
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPClause
argument_list|(
argument|OMPClause *S
argument_list|)
block|{
if|if
condition|(
operator|!
name|S
condition|)
return|return
name|S
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|S
operator|->
name|getClauseKind
argument_list|()
condition|)
block|{
default|default:
break|break;
comment|// Transform individual clause nodes
define|#
directive|define
name|OPENMP_CLAUSE
parameter_list|(
name|Name
parameter_list|,
name|Class
parameter_list|)
define|\
value|case OMPC_ ## Name :                                                         \     return getDerived().Transform ## Class(cast<Class>(S));
include|#
directive|include
file|"clang/Basic/OpenMPKinds.def"
block|}
end_switch

begin_return
return|return
name|S
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExpr
argument_list|(
argument|Expr *E
argument_list|)
block|{
if|if
condition|(
operator|!
name|E
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|E
operator|->
name|getStmtClass
argument_list|()
condition|)
block|{
case|case
name|Stmt
operator|::
name|NoStmtClass
case|:
break|break;
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
value|case Stmt::Node##Class: break;
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|Stmt
parameter_list|)
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|case Stmt::Node##Class: return getDerived().Transform##Node(cast<Node>(E));
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|}
end_switch

begin_return
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformInitializer
argument_list|(
argument|Expr *Init
argument_list|,
argument|bool CXXDirectInit
argument_list|)
block|{
comment|// Initializers are instantiated like expressions, except that various outer
comment|// layers are stripped.
if|if
condition|(
operator|!
name|Init
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|Init
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|ExprWithCleanups
modifier|*
name|ExprTemp
init|=
name|dyn_cast
operator|<
name|ExprWithCleanups
operator|>
operator|(
name|Init
operator|)
condition|)
name|Init
operator|=
name|ExprTemp
operator|->
name|getSubExpr
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|MaterializeTemporaryExpr
modifier|*
name|MTE
init|=
name|dyn_cast
operator|<
name|MaterializeTemporaryExpr
operator|>
operator|(
name|Init
operator|)
condition|)
name|Init
operator|=
name|MTE
operator|->
name|GetTemporaryExpr
argument_list|()
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|CXXBindTemporaryExpr
modifier|*
name|Binder
init|=
name|dyn_cast
operator|<
name|CXXBindTemporaryExpr
operator|>
operator|(
name|Init
operator|)
condition|)
name|Init
operator|=
name|Binder
operator|->
name|getSubExpr
argument_list|()
expr_stmt|;
end_while

begin_if
if|if
condition|(
name|ImplicitCastExpr
modifier|*
name|ICE
init|=
name|dyn_cast
operator|<
name|ImplicitCastExpr
operator|>
operator|(
name|Init
operator|)
condition|)
name|Init
operator|=
name|ICE
operator|->
name|getSubExprAsWritten
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|CXXStdInitializerListExpr
modifier|*
name|ILE
init|=
name|dyn_cast
operator|<
name|CXXStdInitializerListExpr
operator|>
operator|(
name|Init
operator|)
condition|)
return|return
name|TransformInitializer
argument_list|(
name|ILE
operator|->
name|getSubExpr
argument_list|()
argument_list|,
name|CXXDirectInit
argument_list|)
return|;
end_if

begin_comment
comment|// If this is not a direct-initializer, we only need to reconstruct
end_comment

begin_comment
comment|// InitListExprs. Other forms of copy-initialization will be a no-op if
end_comment

begin_comment
comment|// the initializer is already the right type.
end_comment

begin_decl_stmt
name|CXXConstructExpr
modifier|*
name|Construct
init|=
name|dyn_cast
operator|<
name|CXXConstructExpr
operator|>
operator|(
name|Init
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|CXXDirectInit
operator|&&
operator|!
operator|(
name|Construct
operator|&&
name|Construct
operator|->
name|isListInitialization
argument_list|()
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Init
argument_list|)
return|;
end_if

begin_comment
comment|// Revert value-initialization back to empty parens.
end_comment

begin_if
if|if
condition|(
name|CXXScalarValueInitExpr
modifier|*
name|VIE
init|=
name|dyn_cast
operator|<
name|CXXScalarValueInitExpr
operator|>
operator|(
name|Init
operator|)
condition|)
block|{
name|SourceRange
name|Parens
init|=
name|VIE
operator|->
name|getSourceRange
argument_list|()
decl_stmt|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenListExpr
argument_list|(
name|Parens
operator|.
name|getBegin
argument_list|()
argument_list|,
name|None
argument_list|,
name|Parens
operator|.
name|getEnd
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// FIXME: We shouldn't build ImplicitValueInitExprs for direct-initialization.
end_comment

begin_if
if|if
condition|(
name|isa
operator|<
name|ImplicitValueInitExpr
operator|>
operator|(
name|Init
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenListExpr
argument_list|(
name|SourceLocation
argument_list|()
argument_list|,
name|None
argument_list|,
name|SourceLocation
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// Revert initialization by constructor back to a parenthesized or braced list
end_comment

begin_comment
comment|// of expressions. Any other form of initializer can just be reused directly.
end_comment

begin_if
if|if
condition|(
operator|!
name|Construct
operator|||
name|isa
operator|<
name|CXXTemporaryObjectExpr
operator|>
operator|(
name|Construct
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Init
argument_list|)
return|;
end_if

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|NewArgs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|ArgChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|Construct
operator|->
name|getArgs
argument_list|()
argument_list|,
name|Construct
operator|->
name|getNumArgs
argument_list|()
argument_list|,
comment|/*IsCall*/
name|true
argument_list|,
name|NewArgs
argument_list|,
operator|&
name|ArgChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// If this was list initialization, revert to list form.
end_comment

begin_if
if|if
condition|(
name|Construct
operator|->
name|isListInitialization
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildInitList
argument_list|(
name|Construct
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|NewArgs
argument_list|,
name|Construct
operator|->
name|getLocEnd
argument_list|()
argument_list|,
name|Construct
operator|->
name|getType
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// Build a ParenListExpr to represent anything else.
end_comment

begin_decl_stmt
name|SourceRange
name|Parens
init|=
name|Construct
operator|->
name|getParenOrBraceRange
argument_list|()
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenListExpr
argument_list|(
name|Parens
operator|.
name|getBegin
argument_list|()
argument_list|,
name|NewArgs
argument_list|,
name|Parens
operator|.
name|getEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExprs
argument_list|(
argument|Expr **Inputs
argument_list|,
argument|unsigned NumInputs
argument_list|,
argument|bool IsCall
argument_list|,
argument|SmallVectorImpl<Expr *>&Outputs
argument_list|,
argument|bool *ArgChanged
argument_list|)
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|NumInputs
condition|;
operator|++
name|I
control|)
block|{
comment|// If requested, drop call arguments that need to be dropped.
if|if
condition|(
name|IsCall
operator|&&
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
name|Inputs
index|[
name|I
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|ArgChanged
condition|)
operator|*
name|ArgChanged
operator|=
name|true
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|PackExpansionExpr
modifier|*
name|Expansion
init|=
name|dyn_cast
operator|<
name|PackExpansionExpr
operator|>
operator|(
name|Inputs
index|[
name|I
index|]
operator|)
condition|)
block|{
name|Expr
modifier|*
name|Pattern
init|=
name|Expansion
operator|->
name|getPattern
argument_list|()
decl_stmt|;
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
name|getSema
argument_list|()
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|Pattern
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Unexpanded
operator|.
name|empty
argument_list|()
operator|&&
literal|"Pack expansion without parameter packs?"
argument_list|)
expr_stmt|;
comment|// Determine whether the set of unexpanded parameter packs can and should
comment|// be expanded.
name|bool
name|Expand
init|=
name|true
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|OrigNumExpansions
operator|=
name|Expansion
operator|->
name|getNumExpansions
argument_list|()
expr_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
operator|=
name|OrigNumExpansions
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|Expansion
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|Pattern
operator|->
name|getSourceRange
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|Expand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|Expand
condition|)
block|{
comment|// The transform has determined that we should perform a simple
comment|// transformation on the pack expansion, producing another pack
comment|// expansion.
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ExprResult
name|OutPattern
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|OutPattern
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
name|ExprResult
name|Out
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansion
argument_list|(
name|OutPattern
operator|.
name|get
argument_list|()
argument_list|,
name|Expansion
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
decl_stmt|;
if|if
condition|(
name|Out
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ArgChanged
condition|)
operator|*
name|ArgChanged
operator|=
name|true
expr_stmt|;
name|Outputs
operator|.
name|push_back
argument_list|(
name|Out
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Record right away that the argument was changed.  This needs
comment|// to happen even if the array expands to nothing.
if|if
condition|(
name|ArgChanged
condition|)
operator|*
name|ArgChanged
operator|=
name|true
expr_stmt|;
comment|// The transform has determined that we should perform an elementwise
comment|// expansion of the pattern. Do so.
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|ExprResult
name|Out
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|Out
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
if|if
condition|(
name|Out
operator|.
name|get
argument_list|()
operator|->
name|containsUnexpandedParameterPack
argument_list|()
condition|)
block|{
name|Out
operator|=
name|RebuildPackExpansion
argument_list|(
name|Out
operator|.
name|get
argument_list|()
argument_list|,
name|Expansion
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|OrigNumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|Out
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
block|}
name|Outputs
operator|.
name|push_back
argument_list|(
name|Out
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
end_if

begin_decl_stmt
name|ExprResult
name|Result
init|=
name|IsCall
condition|?
name|getDerived
argument_list|()
operator|.
name|TransformInitializer
argument_list|(
name|Inputs
index|[
name|I
index|]
argument_list|,
comment|/*DirectInit*/
name|false
argument_list|)
else|:
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Inputs
index|[
name|I
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
end_if

begin_if
if|if
condition|(
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|Inputs
index|[
name|I
index|]
operator|&&
name|ArgChanged
condition|)
operator|*
name|ArgChanged
operator|=
name|true
expr_stmt|;
end_if

begin_expr_stmt
name|Outputs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|NestedNameSpecifierLoc
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformNestedNameSpecifierLoc
argument_list|(
argument|NestedNameSpecifierLoc NNS
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *FirstQualifierInScope
argument_list|)
block|{
name|SmallVector
operator|<
name|NestedNameSpecifierLoc
block|,
literal|4
operator|>
name|Qualifiers
block|;
for|for
control|(
name|NestedNameSpecifierLoc
name|Qualifier
init|=
name|NNS
init|;
name|Qualifier
condition|;
name|Qualifier
operator|=
name|Qualifier
operator|.
name|getPrefix
argument_list|()
control|)
name|Qualifiers
operator|.
name|push_back
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
name|CXXScopeSpec
name|SS
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|!
name|Qualifiers
operator|.
name|empty
argument_list|()
condition|)
block|{
name|NestedNameSpecifierLoc
name|Q
init|=
name|Qualifiers
operator|.
name|pop_back_val
argument_list|()
decl_stmt|;
name|NestedNameSpecifier
modifier|*
name|QNNS
init|=
name|Q
operator|.
name|getNestedNameSpecifier
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|QNNS
operator|->
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NestedNameSpecifier
operator|::
name|Identifier
case|:
if|if
condition|(
name|SemaRef
operator|.
name|BuildCXXNestedNameSpecifier
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
operator|*
name|QNNS
operator|->
name|getAsIdentifier
argument_list|()
argument_list|,
name|Q
operator|.
name|getLocalBeginLoc
argument_list|()
argument_list|,
name|Q
operator|.
name|getLocalEndLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|false
argument_list|,
name|SS
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|NestedNameSpecifierLoc
argument_list|()
return|;
break|break;
case|case
name|NestedNameSpecifier
operator|::
name|Namespace
case|:
block|{
name|NamespaceDecl
modifier|*
name|NS
init|=
name|cast_or_null
operator|<
name|NamespaceDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Q
operator|.
name|getLocalBeginLoc
argument_list|()
argument_list|,
name|QNNS
operator|->
name|getAsNamespace
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|SS
operator|.
name|Extend
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|NS
argument_list|,
name|Q
operator|.
name|getLocalBeginLoc
argument_list|()
argument_list|,
name|Q
operator|.
name|getLocalEndLoc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NestedNameSpecifier
operator|::
name|NamespaceAlias
case|:
block|{
name|NamespaceAliasDecl
modifier|*
name|Alias
init|=
name|cast_or_null
operator|<
name|NamespaceAliasDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Q
operator|.
name|getLocalBeginLoc
argument_list|()
argument_list|,
name|QNNS
operator|->
name|getAsNamespaceAlias
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|SS
operator|.
name|Extend
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Alias
argument_list|,
name|Q
operator|.
name|getLocalBeginLoc
argument_list|()
argument_list|,
name|Q
operator|.
name|getLocalEndLoc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NestedNameSpecifier
operator|::
name|Global
case|:
comment|// There is no meaningful transformation that one could perform on the
comment|// global scope.
name|SS
operator|.
name|MakeGlobal
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Q
operator|.
name|getBeginLoc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpecWithTemplate
case|:
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpec
case|:
block|{
name|TypeLoc
name|TL
init|=
name|TransformTypeInObjectScope
argument_list|(
name|Q
operator|.
name|getTypeLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|SS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TL
condition|)
return|return
name|NestedNameSpecifierLoc
argument_list|()
return|;
if|if
condition|(
name|TL
operator|.
name|getType
argument_list|()
operator|->
name|isDependentType
argument_list|()
operator|||
name|TL
operator|.
name|getType
argument_list|()
operator|->
name|isRecordType
argument_list|()
operator|||
operator|(
name|SemaRef
operator|.
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
operator|&&
name|TL
operator|.
name|getType
argument_list|()
operator|->
name|isEnumeralType
argument_list|()
operator|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|TL
operator|.
name|getType
argument_list|()
operator|.
name|hasLocalQualifiers
argument_list|()
operator|&&
literal|"Can't get cv-qualifiers here"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TL
operator|.
name|getType
argument_list|()
operator|->
name|isEnumeralType
argument_list|()
condition|)
name|SemaRef
operator|.
name|Diag
argument_list|(
name|TL
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|diag
operator|::
name|warn_cxx98_compat_enum_nested_name_spec
argument_list|)
expr_stmt|;
name|SS
operator|.
name|Extend
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
comment|/*FIXME:*/
name|SourceLocation
argument_list|()
argument_list|,
name|TL
argument_list|,
name|Q
operator|.
name|getLocalEndLoc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// If the nested-name-specifier is an invalid type def, don't emit an
comment|// error because a previous error should have already been emitted.
name|TypedefTypeLoc
name|TTL
init|=
name|TL
operator|.
name|getAs
operator|<
name|TypedefTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|TTL
operator|||
operator|!
name|TTL
operator|.
name|getTypedefNameDecl
argument_list|()
operator|->
name|isInvalidDecl
argument_list|()
condition|)
block|{
name|SemaRef
operator|.
name|Diag
argument_list|(
name|TL
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|diag
operator|::
name|err_nested_name_spec_non_tag
argument_list|)
operator|<<
name|TL
operator|.
name|getType
argument_list|()
operator|<<
name|SS
operator|.
name|getRange
argument_list|()
expr_stmt|;
block|}
return|return
name|NestedNameSpecifierLoc
argument_list|()
return|;
block|}
block|}
comment|// The qualifier-in-scope and object type only apply to the leftmost entity.
name|FirstQualifierInScope
operator|=
literal|0
expr_stmt|;
name|ObjectType
operator|=
name|QualType
argument_list|()
expr_stmt|;
block|}
end_while

begin_comment
comment|// Don't rebuild the nested-name-specifier if we don't have to.
end_comment

begin_if
if|if
condition|(
name|SS
operator|.
name|getScopeRep
argument_list|()
operator|==
name|NNS
operator|.
name|getNestedNameSpecifier
argument_list|()
operator|&&
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
condition|)
return|return
name|NNS
return|;
end_if

begin_comment
comment|// If we can re-use the source-location data from the original
end_comment

begin_comment
comment|// nested-name-specifier, do so.
end_comment

begin_if
if|if
condition|(
name|SS
operator|.
name|location_size
argument_list|()
operator|==
name|NNS
operator|.
name|getDataLength
argument_list|()
operator|&&
name|memcmp
argument_list|(
name|SS
operator|.
name|location_data
argument_list|()
argument_list|,
name|NNS
operator|.
name|getOpaqueData
argument_list|()
argument_list|,
name|SS
operator|.
name|location_size
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NestedNameSpecifierLoc
argument_list|(
name|SS
operator|.
name|getScopeRep
argument_list|()
argument_list|,
name|NNS
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// Allocate new nested-name-specifier location information.
end_comment

begin_return
return|return
name|SS
operator|.
name|getWithLocInContext
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|DeclarationNameInfo
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclarationNameInfo
argument_list|(
argument|const DeclarationNameInfo&NameInfo
argument_list|)
block|{
name|DeclarationName
name|Name
operator|=
name|NameInfo
operator|.
name|getName
argument_list|()
block|;
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|DeclarationNameInfo
argument_list|()
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|Name
operator|.
name|getNameKind
argument_list|()
condition|)
block|{
case|case
name|DeclarationName
operator|::
name|Identifier
case|:
case|case
name|DeclarationName
operator|::
name|ObjCZeroArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|ObjCOneArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|ObjCMultiArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|CXXOperatorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXLiteralOperatorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXUsingDirective
case|:
return|return
name|NameInfo
return|;
case|case
name|DeclarationName
operator|::
name|CXXConstructorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXDestructorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXConversionFunctionName
case|:
block|{
name|TypeSourceInfo
modifier|*
name|NewTInfo
decl_stmt|;
name|CanQualType
name|NewCanTy
decl_stmt|;
if|if
condition|(
name|TypeSourceInfo
modifier|*
name|OldTInfo
init|=
name|NameInfo
operator|.
name|getNamedTypeInfo
argument_list|()
condition|)
block|{
name|NewTInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldTInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewTInfo
condition|)
return|return
name|DeclarationNameInfo
argument_list|()
return|;
name|NewCanTy
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|NewTInfo
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NewTInfo
operator|=
literal|0
expr_stmt|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|NameInfo
operator|.
name|getLoc
argument_list|()
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|QualType
name|NewT
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Name
operator|.
name|getCXXNameType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|NewT
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|DeclarationNameInfo
argument_list|()
return|;
name|NewCanTy
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|NewT
argument_list|)
expr_stmt|;
block|}
name|DeclarationName
name|NewName
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|DeclarationNames
operator|.
name|getCXXSpecialName
argument_list|(
name|Name
operator|.
name|getNameKind
argument_list|()
argument_list|,
name|NewCanTy
argument_list|)
decl_stmt|;
name|DeclarationNameInfo
name|NewNameInfo
parameter_list|(
name|NameInfo
parameter_list|)
function_decl|;
name|NewNameInfo
operator|.
name|setName
argument_list|(
name|NewName
argument_list|)
expr_stmt|;
name|NewNameInfo
operator|.
name|setNamedTypeInfo
argument_list|(
name|NewTInfo
argument_list|)
expr_stmt|;
return|return
name|NewNameInfo
return|;
block|}
block|}
end_switch

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"Unknown name kind."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateName
argument_list|(
argument|CXXScopeSpec&SS
argument_list|,
argument|TemplateName Name
argument_list|,
argument|SourceLocation NameLoc
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *FirstQualifierInScope
argument_list|)
block|{
if|if
condition|(
name|QualifiedTemplateName
modifier|*
name|QTN
init|=
name|Name
operator|.
name|getAsQualifiedTemplateName
argument_list|()
condition|)
block|{
name|TemplateDecl
modifier|*
name|Template
init|=
name|QTN
operator|->
name|getTemplateDecl
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|Template
operator|&&
literal|"qualified template name must refer to a template"
argument_list|)
expr_stmt|;
name|TemplateDecl
modifier|*
name|TransTemplate
init|=
name|cast_or_null
operator|<
name|TemplateDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|NameLoc
argument_list|,
name|Template
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|TransTemplate
condition|)
return|return
name|TemplateName
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SS
operator|.
name|getScopeRep
argument_list|()
operator|==
name|QTN
operator|->
name|getQualifier
argument_list|()
operator|&&
name|TransTemplate
operator|==
name|Template
condition|)
return|return
name|Name
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
name|QTN
operator|->
name|hasTemplateKeyword
argument_list|()
argument_list|,
name|TransTemplate
argument_list|)
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|DependentTemplateName
modifier|*
name|DTN
init|=
name|Name
operator|.
name|getAsDependentTemplateName
argument_list|()
condition|)
block|{
if|if
condition|(
name|SS
operator|.
name|getScopeRep
argument_list|()
condition|)
block|{
comment|// These apply to the scope specifier, not the template.
name|ObjectType
operator|=
name|QualType
argument_list|()
expr_stmt|;
name|FirstQualifierInScope
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SS
operator|.
name|getScopeRep
argument_list|()
operator|==
name|DTN
operator|->
name|getQualifier
argument_list|()
operator|&&
name|ObjectType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|Name
return|;
if|if
condition|(
name|DTN
operator|->
name|isIdentifier
argument_list|()
condition|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
operator|*
name|DTN
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|NameLoc
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|)
return|;
block|}
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
name|DTN
operator|->
name|getOperator
argument_list|()
argument_list|,
name|NameLoc
argument_list|,
name|ObjectType
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|TemplateDecl
modifier|*
name|Template
init|=
name|Name
operator|.
name|getAsTemplateDecl
argument_list|()
condition|)
block|{
name|TemplateDecl
modifier|*
name|TransTemplate
init|=
name|cast_or_null
operator|<
name|TemplateDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|NameLoc
argument_list|,
name|Template
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|TransTemplate
condition|)
return|return
name|TemplateName
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TransTemplate
operator|==
name|Template
condition|)
return|return
name|Name
return|;
return|return
name|TemplateName
argument_list|(
name|TransTemplate
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|SubstTemplateTemplateParmPackStorage
modifier|*
name|SubstPack
init|=
name|Name
operator|.
name|getAsSubstTemplateTemplateParmPack
argument_list|()
condition|)
block|{
name|TemplateTemplateParmDecl
modifier|*
name|TransParam
init|=
name|cast_or_null
operator|<
name|TemplateTemplateParmDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|NameLoc
argument_list|,
name|SubstPack
operator|->
name|getParameterPack
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|TransParam
condition|)
return|return
name|TemplateName
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TransParam
operator|==
name|SubstPack
operator|->
name|getParameterPack
argument_list|()
condition|)
return|return
name|Name
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|TransParam
argument_list|,
name|SubstPack
operator|->
name|getArgumentPack
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// These should be getting filtered out before they reach the AST.
end_comment

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"overloaded function decl survived to here"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|void
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|InventTemplateArgumentLoc
argument_list|(
argument|const TemplateArgument&Arg
argument_list|,
argument|TemplateArgumentLoc&Output
argument_list|)
block|{
name|SourceLocation
name|Loc
operator|=
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
block|;
switch|switch
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Null
case|:
name|llvm_unreachable
argument_list|(
literal|"null template argument in TreeTransform"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|Arg
operator|.
name|getAsType
argument_list|()
argument_list|,
name|Loc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Template
case|:
case|case
name|TemplateArgument
operator|::
name|TemplateExpansion
case|:
block|{
name|NestedNameSpecifierLocBuilder
name|Builder
decl_stmt|;
name|TemplateName
name|Template
init|=
name|Arg
operator|.
name|getAsTemplate
argument_list|()
decl_stmt|;
if|if
condition|(
name|DependentTemplateName
modifier|*
name|DTN
init|=
name|Template
operator|.
name|getAsDependentTemplateName
argument_list|()
condition|)
name|Builder
operator|.
name|MakeTrivial
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|DTN
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QualifiedTemplateName
modifier|*
name|QTN
init|=
name|Template
operator|.
name|getAsQualifiedTemplateName
argument_list|()
condition|)
name|Builder
operator|.
name|MakeTrivial
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|QTN
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Template
condition|)
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|Builder
operator|.
name|getWithLocInContext
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
else|else
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|Builder
operator|.
name|getWithLocInContext
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
argument_list|,
name|Loc
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
end_case

begin_expr_stmt
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|Arg
operator|.
name|getAsExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
end_case

begin_case
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
end_case

begin_case
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
end_case

begin_case
case|case
name|TemplateArgument
operator|::
name|NullPtr
case|:
end_case

begin_expr_stmt
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|TemplateArgumentLocInfo
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|} }
name|template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateArgument
argument_list|(
argument|const TemplateArgumentLoc&Input
argument_list|,
argument|TemplateArgumentLoc&Output
argument_list|)
block|{
specifier|const
name|TemplateArgument
operator|&
name|Arg
operator|=
name|Input
operator|.
name|getArgument
argument_list|()
block|;
switch|switch
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Null
case|:
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
case|case
name|TemplateArgument
operator|::
name|NullPtr
case|:
name|llvm_unreachable
argument_list|(
literal|"Unexpected TemplateArgument"
argument_list|)
expr_stmt|;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
block|{
name|TypeSourceInfo
modifier|*
name|DI
init|=
name|Input
operator|.
name|getTypeSourceInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|DI
operator|==
name|NULL
condition|)
name|DI
operator|=
name|InventTypeSourceInfo
argument_list|(
name|Input
operator|.
name|getArgument
argument_list|()
operator|.
name|getAsType
argument_list|()
argument_list|)
expr_stmt|;
name|DI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|DI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DI
condition|)
return|return
name|true
return|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|DI
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
name|DI
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_expr_stmt

begin_case
case|case
name|TemplateArgument
operator|::
name|Template
case|:
end_case

begin_block
block|{
name|NestedNameSpecifierLoc
name|QualifierLoc
init|=
name|Input
operator|.
name|getTemplateQualifierLoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|QualifierLoc
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|true
return|;
block|}
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|SS
argument_list|,
name|Arg
operator|.
name|getAsTemplate
argument_list|()
argument_list|,
name|Input
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|Template
argument_list|)
argument_list|,
name|QualifierLoc
argument_list|,
name|Input
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_case
case|case
name|TemplateArgument
operator|::
name|TemplateExpansion
case|:
end_case

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"Caller should expand pack expansions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_case
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
end_case

begin_block
block|{
comment|// Template argument expressions are constant expressions.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Sema
operator|::
name|ConstantEvaluated
argument_list|)
decl_stmt|;
name|Expr
modifier|*
name|InputExpr
init|=
name|Input
operator|.
name|getSourceExpression
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|InputExpr
condition|)
name|InputExpr
operator|=
name|Input
operator|.
name|getArgument
argument_list|()
operator|.
name|getAsExpr
argument_list|()
expr_stmt|;
name|ExprResult
name|E
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|InputExpr
argument_list|)
decl_stmt|;
name|E
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|E
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|E
operator|.
name|take
argument_list|()
argument_list|)
argument_list|,
name|E
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_comment
unit|}
comment|// Work around bogus GCC warning
end_comment

begin_expr_stmt
unit|return
name|true
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief Iterator adaptor that invents template argument location information
end_comment

begin_comment
comment|/// for each of the template arguments in its underlying iterator.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|,
name|typename
name|InputIterator
operator|>
name|class
name|TemplateArgumentLocInventIterator
block|{
name|TreeTransform
operator|<
name|Derived
operator|>
operator|&
name|Self
block|;
name|InputIterator
name|Iter
block|;
name|public
operator|:
typedef|typedef
name|TemplateArgumentLoc
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|TemplateArgumentLoc
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|InputIterator
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|input_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|pointer
block|{
name|TemplateArgumentLoc
name|Arg
decl_stmt|;
name|public
label|:
name|explicit
name|pointer
argument_list|(
argument|TemplateArgumentLoc Arg
argument_list|)
block|:
name|Arg
argument_list|(
argument|Arg
argument_list|)
block|{ }
specifier|const
name|TemplateArgumentLoc
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
operator|&
name|Arg
return|;
block|}
end_decl_stmt

begin_macro
unit|};
name|TemplateArgumentLocInventIterator
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_decl_stmt
name|explicit
name|TemplateArgumentLocInventIterator
argument_list|(
name|TreeTransform
operator|<
name|Derived
operator|>
operator|&
name|Self
argument_list|,
name|InputIterator
name|Iter
argument_list|)
range|:
name|Self
argument_list|(
name|Self
argument_list|)
decl_stmt|,
name|Iter
argument_list|(
name|Iter
argument_list|)
block|{ }
end_decl_stmt

begin_expr_stmt
name|TemplateArgumentLocInventIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Iter
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TemplateArgumentLocInventIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|TemplateArgumentLocInventIterator
name|Old
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
operator|(
operator|*
name|this
operator|)
block|;
return|return
name|Old
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|TemplateArgumentLoc
name|Result
block|;
name|Self
operator|.
name|InventTemplateArgumentLoc
argument_list|(
operator|*
name|Iter
argument_list|,
name|Result
argument_list|)
block|;
return|return
name|Result
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|pointer
argument_list|(
operator|*
operator|*
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TemplateArgumentLocInventIterator
operator|&
name|X
operator|,
specifier|const
name|TemplateArgumentLocInventIterator
operator|&
name|Y
operator|)
block|{
return|return
name|X
operator|.
name|Iter
operator|==
name|Y
operator|.
name|Iter
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TemplateArgumentLocInventIterator
operator|&
name|X
operator|,
specifier|const
name|TemplateArgumentLocInventIterator
operator|&
name|Y
operator|)
block|{
return|return
name|X
operator|.
name|Iter
operator|!=
name|Y
operator|.
name|Iter
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Derived
operator|>
name|template
operator|<
name|typename
name|InputIterator
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateArguments
argument_list|(
argument|InputIterator First
argument_list|,
argument|InputIterator Last
argument_list|,
argument|TemplateArgumentListInfo&Outputs
argument_list|)
block|{
for|for
control|(
init|;
name|First
operator|!=
name|Last
condition|;
operator|++
name|First
control|)
block|{
name|TemplateArgumentLoc
name|Out
decl_stmt|;
name|TemplateArgumentLoc
name|In
init|=
operator|*
name|First
decl_stmt|;
if|if
condition|(
name|In
operator|.
name|getArgument
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Pack
condition|)
block|{
comment|// Unpack argument packs, which we translate them into separate
comment|// arguments.
comment|// FIXME: We could do much better if we could guarantee that the
comment|// TemplateArgumentLocInfo for the pack expansion would be usable for
comment|// all of the template arguments in the argument pack.
typedef|typedef
name|TemplateArgumentLocInventIterator
operator|<
name|Derived
operator|,
name|TemplateArgument
operator|::
name|pack_iterator
operator|>
name|PackLocIterator
expr_stmt|;
if|if
condition|(
name|TransformTemplateArguments
argument_list|(
name|PackLocIterator
argument_list|(
operator|*
name|this
argument_list|,
name|In
operator|.
name|getArgument
argument_list|()
operator|.
name|pack_begin
argument_list|()
argument_list|)
argument_list|,
name|PackLocIterator
argument_list|(
operator|*
name|this
argument_list|,
name|In
operator|.
name|getArgument
argument_list|()
operator|.
name|pack_end
argument_list|()
argument_list|)
argument_list|,
name|Outputs
argument_list|)
condition|)
return|return
name|true
return|;
continue|continue;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|In
operator|.
name|getArgument
argument_list|()
operator|.
name|isPackExpansion
argument_list|()
condition|)
block|{
comment|// We have a pack expansion, for which we will be substituting into
comment|// the pattern.
name|SourceLocation
name|Ellipsis
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|OrigNumExpansions
expr_stmt|;
name|TemplateArgumentLoc
name|Pattern
init|=
name|getSema
argument_list|()
operator|.
name|getTemplateArgumentPackExpansionPattern
argument_list|(
name|In
argument_list|,
name|Ellipsis
argument_list|,
name|OrigNumExpansions
argument_list|)
decl_stmt|;
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
name|getSema
argument_list|()
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|Pattern
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Unexpanded
operator|.
name|empty
argument_list|()
operator|&&
literal|"Pack expansion without parameter packs?"
argument_list|)
expr_stmt|;
comment|// Determine whether the set of unexpanded parameter packs can and should
comment|// be expanded.
name|bool
name|Expand
init|=
name|true
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
operator|=
name|OrigNumExpansions
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|Ellipsis
argument_list|,
name|Pattern
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|Expand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|Expand
condition|)
block|{
comment|// The transform has determined that we should perform a simple
comment|// transformation on the pack expansion, producing another pack
comment|// expansion.
name|TemplateArgumentLoc
name|OutPattern
decl_stmt|;
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|Pattern
argument_list|,
name|OutPattern
argument_list|)
condition|)
return|return
name|true
return|;
name|Out
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansion
argument_list|(
name|OutPattern
argument_list|,
name|Ellipsis
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|Out
operator|.
name|getArgument
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|Outputs
operator|.
name|addArgument
argument_list|(
name|Out
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// The transform has determined that we should perform an elementwise
comment|// expansion of the pattern. Do so.
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|Pattern
argument_list|,
name|Out
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|Out
operator|.
name|getArgument
argument_list|()
operator|.
name|containsUnexpandedParameterPack
argument_list|()
condition|)
block|{
name|Out
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansion
argument_list|(
name|Out
argument_list|,
name|Ellipsis
argument_list|,
name|OrigNumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|Out
operator|.
name|getArgument
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
block|}
name|Outputs
operator|.
name|addArgument
argument_list|(
name|Out
argument_list|)
expr_stmt|;
block|}
comment|// If we're supposed to retain a pack expansion, do so by temporarily
comment|// forgetting the partially-substituted parameter pack.
if|if
condition|(
name|RetainExpansion
condition|)
block|{
name|ForgetPartiallySubstitutedPackRAII
name|Forget
argument_list|(
name|getDerived
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|Pattern
argument_list|,
name|Out
argument_list|)
condition|)
return|return
name|true
return|;
name|Out
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansion
argument_list|(
name|Out
argument_list|,
name|Ellipsis
argument_list|,
name|OrigNumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|Out
operator|.
name|getArgument
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|Outputs
operator|.
name|addArgument
argument_list|(
name|Out
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
end_if

begin_comment
comment|// The simple case:
end_comment

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|In
argument_list|,
name|Out
argument_list|)
condition|)
return|return
name|true
return|;
end_if

begin_expr_stmt
name|Outputs
operator|.
name|addArgument
argument_list|(
name|Out
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|false
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Type transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|QualType T
argument_list|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|T
return|;
comment|// Temporary workaround.  All of these transformations should
comment|// eventually turn into transformations on TypeLocs.
name|TypeSourceInfo
operator|*
name|DI
operator|=
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|T
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|NewDI
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|DI
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|NewDI
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_return
return|return
name|NewDI
operator|->
name|getType
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TypeSourceInfo
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|TypeSourceInfo *DI
argument_list|)
block|{
comment|// Refine the base location to the type's location.
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|DI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|DI
operator|->
name|getType
argument_list|()
argument_list|)
condition|)
return|return
name|DI
return|;
name|TypeLocBuilder
name|TLB
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TypeLoc
name|TL
init|=
name|DI
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TLB
operator|.
name|reserve
argument_list|(
name|TL
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
end_if

begin_return
return|return
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Result
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeLoc T
argument_list|)
block|{
switch|switch
condition|(
name|T
operator|.
name|getTypeLocClass
argument_list|()
condition|)
block|{
define|#
directive|define
name|ABSTRACT_TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|#
directive|define
name|TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|case TypeLoc::CLASS:                                                         \     return getDerived().Transform##CLASS##Type(TLB,                            \                                                T.castAs<CLASS##TypeLoc>());
include|#
directive|include
file|"clang/AST/TypeLocNodes.def"
block|}
name|llvm_unreachable
argument_list|(
literal|"unhandled type loc!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// FIXME: By default, this routine adds type qualifiers only to types
end_comment

begin_comment
comment|/// that can have qualifiers, and silently suppresses those qualifiers
end_comment

begin_comment
comment|/// that are not permitted (e.g., qualifiers on reference or function
end_comment

begin_comment
comment|/// types). This is the right thing for template instantiation, but
end_comment

begin_comment
comment|/// probably not for other clients.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformQualifiedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|QualifiedTypeLoc T
argument_list|)
block|{
name|Qualifiers
name|Quals
operator|=
name|T
operator|.
name|getType
argument_list|()
operator|.
name|getLocalQualifiers
argument_list|()
block|;
name|QualType
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|T
operator|.
name|getUnqualifiedLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Silently suppress qualifiers if the result type can't be qualified.
end_comment

begin_comment
comment|// FIXME: this is the right thing for template instantiation, but
end_comment

begin_comment
comment|// probably not for other clients.
end_comment

begin_if
if|if
condition|(
name|Result
operator|->
name|isFunctionType
argument_list|()
operator|||
name|Result
operator|->
name|isReferenceType
argument_list|()
condition|)
return|return
name|Result
return|;
end_if

begin_comment
comment|// Suppress Objective-C lifetime qualifiers if they don't make sense for the
end_comment

begin_comment
comment|// resulting type.
end_comment

begin_if
if|if
condition|(
name|Quals
operator|.
name|hasObjCLifetime
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|Result
operator|->
name|isObjCLifetimeType
argument_list|()
operator|&&
operator|!
name|Result
operator|->
name|isDependentType
argument_list|()
condition|)
name|Quals
operator|.
name|removeObjCLifetime
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Result
operator|.
name|getObjCLifetime
argument_list|()
condition|)
block|{
comment|// Objective-C ARC:
comment|//   A lifetime qualifier applied to a substituted template parameter
comment|//   overrides the lifetime qualifier from the template argument.
specifier|const
name|AutoType
modifier|*
name|AutoTy
decl_stmt|;
if|if
condition|(
specifier|const
name|SubstTemplateTypeParmType
modifier|*
name|SubstTypeParam
init|=
name|dyn_cast
operator|<
name|SubstTemplateTypeParmType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|QualType
name|Replacement
init|=
name|SubstTypeParam
operator|->
name|getReplacementType
argument_list|()
decl_stmt|;
name|Qualifiers
name|Qs
init|=
name|Replacement
operator|.
name|getQualifiers
argument_list|()
decl_stmt|;
name|Qs
operator|.
name|removeObjCLifetime
argument_list|()
expr_stmt|;
name|Replacement
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedType
argument_list|(
name|Replacement
operator|.
name|getUnqualifiedType
argument_list|()
argument_list|,
name|Qs
argument_list|)
expr_stmt|;
name|Result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getSubstTemplateTypeParmType
argument_list|(
name|SubstTypeParam
operator|->
name|getReplacedParameter
argument_list|()
argument_list|,
name|Replacement
argument_list|)
expr_stmt|;
name|TLB
operator|.
name|TypeWasModifiedSafely
argument_list|(
name|Result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|AutoTy
operator|=
name|dyn_cast
operator|<
name|AutoType
operator|>
operator|(
name|Result
operator|)
operator|)
operator|&&
name|AutoTy
operator|->
name|isDeduced
argument_list|()
condition|)
block|{
comment|// 'auto' types behave the same way as template parameters.
name|QualType
name|Deduced
init|=
name|AutoTy
operator|->
name|getDeducedType
argument_list|()
decl_stmt|;
name|Qualifiers
name|Qs
init|=
name|Deduced
operator|.
name|getQualifiers
argument_list|()
decl_stmt|;
name|Qs
operator|.
name|removeObjCLifetime
argument_list|()
expr_stmt|;
name|Deduced
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedType
argument_list|(
name|Deduced
operator|.
name|getUnqualifiedType
argument_list|()
argument_list|,
name|Qs
argument_list|)
expr_stmt|;
name|Result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getAutoType
argument_list|(
name|Deduced
argument_list|,
name|AutoTy
operator|->
name|isDecltypeAuto
argument_list|()
argument_list|,
name|AutoTy
operator|->
name|isDependentType
argument_list|()
argument_list|)
expr_stmt|;
name|TLB
operator|.
name|TypeWasModifiedSafely
argument_list|(
name|Result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise, complain about the addition of a qualifier to an
comment|// already-qualified type.
name|SourceRange
name|R
init|=
name|T
operator|.
name|getUnqualifiedLoc
argument_list|()
operator|.
name|getSourceRange
argument_list|()
decl_stmt|;
name|SemaRef
operator|.
name|Diag
argument_list|(
name|R
operator|.
name|getBegin
argument_list|()
argument_list|,
name|diag
operator|::
name|err_attr_objc_ownership_redundant
argument_list|)
operator|<<
name|Result
operator|<<
name|R
expr_stmt|;
name|Quals
operator|.
name|removeObjCLifetime
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|Quals
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Result
operator|=
name|SemaRef
operator|.
name|BuildQualifiedType
argument_list|(
name|Result
argument_list|,
name|T
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|Quals
argument_list|)
expr_stmt|;
comment|// BuildQualifiedType might not add qualifiers if they are invalid.
if|if
condition|(
name|Result
operator|.
name|hasLocalQualifiers
argument_list|()
condition|)
name|TLB
operator|.
name|push
operator|<
name|QualifiedTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
comment|// No location information to preserve.
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TypeLoc
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeInObjectScope
argument_list|(
argument|TypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *UnqualLookup
argument_list|,
argument|CXXScopeSpec&SS
argument_list|)
block|{
name|QualType
name|T
operator|=
name|TL
operator|.
name|getType
argument_list|()
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|TL
return|;
name|TypeLocBuilder
name|TLB
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|Result
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|TemplateSpecializationType
operator|>
operator|(
name|T
operator|)
condition|)
block|{
name|TemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TL
operator|.
name|castAs
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|SS
argument_list|,
name|SpecTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getTemplateName
argument_list|()
argument_list|,
name|SpecTL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|UnqualLookup
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|TypeLoc
argument_list|()
return|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|SpecTL
argument_list|,
name|Template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isa
operator|<
name|DependentTemplateSpecializationType
operator|>
operator|(
name|T
operator|)
condition|)
block|{
name|DependentTemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TL
operator|.
name|castAs
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
operator|*
name|SpecTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|SpecTL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|UnqualLookup
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|TypeLoc
argument_list|()
return|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDependentTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|SpecTL
argument_list|,
name|Template
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Nothing special needs to be done for these.
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|TypeLoc
argument_list|()
return|;
end_if

begin_return
return|return
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Result
argument_list|)
operator|->
name|getTypeLoc
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TypeSourceInfo
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeInObjectScope
argument_list|(
argument|TypeSourceInfo *TSInfo
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *UnqualLookup
argument_list|,
argument|CXXScopeSpec&SS
argument_list|)
block|{
comment|// FIXME: Painfully copy-paste from the above!
name|QualType
name|T
operator|=
name|TSInfo
operator|->
name|getType
argument_list|()
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|TSInfo
return|;
name|TypeLocBuilder
name|TLB
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|Result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TypeLoc
name|TL
init|=
name|TSInfo
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|TemplateSpecializationType
operator|>
operator|(
name|T
operator|)
condition|)
block|{
name|TemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TL
operator|.
name|castAs
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|SS
argument_list|,
name|SpecTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getTemplateName
argument_list|()
argument_list|,
name|SpecTL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|UnqualLookup
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|SpecTL
argument_list|,
name|Template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isa
operator|<
name|DependentTemplateSpecializationType
operator|>
operator|(
name|T
operator|)
condition|)
block|{
name|DependentTemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TL
operator|.
name|castAs
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|SS
argument_list|,
operator|*
name|SpecTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|SpecTL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|UnqualLookup
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDependentTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|SpecTL
argument_list|,
name|Template
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Nothing special needs to be done for these.
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
end_if

begin_return
return|return
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Result
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|TyLoc
operator|>
specifier|static
specifier|inline
name|QualType
name|TransformTypeSpecType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TyLoc T
argument_list|)
block|{
name|TyLoc
name|NewT
operator|=
name|TLB
operator|.
name|push
operator|<
name|TyLoc
operator|>
operator|(
name|T
operator|.
name|getType
argument_list|()
operator|)
block|;
name|NewT
operator|.
name|setNameLoc
argument_list|(
name|T
operator|.
name|getNameLoc
argument_list|()
argument_list|)
block|;
return|return
name|T
operator|.
name|getType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBuiltinType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|BuiltinTypeLoc T
argument_list|)
block|{
name|BuiltinTypeLoc
name|NewT
operator|=
name|TLB
operator|.
name|push
operator|<
name|BuiltinTypeLoc
operator|>
operator|(
name|T
operator|.
name|getType
argument_list|()
operator|)
block|;
name|NewT
operator|.
name|setBuiltinLoc
argument_list|(
name|T
operator|.
name|getBuiltinLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|needsExtraLocalData
argument_list|()
condition|)
name|NewT
operator|.
name|getWrittenBuiltinSpecs
argument_list|()
operator|=
name|T
operator|.
name|getWrittenBuiltinSpecs
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|T
operator|.
name|getType
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformComplexType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ComplexTypeLoc T
argument_list|)
block|{
comment|// FIXME: recurse?
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDecayedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DecayedTypeLoc TL
argument_list|)
block|{
name|QualType
name|OriginalType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getOriginalLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|OriginalType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|OriginalType
operator|!=
name|TL
operator|.
name|getOriginalLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
name|Result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getDecayedType
argument_list|(
name|OriginalType
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|TLB
operator|.
name|push
operator|<
name|DecayedTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Nothing to set for DecayedTypeLoc.
end_comment

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|PointerTypeLoc TL
argument_list|)
block|{
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PointeeType
operator|->
name|getAs
operator|<
name|ObjCObjectType
operator|>
operator|(
operator|)
condition|)
block|{
comment|// A dependent pointer type 'T *' has is being transformed such
comment|// that an Objective-C class type is being replaced for 'T'. The
comment|// resulting pointer type is an ObjCObjectPointerType, not a
comment|// PointerType.
name|Result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getObjCObjectPointerType
argument_list|(
name|PointeeType
argument_list|)
expr_stmt|;
name|ObjCObjectPointerTypeLoc
name|NewT
init|=
name|TLB
operator|.
name|push
operator|<
name|ObjCObjectPointerTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewT
operator|.
name|setStarLoc
argument_list|(
name|TL
operator|.
name|getStarLoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_if

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|TL
operator|.
name|getPointeeLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPointerType
argument_list|(
name|PointeeType
argument_list|,
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Objective-C ARC can add lifetime qualifiers to the type that we're
end_comment

begin_comment
comment|// pointing to.
end_comment

begin_expr_stmt
name|TLB
operator|.
name|TypeWasModifiedSafely
argument_list|(
name|Result
operator|->
name|getPointeeType
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PointerTypeLoc
name|NewT
init|=
name|TLB
operator|.
name|push
operator|<
name|PointerTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewT
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBlockPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|BlockPointerTypeLoc TL
argument_list|)
block|{
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|TL
operator|.
name|getPointeeLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildBlockPointerType
argument_list|(
name|PointeeType
argument_list|,
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|BlockPointerTypeLoc
name|NewT
init|=
name|TLB
operator|.
name|push
operator|<
name|BlockPointerTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewT
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_comment
unit|}
comment|/// Transforms a reference type.  Note that somewhat paradoxically we
end_comment

begin_comment
comment|/// don't care whether the type itself is an l-value type or an r-value
end_comment

begin_comment
comment|/// type;  we only care if the type was *written* as an l-value type
end_comment

begin_comment
comment|/// or an r-value type.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ReferenceTypeLoc TL
argument_list|)
block|{
specifier|const
name|ReferenceType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// Note that this works with the pointee-as-written.
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|T
operator|->
name|getPointeeTypeAsWritten
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildReferenceType
argument_list|(
name|PointeeType
argument_list|,
name|T
operator|->
name|isSpelledAsLValue
argument_list|()
argument_list|,
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Objective-C ARC can add lifetime qualifiers to the type that we're
end_comment

begin_comment
comment|// referring to.
end_comment

begin_expr_stmt
name|TLB
operator|.
name|TypeWasModifiedSafely
argument_list|(
name|Result
operator|->
name|getAs
operator|<
name|ReferenceType
operator|>
operator|(
operator|)
operator|->
name|getPointeeTypeAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// r-value references can be rebuilt as l-value references.
end_comment

begin_decl_stmt
name|ReferenceTypeLoc
name|NewTL
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|LValueReferenceType
operator|>
operator|(
name|Result
operator|)
condition|)
name|NewTL
operator|=
name|TLB
operator|.
name|push
operator|<
name|LValueReferenceTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
else|else
name|NewTL
operator|=
name|TLB
operator|.
name|push
operator|<
name|RValueReferenceTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
end_if

begin_expr_stmt
name|NewTL
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLValueReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|LValueReferenceTypeLoc TL
argument_list|)
block|{
return|return
name|TransformReferenceType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformRValueReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|RValueReferenceTypeLoc TL
argument_list|)
block|{
return|return
name|TransformReferenceType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMemberPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|MemberPointerTypeLoc TL
argument_list|)
block|{
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|TypeSourceInfo
operator|*
name|OldClsTInfo
operator|=
name|TL
operator|.
name|getClassTInfo
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|NewClsTInfo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|OldClsTInfo
condition|)
block|{
name|NewClsTInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldClsTInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewClsTInfo
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
specifier|const
name|MemberPointerType
modifier|*
name|T
init|=
name|TL
operator|.
name|getTypePtr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|OldClsType
init|=
name|QualType
argument_list|(
name|T
operator|->
name|getClass
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|NewClsType
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NewClsTInfo
condition|)
name|NewClsType
operator|=
name|NewClsTInfo
operator|->
name|getType
argument_list|()
expr_stmt|;
else|else
block|{
name|NewClsType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldClsType
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewClsType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|T
operator|->
name|getPointeeType
argument_list|()
operator|||
name|NewClsType
operator|!=
name|OldClsType
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildMemberPointerType
argument_list|(
name|PointeeType
argument_list|,
name|NewClsType
argument_list|,
name|TL
operator|.
name|getStarLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|MemberPointerTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|MemberPointerTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setClassTInfo
argument_list|(
name|NewClsTInfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformConstantArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ConstantArrayTypeLoc TL
argument_list|)
block|{
specifier|const
name|ConstantArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildConstantArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|T
operator|->
name|getSize
argument_list|()
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We might have either a ConstantArrayType or a VariableArrayType now:
end_comment

begin_comment
comment|// a ConstantArrayType is allowed to have an element type which is a
end_comment

begin_comment
comment|// VariableArrayType if the type is dependent.  Fortunately, all array
end_comment

begin_comment
comment|// types have the same location layout.
end_comment

begin_decl_stmt
name|ArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Expr
modifier|*
name|Size
init|=
name|TL
operator|.
name|getSizeExpr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Size
condition|)
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|ConstantEvaluated
argument_list|)
decl_stmt|;
name|Size
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Size
argument_list|)
operator|.
name|template
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
expr_stmt|;
name|Size
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|Size
argument_list|)
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIncompleteArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|IncompleteArrayTypeLoc TL
argument_list|)
block|{
specifier|const
name|IncompleteArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildIncompleteArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|IncompleteArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|IncompleteArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVariableArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|VariableArrayTypeLoc TL
argument_list|)
block|{
specifier|const
name|VariableArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|ExprResult
name|SizeResult
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SizeResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|Expr
modifier|*
name|Size
init|=
name|SizeResult
operator|.
name|take
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|Size
operator|!=
name|T
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildVariableArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|Size
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We might have constant size array now, but fortunately it has the same
end_comment

begin_comment
comment|// location layout.
end_comment

begin_decl_stmt
name|ArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentSizedArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentSizedArrayTypeLoc TL
argument_list|)
block|{
specifier|const
name|DependentSizedArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Array bounds are constant expressions.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|ConstantEvaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Prefer the expression from the TypeLoc;  the other may have been uniqued.
end_comment

begin_decl_stmt
name|Expr
modifier|*
name|origSize
init|=
name|TL
operator|.
name|getSizeExpr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|origSize
condition|)
name|origSize
operator|=
name|T
operator|->
name|getSizeExpr
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|ExprResult
name|sizeResult
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|origSize
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|sizeResult
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|sizeResult
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|sizeResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|Expr
modifier|*
name|size
init|=
name|sizeResult
operator|.
name|get
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|size
operator|!=
name|origSize
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentSizedArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|size
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We might have any sort of array type now, but fortunately they
end_comment

begin_comment
comment|// all have the same location layout.
end_comment

begin_decl_stmt
name|ArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentSizedExtVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentSizedExtVectorTypeLoc TL
argument_list|)
block|{
specifier|const
name|DependentSizedExtVectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// FIXME: ext vector locs should be nested
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Vector sizes are constant expressions.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|ConstantEvaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ExprResult
name|Size
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Size
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Size
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|Size
operator|.
name|get
argument_list|()
operator|!=
name|T
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentSizedExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|Size
operator|.
name|take
argument_list|()
argument_list|,
name|T
operator|->
name|getAttributeLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Result might be dependent or not.
end_comment

begin_if
if|if
condition|(
name|isa
operator|<
name|DependentSizedExtVectorType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|DependentSizedExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentSizedExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|VectorTypeLoc TL
argument_list|)
block|{
specifier|const
name|VectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildVectorType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getNumElements
argument_list|()
argument_list|,
name|T
operator|->
name|getVectorKind
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|VectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|VectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExtVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ExtVectorTypeLoc TL
argument_list|)
block|{
specifier|const
name|VectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getNumElements
argument_list|()
argument_list|,
comment|/*FIXME*/
name|SourceLocation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ParmVarDecl
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionTypeParam
argument_list|(
argument|ParmVarDecl *OldParm
argument_list|,
argument|int indexAdjustment
argument_list|,
argument|Optional<unsigned> NumExpansions
argument_list|,
argument|bool ExpectParameterPack
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldDI
operator|=
name|OldParm
operator|->
name|getTypeSourceInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|NewDI
operator|=
literal|0
block|;
if|if
condition|(
name|NumExpansions
operator|&&
name|isa
operator|<
name|PackExpansionType
operator|>
operator|(
name|OldDI
operator|->
name|getType
argument_list|()
operator|)
condition|)
block|{
comment|// If we're substituting into a pack expansion type and we know the
comment|// length we want to expand to, just substitute for the pattern.
name|TypeLoc
name|OldTL
init|=
name|OldDI
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
name|PackExpansionTypeLoc
name|OldExpansionTL
init|=
name|OldTL
operator|.
name|castAs
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TypeLocBuilder
name|TLB
decl_stmt|;
name|TypeLoc
name|NewTL
init|=
name|OldDI
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
name|TLB
operator|.
name|reserve
argument_list|(
name|NewTL
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|OldExpansionTL
operator|.
name|getPatternLoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Result
operator|=
name|RebuildPackExpansionType
argument_list|(
name|Result
argument_list|,
name|OldExpansionTL
operator|.
name|getPatternLoc
argument_list|()
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|OldExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|PackExpansionTypeLoc
name|NewExpansionTL
init|=
name|TLB
operator|.
name|push
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewExpansionTL
operator|.
name|setEllipsisLoc
argument_list|(
name|OldExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewDI
operator|=
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Result
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|NewDI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldDI
argument_list|)
expr_stmt|;
end_else

begin_if
if|if
condition|(
operator|!
name|NewDI
condition|)
return|return
literal|0
return|;
end_if

begin_if
if|if
condition|(
name|NewDI
operator|==
name|OldDI
operator|&&
name|indexAdjustment
operator|==
literal|0
condition|)
return|return
name|OldParm
return|;
end_if

begin_decl_stmt
name|ParmVarDecl
modifier|*
name|newParm
init|=
name|ParmVarDecl
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|OldParm
operator|->
name|getDeclContext
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getInnerLocStart
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getLocation
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|NewDI
operator|->
name|getType
argument_list|()
argument_list|,
name|NewDI
argument_list|,
name|OldParm
operator|->
name|getStorageClass
argument_list|()
argument_list|,
comment|/* DefArg */
name|NULL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|newParm
operator|->
name|setScopeInfo
argument_list|(
name|OldParm
operator|->
name|getFunctionScopeDepth
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getFunctionScopeIndex
argument_list|()
operator|+
name|indexAdjustment
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|newParm
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionTypeParams
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|ParmVarDecl **Params
argument_list|,
argument|unsigned NumParams
argument_list|,
argument|const QualType *ParamTypes
argument_list|,
argument|SmallVectorImpl<QualType>&OutParamTypes
argument_list|,
argument|SmallVectorImpl<ParmVarDecl*> *PVars
argument_list|)
block|{
name|int
name|indexAdjustment
operator|=
literal|0
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|NumParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ParmVarDecl
modifier|*
name|OldParm
init|=
name|Params
index|[
name|i
index|]
condition|)
block|{
name|assert
argument_list|(
name|OldParm
operator|->
name|getFunctionScopeIndex
argument_list|()
operator|==
name|i
argument_list|)
expr_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
expr_stmt|;
name|ParmVarDecl
modifier|*
name|NewParm
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OldParm
operator|->
name|isParameterPack
argument_list|()
condition|)
block|{
comment|// We have a function parameter pack that may need to be expanded.
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
comment|// Find the parameter packs that could be expanded.
name|TypeLoc
name|TL
init|=
name|OldParm
operator|->
name|getTypeSourceInfo
argument_list|()
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
name|PackExpansionTypeLoc
name|ExpansionTL
init|=
name|TL
operator|.
name|castAs
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|TypeLoc
name|Pattern
init|=
name|ExpansionTL
operator|.
name|getPatternLoc
argument_list|()
decl_stmt|;
name|SemaRef
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|Pattern
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Unexpanded
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
literal|"Could not find parameter packs!"
argument_list|)
expr_stmt|;
comment|// Determine whether we should expand the parameter packs.
name|bool
name|ShouldExpand
init|=
name|false
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|OrigNumExpansions
operator|=
name|ExpansionTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getNumExpansions
argument_list|()
expr_stmt|;
name|NumExpansions
operator|=
name|OrigNumExpansions
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|Pattern
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|ShouldExpand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|ShouldExpand
condition|)
block|{
comment|// Expand the function parameter pack into multiple, separate
comment|// parameters.
name|getDerived
argument_list|()
operator|.
name|ExpandingFunctionParameterPack
argument_list|(
name|OldParm
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|ParmVarDecl
modifier|*
name|NewParm
init|=
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParam
argument_list|(
name|OldParm
argument_list|,
name|indexAdjustment
operator|++
argument_list|,
name|OrigNumExpansions
argument_list|,
comment|/*ExpectParameterPack=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NewParm
condition|)
return|return
name|true
return|;
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewParm
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
name|NewParm
argument_list|)
expr_stmt|;
block|}
comment|// If we're supposed to retain a pack expansion, do so by temporarily
comment|// forgetting the partially-substituted parameter pack.
if|if
condition|(
name|RetainExpansion
condition|)
block|{
name|ForgetPartiallySubstitutedPackRAII
name|Forget
argument_list|(
name|getDerived
argument_list|()
argument_list|)
decl_stmt|;
name|ParmVarDecl
modifier|*
name|NewParm
init|=
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParam
argument_list|(
name|OldParm
argument_list|,
name|indexAdjustment
operator|++
argument_list|,
name|OrigNumExpansions
argument_list|,
comment|/*ExpectParameterPack=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NewParm
condition|)
return|return
name|true
return|;
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewParm
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
name|NewParm
argument_list|)
expr_stmt|;
block|}
comment|// The next parameter should have the same adjustment as the
comment|// last thing we pushed, but we post-incremented indexAdjustment
comment|// on every push.  Also, if we push nothing, the adjustment should
comment|// go down by one.
name|indexAdjustment
operator|--
expr_stmt|;
comment|// We're done with the pack expansion.
continue|continue;
block|}
end_if

begin_comment
comment|// We'll substitute the parameter now without expanding the pack
end_comment

begin_comment
comment|// expansion.
end_comment

begin_expr_stmt
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewParm
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParam
argument_list|(
name|OldParm
argument_list|,
name|indexAdjustment
argument_list|,
name|NumExpansions
argument_list|,
comment|/*ExpectParameterPack=*/
name|true
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
unit|} else
block|{
name|NewParm
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParam
argument_list|(
name|OldParm
argument_list|,
name|indexAdjustment
argument_list|,
name|None
argument_list|,
comment|/*ExpectParameterPack=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|if
condition|(
operator|!
name|NewParm
condition|)
return|return
name|true
return|;
end_if

begin_expr_stmt
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewParm
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
name|NewParm
argument_list|)
expr_stmt|;
end_if

begin_continue
continue|continue;
end_continue

begin_comment
unit|}
comment|// Deal with the possibility that we don't have a parameter
end_comment

begin_comment
comment|// declaration for this parameter.
end_comment

begin_expr_stmt
unit|QualType
name|OldType
operator|=
name|ParamTypes
index|[
name|i
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|IsPackExpansion
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|NewType
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
specifier|const
name|PackExpansionType
modifier|*
name|Expansion
init|=
name|dyn_cast
operator|<
name|PackExpansionType
operator|>
operator|(
name|OldType
operator|)
condition|)
block|{
comment|// We have a function parameter pack that may need to be expanded.
name|QualType
name|Pattern
init|=
name|Expansion
operator|->
name|getPattern
argument_list|()
decl_stmt|;
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
name|getSema
argument_list|()
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|Pattern
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
comment|// Determine whether we should expand the parameter packs.
name|bool
name|ShouldExpand
init|=
name|false
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|Loc
argument_list|,
name|SourceRange
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|ShouldExpand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|ShouldExpand
condition|)
block|{
comment|// Expand the function parameter pack into multiple, separate
comment|// parameters.
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|QualType
name|NewType
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|NewType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewType
argument_list|)
expr_stmt|;
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// We're done with the pack expansion.
continue|continue;
block|}
comment|// If we're supposed to retain a pack expansion, do so by temporarily
comment|// forgetting the partially-substituted parameter pack.
if|if
condition|(
name|RetainExpansion
condition|)
block|{
name|ForgetPartiallySubstitutedPackRAII
name|Forget
argument_list|(
name|getDerived
argument_list|()
argument_list|)
decl_stmt|;
name|QualType
name|NewType
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|NewType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewType
argument_list|)
expr_stmt|;
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// We'll substitute the parameter now without expanding the pack
comment|// expansion.
name|OldType
operator|=
name|Expansion
operator|->
name|getPattern
argument_list|()
expr_stmt|;
name|IsPackExpansion
operator|=
name|true
expr_stmt|;
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NewType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NewType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldType
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|NewType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
end_if

begin_if
if|if
condition|(
name|IsPackExpansion
condition|)
name|NewType
operator|=
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|getPackExpansionType
argument_list|(
name|NewType
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|OutParamTypes
operator|.
name|push_back
argument_list|(
name|NewType
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PVars
condition|)
name|PVars
operator|->
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_expr_stmt
unit|if
operator|(
name|PVars
operator|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|PVars
operator|->
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ParmVarDecl
modifier|*
name|parm
init|=
operator|(
operator|*
name|PVars
operator|)
index|[
name|i
index|]
condition|)
name|assert
argument_list|(
name|parm
operator|->
name|getFunctionScopeIndex
argument_list|()
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionProtoTypeLoc TL
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformFunctionProtoType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionProtoTypeLoc TL
argument_list|,
argument|CXXRecordDecl *ThisContext
argument_list|,
argument|unsigned ThisTypeQuals
argument_list|)
block|{
comment|// Transform the parameters and return type.
comment|//
comment|// We are required to instantiate the params and return type in source order.
comment|// When the function has a trailing return type, we instantiate the
comment|// parameters before the return type,  since the return type can then refer
comment|// to the parameters themselves (via decltype, sizeof, etc.).
comment|//
name|SmallVector
operator|<
name|QualType
block|,
literal|4
operator|>
name|ParamTypes
block|;
name|SmallVector
operator|<
name|ParmVarDecl
operator|*
block|,
literal|4
operator|>
name|ParamDecls
block|;
specifier|const
name|FunctionProtoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ResultType
block|;
if|if
condition|(
name|T
operator|->
name|hasTrailingReturn
argument_list|()
condition|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParams
argument_list|(
name|TL
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|TL
operator|.
name|getParmArray
argument_list|()
argument_list|,
name|TL
operator|.
name|getNumArgs
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|arg_type_begin
argument_list|()
argument_list|,
name|ParamTypes
argument_list|,
operator|&
name|ParamDecls
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
block|{
comment|// C++11 [expr.prim.general]p3:
comment|//   If a declaration declares a member function or member function
comment|//   template of a class X, the expression this is a prvalue of type
comment|//   "pointer to cv-qualifier-seq X" between the optional cv-qualifer-seq
comment|//   and the end of the function-definition, member-declarator, or
comment|//   declarator.
name|Sema
operator|::
name|CXXThisScopeRAII
name|ThisScope
argument_list|(
name|SemaRef
argument_list|,
name|ThisContext
argument_list|,
name|ThisTypeQuals
argument_list|)
expr_stmt|;
name|ResultType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getResultLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResultType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_expr_stmt

begin_block
unit|}   else
block|{
name|ResultType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getResultLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResultType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParams
argument_list|(
name|TL
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|TL
operator|.
name|getParmArray
argument_list|()
argument_list|,
name|TL
operator|.
name|getNumArgs
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|arg_type_begin
argument_list|()
argument_list|,
name|ParamTypes
argument_list|,
operator|&
name|ParamDecls
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_block

begin_comment
comment|// FIXME: Need to transform the exception-specification too.
end_comment

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ResultType
operator|!=
name|T
operator|->
name|getResultType
argument_list|()
operator|||
name|T
operator|->
name|getNumArgs
argument_list|()
operator|!=
name|ParamTypes
operator|.
name|size
argument_list|()
operator|||
operator|!
name|std
operator|::
name|equal
argument_list|(
name|T
operator|->
name|arg_type_begin
argument_list|()
argument_list|,
name|T
operator|->
name|arg_type_end
argument_list|()
argument_list|,
name|ParamTypes
operator|.
name|begin
argument_list|()
argument_list|)
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildFunctionProtoType
argument_list|(
name|ResultType
argument_list|,
name|ParamTypes
argument_list|,
name|T
operator|->
name|getExtProtoInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|FunctionProtoTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|FunctionProtoTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLocalRangeBegin
argument_list|(
name|TL
operator|.
name|getLocalRangeBegin
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLocalRangeEnd
argument_list|(
name|TL
operator|.
name|getLocalRangeEnd
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTL
operator|.
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArg
argument_list|(
name|i
argument_list|,
name|ParamDecls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionNoProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionNoProtoTypeLoc TL
argument_list|)
block|{
specifier|const
name|FunctionNoProtoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ResultType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getResultLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ResultType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ResultType
operator|!=
name|T
operator|->
name|getResultType
argument_list|()
condition|)
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildFunctionNoProtoType
argument_list|(
name|ResultType
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|FunctionNoProtoTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|FunctionNoProtoTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLocalRangeBegin
argument_list|(
name|TL
operator|.
name|getLocalRangeBegin
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLocalRangeEnd
argument_list|(
name|TL
operator|.
name|getLocalRangeEnd
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedUsingType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|UnresolvedUsingTypeLoc TL
argument_list|)
block|{
specifier|const
name|UnresolvedUsingType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|Decl
operator|*
name|D
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|D
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildUnresolvedUsingType
argument_list|(
name|D
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We might get an arbitrary type spec type back.  We should at
end_comment

begin_comment
comment|// least always get a type spec type, though.
end_comment

begin_decl_stmt
name|TypeSpecTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|pushTypeSpec
argument_list|(
name|Result
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypedefType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypedefTypeLoc TL
argument_list|)
block|{
specifier|const
name|TypedefType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|TypedefNameDecl
operator|*
name|Typedef
operator|=
name|cast_or_null
operator|<
name|TypedefNameDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Typedef
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Typedef
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypedefType
argument_list|(
name|Typedef
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|TypedefTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypedefTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeOfExprType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeOfExprTypeLoc TL
argument_list|)
block|{
comment|// typeof expressions are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|,
name|Sema
operator|::
name|ReuseLambdaContextDecl
argument_list|)
block|;
name|ExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|TL
operator|.
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|E
operator|=
name|SemaRef
operator|.
name|HandleExprEvaluationContextForTypeof
argument_list|(
name|E
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|E
operator|.
name|get
argument_list|()
operator|!=
name|TL
operator|.
name|getUnderlyingExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypeOfExprType
argument_list|(
name|E
operator|.
name|get
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypeofLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|E
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|TypeOfExprTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypeOfExprTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setTypeofLoc
argument_list|(
name|TL
operator|.
name|getTypeofLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeOfType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeOfTypeLoc TL
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|Old_Under_TI
operator|=
name|TL
operator|.
name|getUnderlyingTInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|New_Under_TI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Old_Under_TI
argument_list|)
block|;
if|if
condition|(
operator|!
name|New_Under_TI
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|New_Under_TI
operator|!=
name|Old_Under_TI
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypeOfType
argument_list|(
name|New_Under_TI
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|TypeOfTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypeOfTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setTypeofLoc
argument_list|(
name|TL
operator|.
name|getTypeofLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setUnderlyingTInfo
argument_list|(
name|New_Under_TI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDecltypeType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DecltypeTypeLoc TL
argument_list|)
block|{
specifier|const
name|DecltypeType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// decltype expressions are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|,
literal|0
argument_list|,
comment|/*IsDecltype=*/
name|true
argument_list|)
block|;
name|ExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|E
operator|=
name|getSema
argument_list|()
operator|.
name|ActOnDecltypeExpression
argument_list|(
name|E
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|E
operator|.
name|get
argument_list|()
operator|!=
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDecltypeType
argument_list|(
name|E
operator|.
name|get
argument_list|()
argument_list|,
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|E
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|DecltypeTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DecltypeTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryTransformType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|UnaryTransformTypeLoc TL
argument_list|)
block|{
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
block|;
if|if
condition|(
name|Result
operator|->
name|isDependentType
argument_list|()
condition|)
block|{
specifier|const
name|UnaryTransformType
modifier|*
name|T
init|=
name|TL
operator|.
name|getTypePtr
argument_list|()
decl_stmt|;
name|QualType
name|NewBase
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TL
operator|.
name|getUnderlyingTInfo
argument_list|()
argument_list|)
operator|->
name|getType
argument_list|()
decl_stmt|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryTransformType
argument_list|(
name|NewBase
argument_list|,
name|T
operator|->
name|getUTTKind
argument_list|()
argument_list|,
name|TL
operator|.
name|getKWLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
name|UnaryTransformTypeLoc
name|NewTL
operator|=
name|TLB
operator|.
name|push
operator|<
name|UnaryTransformTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setKWLoc
argument_list|(
name|TL
operator|.
name|getKWLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setParensRange
argument_list|(
name|TL
operator|.
name|getParensRange
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setUnderlyingTInfo
argument_list|(
name|TL
operator|.
name|getUnderlyingTInfo
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAutoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|AutoTypeLoc TL
argument_list|)
block|{
specifier|const
name|AutoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|OldDeduced
operator|=
name|T
operator|->
name|getDeducedType
argument_list|()
block|;
name|QualType
name|NewDeduced
block|;
if|if
condition|(
operator|!
name|OldDeduced
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|NewDeduced
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldDeduced
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewDeduced
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|NewDeduced
operator|!=
name|OldDeduced
operator|||
name|T
operator|->
name|isDependentType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildAutoType
argument_list|(
name|NewDeduced
argument_list|,
name|T
operator|->
name|isDecltypeAuto
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|AutoTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|AutoTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformRecordType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|RecordTypeLoc TL
argument_list|)
block|{
specifier|const
name|RecordType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|RecordDecl
operator|*
name|Record
operator|=
name|cast_or_null
operator|<
name|RecordDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Record
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Record
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildRecordType
argument_list|(
name|Record
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|RecordTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|RecordTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformEnumType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|EnumTypeLoc TL
argument_list|)
block|{
specifier|const
name|EnumType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|EnumDecl
operator|*
name|Enum
operator|=
name|cast_or_null
operator|<
name|EnumDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Enum
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Enum
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildEnumType
argument_list|(
name|Enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|EnumTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|EnumTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformInjectedClassNameType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|InjectedClassNameTypeLoc TL
argument_list|)
block|{
name|Decl
operator|*
name|D
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|T
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|cast
operator|<
name|TypeDecl
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TLB
operator|.
name|pushTypeSpec
argument_list|(
name|T
argument_list|)
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|T
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateTypeParmType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateTypeParmTypeLoc TL
argument_list|)
block|{
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSubstTemplateTypeParmType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|SubstTemplateTypeParmTypeLoc TL
argument_list|)
block|{
specifier|const
name|SubstTemplateTypeParmType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// Substitute into the replacement type, which itself might involve something
comment|// that needs to be transformed. This only tends to occur with default
comment|// template arguments of template template parameters.
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|Replacement
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getReplacementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Replacement
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Always canonicalize the replacement type.
name|Replacement
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|Replacement
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getSubstTemplateTypeParmType
argument_list|(
name|T
operator|->
name|getReplacedParameter
argument_list|()
argument_list|,
name|Replacement
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Propagate type-source information.
end_comment

begin_decl_stmt
name|SubstTemplateTypeParmTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|SubstTemplateTypeParmTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSubstTemplateTypeParmPackType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|SubstTemplateTypeParmPackTypeLoc TL
argument_list|)
block|{
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateSpecializationTypeLoc TL
argument_list|)
block|{
specifier|const
name|TemplateSpecializationType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// The nested-name-specifier never matters in a TemplateSpecializationType,
comment|// because we can't have a dependent nested-name-specifier anyway.
name|CXXScopeSpec
name|SS
block|;
name|TemplateName
name|Template
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|SS
argument_list|,
name|T
operator|->
name|getTemplateName
argument_list|()
argument_list|,
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|TransformTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
name|Template
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAtomicType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|AtomicTypeLoc TL
argument_list|)
block|{
name|QualType
name|ValueType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getValueLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ValueType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ValueType
operator|!=
name|TL
operator|.
name|getValueLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildAtomicType
argument_list|(
name|ValueType
argument_list|,
name|TL
operator|.
name|getKWLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|AtomicTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|AtomicTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setKWLoc
argument_list|(
name|TL
operator|.
name|getKWLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_comment
unit|}
comment|/// \brief Simple iterator that traverses the template arguments in a
end_comment

begin_comment
comment|/// container that provides a \c getArgLoc() member function.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This iterator is intended to be used with the iterator form of
end_comment

begin_comment
comment|/// \c TreeTransform<Derived>::TransformTemplateArguments().
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|ArgLocContainer
operator|>
name|class
name|TemplateArgumentLocContainerIterator
block|{
name|ArgLocContainer
operator|*
name|Container
block|;
name|unsigned
name|Index
block|;
name|public
operator|:
typedef|typedef
name|TemplateArgumentLoc
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|TemplateArgumentLoc
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|input_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|pointer
block|{
name|TemplateArgumentLoc
name|Arg
decl_stmt|;
name|public
label|:
name|explicit
name|pointer
argument_list|(
argument|TemplateArgumentLoc Arg
argument_list|)
block|:
name|Arg
argument_list|(
argument|Arg
argument_list|)
block|{ }
specifier|const
name|TemplateArgumentLoc
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
operator|&
name|Arg
return|;
block|}
end_decl_stmt

begin_macro
unit|};
name|TemplateArgumentLocContainerIterator
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|TemplateArgumentLocContainerIterator
argument_list|(
argument|ArgLocContainer&Container
argument_list|,
argument|unsigned Index
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|Container
argument_list|(
operator|&
name|Container
argument_list|)
operator|,
name|Index
argument_list|(
argument|Index
argument_list|)
block|{ }
name|TemplateArgumentLocContainerIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Index
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TemplateArgumentLocContainerIterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|TemplateArgumentLocContainerIterator
name|Old
argument_list|(
operator|*
name|this
argument_list|)
block|;
operator|++
operator|(
operator|*
name|this
operator|)
block|;
return|return
name|Old
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|TemplateArgumentLoc
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|Container
operator|->
name|getArgLoc
argument_list|(
name|Index
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
name|pointer
argument_list|(
name|Container
operator|->
name|getArgLoc
argument_list|(
name|Index
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TemplateArgumentLocContainerIterator
operator|&
name|X
operator|,
specifier|const
name|TemplateArgumentLocContainerIterator
operator|&
name|Y
operator|)
block|{
return|return
name|X
operator|.
name|Container
operator|==
name|Y
operator|.
name|Container
operator|&&
name|X
operator|.
name|Index
operator|==
name|Y
operator|.
name|Index
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TemplateArgumentLocContainerIterator
operator|&
name|X
operator|,
specifier|const
name|TemplateArgumentLocContainerIterator
operator|&
name|Y
operator|)
block|{
return|return
operator|!
operator|(
name|X
operator|==
name|Y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateSpecializationTypeLoc TL
argument_list|,
argument|TemplateName Template
argument_list|)
block|{
name|TemplateArgumentListInfo
name|NewTemplateArgs
block|;
name|NewTemplateArgs
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
block|;
name|NewTemplateArgs
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
block|;
typedef|typedef
name|TemplateArgumentLocContainerIterator
operator|<
name|TemplateSpecializationTypeLoc
operator|>
name|ArgIterator
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|ArgIterator
argument_list|(
name|TL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ArgIterator
argument_list|(
name|TL
argument_list|,
name|TL
operator|.
name|getNumArgs
argument_list|()
argument_list|)
argument_list|,
name|NewTemplateArgs
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_comment
comment|// FIXME: maybe don't rebuild if all the template arguments are the same.
end_comment

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateSpecializationType
argument_list|(
name|Template
argument_list|,
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|NewTemplateArgs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Result
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Specializations of template template parameters are represented as
comment|// TemplateSpecializationTypes, and substitution of type alias templates
comment|// within a dependent context can transform them into
comment|// DependentTemplateSpecializationTypes.
if|if
condition|(
name|isa
operator|<
name|DependentTemplateSpecializationType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|DependentTemplateSpecializationTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|SourceLocation
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|NestedNameSpecifierLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|NewTemplateArgs
index|[
name|i
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
name|TemplateSpecializationTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|NewTemplateArgs
index|[
name|i
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentTemplateSpecializationTypeLoc TL
argument_list|,
argument|TemplateName Template
argument_list|,
argument|CXXScopeSpec&SS
argument_list|)
block|{
name|TemplateArgumentListInfo
name|NewTemplateArgs
block|;
name|NewTemplateArgs
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
block|;
name|NewTemplateArgs
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
block|;
typedef|typedef
name|TemplateArgumentLocContainerIterator
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
name|ArgIterator
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|ArgIterator
argument_list|(
name|TL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ArgIterator
argument_list|(
name|TL
argument_list|,
name|TL
operator|.
name|getNumArgs
argument_list|()
argument_list|)
argument_list|,
name|NewTemplateArgs
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_comment
comment|// FIXME: maybe don't rebuild if all the template arguments are the same.
end_comment

begin_if
if|if
condition|(
name|DependentTemplateName
modifier|*
name|DTN
init|=
name|Template
operator|.
name|getAsDependentTemplateName
argument_list|()
condition|)
block|{
name|QualType
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|getDependentTemplateSpecializationType
argument_list|(
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getKeyword
argument_list|()
argument_list|,
name|DTN
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|DTN
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|NewTemplateArgs
argument_list|)
decl_stmt|;
name|DependentTemplateSpecializationTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|SS
operator|.
name|getWithLocInContext
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|NewTemplateArgs
index|[
name|i
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateSpecializationType
argument_list|(
name|Template
argument_list|,
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|NewTemplateArgs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Result
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|/// FIXME: Wrap this in an elaborated-type-specifier?
name|TemplateSpecializationTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|NewTemplateArgs
index|[
name|i
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformElaboratedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ElaboratedTypeLoc TL
argument_list|)
block|{
specifier|const
name|ElaboratedType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|NestedNameSpecifierLoc
name|QualifierLoc
block|;
comment|// NOTE: the qualifier in an ElaboratedType is optional.
if|if
condition|(
name|TL
operator|.
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|TL
operator|.
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
name|QualType
name|NamedT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getNamedTypeLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|NamedT
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_comment
comment|// C++0x [dcl.type.elab]p2:
end_comment

begin_comment
comment|//   If the identifier resolves to a typedef-name or the simple-template-id
end_comment

begin_comment
comment|//   resolves to an alias template specialization, the
end_comment

begin_comment
comment|//   elaborated-type-specifier is ill-formed.
end_comment

begin_if
if|if
condition|(
name|T
operator|->
name|getKeyword
argument_list|()
operator|!=
name|ETK_None
operator|&&
name|T
operator|->
name|getKeyword
argument_list|()
operator|!=
name|ETK_Typename
condition|)
block|{
if|if
condition|(
specifier|const
name|TemplateSpecializationType
modifier|*
name|TST
init|=
name|NamedT
operator|->
name|getAs
operator|<
name|TemplateSpecializationType
operator|>
operator|(
operator|)
condition|)
block|{
name|TemplateName
name|Template
init|=
name|TST
operator|->
name|getTemplateName
argument_list|()
decl_stmt|;
if|if
condition|(
name|TypeAliasTemplateDecl
modifier|*
name|TAT
init|=
name|dyn_cast_or_null
operator|<
name|TypeAliasTemplateDecl
operator|>
operator|(
name|Template
operator|.
name|getAsTemplateDecl
argument_list|()
operator|)
condition|)
block|{
name|SemaRef
operator|.
name|Diag
argument_list|(
name|TL
operator|.
name|getNamedTypeLoc
argument_list|()
operator|.
name|getBeginLoc
argument_list|()
argument_list|,
name|diag
operator|::
name|err_tag_reference_non_tag
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|SemaRef
operator|.
name|Diag
argument_list|(
name|TAT
operator|->
name|getLocation
argument_list|()
argument_list|,
name|diag
operator|::
name|note_declared_at
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|QualifierLoc
operator|!=
name|TL
operator|.
name|getQualifierLoc
argument_list|()
operator|||
name|NamedT
operator|!=
name|T
operator|->
name|getNamedType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildElaboratedType
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getKeyword
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|NamedT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ElaboratedTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ElaboratedTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAttributedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|AttributedTypeLoc TL
argument_list|)
block|{
specifier|const
name|AttributedType
operator|*
name|oldType
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|modifiedType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getModifiedLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|modifiedType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// FIXME: dependent operand expressions?
end_comment

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|modifiedType
operator|!=
name|oldType
operator|->
name|getModifiedType
argument_list|()
condition|)
block|{
comment|// TODO: this is really lame; we should really be rebuilding the
comment|// equivalent type from first principles.
name|QualType
name|equivalentType
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|oldType
operator|->
name|getEquivalentType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivalentType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getAttributedType
argument_list|(
name|oldType
operator|->
name|getAttrKind
argument_list|()
argument_list|,
name|modifiedType
argument_list|,
name|equivalentType
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|AttributedTypeLoc
name|newTL
init|=
name|TLB
operator|.
name|push
operator|<
name|AttributedTypeLoc
operator|>
operator|(
name|result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|newTL
operator|.
name|setAttrNameLoc
argument_list|(
name|TL
operator|.
name|getAttrNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|TL
operator|.
name|hasAttrOperand
argument_list|()
condition|)
name|newTL
operator|.
name|setAttrOperandParensRange
argument_list|(
name|TL
operator|.
name|getAttrOperandParensRange
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|TL
operator|.
name|hasAttrExprOperand
argument_list|()
condition|)
name|newTL
operator|.
name|setAttrExprOperand
argument_list|(
name|TL
operator|.
name|getAttrExprOperand
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TL
operator|.
name|hasAttrEnumOperand
argument_list|()
condition|)
name|newTL
operator|.
name|setAttrEnumOperandLoc
argument_list|(
name|TL
operator|.
name|getAttrEnumOperandLoc
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformParenType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ParenTypeLoc TL
argument_list|)
block|{
name|QualType
name|Inner
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getInnerLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Inner
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Inner
operator|!=
name|TL
operator|.
name|getInnerLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildParenType
argument_list|(
name|Inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ParenTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ParenTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentNameType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentNameTypeLoc TL
argument_list|)
block|{
specifier|const
name|DependentNameType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|NestedNameSpecifierLoc
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|TL
operator|.
name|getQualifierLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentNameType
argument_list|(
name|T
operator|->
name|getKeyword
argument_list|()
argument_list|,
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|T
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
specifier|const
name|ElaboratedType
modifier|*
name|ElabT
init|=
name|Result
operator|->
name|getAs
operator|<
name|ElaboratedType
operator|>
operator|(
operator|)
condition|)
block|{
name|QualType
name|NamedT
init|=
name|ElabT
operator|->
name|getNamedType
argument_list|()
decl_stmt|;
name|TLB
operator|.
name|pushTypeSpec
argument_list|(
name|NamedT
argument_list|)
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|ElaboratedTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ElaboratedTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DependentNameTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentNameTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentTemplateSpecializationTypeLoc TL
argument_list|)
block|{
name|NestedNameSpecifierLoc
name|QualifierLoc
block|;
if|if
condition|(
name|TL
operator|.
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|TL
operator|.
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|TransformDependentTemplateSpecializationType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
name|QualifierLoc
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentTemplateSpecializationTypeLoc TL
argument_list|,
argument|NestedNameSpecifierLoc QualifierLoc
argument_list|)
block|{
specifier|const
name|DependentTemplateSpecializationType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|TemplateArgumentListInfo
name|NewTemplateArgs
block|;
name|NewTemplateArgs
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
block|;
name|NewTemplateArgs
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
block|;
typedef|typedef
name|TemplateArgumentLocContainerIterator
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
name|ArgIterator
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|ArgIterator
argument_list|(
name|TL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ArgIterator
argument_list|(
name|TL
argument_list|,
name|TL
operator|.
name|getNumArgs
argument_list|()
argument_list|)
argument_list|,
name|NewTemplateArgs
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentTemplateSpecializationType
argument_list|(
name|T
operator|->
name|getKeyword
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|T
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|NewTemplateArgs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
specifier|const
name|ElaboratedType
modifier|*
name|ElabT
init|=
name|dyn_cast
operator|<
name|ElaboratedType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|QualType
name|NamedT
init|=
name|ElabT
operator|->
name|getNamedType
argument_list|()
decl_stmt|;
comment|// Copy information relevant to the template specialization.
name|TemplateSpecializationTypeLoc
name|NamedTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|NamedT
operator|)
decl_stmt|;
name|NamedTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NamedTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NamedTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NamedTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|NamedTL
operator|.
name|setArgLocInfo
argument_list|(
name|I
argument_list|,
name|NewTemplateArgs
index|[
name|I
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy information relevant to the elaborated type.
name|ElaboratedTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ElaboratedTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setQualifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isa
operator|<
name|DependentTemplateSpecializationType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|DependentTemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentTemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|SpecTL
operator|.
name|setElaboratedKeywordLoc
argument_list|(
name|TL
operator|.
name|getElaboratedKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setQualifierLoc
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|SpecTL
operator|.
name|setArgLocInfo
argument_list|(
name|I
argument_list|,
name|NewTemplateArgs
index|[
name|I
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TemplateSpecializationTypeLoc
name|SpecTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|SpecTL
operator|.
name|setTemplateKeywordLoc
argument_list|(
name|TL
operator|.
name|getTemplateKeywordLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|SpecTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|SpecTL
operator|.
name|setArgLocInfo
argument_list|(
name|I
argument_list|,
name|NewTemplateArgs
index|[
name|I
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPackExpansionType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|PackExpansionTypeLoc TL
argument_list|)
block|{
name|QualType
name|Pattern
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPatternLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Pattern
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Pattern
operator|!=
name|TL
operator|.
name|getPatternLoc
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansionType
argument_list|(
name|Pattern
argument_list|,
name|TL
operator|.
name|getPatternLoc
argument_list|()
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|TL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getNumExpansions
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|PackExpansionTypeLoc
name|NewT
init|=
name|TLB
operator|.
name|push
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewT
operator|.
name|setEllipsisLoc
argument_list|(
name|TL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCInterfaceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ObjCInterfaceTypeLoc TL
argument_list|)
block|{
comment|// ObjCInterfaceType is never dependent.
name|TLB
operator|.
name|pushFullCopy
argument_list|(
name|TL
argument_list|)
block|;
return|return
name|TL
operator|.
name|getType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCObjectType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ObjCObjectTypeLoc TL
argument_list|)
block|{
comment|// ObjCObjectType is never dependent.
name|TLB
operator|.
name|pushFullCopy
argument_list|(
name|TL
argument_list|)
block|;
return|return
name|TL
operator|.
name|getType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCObjectPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ObjCObjectPointerTypeLoc TL
argument_list|)
block|{
comment|// ObjCObjectPointerType is never dependent.
name|TLB
operator|.
name|pushFullCopy
argument_list|(
name|TL
argument_list|)
block|;
return|return
name|TL
operator|.
name|getType
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Statement transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformNullStmt
argument_list|(
argument|NullStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundStmt
argument_list|(
argument|CompoundStmt *S
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
argument_list|,
name|false
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundStmt
argument_list|(
argument|CompoundStmt *S
argument_list|,
argument|bool IsStmtExpr
argument_list|)
block|{
name|Sema
operator|::
name|CompoundScopeRAII
name|CompoundScope
argument_list|(
name|getSema
argument_list|()
argument_list|)
block|;
name|bool
name|SubStmtInvalid
operator|=
name|false
block|;
name|bool
name|SubStmtChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Stmt
operator|*
block|,
literal|8
operator|>
name|Statements
block|;
for|for
control|(
name|CompoundStmt
operator|::
name|body_iterator
name|B
operator|=
name|S
operator|->
name|body_begin
argument_list|()
operator|,
name|BEnd
operator|=
name|S
operator|->
name|body_end
argument_list|()
init|;
name|B
operator|!=
name|BEnd
condition|;
operator|++
name|B
control|)
block|{
name|StmtResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
operator|*
name|B
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
comment|// Immediately fail if this was a DeclStmt, since it's very
comment|// likely that this will cause problems for future statements.
if|if
condition|(
name|isa
operator|<
name|DeclStmt
operator|>
operator|(
operator|*
name|B
operator|)
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Otherwise, just keep processing substatements and fail later.
name|SubStmtInvalid
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|SubStmtChanged
operator|=
name|SubStmtChanged
operator|||
name|Result
operator|.
name|get
argument_list|()
operator|!=
operator|*
name|B
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Statements
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|takeAs
operator|<
name|Stmt
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    if
operator|(
name|SubStmtInvalid
operator|)
end_expr_stmt

begin_return
return|return
name|StmtError
argument_list|()
return|;
end_return

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|SubStmtChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCompoundStmt
argument_list|(
name|S
operator|->
name|getLBracLoc
argument_list|()
argument_list|,
name|Statements
argument_list|,
name|S
operator|->
name|getRBracLoc
argument_list|()
argument_list|,
name|IsStmtExpr
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCaseStmt
argument_list|(
argument|CaseStmt *S
argument_list|)
block|{
name|ExprResult
name|LHS
block|,
name|RHS
block|;
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|ConstantEvaluated
argument_list|)
block|;
comment|// Transform the left-hand case value.
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
name|LHS
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|LHS
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the right-hand case value (for the GNU case-range extension).
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getRHS
argument_list|()
argument_list|)
block|;
name|RHS
operator|=
name|SemaRef
operator|.
name|ActOnConstantExpression
argument_list|(
name|RHS
argument_list|)
block|;
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Build the case statement.
end_comment

begin_comment
comment|// Case statements are always rebuilt so that they will attached to their
end_comment

begin_comment
comment|// transformed switch statement.
end_comment

begin_decl_stmt
name|StmtResult
name|Case
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildCaseStmt
argument_list|(
name|S
operator|->
name|getCaseLoc
argument_list|()
argument_list|,
name|LHS
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|RHS
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Case
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the statement following the case
end_comment

begin_decl_stmt
name|StmtResult
name|SubStmt
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Attach the body to the case statement
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCaseStmtBody
argument_list|(
name|Case
operator|.
name|get
argument_list|()
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDefaultStmt
argument_list|(
argument|DefaultStmt *S
argument_list|)
block|{
comment|// Transform the statement following the default case
name|StmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Default statements are always rebuilt
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDefaultStmt
argument_list|(
name|S
operator|->
name|getDefaultLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLabelStmt
argument_list|(
argument|LabelStmt *S
argument_list|)
block|{
name|StmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Decl
operator|*
name|LD
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|S
operator|->
name|getDecl
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getDecl
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|LD
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// FIXME: Pass the real colon location in.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildLabelStmt
argument_list|(
name|S
operator|->
name|getIdentLoc
argument_list|()
argument_list|,
name|cast
operator|<
name|LabelDecl
operator|>
operator|(
name|LD
operator|)
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAttributedStmt
argument_list|(
argument|AttributedStmt *S
argument_list|)
block|{
name|StmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// TODO: transform attributes
end_comment

begin_if
if|if
condition|(
name|SubStmt
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getSubStmt
argument_list|()
comment|/*&& attrs are the same */
condition|)
return|return
name|S
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildAttributedStmt
argument_list|(
name|S
operator|->
name|getAttrLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getAttrs
argument_list|()
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIfStmt
argument_list|(
argument|IfStmt *S
argument_list|)
block|{
comment|// Transform the condition
name|ExprResult
name|Cond
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Convert the condition to a boolean value.
if|if
condition|(
name|S
operator|->
name|getCond
argument_list|()
condition|)
block|{
name|ExprResult
name|CondE
init|=
name|getSema
argument_list|()
operator|.
name|ActOnBooleanCondition
argument_list|(
literal|0
argument_list|,
name|S
operator|->
name|getIfLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|CondE
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Cond
operator|=
name|CondE
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
operator|.
name|take
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|S
operator|->
name|getCond
argument_list|()
operator|&&
operator|!
name|FullCond
operator|.
name|get
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the "then" branch.
end_comment

begin_decl_stmt
name|StmtResult
name|Then
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getThen
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Then
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the "else" branch.
end_comment

begin_decl_stmt
name|StmtResult
name|Else
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getElse
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Else
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|FullCond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|ConditionVar
operator|==
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|Then
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getThen
argument_list|()
operator|&&
name|Else
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getElse
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildIfStmt
argument_list|(
name|S
operator|->
name|getIfLoc
argument_list|()
argument_list|,
name|FullCond
argument_list|,
name|ConditionVar
argument_list|,
name|Then
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getElseLoc
argument_list|()
argument_list|,
name|Else
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSwitchStmt
argument_list|(
argument|SwitchStmt *S
argument_list|)
block|{
comment|// Transform the condition.
name|ExprResult
name|Cond
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_else

begin_comment
comment|// Rebuild the switch statement.
end_comment

begin_decl_stmt
name|StmtResult
name|Switch
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildSwitchStmtStart
argument_list|(
name|S
operator|->
name|getSwitchLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|ConditionVar
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Switch
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body of the switch statement.
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Complete the switch statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSwitchStmtBody
argument_list|(
name|S
operator|->
name|getSwitchLoc
argument_list|()
argument_list|,
name|Switch
operator|.
name|get
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformWhileStmt
argument_list|(
argument|WhileStmt *S
argument_list|)
block|{
comment|// Transform the condition
name|ExprResult
name|Cond
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
if|if
condition|(
name|S
operator|->
name|getCond
argument_list|()
condition|)
block|{
comment|// Convert the condition to a boolean value.
name|ExprResult
name|CondE
init|=
name|getSema
argument_list|()
operator|.
name|ActOnBooleanCondition
argument_list|(
literal|0
argument_list|,
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|CondE
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Cond
operator|=
name|CondE
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
operator|.
name|take
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|S
operator|->
name|getCond
argument_list|()
operator|&&
operator|!
name|FullCond
operator|.
name|get
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|FullCond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|ConditionVar
operator|==
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildWhileStmt
argument_list|(
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
name|FullCond
argument_list|,
name|ConditionVar
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDoStmt
argument_list|(
argument|DoStmt *S
argument_list|)
block|{
comment|// Transform the body
name|StmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the condition
name|ExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDoStmt
argument_list|(
name|S
operator|->
name|getDoLoc
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformForStmt
argument_list|(
argument|ForStmt *S
argument_list|)
block|{
comment|// Transform the initialization statement
name|StmtResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getInit
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the condition
name|ExprResult
name|Cond
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|VarDecl
modifier|*
name|ConditionVar
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
if|if
condition|(
name|S
operator|->
name|getCond
argument_list|()
condition|)
block|{
comment|// Convert the condition to a boolean value.
name|ExprResult
name|CondE
init|=
name|getSema
argument_list|()
operator|.
name|ActOnBooleanCondition
argument_list|(
literal|0
argument_list|,
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|CondE
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Cond
operator|=
name|CondE
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
operator|.
name|take
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|S
operator|->
name|getCond
argument_list|()
operator|&&
operator|!
name|FullCond
operator|.
name|get
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the increment
end_comment

begin_decl_stmt
name|ExprResult
name|Inc
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getInc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Inc
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullInc
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullDiscardedValueExpr
argument_list|(
name|Inc
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|S
operator|->
name|getInc
argument_list|()
operator|&&
operator|!
name|FullInc
operator|.
name|get
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getInit
argument_list|()
operator|&&
name|FullCond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|Inc
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getInc
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildForStmt
argument_list|(
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|Init
operator|.
name|get
argument_list|()
argument_list|,
name|FullCond
argument_list|,
name|ConditionVar
argument_list|,
name|FullInc
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGotoStmt
argument_list|(
argument|GotoStmt *S
argument_list|)
block|{
name|Decl
operator|*
name|LD
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|S
operator|->
name|getLabel
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getLabel
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|LD
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Goto statements must always be rebuilt, to resolve the label.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildGotoStmt
argument_list|(
name|S
operator|->
name|getGotoLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLabelLoc
argument_list|()
argument_list|,
name|cast
operator|<
name|LabelDecl
operator|>
operator|(
name|LD
operator|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIndirectGotoStmt
argument_list|(
argument|IndirectGotoStmt *S
argument_list|)
block|{
name|ExprResult
name|Target
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getTarget
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Target
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Target
operator|=
name|SemaRef
operator|.
name|MaybeCreateExprWithCleanups
argument_list|(
name|Target
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Target
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTarget
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildIndirectGotoStmt
argument_list|(
name|S
operator|->
name|getGotoLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getStarLoc
argument_list|()
argument_list|,
name|Target
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformContinueStmt
argument_list|(
argument|ContinueStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBreakStmt
argument_list|(
argument|BreakStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformReturnStmt
argument_list|(
argument|ReturnStmt *S
argument_list|)
block|{
name|ExprResult
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getRetValue
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// FIXME: We always rebuild the return statement because there is no way
end_comment

begin_comment
comment|// to tell whether the return type of the function has changed.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildReturnStmt
argument_list|(
name|S
operator|->
name|getReturnLoc
argument_list|()
argument_list|,
name|Result
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclStmt
argument_list|(
argument|DeclStmt *S
argument_list|)
block|{
name|bool
name|DeclChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Decl
operator|*
block|,
literal|4
operator|>
name|Decls
block|;
for|for
control|(
name|DeclStmt
operator|::
name|decl_iterator
name|D
operator|=
name|S
operator|->
name|decl_begin
argument_list|()
operator|,
name|DEnd
operator|=
name|S
operator|->
name|decl_end
argument_list|()
init|;
name|D
operator|!=
name|DEnd
condition|;
operator|++
name|D
control|)
block|{
name|Decl
modifier|*
name|Transformed
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
operator|(
operator|*
name|D
operator|)
operator|->
name|getLocation
argument_list|()
argument_list|,
operator|*
name|D
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Transformed
condition|)
return|return
name|StmtError
argument_list|()
return|;
if|if
condition|(
name|Transformed
operator|!=
operator|*
name|D
condition|)
name|DeclChanged
operator|=
name|true
expr_stmt|;
name|Decls
operator|.
name|push_back
argument_list|(
name|Transformed
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|DeclChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclStmt
argument_list|(
name|Decls
argument_list|,
name|S
operator|->
name|getStartLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getEndLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGCCAsmStmt
argument_list|(
argument|GCCAsmStmt *S
argument_list|)
block|{
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|Constraints
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|Exprs
block|;
name|SmallVector
operator|<
name|IdentifierInfo
operator|*
block|,
literal|4
operator|>
name|Names
block|;
name|ExprResult
name|AsmString
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|Clobbers
block|;
name|bool
name|ExprsChanged
operator|=
name|false
block|;
comment|// Go through the outputs.
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumOutputs
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Names
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getOutputIdentifier
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// No need to transform the constraint literal.
name|Constraints
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getOutputConstraintLiteral
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// Transform the output expr.
name|Expr
modifier|*
name|OutputExpr
init|=
name|S
operator|->
name|getOutputExpr
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|ExprResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OutputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|ExprsChanged
operator||=
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|OutputExpr
expr_stmt|;
name|Exprs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Go through the inputs.
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumInputs
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Names
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getInputIdentifier
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// No need to transform the constraint literal.
name|Constraints
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getInputConstraintLiteral
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// Transform the input expr.
name|Expr
modifier|*
name|InputExpr
init|=
name|S
operator|->
name|getInputExpr
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|ExprResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|InputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|ExprsChanged
operator||=
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|InputExpr
expr_stmt|;
name|Exprs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ExprsChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Go through the clobbers.
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumClobbers
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|Clobbers
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getClobberStringLiteral
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// No need to transform the asm string literal.
end_comment

begin_expr_stmt
name|AsmString
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|getAsmString
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildGCCAsmStmt
argument_list|(
name|S
operator|->
name|getAsmLoc
argument_list|()
argument_list|,
name|S
operator|->
name|isSimple
argument_list|()
argument_list|,
name|S
operator|->
name|isVolatile
argument_list|()
argument_list|,
name|S
operator|->
name|getNumOutputs
argument_list|()
argument_list|,
name|S
operator|->
name|getNumInputs
argument_list|()
argument_list|,
name|Names
operator|.
name|data
argument_list|()
argument_list|,
name|Constraints
argument_list|,
name|Exprs
argument_list|,
name|AsmString
operator|.
name|get
argument_list|()
argument_list|,
name|Clobbers
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMSAsmStmt
argument_list|(
argument|MSAsmStmt *S
argument_list|)
block|{
name|ArrayRef
operator|<
name|Token
operator|>
name|AsmToks
operator|=
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|S
operator|->
name|getAsmToks
argument_list|()
argument_list|,
name|S
operator|->
name|getNumAsmToks
argument_list|()
argument_list|)
block|;
name|bool
name|HadError
operator|=
name|false
block|,
name|HadChange
operator|=
name|false
block|;
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|SrcExprs
operator|=
name|S
operator|->
name|getAllExprs
argument_list|()
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|TransformedExprs
block|;
name|TransformedExprs
operator|.
name|reserve
argument_list|(
name|SrcExprs
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|SrcExprs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|ExprResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|SrcExprs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Result
operator|.
name|isUsable
argument_list|()
condition|)
block|{
name|HadError
operator|=
name|true
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|HadChange
operator||=
operator|(
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|SrcExprs
index|[
name|i
index|]
operator|)
expr_stmt|;
name|TransformedExprs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}    if
operator|(
name|HadError
operator|)
end_expr_stmt

begin_return
return|return
name|StmtError
argument_list|()
return|;
end_return

begin_if
if|if
condition|(
operator|!
name|HadChange
operator|&&
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
condition|)
return|return
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildMSAsmStmt
argument_list|(
name|S
operator|->
name|getAsmLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLBraceLoc
argument_list|()
argument_list|,
name|AsmToks
argument_list|,
name|S
operator|->
name|getAsmString
argument_list|()
argument_list|,
name|S
operator|->
name|getNumOutputs
argument_list|()
argument_list|,
name|S
operator|->
name|getNumInputs
argument_list|()
argument_list|,
name|S
operator|->
name|getAllConstraints
argument_list|()
argument_list|,
name|S
operator|->
name|getClobbers
argument_list|()
argument_list|,
name|TransformedExprs
argument_list|,
name|S
operator|->
name|getEndLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtTryStmt
argument_list|(
argument|ObjCAtTryStmt *S
argument_list|)
block|{
comment|// Transform the body of the @try.
name|StmtResult
name|TryBody
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getTryBody
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|TryBody
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the @catch statements (if present).
name|bool
name|AnyCatchChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Stmt
operator|*
operator|,
literal|8
operator|>
name|CatchStmts
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|S
operator|->
name|getNumCatchStmts
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|StmtResult
name|Catch
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getCatchStmt
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Catch
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
if|if
condition|(
name|Catch
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getCatchStmt
argument_list|(
name|I
argument_list|)
condition|)
name|AnyCatchChanged
operator|=
name|true
expr_stmt|;
name|CatchStmts
operator|.
name|push_back
argument_list|(
name|Catch
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Transform the @finally statement (if present).
end_comment

begin_decl_stmt
name|StmtResult
name|Finally
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|S
operator|->
name|getFinallyStmt
argument_list|()
condition|)
block|{
name|Finally
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getFinallyStmt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Finally
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// If nothing changed, just retain this statement.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TryBody
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTryBody
argument_list|()
operator|&&
operator|!
name|AnyCatchChanged
operator|&&
name|Finally
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getFinallyStmt
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtTryStmt
argument_list|(
name|S
operator|->
name|getAtTryLoc
argument_list|()
argument_list|,
name|TryBody
operator|.
name|get
argument_list|()
argument_list|,
name|CatchStmts
argument_list|,
name|Finally
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtCatchStmt
argument_list|(
argument|ObjCAtCatchStmt *S
argument_list|)
block|{
comment|// Transform the @catch parameter, if there is one.
name|VarDecl
operator|*
name|Var
operator|=
literal|0
block|;
if|if
condition|(
name|VarDecl
modifier|*
name|FromVar
init|=
name|S
operator|->
name|getCatchParamDecl
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|TSInfo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FromVar
operator|->
name|getTypeSourceInfo
argument_list|()
condition|)
block|{
name|TSInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|FromVar
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TSInfo
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
name|QualType
name|T
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|TSInfo
condition|)
name|T
operator|=
name|TSInfo
operator|->
name|getType
argument_list|()
expr_stmt|;
else|else
block|{
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|FromVar
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_expr_stmt
name|Var
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildObjCExceptionDecl
argument_list|(
name|FromVar
argument_list|,
name|TSInfo
argument_list|,
name|T
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Var
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_expr_stmt
unit|}    StmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getCatchBody
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtCatchStmt
argument_list|(
name|S
operator|->
name|getAtCatchLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|Var
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtFinallyStmt
argument_list|(
argument|ObjCAtFinallyStmt *S
argument_list|)
block|{
comment|// Transform the body.
name|StmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getFinallyBody
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// If nothing changed, just retain this statement.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getFinallyBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtFinallyStmt
argument_list|(
name|S
operator|->
name|getAtFinallyLoc
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtThrowStmt
argument_list|(
argument|ObjCAtThrowStmt *S
argument_list|)
block|{
name|ExprResult
name|Operand
block|;
if|if
condition|(
name|S
operator|->
name|getThrowExpr
argument_list|()
condition|)
block|{
name|Operand
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getThrowExpr
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Operand
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Operand
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getThrowExpr
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtThrowStmt
argument_list|(
name|S
operator|->
name|getThrowLoc
argument_list|()
argument_list|,
name|Operand
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtSynchronizedStmt
argument_list|(
argument|ObjCAtSynchronizedStmt *S
argument_list|)
block|{
comment|// Transform the object we are locking.
name|ExprResult
name|Object
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getSynchExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Object
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Object
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtSynchronizedOperand
argument_list|(
name|S
operator|->
name|getAtSynchronizedLoc
argument_list|()
argument_list|,
name|Object
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Object
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body.
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSynchBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// If nothing change, just retain the current statement.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Object
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getSynchExpr
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getSynchBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAtSynchronizedStmt
argument_list|(
name|S
operator|->
name|getAtSynchronizedLoc
argument_list|()
argument_list|,
name|Object
operator|.
name|get
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAutoreleasePoolStmt
argument_list|(
argument|ObjCAutoreleasePoolStmt *S
argument_list|)
block|{
comment|// Transform the body.
name|StmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// If nothing changed, just retain this statement.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getSubStmt
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCAutoreleasePoolStmt
argument_list|(
name|S
operator|->
name|getAtLoc
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCForCollectionStmt
argument_list|(
argument|ObjCForCollectionStmt *S
argument_list|)
block|{
comment|// Transform the element statement.
name|StmtResult
name|Element
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getElement
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Element
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the collection expression.
name|ExprResult
name|Collection
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCollection
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Collection
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body.
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// If nothing changed, just retain this statement.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Element
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getElement
argument_list|()
operator|&&
name|Collection
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCollection
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCForCollectionStmt
argument_list|(
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|Element
operator|.
name|get
argument_list|()
argument_list|,
name|Collection
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXCatchStmt
argument_list|(
argument|CXXCatchStmt *S
argument_list|)
block|{
comment|// Transform the exception declaration, if any.
name|VarDecl
operator|*
name|Var
operator|=
literal|0
block|;
if|if
condition|(
name|VarDecl
modifier|*
name|ExceptionDecl
init|=
name|S
operator|->
name|getExceptionDecl
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|ExceptionDecl
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|Var
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildExceptionDecl
argument_list|(
name|ExceptionDecl
argument_list|,
name|T
argument_list|,
name|ExceptionDecl
operator|->
name|getInnerLocStart
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getLocation
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getIdentifier
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Var
operator|||
name|Var
operator|->
name|isInvalidDecl
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
comment|// Transform the actual exception handler.
name|StmtResult
name|Handler
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getHandlerBlock
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Handler
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|Var
operator|&&
name|Handler
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getHandlerBlock
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXCatchStmt
argument_list|(
name|S
operator|->
name|getCatchLoc
argument_list|()
argument_list|,
name|Var
argument_list|,
name|Handler
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTryStmt
argument_list|(
argument|CXXTryStmt *S
argument_list|)
block|{
comment|// Transform the try block itself.
name|StmtResult
name|TryBlock
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getTryBlock
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|TryBlock
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
comment|// Transform the handlers.
name|bool
name|HandlerChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Stmt
operator|*
operator|,
literal|8
operator|>
name|Handlers
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|S
operator|->
name|getNumHandlers
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|StmtResult
name|Handler
init|=
name|getDerived
argument_list|()
operator|.
name|TransformCXXCatchStmt
argument_list|(
name|S
operator|->
name|getHandler
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Handler
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|HandlerChanged
operator|=
name|HandlerChanged
operator|||
name|Handler
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getHandler
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|Handlers
operator|.
name|push_back
argument_list|(
name|Handler
operator|.
name|takeAs
operator|<
name|Stmt
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TryBlock
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTryBlock
argument_list|()
operator|&&
operator|!
name|HandlerChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTryStmt
argument_list|(
name|S
operator|->
name|getTryLoc
argument_list|()
argument_list|,
name|TryBlock
operator|.
name|get
argument_list|()
argument_list|,
name|Handlers
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXForRangeStmt
argument_list|(
argument|CXXForRangeStmt *S
argument_list|)
block|{
name|StmtResult
name|Range
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getRangeStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Range
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|StmtResult
name|BeginEnd
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBeginEndStmt
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|BeginEnd
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|Cond
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|Cond
operator|.
name|get
argument_list|()
condition|)
name|Cond
operator|=
name|SemaRef
operator|.
name|CheckBooleanCondition
argument_list|(
name|Cond
operator|.
name|take
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|Cond
operator|.
name|get
argument_list|()
condition|)
name|Cond
operator|=
name|SemaRef
operator|.
name|MaybeCreateExprWithCleanups
argument_list|(
name|Cond
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|ExprResult
name|Inc
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getInc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Inc
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|Inc
operator|.
name|get
argument_list|()
condition|)
name|Inc
operator|=
name|SemaRef
operator|.
name|MaybeCreateExprWithCleanups
argument_list|(
name|Inc
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|StmtResult
name|LoopVar
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getLoopVarStmt
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|LoopVar
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_decl_stmt
name|StmtResult
name|NewStmt
init|=
name|S
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Range
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getRangeStmt
argument_list|()
operator|||
name|BeginEnd
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getBeginEndStmt
argument_list|()
operator|||
name|Cond
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getCond
argument_list|()
operator|||
name|Inc
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getInc
argument_list|()
operator|||
name|LoopVar
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getLoopVarStmt
argument_list|()
condition|)
block|{
name|NewStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildCXXForRangeStmt
argument_list|(
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|Range
operator|.
name|get
argument_list|()
argument_list|,
name|BeginEnd
operator|.
name|get
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|Inc
operator|.
name|get
argument_list|()
argument_list|,
name|LoopVar
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Body has changed but we didn't rebuild the for-range statement. Rebuild
end_comment

begin_comment
comment|// it now so we have a new statement to attach the body to.
end_comment

begin_if
if|if
condition|(
name|Body
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getBody
argument_list|()
operator|&&
name|NewStmt
operator|.
name|get
argument_list|()
operator|==
name|S
condition|)
block|{
name|NewStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildCXXForRangeStmt
argument_list|(
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|Range
operator|.
name|get
argument_list|()
argument_list|,
name|BeginEnd
operator|.
name|get
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|Inc
operator|.
name|get
argument_list|()
argument_list|,
name|LoopVar
operator|.
name|get
argument_list|()
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
name|NewStmt
operator|.
name|get
argument_list|()
operator|==
name|S
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|FinishCXXForRangeStmt
argument_list|(
name|NewStmt
operator|.
name|get
argument_list|()
argument_list|,
name|Body
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMSDependentExistsStmt
argument_list|(
argument|MSDependentExistsStmt *S
argument_list|)
block|{
comment|// Transform the nested-name-specifier, if any.
name|NestedNameSpecifierLoc
name|QualifierLoc
block|;
if|if
condition|(
name|S
operator|->
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|S
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
comment|// Transform the declaration name.
name|DeclarationNameInfo
name|NameInfo
operator|=
name|S
operator|->
name|getNameInfo
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
block|{
name|NameInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationNameInfo
argument_list|(
name|NameInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Check whether anything changed.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|QualifierLoc
operator|==
name|S
operator|->
name|getQualifierLoc
argument_list|()
operator|&&
name|NameInfo
operator|.
name|getName
argument_list|()
operator|==
name|S
operator|->
name|getNameInfo
argument_list|()
operator|.
name|getName
argument_list|()
condition|)
return|return
name|S
return|;
end_if

begin_comment
comment|// Determine whether this name exists, if we can.
end_comment

begin_decl_stmt
name|CXXScopeSpec
name|SS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|Dependent
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_switch
switch|switch
condition|(
name|getSema
argument_list|()
operator|.
name|CheckMicrosoftIfExistsSymbol
argument_list|(
comment|/*S=*/
literal|0
argument_list|,
name|SS
argument_list|,
name|NameInfo
argument_list|)
condition|)
block|{
case|case
name|Sema
operator|::
name|IER_Exists
case|:
if|if
condition|(
name|S
operator|->
name|isIfExists
argument_list|()
condition|)
break|break;
return|return
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|NullStmt
argument_list|(
name|S
operator|->
name|getKeywordLoc
argument_list|()
argument_list|)
return|;
case|case
name|Sema
operator|::
name|IER_DoesNotExist
case|:
if|if
condition|(
name|S
operator|->
name|isIfNotExists
argument_list|()
condition|)
break|break;
return|return
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|NullStmt
argument_list|(
name|S
operator|->
name|getKeywordLoc
argument_list|()
argument_list|)
return|;
case|case
name|Sema
operator|::
name|IER_Dependent
case|:
name|Dependent
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|Sema
operator|::
name|IER_Error
case|:
return|return
name|StmtError
argument_list|()
return|;
block|}
end_switch

begin_comment
comment|// We need to continue with the instantiation, so do so now.
end_comment

begin_decl_stmt
name|StmtResult
name|SubStmt
init|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// If we have resolved the name, just transform to the substatement.
end_comment

begin_if
if|if
condition|(
operator|!
name|Dependent
condition|)
return|return
name|SubStmt
return|;
end_if

begin_comment
comment|// The name is still dependent, so build a dependent expression again.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildMSDependentExistsStmt
argument_list|(
name|S
operator|->
name|getKeywordLoc
argument_list|()
argument_list|,
name|S
operator|->
name|isIfExists
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|NameInfo
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMSPropertyRefExpr
argument_list|(
argument|MSPropertyRefExpr *E
argument_list|)
block|{
name|NestedNameSpecifierLoc
name|QualifierLoc
block|;
if|if
condition|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
name|MSPropertyDecl
operator|*
name|PD
operator|=
name|cast_or_null
operator|<
name|MSPropertyDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getPropertyDecl
argument_list|()
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|PD
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|Base
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBaseExpr
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_return
return|return
name|new
argument_list|(
argument|SemaRef.getASTContext()
argument_list|)
name|MSPropertyRefExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|PD
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|getASTContext
argument_list|()
operator|.
name|PseudoObjectTy
argument_list|,
name|VK_LValue
argument_list|,
name|QualifierLoc
argument_list|,
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSEHTryStmt
argument_list|(
argument|SEHTryStmt *S
argument_list|)
block|{
name|StmtResult
name|TryBlock
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getTryBlock
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|TryBlock
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|StmtResult
name|Handler
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformSEHHandler
argument_list|(
name|S
operator|->
name|getHandler
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Handler
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TryBlock
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTryBlock
argument_list|()
operator|&&
name|Handler
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getHandler
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSEHTryStmt
argument_list|(
name|S
operator|->
name|getIsCXXTry
argument_list|()
argument_list|,
name|S
operator|->
name|getTryLoc
argument_list|()
argument_list|,
name|TryBlock
operator|.
name|take
argument_list|()
argument_list|,
name|Handler
operator|.
name|take
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSEHFinallyStmt
argument_list|(
argument|SEHFinallyStmt *S
argument_list|)
block|{
name|StmtResult
name|Block
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getBlock
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Block
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSEHFinallyStmt
argument_list|(
name|S
operator|->
name|getFinallyLoc
argument_list|()
argument_list|,
name|Block
operator|.
name|take
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSEHExceptStmt
argument_list|(
argument|SEHExceptStmt *S
argument_list|)
block|{
name|ExprResult
name|FilterExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getFilterExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|FilterExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
name|StmtResult
name|Block
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Block
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|StmtError
argument_list|()
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSEHExceptStmt
argument_list|(
name|S
operator|->
name|getExceptLoc
argument_list|()
argument_list|,
name|FilterExpr
operator|.
name|take
argument_list|()
argument_list|,
name|Block
operator|.
name|take
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSEHHandler
argument_list|(
argument|Stmt *Handler
argument_list|)
block|{
if|if
condition|(
name|isa
operator|<
name|SEHFinallyStmt
operator|>
operator|(
name|Handler
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformSEHFinallyStmt
argument_list|(
name|cast
operator|<
name|SEHFinallyStmt
operator|>
operator|(
name|Handler
operator|)
argument_list|)
return|;
else|else
return|return
name|getDerived
argument_list|()
operator|.
name|TransformSEHExceptStmt
argument_list|(
name|cast
operator|<
name|SEHExceptStmt
operator|>
operator|(
name|Handler
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPParallelDirective
argument_list|(
argument|OMPParallelDirective *D
argument_list|)
block|{
name|DeclarationNameInfo
name|DirName
block|;
name|getSema
argument_list|()
operator|.
name|StartOpenMPDSABlock
argument_list|(
name|OMPD_parallel
argument_list|,
name|DirName
argument_list|,
literal|0
argument_list|)
block|;
comment|// Transform the clauses
name|llvm
operator|::
name|SmallVector
operator|<
name|OMPClause
operator|*
block|,
literal|16
operator|>
name|TClauses
block|;
name|ArrayRef
operator|<
name|OMPClause
operator|*
operator|>
name|Clauses
operator|=
name|D
operator|->
name|clauses
argument_list|()
block|;
name|TClauses
operator|.
name|reserve
argument_list|(
name|Clauses
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|ArrayRef
operator|<
name|OMPClause
operator|*
operator|>
operator|::
name|iterator
name|I
operator|=
name|Clauses
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Clauses
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
operator|*
name|I
condition|)
block|{
name|OMPClause
modifier|*
name|Clause
init|=
name|getDerived
argument_list|()
operator|.
name|TransformOMPClause
argument_list|(
operator|*
name|I
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Clause
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|EndOpenMPDSABlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|StmtError
argument_list|()
return|;
block|}
name|TClauses
operator|.
name|push_back
argument_list|(
name|Clause
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
unit|}     else
block|{
name|TClauses
operator|.
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}   if
operator|(
operator|!
name|D
operator|->
name|getAssociatedStmt
argument_list|()
operator|)
block|{
name|getSema
argument_list|()
operator|.
name|EndOpenMPDSABlock
argument_list|(
literal|0
argument_list|)
block|;
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|StmtResult
name|AssociatedStmt
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|D
operator|->
name|getAssociatedStmt
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|AssociatedStmt
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|EndOpenMPDSABlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|StmtResult
name|Res
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildOMPParallelDirective
argument_list|(
name|TClauses
argument_list|,
name|AssociatedStmt
operator|.
name|take
argument_list|()
argument_list|,
name|D
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|D
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|getSema
argument_list|()
operator|.
name|EndOpenMPDSABlock
argument_list|(
name|Res
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Res
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|OMPClause
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPDefaultClause
argument_list|(
argument|OMPDefaultClause *C
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildOMPDefaultClause
argument_list|(
name|C
operator|->
name|getDefaultKind
argument_list|()
argument_list|,
name|C
operator|->
name|getDefaultKindKwLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|C
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|OMPClause
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPPrivateClause
argument_list|(
argument|OMPPrivateClause *C
argument_list|)
block|{
name|llvm
operator|::
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|16
operator|>
name|Vars
block|;
name|Vars
operator|.
name|reserve
argument_list|(
name|C
operator|->
name|varlist_size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|OMPPrivateClause
operator|::
name|varlist_iterator
name|I
operator|=
name|C
operator|->
name|varlist_begin
argument_list|()
operator|,
name|E
operator|=
name|C
operator|->
name|varlist_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|ExprResult
name|EVar
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|cast
operator|<
name|Expr
operator|>
operator|(
operator|*
name|I
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVar
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
literal|0
return|;
name|Vars
operator|.
name|push_back
argument_list|(
name|EVar
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildOMPPrivateClause
argument_list|(
name|Vars
argument_list|,
name|C
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|C
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|OMPClause
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPFirstprivateClause
argument_list|(
argument|OMPFirstprivateClause *C
argument_list|)
block|{
name|llvm
operator|::
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|16
operator|>
name|Vars
block|;
name|Vars
operator|.
name|reserve
argument_list|(
name|C
operator|->
name|varlist_size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|OMPFirstprivateClause
operator|::
name|varlist_iterator
name|I
operator|=
name|C
operator|->
name|varlist_begin
argument_list|()
operator|,
name|E
operator|=
name|C
operator|->
name|varlist_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|ExprResult
name|EVar
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|cast
operator|<
name|Expr
operator|>
operator|(
operator|*
name|I
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVar
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
literal|0
return|;
name|Vars
operator|.
name|push_back
argument_list|(
name|EVar
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildOMPFirstprivateClause
argument_list|(
name|Vars
argument_list|,
name|C
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|C
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|OMPClause
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOMPSharedClause
argument_list|(
argument|OMPSharedClause *C
argument_list|)
block|{
name|llvm
operator|::
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|16
operator|>
name|Vars
block|;
name|Vars
operator|.
name|reserve
argument_list|(
name|C
operator|->
name|varlist_size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|OMPSharedClause
operator|::
name|varlist_iterator
name|I
operator|=
name|C
operator|->
name|varlist_begin
argument_list|()
operator|,
name|E
operator|=
name|C
operator|->
name|varlist_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|ExprResult
name|EVar
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|cast
operator|<
name|Expr
operator|>
operator|(
operator|*
name|I
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVar
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
literal|0
return|;
name|Vars
operator|.
name|push_back
argument_list|(
name|EVar
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildOMPSharedClause
argument_list|(
name|Vars
argument_list|,
name|C
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|C
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Expression transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPredefinedExpr
argument_list|(
argument|PredefinedExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclRefExpr
argument_list|(
argument|DeclRefExpr *E
argument_list|)
block|{
name|NestedNameSpecifierLoc
name|QualifierLoc
block|;
if|if
condition|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
name|ValueDecl
operator|*
name|ND
operator|=
name|cast_or_null
operator|<
name|ValueDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
name|E
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|ND
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|DeclarationNameInfo
name|NameInfo
init|=
name|E
operator|->
name|getNameInfo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
block|{
name|NameInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationNameInfo
argument_list|(
name|NameInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|QualifierLoc
operator|==
name|E
operator|->
name|getQualifierLoc
argument_list|()
operator|&&
name|ND
operator|==
name|E
operator|->
name|getDecl
argument_list|()
operator|&&
name|NameInfo
operator|.
name|getName
argument_list|()
operator|==
name|E
operator|->
name|getDecl
argument_list|()
operator|->
name|getDeclName
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
comment|// Mark it referenced in the new context regardless.
comment|// FIXME: this is a bit instantiation-specific.
name|SemaRef
operator|.
name|MarkDeclRefReferenced
argument_list|(
name|E
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|,
modifier|*
name|TemplateArgs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
name|TemplateArgs
operator|=
operator|&
name|TransArgs
expr_stmt|;
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclRefExpr
argument_list|(
name|QualifierLoc
argument_list|,
name|ND
argument_list|,
name|NameInfo
argument_list|,
name|TemplateArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIntegerLiteral
argument_list|(
argument|IntegerLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFloatingLiteral
argument_list|(
argument|FloatingLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImaginaryLiteral
argument_list|(
argument|ImaginaryLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStringLiteral
argument_list|(
argument|StringLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCharacterLiteral
argument_list|(
argument|CharacterLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUserDefinedLiteral
argument_list|(
argument|UserDefinedLiteral *E
argument_list|)
block|{
if|if
condition|(
name|FunctionDecl
modifier|*
name|FD
init|=
name|E
operator|->
name|getDirectCallee
argument_list|()
condition|)
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|FD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGenericSelectionExpr
argument_list|(
argument|GenericSelectionExpr *E
argument_list|)
block|{
name|ExprResult
name|ControllingExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getControllingExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ControllingExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|4
operator|>
name|AssocExprs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|TypeSourceInfo
operator|*
operator|,
literal|4
operator|>
name|AssocTypes
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|E
operator|->
name|getNumAssocs
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TypeSourceInfo
modifier|*
name|TS
init|=
name|E
operator|->
name|getAssocTypeSourceInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TS
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|AssocType
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|AssocType
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|AssocTypes
operator|.
name|push_back
argument_list|(
name|AssocType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AssocTypes
operator|.
name|push_back
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ExprResult
name|AssocExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getAssocExpr
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|AssocExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|AssocExprs
operator|.
name|push_back
argument_list|(
name|AssocExpr
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildGenericSelectionExpr
argument_list|(
name|E
operator|->
name|getGenericLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getDefaultLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|ControllingExpr
operator|.
name|release
argument_list|()
argument_list|,
name|AssocTypes
argument_list|,
name|AssocExprs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformParenExpr
argument_list|(
argument|ParenExpr *E
argument_list|)
block|{
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenExpr
argument_list|(
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getLParen
argument_list|()
argument_list|,
name|E
operator|->
name|getRParen
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief The operand of a unary address-of operator has special rules: it's
end_comment

begin_comment
comment|/// allowed to refer to a non-static member of a class even if there's no 'this'
end_comment

begin_comment
comment|/// object available.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAddressOfOperand
argument_list|(
argument|Expr *E
argument_list|)
block|{
if|if
condition|(
name|DependentScopeDeclRefExpr
modifier|*
name|DRE
init|=
name|dyn_cast
operator|<
name|DependentScopeDeclRefExpr
operator|>
operator|(
name|E
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformDependentScopeDeclRefExpr
argument_list|(
name|DRE
argument_list|,
name|true
argument_list|)
return|;
else|else
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryOperator
argument_list|(
argument|UnaryOperator *E
argument_list|)
block|{
name|ExprResult
name|SubExpr
block|;
if|if
condition|(
name|E
operator|->
name|getOpcode
argument_list|()
operator|==
name|UO_AddrOf
condition|)
name|SubExpr
operator|=
name|TransformAddressOfOperand
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|SubExpr
operator|=
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryOperator
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getOpcode
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOffsetOfExpr
argument_list|(
argument|OffsetOfExpr *E
argument_list|)
block|{
comment|// Transform the type.
name|TypeSourceInfo
operator|*
name|Type
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|Type
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform all of the components into components similar to what the
comment|// parser uses.
comment|// FIXME: It would be slightly more efficient in the non-dependent case to
comment|// just map FieldDecls, rather than requiring the rebuilder to look for
comment|// the fields again. However, __builtin_offsetof is rare enough in
comment|// template code that we don't care.
name|bool
name|ExprChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Sema
operator|::
name|OffsetOfComponent
name|Component
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|OffsetOfExpr
operator|::
name|OffsetOfNode
name|Node
expr_stmt|;
end_typedef

begin_expr_stmt
name|SmallVector
operator|<
name|Component
operator|,
literal|4
operator|>
name|Components
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumComponents
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
specifier|const
name|Node
modifier|&
name|ON
init|=
name|E
operator|->
name|getComponent
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|Component
name|Comp
decl_stmt|;
name|Comp
operator|.
name|isBrackets
operator|=
name|true
expr_stmt|;
name|Comp
operator|.
name|LocStart
operator|=
name|ON
operator|.
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
expr_stmt|;
name|Comp
operator|.
name|LocEnd
operator|=
name|ON
operator|.
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ON
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Array
case|:
block|{
name|Expr
modifier|*
name|FromIndex
init|=
name|E
operator|->
name|getIndexExpr
argument_list|(
name|ON
operator|.
name|getArrayExprIndex
argument_list|()
argument_list|)
decl_stmt|;
name|ExprResult
name|Index
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|FromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|Index
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprChanged
operator|=
name|ExprChanged
operator|||
name|Index
operator|.
name|get
argument_list|()
operator|!=
name|FromIndex
expr_stmt|;
name|Comp
operator|.
name|isBrackets
operator|=
name|true
expr_stmt|;
name|Comp
operator|.
name|U
operator|.
name|E
operator|=
name|Index
operator|.
name|get
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|Node
operator|::
name|Field
case|:
case|case
name|Node
operator|::
name|Identifier
case|:
name|Comp
operator|.
name|isBrackets
operator|=
name|false
expr_stmt|;
name|Comp
operator|.
name|U
operator|.
name|IdentInfo
operator|=
name|ON
operator|.
name|getFieldName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Comp
operator|.
name|U
operator|.
name|IdentInfo
condition|)
continue|continue;
break|break;
case|case
name|Node
operator|::
name|Base
case|:
comment|// Will be recomputed during the rebuild.
continue|continue;
block|}
name|Components
operator|.
name|push_back
argument_list|(
name|Comp
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// If nothing changed, retain the existing expression.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Type
operator|==
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
operator|&&
operator|!
name|ExprChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new offsetof expression.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildOffsetOfExpr
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Type
argument_list|,
name|Components
operator|.
name|data
argument_list|()
argument_list|,
name|Components
operator|.
name|size
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformOpaqueValueExpr
argument_list|(
argument|OpaqueValueExpr *E
argument_list|)
block|{
name|assert
argument_list|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
operator|&&
literal|"opaque value expression requires transformation"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPseudoObjectExpr
argument_list|(
argument|PseudoObjectExpr *E
argument_list|)
block|{
comment|// Rebuild the syntactic form.  The original syntactic form has
comment|// opaque-value expressions in it, so strip those away and rebuild
comment|// the result.  This is a really awful way of doing this, but the
comment|// better solution (rebuilding the semantic expressions and
comment|// rebinding OVEs as necessary) doesn't work; we'd need
comment|// TreeTransform to not strip away implicit conversions.
name|Expr
operator|*
name|newSyntacticForm
operator|=
name|SemaRef
operator|.
name|recreateSyntacticForm
argument_list|(
name|E
argument_list|)
block|;
name|ExprResult
name|result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|newSyntacticForm
argument_list|)
block|;
if|if
condition|(
name|result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// If that gives us a pseudo-object result back, the pseudo-object
end_comment

begin_comment
comment|// expression must have been an lvalue-to-rvalue conversion which we
end_comment

begin_comment
comment|// should reapply.
end_comment

begin_if
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|->
name|hasPlaceholderType
argument_list|(
name|BuiltinType
operator|::
name|PseudoObject
argument_list|)
condition|)
name|result
operator|=
name|SemaRef
operator|.
name|checkPseudoObjectRValue
argument_list|(
name|result
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryExprOrTypeTraitExpr
argument_list|(
argument|UnaryExprOrTypeTraitExpr *E
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|isArgumentType
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|OldT
init|=
name|E
operator|->
name|getArgumentTypeInfo
argument_list|()
decl_stmt|;
name|TypeSourceInfo
modifier|*
name|NewT
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryExprOrTypeTrait
argument_list|(
name|NewT
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getKind
argument_list|()
argument_list|,
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|)
return|;
block|}
comment|// C++0x [expr.sizeof]p1:
comment|//   The operand is either an expression, which is an unevaluated operand
comment|//   [...]
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|,
name|Sema
operator|::
name|ReuseLambdaContextDecl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ExprResult
name|SubExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArgumentExpr
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArgumentExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryExprOrTypeTrait
argument_list|(
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getKind
argument_list|()
argument_list|,
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformArraySubscriptExpr
argument_list|(
argument|ArraySubscriptExpr *E
argument_list|)
block|{
name|ExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArraySubscriptExpr
argument_list|(
name|LHS
operator|.
name|get
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLHS
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|RHS
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getRBracketLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCallExpr
argument_list|(
argument|CallExpr *E
argument_list|)
block|{
comment|// Transform the callee.
name|ExprResult
name|Callee
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCallee
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Callee
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform arguments.
name|bool
name|ArgChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Callee
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCallee
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Wrong source location information for the '('.
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeLParenLoc
init|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Callee
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCallExpr
argument_list|(
name|Callee
operator|.
name|get
argument_list|()
argument_list|,
name|FakeLParenLoc
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMemberExpr
argument_list|(
argument|MemberExpr *E
argument_list|)
block|{
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|NestedNameSpecifierLoc
name|QualifierLoc
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasQualifier
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|SourceLocation
name|TemplateKWLoc
init|=
name|E
operator|->
name|getTemplateKeywordLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ValueDecl
modifier|*
name|Member
init|=
name|cast_or_null
operator|<
name|ValueDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getMemberDecl
argument_list|()
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Member
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|NamedDecl
modifier|*
name|FoundDecl
init|=
name|E
operator|->
name|getFoundDecl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|FoundDecl
operator|==
name|E
operator|->
name|getMemberDecl
argument_list|()
condition|)
block|{
name|FoundDecl
operator|=
name|Member
expr_stmt|;
block|}
else|else
block|{
name|FoundDecl
operator|=
name|cast_or_null
operator|<
name|NamedDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|FoundDecl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|FoundDecl
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
operator|&&
name|QualifierLoc
operator|==
name|E
operator|->
name|getQualifierLoc
argument_list|()
operator|&&
name|Member
operator|==
name|E
operator|->
name|getMemberDecl
argument_list|()
operator|&&
name|FoundDecl
operator|==
name|E
operator|->
name|getFoundDecl
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
comment|// Mark it referenced in the new context regardless.
comment|// FIXME: this is a bit instantiation-specific.
name|SemaRef
operator|.
name|MarkMemberReferenced
argument_list|(
name|E
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// FIXME: Bogus source location for the operator
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeOperatorLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: to do this check properly, we will need to preserve the
end_comment

begin_comment
comment|// first-qualifier-in-scope here, just in case we had a dependent
end_comment

begin_comment
comment|// base (and therefore couldn't do the check) and a
end_comment

begin_comment
comment|// nested-name-qualifier (and therefore could do the lookup).
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildMemberExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|FakeOperatorLoc
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|E
operator|->
name|getMemberNameInfo
argument_list|()
argument_list|,
name|Member
argument_list|,
name|FoundDecl
argument_list|,
operator|(
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|?
operator|&
name|TransArgs
else|:
literal|0
operator|)
argument_list|,
name|FirstQualifierInScope
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBinaryOperator
argument_list|(
argument|BinaryOperator *E
argument_list|)
block|{
name|ExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_expr_stmt
name|Sema
operator|::
name|FPContractStateRAII
name|FPContractState
argument_list|(
name|getSema
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getSema
argument_list|()
operator|.
name|FPFeatures
operator|.
name|fp_contract
operator|=
name|E
operator|->
name|isFPContractable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildBinaryOperator
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getOpcode
argument_list|()
argument_list|,
name|LHS
operator|.
name|get
argument_list|()
argument_list|,
name|RHS
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundAssignOperator
argument_list|(
argument|CompoundAssignOperator *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformBinaryOperator
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBinaryConditionalOperator
argument_list|(
argument|BinaryConditionalOperator *e
argument_list|)
block|{
comment|// Just rebuild the common and RHS expressions and see whether we
comment|// get any changes.
name|ExprResult
name|commonExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|e
operator|->
name|getCommon
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|commonExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|rhs
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|e
operator|->
name|getFalseExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rhs
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|commonExpr
operator|.
name|get
argument_list|()
operator|==
name|e
operator|->
name|getCommon
argument_list|()
operator|&&
name|rhs
operator|.
name|get
argument_list|()
operator|==
name|e
operator|->
name|getFalseExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|e
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildConditionalOperator
argument_list|(
name|commonExpr
operator|.
name|take
argument_list|()
argument_list|,
name|e
operator|->
name|getQuestionLoc
argument_list|()
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|rhs
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformConditionalOperator
argument_list|(
argument|ConditionalOperator *E
argument_list|)
block|{
name|ExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCond
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|RHS
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCond
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildConditionalOperator
argument_list|(
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getQuestionLoc
argument_list|()
argument_list|,
name|LHS
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|RHS
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImplicitCastExpr
argument_list|(
argument|ImplicitCastExpr *E
argument_list|)
block|{
comment|// Implicit casts are eliminated during transformation, since they
comment|// will be recomputed by semantic analysis after transformation.
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCStyleCastExpr
argument_list|(
argument|CStyleCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|Type
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|Type
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Type
operator|==
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCStyleCastExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|Type
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundLiteralExpr
argument_list|(
argument|CompoundLiteralExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldT
operator|=
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|NewT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInitializer
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getInitializer
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// Note: the expression type doesn't necessarily match the
end_comment

begin_comment
comment|// type-as-written, but that's okay, because it should always be
end_comment

begin_comment
comment|// derivable from the initializer.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCompoundLiteralExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|NewT
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getInitializer
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|,
name|Init
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExtVectorElementExpr
argument_list|(
argument|ExtVectorElementExpr *E
argument_list|)
block|{
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Bad source location
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeOperatorLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildExtVectorElementExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|FakeOperatorLoc
argument_list|,
name|E
operator|->
name|getAccessorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getAccessor
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformInitListExpr
argument_list|(
argument|InitListExpr *E
argument_list|)
block|{
name|bool
name|InitChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|4
operator|>
name|Inits
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getInits
argument_list|()
argument_list|,
name|E
operator|->
name|getNumInits
argument_list|()
argument_list|,
name|false
argument_list|,
name|Inits
argument_list|,
operator|&
name|InitChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|InitChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildInitList
argument_list|(
name|E
operator|->
name|getLBraceLoc
argument_list|()
argument_list|,
name|Inits
argument_list|,
name|E
operator|->
name|getRBraceLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getType
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDesignatedInitExpr
argument_list|(
argument|DesignatedInitExpr *E
argument_list|)
block|{
name|Designation
name|Desig
block|;
comment|// transform the initializer value
name|ExprResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInit
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// transform the designators.
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|4
operator|>
name|ArrayExprs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|ExprChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|DesignatedInitExpr
operator|::
name|designators_iterator
name|D
operator|=
name|E
operator|->
name|designators_begin
argument_list|()
operator|,
name|DEnd
operator|=
name|E
operator|->
name|designators_end
argument_list|()
init|;
name|D
operator|!=
name|DEnd
condition|;
operator|++
name|D
control|)
block|{
if|if
condition|(
name|D
operator|->
name|isFieldDesignator
argument_list|()
condition|)
block|{
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getField
argument_list|(
name|D
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|D
operator|->
name|getDotLoc
argument_list|()
argument_list|,
name|D
operator|->
name|getFieldLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|D
operator|->
name|isArrayDesignator
argument_list|()
condition|)
block|{
name|ExprResult
name|Index
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayIndex
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Index
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getArray
argument_list|(
name|Index
operator|.
name|get
argument_list|()
argument_list|,
name|D
operator|->
name|getLBracketLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ExprChanged
operator|=
name|ExprChanged
operator|||
name|Init
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayIndex
argument_list|(
operator|*
name|D
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|Index
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assert
argument_list|(
name|D
operator|->
name|isArrayRangeDesignator
argument_list|()
operator|&&
literal|"New kind of designator?"
argument_list|)
expr_stmt|;
name|ExprResult
name|Start
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayRangeStart
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Start
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|End
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayRangeEnd
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|End
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getArrayRange
argument_list|(
name|Start
operator|.
name|get
argument_list|()
argument_list|,
name|End
operator|.
name|get
argument_list|()
argument_list|,
name|D
operator|->
name|getLBracketLoc
argument_list|()
argument_list|,
name|D
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ExprChanged
operator|=
name|ExprChanged
operator|||
name|Start
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayRangeStart
argument_list|(
operator|*
name|D
argument_list|)
operator|||
name|End
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayRangeEnd
argument_list|(
operator|*
name|D
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|Start
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|End
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getInit
argument_list|()
operator|&&
operator|!
name|ExprChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDesignatedInitExpr
argument_list|(
name|Desig
argument_list|,
name|ArrayExprs
argument_list|,
name|E
operator|->
name|getEqualOrColonLoc
argument_list|()
argument_list|,
name|E
operator|->
name|usesGNUSyntax
argument_list|()
argument_list|,
name|Init
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImplicitValueInitExpr
argument_list|(
argument|ImplicitValueInitExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
comment|// FIXME: Will we ever have proper type location here? Will we actually
comment|// need to transform the type?
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildImplicitValueInitExpr
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVAArgExpr
argument_list|(
argument|VAArgExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|TInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getWrittenTypeInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|TInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TInfo
operator|==
name|E
operator|->
name|getWrittenTypeInfo
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildVAArgExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|TInfo
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformParenListExpr
argument_list|(
argument|ParenListExpr *E
argument_list|)
block|{
name|bool
name|ArgumentChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|4
operator|>
name|Inits
block|;
if|if
condition|(
name|TransformExprs
argument_list|(
name|E
operator|->
name|getExprs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumExprs
argument_list|()
argument_list|,
name|true
argument_list|,
name|Inits
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenListExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|Inits
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief Transform an address-of-label expression.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// By default, the transformation of an address-of-label expression always
end_comment

begin_comment
comment|/// rebuilds the expression, so that the label identifier can be resolved to
end_comment

begin_comment
comment|/// the corresponding label statement by semantic analysis.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAddrLabelExpr
argument_list|(
argument|AddrLabelExpr *E
argument_list|)
block|{
name|Decl
operator|*
name|LD
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLabel
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|E
operator|->
name|getLabel
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|LD
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildAddrLabelExpr
argument_list|(
name|E
operator|->
name|getAmpAmpLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getLabelLoc
argument_list|()
argument_list|,
name|cast
operator|<
name|LabelDecl
operator|>
operator|(
name|LD
operator|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStmtExpr
argument_list|(
argument|StmtExpr *E
argument_list|)
block|{
name|SemaRef
operator|.
name|ActOnStartStmtExpr
argument_list|()
block|;
name|StmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|E
operator|->
name|getSubStmt
argument_list|()
argument_list|,
name|true
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|SemaRef
operator|.
name|ActOnStmtExprError
argument_list|()
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubStmt
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubStmt
argument_list|()
condition|)
block|{
comment|// Calling this an 'error' is unintuitive, but it does the right thing.
name|SemaRef
operator|.
name|ActOnStmtExprError
argument_list|()
expr_stmt|;
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildStmtExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|SubStmt
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformChooseExpr
argument_list|(
argument|ChooseExpr *E
argument_list|)
block|{
name|ExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCond
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|RHS
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCond
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildChooseExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|Cond
operator|.
name|get
argument_list|()
argument_list|,
name|LHS
operator|.
name|get
argument_list|()
argument_list|,
name|RHS
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGNUNullExpr
argument_list|(
argument|GNUNullExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXOperatorCallExpr
argument_list|(
argument|CXXOperatorCallExpr *E
argument_list|)
block|{
switch|switch
condition|(
name|E
operator|->
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|OO_New
case|:
case|case
name|OO_Delete
case|:
case|case
name|OO_Array_New
case|:
case|case
name|OO_Array_Delete
case|:
name|llvm_unreachable
argument_list|(
literal|"new and delete operators cannot use CXXOperatorCallExpr"
argument_list|)
expr_stmt|;
case|case
name|OO_Call
case|:
block|{
comment|// This is a call to an object's operator().
name|assert
argument_list|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|>=
literal|1
operator|&&
literal|"Object call is missing arguments"
argument_list|)
expr_stmt|;
comment|// Transform the object itself.
name|ExprResult
name|Object
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Object
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// FIXME: Poor location information
name|SourceLocation
name|FakeLParenLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|static_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Object
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
comment|// Transform the call arguments.
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
operator|+
literal|1
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
operator|-
literal|1
argument_list|,
name|true
argument_list|,
name|Args
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCallExpr
argument_list|(
name|Object
operator|.
name|get
argument_list|()
argument_list|,
name|FakeLParenLoc
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|OVERLOADED_OPERATOR
parameter_list|(
name|Name
parameter_list|,
name|Spelling
parameter_list|,
name|Token
parameter_list|,
name|Unary
parameter_list|,
name|Binary
parameter_list|,
name|MemberOnly
parameter_list|)
define|\
value|case OO_##Name:
end_define

begin_define
define|#
directive|define
name|OVERLOADED_OPERATOR_MULTI
parameter_list|(
name|Name
parameter_list|,
name|Spelling
parameter_list|,
name|Unary
parameter_list|,
name|Binary
parameter_list|,
name|MemberOnly
parameter_list|)
end_define

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.def"
end_include

begin_case
case|case
name|OO_Subscript
case|:
end_case

begin_comment
comment|// Handled below.
end_comment

begin_break
break|break;
end_break

begin_case
case|case
name|OO_Conditional
case|:
end_case

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"conditional operator is not actually overloadable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_case
case|case
name|OO_None
case|:
end_case

begin_case
case|case
name|NUM_OVERLOADED_OPERATORS
case|:
end_case

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"not an overloaded operator?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    ExprResult
name|Callee
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCallee
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Callee
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|First
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperator
argument_list|()
operator|==
name|OO_Amp
condition|)
name|First
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformAddressOfOperand
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|First
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|First
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|ExprResult
name|Second
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|==
literal|2
condition|)
block|{
name|Second
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Second
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Callee
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCallee
argument_list|()
operator|&&
name|First
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|!=
literal|2
operator|||
name|Second
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_expr_stmt
name|Sema
operator|::
name|FPContractStateRAII
name|FPContractState
argument_list|(
name|getSema
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getSema
argument_list|()
operator|.
name|FPFeatures
operator|.
name|fp_contract
operator|=
name|E
operator|->
name|isFPContractable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXOperatorCallExpr
argument_list|(
name|E
operator|->
name|getOperator
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Callee
operator|.
name|get
argument_list|()
argument_list|,
name|First
operator|.
name|get
argument_list|()
argument_list|,
name|Second
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXMemberCallExpr
argument_list|(
argument|CXXMemberCallExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCallExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCUDAKernelCallExpr
argument_list|(
argument|CUDAKernelCallExpr *E
argument_list|)
block|{
comment|// Transform the callee.
name|ExprResult
name|Callee
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCallee
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Callee
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform exec config.
name|ExprResult
name|EC
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCallExpr
argument_list|(
name|E
operator|->
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|EC
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform arguments.
end_comment

begin_decl_stmt
name|bool
name|ArgChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Callee
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCallee
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Wrong source location information for the '('.
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeLParenLoc
init|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Callee
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCallExpr
argument_list|(
name|Callee
operator|.
name|get
argument_list|()
argument_list|,
name|FakeLParenLoc
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|EC
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNamedCastExpr
argument_list|(
argument|CXXNamedCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|Type
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|Type
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Type
operator|==
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXNamedCastExpr
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getStmtClass
argument_list|()
argument_list|,
name|E
operator|->
name|getAngleBrackets
argument_list|()
operator|.
name|getBegin
argument_list|()
argument_list|,
name|Type
argument_list|,
name|E
operator|->
name|getAngleBrackets
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|,
comment|// FIXME. this should be '(' location
name|E
operator|->
name|getAngleBrackets
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXStaticCastExpr
argument_list|(
argument|CXXStaticCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDynamicCastExpr
argument_list|(
argument|CXXDynamicCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXReinterpretCastExpr
argument_list|(
argument|CXXReinterpretCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXConstCastExpr
argument_list|(
argument|CXXConstCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXFunctionalCastExpr
argument_list|(
argument|CXXFunctionalCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|Type
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|Type
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Type
operator|==
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXFunctionalCastExpr
argument_list|(
name|Type
argument_list|,
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTypeidExpr
argument_list|(
argument|CXXTypeidExpr *E
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|isTypeOperand
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|TInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeOperandSourceInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TInfo
operator|==
name|E
operator|->
name|getTypeOperandSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTypeidExpr
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|TInfo
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
comment|// We don't know whether the subexpression is potentially evaluated until
comment|// after we perform semantic analysis.  We speculatively assume it is
comment|// unevaluated; it will get fixed later if the subexpression is in fact
comment|// potentially evaluated.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|,
name|Sema
operator|::
name|ReuseLambdaContextDecl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ExprResult
name|SubExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getExprOperand
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getExprOperand
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTypeidExpr
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXUuidofExpr
argument_list|(
argument|CXXUuidofExpr *E
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|isTypeOperand
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|TInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeOperandSourceInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TInfo
operator|==
name|E
operator|->
name|getTypeOperandSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXUuidofExpr
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|TInfo
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ExprResult
name|SubExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getExprOperand
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getExprOperand
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXUuidofExpr
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXBoolLiteralExpr
argument_list|(
argument|CXXBoolLiteralExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNullPtrLiteralExpr
argument_list|(
argument|CXXNullPtrLiteralExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXThisExpr
argument_list|(
argument|CXXThisExpr *E
argument_list|)
block|{
name|QualType
name|T
operator|=
name|getSema
argument_list|()
operator|.
name|getCurrentThisType
argument_list|()
block|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
condition|)
block|{
comment|// Make sure that we capture 'this'.
name|getSema
argument_list|()
operator|.
name|CheckCXXThisCapture
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXThisExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|isImplicit
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXThrowExpr
argument_list|(
argument|CXXThrowExpr *E
argument_list|)
block|{
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXThrowExpr
argument_list|(
name|E
operator|->
name|getThrowLoc
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|isThrownVariableInScope
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDefaultArgExpr
argument_list|(
argument|CXXDefaultArgExpr *E
argument_list|)
block|{
name|ParmVarDecl
operator|*
name|Param
operator|=
name|cast_or_null
operator|<
name|ParmVarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getParam
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Param
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Param
operator|==
name|E
operator|->
name|getParam
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDefaultArgExpr
argument_list|(
name|E
operator|->
name|getUsedLocation
argument_list|()
argument_list|,
name|Param
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDefaultInitExpr
argument_list|(
argument|CXXDefaultInitExpr *E
argument_list|)
block|{
name|FieldDecl
operator|*
name|Field
operator|=
name|cast_or_null
operator|<
name|FieldDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getField
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Field
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Field
operator|==
name|E
operator|->
name|getField
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDefaultInitExpr
argument_list|(
name|E
operator|->
name|getExprLoc
argument_list|()
argument_list|,
name|Field
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXScalarValueInitExpr
argument_list|(
argument|CXXScalarValueInitExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXScalarValueInitExpr
argument_list|(
name|T
argument_list|,
comment|/*FIXME:*/
name|T
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getEndLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNewExpr
argument_list|(
argument|CXXNewExpr *E
argument_list|)
block|{
comment|// Transform the type that we're allocating
name|TypeSourceInfo
operator|*
name|AllocTypeInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getAllocatedTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|AllocTypeInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform the size of the array we're allocating (if any).
name|ExprResult
name|ArraySize
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ArraySize
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the placement arguments (if any).
end_comment

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|PlacementArgs
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getPlacementArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumPlacementArgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|PlacementArgs
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the initializer (if any).
end_comment

begin_decl_stmt
name|Expr
modifier|*
name|OldInit
init|=
name|E
operator|->
name|getInitializer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ExprResult
name|NewInit
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|OldInit
condition|)
name|NewInit
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OldInit
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|NewInit
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform new operator and delete operator.
end_comment

begin_decl_stmt
name|FunctionDecl
modifier|*
name|OperatorNew
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorNew
argument_list|()
condition|)
block|{
name|OperatorNew
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorNew
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorNew
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|FunctionDecl
modifier|*
name|OperatorDelete
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
name|OperatorDelete
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorDelete
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorDelete
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|AllocTypeInfo
operator|==
name|E
operator|->
name|getAllocatedTypeSourceInfo
argument_list|()
operator|&&
name|ArraySize
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArraySize
argument_list|()
operator|&&
name|NewInit
operator|.
name|get
argument_list|()
operator|==
name|OldInit
operator|&&
name|OperatorNew
operator|==
name|E
operator|->
name|getOperatorNew
argument_list|()
operator|&&
name|OperatorDelete
operator|==
name|E
operator|->
name|getOperatorDelete
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// Mark any declarations we need as referenced.
comment|// FIXME: instantiation-specific.
if|if
condition|(
name|OperatorNew
condition|)
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorNew
argument_list|)
expr_stmt|;
if|if
condition|(
name|OperatorDelete
condition|)
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorDelete
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|->
name|isArray
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|getAllocatedType
argument_list|()
operator|->
name|isDependentType
argument_list|()
condition|)
block|{
name|QualType
name|ElementType
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getBaseElementType
argument_list|(
name|E
operator|->
name|getAllocatedType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
specifier|const
name|RecordType
modifier|*
name|RecordT
init|=
name|ElementType
operator|->
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
condition|)
block|{
name|CXXRecordDecl
modifier|*
name|Record
init|=
name|cast
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|RecordT
operator|->
name|getDecl
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|CXXDestructorDecl
modifier|*
name|Destructor
init|=
name|SemaRef
operator|.
name|LookupDestructor
argument_list|(
name|Record
argument_list|)
condition|)
block|{
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Destructor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|QualType
name|AllocType
init|=
name|AllocTypeInfo
operator|->
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|ArraySize
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// If no array size was specified, but the new expression was
comment|// instantiated with an array type (e.g., "new T" where T is
comment|// instantiated with "int[4]"), extract the outer bound from the
comment|// array type as our array size. We do this with constant and
comment|// dependently-sized array types.
specifier|const
name|ArrayType
modifier|*
name|ArrayT
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getAsArrayType
argument_list|(
name|AllocType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ArrayT
condition|)
block|{
comment|// Do nothing
block|}
elseif|else
if|if
condition|(
specifier|const
name|ConstantArrayType
modifier|*
name|ConsArrayT
init|=
name|dyn_cast
operator|<
name|ConstantArrayType
operator|>
operator|(
name|ArrayT
operator|)
condition|)
block|{
name|ArraySize
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|IntegerLiteral
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|ConsArrayT
operator|->
name|getSize
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|getSizeType
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|AllocType
operator|=
name|ConsArrayT
operator|->
name|getElementType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|DependentSizedArrayType
modifier|*
name|DepArrayT
init|=
name|dyn_cast
operator|<
name|DependentSizedArrayType
operator|>
operator|(
name|ArrayT
operator|)
condition|)
block|{
if|if
condition|(
name|DepArrayT
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|ArraySize
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|DepArrayT
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
expr_stmt|;
name|AllocType
operator|=
name|DepArrayT
operator|->
name|getElementType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXNewExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|isGlobalNew
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|PlacementArgs
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getTypeIdParens
argument_list|()
argument_list|,
name|AllocType
argument_list|,
name|AllocTypeInfo
argument_list|,
name|ArraySize
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getDirectInitRange
argument_list|()
argument_list|,
name|NewInit
operator|.
name|take
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDeleteExpr
argument_list|(
argument|CXXDeleteExpr *E
argument_list|)
block|{
name|ExprResult
name|Operand
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArgument
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Operand
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform the delete operator, if known.
name|FunctionDecl
operator|*
name|OperatorDelete
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
name|OperatorDelete
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorDelete
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorDelete
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Operand
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArgument
argument_list|()
operator|&&
name|OperatorDelete
operator|==
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
comment|// Mark any declarations we need as referenced.
comment|// FIXME: instantiation-specific.
if|if
condition|(
name|OperatorDelete
condition|)
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorDelete
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|E
operator|->
name|getArgument
argument_list|()
operator|->
name|isTypeDependent
argument_list|()
condition|)
block|{
name|QualType
name|Destroyed
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getBaseElementType
argument_list|(
name|E
operator|->
name|getDestroyedType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
specifier|const
name|RecordType
modifier|*
name|DestroyedRec
init|=
name|Destroyed
operator|->
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
condition|)
block|{
name|CXXRecordDecl
modifier|*
name|Record
init|=
name|cast
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|DestroyedRec
operator|->
name|getDecl
argument_list|()
operator|)
decl_stmt|;
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|LookupDestructor
argument_list|(
name|Record
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDeleteExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|isGlobalDelete
argument_list|()
argument_list|,
name|E
operator|->
name|isArrayForm
argument_list|()
argument_list|,
name|Operand
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXPseudoDestructorExpr
argument_list|(
argument|CXXPseudoDestructorExpr *E
argument_list|)
block|{
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ParsedType
name|ObjectTypePtr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|MayBePseudoDestructor
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Base
operator|=
name|SemaRef
operator|.
name|ActOnStartCXXMemberReference
argument_list|(
literal|0
argument_list|,
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|ObjectTypePtr
argument_list|,
name|MayBePseudoDestructor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|ObjectType
init|=
name|ObjectTypePtr
operator|.
name|get
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NestedNameSpecifierLoc
name|QualifierLoc
init|=
name|E
operator|->
name|getQualifierLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|QualifierLoc
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|QualifierLoc
argument_list|,
name|ObjectType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|CXXScopeSpec
name|SS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PseudoDestructorTypeStorage
name|Destroyed
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getDestroyedTypeInfo
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|DestroyedTypeInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformTypeInObjectScope
argument_list|(
name|E
operator|->
name|getDestroyedTypeInfo
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
literal|0
argument_list|,
name|SS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DestroyedTypeInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Destroyed
operator|=
name|DestroyedTypeInfo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ObjectType
operator|.
name|isNull
argument_list|()
operator|&&
name|ObjectType
operator|->
name|isDependentType
argument_list|()
condition|)
block|{
comment|// We aren't likely to be able to resolve the identifier down to a type
comment|// now anyway, so just retain the identifier.
name|Destroyed
operator|=
name|PseudoDestructorTypeStorage
argument_list|(
name|E
operator|->
name|getDestroyedTypeIdentifier
argument_list|()
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Look for a destructor known with the given name.
name|ParsedType
name|T
init|=
name|SemaRef
operator|.
name|getDestructorName
argument_list|(
name|E
operator|->
name|getTildeLoc
argument_list|()
argument_list|,
operator|*
name|E
operator|->
name|getDestroyedTypeIdentifier
argument_list|()
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|,
name|SS
argument_list|,
name|ObjectTypePtr
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Destroyed
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|GetTypeFromParser
argument_list|(
name|T
argument_list|)
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|ScopeTypeInfo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getScopeTypeInfo
argument_list|()
condition|)
block|{
name|CXXScopeSpec
name|EmptySS
decl_stmt|;
name|ScopeTypeInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTypeInObjectScope
argument_list|(
name|E
operator|->
name|getScopeTypeInfo
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
literal|0
argument_list|,
name|EmptySS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ScopeTypeInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXPseudoDestructorExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|SS
argument_list|,
name|ScopeTypeInfo
argument_list|,
name|E
operator|->
name|getColonColonLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getTildeLoc
argument_list|()
argument_list|,
name|Destroyed
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedLookupExpr
argument_list|(
argument|UnresolvedLookupExpr *Old
argument_list|)
block|{
name|LookupResult
name|R
argument_list|(
name|SemaRef
argument_list|,
name|Old
operator|->
name|getName
argument_list|()
argument_list|,
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
name|Sema
operator|::
name|LookupOrdinaryName
argument_list|)
block|;
comment|// Transform all the decls.
for|for
control|(
name|UnresolvedLookupExpr
operator|::
name|decls_iterator
name|I
operator|=
name|Old
operator|->
name|decls_begin
argument_list|()
operator|,
name|E
operator|=
name|Old
operator|->
name|decls_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NamedDecl
modifier|*
name|InstD
init|=
name|static_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|InstD
condition|)
block|{
comment|// Silently ignore these if a UsingShadowDecl instantiated to nothing.
comment|// This can happen because of dependent hiding.
if|if
condition|(
name|isa
operator|<
name|UsingShadowDecl
operator|>
operator|(
operator|*
name|I
operator|)
condition|)
continue|continue;
else|else
block|{
name|R
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Expand using declarations.
end_comment

begin_expr_stmt
unit|if
operator|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
operator|)
block|{
name|UsingDecl
operator|*
name|UD
operator|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
block|;
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|I
operator|=
name|UD
operator|->
name|shadow_begin
argument_list|()
operator|,
name|E
operator|=
name|UD
operator|->
name|shadow_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|R
operator|.
name|addDecl
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|}      R
operator|.
name|addDecl
argument_list|(
name|InstD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Resolve a kind, but don't do any further analysis.  If it's
end_comment

begin_comment
comment|// ambiguous, the callee needs to deal with it.
end_comment

begin_expr_stmt
unit|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Rebuild the nested-name qualifier, if present.
end_comment

begin_decl_stmt
name|CXXScopeSpec
name|SS
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|NestedNameSpecifierLoc
name|QualifierLoc
init|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|Old
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|SS
operator|.
name|Adopt
argument_list|(
name|QualifierLoc
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Old
operator|->
name|getNamingClass
argument_list|()
condition|)
block|{
name|CXXRecordDecl
modifier|*
name|NamingClass
init|=
name|cast_or_null
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|getNamingClass
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|NamingClass
condition|)
block|{
name|R
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
name|R
operator|.
name|setNamingClass
argument_list|(
name|NamingClass
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|SourceLocation
name|TemplateKWLoc
init|=
name|Old
operator|->
name|getTemplateKeywordLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// If we have neither explicit template arguments, nor the template keyword,
end_comment

begin_comment
comment|// it's a normal declaration name.
end_comment

begin_if
if|if
condition|(
operator|!
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
operator|&&
operator|!
name|TemplateKWLoc
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|Old
operator|->
name|requiresADL
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// If we have template arguments, rebuild them, then rebuild the
end_comment

begin_comment
comment|// templateid expression.
end_comment

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|Old
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
operator|&&
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|Old
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|Old
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
block|{
name|R
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|R
argument_list|,
name|Old
operator|->
name|requiresADL
argument_list|()
argument_list|,
operator|&
name|TransArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryTypeTraitExpr
argument_list|(
argument|UnaryTypeTraitExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getQueriedTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getQueriedTypeSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryTypeTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBinaryTypeTraitExpr
argument_list|(
argument|BinaryTypeTraitExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|LhsT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getLhsTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|LhsT
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|TypeSourceInfo
operator|*
name|RhsT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getRhsTypeSourceInfo
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|RhsT
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|LhsT
operator|==
name|E
operator|->
name|getLhsTypeSourceInfo
argument_list|()
operator|&&
name|RhsT
operator|==
name|E
operator|->
name|getRhsTypeSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildBinaryTypeTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|LhsT
argument_list|,
name|RhsT
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeTraitExpr
argument_list|(
argument|TypeTraitExpr *E
argument_list|)
block|{
name|bool
name|ArgChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|TypeSourceInfo
operator|*
block|,
literal|4
operator|>
name|Args
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TypeSourceInfo
modifier|*
name|From
init|=
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|TypeLoc
name|FromTL
init|=
name|From
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|FromTL
operator|.
name|getAs
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
operator|)
condition|)
block|{
name|TypeLocBuilder
name|TLB
decl_stmt|;
name|TLB
operator|.
name|reserve
argument_list|(
name|FromTL
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|QualType
name|To
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|FromTL
argument_list|)
decl_stmt|;
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|To
operator|==
name|From
operator|->
name|getType
argument_list|()
condition|)
name|Args
operator|.
name|push_back
argument_list|(
name|From
argument_list|)
expr_stmt|;
else|else
block|{
name|Args
operator|.
name|push_back
argument_list|(
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|To
argument_list|)
argument_list|)
expr_stmt|;
name|ArgChanged
operator|=
name|true
expr_stmt|;
block|}
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|}      ArgChanged
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_comment
comment|// We have a pack expansion. Instantiate it.
end_comment

begin_decl_stmt
name|PackExpansionTypeLoc
name|ExpansionTL
init|=
name|FromTL
operator|.
name|castAs
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TypeLoc
name|PatternTL
init|=
name|ExpansionTL
operator|.
name|getPatternLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SemaRef
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|PatternTL
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Determine whether the set of unexpanded parameter packs can and should
end_comment

begin_comment
comment|// be expanded.
end_comment

begin_decl_stmt
name|bool
name|Expand
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|unsigned
operator|>
name|OrigNumExpansions
operator|=
name|ExpansionTL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getNumExpansions
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
operator|=
name|OrigNumExpansions
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|PatternTL
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|Expand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|Expand
condition|)
block|{
comment|// The transform has determined that we should perform a simple
comment|// transformation on the pack expansion, producing another pack
comment|// expansion.
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TypeLocBuilder
name|TLB
decl_stmt|;
name|TLB
operator|.
name|reserve
argument_list|(
name|From
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|QualType
name|To
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|PatternTL
argument_list|)
decl_stmt|;
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|To
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansionType
argument_list|(
name|To
argument_list|,
name|PatternTL
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|PackExpansionTypeLoc
name|ToExpansionTL
init|=
name|TLB
operator|.
name|push
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
name|To
operator|)
decl_stmt|;
name|ToExpansionTL
operator|.
name|setEllipsisLoc
argument_list|(
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|To
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_comment
comment|// Expand the pack expansion by substituting for each argument in the
end_comment

begin_comment
comment|// pack(s).
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|SemaRef
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|TypeLocBuilder
name|TLB
decl_stmt|;
name|TLB
operator|.
name|reserve
argument_list|(
name|PatternTL
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|QualType
name|To
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|PatternTL
argument_list|)
decl_stmt|;
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|To
operator|->
name|containsUnexpandedParameterPack
argument_list|()
condition|)
block|{
name|To
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansionType
argument_list|(
name|To
argument_list|,
name|PatternTL
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|PackExpansionTypeLoc
name|ToExpansionTL
init|=
name|TLB
operator|.
name|push
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
name|To
operator|)
decl_stmt|;
name|ToExpansionTL
operator|.
name|setEllipsisLoc
argument_list|(
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Args
operator|.
name|push_back
argument_list|(
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|To
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|RetainExpansion
condition|)
continue|continue;
end_if

begin_comment
comment|// If we're supposed to retain a pack expansion, do so by temporarily
end_comment

begin_comment
comment|// forgetting the partially-substituted parameter pack.
end_comment

begin_decl_stmt
name|ForgetPartiallySubstitutedPackRAII
name|Forget
argument_list|(
name|getDerived
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TypeLocBuilder
name|TLB
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TLB
operator|.
name|reserve
argument_list|(
name|From
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|To
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|PatternTL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_expr_stmt
name|To
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansionType
argument_list|(
name|To
argument_list|,
name|PatternTL
operator|.
name|getSourceRange
argument_list|()
argument_list|,
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|To
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|PackExpansionTypeLoc
name|ToExpansionTL
init|=
name|TLB
operator|.
name|push
operator|<
name|PackExpansionTypeLoc
operator|>
operator|(
name|To
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ToExpansionTL
operator|.
name|setEllipsisLoc
argument_list|(
name|ExpansionTL
operator|.
name|getEllipsisLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Args
operator|.
name|push_back
argument_list|(
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|To
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    if
operator|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgChanged
operator|)
end_expr_stmt

begin_return
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_return

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTypeTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformArrayTypeTraitExpr
argument_list|(
argument|ArrayTypeTraitExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getQueriedTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getQueriedTypeSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_decl_stmt
name|ExprResult
name|SubExpr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|)
decl_stmt|;
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getDimensionExpression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getDimensionExpression
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_block

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayTypeTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|T
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExpressionTraitExpr
argument_list|(
argument|ExpressionTraitExpr *E
argument_list|)
block|{
name|ExprResult
name|SubExpr
block|;
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|)
block|;
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getQueriedExpression
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getQueriedExpression
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildExpressionTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentScopeDeclRefExpr
argument_list|(
argument|DependentScopeDeclRefExpr *E
argument_list|)
block|{
return|return
name|TransformDependentScopeDeclRefExpr
argument_list|(
name|E
argument_list|,
comment|/*IsAddressOfOperand*/
name|false
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentScopeDeclRefExpr
argument_list|(
argument|DependentScopeDeclRefExpr *E
argument_list|,
argument|bool IsAddressOfOperand
argument_list|)
block|{
name|assert
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
block|;
name|NestedNameSpecifierLoc
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|SourceLocation
name|TemplateKWLoc
operator|=
name|E
operator|->
name|getTemplateKeywordLoc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// TODO: If this is a conversion-function-id, verify that the
end_comment

begin_comment
comment|// destination type name (if present) resolves the same way after
end_comment

begin_comment
comment|// instantiation as it did in the local scope.
end_comment

begin_decl_stmt
name|DeclarationNameInfo
name|NameInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationNameInfo
argument_list|(
name|E
operator|->
name|getNameInfo
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|QualifierLoc
operator|==
name|E
operator|->
name|getQualifierLoc
argument_list|()
operator|&&
comment|// Note: it is sufficient to compare the Name component of NameInfo:
comment|// if name has not changed, DNLoc has not changed either.
name|NameInfo
operator|.
name|getName
argument_list|()
operator|==
name|E
operator|->
name|getDeclName
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDependentScopeDeclRefExpr
argument_list|(
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|NameInfo
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|,
name|IsAddressOfOperand
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDependentScopeDeclRefExpr
argument_list|(
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|NameInfo
argument_list|,
operator|&
name|TransArgs
argument_list|,
name|IsAddressOfOperand
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXConstructExpr
argument_list|(
argument|CXXConstructExpr *E
argument_list|)
block|{
comment|// CXXConstructExprs other than for list-initialization and
comment|// CXXTemporaryObjectExpr are always implicit, so when we have
comment|// a 1-argument construction we just transform that argument.
if|if
condition|(
operator|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|==
literal|1
operator|||
operator|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|>
literal|1
operator|&&
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|E
operator|->
name|isListInitialization
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
comment|/*FIXME*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|CXXConstructorDecl
modifier|*
name|Constructor
init|=
name|cast_or_null
operator|<
name|CXXConstructorDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructor
argument_list|()
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Constructor
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
operator|&&
name|Constructor
operator|==
name|E
operator|->
name|getConstructor
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// Mark the constructor as referenced.
comment|// FIXME: Instantiation-specific
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXConstructExpr
argument_list|(
name|T
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|,
name|E
operator|->
name|isElidable
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|hadMultipleCandidates
argument_list|()
argument_list|,
name|E
operator|->
name|isListInitialization
argument_list|()
argument_list|,
name|E
operator|->
name|requiresZeroInitialization
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructionKind
argument_list|()
argument_list|,
name|E
operator|->
name|getParenOrBraceRange
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief Transform a C++ temporary-binding expression.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since CXXBindTemporaryExpr nodes are implicitly generated, we just
end_comment

begin_comment
comment|/// transform the subexpression and return that.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXBindTemporaryExpr
argument_list|(
argument|CXXBindTemporaryExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Transform a C++ expression that contains cleanups that should
end_comment

begin_comment
comment|/// be run after the expression is evaluated.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since ExprWithCleanups nodes are implicitly generated, we
end_comment

begin_comment
comment|/// just transform the subexpression and return that.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExprWithCleanups
argument_list|(
argument|ExprWithCleanups *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTemporaryObjectExpr
argument_list|(
argument|CXXTemporaryObjectExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|CXXConstructorDecl
operator|*
name|Constructor
operator|=
name|cast_or_null
operator|<
name|CXXConstructorDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructor
argument_list|()
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Constructor
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Args
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|,
name|true
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
operator|&&
name|Constructor
operator|==
name|E
operator|->
name|getConstructor
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// FIXME: Instantiation-specific
name|SemaRef
operator|.
name|MarkFunctionReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// FIXME: Pass in E->isListInitialization().
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTemporaryObjectExpr
argument_list|(
name|T
argument_list|,
comment|/*FIXME:*/
name|T
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getEndLoc
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLambdaExpr
argument_list|(
argument|LambdaExpr *E
argument_list|)
block|{
comment|// Transform any init-capture expressions before entering the scope of the
comment|// lambda body, because they are not semantically within that scope.
name|SmallVector
operator|<
name|InitCaptureInfoTy
block|,
literal|8
operator|>
name|InitCaptureExprsAndTypes
block|;
name|InitCaptureExprsAndTypes
operator|.
name|resize
argument_list|(
name|E
operator|->
name|explicit_capture_end
argument_list|()
operator|-
name|E
operator|->
name|explicit_capture_begin
argument_list|()
argument_list|)
block|;
for|for
control|(
name|LambdaExpr
operator|::
name|capture_iterator
name|C
operator|=
name|E
operator|->
name|capture_begin
argument_list|()
operator|,
name|CEnd
operator|=
name|E
operator|->
name|capture_end
argument_list|()
init|;
name|C
operator|!=
name|CEnd
condition|;
operator|++
name|C
control|)
block|{
if|if
condition|(
operator|!
name|C
operator|->
name|isInitCapture
argument_list|()
condition|)
continue|continue;
name|EnterExpressionEvaluationContext
name|EEEC
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Sema
operator|::
name|PotentiallyEvaluated
argument_list|)
decl_stmt|;
name|ExprResult
name|NewExprInitResult
init|=
name|getDerived
argument_list|()
operator|.
name|TransformInitializer
argument_list|(
name|C
operator|->
name|getCapturedVar
argument_list|()
operator|->
name|getInit
argument_list|()
argument_list|,
name|C
operator|->
name|getCapturedVar
argument_list|()
operator|->
name|getInitStyle
argument_list|()
operator|==
name|VarDecl
operator|::
name|CallInit
argument_list|)
decl_stmt|;
if|if
condition|(
name|NewExprInitResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Expr
modifier|*
name|NewExprInit
init|=
name|NewExprInitResult
operator|.
name|get
argument_list|()
decl_stmt|;
name|VarDecl
modifier|*
name|OldVD
init|=
name|C
operator|->
name|getCapturedVar
argument_list|()
decl_stmt|;
name|QualType
name|NewInitCaptureType
init|=
name|getSema
argument_list|()
operator|.
name|performLambdaInitCaptureInitialization
argument_list|(
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|OldVD
operator|->
name|getType
argument_list|()
operator|->
name|isReferenceType
argument_list|()
argument_list|,
name|OldVD
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|NewExprInit
argument_list|)
decl_stmt|;
name|NewExprInitResult
operator|=
name|NewExprInit
expr_stmt|;
name|InitCaptureExprsAndTypes
index|[
name|C
operator|-
name|E
operator|->
name|capture_begin
argument_list|()
index|]
operator|=
name|std
operator|::
name|make_pair
argument_list|(
name|NewExprInitResult
argument_list|,
name|NewInitCaptureType
argument_list|)
expr_stmt|;
block|}
name|LambdaScopeInfo
operator|*
name|LSI
operator|=
name|getSema
argument_list|()
operator|.
name|PushLambdaScope
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Transform the template parameters, and add them to the current
end_comment

begin_comment
comment|// instantiation scope. The null case is handled correctly.
end_comment

begin_expr_stmt
name|LSI
operator|->
name|GLTemplateParameterList
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateParameterList
argument_list|(
name|E
operator|->
name|getTemplateParameterList
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Check to see if the TypeSourceInfo of the call operator needs to
end_comment

begin_comment
comment|// be transformed, and if so do the transformation in the
end_comment

begin_comment
comment|// CurrentInstantiationScope.
end_comment

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|OldCallOpTSI
init|=
name|E
operator|->
name|getCallOperator
argument_list|()
operator|->
name|getTypeSourceInfo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FunctionProtoTypeLoc
name|OldCallOpFPTL
init|=
name|OldCallOpTSI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|getAs
operator|<
name|FunctionProtoTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|NewCallOpTSI
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bool
name|CallOpWasAlreadyTransformed
init|=
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|OldCallOpTSI
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Use the Old Call Operator's TypeSourceInfo if it is already transformed.
end_comment

begin_if
if|if
condition|(
name|CallOpWasAlreadyTransformed
condition|)
name|NewCallOpTSI
operator|=
name|OldCallOpTSI
expr_stmt|;
else|else
block|{
comment|// Transform the TypeSourceInfo of the Original Lambda's Call Operator.
comment|// The transformation MUST be done in the CurrentInstantiationScope since
comment|// it introduces a mapping of the original to the newly created
comment|// transformed parameters.
name|TypeLocBuilder
name|NewCallOpTLBuilder
decl_stmt|;
name|QualType
name|NewCallOpType
init|=
name|TransformFunctionProtoType
argument_list|(
name|NewCallOpTLBuilder
argument_list|,
name|OldCallOpFPTL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|NewCallOpTSI
operator|=
name|NewCallOpTLBuilder
operator|.
name|getTypeSourceInfo
argument_list|(
name|getSema
argument_list|()
operator|.
name|Context
argument_list|,
name|NewCallOpType
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Extract the ParmVarDecls from the NewCallOpTSI and add them to
end_comment

begin_comment
comment|// the vector below - this will be used to synthesize the
end_comment

begin_comment
comment|// NewCallOperator.  Additionally, add the parameters of the untransformed
end_comment

begin_comment
comment|// lambda call operator to the CurrentInstantiationScope.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|ParmVarDecl
operator|*
operator|,
literal|4
operator|>
name|Params
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FunctionProtoTypeLoc
name|NewCallOpFPTL
init|=
name|NewCallOpTSI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|castAs
operator|<
name|FunctionProtoTypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|ParmVarDecl
modifier|*
modifier|*
name|NewParamDeclArray
init|=
name|NewCallOpFPTL
operator|.
name|getParmArray
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|NewNumArgs
init|=
name|NewCallOpFPTL
operator|.
name|getNumArgs
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|NewNumArgs
condition|;
operator|++
name|I
control|)
block|{
comment|// If this call operator's type does not require transformation,
comment|// the parameters do not get added to the current instantiation scope,
comment|// - so ADD them! This allows the following to compile when the enclosing
comment|// template is specialized and the entire lambda expression has to be
comment|// transformed.
comment|// template<class T> void foo(T t) {
comment|//   auto L = [](auto a) {
comment|//       auto M = [](char b) {<-- note: non-generic lambda
comment|//         auto N = [](auto c) {
comment|//            int x = sizeof(a);
comment|//            x = sizeof(b);<-- specifically this line
comment|//            x = sizeof(c);
comment|//          };
comment|//        };
comment|//      };
comment|//    }
comment|// foo('a')
if|if
condition|(
name|CallOpWasAlreadyTransformed
condition|)
name|getDerived
argument_list|()
operator|.
name|transformedLocalDecl
argument_list|(
name|NewParamDeclArray
index|[
name|I
index|]
argument_list|,
name|NewParamDeclArray
index|[
name|I
index|]
argument_list|)
expr_stmt|;
comment|// Add to Params array, so these parameters can be used to create
comment|// the newly transformed call operator.
name|Params
operator|.
name|push_back
argument_list|(
name|NewParamDeclArray
index|[
name|I
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|if
condition|(
operator|!
name|NewCallOpTSI
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Create the local class that will describe the lambda.
end_comment

begin_decl_stmt
name|CXXRecordDecl
modifier|*
name|Class
init|=
name|getSema
argument_list|()
operator|.
name|createLambdaClosureType
argument_list|(
name|E
operator|->
name|getIntroducerRange
argument_list|()
argument_list|,
name|NewCallOpTSI
argument_list|,
comment|/*KnownDependent=*/
name|false
argument_list|,
name|E
operator|->
name|getCaptureDefault
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|getDerived
argument_list|()
operator|.
name|transformedLocalDecl
argument_list|(
name|E
operator|->
name|getLambdaClass
argument_list|()
argument_list|,
name|Class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Build the call operator.
end_comment

begin_decl_stmt
name|CXXMethodDecl
modifier|*
name|NewCallOperator
init|=
name|getSema
argument_list|()
operator|.
name|startLambdaDefinition
argument_list|(
name|Class
argument_list|,
name|E
operator|->
name|getIntroducerRange
argument_list|()
argument_list|,
name|NewCallOpTSI
argument_list|,
name|E
operator|->
name|getCallOperator
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|,
name|Params
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LSI
operator|->
name|CallOperator
operator|=
name|NewCallOperator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getDerived
argument_list|()
operator|.
name|transformAttrs
argument_list|(
name|E
operator|->
name|getCallOperator
argument_list|()
argument_list|,
name|NewCallOperator
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|TransformLambdaScope
argument_list|(
name|E
argument_list|,
name|NewCallOperator
argument_list|,
name|InitCaptureExprsAndTypes
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLambdaScope
argument_list|(
argument|LambdaExpr *E
argument_list|,
argument|CXXMethodDecl *CallOperator
argument_list|,
argument|ArrayRef<InitCaptureInfoTy> InitCaptureExprsAndTypes
argument_list|)
block|{
name|bool
name|Invalid
operator|=
name|false
block|;
comment|// Introduce the context of the call operator.
name|Sema
operator|::
name|ContextRAII
name|SavedContext
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|CallOperator
argument_list|)
block|;
name|LambdaScopeInfo
operator|*
specifier|const
name|LSI
operator|=
name|getSema
argument_list|()
operator|.
name|getCurLambda
argument_list|()
block|;
comment|// Enter the scope of the lambda.
name|getSema
argument_list|()
operator|.
name|buildLambdaScope
argument_list|(
name|LSI
argument_list|,
name|CallOperator
argument_list|,
name|E
operator|->
name|getIntroducerRange
argument_list|()
argument_list|,
name|E
operator|->
name|getCaptureDefault
argument_list|()
argument_list|,
name|E
operator|->
name|getCaptureDefaultLoc
argument_list|()
argument_list|,
name|E
operator|->
name|hasExplicitParameters
argument_list|()
argument_list|,
name|E
operator|->
name|hasExplicitResultType
argument_list|()
argument_list|,
name|E
operator|->
name|isMutable
argument_list|()
argument_list|)
block|;
comment|// Transform captures.
name|bool
name|FinishedExplicitCaptures
operator|=
name|false
block|;
for|for
control|(
name|LambdaExpr
operator|::
name|capture_iterator
name|C
operator|=
name|E
operator|->
name|capture_begin
argument_list|()
operator|,
name|CEnd
operator|=
name|E
operator|->
name|capture_end
argument_list|()
init|;
name|C
operator|!=
name|CEnd
condition|;
operator|++
name|C
control|)
block|{
comment|// When we hit the first implicit capture, tell Sema that we've finished
comment|// the list of explicit captures.
if|if
condition|(
operator|!
name|FinishedExplicitCaptures
operator|&&
name|C
operator|->
name|isImplicit
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|finishLambdaExplicitCaptures
argument_list|(
name|LSI
argument_list|)
expr_stmt|;
name|FinishedExplicitCaptures
operator|=
name|true
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Capturing 'this' is trivial.
end_comment

begin_if
if|if
condition|(
name|C
operator|->
name|capturesThis
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|CheckCXXThisCapture
argument_list|(
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|C
operator|->
name|isExplicit
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_comment
comment|// Rebuild init-captures, including the implied field declaration.
end_comment

begin_if
if|if
condition|(
name|C
operator|->
name|isInitCapture
argument_list|()
condition|)
block|{
name|InitCaptureInfoTy
name|InitExprTypePair
init|=
name|InitCaptureExprsAndTypes
index|[
name|C
operator|-
name|E
operator|->
name|capture_begin
argument_list|()
index|]
decl_stmt|;
name|ExprResult
name|Init
init|=
name|InitExprTypePair
operator|.
name|first
decl_stmt|;
name|QualType
name|InitQualType
init|=
name|InitExprTypePair
operator|.
name|second
decl_stmt|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
operator|||
name|InitQualType
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|Invalid
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|VarDecl
modifier|*
name|OldVD
init|=
name|C
operator|->
name|getCapturedVar
argument_list|()
decl_stmt|;
name|VarDecl
modifier|*
name|NewVD
init|=
name|getSema
argument_list|()
operator|.
name|createLambdaInitCaptureVarDecl
argument_list|(
name|OldVD
operator|->
name|getLocation
argument_list|()
argument_list|,
name|InitExprTypePair
operator|.
name|second
argument_list|,
name|OldVD
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|Init
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NewVD
condition|)
name|Invalid
operator|=
name|true
expr_stmt|;
else|else
block|{
name|getDerived
argument_list|()
operator|.
name|transformedLocalDecl
argument_list|(
name|OldVD
argument_list|,
name|NewVD
argument_list|)
expr_stmt|;
block|}
name|getSema
argument_list|()
operator|.
name|buildInitCaptureField
argument_list|(
name|LSI
argument_list|,
name|NewVD
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|assert
argument_list|(
name|C
operator|->
name|capturesVariable
argument_list|()
operator|&&
literal|"unexpected kind of lambda capture"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Determine the capture kind for Sema.
end_comment

begin_expr_stmt
name|Sema
operator|::
name|TryCaptureKind
name|Kind
operator|=
name|C
operator|->
name|isImplicit
argument_list|()
condition|?
name|Sema
operator|::
name|TryCapture_Implicit
else|:
name|C
operator|->
name|getCaptureKind
argument_list|()
operator|==
name|LCK_ByCopy
condition|?
name|Sema
operator|::
name|TryCapture_ExplicitByVal
else|:
name|Sema
operator|::
name|TryCapture_ExplicitByRef
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SourceLocation
name|EllipsisLoc
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|C
operator|->
name|isPackExpansion
argument_list|()
condition|)
block|{
name|UnexpandedParameterPack
name|Unexpanded
argument_list|(
name|C
operator|->
name|getCapturedVar
argument_list|()
argument_list|,
name|C
operator|->
name|getLocation
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|ShouldExpand
init|=
name|false
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|C
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|ShouldExpand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
block|{
name|Invalid
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ShouldExpand
condition|)
block|{
comment|// The transform has determined that we should perform an expansion;
comment|// transform and capture each of the arguments.
comment|// expansion of the pattern. Do so.
name|VarDecl
modifier|*
name|Pack
init|=
name|C
operator|->
name|getCapturedVar
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|VarDecl
modifier|*
name|CapturedVar
init|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|Pack
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|CapturedVar
condition|)
block|{
name|Invalid
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|// Capture the transformed variable.
name|getSema
argument_list|()
operator|.
name|tryCaptureVariable
argument_list|(
name|CapturedVar
argument_list|,
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|Kind
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|EllipsisLoc
operator|=
name|C
operator|->
name|getEllipsisLoc
argument_list|()
expr_stmt|;
block|}
end_if

begin_comment
comment|// Transform the captured variable.
end_comment

begin_decl_stmt
name|VarDecl
modifier|*
name|CapturedVar
init|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|C
operator|->
name|getCapturedVar
argument_list|()
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|CapturedVar
condition|)
block|{
name|Invalid
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
end_if

begin_comment
comment|// Capture the transformed variable.
end_comment

begin_expr_stmt
name|getSema
argument_list|()
operator|.
name|tryCaptureVariable
argument_list|(
name|CapturedVar
argument_list|,
name|C
operator|->
name|getLocation
argument_list|()
argument_list|,
name|Kind
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   if
operator|(
operator|!
name|FinishedExplicitCaptures
operator|)
name|getSema
argument_list|()
operator|.
name|finishLambdaExplicitCaptures
argument_list|(
name|LSI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Enter a new evaluation context to insulate the lambda from any
end_comment

begin_comment
comment|// cleanups from the enclosing full-expression.
end_comment

begin_expr_stmt
name|getSema
argument_list|()
operator|.
name|PushExpressionEvaluationContext
argument_list|(
name|Sema
operator|::
name|PotentiallyEvaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Invalid
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnLambdaError
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*CurScope=*/
literal|0
argument_list|,
comment|/*IsInstantiation=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Instantiate the body of the lambda expression.
end_comment

begin_decl_stmt
name|StmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|E
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnLambdaError
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*CurScope=*/
literal|0
argument_list|,
comment|/*IsInstantiation=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_return
return|return
name|getSema
argument_list|()
operator|.
name|ActOnLambdaExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Body
operator|.
name|take
argument_list|()
argument_list|,
comment|/*CurScope=*/
literal|0
argument_list|,
comment|/*IsInstantiation=*/
name|true
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXUnresolvedConstructExpr
argument_list|(
argument|CXXUnresolvedConstructExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|bool
name|ArgumentChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|8
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Args
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|arg_size
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|arg_begin
argument_list|()
argument_list|,
name|E
operator|->
name|arg_size
argument_list|()
argument_list|,
name|true
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: we're faking the locations of the commas
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXUnresolvedConstructExpr
argument_list|(
name|T
argument_list|,
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDependentScopeMemberExpr
argument_list|(
argument|CXXDependentScopeMemberExpr *E
argument_list|)
block|{
comment|// Transform the base of the expression.
name|ExprResult
name|Base
argument_list|(
operator|(
name|Expr
operator|*
operator|)
literal|0
argument_list|)
block|;
name|Expr
operator|*
name|OldBase
block|;
name|QualType
name|BaseType
block|;
name|QualType
name|ObjectType
block|;
if|if
condition|(
operator|!
name|E
operator|->
name|isImplicitAccess
argument_list|()
condition|)
block|{
name|OldBase
operator|=
name|E
operator|->
name|getBase
argument_list|()
expr_stmt|;
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OldBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Start the member reference and compute the object's type.
name|ParsedType
name|ObjectTy
decl_stmt|;
name|bool
name|MayBePseudoDestructor
init|=
name|false
decl_stmt|;
name|Base
operator|=
name|SemaRef
operator|.
name|ActOnStartCXXMemberReference
argument_list|(
literal|0
argument_list|,
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|ObjectTy
argument_list|,
name|MayBePseudoDestructor
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ObjectType
operator|=
name|ObjectTy
operator|.
name|get
argument_list|()
expr_stmt|;
name|BaseType
operator|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getType
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|OldBase
operator|=
literal|0
expr_stmt|;
name|BaseType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getBaseType
argument_list|()
argument_list|)
expr_stmt|;
name|ObjectType
operator|=
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|->
name|getPointeeType
argument_list|()
expr_stmt|;
block|}
end_else

begin_comment
comment|// Transform the first part of the nested-name-specifier that qualifies
end_comment

begin_comment
comment|// the member name.
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
name|getDerived
argument_list|()
operator|.
name|TransformFirstQualifierInScope
argument_list|(
name|E
operator|->
name|getFirstQualifierFoundInScope
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierLoc
argument_list|()
operator|.
name|getBeginLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NestedNameSpecifierLoc
name|QualifierLoc
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|E
operator|->
name|getQualifierLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|SourceLocation
name|TemplateKWLoc
init|=
name|E
operator|->
name|getTemplateKeywordLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// TODO: If this is a conversion-function-id, verify that the
end_comment

begin_comment
comment|// destination type name (if present) resolves the same way after
end_comment

begin_comment
comment|// instantiation as it did in the local scope.
end_comment

begin_decl_stmt
name|DeclarationNameInfo
name|NameInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationNameInfo
argument_list|(
name|E
operator|->
name|getMemberNameInfo
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|NameInfo
operator|.
name|getName
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
comment|// This is a reference to a member without an explicitly-specified
comment|// template argument list. Optimize for this common case.
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|OldBase
operator|&&
name|BaseType
operator|==
name|E
operator|->
name|getBaseType
argument_list|()
operator|&&
name|QualifierLoc
operator|==
name|E
operator|->
name|getQualifierLoc
argument_list|()
operator|&&
name|NameInfo
operator|.
name|getName
argument_list|()
operator|==
name|E
operator|->
name|getMember
argument_list|()
operator|&&
name|FirstQualifierInScope
operator|==
name|E
operator|->
name|getFirstQualifierFoundInScope
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDependentScopeMemberExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|BaseType
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|NameInfo
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDependentScopeMemberExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|BaseType
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|NameInfo
argument_list|,
operator|&
name|TransArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedMemberExpr
argument_list|(
argument|UnresolvedMemberExpr *Old
argument_list|)
block|{
comment|// Transform the base of the expression.
name|ExprResult
name|Base
argument_list|(
operator|(
name|Expr
operator|*
operator|)
literal|0
argument_list|)
block|;
name|QualType
name|BaseType
block|;
if|if
condition|(
operator|!
name|Old
operator|->
name|isImplicitAccess
argument_list|()
condition|)
block|{
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Old
operator|->
name|getBase
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|Base
operator|=
name|getSema
argument_list|()
operator|.
name|PerformMemberExprBaseConversion
argument_list|(
name|Base
operator|.
name|take
argument_list|()
argument_list|,
name|Old
operator|->
name|isArrow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|BaseType
operator|=
name|Base
operator|.
name|get
argument_list|()
operator|->
name|getType
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|BaseType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Old
operator|->
name|getBaseType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_decl_stmt
name|NestedNameSpecifierLoc
name|QualifierLoc
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|getQualifierLoc
argument_list|()
condition|)
block|{
name|QualifierLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifierLoc
argument_list|(
name|Old
operator|->
name|getQualifierLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QualifierLoc
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|SourceLocation
name|TemplateKWLoc
init|=
name|Old
operator|->
name|getTemplateKeywordLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LookupResult
name|R
argument_list|(
name|SemaRef
argument_list|,
name|Old
operator|->
name|getMemberNameInfo
argument_list|()
argument_list|,
name|Sema
operator|::
name|LookupOrdinaryName
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Transform all the decls.
end_comment

begin_for
for|for
control|(
name|UnresolvedMemberExpr
operator|::
name|decls_iterator
name|I
operator|=
name|Old
operator|->
name|decls_begin
argument_list|()
operator|,
name|E
operator|=
name|Old
operator|->
name|decls_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NamedDecl
modifier|*
name|InstD
init|=
name|static_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|InstD
condition|)
block|{
comment|// Silently ignore these if a UsingShadowDecl instantiated to nothing.
comment|// This can happen because of dependent hiding.
if|if
condition|(
name|isa
operator|<
name|UsingShadowDecl
operator|>
operator|(
operator|*
name|I
operator|)
condition|)
continue|continue;
else|else
block|{
name|R
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
block|}
comment|// Expand using declarations.
if|if
condition|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
condition|)
block|{
name|UsingDecl
modifier|*
name|UD
init|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
decl_stmt|;
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|I
operator|=
name|UD
operator|->
name|shadow_begin
argument_list|()
operator|,
name|E
operator|=
name|UD
operator|->
name|shadow_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|R
operator|.
name|addDecl
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|R
operator|.
name|addDecl
argument_list|(
name|InstD
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Determine the naming class.
end_comment

begin_if
if|if
condition|(
name|Old
operator|->
name|getNamingClass
argument_list|()
condition|)
block|{
name|CXXRecordDecl
modifier|*
name|NamingClass
init|=
name|cast_or_null
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|getNamingClass
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|NamingClass
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|R
operator|.
name|setNamingClass
argument_list|(
name|NamingClass
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|Old
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|Old
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArguments
argument_list|(
name|Old
operator|->
name|getTemplateArgs
argument_list|()
argument_list|,
name|Old
operator|->
name|getNumTemplateArgs
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// FIXME: to do this check properly, we will need to preserve the
end_comment

begin_comment
comment|// first-qualifier-in-scope here, just in case we had a dependent
end_comment

begin_comment
comment|// base (and therefore couldn't do the check) and a
end_comment

begin_comment
comment|// nested-name-qualifier (and therefore could do the lookup).
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnresolvedMemberExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|BaseType
argument_list|,
name|Old
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|isArrow
argument_list|()
argument_list|,
name|QualifierLoc
argument_list|,
name|TemplateKWLoc
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
operator|(
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|?
operator|&
name|TransArgs
else|:
literal|0
operator|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNoexceptExpr
argument_list|(
argument|CXXNoexceptExpr *E
argument_list|)
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Sema
operator|::
name|Unevaluated
argument_list|)
block|;
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getOperand
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getOperand
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXNoexceptExpr
argument_list|(
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPackExpansionExpr
argument_list|(
argument|PackExpansionExpr *E
argument_list|)
block|{
name|ExprResult
name|Pattern
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getPattern
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Pattern
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Pattern
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getPattern
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildPackExpansion
argument_list|(
name|Pattern
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getNumExpansions
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSizeOfPackExpr
argument_list|(
argument|SizeOfPackExpr *E
argument_list|)
block|{
comment|// If E is not value-dependent, then nothing will change when we transform it.
comment|// Note: This is an instantiation-centric view.
if|if
condition|(
operator|!
name|E
operator|->
name|isValueDependent
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
comment|// Note: None of the implementations of TryExpandParameterPacks can ever
comment|// produce a diagnostic when given only a single unexpanded parameter pack,
comment|// so
name|UnexpandedParameterPack
name|Unexpanded
argument_list|(
name|E
operator|->
name|getPack
argument_list|()
argument_list|,
name|E
operator|->
name|getPackLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|ShouldExpand
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getPackLoc
argument_list|()
argument_list|,
name|Unexpanded
argument_list|,
name|ShouldExpand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|RetainExpansion
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_decl_stmt
name|NamedDecl
modifier|*
name|Pack
init|=
name|E
operator|->
name|getPack
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|ShouldExpand
condition|)
block|{
name|Pack
operator|=
name|cast_or_null
operator|<
name|NamedDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getPackLoc
argument_list|()
argument_list|,
name|Pack
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pack
condition|)
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We now know the length of the parameter pack, so build a new expression
end_comment

begin_comment
comment|// that stores that length.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSizeOfPackExpr
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Pack
argument_list|,
name|E
operator|->
name|getPackLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|NumExpansions
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSubstNonTypeTemplateParmPackExpr
argument_list|(
argument|SubstNonTypeTemplateParmPackExpr *E
argument_list|)
block|{
comment|// Default behavior is to do nothing with this transformation.
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSubstNonTypeTemplateParmExpr
argument_list|(
argument|SubstNonTypeTemplateParmExpr *E
argument_list|)
block|{
comment|// Default behavior is to do nothing with this transformation.
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionParmPackExpr
argument_list|(
argument|FunctionParmPackExpr *E
argument_list|)
block|{
comment|// Default behavior is to do nothing with this transformation.
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMaterializeTemporaryExpr
argument_list|(
argument|MaterializeTemporaryExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|GetTemporaryExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXStdInitializerListExpr
argument_list|(
argument|CXXStdInitializerListExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCStringLiteral
argument_list|(
argument|ObjCStringLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCBoolLiteralExpr
argument_list|(
argument|ObjCBoolLiteralExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCBoxedExpr
argument_list|(
argument|ObjCBoxedExpr *E
argument_list|)
block|{
name|ExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCBoxedExpr
argument_list|(
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|,
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCArrayLiteral
argument_list|(
argument|ObjCArrayLiteral *E
argument_list|)
block|{
comment|// Transform each of the elements.
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|Elements
block|;
name|bool
name|ArgChanged
operator|=
name|false
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getElements
argument_list|()
argument_list|,
name|E
operator|->
name|getNumElements
argument_list|()
argument_list|,
comment|/*IsCall=*/
name|false
argument_list|,
name|Elements
argument_list|,
operator|&
name|ArgChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCArrayLiteral
argument_list|(
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|,
name|Elements
operator|.
name|data
argument_list|()
argument_list|,
name|Elements
operator|.
name|size
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCDictionaryLiteral
argument_list|(
argument|ObjCDictionaryLiteral *E
argument_list|)
block|{
comment|// Transform each of the elements.
name|SmallVector
operator|<
name|ObjCDictionaryElement
block|,
literal|8
operator|>
name|Elements
block|;
name|bool
name|ArgChanged
operator|=
name|false
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumElements
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|ObjCDictionaryElement
name|OrigElement
init|=
name|E
operator|->
name|getKeyValueElement
argument_list|(
name|I
argument_list|)
decl_stmt|;
if|if
condition|(
name|OrigElement
operator|.
name|isPackExpansion
argument_list|()
condition|)
block|{
comment|// This key/value element is a pack expansion.
name|SmallVector
operator|<
name|UnexpandedParameterPack
operator|,
literal|2
operator|>
name|Unexpanded
expr_stmt|;
name|getSema
argument_list|()
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|OrigElement
operator|.
name|Key
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
name|getSema
argument_list|()
operator|.
name|collectUnexpandedParameterPacks
argument_list|(
name|OrigElement
operator|.
name|Value
argument_list|,
name|Unexpanded
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Unexpanded
operator|.
name|empty
argument_list|()
operator|&&
literal|"Pack expansion without parameter packs?"
argument_list|)
expr_stmt|;
comment|// Determine whether the set of unexpanded parameter packs can
comment|// and should be expanded.
name|bool
name|Expand
init|=
name|true
decl_stmt|;
name|bool
name|RetainExpansion
init|=
name|false
decl_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|OrigNumExpansions
operator|=
name|OrigElement
operator|.
name|NumExpansions
expr_stmt|;
name|Optional
operator|<
name|unsigned
operator|>
name|NumExpansions
operator|=
name|OrigNumExpansions
expr_stmt|;
name|SourceRange
name|PatternRange
argument_list|(
name|OrigElement
operator|.
name|Key
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OrigElement
operator|.
name|Value
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TryExpandParameterPacks
argument_list|(
name|OrigElement
operator|.
name|EllipsisLoc
argument_list|,
name|PatternRange
argument_list|,
name|Unexpanded
argument_list|,
name|Expand
argument_list|,
name|RetainExpansion
argument_list|,
name|NumExpansions
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|Expand
condition|)
block|{
comment|// The transform has determined that we should perform a simple
comment|// transformation on the pack expansion, producing another pack
comment|// expansion.
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ExprResult
name|Key
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Key
argument_list|)
decl_stmt|;
if|if
condition|(
name|Key
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|Key
operator|.
name|get
argument_list|()
operator|!=
name|OrigElement
operator|.
name|Key
condition|)
name|ArgChanged
operator|=
name|true
expr_stmt|;
name|ExprResult
name|Value
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Value
argument_list|)
decl_stmt|;
if|if
condition|(
name|Value
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
if|if
condition|(
name|Value
operator|.
name|get
argument_list|()
operator|!=
name|OrigElement
operator|.
name|Value
condition|)
name|ArgChanged
operator|=
name|true
expr_stmt|;
name|ObjCDictionaryElement
name|Expansion
init|=
block|{
name|Key
operator|.
name|get
argument_list|()
block|,
name|Value
operator|.
name|get
argument_list|()
block|,
name|OrigElement
operator|.
name|EllipsisLoc
block|,
name|NumExpansions
block|}
decl_stmt|;
name|Elements
operator|.
name|push_back
argument_list|(
name|Expansion
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Record right away that the argument was changed.  This needs
comment|// to happen even if the array expands to nothing.
name|ArgChanged
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_comment
comment|// The transform has determined that we should perform an elementwise
end_comment

begin_comment
comment|// expansion of the pattern. Do so.
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
operator|*
name|NumExpansions
condition|;
operator|++
name|I
control|)
block|{
name|Sema
operator|::
name|ArgumentPackSubstitutionIndexRAII
name|SubstIndex
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|ExprResult
name|Key
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Key
argument_list|)
decl_stmt|;
if|if
condition|(
name|Key
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|Value
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Value
argument_list|)
decl_stmt|;
if|if
condition|(
name|Value
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ObjCDictionaryElement
name|Element
init|=
block|{
name|Key
operator|.
name|get
argument_list|()
block|,
name|Value
operator|.
name|get
argument_list|()
block|,
name|SourceLocation
argument_list|()
block|,
name|NumExpansions
block|}
decl_stmt|;
comment|// If any unexpanded parameter packs remain, we still have a
comment|// pack expansion.
if|if
condition|(
name|Key
operator|.
name|get
argument_list|()
operator|->
name|containsUnexpandedParameterPack
argument_list|()
operator|||
name|Value
operator|.
name|get
argument_list|()
operator|->
name|containsUnexpandedParameterPack
argument_list|()
condition|)
name|Element
operator|.
name|EllipsisLoc
operator|=
name|OrigElement
operator|.
name|EllipsisLoc
expr_stmt|;
name|Elements
operator|.
name|push_back
argument_list|(
name|Element
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// We've finished with this pack expansion.
end_comment

begin_continue
continue|continue;
end_continue

begin_comment
unit|}
comment|// Transform and check key.
end_comment

begin_expr_stmt
unit|ExprResult
name|Key
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Key
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Key
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|Key
operator|.
name|get
argument_list|()
operator|!=
name|OrigElement
operator|.
name|Key
condition|)
name|ArgChanged
operator|=
name|true
expr_stmt|;
end_if

begin_comment
comment|// Transform and check value.
end_comment

begin_decl_stmt
name|ExprResult
name|Value
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OrigElement
operator|.
name|Value
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Value
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|Value
operator|.
name|get
argument_list|()
operator|!=
name|OrigElement
operator|.
name|Value
condition|)
name|ArgChanged
operator|=
name|true
expr_stmt|;
end_if

begin_decl_stmt
name|ObjCDictionaryElement
name|Element
init|=
block|{
name|Key
operator|.
name|get
argument_list|()
block|,
name|Value
operator|.
name|get
argument_list|()
block|,
name|SourceLocation
argument_list|()
block|,
name|None
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Elements
operator|.
name|push_back
argument_list|(
name|Element
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    if
operator|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgChanged
operator|)
end_expr_stmt

begin_return
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_return

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCDictionaryLiteral
argument_list|(
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|,
name|Elements
operator|.
name|data
argument_list|()
argument_list|,
name|Elements
operator|.
name|size
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCEncodeExpr
argument_list|(
argument|ObjCEncodeExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|EncodedTypeInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getEncodedTypeSourceInfo
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|EncodedTypeInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|EncodedTypeInfo
operator|==
name|E
operator|->
name|getEncodedTypeSourceInfo
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCEncodeExpr
argument_list|(
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
name|EncodedTypeInfo
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCIndirectCopyRestoreExpr
argument_list|(
argument|ObjCIndirectCopyRestoreExpr *E
argument_list|)
block|{
comment|// This is a kind of implicit conversion, and it needs to get dropped
comment|// and recomputed for the same general reasons that ImplicitCastExprs
comment|// do, as well a more specific one: this expression is only valid when
comment|// it appears *immediately* as an argument expression.
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCBridgedCastExpr
argument_list|(
argument|ObjCBridgedCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|TSInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|TSInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|ExprResult
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TSInfo
operator|==
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
operator|&&
name|Result
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|SemaRef
operator|.
name|BuildObjCBridgedCast
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getBridgeKind
argument_list|()
argument_list|,
name|E
operator|->
name|getBridgeKeywordLoc
argument_list|()
argument_list|,
name|TSInfo
argument_list|,
name|Result
operator|.
name|get
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCMessageExpr
argument_list|(
argument|ObjCMessageExpr *E
argument_list|)
block|{
comment|// Transform arguments.
name|bool
name|ArgChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|Args
block|;
name|Args
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getArgs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|,
name|false
argument_list|,
name|Args
argument_list|,
operator|&
name|ArgChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getReceiverKind
argument_list|()
operator|==
name|ObjCMessageExpr
operator|::
name|Class
condition|)
block|{
comment|// Class message: transform the receiver type.
name|TypeSourceInfo
modifier|*
name|ReceiverTypeInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getClassReceiverTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ReceiverTypeInfo
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// If nothing changed, just retain the existing message send.
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|ReceiverTypeInfo
operator|==
name|E
operator|->
name|getClassReceiverTypeInfo
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
comment|// Build a new class message send.
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|16
operator|>
name|SelLocs
expr_stmt|;
name|E
operator|->
name|getSelectorLocs
argument_list|(
name|SelLocs
argument_list|)
expr_stmt|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCMessageExpr
argument_list|(
name|ReceiverTypeInfo
argument_list|,
name|E
operator|->
name|getSelector
argument_list|()
argument_list|,
name|SelLocs
argument_list|,
name|E
operator|->
name|getMethodDecl
argument_list|()
argument_list|,
name|E
operator|->
name|getLeftLoc
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getRightLoc
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// Instance message: transform the receiver
end_comment

begin_expr_stmt
name|assert
argument_list|(
name|E
operator|->
name|getReceiverKind
argument_list|()
operator|==
name|ObjCMessageExpr
operator|::
name|Instance
operator|&&
literal|"Only class and instance messages may be instantiated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ExprResult
name|Receiver
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInstanceReceiver
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Receiver
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// If nothing changed, just retain the existing message send.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Receiver
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getInstanceReceiver
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|MaybeBindToTemporary
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_comment
comment|// Build a new instance message send.
end_comment

begin_expr_stmt
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|16
operator|>
name|SelLocs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|E
operator|->
name|getSelectorLocs
argument_list|(
name|SelLocs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCMessageExpr
argument_list|(
name|Receiver
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getSelector
argument_list|()
argument_list|,
name|SelLocs
argument_list|,
name|E
operator|->
name|getMethodDecl
argument_list|()
argument_list|,
name|E
operator|->
name|getLeftLoc
argument_list|()
argument_list|,
name|Args
argument_list|,
name|E
operator|->
name|getRightLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCSelectorExpr
argument_list|(
argument|ObjCSelectorExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCProtocolExpr
argument_list|(
argument|ObjCProtocolExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCIvarRefExpr
argument_list|(
argument|ObjCIvarRefExpr *E
argument_list|)
block|{
comment|// Transform the base expression.
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// We don't need to transform the ivar; it will never change.
end_comment

begin_comment
comment|// If nothing changed, just retain the existing expression.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCIvarRefExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getDecl
argument_list|()
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|E
operator|->
name|isFreeIvar
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCPropertyRefExpr
argument_list|(
argument|ObjCPropertyRefExpr *E
argument_list|)
block|{
comment|// 'super' and types never change. Property never changes. Just
comment|// retain the existing expression.
if|if
condition|(
operator|!
name|E
operator|->
name|isObjectReceiver
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
comment|// Transform the base expression.
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// We don't need to transform the property; it will never change.
end_comment

begin_comment
comment|// If nothing changed, just retain the existing expression.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_if
if|if
condition|(
name|E
operator|->
name|isExplicitProperty
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCPropertyRefExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getExplicitProperty
argument_list|()
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCPropertyRefExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|PseudoObjectTy
argument_list|,
name|E
operator|->
name|getImplicitPropertyGetter
argument_list|()
argument_list|,
name|E
operator|->
name|getImplicitPropertySetter
argument_list|()
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCSubscriptRefExpr
argument_list|(
argument|ObjCSubscriptRefExpr *E
argument_list|)
block|{
comment|// Transform the base expression.
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBaseExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
comment|// Transform the key expression.
name|ExprResult
name|Key
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getKeyExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Key
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// If nothing changed, just retain the existing expression.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Key
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getKeyExpr
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBaseExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCSubscriptRefExpr
argument_list|(
name|E
operator|->
name|getRBracket
argument_list|()
argument_list|,
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|Key
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getAtIndexMethodDecl
argument_list|()
argument_list|,
name|E
operator|->
name|setAtIndexMethodDecl
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCIsaExpr
argument_list|(
argument|ObjCIsaExpr *E
argument_list|)
block|{
comment|// Transform the base expression.
name|ExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// If nothing changed, just retain the existing expression.
end_comment

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCIsaExpr
argument_list|(
name|Base
operator|.
name|get
argument_list|()
argument_list|,
name|E
operator|->
name|getIsaMemberLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getOpLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformShuffleVectorExpr
argument_list|(
argument|ShuffleVectorExpr *E
argument_list|)
block|{
name|bool
name|ArgumentChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|SubExprs
block|;
name|SubExprs
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|getNumSubExprs
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getSubExprs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumSubExprs
argument_list|()
argument_list|,
name|false
argument_list|,
name|SubExprs
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildShuffleVectorExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|SubExprs
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformConvertVectorExpr
argument_list|(
argument|ConvertVectorExpr *E
argument_list|)
block|{
name|ExprResult
name|SrcExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSrcExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SrcExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
name|TypeSourceInfo
operator|*
name|Type
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Type
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Type
operator|==
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
operator|&&
name|SrcExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSrcExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildConvertVectorExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|SrcExpr
operator|.
name|get
argument_list|()
argument_list|,
name|Type
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBlockExpr
argument_list|(
argument|BlockExpr *E
argument_list|)
block|{
name|BlockDecl
operator|*
name|oldBlock
operator|=
name|E
operator|->
name|getBlockDecl
argument_list|()
block|;
name|SemaRef
operator|.
name|ActOnBlockStart
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|)
block|;
name|BlockScopeInfo
operator|*
name|blockScope
operator|=
name|SemaRef
operator|.
name|getCurBlock
argument_list|()
block|;
name|blockScope
operator|->
name|TheDecl
operator|->
name|setIsVariadic
argument_list|(
name|oldBlock
operator|->
name|isVariadic
argument_list|()
argument_list|)
block|;
name|blockScope
operator|->
name|TheDecl
operator|->
name|setBlockMissingReturnType
argument_list|(
name|oldBlock
operator|->
name|blockMissingReturnType
argument_list|()
argument_list|)
block|;
name|SmallVector
operator|<
name|ParmVarDecl
operator|*
block|,
literal|4
operator|>
name|params
block|;
name|SmallVector
operator|<
name|QualType
block|,
literal|4
operator|>
name|paramTypes
block|;
comment|// Parameter substitution.
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParams
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
name|oldBlock
operator|->
name|param_begin
argument_list|()
argument_list|,
name|oldBlock
operator|->
name|param_size
argument_list|()
argument_list|,
literal|0
argument_list|,
name|paramTypes
argument_list|,
operator|&
name|params
argument_list|)
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnBlockError
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
specifier|const
name|FunctionProtoType
operator|*
name|exprFunctionType
operator|=
name|E
operator|->
name|getFunctionType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|exprResultType
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|exprFunctionType
operator|->
name|getResultType
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|functionType
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildFunctionProtoType
argument_list|(
name|exprResultType
argument_list|,
name|paramTypes
argument_list|,
name|exprFunctionType
operator|->
name|getExtProtoInfo
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|blockScope
operator|->
name|FunctionType
operator|=
name|functionType
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set the parameters on the block decl.
end_comment

begin_if
if|if
condition|(
operator|!
name|params
operator|.
name|empty
argument_list|()
condition|)
name|blockScope
operator|->
name|TheDecl
operator|->
name|setParams
argument_list|(
name|params
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|oldBlock
operator|->
name|blockMissingReturnType
argument_list|()
condition|)
block|{
name|blockScope
operator|->
name|HasImplicitReturnType
operator|=
name|false
expr_stmt|;
name|blockScope
operator|->
name|ReturnType
operator|=
name|exprResultType
expr_stmt|;
block|}
end_if

begin_comment
comment|// Transform the body
end_comment

begin_decl_stmt
name|StmtResult
name|body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|E
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|body
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnBlockError
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|// In builds with assertions, make sure that we captured everything we
end_comment

begin_comment
comment|// captured before.
end_comment

begin_if
if|if
condition|(
operator|!
name|SemaRef
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|hasErrorOccurred
argument_list|()
condition|)
block|{
for|for
control|(
name|BlockDecl
operator|::
name|capture_iterator
name|i
operator|=
name|oldBlock
operator|->
name|capture_begin
argument_list|()
operator|,
name|e
operator|=
name|oldBlock
operator|->
name|capture_end
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|VarDecl
modifier|*
name|oldCapture
init|=
name|i
operator|->
name|getVariable
argument_list|()
decl_stmt|;
comment|// Ignore parameter packs.
if|if
condition|(
name|isa
operator|<
name|ParmVarDecl
operator|>
operator|(
name|oldCapture
operator|)
operator|&&
name|cast
operator|<
name|ParmVarDecl
operator|>
operator|(
name|oldCapture
operator|)
operator|->
name|isParameterPack
argument_list|()
condition|)
continue|continue;
name|VarDecl
modifier|*
name|newCapture
init|=
name|cast
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
name|oldCapture
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|blockScope
operator|->
name|CaptureMap
operator|.
name|count
argument_list|(
name|newCapture
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|oldBlock
operator|->
name|capturesCXXThis
argument_list|()
operator|==
name|blockScope
operator|->
name|isCXXThisCaptured
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|SemaRef
operator|.
name|ActOnBlockStmtExpr
argument_list|(
name|E
operator|->
name|getCaretLocation
argument_list|()
argument_list|,
name|body
operator|.
name|get
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAsTypeExpr
argument_list|(
argument|AsTypeExpr *E
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Cannot transform asType expressions yet"
argument_list|)
block|; }
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAtomicExpr
argument_list|(
argument|AtomicExpr *E
argument_list|)
block|{
name|QualType
name|RetTy
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
name|bool
name|ArgumentChanged
operator|=
name|false
block|;
name|SmallVector
operator|<
name|Expr
operator|*
block|,
literal|8
operator|>
name|SubExprs
block|;
name|SubExprs
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|getNumSubExprs
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformExprs
argument_list|(
name|E
operator|->
name|getSubExprs
argument_list|()
argument_list|,
name|E
operator|->
name|getNumSubExprs
argument_list|()
argument_list|,
name|false
argument_list|,
name|SubExprs
argument_list|,
operator|&
name|ArgumentChanged
argument_list|)
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildAtomicExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|SubExprs
argument_list|,
name|RetTy
argument_list|,
name|E
operator|->
name|getOp
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Type reconstruction
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|SourceLocation Star
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildPointerType
argument_list|(
name|PointeeType
argument_list|,
name|Star
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildBlockPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|SourceLocation Star
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildBlockPointerType
argument_list|(
name|PointeeType
argument_list|,
name|Star
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildReferenceType
argument_list|(
argument|QualType ReferentType
argument_list|,
argument|bool WrittenAsLValue
argument_list|,
argument|SourceLocation Sigil
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildReferenceType
argument_list|(
name|ReferentType
argument_list|,
name|WrittenAsLValue
argument_list|,
name|Sigil
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildMemberPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|QualType ClassType
argument_list|,
argument|SourceLocation Sigil
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildMemberPointerType
argument_list|(
name|PointeeType
argument_list|,
name|ClassType
argument_list|,
name|Sigil
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|const llvm::APInt *Size
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
if|if
condition|(
name|SizeExpr
operator|||
operator|!
name|Size
condition|)
return|return
name|SemaRef
operator|.
name|BuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
name|SizeExpr
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
name|QualType
name|Types
index|[]
operator|=
block|{
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedCharTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedShortTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedIntTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedLongTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedLongLongTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedInt128Ty
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|unsigned
name|NumTypes
init|=
name|llvm
operator|::
name|array_lengthof
argument_list|(
name|Types
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|SizeType
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|NumTypes
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|Size
operator|->
name|getBitWidth
argument_list|()
operator|==
name|SemaRef
operator|.
name|Context
operator|.
name|getIntWidth
argument_list|(
name|Types
index|[
name|I
index|]
argument_list|)
condition|)
block|{
name|SizeType
operator|=
name|Types
index|[
name|I
index|]
expr_stmt|;
break|break;
block|}
end_for

begin_comment
comment|// Note that we can return a VariableArrayType here in the case where
end_comment

begin_comment
comment|// the element type was a dependent VariableArrayType.
end_comment

begin_decl_stmt
name|IntegerLiteral
modifier|*
name|ArraySize
init|=
name|IntegerLiteral
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
operator|*
name|Size
argument_list|,
name|SizeType
argument_list|,
comment|/*FIXME*/
name|BracketsRange
operator|.
name|getBegin
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|SemaRef
operator|.
name|BuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
name|ArraySize
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildConstantArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|const llvm::APInt&Size
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
operator|&
name|Size
argument_list|,
literal|0
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildIncompleteArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildVariableArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
name|SizeExpr
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDependentSizedArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
name|SizeExpr
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|unsigned NumElements
argument_list|,
argument|VectorType::VectorKind VecKind
argument_list|)
block|{
comment|// FIXME: semantic checking!
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getVectorType
argument_list|(
name|ElementType
argument_list|,
name|NumElements
argument_list|,
name|VecKind
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildExtVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|unsigned NumElements
argument_list|,
argument|SourceLocation AttributeLoc
argument_list|)
block|{
name|llvm
operator|::
name|APInt
name|numElements
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getIntWidth
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|IntTy
argument_list|)
argument_list|,
name|NumElements
argument_list|,
name|true
argument_list|)
block|;
name|IntegerLiteral
operator|*
name|VectorSize
operator|=
name|IntegerLiteral
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|numElements
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|IntTy
argument_list|,
name|AttributeLoc
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|BuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|VectorSize
argument_list|,
name|AttributeLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDependentSizedExtVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|SourceLocation AttributeLoc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|SizeExpr
argument_list|,
name|AttributeLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildFunctionProtoType
argument_list|(
argument|QualType T
argument_list|,
argument|llvm::MutableArrayRef<QualType> ParamTypes
argument_list|,
argument|const FunctionProtoType::ExtProtoInfo&EPI
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildFunctionType
argument_list|(
name|T
argument_list|,
name|ParamTypes
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|,
name|EPI
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildFunctionNoProtoType
argument_list|(
argument|QualType T
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getFunctionNoProtoType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildUnresolvedUsingType
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|assert
argument_list|(
name|D
operator|&&
literal|"no decl found"
argument_list|)
block|;
if|if
condition|(
name|D
operator|->
name|isInvalidDecl
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// FIXME: Doesn't account for ObjCInterfaceDecl!
name|TypeDecl
operator|*
name|Ty
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|D
operator|)
condition|)
block|{
name|UsingDecl
modifier|*
name|Using
init|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|D
operator|)
decl_stmt|;
name|assert
argument_list|(
name|Using
operator|->
name|hasTypename
argument_list|()
operator|&&
literal|"UnresolvedUsingTypenameDecl transformed to non-typename using"
argument_list|)
expr_stmt|;
comment|// A valid resolved using typename decl points to exactly one type decl.
name|assert
argument_list|(
operator|++
name|Using
operator|->
name|shadow_begin
argument_list|()
operator|==
name|Using
operator|->
name|shadow_end
argument_list|()
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|cast
operator|<
name|TypeDecl
operator|>
operator|(
operator|(
operator|*
name|Using
operator|->
name|shadow_begin
argument_list|()
operator|)
operator|->
name|getTargetDecl
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|isa
operator|<
name|UnresolvedUsingTypenameDecl
operator|>
operator|(
name|D
operator|)
operator|&&
literal|"UnresolvedUsingTypenameDecl transformed to non-using decl"
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|cast
operator|<
name|UnresolvedUsingTypenameDecl
operator|>
operator|(
name|D
operator|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Ty
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTypeOfExprType
argument_list|(
argument|Expr *E
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildTypeofExprType
argument_list|(
name|E
argument_list|,
name|Loc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTypeOfType
argument_list|(
argument|QualType Underlying
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeOfType
argument_list|(
name|Underlying
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDecltypeType
argument_list|(
argument|Expr *E
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildDecltypeType
argument_list|(
name|E
argument_list|,
name|Loc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildUnaryTransformType
argument_list|(
argument|QualType BaseType
argument_list|,
argument|UnaryTransformType::UTTKind UKind
argument_list|,
argument|SourceLocation Loc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildUnaryTransformType
argument_list|(
name|BaseType
argument_list|,
name|UKind
argument_list|,
name|Loc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateSpecializationType
argument_list|(
argument|TemplateName Template
argument_list|,
argument|SourceLocation TemplateNameLoc
argument_list|,
argument|TemplateArgumentListInfo&TemplateArgs
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|CheckTemplateIdType
argument_list|(
name|Template
argument_list|,
name|TemplateNameLoc
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildAtomicType
argument_list|(
argument|QualType ValueType
argument_list|,
argument|SourceLocation KWLoc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildAtomicType
argument_list|(
name|ValueType
argument_list|,
name|KWLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|CXXScopeSpec&SS
argument_list|,
argument|bool TemplateKW
argument_list|,
argument|TemplateDecl *Template
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedTemplateName
argument_list|(
name|SS
operator|.
name|getScopeRep
argument_list|()
argument_list|,
name|TemplateKW
argument_list|,
name|Template
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|CXXScopeSpec&SS
argument_list|,
argument|const IdentifierInfo&Name
argument_list|,
argument|SourceLocation NameLoc
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *FirstQualifierInScope
argument_list|)
block|{
name|UnqualifiedId
name|TemplateName
block|;
name|TemplateName
operator|.
name|setIdentifier
argument_list|(
operator|&
name|Name
argument_list|,
name|NameLoc
argument_list|)
block|;
name|Sema
operator|::
name|TemplateTy
name|Template
block|;
name|SourceLocation
name|TemplateKWLoc
block|;
comment|// FIXME: retrieve it from caller.
name|getSema
argument_list|()
operator|.
name|ActOnDependentTemplateName
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|TemplateName
argument_list|,
name|ParsedType
operator|::
name|make
argument_list|(
name|ObjectType
argument_list|)
argument_list|,
comment|/*EnteringContext=*/
name|false
argument_list|,
name|Template
argument_list|)
block|;
return|return
name|Template
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|CXXScopeSpec&SS
argument_list|,
argument|OverloadedOperatorKind Operator
argument_list|,
argument|SourceLocation NameLoc
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|UnqualifiedId
name|Name
block|;
comment|// FIXME: Bogus location information.
name|SourceLocation
name|SymbolLocations
index|[
literal|3
index|]
operator|=
block|{
name|NameLoc
block|,
name|NameLoc
block|,
name|NameLoc
block|}
block|;
name|Name
operator|.
name|setOperatorFunctionId
argument_list|(
name|NameLoc
argument_list|,
name|Operator
argument_list|,
name|SymbolLocations
argument_list|)
block|;
name|SourceLocation
name|TemplateKWLoc
block|;
comment|// FIXME: retrieve it from caller.
name|Sema
operator|::
name|TemplateTy
name|Template
block|;
name|getSema
argument_list|()
operator|.
name|ActOnDependentTemplateName
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
name|Name
argument_list|,
name|ParsedType
operator|::
name|make
argument_list|(
name|ObjectType
argument_list|)
argument_list|,
comment|/*EnteringContext=*/
name|false
argument_list|,
name|Template
argument_list|)
block|;
return|return
name|Template
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildCXXOperatorCallExpr
argument_list|(
argument|OverloadedOperatorKind Op
argument_list|,
argument|SourceLocation OpLoc
argument_list|,
argument|Expr *OrigCallee
argument_list|,
argument|Expr *First
argument_list|,
argument|Expr *Second
argument_list|)
block|{
name|Expr
operator|*
name|Callee
operator|=
name|OrigCallee
operator|->
name|IgnoreParenCasts
argument_list|()
block|;
name|bool
name|isPostIncDec
operator|=
name|Second
operator|&&
operator|(
name|Op
operator|==
name|OO_PlusPlus
operator|||
name|Op
operator|==
name|OO_MinusMinus
operator|)
block|;
comment|// Determine whether this should be a builtin operation.
if|if
condition|(
name|Op
operator|==
name|OO_Subscript
condition|)
block|{
if|if
condition|(
operator|!
name|First
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
operator|&&
operator|!
name|Second
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|CreateBuiltinArraySubscriptExpr
argument_list|(
name|First
argument_list|,
name|Callee
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Second
argument_list|,
name|OpLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|Op
operator|==
name|OO_Arrow
condition|)
block|{
comment|// -> is never a builtin operation.
return|return
name|SemaRef
operator|.
name|BuildOverloadedArrowExpr
argument_list|(
literal|0
argument_list|,
name|First
argument_list|,
name|OpLoc
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|Second
operator|==
literal|0
operator|||
name|isPostIncDec
condition|)
block|{
if|if
condition|(
operator|!
name|First
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
block|{
comment|// The argument is not of overloadable type, so try to create a
comment|// built-in unary operation.
name|UnaryOperatorKind
name|Opc
init|=
name|UnaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|,
name|isPostIncDec
argument_list|)
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|CreateBuiltinUnaryOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|First
argument_list|)
return|;
block|}
block|}
end_elseif

begin_else
else|else
block|{
if|if
condition|(
operator|!
name|First
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
operator|&&
operator|!
name|Second
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
block|{
comment|// Neither of the arguments is an overloadable type, so try to
comment|// create a built-in binary operation.
name|BinaryOperatorKind
name|Opc
init|=
name|BinaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|)
decl_stmt|;
name|ExprResult
name|Result
init|=
name|SemaRef
operator|.
name|CreateBuiltinBinOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|First
argument_list|,
name|Second
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
return|return
name|Result
return|;
block|}
block|}
end_else

begin_comment
comment|// Compute the transformed set of functions (and function templates) to be
end_comment

begin_comment
comment|// used during overload resolution.
end_comment

begin_expr_stmt
name|UnresolvedSet
operator|<
literal|16
operator|>
name|Functions
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|UnresolvedLookupExpr
modifier|*
name|ULE
init|=
name|dyn_cast
operator|<
name|UnresolvedLookupExpr
operator|>
operator|(
name|Callee
operator|)
condition|)
block|{
name|assert
argument_list|(
name|ULE
operator|->
name|requiresADL
argument_list|()
argument_list|)
expr_stmt|;
comment|// FIXME: Do we have to check
comment|// IsAcceptableNonMemberOperatorCandidate for each of these?
name|Functions
operator|.
name|append
argument_list|(
name|ULE
operator|->
name|decls_begin
argument_list|()
argument_list|,
name|ULE
operator|->
name|decls_end
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we've resolved this to a particular non-member function, just call
comment|// that function. If we resolved it to a member function,
comment|// CreateOverloaded* will find that function for us.
name|NamedDecl
modifier|*
name|ND
init|=
name|cast
operator|<
name|DeclRefExpr
operator|>
operator|(
name|Callee
operator|)
operator|->
name|getDecl
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isa
operator|<
name|CXXMethodDecl
operator|>
operator|(
name|ND
operator|)
condition|)
name|Functions
operator|.
name|addDecl
argument_list|(
name|ND
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Add any functions found via argument-dependent lookup.
end_comment

begin_decl_stmt
name|Expr
modifier|*
name|Args
index|[
literal|2
index|]
init|=
block|{
name|First
block|,
name|Second
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumArgs
init|=
literal|1
operator|+
operator|(
name|Second
operator|!=
literal|0
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Create the overloaded operator invocation for unary operators.
end_comment

begin_if
if|if
condition|(
name|NumArgs
operator|==
literal|1
operator|||
name|isPostIncDec
condition|)
block|{
name|UnaryOperatorKind
name|Opc
init|=
name|UnaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|,
name|isPostIncDec
argument_list|)
decl_stmt|;
return|return
name|SemaRef
operator|.
name|CreateOverloadedUnaryOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|Functions
argument_list|,
name|First
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|Op
operator|==
name|OO_Subscript
condition|)
block|{
name|SourceLocation
name|LBrace
decl_stmt|;
name|SourceLocation
name|RBrace
decl_stmt|;
if|if
condition|(
name|DeclRefExpr
modifier|*
name|DRE
init|=
name|dyn_cast
operator|<
name|DeclRefExpr
operator|>
operator|(
name|Callee
operator|)
condition|)
block|{
name|DeclarationNameLoc
modifier|&
name|NameLoc
init|=
name|DRE
operator|->
name|getNameInfo
argument_list|()
operator|.
name|getInfo
argument_list|()
decl_stmt|;
name|LBrace
operator|=
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|NameLoc
operator|.
name|CXXOperatorName
operator|.
name|BeginOpNameLoc
argument_list|)
expr_stmt|;
name|RBrace
operator|=
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|NameLoc
operator|.
name|CXXOperatorName
operator|.
name|EndOpNameLoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LBrace
operator|=
name|Callee
operator|->
name|getLocStart
argument_list|()
expr_stmt|;
name|RBrace
operator|=
name|OpLoc
expr_stmt|;
block|}
return|return
name|SemaRef
operator|.
name|CreateOverloadedArraySubscriptExpr
argument_list|(
name|LBrace
argument_list|,
name|RBrace
argument_list|,
name|First
argument_list|,
name|Second
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// Create the overloaded operator invocation for binary operators.
end_comment

begin_decl_stmt
name|BinaryOperatorKind
name|Opc
init|=
name|BinaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ExprResult
name|Result
init|=
name|SemaRef
operator|.
name|CreateOverloadedBinOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|Functions
argument_list|,
name|Args
index|[
literal|0
index|]
argument_list|,
name|Args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|ExprError
argument_list|()
return|;
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildCXXPseudoDestructorExpr
argument_list|(
argument|Expr *Base
argument_list|,
argument|SourceLocation OperatorLoc
argument_list|,
argument|bool isArrow
argument_list|,
argument|CXXScopeSpec&SS
argument_list|,
argument|TypeSourceInfo *ScopeType
argument_list|,
argument|SourceLocation CCLoc
argument_list|,
argument|SourceLocation TildeLoc
argument_list|,
argument|PseudoDestructorTypeStorage Destroyed
argument_list|)
block|{
name|QualType
name|BaseType
operator|=
name|Base
operator|->
name|getType
argument_list|()
block|;
if|if
condition|(
name|Base
operator|->
name|isTypeDependent
argument_list|()
operator|||
name|Destroyed
operator|.
name|getIdentifier
argument_list|()
operator|||
operator|(
operator|!
name|isArrow
operator|&&
operator|!
name|BaseType
operator|->
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
operator|)
operator|||
operator|(
name|isArrow
operator|&&
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|&&
operator|!
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|->
name|getPointeeType
argument_list|()
operator|->
name|template
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
operator|)
condition|)
block|{
comment|// This pseudo-destructor expression is still a pseudo-destructor.
return|return
name|SemaRef
operator|.
name|BuildPseudoDestructorExpr
argument_list|(
name|Base
argument_list|,
name|OperatorLoc
argument_list|,
name|isArrow
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|SS
argument_list|,
name|ScopeType
argument_list|,
name|CCLoc
argument_list|,
name|TildeLoc
argument_list|,
name|Destroyed
argument_list|,
comment|/*FIXME?*/
name|true
argument_list|)
return|;
block|}
name|TypeSourceInfo
operator|*
name|DestroyedType
operator|=
name|Destroyed
operator|.
name|getTypeSourceInfo
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DeclarationName
name|Name
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|DeclarationNames
operator|.
name|getCXXDestructorName
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|DestroyedType
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeclarationNameInfo
name|NameInfo
argument_list|(
name|Name
argument_list|,
name|Destroyed
operator|.
name|getLocation
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NameInfo
operator|.
name|setNamedTypeInfo
argument_list|(
name|DestroyedType
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// The scope type is now known to be a valid nested name specifier
end_comment

begin_comment
comment|// component. Tack it on to the end of the nested name specifier.
end_comment

begin_if
if|if
condition|(
name|ScopeType
condition|)
name|SS
operator|.
name|Extend
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
name|ScopeType
operator|->
name|getTypeLoc
argument_list|()
argument_list|,
name|CCLoc
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|SourceLocation
name|TemplateKWLoc
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: retrieve it from caller.
end_comment

begin_return
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|Base
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|isArrow
argument_list|,
name|SS
argument_list|,
name|TemplateKWLoc
argument_list|,
comment|/*FIXME: FirstQualifier*/
literal|0
argument_list|,
name|NameInfo
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|StmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCapturedStmt
argument_list|(
argument|CapturedStmt *S
argument_list|)
block|{
name|SourceLocation
name|Loc
operator|=
name|S
operator|->
name|getLocStart
argument_list|()
block|;
name|unsigned
name|NumParams
operator|=
name|S
operator|->
name|getCapturedDecl
argument_list|()
operator|->
name|getNumParams
argument_list|()
block|;
name|getSema
argument_list|()
operator|.
name|ActOnCapturedRegionStart
argument_list|(
name|Loc
argument_list|,
comment|/*CurScope*/
literal|0
argument_list|,
name|S
operator|->
name|getCapturedRegionKind
argument_list|()
argument_list|,
name|NumParams
argument_list|)
block|;
name|StmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getCapturedStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnCapturedRegionError
argument_list|()
expr_stmt|;
return|return
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_return
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCapturedRegionEnd
argument_list|(
name|Body
operator|.
name|take
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}  }
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_SEMA_TREETRANSFORM_H
end_comment

end_unit

