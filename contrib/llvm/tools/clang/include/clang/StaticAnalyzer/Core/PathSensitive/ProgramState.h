begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== ProgramState.h - Path-sensitive "State" for tracking values -*- C++ -*--=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the state of the program along the analysisa path.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_PROGRAMSTATE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_PROGRAMSTATE_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/Environment.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/Store.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/TaintTag.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ImmutableMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|APSInt
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|namespace
name|ento
block|{
name|class
name|CallEvent
decl_stmt|;
name|class
name|CallEventManager
decl_stmt|;
typedef|typedef
name|std
operator|::
name|unique_ptr
operator|<
name|ConstraintManager
operator|>
call|(
modifier|*
name|ConstraintManagerCreator
call|)
argument_list|(
name|ProgramStateManager
operator|&
argument_list|,
name|SubEngine
operator|*
argument_list|)
expr_stmt|;
typedef|typedef
name|std
operator|::
name|unique_ptr
operator|<
name|StoreManager
operator|>
call|(
modifier|*
name|StoreManagerCreator
call|)
argument_list|(
name|ProgramStateManager
operator|&
argument_list|)
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|ImmutableMap
operator|<
specifier|const
name|SubRegion
operator|*
operator|,
name|TaintTagType
operator|>
name|TaintedSubRegions
expr_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// ProgramStateTrait - Traits used by the Generic Data Map of a ProgramState.
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ProgramStatePartialTrait
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ProgramStateTrait
block|{
typedef|typedef
name|typename
name|T
operator|::
name|data_type
name|data_type
expr_stmt|;
specifier|static
specifier|inline
name|void
operator|*
name|MakeVoidPtr
argument_list|(
argument|data_type D
argument_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|D
return|;
block|}
specifier|static
specifier|inline
name|data_type
name|MakeData
argument_list|(
argument|void *const* P
argument_list|)
block|{
return|return
name|P
operator|?
operator|(
name|data_type
operator|)
operator|*
name|P
operator|:
operator|(
name|data_type
operator|)
literal|0
return|;
block|}
block|}
empty_stmt|;
comment|/// \class ProgramState
comment|/// ProgramState - This class encapsulates:
comment|///
comment|///    1. A mapping from expressions to values (Environment)
comment|///    2. A mapping from locations to values (Store)
comment|///    3. Constraints on symbolic values (GenericDataMap)
comment|///
comment|///  Together these represent the "abstract state" of a program.
comment|///
comment|///  ProgramState is intended to be used as a functional object; that is,
comment|///  once it is created and made "persistent" in a FoldingSet, its
comment|///  values will never change.
name|class
name|ProgramState
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
typedef|typedef
name|llvm
operator|::
name|ImmutableSet
operator|<
name|llvm
operator|::
name|APSInt
operator|*
operator|>
name|IntSetTy
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|ImmutableMap
operator|<
name|void
operator|*
operator|,
name|void
operator|*
operator|>
name|GenericDataMap
expr_stmt|;
name|private
label|:
name|void
name|operator
init|=
operator|(
specifier|const
name|ProgramState
operator|&
name|R
operator|)
operator|=
name|delete
decl_stmt|;
name|friend
name|class
name|ProgramStateManager
decl_stmt|;
name|friend
name|class
name|ExplodedGraph
decl_stmt|;
name|friend
name|class
name|ExplodedNode
decl_stmt|;
name|ProgramStateManager
modifier|*
name|stateMgr
decl_stmt|;
name|Environment
name|Env
decl_stmt|;
comment|// Maps a Stmt to its current SVal.
name|Store
name|store
decl_stmt|;
comment|// Maps a location to its current value.
name|GenericDataMap
name|GDM
decl_stmt|;
comment|// Custom data stored by a client of this class.
name|unsigned
name|refCount
decl_stmt|;
comment|/// makeWithStore - Return a ProgramState with the same values as the current
comment|///  state with the exception of using the specified Store.
name|ProgramStateRef
name|makeWithStore
argument_list|(
specifier|const
name|StoreRef
operator|&
name|store
argument_list|)
decl|const
decl_stmt|;
name|void
name|setStore
parameter_list|(
specifier|const
name|StoreRef
modifier|&
name|storeRef
parameter_list|)
function_decl|;
name|public
label|:
comment|/// This ctor is used when creating the first ProgramState object.
name|ProgramState
argument_list|(
argument|ProgramStateManager *mgr
argument_list|,
argument|const Environment& env
argument_list|,
argument|StoreRef st
argument_list|,
argument|GenericDataMap gdm
argument_list|)
empty_stmt|;
comment|/// Copy ctor - We must explicitly define this or else the "Next" ptr
comment|///  in FoldingSetNode will also get copied.
name|ProgramState
argument_list|(
specifier|const
name|ProgramState
operator|&
name|RHS
argument_list|)
expr_stmt|;
operator|~
name|ProgramState
argument_list|()
expr_stmt|;
comment|/// Return the ProgramStateManager associated with this state.
name|ProgramStateManager
operator|&
name|getStateManager
argument_list|()
specifier|const
block|{
return|return
operator|*
name|stateMgr
return|;
block|}
comment|/// Return the ConstraintManager.
name|ConstraintManager
operator|&
name|getConstraintManager
argument_list|()
specifier|const
expr_stmt|;
comment|/// getEnvironment - Return the environment associated with this state.
comment|///  The environment is the mapping from expressions to values.
specifier|const
name|Environment
operator|&
name|getEnvironment
argument_list|()
specifier|const
block|{
return|return
name|Env
return|;
block|}
comment|/// Return the store associated with this state.  The store
comment|///  is a mapping from locations to values.
name|Store
name|getStore
argument_list|()
specifier|const
block|{
return|return
name|store
return|;
block|}
comment|/// getGDM - Return the generic data map associated with this state.
name|GenericDataMap
name|getGDM
argument_list|()
specifier|const
block|{
return|return
name|GDM
return|;
block|}
name|void
name|setGDM
parameter_list|(
name|GenericDataMap
name|gdm
parameter_list|)
block|{
name|GDM
operator|=
name|gdm
expr_stmt|;
block|}
comment|/// Profile - Profile the contents of a ProgramState object for use in a
comment|///  FoldingSet.  Two ProgramState objects are considered equal if they
comment|///  have the same Environment, Store, and GenericDataMap.
specifier|static
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|ProgramState
operator|*
name|V
argument_list|)
block|{
name|V
operator|->
name|Env
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
expr_stmt|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|V
operator|->
name|store
argument_list|)
expr_stmt|;
name|V
operator|->
name|GDM
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
expr_stmt|;
block|}
comment|/// Profile - Used to profile the contents of this object for inclusion
comment|///  in a FoldingSet.
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
name|Profile
argument_list|(
name|ID
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|BasicValueFactory
operator|&
name|getBasicVals
argument_list|()
specifier|const
expr_stmt|;
name|SymbolManager
operator|&
name|getSymbolManager
argument_list|()
specifier|const
expr_stmt|;
comment|//==---------------------------------------------------------------------==//
comment|// Constraints on values.
comment|//==---------------------------------------------------------------------==//
comment|//
comment|// Each ProgramState records constraints on symbolic values.  These constraints
comment|// are managed using the ConstraintManager associated with a ProgramStateManager.
comment|// As constraints gradually accrue on symbolic values, added constraints
comment|// may conflict and indicate that a state is infeasible (as no real values
comment|// could satisfy all the constraints).  This is the principal mechanism
comment|// for modeling path-sensitivity in ExprEngine/ProgramState.
comment|//
comment|// Various "assume" methods form the interface for adding constraints to
comment|// symbolic values.  A call to 'assume' indicates an assumption being placed
comment|// on one or symbolic values.  'assume' methods take the following inputs:
comment|//
comment|//  (1) A ProgramState object representing the current state.
comment|//
comment|//  (2) The assumed constraint (which is specific to a given "assume" method).
comment|//
comment|//  (3) A binary value "Assumption" that indicates whether the constraint is
comment|//      assumed to be true or false.
comment|//
comment|// The output of "assume*" is a new ProgramState object with the added constraints.
comment|// If no new state is feasible, NULL is returned.
comment|//
comment|/// Assumes that the value of \p cond is zero (if \p assumption is "false")
comment|/// or non-zero (if \p assumption is "true").
comment|///
comment|/// This returns a new state with the added constraint on \p cond.
comment|/// If no new state is feasible, NULL is returned.
name|ProgramStateRef
name|assume
argument_list|(
name|DefinedOrUnknownSVal
name|cond
argument_list|,
name|bool
name|assumption
argument_list|)
decl|const
decl_stmt|;
comment|/// Assumes both "true" and "false" for \p cond, and returns both
comment|/// corresponding states (respectively).
comment|///
comment|/// This is more efficient than calling assume() twice. Note that one (but not
comment|/// both) of the returned states may be NULL.
name|std
operator|::
name|pair
operator|<
name|ProgramStateRef
operator|,
name|ProgramStateRef
operator|>
name|assume
argument_list|(
argument|DefinedOrUnknownSVal cond
argument_list|)
specifier|const
expr_stmt|;
name|ProgramStateRef
name|assumeInBound
argument_list|(
name|DefinedOrUnknownSVal
name|idx
argument_list|,
name|DefinedOrUnknownSVal
name|upperBound
argument_list|,
name|bool
name|assumption
argument_list|,
name|QualType
name|IndexType
operator|=
name|QualType
argument_list|()
argument_list|)
decl|const
decl_stmt|;
comment|/// Assumes that the value of \p Val is bounded with [\p From; \p To]
comment|/// (if \p assumption is "true") or it is fully out of this range
comment|/// (if \p assumption is "false").
comment|///
comment|/// This returns a new state with the added constraint on \p cond.
comment|/// If no new state is feasible, NULL is returned.
name|ProgramStateRef
name|assumeInclusiveRange
argument_list|(
name|DefinedOrUnknownSVal
name|Val
argument_list|,
specifier|const
name|llvm
operator|::
name|APSInt
operator|&
name|From
argument_list|,
specifier|const
name|llvm
operator|::
name|APSInt
operator|&
name|To
argument_list|,
name|bool
name|assumption
argument_list|)
decl|const
decl_stmt|;
comment|/// Assumes given range both "true" and "false" for \p Val, and returns both
comment|/// corresponding states (respectively).
comment|///
comment|/// This is more efficient than calling assume() twice. Note that one (but not
comment|/// both) of the returned states may be NULL.
name|std
operator|::
name|pair
operator|<
name|ProgramStateRef
operator|,
name|ProgramStateRef
operator|>
name|assumeInclusiveRange
argument_list|(
argument|DefinedOrUnknownSVal Val
argument_list|,
argument|const llvm::APSInt&From
argument_list|,
argument|const llvm::APSInt&To
argument_list|)
specifier|const
expr_stmt|;
comment|/// \brief Check if the given SVal is constrained to zero or is a zero
comment|///        constant.
name|ConditionTruthVal
name|isNull
argument_list|(
name|SVal
name|V
argument_list|)
decl|const
decl_stmt|;
comment|/// Utility method for getting regions.
specifier|const
name|VarRegion
modifier|*
name|getRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
decl|const
decl_stmt|;
comment|//==---------------------------------------------------------------------==//
comment|// Binding and retrieving values to/from the environment and symbolic store.
comment|//==---------------------------------------------------------------------==//
comment|/// Create a new state by binding the value 'V' to the statement 'S' in the
comment|/// state's environment.
name|ProgramStateRef
name|BindExpr
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|SVal
name|V
argument_list|,
name|bool
name|Invalidate
operator|=
name|true
argument_list|)
decl|const
decl_stmt|;
name|ProgramStateRef
name|bindLoc
argument_list|(
name|Loc
name|location
argument_list|,
name|SVal
name|V
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|bool
name|notifyChanges
operator|=
name|true
argument_list|)
decl|const
decl_stmt|;
name|ProgramStateRef
name|bindLoc
argument_list|(
name|SVal
name|location
argument_list|,
name|SVal
name|V
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|)
decl|const
decl_stmt|;
name|ProgramStateRef
name|bindDefault
argument_list|(
name|SVal
name|loc
argument_list|,
name|SVal
name|V
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|)
decl|const
decl_stmt|;
name|ProgramStateRef
name|killBinding
argument_list|(
name|Loc
name|LV
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Returns the state with bindings for the given regions
comment|///  cleared from the store.
comment|///
comment|/// Optionally invalidates global regions as well.
comment|///
comment|/// \param Regions the set of regions to be invalidated.
comment|/// \param E the expression that caused the invalidation.
comment|/// \param BlockCount The number of times the current basic block has been
comment|//         visited.
comment|/// \param CausesPointerEscape the flag is set to true when
comment|///        the invalidation entails escape of a symbol (representing a
comment|///        pointer). For example, due to it being passed as an argument in a
comment|///        call.
comment|/// \param IS the set of invalidated symbols.
comment|/// \param Call if non-null, the invalidated regions represent parameters to
comment|///        the call and should be considered directly invalidated.
comment|/// \param ITraits information about special handling for a particular
comment|///        region/symbol.
name|ProgramStateRef
name|invalidateRegions
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|MemRegion
operator|*
operator|>
name|Regions
argument_list|,
specifier|const
name|Expr
operator|*
name|E
argument_list|,
name|unsigned
name|BlockCount
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|bool
name|CausesPointerEscape
argument_list|,
name|InvalidatedSymbols
operator|*
name|IS
operator|=
name|nullptr
argument_list|,
specifier|const
name|CallEvent
operator|*
name|Call
operator|=
name|nullptr
argument_list|,
name|RegionAndSymbolInvalidationTraits
operator|*
name|ITraits
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
name|ProgramStateRef
name|invalidateRegions
argument_list|(
name|ArrayRef
operator|<
name|SVal
operator|>
name|Regions
argument_list|,
specifier|const
name|Expr
operator|*
name|E
argument_list|,
name|unsigned
name|BlockCount
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|bool
name|CausesPointerEscape
argument_list|,
name|InvalidatedSymbols
operator|*
name|IS
operator|=
name|nullptr
argument_list|,
specifier|const
name|CallEvent
operator|*
name|Call
operator|=
name|nullptr
argument_list|,
name|RegionAndSymbolInvalidationTraits
operator|*
name|ITraits
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// enterStackFrame - Returns the state for entry to the given stack frame,
comment|///  preserving the current state.
name|ProgramStateRef
name|enterStackFrame
argument_list|(
specifier|const
name|CallEvent
operator|&
name|Call
argument_list|,
specifier|const
name|StackFrameContext
operator|*
name|CalleeCtx
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the lvalue for a variable reference.
name|Loc
name|getLValue
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
decl|const
decl_stmt|;
name|Loc
name|getLValue
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|literal
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the lvalue for an ivar reference.
name|SVal
name|getLValue
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|decl
argument_list|,
name|SVal
name|base
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the lvalue for a field reference.
name|SVal
name|getLValue
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|decl
argument_list|,
name|SVal
name|Base
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the lvalue for an indirect field reference.
name|SVal
name|getLValue
argument_list|(
specifier|const
name|IndirectFieldDecl
operator|*
name|decl
argument_list|,
name|SVal
name|Base
argument_list|)
decl|const
decl_stmt|;
comment|/// Get the lvalue for an array index.
name|SVal
name|getLValue
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|SVal
name|Idx
argument_list|,
name|SVal
name|Base
argument_list|)
decl|const
decl_stmt|;
comment|/// Returns the SVal bound to the statement 'S' in the state's environment.
name|SVal
name|getSVal
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|)
decl|const
decl_stmt|;
name|SVal
name|getSValAsScalarOrLoc
argument_list|(
specifier|const
name|Stmt
operator|*
name|Ex
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the value bound to the specified location.
comment|/// Returns UnknownVal() if none found.
name|SVal
name|getSVal
argument_list|(
name|Loc
name|LV
argument_list|,
name|QualType
name|T
operator|=
name|QualType
argument_list|()
argument_list|)
decl|const
decl_stmt|;
comment|/// Returns the "raw" SVal bound to LV before any value simplfication.
name|SVal
name|getRawSVal
argument_list|(
name|Loc
name|LV
argument_list|,
name|QualType
name|T
operator|=
name|QualType
argument_list|()
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the value bound to the specified location.
comment|/// Returns UnknownVal() if none found.
name|SVal
name|getSVal
argument_list|(
specifier|const
name|MemRegion
operator|*
name|R
argument_list|)
decl|const
decl_stmt|;
name|SVal
name|getSValAsScalarOrLoc
argument_list|(
specifier|const
name|MemRegion
operator|*
name|R
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Visits the symbols reachable from the given SVal using the provided
comment|/// SymbolVisitor.
comment|///
comment|/// This is a convenience API. Consider using ScanReachableSymbols class
comment|/// directly when making multiple scans on the same state with the same
comment|/// visitor to avoid repeated initialization cost.
comment|/// \sa ScanReachableSymbols
name|bool
name|scanReachableSymbols
argument_list|(
name|SVal
name|val
argument_list|,
name|SymbolVisitor
operator|&
name|visitor
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Visits the symbols reachable from the SVals in the given range
comment|/// using the provided SymbolVisitor.
name|bool
name|scanReachableSymbols
argument_list|(
specifier|const
name|SVal
operator|*
name|I
argument_list|,
specifier|const
name|SVal
operator|*
name|E
argument_list|,
name|SymbolVisitor
operator|&
name|visitor
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Visits the symbols reachable from the regions in the given
comment|/// MemRegions range using the provided SymbolVisitor.
name|bool
name|scanReachableSymbols
argument_list|(
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|I
argument_list|,
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|E
argument_list|,
name|SymbolVisitor
operator|&
name|visitor
argument_list|)
decl|const
decl_stmt|;
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|scanReachableSymbols
argument_list|(
argument|SVal val
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|scanReachableSymbols
argument_list|(
argument|const SVal *beg
argument_list|,
argument|const SVal *end
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|scanReachableSymbols
argument_list|(
argument|const MemRegion * const *beg
argument_list|,
argument|const MemRegion * const *end
argument_list|)
specifier|const
expr_stmt|;
comment|/// Create a new state in which the statement is marked as tainted.
name|ProgramStateRef
name|addTaint
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|/// Create a new state in which the value is marked as tainted.
name|ProgramStateRef
name|addTaint
argument_list|(
name|SVal
name|V
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|/// Create a new state in which the symbol is marked as tainted.
name|ProgramStateRef
name|addTaint
argument_list|(
name|SymbolRef
name|S
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|/// Create a new state in which the region symbol is marked as tainted.
name|ProgramStateRef
name|addTaint
argument_list|(
specifier|const
name|MemRegion
operator|*
name|R
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|/// Create a new state in a which a sub-region of a given symbol is tainted.
comment|/// This might be necessary when referring to regions that can not have an
comment|/// individual symbol, e.g. if they are represented by the default binding of
comment|/// a LazyCompoundVal.
name|ProgramStateRef
name|addPartialTaint
argument_list|(
name|SymbolRef
name|ParentSym
argument_list|,
specifier|const
name|SubRegion
operator|*
name|SubRegion
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|/// Check if the statement is tainted in the current state.
name|bool
name|isTainted
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isTainted
argument_list|(
name|SVal
name|V
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isTainted
argument_list|(
name|SymbolRef
name|Sym
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isTainted
argument_list|(
specifier|const
name|MemRegion
operator|*
name|Reg
argument_list|,
name|TaintTagType
name|Kind
operator|=
name|TaintTagGeneric
argument_list|)
decl|const
decl_stmt|;
comment|//==---------------------------------------------------------------------==//
comment|// Accessing the Generic Data Map (GDM).
comment|//==---------------------------------------------------------------------==//
name|void
modifier|*
specifier|const
modifier|*
name|FindGDM
argument_list|(
name|void
operator|*
name|K
argument_list|)
decl|const
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|add
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|data_type
name|get
argument_list|()
specifier|const
block|{
return|return
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeData
argument_list|(
name|FindGDM
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|lookup_type
name|get
argument_list|(
argument|typename ProgramStateTrait<T>::key_type key
argument_list|)
specifier|const
block|{
name|void
operator|*
specifier|const
operator|*
name|d
operator|=
name|FindGDM
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|)
block|;
return|return
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|Lookup
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeData
argument_list|(
name|d
argument_list|)
argument_list|,
name|key
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|context_type
name|get_context
argument_list|()
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|remove
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|remove
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|remove
argument_list|()
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::data_type D
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::value_type E
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::value_type E
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|bool
name|contains
argument_list|(
argument|typename ProgramStateTrait<T>::key_type key
argument_list|)
specifier|const
block|{
name|void
operator|*
specifier|const
operator|*
name|d
operator|=
name|FindGDM
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|)
block|;
return|return
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|Contains
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeData
argument_list|(
name|d
argument_list|)
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|// Pretty-printing.
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|Out
argument_list|,
specifier|const
name|char
operator|*
name|nl
operator|=
literal|"\n"
argument_list|,
specifier|const
name|char
operator|*
name|sep
operator|=
literal|""
argument_list|)
decl|const
decl_stmt|;
name|void
name|printDOT
argument_list|(
name|raw_ostream
operator|&
name|Out
argument_list|)
decl|const
decl_stmt|;
name|void
name|printTaint
argument_list|(
name|raw_ostream
operator|&
name|Out
argument_list|,
specifier|const
name|char
operator|*
name|nl
operator|=
literal|"\n"
argument_list|,
specifier|const
name|char
operator|*
name|sep
operator|=
literal|""
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dumpTaint
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|friend
name|void
name|ProgramStateRetain
parameter_list|(
specifier|const
name|ProgramState
modifier|*
name|state
parameter_list|)
function_decl|;
name|friend
name|void
name|ProgramStateRelease
parameter_list|(
specifier|const
name|ProgramState
modifier|*
name|state
parameter_list|)
function_decl|;
comment|/// \sa invalidateValues()
comment|/// \sa invalidateRegions()
name|ProgramStateRef
name|invalidateRegionsImpl
argument_list|(
name|ArrayRef
operator|<
name|SVal
operator|>
name|Values
argument_list|,
specifier|const
name|Expr
operator|*
name|E
argument_list|,
name|unsigned
name|BlockCount
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LCtx
argument_list|,
name|bool
name|ResultsInSymbolEscape
argument_list|,
name|InvalidatedSymbols
operator|*
name|IS
argument_list|,
name|RegionAndSymbolInvalidationTraits
operator|*
name|HTraits
argument_list|,
specifier|const
name|CallEvent
operator|*
name|Call
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// ProgramStateManager - Factory object for ProgramStates.
comment|//===----------------------------------------------------------------------===//
name|class
name|ProgramStateManager
block|{
name|friend
name|class
name|ProgramState
decl_stmt|;
name|friend
name|void
name|ProgramStateRelease
parameter_list|(
specifier|const
name|ProgramState
modifier|*
name|state
parameter_list|)
function_decl|;
name|private
label|:
comment|/// Eng - The SubEngine that owns this state manager.
name|SubEngine
modifier|*
name|Eng
decl_stmt|;
comment|/* Can be null. */
name|EnvironmentManager
name|EnvMgr
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|StoreManager
operator|>
name|StoreMgr
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ConstraintManager
operator|>
name|ConstraintMgr
expr_stmt|;
name|ProgramState
operator|::
name|GenericDataMap
operator|::
name|Factory
name|GDMFactory
expr_stmt|;
name|TaintedSubRegions
operator|::
name|Factory
name|TSRFactory
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|void
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|void
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|>
expr|>
name|GDMContextsTy
expr_stmt|;
name|GDMContextsTy
name|GDMContexts
decl_stmt|;
comment|/// StateSet - FoldingSet containing all the states created for analyzing
comment|///  a particular function.  This is used to unique states.
name|llvm
operator|::
name|FoldingSet
operator|<
name|ProgramState
operator|>
name|StateSet
expr_stmt|;
comment|/// Object that manages the data for all created SVals.
name|std
operator|::
name|unique_ptr
operator|<
name|SValBuilder
operator|>
name|svalBuilder
expr_stmt|;
comment|/// Manages memory for created CallEvents.
name|std
operator|::
name|unique_ptr
operator|<
name|CallEventManager
operator|>
name|CallEventMgr
expr_stmt|;
comment|/// A BumpPtrAllocator to allocate states.
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|Alloc
expr_stmt|;
comment|/// A vector of ProgramStates that we can reuse.
name|std
operator|::
name|vector
operator|<
name|ProgramState
operator|*
operator|>
name|freeStates
expr_stmt|;
name|public
label|:
name|ProgramStateManager
argument_list|(
argument|ASTContext&Ctx
argument_list|,
argument|StoreManagerCreator CreateStoreManager
argument_list|,
argument|ConstraintManagerCreator CreateConstraintManager
argument_list|,
argument|llvm::BumpPtrAllocator& alloc
argument_list|,
argument|SubEngine *subeng
argument_list|)
empty_stmt|;
operator|~
name|ProgramStateManager
argument_list|()
expr_stmt|;
name|ProgramStateRef
name|getInitialState
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|InitLoc
parameter_list|)
function_decl|;
name|ASTContext
modifier|&
name|getContext
parameter_list|()
block|{
return|return
name|svalBuilder
operator|->
name|getContext
argument_list|()
return|;
block|}
specifier|const
name|ASTContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|svalBuilder
operator|->
name|getContext
argument_list|()
return|;
block|}
name|BasicValueFactory
modifier|&
name|getBasicVals
parameter_list|()
block|{
return|return
name|svalBuilder
operator|->
name|getBasicValueFactory
argument_list|()
return|;
block|}
name|SValBuilder
modifier|&
name|getSValBuilder
parameter_list|()
block|{
return|return
operator|*
name|svalBuilder
return|;
block|}
name|SymbolManager
modifier|&
name|getSymbolManager
parameter_list|()
block|{
return|return
name|svalBuilder
operator|->
name|getSymbolManager
argument_list|()
return|;
block|}
specifier|const
name|SymbolManager
operator|&
name|getSymbolManager
argument_list|()
specifier|const
block|{
return|return
name|svalBuilder
operator|->
name|getSymbolManager
argument_list|()
return|;
block|}
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
block|{
return|return
name|Alloc
return|;
block|}
name|MemRegionManager
modifier|&
name|getRegionManager
parameter_list|()
block|{
return|return
name|svalBuilder
operator|->
name|getRegionManager
argument_list|()
return|;
block|}
specifier|const
name|MemRegionManager
operator|&
name|getRegionManager
argument_list|()
specifier|const
block|{
return|return
name|svalBuilder
operator|->
name|getRegionManager
argument_list|()
return|;
block|}
name|CallEventManager
modifier|&
name|getCallEventManager
parameter_list|()
block|{
return|return
operator|*
name|CallEventMgr
return|;
block|}
name|StoreManager
modifier|&
name|getStoreManager
parameter_list|()
block|{
return|return
operator|*
name|StoreMgr
return|;
block|}
name|ConstraintManager
modifier|&
name|getConstraintManager
parameter_list|()
block|{
return|return
operator|*
name|ConstraintMgr
return|;
block|}
name|SubEngine
modifier|*
name|getOwningEngine
parameter_list|()
block|{
return|return
name|Eng
return|;
block|}
name|ProgramStateRef
name|removeDeadBindings
parameter_list|(
name|ProgramStateRef
name|St
parameter_list|,
specifier|const
name|StackFrameContext
modifier|*
name|LCtx
parameter_list|,
name|SymbolReaper
modifier|&
name|SymReaper
parameter_list|)
function_decl|;
name|public
label|:
name|SVal
name|ArrayToPointer
parameter_list|(
name|Loc
name|Array
parameter_list|,
name|QualType
name|ElementTy
parameter_list|)
block|{
return|return
name|StoreMgr
operator|->
name|ArrayToPointer
argument_list|(
name|Array
argument_list|,
name|ElementTy
argument_list|)
return|;
block|}
comment|// Methods that manipulate the GDM.
name|ProgramStateRef
name|addGDM
parameter_list|(
name|ProgramStateRef
name|St
parameter_list|,
name|void
modifier|*
name|Key
parameter_list|,
name|void
modifier|*
name|Data
parameter_list|)
function_decl|;
name|ProgramStateRef
name|removeGDM
parameter_list|(
name|ProgramStateRef
name|state
parameter_list|,
name|void
modifier|*
name|Key
parameter_list|)
function_decl|;
comment|// Methods that query& manipulate the Store.
name|void
name|iterBindings
argument_list|(
name|ProgramStateRef
name|state
argument_list|,
name|StoreManager
operator|::
name|BindingsHandler
operator|&
name|F
argument_list|)
block|{
name|StoreMgr
operator|->
name|iterBindings
argument_list|(
name|state
operator|->
name|getStore
argument_list|()
argument_list|,
name|F
argument_list|)
expr_stmt|;
block|}
name|ProgramStateRef
name|getPersistentState
parameter_list|(
name|ProgramState
modifier|&
name|Impl
parameter_list|)
function_decl|;
name|ProgramStateRef
name|getPersistentStateWithGDM
parameter_list|(
name|ProgramStateRef
name|FromState
parameter_list|,
name|ProgramStateRef
name|GDMState
parameter_list|)
function_decl|;
name|bool
name|haveEqualEnvironments
parameter_list|(
name|ProgramStateRef
name|S1
parameter_list|,
name|ProgramStateRef
name|S2
parameter_list|)
block|{
return|return
name|S1
operator|->
name|Env
operator|==
name|S2
operator|->
name|Env
return|;
block|}
name|bool
name|haveEqualStores
parameter_list|(
name|ProgramStateRef
name|S1
parameter_list|,
name|ProgramStateRef
name|S2
parameter_list|)
block|{
return|return
name|S1
operator|->
name|store
operator|==
name|S2
operator|->
name|store
return|;
block|}
comment|//==---------------------------------------------------------------------==//
comment|// Generic Data Map methods.
comment|//==---------------------------------------------------------------------==//
comment|//
comment|// ProgramStateManager and ProgramState support a "generic data map" that allows
comment|// different clients of ProgramState objects to embed arbitrary data within a
comment|// ProgramState object.  The generic data map is essentially an immutable map
comment|// from a "tag" (that acts as the "key" for a client) and opaque values.
comment|// Tags/keys and values are simply void* values.  The typical way that clients
comment|// generate unique tags are by taking the address of a static variable.
comment|// Clients are responsible for ensuring that data values referred to by a
comment|// the data pointer are immutable (and thus are essentially purely functional
comment|// data).
comment|//
comment|// The templated methods below use the ProgramStateTrait<T> class
comment|// to resolve keys into the GDM and to return data values to clients.
comment|//
comment|// Trait based GDM dispatch.
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|set
argument_list|(
argument|ProgramStateRef st
argument_list|,
argument|typename ProgramStateTrait<T>::data_type D
argument_list|)
block|{
return|return
name|addGDM
argument_list|(
name|st
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeVoidPtr
argument_list|(
name|D
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|set
argument_list|(
argument|ProgramStateRef st
argument_list|,
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::value_type V
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
block|{
return|return
name|addGDM
argument_list|(
name|st
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeVoidPtr
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|Set
argument_list|(
name|st
operator|->
name|get
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|,
name|K
argument_list|,
name|V
argument_list|,
name|C
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|add
argument_list|(
argument|ProgramStateRef st
argument_list|,
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
block|{
return|return
name|addGDM
argument_list|(
name|st
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeVoidPtr
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|Add
argument_list|(
name|st
operator|->
name|get
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|,
name|K
argument_list|,
name|C
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|remove
argument_list|(
argument|ProgramStateRef st
argument_list|,
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
block|{
return|return
name|addGDM
argument_list|(
name|st
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeVoidPtr
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|Remove
argument_list|(
name|st
operator|->
name|get
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|,
name|K
argument_list|,
name|C
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|remove
argument_list|(
argument|ProgramStateRef st
argument_list|)
block|{
return|return
name|removeGDM
argument_list|(
name|st
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|)
return|;
block|}
name|void
modifier|*
name|FindGDMContext
argument_list|(
name|void
operator|*
name|index
argument_list|,
name|void
operator|*
call|(
modifier|*
name|CreateContext
call|)
argument_list|(
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|DeleteContext
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|context_type
name|get_context
argument_list|()
block|{
name|void
operator|*
name|p
operator|=
name|FindGDMContext
argument_list|(
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|GDMIndex
argument_list|()
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|CreateContext
argument_list|,
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|DeleteContext
argument_list|)
block|;
return|return
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|MakeContext
argument_list|(
name|p
argument_list|)
return|;
block|}
name|void
name|EndPath
parameter_list|(
name|ProgramStateRef
name|St
parameter_list|)
block|{
name|ConstraintMgr
operator|->
name|EndPath
argument_list|(
name|St
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Out-of-line method definitions for ProgramState.
comment|//===----------------------------------------------------------------------===//
specifier|inline
name|ConstraintManager
operator|&
name|ProgramState
operator|::
name|getConstraintManager
argument_list|()
specifier|const
block|{
return|return
name|stateMgr
operator|->
name|getConstraintManager
argument_list|()
return|;
block|}
specifier|inline
specifier|const
name|VarRegion
operator|*
name|ProgramState
operator|::
name|getRegion
argument_list|(
argument|const VarDecl *D
argument_list|,
argument|const LocationContext *LC
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getVarRegion
argument_list|(
name|D
argument_list|,
name|LC
argument_list|)
return|;
block|}
specifier|inline
name|ProgramStateRef
name|ProgramState
operator|::
name|assume
argument_list|(
argument|DefinedOrUnknownSVal Cond
argument_list|,
argument|bool Assumption
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Cond
operator|.
name|isUnknown
argument_list|()
condition|)
return|return
name|this
return|;
return|return
name|getStateManager
argument_list|()
operator|.
name|ConstraintMgr
operator|->
name|assume
argument_list|(
name|this
argument_list|,
name|Cond
operator|.
name|castAs
operator|<
name|DefinedSVal
operator|>
operator|(
operator|)
argument_list|,
name|Assumption
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|inline
name|std
operator|::
name|pair
operator|<
name|ProgramStateRef
operator|,
name|ProgramStateRef
operator|>
name|ProgramState
operator|::
name|assume
argument_list|(
argument|DefinedOrUnknownSVal Cond
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Cond
operator|.
name|isUnknown
argument_list|()
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|getStateManager
argument_list|()
operator|.
name|ConstraintMgr
operator|->
name|assumeDual
argument_list|(
name|this
argument_list|,
name|Cond
operator|.
name|castAs
operator|<
name|DefinedSVal
operator|>
operator|(
operator|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  inline
name|ProgramStateRef
name|ProgramState
operator|::
name|assumeInclusiveRange
argument_list|(
argument|DefinedOrUnknownSVal Val
argument_list|,
argument|const llvm::APSInt&From
argument_list|,
argument|const llvm::APSInt&To
argument_list|,
argument|bool Assumption
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Val
operator|.
name|isUnknown
argument_list|()
condition|)
return|return
name|this
return|;
name|assert
argument_list|(
name|Val
operator|.
name|getAs
operator|<
name|NonLoc
operator|>
operator|(
operator|)
operator|&&
literal|"Only NonLocs are supported!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getStateManager
argument_list|()
operator|.
name|ConstraintMgr
operator|->
name|assumeInclusiveRange
argument_list|(
name|this
argument_list|,
name|Val
operator|.
name|castAs
operator|<
name|NonLoc
operator|>
operator|(
operator|)
argument_list|,
name|From
argument_list|,
name|To
argument_list|,
name|Assumption
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  inline
name|std
operator|::
name|pair
operator|<
name|ProgramStateRef
operator|,
name|ProgramStateRef
operator|>
name|ProgramState
operator|::
name|assumeInclusiveRange
argument_list|(
argument|DefinedOrUnknownSVal Val
argument_list|,
argument|const llvm::APSInt&From
argument_list|,
argument|const llvm::APSInt&To
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Val
operator|.
name|isUnknown
argument_list|()
condition|)
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
return|;
name|assert
argument_list|(
name|Val
operator|.
name|getAs
operator|<
name|NonLoc
operator|>
operator|(
operator|)
operator|&&
literal|"Only NonLocs are supported!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getStateManager
argument_list|()
operator|.
name|ConstraintMgr
operator|->
name|assumeInclusiveRangeDual
argument_list|(
name|this
argument_list|,
name|Val
operator|.
name|castAs
operator|<
name|NonLoc
operator|>
operator|(
operator|)
argument_list|,
name|From
argument_list|,
name|To
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  inline
name|ProgramStateRef
name|ProgramState
operator|::
name|bindLoc
argument_list|(
argument|SVal LV
argument_list|,
argument|SVal V
argument_list|,
argument|const LocationContext *LCtx
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Optional
operator|<
name|Loc
operator|>
name|L
operator|=
name|LV
operator|.
name|getAs
operator|<
name|Loc
operator|>
operator|(
operator|)
condition|)
return|return
name|bindLoc
argument_list|(
operator|*
name|L
argument_list|,
name|V
argument_list|,
name|LCtx
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|this
return|;
end_return

begin_expr_stmt
unit|}  inline
name|Loc
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|const VarDecl *VD
argument_list|,
argument|const LocationContext *LC
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getLValueVar
argument_list|(
name|VD
argument_list|,
name|LC
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|Loc
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|const CompoundLiteralExpr *literal
argument_list|,
argument|const LocationContext *LC
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getLValueCompoundLiteral
argument_list|(
name|literal
argument_list|,
name|LC
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SVal
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|const ObjCIvarDecl *D
argument_list|,
argument|SVal Base
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getLValueIvar
argument_list|(
name|D
argument_list|,
name|Base
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SVal
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|const FieldDecl *D
argument_list|,
argument|SVal Base
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getLValueField
argument_list|(
name|D
argument_list|,
name|Base
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SVal
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|const IndirectFieldDecl *D
argument_list|,
argument|SVal Base
argument_list|)
specifier|const
block|{
name|StoreManager
operator|&
name|SM
operator|=
operator|*
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|I
range|:
name|D
operator|->
name|chain
argument_list|()
control|)
block|{
name|Base
operator|=
name|SM
operator|.
name|getLValueField
argument_list|(
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|I
operator|)
argument_list|,
name|Base
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|Base
return|;
end_return

begin_expr_stmt
unit|}  inline
name|SVal
name|ProgramState
operator|::
name|getLValue
argument_list|(
argument|QualType ElementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|SVal Base
argument_list|)
specifier|const
block|{
if|if
condition|(
name|Optional
operator|<
name|NonLoc
operator|>
name|N
operator|=
name|Idx
operator|.
name|getAs
operator|<
name|NonLoc
operator|>
operator|(
operator|)
condition|)
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getLValueElement
argument_list|(
name|ElementType
argument_list|,
operator|*
name|N
argument_list|,
name|Base
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|UnknownVal
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  inline
name|SVal
name|ProgramState
operator|::
name|getSVal
argument_list|(
argument|const Stmt *Ex
argument_list|,
argument|const LocationContext *LCtx
argument_list|)
specifier|const
block|{
return|return
name|Env
operator|.
name|getSVal
argument_list|(
name|EnvironmentEntry
argument_list|(
name|Ex
argument_list|,
name|LCtx
argument_list|)
argument_list|,
operator|*
name|getStateManager
argument_list|()
operator|.
name|svalBuilder
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SVal
name|ProgramState
operator|::
name|getSValAsScalarOrLoc
argument_list|(
argument|const Stmt *S
argument_list|,
argument|const LocationContext *LCtx
argument_list|)
specifier|const
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Ex
init|=
name|dyn_cast
operator|<
name|Expr
operator|>
operator|(
name|S
operator|)
condition|)
block|{
name|QualType
name|T
init|=
name|Ex
operator|->
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|Ex
operator|->
name|isGLValue
argument_list|()
operator|||
name|Loc
operator|::
name|isLocType
argument_list|(
name|T
argument_list|)
operator|||
name|T
operator|->
name|isIntegralOrEnumerationType
argument_list|()
condition|)
return|return
name|getSVal
argument_list|(
name|S
argument_list|,
name|LCtx
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|UnknownVal
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  inline
name|SVal
name|ProgramState
operator|::
name|getRawSVal
argument_list|(
argument|Loc LV
argument_list|,
argument|QualType T
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getBinding
argument_list|(
name|getStore
argument_list|()
argument_list|,
name|LV
argument_list|,
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SVal
name|ProgramState
operator|::
name|getSVal
argument_list|(
argument|const MemRegion* R
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|StoreMgr
operator|->
name|getBinding
argument_list|(
name|getStore
argument_list|()
argument_list|,
name|loc
operator|::
name|MemRegionVal
argument_list|(
name|R
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|BasicValueFactory
operator|&
name|ProgramState
operator|::
name|getBasicVals
argument_list|()
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|getBasicVals
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|SymbolManager
operator|&
name|ProgramState
operator|::
name|getSymbolManager
argument_list|()
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|getSymbolManager
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|add
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|add
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|K
operator|,
name|get_context
operator|<
name|T
operator|>
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|typename
name|ProgramStateTrait
operator|<
name|T
operator|>
operator|::
name|context_type
name|ProgramState
operator|::
name|get_context
argument_list|()
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|get_context
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|remove
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|remove
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|K
operator|,
name|get_context
operator|<
name|T
operator|>
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|remove
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|remove
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|K
operator|,
name|C
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|remove
argument_list|()
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|remove
operator|<
name|T
operator|>
operator|(
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::data_type D
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|set
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|D
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::value_type E
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|set
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|K
operator|,
name|E
operator|,
name|get_context
operator|<
name|T
operator|>
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|ProgramStateRef
name|ProgramState
operator|::
name|set
argument_list|(
argument|typename ProgramStateTrait<T>::key_type K
argument_list|,
argument|typename ProgramStateTrait<T>::value_type E
argument_list|,
argument|typename ProgramStateTrait<T>::context_type C
argument_list|)
specifier|const
block|{
return|return
name|getStateManager
argument_list|()
operator|.
name|set
operator|<
name|T
operator|>
operator|(
name|this
operator|,
name|K
operator|,
name|E
operator|,
name|C
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|ProgramState
operator|::
name|scanReachableSymbols
argument_list|(
argument|SVal val
argument_list|)
specifier|const
block|{
name|CB
name|cb
argument_list|(
name|this
argument_list|)
block|;
name|scanReachableSymbols
argument_list|(
name|val
argument_list|,
name|cb
argument_list|)
block|;
return|return
name|cb
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|ProgramState
operator|::
name|scanReachableSymbols
argument_list|(
argument|const SVal *beg
argument_list|,
argument|const SVal *end
argument_list|)
specifier|const
block|{
name|CB
name|cb
argument_list|(
name|this
argument_list|)
block|;
name|scanReachableSymbols
argument_list|(
name|beg
argument_list|,
name|end
argument_list|,
name|cb
argument_list|)
block|;
return|return
name|cb
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|CB
operator|>
name|CB
name|ProgramState
operator|::
name|scanReachableSymbols
argument_list|(
argument|const MemRegion * const *beg
argument_list|,
argument|const MemRegion * const *end
argument_list|)
specifier|const
block|{
name|CB
name|cb
argument_list|(
name|this
argument_list|)
block|;
name|scanReachableSymbols
argument_list|(
name|beg
argument_list|,
name|end
argument_list|,
name|cb
argument_list|)
block|;
return|return
name|cb
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \class ScanReachableSymbols
end_comment

begin_comment
comment|/// A utility class that visits the reachable symbols using a custom
end_comment

begin_comment
comment|/// SymbolVisitor. Terminates recursive traversal when the visitor function
end_comment

begin_comment
comment|/// returns false.
end_comment

begin_decl_stmt
name|class
name|ScanReachableSymbols
block|{
typedef|typedef
name|llvm
operator|::
name|DenseSet
operator|<
specifier|const
name|void
operator|*
operator|>
name|VisitedItems
expr_stmt|;
name|VisitedItems
name|visited
decl_stmt|;
name|ProgramStateRef
name|state
decl_stmt|;
name|SymbolVisitor
modifier|&
name|visitor
decl_stmt|;
name|public
label|:
name|ScanReachableSymbols
argument_list|(
argument|ProgramStateRef st
argument_list|,
argument|SymbolVisitor&v
argument_list|)
block|:
name|state
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|st
argument_list|)
argument_list|)
operator|,
name|visitor
argument_list|(
argument|v
argument_list|)
block|{}
name|bool
name|scan
argument_list|(
argument|nonloc::LazyCompoundVal val
argument_list|)
expr_stmt|;
name|bool
name|scan
argument_list|(
name|nonloc
operator|::
name|CompoundVal
name|val
argument_list|)
decl_stmt|;
name|bool
name|scan
parameter_list|(
name|SVal
name|val
parameter_list|)
function_decl|;
name|bool
name|scan
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|)
function_decl|;
name|bool
name|scan
parameter_list|(
specifier|const
name|SymExpr
modifier|*
name|sym
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end ento namespace
end_comment

begin_comment
unit|}
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

