begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== Store.h - Interface for maps from Locations to Values ------*- C++ -*--==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defined the types Store and StoreManager.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_GR_STORE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_GR_STORE_H
end_define

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Stmt
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|ObjCIvarDecl
decl_stmt|;
name|class
name|StackFrameContext
decl_stmt|;
name|namespace
name|ento
block|{
name|class
name|GRState
decl_stmt|;
name|class
name|GRStateManager
decl_stmt|;
name|class
name|SubRegionMap
decl_stmt|;
name|class
name|StoreManager
block|{
name|protected
label|:
name|SValBuilder
modifier|&
name|svalBuilder
decl_stmt|;
name|GRStateManager
modifier|&
name|StateMgr
decl_stmt|;
comment|/// MRMgr - Manages region objects associated with this StoreManager.
name|MemRegionManager
modifier|&
name|MRMgr
decl_stmt|;
name|ASTContext
modifier|&
name|Ctx
decl_stmt|;
name|StoreManager
argument_list|(
name|GRStateManager
operator|&
name|stateMgr
argument_list|)
expr_stmt|;
name|public
label|:
name|virtual
operator|~
name|StoreManager
argument_list|()
block|{}
comment|/// Return the value bound to specified location in a given state.
comment|/// \param[in] state The analysis state.
comment|/// \param[in] loc The symbolic memory location.
comment|/// \param[in] T An optional type that provides a hint indicating the
comment|///   expected type of the returned value.  This is used if the value is
comment|///   lazily computed.
comment|/// \return The value bound to the location \c loc.
name|virtual
name|SVal
name|Retrieve
argument_list|(
argument|Store store
argument_list|,
argument|Loc loc
argument_list|,
argument|QualType T = QualType()
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/// Return a state with the specified value bound to the given location.
comment|/// \param[in] state The analysis state.
comment|/// \param[in] loc The symbolic memory location.
comment|/// \param[in] val The value to bind to location \c loc.
comment|/// \return A pointer to a GRState object that contains the same bindings as
comment|///   \c state with the addition of having the value specified by \c val bound
comment|///   to the location given for \c loc.
name|virtual
name|StoreRef
name|Bind
parameter_list|(
name|Store
name|store
parameter_list|,
name|Loc
name|loc
parameter_list|,
name|SVal
name|val
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|StoreRef
name|BindDefault
parameter_list|(
name|Store
name|store
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|,
name|SVal
name|V
parameter_list|)
function_decl|;
name|virtual
name|StoreRef
name|Remove
parameter_list|(
name|Store
name|St
parameter_list|,
name|Loc
name|L
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// BindCompoundLiteral - Return the store that has the bindings currently
comment|///  in 'store' plus the bindings for the CompoundLiteral.  'R' is the region
comment|///  for the compound literal and 'BegInit' and 'EndInit' represent an
comment|///  array of initializer values.
name|virtual
name|StoreRef
name|BindCompoundLiteral
parameter_list|(
name|Store
name|store
parameter_list|,
specifier|const
name|CompoundLiteralExpr
modifier|*
name|cl
parameter_list|,
specifier|const
name|LocationContext
modifier|*
name|LC
parameter_list|,
name|SVal
name|v
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// getInitialStore - Returns the initial "empty" store representing the
comment|///  value bindings upon entry to an analyzed function.
name|virtual
name|StoreRef
name|getInitialStore
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|InitLoc
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// getRegionManager - Returns the internal RegionManager object that is
comment|///  used to query and manipulate MemRegion objects.
name|MemRegionManager
modifier|&
name|getRegionManager
parameter_list|()
block|{
return|return
name|MRMgr
return|;
block|}
comment|/// getSubRegionMap - Returns an opaque map object that clients can query
comment|///  to get the subregions of a given MemRegion object.  It is the
comment|//   caller's responsibility to 'delete' the returned map.
name|virtual
name|SubRegionMap
modifier|*
name|getSubRegionMap
parameter_list|(
name|Store
name|store
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|Loc
name|getLValueVar
parameter_list|(
specifier|const
name|VarDecl
modifier|*
name|VD
parameter_list|,
specifier|const
name|LocationContext
modifier|*
name|LC
parameter_list|)
block|{
return|return
name|svalBuilder
operator|.
name|makeLoc
argument_list|(
name|MRMgr
operator|.
name|getVarRegion
argument_list|(
name|VD
argument_list|,
name|LC
argument_list|)
argument_list|)
return|;
block|}
name|virtual
name|Loc
name|getLValueString
parameter_list|(
specifier|const
name|StringLiteral
modifier|*
name|S
parameter_list|)
block|{
return|return
name|svalBuilder
operator|.
name|makeLoc
argument_list|(
name|MRMgr
operator|.
name|getStringRegion
argument_list|(
name|S
argument_list|)
argument_list|)
return|;
block|}
name|Loc
name|getLValueCompoundLiteral
parameter_list|(
specifier|const
name|CompoundLiteralExpr
modifier|*
name|CL
parameter_list|,
specifier|const
name|LocationContext
modifier|*
name|LC
parameter_list|)
block|{
return|return
name|loc
operator|::
name|MemRegionVal
argument_list|(
name|MRMgr
operator|.
name|getCompoundLiteralRegion
argument_list|(
name|CL
argument_list|,
name|LC
argument_list|)
argument_list|)
return|;
block|}
name|virtual
name|SVal
name|getLValueIvar
parameter_list|(
specifier|const
name|ObjCIvarDecl
modifier|*
name|decl
parameter_list|,
name|SVal
name|base
parameter_list|)
block|{
return|return
name|getLValueFieldOrIvar
argument_list|(
name|decl
argument_list|,
name|base
argument_list|)
return|;
block|}
name|virtual
name|SVal
name|getLValueField
parameter_list|(
specifier|const
name|FieldDecl
modifier|*
name|D
parameter_list|,
name|SVal
name|Base
parameter_list|)
block|{
return|return
name|getLValueFieldOrIvar
argument_list|(
name|D
argument_list|,
name|Base
argument_list|)
return|;
block|}
name|virtual
name|SVal
name|getLValueElement
parameter_list|(
name|QualType
name|elementType
parameter_list|,
name|NonLoc
name|offset
parameter_list|,
name|SVal
name|Base
parameter_list|)
function_decl|;
comment|// FIXME: This should soon be eliminated altogether; clients should deal with
comment|// region extents directly.
name|virtual
name|DefinedOrUnknownSVal
name|getSizeInElements
parameter_list|(
specifier|const
name|GRState
modifier|*
name|state
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|region
parameter_list|,
name|QualType
name|EleTy
parameter_list|)
block|{
return|return
name|UnknownVal
argument_list|()
return|;
block|}
comment|/// ArrayToPointer - Used by ExprEngine::VistCast to handle implicit
comment|///  conversions between arrays and pointers.
name|virtual
name|SVal
name|ArrayToPointer
parameter_list|(
name|Loc
name|Array
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// Evaluates DerivedToBase casts.
name|virtual
name|SVal
name|evalDerivedToBase
parameter_list|(
name|SVal
name|derived
parameter_list|,
name|QualType
name|basePtrType
parameter_list|)
block|{
return|return
name|UnknownVal
argument_list|()
return|;
block|}
name|class
name|CastResult
block|{
specifier|const
name|GRState
modifier|*
name|state
decl_stmt|;
specifier|const
name|MemRegion
modifier|*
name|region
decl_stmt|;
name|public
label|:
specifier|const
name|GRState
operator|*
name|getState
argument_list|()
specifier|const
block|{
return|return
name|state
return|;
block|}
specifier|const
name|MemRegion
operator|*
name|getRegion
argument_list|()
specifier|const
block|{
return|return
name|region
return|;
block|}
name|CastResult
argument_list|(
specifier|const
name|GRState
operator|*
name|s
argument_list|,
specifier|const
name|MemRegion
operator|*
name|r
operator|=
literal|0
argument_list|)
operator|:
name|state
argument_list|(
name|s
argument_list|)
operator|,
name|region
argument_list|(
argument|r
argument_list|)
block|{}
block|}
empty_stmt|;
specifier|const
name|ElementRegion
modifier|*
name|GetElementZeroRegion
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|R
parameter_list|,
name|QualType
name|T
parameter_list|)
function_decl|;
comment|/// castRegion - Used by ExprEngine::VisitCast to handle casts from
comment|///  a MemRegion* to a specific location type.  'R' is the region being
comment|///  casted and 'CastToTy' the result type of the cast.
specifier|const
name|MemRegion
modifier|*
name|castRegion
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|region
parameter_list|,
name|QualType
name|CastToTy
parameter_list|)
function_decl|;
name|virtual
name|StoreRef
name|removeDeadBindings
argument_list|(
name|Store
name|store
argument_list|,
specifier|const
name|StackFrameContext
operator|*
name|LCtx
argument_list|,
name|SymbolReaper
operator|&
name|SymReaper
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
specifier|const
name|MemRegion
operator|*
operator|>
operator|&
name|RegionRoots
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|StoreRef
name|BindDecl
parameter_list|(
name|Store
name|store
parameter_list|,
specifier|const
name|VarRegion
modifier|*
name|VR
parameter_list|,
name|SVal
name|initVal
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|StoreRef
name|BindDeclWithNoInit
parameter_list|(
name|Store
name|store
parameter_list|,
specifier|const
name|VarRegion
modifier|*
name|VR
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// If the StoreManager supports it, increment the reference count of
comment|/// the specified Store object.
name|virtual
name|void
name|incrementReferenceCount
parameter_list|(
name|Store
name|store
parameter_list|)
block|{}
comment|/// If the StoreManager supports it, decrement the reference count of
comment|/// the specified Store object.  If the reference count hits 0, the memory
comment|/// associated with the object is recycled.
name|virtual
name|void
name|decrementReferenceCount
parameter_list|(
name|Store
name|store
parameter_list|)
block|{}
typedef|typedef
name|llvm
operator|::
name|DenseSet
operator|<
name|SymbolRef
operator|>
name|InvalidatedSymbols
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
specifier|const
name|MemRegion
operator|*
operator|,
literal|8
operator|>
name|InvalidatedRegions
expr_stmt|;
comment|/// invalidateRegions - Clears out the specified regions from the store,
comment|///  marking their values as unknown. Depending on the store, this may also
comment|///  invalidate additional regions that may have changed based on accessing
comment|///  the given regions. Optionally, invalidates non-static globals as well.
comment|/// \param[in] store The initial store
comment|/// \param[in] Begin A pointer to the first region to invalidate.
comment|/// \param[in] End A pointer just past the last region to invalidate.
comment|/// \param[in] E The current statement being evaluated. Used to conjure
comment|///   symbols to mark the values of invalidated regions.
comment|/// \param[in] Count The current block count. Used to conjure
comment|///   symbols to mark the values of invalidated regions.
comment|/// \param[in,out] IS A set to fill with any symbols that are no longer
comment|///   accessible. Pass \c NULL if this information will not be used.
comment|/// \param[in] invalidateGlobals If \c true, any non-static global regions
comment|///   are invalidated as well.
comment|/// \param[in,out] Regions A vector to fill with any regions being
comment|///   invalidated. This should include any regions explicitly invalidated
comment|///   even if they do not currently have bindings. Pass \c NULL if this
comment|///   information will not be used.
name|virtual
name|StoreRef
name|invalidateRegions
parameter_list|(
name|Store
name|store
parameter_list|,
specifier|const
name|MemRegion
modifier|*
specifier|const
modifier|*
name|Begin
parameter_list|,
specifier|const
name|MemRegion
modifier|*
specifier|const
modifier|*
name|End
parameter_list|,
specifier|const
name|Expr
modifier|*
name|E
parameter_list|,
name|unsigned
name|Count
parameter_list|,
name|InvalidatedSymbols
modifier|&
name|IS
parameter_list|,
name|bool
name|invalidateGlobals
parameter_list|,
name|InvalidatedRegions
modifier|*
name|Regions
parameter_list|)
init|=
literal|0
function_decl|;
comment|/// enterStackFrame - Let the StoreManager to do something when execution
comment|/// engine is about to execute into a callee.
name|virtual
name|StoreRef
name|enterStackFrame
parameter_list|(
specifier|const
name|GRState
modifier|*
name|state
parameter_list|,
specifier|const
name|StackFrameContext
modifier|*
name|frame
parameter_list|)
function_decl|;
name|virtual
name|void
name|print
argument_list|(
name|Store
name|store
argument_list|,
name|llvm
operator|::
name|raw_ostream
operator|&
name|Out
argument_list|,
specifier|const
name|char
operator|*
name|nl
argument_list|,
specifier|const
name|char
operator|*
name|sep
argument_list|)
init|=
literal|0
decl_stmt|;
name|class
name|BindingsHandler
block|{
name|public
label|:
name|virtual
operator|~
name|BindingsHandler
argument_list|()
expr_stmt|;
name|virtual
name|bool
name|HandleBinding
parameter_list|(
name|StoreManager
modifier|&
name|SMgr
parameter_list|,
name|Store
name|store
parameter_list|,
specifier|const
name|MemRegion
modifier|*
name|region
parameter_list|,
name|SVal
name|val
parameter_list|)
init|=
literal|0
function_decl|;
block|}
empty_stmt|;
comment|/// iterBindings - Iterate over the bindings in the Store.
name|virtual
name|void
name|iterBindings
parameter_list|(
name|Store
name|store
parameter_list|,
name|BindingsHandler
modifier|&
name|f
parameter_list|)
init|=
literal|0
function_decl|;
name|protected
label|:
specifier|const
name|MemRegion
modifier|*
name|MakeElementRegion
parameter_list|(
specifier|const
name|MemRegion
modifier|*
name|baseRegion
parameter_list|,
name|QualType
name|pointeeTy
parameter_list|,
name|uint64_t
name|index
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// CastRetrievedVal - Used by subclasses of StoreManager to implement
comment|///  implicit casts that arise from loads from regions that are reinterpreted
comment|///  as another region.
name|SVal
name|CastRetrievedVal
parameter_list|(
name|SVal
name|val
parameter_list|,
specifier|const
name|TypedRegion
modifier|*
name|region
parameter_list|,
name|QualType
name|castTy
parameter_list|,
name|bool
name|performTestOnly
init|=
name|true
parameter_list|)
function_decl|;
name|private
label|:
name|SVal
name|getLValueFieldOrIvar
parameter_list|(
specifier|const
name|Decl
modifier|*
name|decl
parameter_list|,
name|SVal
name|base
parameter_list|)
function_decl|;
block|}
empty_stmt|;
specifier|inline
name|StoreRef
operator|::
name|StoreRef
argument_list|(
argument|Store store
argument_list|,
argument|StoreManager& smgr
argument_list|)
operator|:
name|store
argument_list|(
name|store
argument_list|)
operator|,
name|mgr
argument_list|(
argument|smgr
argument_list|)
block|{
if|if
condition|(
name|store
condition|)
name|mgr
operator|.
name|incrementReferenceCount
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|StoreRef
operator|::
name|StoreRef
argument_list|(
specifier|const
name|StoreRef
operator|&
name|sr
argument_list|)
operator|:
name|store
argument_list|(
name|sr
operator|.
name|store
argument_list|)
operator|,
name|mgr
argument_list|(
argument|sr.mgr
argument_list|)
block|{
if|if
condition|(
name|store
condition|)
name|mgr
operator|.
name|incrementReferenceCount
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|StoreRef
operator|::
operator|~
name|StoreRef
argument_list|()
block|{
if|if
condition|(
name|store
condition|)
name|mgr
operator|.
name|decrementReferenceCount
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
specifier|inline
name|StoreRef
operator|&
name|StoreRef
operator|::
name|operator
operator|=
operator|(
name|StoreRef
specifier|const
operator|&
name|newStore
operator|)
block|{
name|assert
argument_list|(
operator|&
name|newStore
operator|.
name|mgr
operator|==
operator|&
name|mgr
argument_list|)
block|;
if|if
condition|(
name|store
operator|!=
name|newStore
operator|.
name|store
condition|)
block|{
name|mgr
operator|.
name|incrementReferenceCount
argument_list|(
name|newStore
operator|.
name|store
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|decrementReferenceCount
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|store
operator|=
name|newStore
operator|.
name|getStore
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
comment|// FIXME: Do we still need this?
comment|/// SubRegionMap - An abstract interface that represents a queryable map
comment|///  between MemRegion objects and their subregions.
name|class
name|SubRegionMap
block|{
name|public
label|:
name|virtual
operator|~
name|SubRegionMap
argument_list|()
block|{}
name|class
name|Visitor
block|{
name|public
operator|:
name|virtual
operator|~
name|Visitor
argument_list|()
block|{}
name|virtual
name|bool
name|Visit
argument_list|(
specifier|const
name|MemRegion
operator|*
name|Parent
argument_list|,
specifier|const
name|MemRegion
operator|*
name|SubRegion
argument_list|)
operator|=
literal|0
block|;   }
expr_stmt|;
name|virtual
name|bool
name|iterSubRegions
argument_list|(
specifier|const
name|MemRegion
operator|*
name|region
argument_list|,
name|Visitor
operator|&
name|V
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
block|}
empty_stmt|;
comment|// FIXME: Do we need to pass GRStateManager anymore?
name|StoreManager
modifier|*
name|CreateBasicStoreManager
parameter_list|(
name|GRStateManager
modifier|&
name|StMgr
parameter_list|)
function_decl|;
name|StoreManager
modifier|*
name|CreateRegionStoreManager
parameter_list|(
name|GRStateManager
modifier|&
name|StMgr
parameter_list|)
function_decl|;
name|StoreManager
modifier|*
name|CreateFieldsOnlyRegionStoreManager
parameter_list|(
name|GRStateManager
modifier|&
name|StMgr
parameter_list|)
function_decl|;
name|StoreManager
modifier|*
name|CreateFlatStoreManager
parameter_list|(
name|GRStateManager
modifier|&
name|StMgr
parameter_list|)
function_decl|;
block|}
comment|// end GR namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

