begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==- CoreEngine.h - Path-Sensitive Dataflow Engine ----------------*- C++ -*-//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines a generic engine for intraprocedural, path-sensitive,
end_comment

begin_comment
comment|//  dataflow analysis via graph reachability.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_GR_COREENGINE
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_GR_COREENGINE
end_define

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/AnalysisContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/BlockCounter.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/FunctionSummary.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/WorkList.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ProgramPointTag
decl_stmt|;
name|namespace
name|ento
block|{
name|class
name|NodeBuilder
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// CoreEngine - Implements the core logic of the graph-reachability
comment|///   analysis. It traverses the CFG and generates the ExplodedGraph.
comment|///   Program "states" are treated as opaque void pointers.
comment|///   The template class CoreEngine (which subclasses CoreEngine)
comment|///   provides the matching component to the engine that knows the actual types
comment|///   for states.  Note that this engine only dispatches to transfer functions
comment|///   at the statement and block-level.  The analyses themselves must implement
comment|///   any transfer function logic and the sub-expression level (if any).
name|class
name|CoreEngine
block|{
name|friend
struct_decl|struct
name|NodeBuilderContext
struct_decl|;
name|friend
name|class
name|NodeBuilder
decl_stmt|;
name|friend
name|class
name|ExprEngine
decl_stmt|;
name|friend
name|class
name|CommonNodeBuilder
decl_stmt|;
name|friend
name|class
name|IndirectGotoNodeBuilder
decl_stmt|;
name|friend
name|class
name|SwitchNodeBuilder
decl_stmt|;
name|friend
name|class
name|EndOfFunctionNodeBuilder
decl_stmt|;
name|public
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|BlockEdge
operator|,
specifier|const
name|ExplodedNode
operator|*
operator|>
expr|>
name|BlocksExhausted
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|CFGBlock
operator|*
operator|,
specifier|const
name|ExplodedNode
operator|*
operator|>
expr|>
name|BlocksAborted
expr_stmt|;
name|private
label|:
name|SubEngine
modifier|&
name|SubEng
decl_stmt|;
comment|/// G - The simulation graph.  Each node is a (location,state) pair.
name|std
operator|::
name|unique_ptr
operator|<
name|ExplodedGraph
operator|>
name|G
expr_stmt|;
comment|/// WList - A set of queued nodes that need to be processed by the
comment|///  worklist algorithm.  It is up to the implementation of WList to decide
comment|///  the order that nodes are processed.
name|std
operator|::
name|unique_ptr
operator|<
name|WorkList
operator|>
name|WList
expr_stmt|;
comment|/// BCounterFactory - A factory object for created BlockCounter objects.
comment|///   These are used to record for key nodes in the ExplodedGraph the
comment|///   number of times different CFGBlocks have been visited along a path.
name|BlockCounter
operator|::
name|Factory
name|BCounterFactory
expr_stmt|;
comment|/// The locations where we stopped doing work because we visited a location
comment|///  too many times.
name|BlocksExhausted
name|blocksExhausted
decl_stmt|;
comment|/// The locations where we stopped because the engine aborted analysis,
comment|/// usually because it could not reason about something.
name|BlocksAborted
name|blocksAborted
decl_stmt|;
comment|/// The information about functions shared by the whole translation unit.
comment|/// (This data is owned by AnalysisConsumer.)
name|FunctionSummariesTy
modifier|*
name|FunctionSummaries
decl_stmt|;
name|void
name|generateNode
parameter_list|(
specifier|const
name|ProgramPoint
modifier|&
name|Loc
parameter_list|,
name|ProgramStateRef
name|State
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|HandleBlockEdge
parameter_list|(
specifier|const
name|BlockEdge
modifier|&
name|E
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|HandleBlockEntrance
parameter_list|(
specifier|const
name|BlockEntrance
modifier|&
name|E
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|HandleBlockExit
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|HandlePostStmt
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
name|unsigned
name|StmtIdx
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|HandleBranch
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|Cond
parameter_list|,
specifier|const
name|Stmt
modifier|*
name|Term
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
comment|/// Handle conditional logic for running static initializers.
name|void
name|HandleStaticInit
parameter_list|(
specifier|const
name|DeclStmt
modifier|*
name|DS
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|private
label|:
name|CoreEngine
argument_list|(
argument|const CoreEngine&
argument_list|)
name|LLVM_DELETED_FUNCTION
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|CoreEngine
operator|&
operator|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|ExplodedNode
modifier|*
name|generateCallExitBeginNode
parameter_list|(
name|ExplodedNode
modifier|*
name|N
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Construct a CoreEngine object to analyze the provided CFG.
name|CoreEngine
argument_list|(
name|SubEngine
operator|&
name|subengine
argument_list|,
name|FunctionSummariesTy
operator|*
name|FS
argument_list|)
operator|:
name|SubEng
argument_list|(
name|subengine
argument_list|)
operator|,
name|G
argument_list|(
argument|new ExplodedGraph()
argument_list|)
operator|,
name|WList
argument_list|(
name|WorkList
operator|::
name|makeDFS
argument_list|()
argument_list|)
operator|,
name|BCounterFactory
argument_list|(
name|G
operator|->
name|getAllocator
argument_list|()
argument_list|)
operator|,
name|FunctionSummaries
argument_list|(
argument|FS
argument_list|)
block|{}
comment|/// getGraph - Returns the exploded graph.
name|ExplodedGraph
operator|&
name|getGraph
argument_list|()
block|{
return|return
operator|*
name|G
operator|.
name|get
argument_list|()
return|;
block|}
comment|/// takeGraph - Returns the exploded graph.  Ownership of the graph is
comment|///  transferred to the caller.
name|ExplodedGraph
modifier|*
name|takeGraph
parameter_list|()
block|{
return|return
name|G
operator|.
name|release
argument_list|()
return|;
block|}
comment|/// ExecuteWorkList - Run the worklist algorithm for a maximum number of
comment|///  steps.  Returns true if there is still simulation state on the worklist.
name|bool
name|ExecuteWorkList
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|L
parameter_list|,
name|unsigned
name|Steps
parameter_list|,
name|ProgramStateRef
name|InitState
parameter_list|)
function_decl|;
comment|/// Returns true if there is still simulation state on the worklist.
name|bool
name|ExecuteWorkListWithInitialState
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|L
parameter_list|,
name|unsigned
name|Steps
parameter_list|,
name|ProgramStateRef
name|InitState
parameter_list|,
name|ExplodedNodeSet
modifier|&
name|Dst
parameter_list|)
function_decl|;
comment|/// Dispatch the work list item based on the given location information.
comment|/// Use Pred parameter as the predecessor state.
name|void
name|dispatchWorkItem
parameter_list|(
name|ExplodedNode
modifier|*
name|Pred
parameter_list|,
name|ProgramPoint
name|Loc
parameter_list|,
specifier|const
name|WorkListUnit
modifier|&
name|WU
parameter_list|)
function_decl|;
comment|// Functions for external checking of whether we have unfinished work
name|bool
name|wasBlockAborted
argument_list|()
specifier|const
block|{
return|return
operator|!
name|blocksAborted
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|wasBlocksExhausted
argument_list|()
specifier|const
block|{
return|return
operator|!
name|blocksExhausted
operator|.
name|empty
argument_list|()
return|;
block|}
name|bool
name|hasWorkRemaining
argument_list|()
specifier|const
block|{
return|return
name|wasBlocksExhausted
argument_list|()
operator|||
name|WList
operator|->
name|hasWork
argument_list|()
operator|||
name|wasBlockAborted
argument_list|()
return|;
block|}
comment|/// Inform the CoreEngine that a basic block was aborted because
comment|/// it could not be completely analyzed.
name|void
name|addAbortedBlock
parameter_list|(
specifier|const
name|ExplodedNode
modifier|*
name|node
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|block
parameter_list|)
block|{
name|blocksAborted
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|WorkList
operator|*
name|getWorkList
argument_list|()
specifier|const
block|{
return|return
name|WList
operator|.
name|get
argument_list|()
return|;
block|}
name|BlocksExhausted
operator|::
name|const_iterator
name|blocks_exhausted_begin
argument_list|()
specifier|const
block|{
return|return
name|blocksExhausted
operator|.
name|begin
argument_list|()
return|;
block|}
name|BlocksExhausted
operator|::
name|const_iterator
name|blocks_exhausted_end
argument_list|()
specifier|const
block|{
return|return
name|blocksExhausted
operator|.
name|end
argument_list|()
return|;
block|}
name|BlocksAborted
operator|::
name|const_iterator
name|blocks_aborted_begin
argument_list|()
specifier|const
block|{
return|return
name|blocksAborted
operator|.
name|begin
argument_list|()
return|;
block|}
name|BlocksAborted
operator|::
name|const_iterator
name|blocks_aborted_end
argument_list|()
specifier|const
block|{
return|return
name|blocksAborted
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief Enqueue the given set of nodes onto the work list.
name|void
name|enqueue
parameter_list|(
name|ExplodedNodeSet
modifier|&
name|Set
parameter_list|)
function_decl|;
comment|/// \brief Enqueue nodes that were created as a result of processing
comment|/// a statement onto the work list.
name|void
name|enqueue
parameter_list|(
name|ExplodedNodeSet
modifier|&
name|Set
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Block
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
comment|/// \brief enqueue the nodes corresponding to the end of function onto the
comment|/// end of path / work list.
name|void
name|enqueueEndOfFunction
parameter_list|(
name|ExplodedNodeSet
modifier|&
name|Set
parameter_list|)
function_decl|;
comment|/// \brief Enqueue a single node created as a result of statement processing.
name|void
name|enqueueStmtNode
parameter_list|(
name|ExplodedNode
modifier|*
name|N
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Block
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|// TODO: Turn into a calss.
struct|struct
name|NodeBuilderContext
block|{
specifier|const
name|CoreEngine
modifier|&
name|Eng
decl_stmt|;
specifier|const
name|CFGBlock
modifier|*
name|Block
decl_stmt|;
specifier|const
name|LocationContext
modifier|*
name|LC
decl_stmt|;
name|NodeBuilderContext
argument_list|(
specifier|const
name|CoreEngine
operator|&
name|E
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|B
argument_list|,
name|ExplodedNode
operator|*
name|N
argument_list|)
operator|:
name|Eng
argument_list|(
name|E
argument_list|)
operator|,
name|Block
argument_list|(
name|B
argument_list|)
operator|,
name|LC
argument_list|(
argument|N->getLocationContext()
argument_list|)
block|{
name|assert
argument_list|(
name|B
argument_list|)
block|; }
comment|/// \brief Return the CFGBlock associated with this builder.
specifier|const
name|CFGBlock
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
comment|/// \brief Returns the number of times the current basic block has been
comment|/// visited on the exploded graph path.
name|unsigned
name|blockCount
argument_list|()
specifier|const
block|{
return|return
name|Eng
operator|.
name|WList
operator|->
name|getBlockCounter
argument_list|()
operator|.
name|getNumVisited
argument_list|(
name|LC
operator|->
name|getCurrentStackFrame
argument_list|()
argument_list|,
name|Block
operator|->
name|getBlockID
argument_list|()
argument_list|)
return|;
block|}
block|}
struct|;
comment|/// \class NodeBuilder
comment|/// \brief This is the simplest builder which generates nodes in the
comment|/// ExplodedGraph.
comment|///
comment|/// The main benefit of the builder is that it automatically tracks the
comment|/// frontier nodes (or destination set). This is the set of nodes which should
comment|/// be propagated to the next step / builder. They are the nodes which have been
comment|/// added to the builder (either as the input node set or as the newly
comment|/// constructed nodes) but did not have any outgoing transitions added.
name|class
name|NodeBuilder
block|{
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
name|protected
label|:
specifier|const
name|NodeBuilderContext
modifier|&
name|C
decl_stmt|;
comment|/// Specifies if the builder results have been finalized. For example, if it
comment|/// is set to false, autotransitions are yet to be generated.
name|bool
name|Finalized
decl_stmt|;
name|bool
name|HasGeneratedNodes
decl_stmt|;
comment|/// \brief The frontier set - a set of nodes which need to be propagated after
comment|/// the builder dies.
name|ExplodedNodeSet
modifier|&
name|Frontier
decl_stmt|;
comment|/// Checkes if the results are ready.
name|virtual
name|bool
name|checkResults
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Finalized
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|bool
name|hasNoSinksInFrontier
parameter_list|()
block|{
for|for
control|(
name|iterator
name|I
init|=
name|Frontier
operator|.
name|begin
argument_list|()
init|,
name|E
init|=
name|Frontier
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|I
operator|)
operator|->
name|isSink
argument_list|()
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/// Allow subclasses to finalize results before result_begin() is executed.
name|virtual
name|void
name|finalizeResults
parameter_list|()
block|{}
name|ExplodedNode
modifier|*
name|generateNodeImpl
parameter_list|(
specifier|const
name|ProgramPoint
modifier|&
name|PP
parameter_list|,
name|ProgramStateRef
name|State
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|,
name|bool
name|MarkAsSink
init|=
name|false
parameter_list|)
function_decl|;
name|public
label|:
name|NodeBuilder
argument_list|(
argument|ExplodedNode *SrcNode
argument_list|,
argument|ExplodedNodeSet&DstSet
argument_list|,
argument|const NodeBuilderContext&Ctx
argument_list|,
argument|bool F = true
argument_list|)
block|:
name|C
argument_list|(
name|Ctx
argument_list|)
operator|,
name|Finalized
argument_list|(
name|F
argument_list|)
operator|,
name|HasGeneratedNodes
argument_list|(
name|false
argument_list|)
operator|,
name|Frontier
argument_list|(
argument|DstSet
argument_list|)
block|{
name|Frontier
operator|.
name|Add
argument_list|(
name|SrcNode
argument_list|)
block|;   }
name|NodeBuilder
argument_list|(
argument|const ExplodedNodeSet&SrcSet
argument_list|,
argument|ExplodedNodeSet&DstSet
argument_list|,
argument|const NodeBuilderContext&Ctx
argument_list|,
argument|bool F = true
argument_list|)
operator|:
name|C
argument_list|(
name|Ctx
argument_list|)
operator|,
name|Finalized
argument_list|(
name|F
argument_list|)
operator|,
name|HasGeneratedNodes
argument_list|(
name|false
argument_list|)
operator|,
name|Frontier
argument_list|(
argument|DstSet
argument_list|)
block|{
name|Frontier
operator|.
name|insert
argument_list|(
name|SrcSet
argument_list|)
block|;
name|assert
argument_list|(
name|hasNoSinksInFrontier
argument_list|()
argument_list|)
block|;   }
name|virtual
operator|~
name|NodeBuilder
argument_list|()
block|{}
comment|/// \brief Generates a node in the ExplodedGraph.
name|ExplodedNode
operator|*
name|generateNode
argument_list|(
argument|const ProgramPoint&PP
argument_list|,
argument|ProgramStateRef State
argument_list|,
argument|ExplodedNode *Pred
argument_list|)
block|{
return|return
name|generateNodeImpl
argument_list|(
name|PP
argument_list|,
name|State
argument_list|,
name|Pred
argument_list|,
name|false
argument_list|)
return|;
block|}
comment|/// \brief Generates a sink in the ExplodedGraph.
comment|///
comment|/// When a node is marked as sink, the exploration from the node is stopped -
comment|/// the node becomes the last node on the path and certain kinds of bugs are
comment|/// suppressed.
name|ExplodedNode
modifier|*
name|generateSink
parameter_list|(
specifier|const
name|ProgramPoint
modifier|&
name|PP
parameter_list|,
name|ProgramStateRef
name|State
parameter_list|,
name|ExplodedNode
modifier|*
name|Pred
parameter_list|)
block|{
return|return
name|generateNodeImpl
argument_list|(
name|PP
argument_list|,
name|State
argument_list|,
name|Pred
argument_list|,
name|true
argument_list|)
return|;
block|}
specifier|const
name|ExplodedNodeSet
modifier|&
name|getResults
parameter_list|()
block|{
name|finalizeResults
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|checkResults
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Frontier
return|;
block|}
typedef|typedef
name|ExplodedNodeSet
operator|::
name|iterator
name|iterator
expr_stmt|;
comment|/// \brief Iterators through the results frontier.
specifier|inline
name|iterator
name|begin
parameter_list|()
block|{
name|finalizeResults
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|checkResults
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Frontier
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|inline
name|iterator
name|end
parameter_list|()
block|{
name|finalizeResults
argument_list|()
expr_stmt|;
return|return
name|Frontier
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|NodeBuilderContext
modifier|&
name|getContext
parameter_list|()
block|{
return|return
name|C
return|;
block|}
name|bool
name|hasGeneratedNodes
parameter_list|()
block|{
return|return
name|HasGeneratedNodes
return|;
block|}
name|void
name|takeNodes
parameter_list|(
specifier|const
name|ExplodedNodeSet
modifier|&
name|S
parameter_list|)
block|{
for|for
control|(
name|ExplodedNodeSet
operator|::
name|iterator
name|I
operator|=
name|S
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|S
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|Frontier
operator|.
name|erase
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
name|void
name|takeNodes
parameter_list|(
name|ExplodedNode
modifier|*
name|N
parameter_list|)
block|{
name|Frontier
operator|.
name|erase
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|addNodes
parameter_list|(
specifier|const
name|ExplodedNodeSet
modifier|&
name|S
parameter_list|)
block|{
name|Frontier
operator|.
name|insert
argument_list|(
name|S
argument_list|)
expr_stmt|;
block|}
name|void
name|addNodes
parameter_list|(
name|ExplodedNode
modifier|*
name|N
parameter_list|)
block|{
name|Frontier
operator|.
name|Add
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// \class NodeBuilderWithSinks
comment|/// \brief This node builder keeps track of the generated sink nodes.
name|class
name|NodeBuilderWithSinks
range|:
name|public
name|NodeBuilder
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
name|protected
operator|:
name|SmallVector
operator|<
name|ExplodedNode
operator|*
block|,
literal|2
operator|>
name|sinksGenerated
block|;
name|ProgramPoint
operator|&
name|Location
block|;
name|public
operator|:
name|NodeBuilderWithSinks
argument_list|(
name|ExplodedNode
operator|*
name|Pred
argument_list|,
name|ExplodedNodeSet
operator|&
name|DstSet
argument_list|,
specifier|const
name|NodeBuilderContext
operator|&
name|Ctx
argument_list|,
name|ProgramPoint
operator|&
name|L
argument_list|)
operator|:
name|NodeBuilder
argument_list|(
name|Pred
argument_list|,
name|DstSet
argument_list|,
name|Ctx
argument_list|)
block|,
name|Location
argument_list|(
argument|L
argument_list|)
block|{}
name|ExplodedNode
operator|*
name|generateNode
argument_list|(
argument|ProgramStateRef State
argument_list|,
argument|ExplodedNode *Pred
argument_list|,
argument|const ProgramPointTag *Tag = nullptr
argument_list|)
block|{
specifier|const
name|ProgramPoint
operator|&
name|LocalLoc
operator|=
operator|(
name|Tag
operator|?
name|Location
operator|.
name|withTag
argument_list|(
name|Tag
argument_list|)
operator|:
name|Location
operator|)
block|;
return|return
name|NodeBuilder
operator|::
name|generateNode
argument_list|(
name|LocalLoc
argument_list|,
name|State
argument_list|,
name|Pred
argument_list|)
return|;
block|}
name|ExplodedNode
operator|*
name|generateSink
argument_list|(
argument|ProgramStateRef State
argument_list|,
argument|ExplodedNode *Pred
argument_list|,
argument|const ProgramPointTag *Tag = nullptr
argument_list|)
block|{
specifier|const
name|ProgramPoint
operator|&
name|LocalLoc
operator|=
operator|(
name|Tag
condition|?
name|Location
operator|.
name|withTag
argument_list|(
name|Tag
argument_list|)
else|:
name|Location
operator|)
block|;
name|ExplodedNode
operator|*
name|N
operator|=
name|NodeBuilder
operator|::
name|generateSink
argument_list|(
name|LocalLoc
argument_list|,
name|State
argument_list|,
name|Pred
argument_list|)
block|;
if|if
condition|(
name|N
operator|&&
name|N
operator|->
name|isSink
argument_list|()
condition|)
name|sinksGenerated
operator|.
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
return|return
name|N
return|;
block|}
specifier|const
name|SmallVectorImpl
operator|<
name|ExplodedNode
operator|*
operator|>
operator|&
name|getSinks
argument_list|()
specifier|const
block|{
return|return
name|sinksGenerated
return|;
block|}
block|}
empty_stmt|;
comment|/// \class StmtNodeBuilder
comment|/// \brief This builder class is useful for generating nodes that resulted from
comment|/// visiting a statement. The main difference from its parent NodeBuilder is
comment|/// that it creates a statement specific ProgramPoint.
name|class
name|StmtNodeBuilder
range|:
name|public
name|NodeBuilder
block|{
name|NodeBuilder
operator|*
name|EnclosingBldr
block|;
name|public
operator|:
comment|/// \brief Constructs a StmtNodeBuilder. If the builder is going to process
comment|/// nodes currently owned by another builder(with larger scope), use
comment|/// Enclosing builder to transfer ownership.
name|StmtNodeBuilder
argument_list|(
name|ExplodedNode
operator|*
name|SrcNode
argument_list|,
name|ExplodedNodeSet
operator|&
name|DstSet
argument_list|,
specifier|const
name|NodeBuilderContext
operator|&
name|Ctx
argument_list|,
name|NodeBuilder
operator|*
name|Enclosing
operator|=
name|nullptr
argument_list|)
operator|:
name|NodeBuilder
argument_list|(
name|SrcNode
argument_list|,
name|DstSet
argument_list|,
name|Ctx
argument_list|)
block|,
name|EnclosingBldr
argument_list|(
argument|Enclosing
argument_list|)
block|{
if|if
condition|(
name|EnclosingBldr
condition|)
name|EnclosingBldr
operator|->
name|takeNodes
argument_list|(
name|SrcNode
argument_list|)
expr_stmt|;
block|}
name|StmtNodeBuilder
argument_list|(
name|ExplodedNodeSet
operator|&
name|SrcSet
argument_list|,
name|ExplodedNodeSet
operator|&
name|DstSet
argument_list|,
specifier|const
name|NodeBuilderContext
operator|&
name|Ctx
argument_list|,
name|NodeBuilder
operator|*
name|Enclosing
operator|=
name|nullptr
argument_list|)
operator|:
name|NodeBuilder
argument_list|(
name|SrcSet
argument_list|,
name|DstSet
argument_list|,
name|Ctx
argument_list|)
block|,
name|EnclosingBldr
argument_list|(
argument|Enclosing
argument_list|)
block|{
if|if
condition|(
name|EnclosingBldr
condition|)
for|for
control|(
name|ExplodedNodeSet
operator|::
name|iterator
name|I
operator|=
name|SrcSet
operator|.
name|begin
argument_list|()
init|,
name|E
operator|=
name|SrcSet
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|EnclosingBldr
operator|->
name|takeNodes
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
name|virtual
operator|~
name|StmtNodeBuilder
argument_list|()
block|;
name|using
name|NodeBuilder
operator|::
name|generateNode
block|;
name|using
name|NodeBuilder
operator|::
name|generateSink
block|;
name|ExplodedNode
operator|*
name|generateNode
argument_list|(
argument|const Stmt *S
argument_list|,
argument|ExplodedNode *Pred
argument_list|,
argument|ProgramStateRef St
argument_list|,
argument|const ProgramPointTag *tag = nullptr
argument_list|,
argument|ProgramPoint::Kind K = ProgramPoint::PostStmtKind
argument_list|)
block|{
specifier|const
name|ProgramPoint
operator|&
name|L
operator|=
name|ProgramPoint
operator|::
name|getProgramPoint
argument_list|(
name|S
argument_list|,
name|K
argument_list|,
name|Pred
operator|->
name|getLocationContext
argument_list|()
argument_list|,
name|tag
argument_list|)
block|;
return|return
name|NodeBuilder
operator|::
name|generateNode
argument_list|(
name|L
argument_list|,
name|St
argument_list|,
name|Pred
argument_list|)
return|;
block|}
name|ExplodedNode
operator|*
name|generateSink
argument_list|(
argument|const Stmt *S
argument_list|,
argument|ExplodedNode *Pred
argument_list|,
argument|ProgramStateRef St
argument_list|,
argument|const ProgramPointTag *tag = nullptr
argument_list|,
argument|ProgramPoint::Kind K = ProgramPoint::PostStmtKind
argument_list|)
block|{
specifier|const
name|ProgramPoint
operator|&
name|L
operator|=
name|ProgramPoint
operator|::
name|getProgramPoint
argument_list|(
name|S
argument_list|,
name|K
argument_list|,
name|Pred
operator|->
name|getLocationContext
argument_list|()
argument_list|,
name|tag
argument_list|)
block|;
return|return
name|NodeBuilder
operator|::
name|generateSink
argument_list|(
name|L
argument_list|,
name|St
argument_list|,
name|Pred
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief BranchNodeBuilder is responsible for constructing the nodes
comment|/// corresponding to the two branches of the if statement - true and false.
name|class
name|BranchNodeBuilder
operator|:
name|public
name|NodeBuilder
block|{
name|void
name|anchor
argument_list|()
name|override
block|;
specifier|const
name|CFGBlock
operator|*
name|DstT
block|;
specifier|const
name|CFGBlock
operator|*
name|DstF
block|;
name|bool
name|InFeasibleTrue
block|;
name|bool
name|InFeasibleFalse
block|;
name|public
operator|:
name|BranchNodeBuilder
argument_list|(
name|ExplodedNode
operator|*
name|SrcNode
argument_list|,
name|ExplodedNodeSet
operator|&
name|DstSet
argument_list|,
specifier|const
name|NodeBuilderContext
operator|&
name|C
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|dstT
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|dstF
argument_list|)
operator|:
name|NodeBuilder
argument_list|(
name|SrcNode
argument_list|,
name|DstSet
argument_list|,
name|C
argument_list|)
block|,
name|DstT
argument_list|(
name|dstT
argument_list|)
block|,
name|DstF
argument_list|(
name|dstF
argument_list|)
block|,
name|InFeasibleTrue
argument_list|(
operator|!
name|DstT
argument_list|)
block|,
name|InFeasibleFalse
argument_list|(
argument|!DstF
argument_list|)
block|{
comment|// The branch node builder does not generate autotransitions.
comment|// If there are no successors it means that both branches are infeasible.
name|takeNodes
argument_list|(
name|SrcNode
argument_list|)
block|;   }
name|BranchNodeBuilder
argument_list|(
specifier|const
name|ExplodedNodeSet
operator|&
name|SrcSet
argument_list|,
name|ExplodedNodeSet
operator|&
name|DstSet
argument_list|,
specifier|const
name|NodeBuilderContext
operator|&
name|C
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|dstT
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|dstF
argument_list|)
operator|:
name|NodeBuilder
argument_list|(
name|SrcSet
argument_list|,
name|DstSet
argument_list|,
name|C
argument_list|)
block|,
name|DstT
argument_list|(
name|dstT
argument_list|)
block|,
name|DstF
argument_list|(
name|dstF
argument_list|)
block|,
name|InFeasibleTrue
argument_list|(
operator|!
name|DstT
argument_list|)
block|,
name|InFeasibleFalse
argument_list|(
argument|!DstF
argument_list|)
block|{
name|takeNodes
argument_list|(
name|SrcSet
argument_list|)
block|;   }
name|ExplodedNode
operator|*
name|generateNode
argument_list|(
argument|ProgramStateRef State
argument_list|,
argument|bool branch
argument_list|,
argument|ExplodedNode *Pred
argument_list|)
block|;
specifier|const
name|CFGBlock
operator|*
name|getTargetBlock
argument_list|(
argument|bool branch
argument_list|)
specifier|const
block|{
return|return
name|branch
operator|?
name|DstT
operator|:
name|DstF
return|;
block|}
name|void
name|markInfeasible
argument_list|(
argument|bool branch
argument_list|)
block|{
if|if
condition|(
name|branch
condition|)
name|InFeasibleTrue
operator|=
name|true
expr_stmt|;
else|else
name|InFeasibleFalse
operator|=
name|true
expr_stmt|;
block|}
name|bool
name|isFeasible
argument_list|(
argument|bool branch
argument_list|)
block|{
return|return
name|branch
operator|?
operator|!
name|InFeasibleTrue
operator|:
operator|!
name|InFeasibleFalse
return|;
block|}
expr|}
block|;
name|class
name|IndirectGotoNodeBuilder
block|{
name|CoreEngine
operator|&
name|Eng
block|;
specifier|const
name|CFGBlock
operator|*
name|Src
block|;
specifier|const
name|CFGBlock
operator|&
name|DispatchBlock
block|;
specifier|const
name|Expr
operator|*
name|E
block|;
name|ExplodedNode
operator|*
name|Pred
block|;
name|public
operator|:
name|IndirectGotoNodeBuilder
argument_list|(
name|ExplodedNode
operator|*
name|pred
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|src
argument_list|,
specifier|const
name|Expr
operator|*
name|e
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|dispatch
argument_list|,
name|CoreEngine
operator|*
name|eng
argument_list|)
operator|:
name|Eng
argument_list|(
operator|*
name|eng
argument_list|)
block|,
name|Src
argument_list|(
name|src
argument_list|)
block|,
name|DispatchBlock
argument_list|(
operator|*
name|dispatch
argument_list|)
block|,
name|E
argument_list|(
name|e
argument_list|)
block|,
name|Pred
argument_list|(
argument|pred
argument_list|)
block|{}
name|class
name|iterator
block|{
name|CFGBlock
operator|::
name|const_succ_iterator
name|I
block|;
name|friend
name|class
name|IndirectGotoNodeBuilder
block|;
name|iterator
argument_list|(
argument|CFGBlock::const_succ_iterator i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|public
operator|:
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|X
operator|.
name|I
return|;
block|}
specifier|const
name|LabelDecl
operator|*
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|LabelStmt
operator|>
operator|(
operator|(
operator|*
name|I
operator|)
operator|->
name|getLabel
argument_list|()
operator|)
operator|->
name|getDecl
argument_list|()
return|;
block|}
specifier|const
name|CFGBlock
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
operator|*
name|I
return|;
block|}
expr|}
block|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|DispatchBlock
operator|.
name|succ_begin
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|DispatchBlock
operator|.
name|succ_end
argument_list|()
argument_list|)
return|;
block|}
name|ExplodedNode
operator|*
name|generateNode
argument_list|(
argument|const iterator&I
argument_list|,
argument|ProgramStateRef State
argument_list|,
argument|bool isSink = false
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getTarget
argument_list|()
specifier|const
block|{
return|return
name|E
return|;
block|}
name|ProgramStateRef
name|getState
argument_list|()
specifier|const
block|{
return|return
name|Pred
operator|->
name|State
return|;
block|}
specifier|const
name|LocationContext
operator|*
name|getLocationContext
argument_list|()
specifier|const
block|{
return|return
name|Pred
operator|->
name|getLocationContext
argument_list|()
return|;
block|}
expr|}
block|;
name|class
name|SwitchNodeBuilder
block|{
name|CoreEngine
operator|&
name|Eng
block|;
specifier|const
name|CFGBlock
operator|*
name|Src
block|;
specifier|const
name|Expr
operator|*
name|Condition
block|;
name|ExplodedNode
operator|*
name|Pred
block|;
name|public
operator|:
name|SwitchNodeBuilder
argument_list|(
name|ExplodedNode
operator|*
name|pred
argument_list|,
specifier|const
name|CFGBlock
operator|*
name|src
argument_list|,
specifier|const
name|Expr
operator|*
name|condition
argument_list|,
name|CoreEngine
operator|*
name|eng
argument_list|)
operator|:
name|Eng
argument_list|(
operator|*
name|eng
argument_list|)
block|,
name|Src
argument_list|(
name|src
argument_list|)
block|,
name|Condition
argument_list|(
name|condition
argument_list|)
block|,
name|Pred
argument_list|(
argument|pred
argument_list|)
block|{}
name|class
name|iterator
block|{
name|CFGBlock
operator|::
name|const_succ_reverse_iterator
name|I
block|;
name|friend
name|class
name|SwitchNodeBuilder
block|;
name|iterator
argument_list|(
argument|CFGBlock::const_succ_reverse_iterator i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|public
operator|:
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|X
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|X
operator|.
name|I
return|;
block|}
specifier|const
name|CaseStmt
operator|*
name|getCase
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|CaseStmt
operator|>
operator|(
operator|(
operator|*
name|I
operator|)
operator|->
name|getLabel
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CFGBlock
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
operator|*
name|I
return|;
block|}
expr|}
block|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|Src
operator|->
name|succ_rbegin
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|Src
operator|->
name|succ_rend
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|SwitchStmt
operator|*
name|getSwitch
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|SwitchStmt
operator|>
operator|(
name|Src
operator|->
name|getTerminator
argument_list|()
operator|)
return|;
block|}
name|ExplodedNode
operator|*
name|generateCaseStmtNode
argument_list|(
argument|const iterator&I
argument_list|,
argument|ProgramStateRef State
argument_list|)
block|;
name|ExplodedNode
operator|*
name|generateDefaultCaseNode
argument_list|(
argument|ProgramStateRef State
argument_list|,
argument|bool isSink = false
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getCondition
argument_list|()
specifier|const
block|{
return|return
name|Condition
return|;
block|}
name|ProgramStateRef
name|getState
argument_list|()
specifier|const
block|{
return|return
name|Pred
operator|->
name|State
return|;
block|}
specifier|const
name|LocationContext
operator|*
name|getLocationContext
argument_list|()
specifier|const
block|{
return|return
name|Pred
operator|->
name|getLocationContext
argument_list|()
return|;
block|}
expr|}
block|;  }
comment|// end ento namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

