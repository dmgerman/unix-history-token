begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- PathDiagnostic.h - Path-Specific Diagnostic Handling ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the PathDiagnostic-related interfaces.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H
end_define

begin_include
include|#
directive|include
file|"clang/Analysis/ProgramPoint.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/IntrusiveRefCntPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|<deque>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ConditionalOperator
decl_stmt|;
name|class
name|AnalysisDeclContext
decl_stmt|;
name|class
name|BinaryOperator
decl_stmt|;
name|class
name|CompoundStmt
decl_stmt|;
name|class
name|Decl
decl_stmt|;
name|class
name|LocationContext
decl_stmt|;
name|class
name|MemberExpr
decl_stmt|;
name|class
name|ParentMap
decl_stmt|;
name|class
name|ProgramPoint
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
name|class
name|Stmt
decl_stmt|;
name|class
name|CallExpr
decl_stmt|;
name|namespace
name|ento
block|{
name|class
name|ExplodedNode
decl_stmt|;
name|class
name|SymExpr
decl_stmt|;
typedef|typedef
specifier|const
name|SymExpr
modifier|*
name|SymbolRef
typedef|;
comment|//===----------------------------------------------------------------------===//
comment|// High-level interface for handlers of path-sensitive diagnostics.
comment|//===----------------------------------------------------------------------===//
name|class
name|PathDiagnostic
decl_stmt|;
name|class
name|PathDiagnosticConsumer
block|{
name|public
label|:
name|class
name|PDFileEntry
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
name|PDFileEntry
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|NodeID
argument_list|)
operator|:
name|NodeID
argument_list|(
argument|NodeID
argument_list|)
block|{}
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|StringRef
operator|,
name|StringRef
operator|>
expr|>
name|ConsumerFiles
expr_stmt|;
comment|/// \brief A vector of<consumer,file> pairs.
name|ConsumerFiles
name|files
decl_stmt|;
comment|/// \brief A precomputed hash tag used for uniquing PDFileEntry objects.
specifier|const
name|llvm
operator|::
name|FoldingSetNodeID
name|NodeID
expr_stmt|;
comment|/// \brief Used for profiling in the FoldingSet.
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|{
name|ID
operator|=
name|NodeID
expr_stmt|;
block|}
block|}
empty_stmt|;
name|class
name|FilesMade
block|{
name|llvm
operator|::
name|BumpPtrAllocator
name|Alloc
expr_stmt|;
name|llvm
operator|::
name|FoldingSet
operator|<
name|PDFileEntry
operator|>
name|Set
expr_stmt|;
name|public
label|:
operator|~
name|FilesMade
argument_list|()
expr_stmt|;
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Set
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|addDiagnostic
parameter_list|(
specifier|const
name|PathDiagnostic
modifier|&
name|PD
parameter_list|,
name|StringRef
name|ConsumerName
parameter_list|,
name|StringRef
name|fileName
parameter_list|)
function_decl|;
name|PDFileEntry
operator|::
name|ConsumerFiles
operator|*
name|getFiles
argument_list|(
specifier|const
name|PathDiagnostic
operator|&
name|PD
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|private
label|:
name|virtual
name|void
name|anchor
parameter_list|()
function_decl|;
name|public
label|:
name|PathDiagnosticConsumer
argument_list|()
operator|:
name|flushed
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
operator|~
name|PathDiagnosticConsumer
argument_list|()
expr_stmt|;
name|void
name|FlushDiagnostics
parameter_list|(
name|FilesMade
modifier|*
name|FilesMade
parameter_list|)
function_decl|;
name|virtual
name|void
name|FlushDiagnosticsImpl
argument_list|(
name|std
operator|::
name|vector
operator|<
specifier|const
name|PathDiagnostic
operator|*
operator|>
operator|&
name|Diags
argument_list|,
name|FilesMade
operator|*
name|filesMade
argument_list|)
init|=
literal|0
decl_stmt|;
name|virtual
name|StringRef
name|getName
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|void
name|HandlePathDiagnostic
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|PathDiagnostic
operator|>
name|D
argument_list|)
decl_stmt|;
enum|enum
name|PathGenerationScheme
block|{
name|None
block|,
name|Minimal
block|,
name|Extensive
block|,
name|AlternateExtensive
block|}
enum|;
name|virtual
name|PathGenerationScheme
name|getGenerationScheme
argument_list|()
specifier|const
block|{
return|return
name|Minimal
return|;
block|}
name|virtual
name|bool
name|supportsLogicalOpControlFlow
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// Return true if the PathDiagnosticConsumer supports individual
comment|/// PathDiagnostics that span multiple files.
name|virtual
name|bool
name|supportsCrossFileDiagnostics
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
name|protected
label|:
name|bool
name|flushed
decl_stmt|;
name|llvm
operator|::
name|FoldingSet
operator|<
name|PathDiagnostic
operator|>
name|Diags
expr_stmt|;
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Path-sensitive diagnostics.
comment|//===----------------------------------------------------------------------===//
name|class
name|PathDiagnosticRange
range|:
name|public
name|SourceRange
block|{
name|public
operator|:
name|bool
name|isPoint
block|;
name|PathDiagnosticRange
argument_list|(
argument|SourceRange R
argument_list|,
argument|bool isP = false
argument_list|)
operator|:
name|SourceRange
argument_list|(
name|R
argument_list|)
block|,
name|isPoint
argument_list|(
argument|isP
argument_list|)
block|{}
name|PathDiagnosticRange
argument_list|()
operator|:
name|isPoint
argument_list|(
argument|false
argument_list|)
block|{}
block|}
decl_stmt|;
typedef|typedef
name|llvm
operator|::
name|PointerUnion
operator|<
specifier|const
name|LocationContext
operator|*
operator|,
name|AnalysisDeclContext
operator|*
operator|>
name|LocationOrAnalysisDeclContext
expr_stmt|;
name|class
name|PathDiagnosticLocation
block|{
name|private
label|:
enum|enum
name|Kind
block|{
name|RangeK
block|,
name|SingleLocK
block|,
name|StmtK
block|,
name|DeclK
block|}
name|K
enum|;
specifier|const
name|Stmt
modifier|*
name|S
decl_stmt|;
specifier|const
name|Decl
modifier|*
name|D
decl_stmt|;
specifier|const
name|SourceManager
modifier|*
name|SM
decl_stmt|;
name|FullSourceLoc
name|Loc
decl_stmt|;
name|PathDiagnosticRange
name|Range
decl_stmt|;
name|PathDiagnosticLocation
argument_list|(
argument|SourceLocation L
argument_list|,
argument|const SourceManager&sm
argument_list|,
argument|Kind kind
argument_list|)
block|:
name|K
argument_list|(
name|kind
argument_list|)
operator|,
name|S
argument_list|(
name|nullptr
argument_list|)
operator|,
name|D
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SM
argument_list|(
operator|&
name|sm
argument_list|)
operator|,
name|Loc
argument_list|(
name|genLocation
argument_list|(
name|L
argument_list|)
argument_list|)
operator|,
name|Range
argument_list|(
argument|genRange()
argument_list|)
block|{   }
name|FullSourceLoc
name|genLocation
argument_list|(
argument|SourceLocation L = SourceLocation()
argument_list|,
argument|LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr
argument_list|)
specifier|const
expr_stmt|;
name|PathDiagnosticRange
name|genRange
argument_list|(
name|LocationOrAnalysisDeclContext
name|LAC
operator|=
operator|(
name|AnalysisDeclContext
operator|*
operator|)
name|nullptr
argument_list|)
decl|const
decl_stmt|;
name|public
label|:
comment|/// Create an invalid location.
name|PathDiagnosticLocation
argument_list|()
operator|:
name|K
argument_list|(
name|SingleLocK
argument_list|)
operator|,
name|S
argument_list|(
name|nullptr
argument_list|)
operator|,
name|D
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SM
argument_list|(
argument|nullptr
argument_list|)
block|{}
comment|/// Create a location corresponding to the given statement.
name|PathDiagnosticLocation
argument_list|(
argument|const Stmt *s
argument_list|,
argument|const SourceManager&sm
argument_list|,
argument|LocationOrAnalysisDeclContext lac
argument_list|)
operator|:
name|K
argument_list|(
name|s
operator|->
name|getLocStart
argument_list|()
operator|.
name|isValid
argument_list|()
operator|?
name|StmtK
operator|:
name|SingleLocK
argument_list|)
operator|,
name|S
argument_list|(
name|K
operator|==
name|StmtK
operator|?
name|s
operator|:
name|nullptr
argument_list|)
operator|,
name|D
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SM
argument_list|(
operator|&
name|sm
argument_list|)
operator|,
name|Loc
argument_list|(
name|genLocation
argument_list|(
name|SourceLocation
argument_list|()
argument_list|,
name|lac
argument_list|)
argument_list|)
operator|,
name|Range
argument_list|(
argument|genRange(lac)
argument_list|)
block|{
name|assert
argument_list|(
name|K
operator|==
name|SingleLocK
operator|||
name|S
argument_list|)
block|;
name|assert
argument_list|(
name|K
operator|==
name|SingleLocK
operator|||
name|Loc
operator|.
name|isValid
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|K
operator|==
name|SingleLocK
operator|||
name|Range
operator|.
name|isValid
argument_list|()
argument_list|)
block|;   }
comment|/// Create a location corresponding to the given declaration.
name|PathDiagnosticLocation
argument_list|(
specifier|const
name|Decl
operator|*
name|d
argument_list|,
specifier|const
name|SourceManager
operator|&
name|sm
argument_list|)
operator|:
name|K
argument_list|(
name|DeclK
argument_list|)
operator|,
name|S
argument_list|(
name|nullptr
argument_list|)
operator|,
name|D
argument_list|(
name|d
argument_list|)
operator|,
name|SM
argument_list|(
operator|&
name|sm
argument_list|)
operator|,
name|Loc
argument_list|(
name|genLocation
argument_list|()
argument_list|)
operator|,
name|Range
argument_list|(
argument|genRange()
argument_list|)
block|{
name|assert
argument_list|(
name|D
argument_list|)
block|;
name|assert
argument_list|(
name|Loc
operator|.
name|isValid
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|Range
operator|.
name|isValid
argument_list|()
argument_list|)
block|;   }
comment|/// Create a location at an explicit offset in the source.
comment|///
comment|/// This should only be used if there are no more appropriate constructors.
name|PathDiagnosticLocation
argument_list|(
argument|SourceLocation loc
argument_list|,
argument|const SourceManager&sm
argument_list|)
operator|:
name|K
argument_list|(
name|SingleLocK
argument_list|)
operator|,
name|S
argument_list|(
name|nullptr
argument_list|)
operator|,
name|D
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SM
argument_list|(
operator|&
name|sm
argument_list|)
operator|,
name|Loc
argument_list|(
name|loc
argument_list|,
name|sm
argument_list|)
operator|,
name|Range
argument_list|(
argument|genRange()
argument_list|)
block|{
name|assert
argument_list|(
name|Loc
operator|.
name|isValid
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|Range
operator|.
name|isValid
argument_list|()
argument_list|)
block|;   }
comment|/// Create a location corresponding to the given declaration.
specifier|static
name|PathDiagnosticLocation
name|create
argument_list|(
argument|const Decl *D
argument_list|,
argument|const SourceManager&SM
argument_list|)
block|{
return|return
name|PathDiagnosticLocation
argument_list|(
name|D
argument_list|,
name|SM
argument_list|)
return|;
block|}
comment|/// Create a location for the beginning of the declaration.
specifier|static
name|PathDiagnosticLocation
name|createBegin
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Create a location for the beginning of the statement.
specifier|static
name|PathDiagnosticLocation
name|createBegin
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|S
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|,
specifier|const
name|LocationOrAnalysisDeclContext
name|LAC
parameter_list|)
function_decl|;
comment|/// Create a location for the end of the statement.
comment|///
comment|/// If the statement is a CompoundStatement, the location will point to the
comment|/// closing brace instead of following it.
specifier|static
name|PathDiagnosticLocation
name|createEnd
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|S
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|,
specifier|const
name|LocationOrAnalysisDeclContext
name|LAC
parameter_list|)
function_decl|;
comment|/// Create the location for the operator of the binary expression.
comment|/// Assumes the statement has a valid location.
specifier|static
name|PathDiagnosticLocation
name|createOperatorLoc
parameter_list|(
specifier|const
name|BinaryOperator
modifier|*
name|BO
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
specifier|static
name|PathDiagnosticLocation
name|createConditionalColonLoc
parameter_list|(
specifier|const
name|ConditionalOperator
modifier|*
name|CO
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// For member expressions, return the location of the '.' or '->'.
comment|/// Assumes the statement has a valid location.
specifier|static
name|PathDiagnosticLocation
name|createMemberLoc
parameter_list|(
specifier|const
name|MemberExpr
modifier|*
name|ME
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Create a location for the beginning of the compound statement.
comment|/// Assumes the statement has a valid location.
specifier|static
name|PathDiagnosticLocation
name|createBeginBrace
parameter_list|(
specifier|const
name|CompoundStmt
modifier|*
name|CS
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Create a location for the end of the compound statement.
comment|/// Assumes the statement has a valid location.
specifier|static
name|PathDiagnosticLocation
name|createEndBrace
parameter_list|(
specifier|const
name|CompoundStmt
modifier|*
name|CS
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Create a location for the beginning of the enclosing declaration body.
comment|/// Defaults to the beginning of the first statement in the declaration body.
specifier|static
name|PathDiagnosticLocation
name|createDeclBegin
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|LC
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Constructs a location for the end of the enclosing declaration body.
comment|/// Defaults to the end of brace.
specifier|static
name|PathDiagnosticLocation
name|createDeclEnd
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|LC
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Create a location corresponding to the given valid ExplodedNode.
specifier|static
name|PathDiagnosticLocation
name|create
parameter_list|(
specifier|const
name|ProgramPoint
modifier|&
name|P
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SMng
parameter_list|)
function_decl|;
comment|/// Create a location corresponding to the next valid ExplodedNode as end
comment|/// of path location.
specifier|static
name|PathDiagnosticLocation
name|createEndOfPath
parameter_list|(
specifier|const
name|ExplodedNode
modifier|*
name|N
parameter_list|,
specifier|const
name|SourceManager
modifier|&
name|SM
parameter_list|)
function_decl|;
comment|/// Convert the given location into a single kind location.
specifier|static
name|PathDiagnosticLocation
name|createSingleLocation
parameter_list|(
specifier|const
name|PathDiagnosticLocation
modifier|&
name|PDL
parameter_list|)
function_decl|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|PathDiagnosticLocation
operator|&
name|X
operator|)
specifier|const
block|{
return|return
name|K
operator|==
name|X
operator|.
name|K
operator|&&
name|Loc
operator|==
name|X
operator|.
name|Loc
operator|&&
name|Range
operator|==
name|X
operator|.
name|Range
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|PathDiagnosticLocation
operator|&
name|X
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|X
operator|)
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|SM
operator|!=
name|nullptr
return|;
block|}
name|FullSourceLoc
name|asLocation
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|PathDiagnosticRange
name|asRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
specifier|const
name|Stmt
operator|*
name|asStmt
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
argument_list|)
block|;
return|return
name|S
return|;
block|}
specifier|const
name|Decl
operator|*
name|asDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
argument_list|)
block|;
return|return
name|D
return|;
block|}
name|bool
name|hasRange
argument_list|()
specifier|const
block|{
return|return
name|K
operator|==
name|StmtK
operator|||
name|K
operator|==
name|RangeK
operator|||
name|K
operator|==
name|DeclK
return|;
block|}
name|void
name|invalidate
parameter_list|()
block|{
operator|*
name|this
operator|=
name|PathDiagnosticLocation
argument_list|()
expr_stmt|;
block|}
name|void
name|flatten
parameter_list|()
function_decl|;
specifier|const
name|SourceManager
operator|&
name|getManager
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isValid
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|SM
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Given an exploded node, retrieve the statement that should be used
comment|/// for the diagnostic location.
specifier|static
specifier|const
name|Stmt
modifier|*
name|getStmt
parameter_list|(
specifier|const
name|ExplodedNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// \brief Retrieve the statement corresponding to the successor node.
specifier|static
specifier|const
name|Stmt
modifier|*
name|getNextStmt
parameter_list|(
specifier|const
name|ExplodedNode
modifier|*
name|N
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|class
name|PathDiagnosticLocationPair
block|{
name|private
label|:
name|PathDiagnosticLocation
name|Start
decl_stmt|,
name|End
decl_stmt|;
name|public
label|:
name|PathDiagnosticLocationPair
argument_list|(
specifier|const
name|PathDiagnosticLocation
operator|&
name|start
argument_list|,
specifier|const
name|PathDiagnosticLocation
operator|&
name|end
argument_list|)
operator|:
name|Start
argument_list|(
name|start
argument_list|)
operator|,
name|End
argument_list|(
argument|end
argument_list|)
block|{}
specifier|const
name|PathDiagnosticLocation
operator|&
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Start
return|;
block|}
specifier|const
name|PathDiagnosticLocation
operator|&
name|getEnd
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
name|void
name|setStart
parameter_list|(
specifier|const
name|PathDiagnosticLocation
modifier|&
name|L
parameter_list|)
block|{
name|Start
operator|=
name|L
expr_stmt|;
block|}
name|void
name|setEnd
parameter_list|(
specifier|const
name|PathDiagnosticLocation
modifier|&
name|L
parameter_list|)
block|{
name|End
operator|=
name|L
expr_stmt|;
block|}
name|void
name|flatten
parameter_list|()
block|{
name|Start
operator|.
name|flatten
argument_list|()
expr_stmt|;
name|End
operator|.
name|flatten
argument_list|()
expr_stmt|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
block|{
name|Start
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
expr_stmt|;
name|End
operator|.
name|Profile
argument_list|(
name|ID
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Path "pieces" for path-sensitive diagnostics.
comment|//===----------------------------------------------------------------------===//
name|class
name|PathDiagnosticPiece
range|:
name|public
name|RefCountedBaseVPTR
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|ControlFlow
block|,
name|Event
block|,
name|Macro
block|,
name|Call
block|}
block|;   enum
name|DisplayHint
block|{
name|Above
block|,
name|Below
block|}
block|;
name|private
operator|:
specifier|const
name|std
operator|::
name|string
name|str
block|;
specifier|const
name|Kind
name|kind
block|;
specifier|const
name|DisplayHint
name|Hint
block|;
comment|/// \brief In the containing bug report, this piece is the last piece from
comment|/// the main source file.
name|bool
name|LastInMainSourceFile
block|;
comment|/// A constant string that can be used to tag the PathDiagnosticPiece,
comment|/// typically with the identification of the creator.  The actual pointer
comment|/// value is meant to be an identifier; the string itself is useful for
comment|/// debugging.
name|StringRef
name|Tag
block|;
name|std
operator|::
name|vector
operator|<
name|SourceRange
operator|>
name|ranges
block|;
name|PathDiagnosticPiece
argument_list|()
operator|=
name|delete
block|;
name|PathDiagnosticPiece
argument_list|(
specifier|const
name|PathDiagnosticPiece
operator|&
name|P
argument_list|)
operator|=
name|delete
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|PathDiagnosticPiece
operator|&
name|P
operator|)
operator|=
name|delete
block|;
name|protected
operator|:
name|PathDiagnosticPiece
argument_list|(
argument|StringRef s
argument_list|,
argument|Kind k
argument_list|,
argument|DisplayHint hint = Below
argument_list|)
block|;
name|PathDiagnosticPiece
argument_list|(
argument|Kind k
argument_list|,
argument|DisplayHint hint = Below
argument_list|)
block|;
name|public
operator|:
operator|~
name|PathDiagnosticPiece
argument_list|()
name|override
block|;
name|StringRef
name|getString
argument_list|()
specifier|const
block|{
return|return
name|str
return|;
block|}
comment|/// Tag this PathDiagnosticPiece with the given C-string.
name|void
name|setTag
argument_list|(
argument|const char *tag
argument_list|)
block|{
name|Tag
operator|=
name|tag
block|; }
comment|/// Return the opaque tag (if any) on the PathDiagnosticPiece.
specifier|const
name|void
operator|*
name|getTag
argument_list|()
specifier|const
block|{
return|return
name|Tag
operator|.
name|data
argument_list|()
return|;
block|}
comment|/// Return the string representation of the tag.  This is useful
comment|/// for debugging.
name|StringRef
name|getTagStr
argument_list|()
specifier|const
block|{
return|return
name|Tag
return|;
block|}
comment|/// getDisplayHint - Return a hint indicating where the diagnostic should
comment|///  be displayed by the PathDiagnosticConsumer.
name|DisplayHint
name|getDisplayHint
argument_list|()
specifier|const
block|{
return|return
name|Hint
return|;
block|}
name|virtual
name|PathDiagnosticLocation
name|getLocation
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|virtual
name|void
name|flattenLocations
argument_list|()
operator|=
literal|0
block|;
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|void
name|addRange
argument_list|(
argument|SourceRange R
argument_list|)
block|{
if|if
condition|(
operator|!
name|R
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|ranges
operator|.
name|push_back
argument_list|(
name|R
argument_list|)
block|;   }
name|void
name|addRange
argument_list|(
argument|SourceLocation B
argument_list|,
argument|SourceLocation E
argument_list|)
block|{
if|if
condition|(
operator|!
name|B
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|E
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|ranges
operator|.
name|push_back
argument_list|(
name|SourceRange
argument_list|(
name|B
argument_list|,
name|E
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Return the SourceRanges associated with this PathDiagnosticPiece.
end_comment

begin_expr_stmt
name|ArrayRef
operator|<
name|SourceRange
operator|>
name|getRanges
argument_list|()
specifier|const
block|{
return|return
name|ranges
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|virtual
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setAsLastInMainSourceFile
parameter_list|()
block|{
name|LastInMainSourceFile
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isLastInMainSourceFile
argument_list|()
specifier|const
block|{
return|return
name|LastInMainSourceFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|void
name|dump
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|};
name|class
name|PathPieces
range|:
name|public
name|std
operator|::
name|list
operator|<
name|IntrusiveRefCntPtr
operator|<
name|PathDiagnosticPiece
operator|>
expr|>
block|{
name|void
name|flattenTo
argument_list|(
argument|PathPieces&Primary
argument_list|,
argument|PathPieces&Current
argument_list|,
argument|bool ShouldFlattenMacros
argument_list|)
specifier|const
block|;
name|public
operator|:
name|PathPieces
name|flatten
argument_list|(
argument|bool ShouldFlattenMacros
argument_list|)
specifier|const
block|{
name|PathPieces
name|Result
block|;
name|flattenTo
argument_list|(
name|Result
argument_list|,
name|Result
argument_list|,
name|ShouldFlattenMacros
argument_list|)
block|;
return|return
name|Result
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|PathDiagnosticSpotPiece
range|:
name|public
name|PathDiagnosticPiece
block|{
name|private
operator|:
name|PathDiagnosticLocation
name|Pos
block|;
name|public
operator|:
name|PathDiagnosticSpotPiece
argument_list|(
argument|const PathDiagnosticLocation&pos
argument_list|,
argument|StringRef s
argument_list|,
argument|PathDiagnosticPiece::Kind k
argument_list|,
argument|bool addPosRange = true
argument_list|)
operator|:
name|PathDiagnosticPiece
argument_list|(
name|s
argument_list|,
name|k
argument_list|)
block|,
name|Pos
argument_list|(
argument|pos
argument_list|)
block|{
name|assert
argument_list|(
name|Pos
operator|.
name|isValid
argument_list|()
operator|&&
name|Pos
operator|.
name|asLocation
argument_list|()
operator|.
name|isValid
argument_list|()
operator|&&
literal|"PathDiagnosticSpotPiece's must have a valid location."
argument_list|)
block|;
if|if
condition|(
name|addPosRange
operator|&&
name|Pos
operator|.
name|hasRange
argument_list|()
condition|)
name|addRange
argument_list|(
name|Pos
operator|.
name|asRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|PathDiagnosticLocation
name|getLocation
argument_list|()
specifier|const
name|override
block|{
return|return
name|Pos
return|;
block|}
name|void
name|flattenLocations
argument_list|()
name|override
block|{
name|Pos
operator|.
name|flatten
argument_list|()
block|; }
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const PathDiagnosticPiece *P
argument_list|)
block|{
return|return
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|Event
operator|||
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|Macro
return|;
block|}
expr|}
block|;
comment|/// \brief Interface for classes constructing Stack hints.
comment|///
comment|/// If a PathDiagnosticEvent occurs in a different frame than the final
comment|/// diagnostic the hints can be used to summarize the effect of the call.
name|class
name|StackHintGenerator
block|{
name|public
operator|:
name|virtual
operator|~
name|StackHintGenerator
argument_list|()
operator|=
literal|0
block|;
comment|/// \brief Construct the Diagnostic message for the given ExplodedNode.
name|virtual
name|std
operator|::
name|string
name|getMessage
argument_list|(
specifier|const
name|ExplodedNode
operator|*
name|N
argument_list|)
operator|=
literal|0
block|; }
block|;
comment|/// \brief Constructs a Stack hint for the given symbol.
comment|///
comment|/// The class knows how to construct the stack hint message based on
comment|/// traversing the CallExpr associated with the call and checking if the given
comment|/// symbol is returned or is one of the arguments.
comment|/// The hint can be customized by redefining 'getMessageForX()' methods.
name|class
name|StackHintGeneratorForSymbol
operator|:
name|public
name|StackHintGenerator
block|{
name|private
operator|:
name|SymbolRef
name|Sym
block|;
name|std
operator|::
name|string
name|Msg
block|;
name|public
operator|:
name|StackHintGeneratorForSymbol
argument_list|(
argument|SymbolRef S
argument_list|,
argument|StringRef M
argument_list|)
operator|:
name|Sym
argument_list|(
name|S
argument_list|)
block|,
name|Msg
argument_list|(
argument|M
argument_list|)
block|{}
operator|~
name|StackHintGeneratorForSymbol
argument_list|()
name|override
block|{}
comment|/// \brief Search the call expression for the symbol Sym and dispatch the
comment|/// 'getMessageForX()' methods to construct a specific message.
name|std
operator|::
name|string
name|getMessage
argument_list|(
argument|const ExplodedNode *N
argument_list|)
name|override
block|;
comment|/// Produces the message of the following form:
comment|///   'Msg via Nth parameter'
name|virtual
name|std
operator|::
name|string
name|getMessageForArg
argument_list|(
argument|const Expr *ArgE
argument_list|,
argument|unsigned ArgIndex
argument_list|)
block|;
name|virtual
name|std
operator|::
name|string
name|getMessageForReturn
argument_list|(
argument|const CallExpr *CallExpr
argument_list|)
block|{
return|return
name|Msg
return|;
block|}
name|virtual
name|std
operator|::
name|string
name|getMessageForSymbolNotFound
argument_list|()
block|{
return|return
name|Msg
return|;
block|}
expr|}
block|;
name|class
name|PathDiagnosticEventPiece
operator|:
name|public
name|PathDiagnosticSpotPiece
block|{
name|Optional
operator|<
name|bool
operator|>
name|IsPrunable
block|;
comment|/// If the event occurs in a different frame than the final diagnostic,
comment|/// supply a message that will be used to construct an extra hint on the
comment|/// returns from all the calls on the stack from this event to the final
comment|/// diagnostic.
name|std
operator|::
name|unique_ptr
operator|<
name|StackHintGenerator
operator|>
name|CallStackHint
block|;
name|public
operator|:
name|PathDiagnosticEventPiece
argument_list|(
argument|const PathDiagnosticLocation&pos
argument_list|,
argument|StringRef s
argument_list|,
argument|bool addPosRange = true
argument_list|,
argument|StackHintGenerator *stackHint = nullptr
argument_list|)
operator|:
name|PathDiagnosticSpotPiece
argument_list|(
name|pos
argument_list|,
name|s
argument_list|,
name|Event
argument_list|,
name|addPosRange
argument_list|)
block|,
name|CallStackHint
argument_list|(
argument|stackHint
argument_list|)
block|{}
operator|~
name|PathDiagnosticEventPiece
argument_list|()
name|override
block|;
comment|/// Mark the diagnostic piece as being potentially prunable.  This
comment|/// flag may have been previously set, at which point it will not
comment|/// be reset unless one specifies to do so.
name|void
name|setPrunable
argument_list|(
argument|bool isPrunable
argument_list|,
argument|bool override = false
argument_list|)
block|{
if|if
condition|(
name|IsPrunable
operator|.
name|hasValue
argument_list|()
operator|&&
operator|!
name|override
condition|)
return|return;
name|IsPrunable
operator|=
name|isPrunable
block|;   }
comment|/// Return true if the diagnostic piece is prunable.
name|bool
name|isPrunable
argument_list|()
specifier|const
block|{
return|return
name|IsPrunable
operator|.
name|hasValue
argument_list|()
operator|?
name|IsPrunable
operator|.
name|getValue
argument_list|()
operator|:
name|false
return|;
block|}
name|bool
name|hasCallStackHint
argument_list|()
block|{
return|return
operator|(
name|bool
operator|)
name|CallStackHint
return|;
block|}
comment|/// Produce the hint for the given node. The node contains
comment|/// information about the call for which the diagnostic can be generated.
name|std
operator|::
name|string
name|getCallStackMessage
argument_list|(
argument|const ExplodedNode *N
argument_list|)
block|{
if|if
condition|(
name|CallStackHint
condition|)
return|return
name|CallStackHint
operator|->
name|getMessage
argument_list|(
name|N
argument_list|)
return|;
return|return
literal|""
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
name|override
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const PathDiagnosticPiece *P
argument_list|)
block|{
return|return
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|Event
return|;
block|}
expr|}
block|;
name|class
name|PathDiagnosticCallPiece
operator|:
name|public
name|PathDiagnosticPiece
block|{
name|PathDiagnosticCallPiece
argument_list|(
specifier|const
name|Decl
operator|*
name|callerD
argument_list|,
specifier|const
name|PathDiagnosticLocation
operator|&
name|callReturnPos
argument_list|)
operator|:
name|PathDiagnosticPiece
argument_list|(
name|Call
argument_list|)
block|,
name|Caller
argument_list|(
name|callerD
argument_list|)
block|,
name|Callee
argument_list|(
name|nullptr
argument_list|)
block|,
name|NoExit
argument_list|(
name|false
argument_list|)
block|,
name|callReturn
argument_list|(
argument|callReturnPos
argument_list|)
block|{}
name|PathDiagnosticCallPiece
argument_list|(
name|PathPieces
operator|&
name|oldPath
argument_list|,
specifier|const
name|Decl
operator|*
name|caller
argument_list|)
operator|:
name|PathDiagnosticPiece
argument_list|(
name|Call
argument_list|)
block|,
name|Caller
argument_list|(
name|caller
argument_list|)
block|,
name|Callee
argument_list|(
name|nullptr
argument_list|)
block|,
name|NoExit
argument_list|(
name|true
argument_list|)
block|,
name|path
argument_list|(
argument|oldPath
argument_list|)
block|{}
specifier|const
name|Decl
operator|*
name|Caller
block|;
specifier|const
name|Decl
operator|*
name|Callee
block|;
comment|// Flag signifying that this diagnostic has only call enter and no matching
comment|// call exit.
name|bool
name|NoExit
block|;
comment|// The custom string, which should appear after the call Return Diagnostic.
comment|// TODO: Should we allow multiple diagnostics?
name|std
operator|::
name|string
name|CallStackMessage
block|;
name|public
operator|:
name|PathDiagnosticLocation
name|callEnter
block|;
name|PathDiagnosticLocation
name|callEnterWithin
block|;
name|PathDiagnosticLocation
name|callReturn
block|;
name|PathPieces
name|path
block|;
operator|~
name|PathDiagnosticCallPiece
argument_list|()
name|override
block|;
specifier|const
name|Decl
operator|*
name|getCaller
argument_list|()
specifier|const
block|{
return|return
name|Caller
return|;
block|}
specifier|const
name|Decl
operator|*
name|getCallee
argument_list|()
specifier|const
block|{
return|return
name|Callee
return|;
block|}
name|void
name|setCallee
argument_list|(
specifier|const
name|CallEnter
operator|&
name|CE
argument_list|,
specifier|const
name|SourceManager
operator|&
name|SM
argument_list|)
block|;
name|bool
name|hasCallStackMessage
argument_list|()
block|{
return|return
operator|!
name|CallStackMessage
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|setCallStackMessage
argument_list|(
argument|StringRef st
argument_list|)
block|{
name|CallStackMessage
operator|=
name|st
block|;   }
name|PathDiagnosticLocation
name|getLocation
argument_list|()
specifier|const
name|override
block|{
return|return
name|callEnter
return|;
block|}
name|IntrusiveRefCntPtr
operator|<
name|PathDiagnosticEventPiece
operator|>
name|getCallEnterEvent
argument_list|()
specifier|const
block|;
name|IntrusiveRefCntPtr
operator|<
name|PathDiagnosticEventPiece
operator|>
name|getCallEnterWithinCallerEvent
argument_list|()
specifier|const
block|;
name|IntrusiveRefCntPtr
operator|<
name|PathDiagnosticEventPiece
operator|>
name|getCallExitEvent
argument_list|()
specifier|const
block|;
name|void
name|flattenLocations
argument_list|()
name|override
block|{
name|callEnter
operator|.
name|flatten
argument_list|()
block|;
name|callReturn
operator|.
name|flatten
argument_list|()
block|;
for|for
control|(
name|PathPieces
operator|::
name|iterator
name|I
operator|=
name|path
operator|.
name|begin
argument_list|()
init|,
name|E
operator|=
name|path
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|flattenLocations
argument_list|()
expr_stmt|;
block|}
specifier|static
name|PathDiagnosticCallPiece
operator|*
name|construct
argument_list|(
specifier|const
name|ExplodedNode
operator|*
name|N
argument_list|,
specifier|const
name|CallExitEnd
operator|&
name|CE
argument_list|,
specifier|const
name|SourceManager
operator|&
name|SM
argument_list|)
block|;
specifier|static
name|PathDiagnosticCallPiece
operator|*
name|construct
argument_list|(
name|PathPieces
operator|&
name|pieces
argument_list|,
specifier|const
name|Decl
operator|*
name|caller
argument_list|)
block|;
name|void
name|dump
argument_list|()
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const PathDiagnosticPiece *P
argument_list|)
block|{
return|return
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|Call
return|;
block|}
expr|}
block|;
name|class
name|PathDiagnosticControlFlowPiece
operator|:
name|public
name|PathDiagnosticPiece
block|{
name|std
operator|::
name|vector
operator|<
name|PathDiagnosticLocationPair
operator|>
name|LPairs
block|;
name|public
operator|:
name|PathDiagnosticControlFlowPiece
argument_list|(
argument|const PathDiagnosticLocation&startPos
argument_list|,
argument|const PathDiagnosticLocation&endPos
argument_list|,
argument|StringRef s
argument_list|)
operator|:
name|PathDiagnosticPiece
argument_list|(
argument|s
argument_list|,
argument|ControlFlow
argument_list|)
block|{
name|LPairs
operator|.
name|push_back
argument_list|(
name|PathDiagnosticLocationPair
argument_list|(
name|startPos
argument_list|,
name|endPos
argument_list|)
argument_list|)
block|;     }
name|PathDiagnosticControlFlowPiece
argument_list|(
specifier|const
name|PathDiagnosticLocation
operator|&
name|startPos
argument_list|,
specifier|const
name|PathDiagnosticLocation
operator|&
name|endPos
argument_list|)
operator|:
name|PathDiagnosticPiece
argument_list|(
argument|ControlFlow
argument_list|)
block|{
name|LPairs
operator|.
name|push_back
argument_list|(
name|PathDiagnosticLocationPair
argument_list|(
name|startPos
argument_list|,
name|endPos
argument_list|)
argument_list|)
block|;     }
operator|~
name|PathDiagnosticControlFlowPiece
argument_list|()
name|override
block|;
name|PathDiagnosticLocation
name|getStartLocation
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|LPairs
operator|.
name|empty
argument_list|()
operator|&&
literal|"PathDiagnosticControlFlowPiece needs at least one location."
argument_list|)
block|;
return|return
name|LPairs
index|[
literal|0
index|]
operator|.
name|getStart
argument_list|()
return|;
block|}
name|PathDiagnosticLocation
name|getEndLocation
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|LPairs
operator|.
name|empty
argument_list|()
operator|&&
literal|"PathDiagnosticControlFlowPiece needs at least one location."
argument_list|)
block|;
return|return
name|LPairs
index|[
literal|0
index|]
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|void
name|setStartLocation
argument_list|(
argument|const PathDiagnosticLocation&L
argument_list|)
block|{
name|LPairs
index|[
literal|0
index|]
operator|.
name|setStart
argument_list|(
name|L
argument_list|)
block|;   }
name|void
name|setEndLocation
argument_list|(
argument|const PathDiagnosticLocation&L
argument_list|)
block|{
name|LPairs
index|[
literal|0
index|]
operator|.
name|setEnd
argument_list|(
name|L
argument_list|)
block|;   }
name|void
name|push_back
argument_list|(
argument|const PathDiagnosticLocationPair&X
argument_list|)
block|{
name|LPairs
operator|.
name|push_back
argument_list|(
name|X
argument_list|)
block|; }
name|PathDiagnosticLocation
name|getLocation
argument_list|()
specifier|const
name|override
block|{
return|return
name|getStartLocation
argument_list|()
return|;
block|}
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|PathDiagnosticLocationPair
operator|>
operator|::
name|iterator
name|iterator
expr_stmt|;
name|iterator
name|begin
argument_list|()
block|{
return|return
name|LPairs
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
argument_list|()
block|{
return|return
name|LPairs
operator|.
name|end
argument_list|()
return|;
block|}
name|void
name|flattenLocations
argument_list|()
name|override
block|{
for|for
control|(
name|iterator
name|I
init|=
name|begin
argument_list|()
init|,
name|E
init|=
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|I
operator|->
name|flatten
argument_list|()
expr_stmt|;
block|}
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|PathDiagnosticLocationPair
operator|>
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|LPairs
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|LPairs
operator|.
name|end
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const PathDiagnosticPiece *P
argument_list|)
block|{
return|return
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|ControlFlow
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|PathDiagnosticMacroPiece
range|:
name|public
name|PathDiagnosticSpotPiece
block|{
name|public
operator|:
name|PathDiagnosticMacroPiece
argument_list|(
specifier|const
name|PathDiagnosticLocation
operator|&
name|pos
argument_list|)
operator|:
name|PathDiagnosticSpotPiece
argument_list|(
argument|pos
argument_list|,
literal|""
argument_list|,
argument|Macro
argument_list|)
block|{}
operator|~
name|PathDiagnosticMacroPiece
argument_list|()
name|override
block|;
name|PathPieces
name|subPieces
block|;
name|bool
name|containsEvent
argument_list|()
specifier|const
block|;
name|void
name|flattenLocations
argument_list|()
name|override
block|{
name|PathDiagnosticSpotPiece
operator|::
name|flattenLocations
argument_list|()
block|;
for|for
control|(
name|PathPieces
operator|::
name|iterator
name|I
operator|=
name|subPieces
operator|.
name|begin
argument_list|()
init|,
name|E
operator|=
name|subPieces
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|flattenLocations
argument_list|()
expr_stmt|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const PathDiagnosticPiece *P
argument_list|)
block|{
return|return
name|P
operator|->
name|getKind
argument_list|()
operator|==
name|Macro
return|;
block|}
name|void
name|dump
argument_list|()
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive
end_comment

begin_comment
comment|///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,
end_comment

begin_comment
comment|///  each which represent the pieces of the path.
end_comment

begin_decl_stmt
name|class
name|PathDiagnostic
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|std
operator|::
name|string
name|CheckName
block|;
specifier|const
name|Decl
operator|*
name|DeclWithIssue
block|;
name|std
operator|::
name|string
name|BugType
block|;
name|std
operator|::
name|string
name|VerboseDesc
block|;
name|std
operator|::
name|string
name|ShortDesc
block|;
name|std
operator|::
name|string
name|Category
block|;
name|std
operator|::
name|deque
operator|<
name|std
operator|::
name|string
operator|>
name|OtherDesc
block|;
comment|/// \brief Loc The location of the path diagnostic report.
name|PathDiagnosticLocation
name|Loc
block|;
name|PathPieces
name|pathImpl
block|;
name|SmallVector
operator|<
name|PathPieces
operator|*
block|,
literal|3
operator|>
name|pathStack
block|;
comment|/// \brief Important bug uniqueing location.
comment|/// The location info is useful to differentiate between bugs.
name|PathDiagnosticLocation
name|UniqueingLoc
block|;
specifier|const
name|Decl
operator|*
name|UniqueingDecl
block|;
name|PathDiagnostic
argument_list|()
operator|=
name|delete
block|;
name|public
operator|:
name|PathDiagnostic
argument_list|(
argument|StringRef CheckName
argument_list|,
argument|const Decl *DeclWithIssue
argument_list|,
argument|StringRef bugtype
argument_list|,
argument|StringRef verboseDesc
argument_list|,
argument|StringRef shortDesc
argument_list|,
argument|StringRef category
argument_list|,
argument|PathDiagnosticLocation LocationToUnique
argument_list|,
argument|const Decl *DeclToUnique
argument_list|)
block|;
operator|~
name|PathDiagnostic
argument_list|()
block|;
specifier|const
name|PathPieces
operator|&
name|path
block|;
comment|/// Return the path currently used by builders for constructing the
comment|/// PathDiagnostic.
name|PathPieces
operator|&
name|getActivePath
argument_list|()
block|{
if|if
condition|(
name|pathStack
operator|.
name|empty
argument_list|()
condition|)
return|return
name|pathImpl
return|;
return|return
operator|*
name|pathStack
operator|.
name|back
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Return a mutable version of 'path'.
end_comment

begin_function
name|PathPieces
modifier|&
name|getMutablePieces
parameter_list|()
block|{
return|return
name|pathImpl
return|;
block|}
end_function

begin_comment
comment|/// Return the unrolled size of the path.
end_comment

begin_function_decl
name|unsigned
name|full_size
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|pushActivePath
parameter_list|(
name|PathPieces
modifier|*
name|p
parameter_list|)
block|{
name|pathStack
operator|.
name|push_back
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|popActivePath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pathStack
operator|.
name|empty
argument_list|()
condition|)
name|pathStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isWithinCall
argument_list|()
specifier|const
block|{
return|return
operator|!
name|pathStack
operator|.
name|empty
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setEndOfPath
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|PathDiagnosticPiece
operator|>
name|EndPiece
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Loc
operator|.
name|isValid
argument_list|()
operator|&&
literal|"End location already set!"
argument_list|)
expr_stmt|;
name|Loc
operator|=
name|EndPiece
operator|->
name|getLocation
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|Loc
operator|.
name|isValid
argument_list|()
operator|&&
literal|"Invalid location for end-of-path piece"
argument_list|)
expr_stmt|;
name|getActivePath
argument_list|()
operator|.
name|push_back
argument_list|(
name|EndPiece
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|appendToDesc
parameter_list|(
name|StringRef
name|S
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ShortDesc
operator|.
name|empty
argument_list|()
condition|)
name|ShortDesc
operator|+=
name|S
expr_stmt|;
name|VerboseDesc
operator|+=
name|S
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resetPath
parameter_list|()
block|{
name|pathStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pathImpl
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Loc
operator|=
name|PathDiagnosticLocation
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief If the last piece of the report point to the header file, resets
end_comment

begin_comment
comment|/// the location of the report to be the last location in the main source
end_comment

begin_comment
comment|/// file.
end_comment

begin_function_decl
name|void
name|resetDiagnosticLocationToMainFile
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|StringRef
name|getVerboseDescription
argument_list|()
specifier|const
block|{
return|return
name|VerboseDesc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getShortDescription
argument_list|()
specifier|const
block|{
return|return
name|ShortDesc
operator|.
name|empty
argument_list|()
operator|?
name|VerboseDesc
operator|:
name|ShortDesc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getCheckName
argument_list|()
specifier|const
block|{
return|return
name|CheckName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getBugType
argument_list|()
specifier|const
block|{
return|return
name|BugType
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|getCategory
argument_list|()
specifier|const
block|{
return|return
name|Category
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the semantic context where an issue occurred.  If the
end_comment

begin_comment
comment|/// issue occurs along a path, this represents the "central" area
end_comment

begin_comment
comment|/// where the bug manifests.
end_comment

begin_expr_stmt
specifier|const
name|Decl
operator|*
name|getDeclWithIssue
argument_list|()
specifier|const
block|{
return|return
name|DeclWithIssue
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|deque
operator|<
name|std
operator|::
name|string
operator|>
operator|::
name|const_iterator
name|meta_iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|meta_iterator
name|meta_begin
argument_list|()
specifier|const
block|{
return|return
name|OtherDesc
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|meta_iterator
name|meta_end
argument_list|()
specifier|const
block|{
return|return
name|OtherDesc
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|addMeta
parameter_list|(
name|StringRef
name|s
parameter_list|)
block|{
name|OtherDesc
operator|.
name|push_back
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|PathDiagnosticLocation
name|getLocation
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Loc
operator|.
name|isValid
argument_list|()
operator|&&
literal|"No report location set yet!"
argument_list|)
block|;
return|return
name|Loc
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Get the location on which the report should be uniqued.
end_comment

begin_expr_stmt
name|PathDiagnosticLocation
name|getUniqueingLoc
argument_list|()
specifier|const
block|{
return|return
name|UniqueingLoc
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Get the declaration containing the uniqueing location.
end_comment

begin_expr_stmt
specifier|const
name|Decl
operator|*
name|getUniqueingDecl
argument_list|()
specifier|const
block|{
return|return
name|UniqueingDecl
return|;
block|}
end_expr_stmt

begin_function
name|void
name|flattenLocations
parameter_list|()
block|{
name|Loc
operator|.
name|flatten
argument_list|()
expr_stmt|;
for|for
control|(
name|PathPieces
operator|::
name|iterator
name|I
operator|=
name|pathImpl
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|pathImpl
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
operator|(
operator|*
name|I
operator|)
operator|->
name|flattenLocations
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Profiles the diagnostic, independent of the path it references.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This can be used to merge diagnostics that refer to the same issue
end_comment

begin_comment
comment|/// along different paths.
end_comment

begin_decl_stmt
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Profiles the diagnostic, including its path.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Two diagnostics with the same issue along different paths will generate
end_comment

begin_comment
comment|/// different profiles.
end_comment

begin_decl_stmt
name|void
name|FullProfile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
unit|};    }
comment|// end GR namespace
end_comment

begin_comment
unit|}
comment|//end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

