begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//== MemRegion.h - Abstract memory regions for static analysis --*- C++ -*--==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines MemRegion and its subclasses.  MemRegion defines a
end_comment

begin_comment
comment|//  partially-typed abstraction of memory useful for path-sensitive dataflow
end_comment

begin_comment
comment|//  analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/CharUnits.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/AnalysisContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/SVals.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|LocationContext
decl_stmt|;
name|class
name|StackFrameContext
decl_stmt|;
name|namespace
name|ento
block|{
name|class
name|CodeTextRegion
decl_stmt|;
name|class
name|MemRegionManager
decl_stmt|;
name|class
name|MemSpaceRegion
decl_stmt|;
name|class
name|SValBuilder
decl_stmt|;
name|class
name|SymbolicRegion
decl_stmt|;
name|class
name|VarRegion
decl_stmt|;
comment|/// Represent a region's offset within the top level base region.
name|class
name|RegionOffset
block|{
comment|/// The base region.
specifier|const
name|MemRegion
modifier|*
name|R
decl_stmt|;
comment|/// The bit offset within the base region. Can be negative.
name|int64_t
name|Offset
decl_stmt|;
name|public
label|:
comment|// We're using a const instead of an enumeration due to the size required;
comment|// Visual Studio will only create enumerations of size int, not long long.
specifier|static
specifier|const
name|int64_t
name|Symbolic
init|=
name|INT64_MAX
decl_stmt|;
name|RegionOffset
argument_list|()
operator|:
name|R
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|RegionOffset
argument_list|(
argument|const MemRegion *r
argument_list|,
argument|int64_t off
argument_list|)
operator|:
name|R
argument_list|(
name|r
argument_list|)
operator|,
name|Offset
argument_list|(
argument|off
argument_list|)
block|{}
specifier|const
name|MemRegion
operator|*
name|getRegion
argument_list|()
specifier|const
block|{
return|return
name|R
return|;
block|}
name|bool
name|hasSymbolicOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
operator|==
name|Symbolic
return|;
block|}
name|int64_t
name|getOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|hasSymbolicOffset
argument_list|()
argument_list|)
block|;
return|return
name|Offset
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|R
return|;
block|}
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// Base region classes.
comment|//===----------------------------------------------------------------------===//
comment|/// MemRegion - The root abstract class for all memory regions.
name|class
name|MemRegion
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
define|#
directive|define
name|REGION
parameter_list|(
name|Id
parameter_list|,
name|Parent
parameter_list|)
value|Id ## Kind,
define|#
directive|define
name|REGION_RANGE
parameter_list|(
name|Id
parameter_list|,
name|First
parameter_list|,
name|Last
parameter_list|)
value|BEGIN_##Id = First, END_##Id = Last,
include|#
directive|include
file|"clang/StaticAnalyzer/Core/PathSensitive/Regions.def"
block|}
block|;
name|private
operator|:
specifier|const
name|Kind
name|kind
block|;
name|protected
operator|:
name|MemRegion
argument_list|(
argument|Kind k
argument_list|)
operator|:
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
name|virtual
operator|~
name|MemRegion
argument_list|()
block|;
name|public
operator|:
name|ASTContext
operator|&
name|getContext
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
operator|=
literal|0
block|;
name|virtual
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
operator|=
literal|0
block|;
specifier|const
name|MemSpaceRegion
operator|*
name|getMemorySpace
argument_list|()
specifier|const
block|;
specifier|const
name|MemRegion
operator|*
name|getBaseRegion
argument_list|()
specifier|const
block|;
comment|/// Check if the region is a subregion of the given region.
name|virtual
name|bool
name|isSubRegionOf
argument_list|(
argument|const MemRegion *R
argument_list|)
specifier|const
block|;
specifier|const
name|MemRegion
operator|*
name|StripCasts
argument_list|(
argument|bool StripBaseCasts = true
argument_list|)
specifier|const
block|;
comment|/// \brief If this is a symbolic region, returns the region. Otherwise,
comment|/// goes up the base chain looking for the first symbolic base region.
specifier|const
name|SymbolicRegion
operator|*
name|getSymbolicBase
argument_list|()
specifier|const
block|;
name|bool
name|hasGlobalsOrParametersStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasStackStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasStackNonParametersStorage
argument_list|()
specifier|const
block|;
name|bool
name|hasStackParametersStorage
argument_list|()
specifier|const
block|;
comment|/// Compute the offset within the top level memory object.
name|RegionOffset
name|getAsOffset
argument_list|()
specifier|const
block|;
comment|/// \brief Get a string representation of a region for debug use.
name|std
operator|::
name|string
name|getString
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|;
comment|/// \brief Returns true if this region can be printed in a user-friendly way.
name|virtual
name|bool
name|canPrintPretty
argument_list|()
specifier|const
block|;
comment|/// \brief Print the region for use in diagnostics.
name|virtual
name|void
name|printPretty
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
comment|/// \brief Returns true if this region's textual representation can be used
comment|/// as part of a larger expression.
name|virtual
name|bool
name|canPrintPrettyAsExpr
argument_list|()
specifier|const
block|;
comment|/// \brief Print the region as expression.
comment|///
comment|/// When this region represents a subexpression, the method is for printing
comment|/// an expression containing it.
name|virtual
name|void
name|printPrettyAsExpr
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|getAs
argument_list|()
specifier|const
block|;
name|virtual
name|bool
name|isBoundable
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// Get descriptive name for memory region. The name is obtained from
comment|/// the variable/field declaration retrieved from the memory region.
comment|/// Regions that point to an element of an array are returned as: "arr[0]".
comment|/// Regions that point to a struct are returned as: "st.var".
comment|//
comment|/// \param UseQuotes Set if the name should be quoted.
comment|///
comment|/// \returns variable name for memory region
name|std
operator|::
name|string
name|getDescriptiveName
argument_list|(
argument|bool UseQuotes = true
argument_list|)
specifier|const
block|;
comment|/// Retrieve source range from memory region. The range retrieval
comment|/// is based on the decl obtained from the memory region.
comment|/// For a VarRegion the range of the base region is returned.
comment|/// For a FieldRegion the range of the field is returned.
comment|/// If no declaration is found, an empty source range is returned.
comment|/// The client is responsible for checking if the returned range is valid.
comment|///
comment|/// \returns source range for declaration retrieved from memory region
name|clang
operator|::
name|SourceRange
name|sourceRange
argument_list|()
specifier|const
block|; }
decl_stmt|;
comment|/// MemSpaceRegion - A memory region that represents a "memory space";
comment|///  for example, the set of global variables, the stack frame, etc.
name|class
name|MemSpaceRegion
range|:
name|public
name|MemRegion
block|{
name|protected
operator|:
name|MemRegionManager
operator|*
name|Mgr
block|;
name|MemSpaceRegion
argument_list|(
argument|MemRegionManager *mgr
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|MemRegion
argument_list|(
name|k
argument_list|)
block|,
name|Mgr
argument_list|(
argument|mgr
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|mgr
argument_list|)
block|;   }
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
name|override
block|{
return|return
name|Mgr
return|;
block|}
name|public
operator|:
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
name|Kind
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_MEMSPACES
operator|&&
name|k
operator|<=
name|END_MEMSPACES
return|;
block|}
expr|}
block|;
comment|/// CodeSpaceRegion - The memory space that holds the executable code of
comment|/// functions and blocks.
name|class
name|CodeSpaceRegion
operator|:
name|public
name|MemSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|CodeSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|MemSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|CodeSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CodeSpaceRegionKind
return|;
block|}
expr|}
block|;
name|class
name|GlobalsSpaceRegion
operator|:
name|public
name|MemSpaceRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|protected
operator|:
name|GlobalsSpaceRegion
argument_list|(
argument|MemRegionManager *mgr
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|MemSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|k
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
name|Kind
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_GLOBAL_MEMSPACES
operator|&&
name|k
operator|<=
name|END_GLOBAL_MEMSPACES
return|;
block|}
expr|}
block|;
comment|/// \brief The region of the static variables within the current CodeTextRegion
comment|/// scope.
comment|///
comment|/// Currently, only the static locals are placed there, so we know that these
comment|/// variables do not get invalidated by calls to other functions.
name|class
name|StaticGlobalSpaceRegion
operator|:
name|public
name|GlobalsSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|CodeTextRegion
operator|*
name|CR
block|;
name|StaticGlobalSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|,
specifier|const
name|CodeTextRegion
operator|*
name|cr
argument_list|)
operator|:
name|GlobalsSpaceRegion
argument_list|(
name|mgr
argument_list|,
name|StaticGlobalSpaceRegionKind
argument_list|)
block|,
name|CR
argument_list|(
argument|cr
argument_list|)
block|{
name|assert
argument_list|(
name|cr
argument_list|)
block|;   }
name|public
operator|:
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|const
name|CodeTextRegion
operator|*
name|getCodeRegion
argument_list|()
specifier|const
block|{
return|return
name|CR
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StaticGlobalSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// \brief The region for all the non-static global variables.
comment|///
comment|/// This class is further split into subclasses for efficient implementation of
comment|/// invalidating a set of related global values as is done in
comment|/// RegionStoreManager::invalidateRegions (instead of finding all the dependent
comment|/// globals, we invalidate the whole parent region).
name|class
name|NonStaticGlobalSpaceRegion
operator|:
name|public
name|GlobalsSpaceRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
name|override
block|;
name|protected
operator|:
name|NonStaticGlobalSpaceRegion
argument_list|(
argument|MemRegionManager *mgr
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|GlobalsSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|k
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
name|Kind
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_NON_STATIC_GLOBAL_MEMSPACES
operator|&&
name|k
operator|<=
name|END_NON_STATIC_GLOBAL_MEMSPACES
return|;
block|}
expr|}
block|;
comment|/// \brief The region containing globals which are defined in system/external
comment|/// headers and are considered modifiable by system calls (ex: errno).
name|class
name|GlobalSystemSpaceRegion
operator|:
name|public
name|NonStaticGlobalSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|GlobalSystemSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|NonStaticGlobalSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|GlobalSystemSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|GlobalSystemSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// \brief The region containing globals which are considered not to be modified
comment|/// or point to data which could be modified as a result of a function call
comment|/// (system or internal). Ex: Const global scalars would be modeled as part of
comment|/// this region. This region also includes most system globals since they have
comment|/// low chance of being modified.
name|class
name|GlobalImmutableSpaceRegion
operator|:
name|public
name|NonStaticGlobalSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|GlobalImmutableSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|NonStaticGlobalSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|GlobalImmutableSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|GlobalImmutableSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// \brief The region containing globals which can be modified by calls to
comment|/// "internally" defined functions - (for now just) functions other then system
comment|/// calls.
name|class
name|GlobalInternalSpaceRegion
operator|:
name|public
name|NonStaticGlobalSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|GlobalInternalSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|NonStaticGlobalSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|GlobalInternalSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|GlobalInternalSpaceRegionKind
return|;
block|}
expr|}
block|;
name|class
name|HeapSpaceRegion
operator|:
name|public
name|MemSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|HeapSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|MemSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|HeapSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|HeapSpaceRegionKind
return|;
block|}
expr|}
block|;
name|class
name|UnknownSpaceRegion
operator|:
name|public
name|MemSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|UnknownSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|)
operator|:
name|MemSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|UnknownSpaceRegionKind
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|UnknownSpaceRegionKind
return|;
block|}
expr|}
block|;
name|class
name|StackSpaceRegion
operator|:
name|public
name|MemSpaceRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
specifier|const
name|StackFrameContext
operator|*
name|SFC
block|;
name|protected
operator|:
name|StackSpaceRegion
argument_list|(
argument|MemRegionManager *mgr
argument_list|,
argument|Kind k
argument_list|,
argument|const StackFrameContext *sfc
argument_list|)
operator|:
name|MemSpaceRegion
argument_list|(
name|mgr
argument_list|,
name|k
argument_list|)
block|,
name|SFC
argument_list|(
argument|sfc
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|sfc
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|()
specifier|const
block|{
return|return
name|SFC
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
name|Kind
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_STACK_MEMSPACES
operator|&&
name|k
operator|<=
name|END_STACK_MEMSPACES
return|;
block|}
expr|}
block|;
name|class
name|StackLocalsSpaceRegion
operator|:
name|public
name|StackSpaceRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|StackLocalsSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|,
specifier|const
name|StackFrameContext
operator|*
name|sfc
argument_list|)
operator|:
name|StackSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|StackLocalsSpaceRegionKind
argument_list|,
argument|sfc
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StackLocalsSpaceRegionKind
return|;
block|}
expr|}
block|;
name|class
name|StackArgumentsSpaceRegion
operator|:
name|public
name|StackSpaceRegion
block|{
name|private
operator|:
name|friend
name|class
name|MemRegionManager
block|;
name|StackArgumentsSpaceRegion
argument_list|(
name|MemRegionManager
operator|*
name|mgr
argument_list|,
specifier|const
name|StackFrameContext
operator|*
name|sfc
argument_list|)
operator|:
name|StackSpaceRegion
argument_list|(
argument|mgr
argument_list|,
argument|StackArgumentsSpaceRegionKind
argument_list|,
argument|sfc
argument_list|)
block|{}
name|public
operator|:
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StackArgumentsSpaceRegionKind
return|;
block|}
expr|}
block|;
comment|/// SubRegion - A region that subsets another larger region.  Most regions
comment|///  are subclasses of SubRegion.
name|class
name|SubRegion
operator|:
name|public
name|MemRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;
name|protected
operator|:
specifier|const
name|MemRegion
operator|*
name|superRegion
block|;
name|SubRegion
argument_list|(
argument|const MemRegion *sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|MemRegion
argument_list|(
name|k
argument_list|)
block|,
name|superRegion
argument_list|(
argument|sReg
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|sReg
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|MemRegion
operator|*
name|getSuperRegion
argument_list|()
specifier|const
block|{
return|return
name|superRegion
return|;
block|}
comment|/// getExtent - Returns the size of the region in bytes.
name|virtual
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
block|{
return|return
name|UnknownVal
argument_list|()
return|;
block|}
name|MemRegionManager
operator|*
name|getMemRegionManager
argument_list|()
specifier|const
name|override
block|;
name|bool
name|isSubRegionOf
argument_list|(
argument|const MemRegion* R
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|>
name|END_MEMSPACES
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|// MemRegion subclasses.
comment|//===----------------------------------------------------------------------===//
comment|/// AllocaRegion - A region that represents an untyped blob of bytes created
comment|///  by a call to 'alloca'.
name|class
name|AllocaRegion
operator|:
name|public
name|SubRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|unsigned
name|Cnt
block|;
comment|// Block counter.  Used to distinguish different pieces of
comment|// memory allocated by alloca at the same call site.
specifier|const
name|Expr
operator|*
name|Ex
block|;
name|AllocaRegion
argument_list|(
argument|const Expr *ex
argument_list|,
argument|unsigned cnt
argument_list|,
argument|const MemSpaceRegion *superRegion
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|superRegion
argument_list|,
name|AllocaRegionKind
argument_list|)
block|,
name|Cnt
argument_list|(
name|cnt
argument_list|)
block|,
name|Ex
argument_list|(
argument|ex
argument_list|)
block|{
name|assert
argument_list|(
name|Ex
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Expr *Ex
argument_list|,
argument|unsigned Cnt
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|Expr
operator|*
name|getExpr
argument_list|()
specifier|const
block|{
return|return
name|Ex
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|AllocaRegionKind
return|;
block|}
expr|}
block|;
comment|/// TypedRegion - An abstract class representing regions that are typed.
name|class
name|TypedRegion
operator|:
name|public
name|SubRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
name|override
block|;
name|protected
operator|:
name|TypedRegion
argument_list|(
argument|const MemRegion *sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|SubRegion
argument_list|(
argument|sReg
argument_list|,
argument|k
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
name|virtual
name|QualType
name|getLocationType
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|QualType
name|getDesugaredLocationType
argument_list|(
argument|ASTContext&Context
argument_list|)
specifier|const
block|{
return|return
name|getLocationType
argument_list|()
operator|.
name|getDesugaredType
argument_list|(
name|Context
argument_list|)
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_TYPED_REGIONS
operator|&&
name|k
operator|<=
name|END_TYPED_REGIONS
return|;
block|}
expr|}
block|;
comment|/// TypedValueRegion - An abstract class representing regions having a typed value.
name|class
name|TypedValueRegion
operator|:
name|public
name|TypedRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
name|override
block|;
name|protected
operator|:
name|TypedValueRegion
argument_list|(
argument|const MemRegion* sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|TypedRegion
argument_list|(
argument|sReg
argument_list|,
argument|k
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
name|virtual
name|QualType
name|getValueType
argument_list|()
specifier|const
operator|=
literal|0
block|;
name|QualType
name|getLocationType
argument_list|()
specifier|const
name|override
block|{
comment|// FIXME: We can possibly optimize this later to cache this value.
name|QualType
name|T
operator|=
name|getValueType
argument_list|()
block|;
name|ASTContext
operator|&
name|ctx
operator|=
name|getContext
argument_list|()
block|;
if|if
condition|(
name|T
operator|->
name|getAs
operator|<
name|ObjCObjectType
operator|>
operator|(
operator|)
condition|)
return|return
name|ctx
operator|.
name|getObjCObjectPointerType
argument_list|(
name|T
argument_list|)
return|;
return|return
name|ctx
operator|.
name|getPointerType
argument_list|(
name|getValueType
argument_list|()
argument_list|)
return|;
block|}
name|QualType
name|getDesugaredValueType
argument_list|(
argument|ASTContext&Context
argument_list|)
specifier|const
block|{
name|QualType
name|T
operator|=
name|getValueType
argument_list|()
block|;
return|return
name|T
operator|.
name|getTypePtrOrNull
argument_list|()
condition|?
name|T
operator|.
name|getDesugaredType
argument_list|(
name|Context
argument_list|)
else|:
name|T
return|;
block|}
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_TYPED_VALUE_REGIONS
operator|&&
name|k
operator|<=
name|END_TYPED_VALUE_REGIONS
return|;
block|}
expr|}
block|;
name|class
name|CodeTextRegion
operator|:
name|public
name|TypedRegion
block|{
name|virtual
name|void
name|anchor
argument_list|()
name|override
block|;
name|protected
operator|:
name|CodeTextRegion
argument_list|(
argument|const MemSpaceRegion *sreg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|TypedRegion
argument_list|(
argument|sreg
argument_list|,
argument|k
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;   }
name|public
operator|:
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|Kind
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_CODE_TEXT_REGIONS
operator|&&
name|k
operator|<=
name|END_CODE_TEXT_REGIONS
return|;
block|}
expr|}
block|;
comment|/// FunctionCodeRegion - A region that represents code texts of function.
name|class
name|FunctionCodeRegion
operator|:
name|public
name|CodeTextRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|NamedDecl
operator|*
name|FD
block|;
name|FunctionCodeRegion
argument_list|(
specifier|const
name|NamedDecl
operator|*
name|fd
argument_list|,
specifier|const
name|CodeSpaceRegion
operator|*
name|sreg
argument_list|)
operator|:
name|CodeTextRegion
argument_list|(
name|sreg
argument_list|,
name|FunctionCodeRegionKind
argument_list|)
block|,
name|FD
argument_list|(
argument|fd
argument_list|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|ObjCMethodDecl
operator|>
operator|(
name|fd
operator|)
operator|||
name|isa
operator|<
name|FunctionDecl
operator|>
operator|(
name|fd
operator|)
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|NamedDecl
operator|*
name|FD
argument_list|,
specifier|const
name|MemRegion
operator|*
argument_list|)
block|;
name|public
operator|:
name|QualType
name|getLocationType
argument_list|()
specifier|const
name|override
block|{
specifier|const
name|ASTContext
operator|&
name|Ctx
operator|=
name|getContext
argument_list|()
block|;
if|if
condition|(
specifier|const
name|FunctionDecl
modifier|*
name|D
init|=
name|dyn_cast
operator|<
name|FunctionDecl
operator|>
operator|(
name|FD
operator|)
condition|)
block|{
return|return
name|Ctx
operator|.
name|getPointerType
argument_list|(
name|D
operator|->
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|assert
argument_list|(
name|isa
operator|<
name|ObjCMethodDecl
operator|>
operator|(
name|FD
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|false
operator|&&
literal|"Getting the type of ObjCMethod is not supported yet"
argument_list|)
block|;
comment|// TODO: We might want to return a different type here (ex: id (*ty)(...))
comment|//       depending on how it is used.
return|return
name|QualType
argument_list|()
return|;
block|}
specifier|const
name|NamedDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|FD
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|FunctionCodeRegionKind
return|;
block|}
expr|}
block|;
comment|/// BlockCodeRegion - A region that represents code texts of blocks (closures).
comment|///  Blocks are represented with two kinds of regions.  BlockCodeRegions
comment|///  represent the "code", while BlockDataRegions represent instances of blocks,
comment|///  which correspond to "code+data".  The distinction is important, because
comment|///  like a closure a block captures the values of externally referenced
comment|///  variables.
name|class
name|BlockCodeRegion
operator|:
name|public
name|CodeTextRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|BlockDecl
operator|*
name|BD
block|;
name|AnalysisDeclContext
operator|*
name|AC
block|;
name|CanQualType
name|locTy
block|;
name|BlockCodeRegion
argument_list|(
argument|const BlockDecl *bd
argument_list|,
argument|CanQualType lTy
argument_list|,
argument|AnalysisDeclContext *ac
argument_list|,
argument|const CodeSpaceRegion* sreg
argument_list|)
operator|:
name|CodeTextRegion
argument_list|(
name|sreg
argument_list|,
name|BlockCodeRegionKind
argument_list|)
block|,
name|BD
argument_list|(
name|bd
argument_list|)
block|,
name|AC
argument_list|(
name|ac
argument_list|)
block|,
name|locTy
argument_list|(
argument|lTy
argument_list|)
block|{
name|assert
argument_list|(
name|bd
argument_list|)
block|;
name|assert
argument_list|(
name|ac
argument_list|)
block|;
name|assert
argument_list|(
name|lTy
operator|->
name|getTypePtr
argument_list|()
operator|->
name|isBlockPointerType
argument_list|()
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|BlockDecl
operator|*
name|BD
argument_list|,
name|CanQualType
argument_list|,
specifier|const
name|AnalysisDeclContext
operator|*
argument_list|,
specifier|const
name|MemRegion
operator|*
argument_list|)
block|;
name|public
operator|:
name|QualType
name|getLocationType
argument_list|()
specifier|const
name|override
block|{
return|return
name|locTy
return|;
block|}
specifier|const
name|BlockDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|BD
return|;
block|}
name|AnalysisDeclContext
operator|*
name|getAnalysisDeclContext
argument_list|()
specifier|const
block|{
return|return
name|AC
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|BlockCodeRegionKind
return|;
block|}
expr|}
block|;
comment|/// BlockDataRegion - A region that represents a block instance.
comment|///  Blocks are represented with two kinds of regions.  BlockCodeRegions
comment|///  represent the "code", while BlockDataRegions represent instances of blocks,
comment|///  which correspond to "code+data".  The distinction is important, because
comment|///  like a closure a block captures the values of externally referenced
comment|///  variables.
name|class
name|BlockDataRegion
operator|:
name|public
name|TypedRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|BlockCodeRegion
operator|*
name|BC
block|;
specifier|const
name|LocationContext
operator|*
name|LC
block|;
comment|// Can be null */
name|unsigned
name|BlockCount
block|;
name|void
operator|*
name|ReferencedVars
block|;
name|void
operator|*
name|OriginalVars
block|;
name|BlockDataRegion
argument_list|(
argument|const BlockCodeRegion *bc
argument_list|,
argument|const LocationContext *lc
argument_list|,
argument|unsigned count
argument_list|,
argument|const MemSpaceRegion *sreg
argument_list|)
operator|:
name|TypedRegion
argument_list|(
name|sreg
argument_list|,
name|BlockDataRegionKind
argument_list|)
block|,
name|BC
argument_list|(
name|bc
argument_list|)
block|,
name|LC
argument_list|(
name|lc
argument_list|)
block|,
name|BlockCount
argument_list|(
name|count
argument_list|)
block|,
name|ReferencedVars
argument_list|(
name|nullptr
argument_list|)
block|,
name|OriginalVars
argument_list|(
argument|nullptr
argument_list|)
block|{
name|assert
argument_list|(
name|bc
argument_list|)
block|;
name|assert
argument_list|(
name|lc
argument_list|)
block|;
name|assert
argument_list|(
name|isa
operator|<
name|GlobalImmutableSpaceRegion
operator|>
operator|(
name|sreg
operator|)
operator|||
name|isa
operator|<
name|StackLocalsSpaceRegion
operator|>
operator|(
name|sreg
operator|)
operator|||
name|isa
operator|<
name|UnknownSpaceRegion
operator|>
operator|(
name|sreg
operator|)
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
argument_list|,
specifier|const
name|BlockCodeRegion
operator|*
argument_list|,
specifier|const
name|LocationContext
operator|*
argument_list|,
name|unsigned
argument_list|,
specifier|const
name|MemRegion
operator|*
argument_list|)
block|;
name|public
operator|:
specifier|const
name|BlockCodeRegion
operator|*
name|getCodeRegion
argument_list|()
specifier|const
block|{
return|return
name|BC
return|;
block|}
specifier|const
name|BlockDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|BC
operator|->
name|getDecl
argument_list|()
return|;
block|}
name|QualType
name|getLocationType
argument_list|()
specifier|const
name|override
block|{
return|return
name|BC
operator|->
name|getLocationType
argument_list|()
return|;
block|}
name|class
name|referenced_vars_iterator
block|{
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|R
block|;
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|OriginalR
block|;
name|public
operator|:
name|explicit
name|referenced_vars_iterator
argument_list|(
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|r
argument_list|,
specifier|const
name|MemRegion
operator|*
specifier|const
operator|*
name|originalR
argument_list|)
operator|:
name|R
argument_list|(
name|r
argument_list|)
block|,
name|OriginalR
argument_list|(
argument|originalR
argument_list|)
block|{}
specifier|const
name|VarRegion
operator|*
name|getCapturedRegion
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|VarRegion
operator|>
operator|(
operator|*
name|R
operator|)
return|;
block|}
specifier|const
name|VarRegion
operator|*
name|getOriginalRegion
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|VarRegion
operator|>
operator|(
operator|*
name|OriginalR
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|referenced_vars_iterator
operator|&
name|I
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|R
operator|==
name|nullptr
operator|)
operator|==
operator|(
name|I
operator|.
name|R
operator|==
name|nullptr
operator|)
argument_list|)
block|;
return|return
name|I
operator|.
name|R
operator|==
name|R
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|referenced_vars_iterator
operator|&
name|I
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|R
operator|==
name|nullptr
operator|)
operator|==
operator|(
name|I
operator|.
name|R
operator|==
name|nullptr
operator|)
argument_list|)
block|;
return|return
name|I
operator|.
name|R
operator|!=
name|R
return|;
block|}
name|referenced_vars_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|R
block|;
operator|++
name|OriginalR
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|;
comment|/// Return the original region for a captured region, if
comment|/// one exists.
specifier|const
name|VarRegion
operator|*
name|getOriginalRegion
argument_list|(
argument|const VarRegion *VR
argument_list|)
specifier|const
block|;
name|referenced_vars_iterator
name|referenced_vars_begin
argument_list|()
specifier|const
block|;
name|referenced_vars_iterator
name|referenced_vars_end
argument_list|()
specifier|const
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|BlockDataRegionKind
return|;
block|}
name|private
operator|:
name|void
name|LazyInitializeReferencedVars
argument_list|()
block|;
name|std
operator|::
name|pair
operator|<
specifier|const
name|VarRegion
operator|*
block|,
specifier|const
name|VarRegion
operator|*
operator|>
name|getCaptureRegions
argument_list|(
specifier|const
name|VarDecl
operator|*
name|VD
argument_list|)
block|; }
block|;
comment|/// SymbolicRegion - A special, "non-concrete" region. Unlike other region
comment|///  classes, SymbolicRegion represents a region that serves as an alias for
comment|///  either a real region, a NULL pointer, etc.  It essentially is used to
comment|///  map the concept of symbolic values into the domain of regions.  Symbolic
comment|///  regions do not need to be typed.
name|class
name|SymbolicRegion
operator|:
name|public
name|SubRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|SymbolRef
name|sym
block|;
name|SymbolicRegion
argument_list|(
argument|const SymbolRef s
argument_list|,
argument|const MemSpaceRegion *sreg
argument_list|)
operator|:
name|SubRegion
argument_list|(
name|sreg
argument_list|,
name|SymbolicRegionKind
argument_list|)
block|,
name|sym
argument_list|(
argument|s
argument_list|)
block|{
name|assert
argument_list|(
name|s
argument_list|)
block|;
name|assert
argument_list|(
name|s
operator|->
name|getType
argument_list|()
operator|->
name|isAnyPointerType
argument_list|()
operator|||
name|s
operator|->
name|getType
argument_list|()
operator|->
name|isReferenceType
argument_list|()
operator|||
name|s
operator|->
name|getType
argument_list|()
operator|->
name|isBlockPointerType
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
name|isa
operator|<
name|UnknownSpaceRegion
operator|>
operator|(
name|sreg
operator|)
operator|||
name|isa
operator|<
name|HeapSpaceRegion
operator|>
operator|(
name|sreg
operator|)
argument_list|)
block|;   }
name|public
operator|:
name|SymbolRef
name|getSymbol
argument_list|()
specifier|const
block|{
return|return
name|sym
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|SymbolRef sym
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|SymbolicRegionKind
return|;
block|}
expr|}
block|;
comment|/// StringRegion - Region associated with a StringLiteral.
name|class
name|StringRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|StringLiteral
operator|*
name|Str
block|;
name|StringRegion
argument_list|(
specifier|const
name|StringLiteral
operator|*
name|str
argument_list|,
specifier|const
name|GlobalInternalSpaceRegion
operator|*
name|sreg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sreg
argument_list|,
name|StringRegionKind
argument_list|)
block|,
name|Str
argument_list|(
argument|str
argument_list|)
block|{
name|assert
argument_list|(
name|str
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|StringLiteral
operator|*
name|Str
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|StringLiteral
operator|*
name|getStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|Str
operator|->
name|getType
argument_list|()
return|;
block|}
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|{
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|Str
argument_list|,
name|superRegion
argument_list|)
block|;   }
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|StringRegionKind
return|;
block|}
expr|}
block|;
comment|/// The region associated with an ObjCStringLiteral.
name|class
name|ObjCStringRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|ObjCStringLiteral
operator|*
name|Str
block|;
name|ObjCStringRegion
argument_list|(
specifier|const
name|ObjCStringLiteral
operator|*
name|str
argument_list|,
specifier|const
name|GlobalInternalSpaceRegion
operator|*
name|sreg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sreg
argument_list|,
name|ObjCStringRegionKind
argument_list|)
block|,
name|Str
argument_list|(
argument|str
argument_list|)
block|{
name|assert
argument_list|(
name|str
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|ObjCStringLiteral
operator|*
name|Str
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|ObjCStringLiteral
operator|*
name|getObjCStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|Str
operator|->
name|getType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
name|false
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|{
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|Str
argument_list|,
name|superRegion
argument_list|)
block|;   }
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCStringRegionKind
return|;
block|}
expr|}
block|;
comment|/// CompoundLiteralRegion - A memory region representing a compound literal.
comment|///   Compound literals are essentially temporaries that are stack allocated
comment|///   or in the global constant pool.
name|class
name|CompoundLiteralRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
block|;
name|CompoundLiteralRegion
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|cl
argument_list|,
specifier|const
name|MemSpaceRegion
operator|*
name|sReg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sReg
argument_list|,
name|CompoundLiteralRegionKind
argument_list|)
block|,
name|CL
argument_list|(
argument|cl
argument_list|)
block|{
name|assert
argument_list|(
name|cl
argument_list|)
block|;
name|assert
argument_list|(
name|isa
operator|<
name|GlobalInternalSpaceRegion
operator|>
operator|(
name|sReg
operator|)
operator|||
name|isa
operator|<
name|StackLocalsSpaceRegion
operator|>
operator|(
name|sReg
operator|)
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|CL
operator|->
name|getType
argument_list|()
return|;
block|}
name|bool
name|isBoundable
argument_list|()
specifier|const
name|override
block|{
return|return
operator|!
name|CL
operator|->
name|isFileScope
argument_list|()
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|const
name|CompoundLiteralExpr
operator|*
name|getLiteralExpr
argument_list|()
specifier|const
block|{
return|return
name|CL
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CompoundLiteralRegionKind
return|;
block|}
expr|}
block|;
name|class
name|DeclRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|protected
operator|:
specifier|const
name|Decl
operator|*
name|D
block|;
name|DeclRegion
argument_list|(
argument|const Decl *d
argument_list|,
argument|const MemRegion *sReg
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sReg
argument_list|,
name|k
argument_list|)
block|,
name|D
argument_list|(
argument|d
argument_list|)
block|{
name|assert
argument_list|(
name|classof
argument_list|(
name|this
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|d
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const Decl *D
argument_list|,
argument|const MemRegion* superRegion
argument_list|,
argument|Kind k
argument_list|)
block|;
name|public
operator|:
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|D
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
name|unsigned
name|k
operator|=
name|R
operator|->
name|getKind
argument_list|()
block|;
return|return
name|k
operator|>=
name|BEGIN_DECL_REGIONS
operator|&&
name|k
operator|<=
name|END_DECL_REGIONS
return|;
block|}
expr|}
block|;
name|class
name|VarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
comment|// Constructors and private methods.
name|VarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|vd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|vd
argument_list|,
argument|sReg
argument_list|,
argument|VarRegionKind
argument_list|)
block|{
comment|// VarRegion appears in unknown space when it's a block variable as seen
comment|// from a block using it, when this block is analyzed at top-level.
comment|// Other block variables appear within block data regions,
comment|// which, unlike everything else on this list, are not memory spaces.
name|assert
argument_list|(
name|isa
operator|<
name|GlobalsSpaceRegion
operator|>
operator|(
name|sReg
operator|)
operator|||
name|isa
operator|<
name|StackSpaceRegion
operator|>
operator|(
name|sReg
operator|)
operator|||
name|isa
operator|<
name|BlockDataRegion
operator|>
operator|(
name|sReg
operator|)
operator|||
name|isa
operator|<
name|UnknownSpaceRegion
operator|>
operator|(
name|sReg
operator|)
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const VarDecl *VD
argument_list|,
argument|const MemRegion *superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|VD
argument_list|,
name|superRegion
argument_list|,
name|VarRegionKind
argument_list|)
block|;   }
name|public
operator|:
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|const
name|VarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|VarDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|()
specifier|const
block|;
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|VarRegionKind
return|;
block|}
name|bool
name|canPrintPrettyAsExpr
argument_list|()
specifier|const
name|override
block|;
name|void
name|printPrettyAsExpr
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|; }
block|;
comment|/// CXXThisRegion - Represents the region for the implicit 'this' parameter
comment|///  in a call to a C++ method.  This region doesn't represent the object
comment|///  referred to by 'this', but rather 'this' itself.
name|class
name|CXXThisRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|CXXThisRegion
argument_list|(
specifier|const
name|PointerType
operator|*
name|thisPointerTy
argument_list|,
specifier|const
name|StackArgumentsSpaceRegion
operator|*
name|sReg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sReg
argument_list|,
name|CXXThisRegionKind
argument_list|)
block|,
name|ThisPointerTy
argument_list|(
argument|thisPointerTy
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|PointerType
operator|*
name|PT
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
block|;
name|public
operator|:
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|QualType
argument_list|(
name|ThisPointerTy
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CXXThisRegionKind
return|;
block|}
name|private
operator|:
specifier|const
name|PointerType
operator|*
name|ThisPointerTy
block|; }
block|;
name|class
name|FieldRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|FieldRegion
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|fd
argument_list|,
specifier|const
name|SubRegion
operator|*
name|sReg
argument_list|)
operator|:
name|DeclRegion
argument_list|(
argument|fd
argument_list|,
argument|sReg
argument_list|,
argument|FieldRegionKind
argument_list|)
block|{}
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|const FieldDecl *FD
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|{
name|DeclRegion
operator|::
name|ProfileRegion
argument_list|(
name|ID
argument_list|,
name|FD
argument_list|,
name|superRegion
argument_list|,
name|FieldRegionKind
argument_list|)
block|;   }
name|public
operator|:
specifier|const
name|FieldDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|D
operator|)
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
comment|// FIXME: We can cache this if needed.
return|return
name|getDecl
argument_list|()
operator|->
name|getType
argument_list|()
return|;
block|}
name|DefinedOrUnknownSVal
name|getExtent
argument_list|(
argument|SValBuilder&svalBuilder
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|FieldRegionKind
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|bool
name|canPrintPretty
argument_list|()
specifier|const
name|override
block|;
name|void
name|printPretty
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|bool
name|canPrintPrettyAsExpr
argument_list|()
specifier|const
name|override
block|;
name|void
name|printPrettyAsExpr
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|; }
block|;
name|class
name|ObjCIvarRegion
operator|:
name|public
name|DeclRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|ObjCIvarRegion
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|SubRegion
operator|*
name|sReg
argument_list|)
block|;
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superRegion
argument_list|)
block|;
name|public
operator|:
specifier|const
name|ObjCIvarDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|;
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|;
name|bool
name|canPrintPrettyAsExpr
argument_list|()
specifier|const
name|override
block|;
name|void
name|printPrettyAsExpr
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ObjCIvarRegionKind
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|// Auxiliary data classes for use with MemRegions.
comment|//===----------------------------------------------------------------------===//
name|class
name|ElementRegion
block|;
name|class
name|RegionRawOffset
block|{
name|friend
name|class
name|ElementRegion
block|;
specifier|const
name|MemRegion
operator|*
name|Region
block|;
name|CharUnits
name|Offset
block|;
name|RegionRawOffset
argument_list|(
argument|const MemRegion* reg
argument_list|,
argument|CharUnits offset = CharUnits::Zero()
argument_list|)
operator|:
name|Region
argument_list|(
name|reg
argument_list|)
block|,
name|Offset
argument_list|(
argument|offset
argument_list|)
block|{}
name|public
operator|:
comment|// FIXME: Eventually support symbolic offsets.
name|CharUnits
name|getOffset
argument_list|()
specifier|const
block|{
return|return
name|Offset
return|;
block|}
specifier|const
name|MemRegion
operator|*
name|getRegion
argument_list|()
specifier|const
block|{
return|return
name|Region
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
block|;
name|void
name|dump
argument_list|()
specifier|const
block|; }
block|;
comment|/// \brief ElementRegin is used to represent both array elements and casts.
name|class
name|ElementRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|QualType
name|ElementType
block|;
name|NonLoc
name|Index
block|;
name|ElementRegion
argument_list|(
argument|QualType elementType
argument_list|,
argument|NonLoc Idx
argument_list|,
argument|const SubRegion *sReg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sReg
argument_list|,
name|ElementRegionKind
argument_list|)
block|,
name|ElementType
argument_list|(
name|elementType
argument_list|)
block|,
name|Index
argument_list|(
argument|Idx
argument_list|)
block|{
name|assert
argument_list|(
operator|(
operator|!
name|Idx
operator|.
name|getAs
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|)
operator|||
name|Idx
operator|.
name|castAs
operator|<
name|nonloc
operator|::
name|ConcreteInt
operator|>
operator|(
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|isSigned
argument_list|()
operator|)
operator|&&
literal|"The index must be signed"
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|,
argument|QualType elementType
argument_list|,
argument|SVal Idx
argument_list|,
argument|const MemRegion* superRegion
argument_list|)
block|;
name|public
operator|:
name|NonLoc
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|ElementType
return|;
block|}
name|QualType
name|getElementType
argument_list|()
specifier|const
block|{
return|return
name|ElementType
return|;
block|}
comment|/// Compute the offset within the array. The array might also be a subobject.
name|RegionRawOffset
name|getAsArrayOffset
argument_list|()
specifier|const
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID& ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|ElementRegionKind
return|;
block|}
expr|}
block|;
comment|// C++ temporary object associated with an expression.
name|class
name|CXXTempObjectRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|Expr
specifier|const
operator|*
name|Ex
block|;
name|CXXTempObjectRegion
argument_list|(
name|Expr
specifier|const
operator|*
name|E
argument_list|,
name|MemSpaceRegion
specifier|const
operator|*
name|sReg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|sReg
argument_list|,
name|CXXTempObjectRegionKind
argument_list|)
block|,
name|Ex
argument_list|(
argument|E
argument_list|)
block|{
name|assert
argument_list|(
name|E
argument_list|)
block|;
name|assert
argument_list|(
name|isa
operator|<
name|StackLocalsSpaceRegion
operator|>
operator|(
name|sReg
operator|)
operator|||
name|isa
operator|<
name|GlobalInternalSpaceRegion
operator|>
operator|(
name|sReg
operator|)
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
name|Expr
specifier|const
operator|*
name|E
argument_list|,
specifier|const
name|MemRegion
operator|*
name|sReg
argument_list|)
block|;
name|public
operator|:
specifier|const
name|Expr
operator|*
name|getExpr
argument_list|()
specifier|const
block|{
return|return
name|Ex
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|{
return|return
name|Ex
operator|->
name|getType
argument_list|()
return|;
block|}
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion* R
argument_list|)
block|{
return|return
name|R
operator|->
name|getKind
argument_list|()
operator|==
name|CXXTempObjectRegionKind
return|;
block|}
expr|}
block|;
comment|// CXXBaseObjectRegion represents a base object within a C++ object. It is
comment|// identified by the base class declaration and the region of its parent object.
name|class
name|CXXBaseObjectRegion
operator|:
name|public
name|TypedValueRegion
block|{
name|friend
name|class
name|MemRegionManager
block|;
name|llvm
operator|::
name|PointerIntPair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|Data
block|;
name|CXXBaseObjectRegion
argument_list|(
argument|const CXXRecordDecl *RD
argument_list|,
argument|bool IsVirtual
argument_list|,
argument|const SubRegion *SReg
argument_list|)
operator|:
name|TypedValueRegion
argument_list|(
name|SReg
argument_list|,
name|CXXBaseObjectRegionKind
argument_list|)
block|,
name|Data
argument_list|(
argument|RD
argument_list|,
argument|IsVirtual
argument_list|)
block|{
name|assert
argument_list|(
name|RD
argument_list|)
block|;   }
specifier|static
name|void
name|ProfileRegion
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|const CXXRecordDecl *RD
argument_list|,
argument|bool IsVirtual
argument_list|,
argument|const MemRegion *SReg
argument_list|)
block|;
name|public
operator|:
specifier|const
name|CXXRecordDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|Data
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|bool
name|isVirtual
argument_list|()
specifier|const
block|{
return|return
name|Data
operator|.
name|getInt
argument_list|()
return|;
block|}
name|QualType
name|getValueType
argument_list|()
specifier|const
name|override
block|;
name|void
name|dumpToStream
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|;
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const MemRegion *region
argument_list|)
block|{
return|return
name|region
operator|->
name|getKind
argument_list|()
operator|==
name|CXXBaseObjectRegionKind
return|;
block|}
name|bool
name|canPrintPrettyAsExpr
argument_list|()
specifier|const
name|override
block|;
name|void
name|printPrettyAsExpr
argument_list|(
argument|raw_ostream&os
argument_list|)
specifier|const
name|override
block|; }
block|;
name|template
operator|<
name|typename
name|RegionTy
operator|>
specifier|const
name|RegionTy
operator|*
name|MemRegion
operator|::
name|getAs
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|RegionTy
modifier|*
name|RT
init|=
name|dyn_cast
operator|<
name|RegionTy
operator|>
operator|(
name|this
operator|)
condition|)
return|return
name|RT
return|;
return|return
name|nullptr
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// MemRegionManager - Factory object for creating regions.
comment|//===----------------------------------------------------------------------===//
name|class
name|MemRegionManager
block|{
name|ASTContext
operator|&
name|C
block|;
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|A
block|;
name|llvm
operator|::
name|FoldingSet
operator|<
name|MemRegion
operator|>
name|Regions
block|;
name|GlobalInternalSpaceRegion
operator|*
name|InternalGlobals
block|;
name|GlobalSystemSpaceRegion
operator|*
name|SystemGlobals
block|;
name|GlobalImmutableSpaceRegion
operator|*
name|ImmutableGlobals
block|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|StackFrameContext
operator|*
block|,
name|StackLocalsSpaceRegion
operator|*
operator|>
name|StackLocalsSpaceRegions
block|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|StackFrameContext
operator|*
block|,
name|StackArgumentsSpaceRegion
operator|*
operator|>
name|StackArgumentsSpaceRegions
block|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CodeTextRegion
operator|*
block|,
name|StaticGlobalSpaceRegion
operator|*
operator|>
name|StaticsGlobalSpaceRegions
block|;
name|HeapSpaceRegion
operator|*
name|heap
block|;
name|UnknownSpaceRegion
operator|*
name|unknown
block|;
name|CodeSpaceRegion
operator|*
name|code
block|;
name|public
operator|:
name|MemRegionManager
argument_list|(
name|ASTContext
operator|&
name|c
argument_list|,
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|a
argument_list|)
operator|:
name|C
argument_list|(
name|c
argument_list|)
block|,
name|A
argument_list|(
name|a
argument_list|)
block|,
name|InternalGlobals
argument_list|(
name|nullptr
argument_list|)
block|,
name|SystemGlobals
argument_list|(
name|nullptr
argument_list|)
block|,
name|ImmutableGlobals
argument_list|(
name|nullptr
argument_list|)
block|,
name|heap
argument_list|(
name|nullptr
argument_list|)
block|,
name|unknown
argument_list|(
name|nullptr
argument_list|)
block|,
name|code
argument_list|(
argument|nullptr
argument_list|)
block|{}
operator|~
name|MemRegionManager
argument_list|()
block|;
name|ASTContext
operator|&
name|getContext
argument_list|()
block|{
return|return
name|C
return|;
block|}
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
block|{
return|return
name|A
return|;
block|}
comment|/// getStackLocalsRegion - Retrieve the memory region associated with the
comment|///  specified stack frame.
specifier|const
name|StackLocalsSpaceRegion
operator|*
name|getStackLocalsRegion
argument_list|(
specifier|const
name|StackFrameContext
operator|*
name|STC
argument_list|)
block|;
comment|/// getStackArgumentsRegion - Retrieve the memory region associated with
comment|///  function/method arguments of the specified stack frame.
specifier|const
name|StackArgumentsSpaceRegion
operator|*
name|getStackArgumentsRegion
argument_list|(
specifier|const
name|StackFrameContext
operator|*
name|STC
argument_list|)
block|;
comment|/// getGlobalsRegion - Retrieve the memory region associated with
comment|///  global variables.
specifier|const
name|GlobalsSpaceRegion
operator|*
name|getGlobalsRegion
argument_list|(
argument|MemRegion::Kind K = MemRegion::GlobalInternalSpaceRegionKind
argument_list|,
argument|const CodeTextRegion *R = nullptr
argument_list|)
block|;
comment|/// getHeapRegion - Retrieve the memory region associated with the
comment|///  generic "heap".
specifier|const
name|HeapSpaceRegion
operator|*
name|getHeapRegion
argument_list|()
block|;
comment|/// getUnknownRegion - Retrieve the memory region associated with unknown
comment|/// memory space.
specifier|const
name|UnknownSpaceRegion
operator|*
name|getUnknownRegion
argument_list|()
block|;
specifier|const
name|CodeSpaceRegion
operator|*
name|getCodeRegion
argument_list|()
block|;
comment|/// getAllocaRegion - Retrieve a region associated with a call to alloca().
specifier|const
name|AllocaRegion
operator|*
name|getAllocaRegion
argument_list|(
argument|const Expr *Ex
argument_list|,
argument|unsigned Cnt
argument_list|,
argument|const LocationContext *LC
argument_list|)
block|;
comment|/// getCompoundLiteralRegion - Retrieve the region associated with a
comment|///  given CompoundLiteral.
specifier|const
name|CompoundLiteralRegion
operator|*
name|getCompoundLiteralRegion
argument_list|(
specifier|const
name|CompoundLiteralExpr
operator|*
name|CL
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
block|;
comment|/// getCXXThisRegion - Retrieve the [artificial] region associated with the
comment|///  parameter 'this'.
specifier|const
name|CXXThisRegion
operator|*
name|getCXXThisRegion
argument_list|(
argument|QualType thisPointerTy
argument_list|,
argument|const LocationContext *LC
argument_list|)
block|;
comment|/// \brief Retrieve or create a "symbolic" memory region.
specifier|const
name|SymbolicRegion
operator|*
name|getSymbolicRegion
argument_list|(
argument|SymbolRef Sym
argument_list|)
block|;
comment|/// \brief Return a unique symbolic region belonging to heap memory space.
specifier|const
name|SymbolicRegion
operator|*
name|getSymbolicHeapRegion
argument_list|(
argument|SymbolRef sym
argument_list|)
block|;
specifier|const
name|StringRegion
operator|*
name|getStringRegion
argument_list|(
specifier|const
name|StringLiteral
operator|*
name|Str
argument_list|)
block|;
specifier|const
name|ObjCStringRegion
operator|*
name|getObjCStringRegion
argument_list|(
specifier|const
name|ObjCStringLiteral
operator|*
name|Str
argument_list|)
block|;
comment|/// getVarRegion - Retrieve or create the memory region associated with
comment|///  a specified VarDecl and LocationContext.
specifier|const
name|VarRegion
operator|*
name|getVarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|,
specifier|const
name|LocationContext
operator|*
name|LC
argument_list|)
block|;
comment|/// getVarRegion - Retrieve or create the memory region associated with
comment|///  a specified VarDecl and super region.
specifier|const
name|VarRegion
operator|*
name|getVarRegion
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|,
specifier|const
name|MemRegion
operator|*
name|superR
argument_list|)
block|;
comment|/// getElementRegion - Retrieve the memory region associated with the
comment|///  associated element type, index, and super region.
specifier|const
name|ElementRegion
operator|*
name|getElementRegion
argument_list|(
argument|QualType elementType
argument_list|,
argument|NonLoc Idx
argument_list|,
argument|const SubRegion *superRegion
argument_list|,
argument|ASTContext&Ctx
argument_list|)
block|;
specifier|const
name|ElementRegion
operator|*
name|getElementRegionWithSuper
argument_list|(
argument|const ElementRegion *ER
argument_list|,
argument|const SubRegion *superRegion
argument_list|)
block|{
return|return
name|getElementRegion
argument_list|(
name|ER
operator|->
name|getElementType
argument_list|()
argument_list|,
name|ER
operator|->
name|getIndex
argument_list|()
argument_list|,
name|superRegion
argument_list|,
name|ER
operator|->
name|getContext
argument_list|()
argument_list|)
return|;
block|}
comment|/// getFieldRegion - Retrieve or create the memory region associated with
comment|///  a specified FieldDecl.  'superRegion' corresponds to the containing
comment|///  memory region (which typically represents the memory representing
comment|///  a structure or class).
specifier|const
name|FieldRegion
operator|*
name|getFieldRegion
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|fd
argument_list|,
specifier|const
name|SubRegion
operator|*
name|superRegion
argument_list|)
block|;
specifier|const
name|FieldRegion
operator|*
name|getFieldRegionWithSuper
argument_list|(
argument|const FieldRegion *FR
argument_list|,
argument|const SubRegion *superRegion
argument_list|)
block|{
return|return
name|getFieldRegion
argument_list|(
name|FR
operator|->
name|getDecl
argument_list|()
argument_list|,
name|superRegion
argument_list|)
return|;
block|}
comment|/// getObjCIvarRegion - Retrieve or create the memory region associated with
comment|///   a specified Objective-c instance variable.  'superRegion' corresponds
comment|///   to the containing region (which typically represents the Objective-C
comment|///   object).
specifier|const
name|ObjCIvarRegion
operator|*
name|getObjCIvarRegion
argument_list|(
specifier|const
name|ObjCIvarDecl
operator|*
name|ivd
argument_list|,
specifier|const
name|SubRegion
operator|*
name|superRegion
argument_list|)
block|;
specifier|const
name|CXXTempObjectRegion
operator|*
name|getCXXTempObjectRegion
argument_list|(
name|Expr
specifier|const
operator|*
name|Ex
argument_list|,
name|LocationContext
specifier|const
operator|*
name|LC
argument_list|)
block|;
comment|/// Create a CXXBaseObjectRegion with the given base class for region
comment|/// \p Super.
comment|///
comment|/// The type of \p Super is assumed be a class deriving from \p BaseClass.
specifier|const
name|CXXBaseObjectRegion
operator|*
name|getCXXBaseObjectRegion
argument_list|(
argument|const CXXRecordDecl *BaseClass
argument_list|,
argument|const SubRegion *Super
argument_list|,
argument|bool IsVirtual
argument_list|)
block|;
comment|/// Create a CXXBaseObjectRegion with the same CXXRecordDecl but a different
comment|/// super region.
specifier|const
name|CXXBaseObjectRegion
operator|*
name|getCXXBaseObjectRegionWithSuper
argument_list|(
argument|const CXXBaseObjectRegion *baseReg
argument_list|,
argument|const SubRegion *superRegion
argument_list|)
block|{
return|return
name|getCXXBaseObjectRegion
argument_list|(
name|baseReg
operator|->
name|getDecl
argument_list|()
argument_list|,
name|superRegion
argument_list|,
name|baseReg
operator|->
name|isVirtual
argument_list|()
argument_list|)
return|;
block|}
specifier|const
name|FunctionCodeRegion
operator|*
name|getFunctionCodeRegion
argument_list|(
specifier|const
name|NamedDecl
operator|*
name|FD
argument_list|)
block|;
specifier|const
name|BlockCodeRegion
operator|*
name|getBlockCodeRegion
argument_list|(
argument|const BlockDecl *BD
argument_list|,
argument|CanQualType locTy
argument_list|,
argument|AnalysisDeclContext *AC
argument_list|)
block|;
comment|/// getBlockDataRegion - Get the memory region associated with an instance
comment|///  of a block.  Unlike many other MemRegions, the LocationContext*
comment|///  argument is allowed to be NULL for cases where we have no known
comment|///  context.
specifier|const
name|BlockDataRegion
operator|*
name|getBlockDataRegion
argument_list|(
argument|const BlockCodeRegion *bc
argument_list|,
argument|const LocationContext *lc
argument_list|,
argument|unsigned blockCount
argument_list|)
block|;
comment|/// Create a CXXTempObjectRegion for temporaries which are lifetime-extended
comment|/// by static references. This differs from getCXXTempObjectRegion in the
comment|/// super-region used.
specifier|const
name|CXXTempObjectRegion
operator|*
name|getCXXStaticTempObjectRegion
argument_list|(
specifier|const
name|Expr
operator|*
name|Ex
argument_list|)
block|;
name|private
operator|:
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|SuperTy
block|,
name|typename
name|Arg1Ty
operator|>
name|RegionTy
operator|*
name|getSubRegion
argument_list|(
argument|const Arg1Ty arg1
argument_list|,
argument|const SuperTy* superRegion
argument_list|)
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|SuperTy
block|,
name|typename
name|Arg1Ty
block|,
name|typename
name|Arg2Ty
operator|>
name|RegionTy
operator|*
name|getSubRegion
argument_list|(
argument|const Arg1Ty arg1
argument_list|,
argument|const Arg2Ty arg2
argument_list|,
argument|const SuperTy* superRegion
argument_list|)
block|;
name|template
operator|<
name|typename
name|RegionTy
block|,
name|typename
name|SuperTy
block|,
name|typename
name|Arg1Ty
block|,
name|typename
name|Arg2Ty
block|,
name|typename
name|Arg3Ty
operator|>
name|RegionTy
operator|*
name|getSubRegion
argument_list|(
argument|const Arg1Ty arg1
argument_list|,
argument|const Arg2Ty arg2
argument_list|,
argument|const Arg3Ty arg3
argument_list|,
argument|const SuperTy* superRegion
argument_list|)
block|;
name|template
operator|<
name|typename
name|REG
operator|>
specifier|const
name|REG
operator|*
name|LazyAllocate
argument_list|(
name|REG
operator|*
operator|&
name|region
argument_list|)
block|;
name|template
operator|<
name|typename
name|REG
block|,
name|typename
name|ARG
operator|>
specifier|const
name|REG
operator|*
name|LazyAllocate
argument_list|(
argument|REG*& region
argument_list|,
argument|ARG a
argument_list|)
block|; }
block|;
comment|//===----------------------------------------------------------------------===//
comment|// Out-of-line member definitions.
comment|//===----------------------------------------------------------------------===//
specifier|inline
name|ASTContext
operator|&
name|MemRegion
operator|::
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|getMemRegionManager
argument_list|()
operator|->
name|getContext
argument_list|()
return|;
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Means for storing region/symbol handling traits.
comment|//===----------------------------------------------------------------------===//
comment|/// Information about invalidation for a particular region/symbol.
name|class
name|RegionAndSymbolInvalidationTraits
block|{
typedef|typedef
name|unsigned
name|char
name|StorageTypeForKinds
typedef|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|MemRegion
operator|*
block|,
name|StorageTypeForKinds
operator|>
name|MRTraitsMap
block|;
name|llvm
operator|::
name|DenseMap
operator|<
name|SymbolRef
block|,
name|StorageTypeForKinds
operator|>
name|SymTraitsMap
block|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|MemRegion
operator|*
operator|,
name|StorageTypeForKinds
operator|>
operator|::
name|const_iterator
name|const_region_iterator
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|SymbolRef
operator|,
name|StorageTypeForKinds
operator|>
operator|::
name|const_iterator
name|const_symbol_iterator
expr_stmt|;
name|public
operator|:
comment|/// \brief Describes different invalidation traits.
block|enum
name|InvalidationKinds
block|{
comment|/// Tells that a region's contents is not changed.
name|TK_PreserveContents
operator|=
literal|0x1
block|,
comment|/// Suppress pointer-escaping of a region.
name|TK_SuppressEscape
operator|=
literal|0x2
block|,
comment|// Do not invalidate super region.
name|TK_DoNotInvalidateSuperRegion
operator|=
literal|0x4
block|,
comment|/// When applied to a MemSpaceRegion, indicates the entire memory space
comment|/// should be invalidated.
name|TK_EntireMemSpace
operator|=
literal|0x8
comment|// Do not forget to extend StorageTypeForKinds if number of traits exceed
comment|// the number of bits StorageTypeForKinds can store.
block|}
block|;
name|void
name|setTrait
argument_list|(
argument|SymbolRef Sym
argument_list|,
argument|InvalidationKinds IK
argument_list|)
block|;
name|void
name|setTrait
argument_list|(
argument|const MemRegion *MR
argument_list|,
argument|InvalidationKinds IK
argument_list|)
block|;
name|bool
name|hasTrait
argument_list|(
argument|SymbolRef Sym
argument_list|,
argument|InvalidationKinds IK
argument_list|)
specifier|const
block|;
name|bool
name|hasTrait
argument_list|(
argument|const MemRegion *MR
argument_list|,
argument|InvalidationKinds IK
argument_list|)
specifier|const
block|; }
block|;    }
comment|// end GR namespace
block|}
comment|// end clang namespace
comment|//===----------------------------------------------------------------------===//
comment|// Pretty-printing regions.
comment|//===----------------------------------------------------------------------===//
name|namespace
name|llvm
block|{
specifier|static
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|os
expr|,
specifier|const
name|clang
operator|::
name|ento
operator|::
name|MemRegion
operator|*
name|R
operator|)
block|{
name|R
operator|->
name|dumpToStream
argument_list|(
name|os
argument_list|)
block|;
return|return
name|os
return|;
block|}
expr|}
end_decl_stmt

begin_comment
comment|// end llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

