begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- DataflowSolver.h - Skeleton Dataflow Analysis Code -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines skeleton code for implementing dataflow analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSES_DATAFLOW_SOLVER
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSES_DATAFLOW_SOLVER
end_define

begin_include
include|#
directive|include
file|"clang/Analysis/CFG.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/ProgramPoint.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/FlowSensitive/DataflowValues.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"functional"
end_include

begin_comment
comment|// STL
end_comment

begin_decl_stmt
name|namespace
name|clang
block|{
comment|//===----------------------------------------------------------------------===//
comment|/// DataflowWorkListTy - Data structure representing the worklist used for
comment|///  dataflow algorithms.
comment|//===----------------------------------------------------------------------===//
name|class
name|DataflowWorkListTy
block|{
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CFGBlock
operator|*
operator|,
name|unsigned
name|char
operator|>
name|BlockSet
expr_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
specifier|const
name|CFGBlock
operator|*
operator|,
literal|10
operator|>
name|BlockQueue
expr_stmt|;
name|public
label|:
comment|/// enqueue - Add a block to the worklist.  Blocks already on the
comment|///  worklist are not added a second time.
name|void
name|enqueue
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
name|unsigned
name|char
modifier|&
name|x
init|=
name|BlockSet
index|[
name|B
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|1
condition|)
return|return;
name|x
operator|=
literal|1
expr_stmt|;
name|BlockQueue
operator|.
name|push_back
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
comment|/// dequeue - Remove a block from the worklist.
specifier|const
name|CFGBlock
modifier|*
name|dequeue
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|BlockQueue
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|CFGBlock
modifier|*
name|B
init|=
name|BlockQueue
operator|.
name|back
argument_list|()
decl_stmt|;
name|BlockQueue
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|BlockSet
index|[
name|B
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|B
return|;
block|}
comment|/// isEmpty - Return true if the worklist is empty.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|BlockQueue
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// BlockItrTraits - Traits classes that allow transparent iteration
comment|//  over successors/predecessors of a block depending on the direction
comment|//  of our dataflow analysis.
comment|//===----------------------------------------------------------------------===//
name|namespace
name|dataflow
block|{
name|template
operator|<
name|typename
name|Tag
operator|>
expr|struct
name|ItrTraits
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ItrTraits
operator|<
name|forward_analysis_tag
operator|>
block|{
typedef|typedef
name|CFGBlock
operator|::
name|const_pred_iterator
name|PrevBItr
expr_stmt|;
typedef|typedef
name|CFGBlock
operator|::
name|const_succ_iterator
name|NextBItr
expr_stmt|;
typedef|typedef
name|CFGBlock
operator|::
name|const_iterator
name|StmtItr
expr_stmt|;
specifier|static
name|PrevBItr
name|PrevBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|pred_begin
argument_list|()
return|;
block|}
specifier|static
name|PrevBItr
name|PrevEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|pred_end
argument_list|()
return|;
block|}
specifier|static
name|NextBItr
name|NextBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|succ_begin
argument_list|()
return|;
block|}
specifier|static
name|NextBItr
name|NextEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|succ_end
argument_list|()
return|;
block|}
specifier|static
name|StmtItr
name|StmtBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|begin
argument_list|()
return|;
block|}
specifier|static
name|StmtItr
name|StmtEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|end
argument_list|()
return|;
block|}
specifier|static
name|BlockEdge
name|PrevEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Prev
parameter_list|)
block|{
return|return
name|BlockEdge
argument_list|(
name|Prev
argument_list|,
name|B
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|BlockEdge
name|NextEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Next
parameter_list|)
block|{
return|return
name|BlockEdge
argument_list|(
name|B
argument_list|,
name|Next
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|ItrTraits
operator|<
name|backward_analysis_tag
operator|>
block|{
typedef|typedef
name|CFGBlock
operator|::
name|const_succ_iterator
name|PrevBItr
expr_stmt|;
typedef|typedef
name|CFGBlock
operator|::
name|const_pred_iterator
name|NextBItr
expr_stmt|;
typedef|typedef
name|CFGBlock
operator|::
name|const_reverse_iterator
name|StmtItr
expr_stmt|;
specifier|static
name|PrevBItr
name|PrevBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|succ_begin
argument_list|()
return|;
block|}
specifier|static
name|PrevBItr
name|PrevEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|succ_end
argument_list|()
return|;
block|}
specifier|static
name|NextBItr
name|NextBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|pred_begin
argument_list|()
return|;
block|}
specifier|static
name|NextBItr
name|NextEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|pred_end
argument_list|()
return|;
block|}
specifier|static
name|StmtItr
name|StmtBegin
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|rbegin
argument_list|()
return|;
block|}
specifier|static
name|StmtItr
name|StmtEnd
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
return|return
name|B
operator|->
name|rend
argument_list|()
return|;
block|}
specifier|static
name|BlockEdge
name|PrevEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Prev
parameter_list|)
block|{
return|return
name|BlockEdge
argument_list|(
name|B
argument_list|,
name|Prev
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|BlockEdge
name|NextEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Next
parameter_list|)
block|{
return|return
name|BlockEdge
argument_list|(
name|Next
argument_list|,
name|B
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace dataflow
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// DataflowSolverTy - Generic dataflow solver.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_DFValuesTy
operator|,
comment|// Usually a subclass of DataflowValues
name|typename
name|_TransferFuncsTy
operator|,
name|typename
name|_MergeOperatorTy
operator|,
name|typename
name|_Equal
operator|=
name|std
operator|::
name|equal_to
operator|<
name|typename
name|_DFValuesTy
operator|::
name|ValTy
operator|>
expr|>
name|class
name|DataflowSolver
block|{
comment|//===----------------------------------------------------===//
comment|// Type declarations.
comment|//===----------------------------------------------------===//
name|public
operator|:
typedef|typedef
name|_DFValuesTy
name|DFValuesTy
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_TransferFuncsTy
name|TransferFuncsTy
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_MergeOperatorTy
name|MergeOperatorTy
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_DFValuesTy
operator|::
name|AnalysisDirTag
name|AnalysisDirTag
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_DFValuesTy
operator|::
name|ValTy
name|ValTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_DFValuesTy
operator|::
name|EdgeDataMapTy
name|EdgeDataMapTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_DFValuesTy
operator|::
name|BlockDataMapTy
name|BlockDataMapTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|dataflow
operator|::
name|ItrTraits
operator|<
name|AnalysisDirTag
operator|>
name|ItrTraits
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ItrTraits
operator|::
name|NextBItr
name|NextBItr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ItrTraits
operator|::
name|PrevBItr
name|PrevBItr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ItrTraits
operator|::
name|StmtItr
name|StmtItr
expr_stmt|;
end_typedef

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// External interface: constructing and running the solver.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|DataflowSolver
argument_list|(
name|DFValuesTy
operator|&
name|d
argument_list|)
operator|:
name|D
argument_list|(
name|d
argument_list|)
operator|,
name|TF
argument_list|(
argument|d.getAnalysisData()
argument_list|)
block|{}
operator|~
name|DataflowSolver
argument_list|()
block|{}
comment|/// runOnCFG - Computes dataflow values for all blocks in a CFG.
name|void
name|runOnCFG
argument_list|(
argument|CFG& cfg
argument_list|,
argument|bool recordStmtValues = false
argument_list|)
block|{
comment|// Set initial dataflow values and boundary conditions.
name|D
operator|.
name|InitializeValues
argument_list|(
name|cfg
argument_list|)
block|;
comment|// Solve the dataflow equations.  This will populate D.EdgeDataMap
comment|// with dataflow values.
name|SolveDataflowEquations
argument_list|(
name|cfg
argument_list|,
name|recordStmtValues
argument_list|)
block|;   }
comment|/// runOnBlock - Computes dataflow values for a given block.  This
comment|///  should usually be invoked only after previously computing
comment|///  dataflow values using runOnCFG, as runOnBlock is intended to
comment|///  only be used for querying the dataflow values within a block
comment|///  with and Observer object.
name|void
name|runOnBlock
argument_list|(
argument|const CFGBlock* B
argument_list|,
argument|bool recordStmtValues
argument_list|)
block|{
name|BlockDataMapTy
operator|&
name|M
operator|=
name|D
operator|.
name|getBlockDataMap
argument_list|()
block|;
name|typename
name|BlockDataMapTy
operator|::
name|iterator
name|I
operator|=
name|M
operator|.
name|find
argument_list|(
name|B
argument_list|)
block|;
if|if
condition|(
name|I
operator|!=
name|M
operator|.
name|end
argument_list|()
condition|)
block|{
name|TF
operator|.
name|getVal
argument_list|()
operator|.
name|copyValues
argument_list|(
name|I
operator|->
name|second
argument_list|)
expr_stmt|;
name|ProcessBlock
argument_list|(
name|B
argument_list|,
name|recordStmtValues
argument_list|,
name|AnalysisDirTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}    void
name|runOnBlock
argument_list|(
argument|const CFGBlock& B
argument_list|,
argument|bool recordStmtValues
argument_list|)
end_macro

begin_block
block|{
name|runOnBlock
argument_list|(
operator|&
name|B
argument_list|,
name|recordStmtValues
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|runOnBlock
argument_list|(
name|CFG
operator|::
name|iterator
operator|&
name|I
argument_list|,
name|bool
name|recordStmtValues
argument_list|)
block|{
name|runOnBlock
argument_list|(
operator|*
name|I
argument_list|,
name|recordStmtValues
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|runOnBlock
argument_list|(
name|CFG
operator|::
name|const_iterator
operator|&
name|I
argument_list|,
name|bool
name|recordStmtValues
argument_list|)
block|{
name|runOnBlock
argument_list|(
operator|*
name|I
argument_list|,
name|recordStmtValues
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|runOnAllBlocks
parameter_list|(
specifier|const
name|CFG
modifier|&
name|cfg
parameter_list|,
name|bool
name|recordStmtValues
init|=
name|false
parameter_list|)
block|{
for|for
control|(
name|CFG
operator|::
name|const_iterator
name|I
operator|=
name|cfg
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|cfg
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|runOnBlock
argument_list|(
name|I
argument_list|,
name|recordStmtValues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_comment
comment|// Internal solver logic.
end_comment

begin_comment
comment|//===----------------------------------------------------===//
end_comment

begin_label
name|private
label|:
end_label

begin_comment
comment|/// SolveDataflowEquations - Perform the actual worklist algorithm
end_comment

begin_comment
comment|///  to compute dataflow values.
end_comment

begin_function
name|void
name|SolveDataflowEquations
parameter_list|(
name|CFG
modifier|&
name|cfg
parameter_list|,
name|bool
name|recordStmtValues
parameter_list|)
block|{
name|EnqueueBlocksOnWorklist
argument_list|(
name|cfg
argument_list|,
name|AnalysisDirTag
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|WorkList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|CFGBlock
modifier|*
name|B
init|=
name|WorkList
operator|.
name|dequeue
argument_list|()
decl_stmt|;
name|ProcessMerge
argument_list|(
name|cfg
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|ProcessBlock
argument_list|(
name|B
argument_list|,
name|recordStmtValues
argument_list|,
name|AnalysisDirTag
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateEdges
argument_list|(
name|cfg
argument_list|,
name|B
argument_list|,
name|TF
operator|.
name|getVal
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|EnqueueBlocksOnWorklist
argument_list|(
name|CFG
operator|&
name|cfg
argument_list|,
name|dataflow
operator|::
name|forward_analysis_tag
argument_list|)
block|{
comment|// Enqueue all blocks to ensure the dataflow values are computed
comment|// for every block.  Not all blocks are guaranteed to reach the exit block.
for|for
control|(
name|CFG
operator|::
name|iterator
name|I
operator|=
name|cfg
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|cfg
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|WorkList
operator|.
name|enqueue
argument_list|(
operator|&
operator|*
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|EnqueueBlocksOnWorklist
argument_list|(
name|CFG
operator|&
name|cfg
argument_list|,
name|dataflow
operator|::
name|backward_analysis_tag
argument_list|)
block|{
comment|// Enqueue all blocks to ensure the dataflow values are computed
comment|// for every block.  Not all blocks are guaranteed to reach the exit block.
comment|// Enqueue in reverse order since that will more likely match with
comment|// the order they should ideally processed by the dataflow algorithm.
for|for
control|(
name|CFG
operator|::
name|reverse_iterator
name|I
operator|=
name|cfg
operator|.
name|rbegin
argument_list|()
operator|,
name|E
operator|=
name|cfg
operator|.
name|rend
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|WorkList
operator|.
name|enqueue
argument_list|(
operator|&
operator|*
operator|*
name|I
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|ProcessMerge
parameter_list|(
name|CFG
modifier|&
name|cfg
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{
name|ValTy
modifier|&
name|V
init|=
name|TF
operator|.
name|getVal
argument_list|()
decl_stmt|;
name|TF
operator|.
name|SetTopValue
argument_list|(
name|V
argument_list|)
expr_stmt|;
comment|// Merge dataflow values from all predecessors of this block.
name|MergeOperatorTy
name|Merge
decl_stmt|;
name|EdgeDataMapTy
modifier|&
name|M
init|=
name|D
operator|.
name|getEdgeDataMap
argument_list|()
decl_stmt|;
name|bool
name|firstMerge
init|=
name|true
decl_stmt|;
for|for
control|(
name|PrevBItr
name|I
init|=
name|ItrTraits
operator|::
name|PrevBegin
argument_list|(
name|B
argument_list|)
init|,
name|E
init|=
name|ItrTraits
operator|::
name|PrevEnd
argument_list|(
name|B
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|CFGBlock
modifier|*
name|PrevBlk
init|=
operator|*
name|I
decl_stmt|;
if|if
condition|(
operator|!
name|PrevBlk
condition|)
continue|continue;
name|typename
name|EdgeDataMapTy
operator|::
name|iterator
name|EI
operator|=
name|M
operator|.
name|find
argument_list|(
name|ItrTraits
operator|::
name|PrevEdge
argument_list|(
name|B
argument_list|,
name|PrevBlk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EI
operator|!=
name|M
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|firstMerge
condition|)
block|{
name|firstMerge
operator|=
name|false
expr_stmt|;
name|V
operator|.
name|copyValues
argument_list|(
name|EI
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
else|else
name|Merge
argument_list|(
name|V
argument_list|,
name|EI
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set the data for the block.
name|D
operator|.
name|getBlockDataMap
argument_list|()
index|[
name|B
index|]
operator|.
name|copyValues
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// ProcessBlock - Process the transfer functions for a given block.
end_comment

begin_decl_stmt
name|void
name|ProcessBlock
argument_list|(
specifier|const
name|CFGBlock
operator|*
name|B
argument_list|,
name|bool
name|recordStmtValues
argument_list|,
name|dataflow
operator|::
name|forward_analysis_tag
argument_list|)
block|{
for|for
control|(
name|StmtItr
name|I
init|=
name|ItrTraits
operator|::
name|StmtBegin
argument_list|(
name|B
argument_list|)
init|,
name|E
init|=
name|ItrTraits
operator|::
name|StmtEnd
argument_list|(
name|B
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|ProcessStmt
argument_list|(
operator|*
name|I
argument_list|,
name|recordStmtValues
argument_list|,
name|AnalysisDirTag
argument_list|()
argument_list|)
expr_stmt|;
name|TF
operator|.
name|VisitTerminator
argument_list|(
name|const_cast
operator|<
name|CFGBlock
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|ProcessBlock
argument_list|(
specifier|const
name|CFGBlock
operator|*
name|B
argument_list|,
name|bool
name|recordStmtValues
argument_list|,
name|dataflow
operator|::
name|backward_analysis_tag
argument_list|)
block|{
name|TF
operator|.
name|VisitTerminator
argument_list|(
name|const_cast
operator|<
name|CFGBlock
operator|*
operator|>
operator|(
name|B
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|StmtItr
name|I
init|=
name|ItrTraits
operator|::
name|StmtBegin
argument_list|(
name|B
argument_list|)
init|,
name|E
init|=
name|ItrTraits
operator|::
name|StmtEnd
argument_list|(
name|B
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|ProcessStmt
argument_list|(
operator|*
name|I
argument_list|,
name|recordStmtValues
argument_list|,
name|AnalysisDirTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|ProcessStmt
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
name|bool
name|record
argument_list|,
name|dataflow
operator|::
name|forward_analysis_tag
argument_list|)
block|{
if|if
condition|(
name|record
condition|)
name|D
operator|.
name|getStmtDataMap
argument_list|()
index|[
name|S
index|]
operator|=
name|TF
operator|.
name|getVal
argument_list|()
expr_stmt|;
name|TF
operator|.
name|BlockStmt_Visit
argument_list|(
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|S
operator|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|ProcessStmt
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
name|bool
name|record
argument_list|,
name|dataflow
operator|::
name|backward_analysis_tag
argument_list|)
block|{
name|TF
operator|.
name|BlockStmt_Visit
argument_list|(
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|S
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
condition|)
name|D
operator|.
name|getStmtDataMap
argument_list|()
index|[
name|S
index|]
operator|=
name|TF
operator|.
name|getVal
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// UpdateEdges - After processing the transfer functions for a
end_comment

begin_comment
comment|///   block, update the dataflow value associated with the block's
end_comment

begin_comment
comment|///   outgoing/incoming edges (depending on whether we do a
end_comment

begin_comment
comment|//    forward/backward analysis respectively)
end_comment

begin_function
name|void
name|UpdateEdges
parameter_list|(
name|CFG
modifier|&
name|cfg
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|,
name|ValTy
modifier|&
name|V
parameter_list|)
block|{
for|for
control|(
name|NextBItr
name|I
init|=
name|ItrTraits
operator|::
name|NextBegin
argument_list|(
name|B
argument_list|)
init|,
name|E
init|=
name|ItrTraits
operator|::
name|NextEnd
argument_list|(
name|B
argument_list|)
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|CFGBlock
modifier|*
name|NextBlk
init|=
operator|*
name|I
condition|)
name|UpdateEdgeValue
argument_list|(
name|ItrTraits
operator|::
name|NextEdge
argument_list|(
name|B
argument_list|,
name|NextBlk
argument_list|)
argument_list|,
name|V
argument_list|,
name|NextBlk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// UpdateEdgeValue - Update the value associated with a given edge.
end_comment

begin_function
name|void
name|UpdateEdgeValue
parameter_list|(
name|BlockEdge
name|E
parameter_list|,
name|ValTy
modifier|&
name|V
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|TargetBlock
parameter_list|)
block|{
name|EdgeDataMapTy
modifier|&
name|M
init|=
name|D
operator|.
name|getEdgeDataMap
argument_list|()
decl_stmt|;
name|typename
name|EdgeDataMapTy
operator|::
name|iterator
name|I
operator|=
name|M
operator|.
name|find
argument_list|(
name|E
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|M
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// First computed value for this edge?
name|M
index|[
name|E
index|]
operator|.
name|copyValues
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|WorkList
operator|.
name|enqueue
argument_list|(
name|TargetBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|_Equal
argument_list|()
argument_list|(
name|V
argument_list|,
name|I
operator|->
name|second
argument_list|)
condition|)
block|{
name|I
operator|->
name|second
operator|.
name|copyValues
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|WorkList
operator|.
name|enqueue
argument_list|(
name|TargetBlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|DFValuesTy
modifier|&
name|D
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DataflowWorkListTy
name|WorkList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TransferFuncsTy
name|TF
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

