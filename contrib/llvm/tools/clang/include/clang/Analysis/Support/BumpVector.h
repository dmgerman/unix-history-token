begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- BumpVector.h - Vector-like ADT that uses bump allocation --*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file provides BumpVector, a vector-like ADT whose contents are
end_comment

begin_comment
comment|//  allocated from a BumpPtrAllocator.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// FIXME: Most of this is copy-and-paste from SmallVector.h.  We can
end_comment

begin_comment
comment|// refactor this core logic into something common that is shared between
end_comment

begin_comment
comment|// the two.  The main thing that is different is the allocation strategy.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_BUMP_VECTOR
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_BUMP_VECTOR
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/type_traits.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|BumpVectorContext
block|{
name|llvm
operator|::
name|PointerIntPair
operator|<
name|llvm
operator|::
name|BumpPtrAllocator
operator|*
operator|,
literal|1
operator|>
name|Alloc
expr_stmt|;
name|public
label|:
comment|/// Construct a new BumpVectorContext that creates a new BumpPtrAllocator
comment|/// and destroys it when the BumpVectorContext object is destroyed.
name|BumpVectorContext
argument_list|()
operator|:
name|Alloc
argument_list|(
argument|new llvm::BumpPtrAllocator()
argument_list|,
literal|1
argument_list|)
block|{}
comment|/// Construct a new BumpVectorContext that reuses an existing
comment|/// BumpPtrAllocator.  This BumpPtrAllocator is not destroyed when the
comment|/// BumpVectorContext object is destroyed.
name|BumpVectorContext
argument_list|(
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|A
argument_list|)
operator|:
name|Alloc
argument_list|(
argument|&A
argument_list|,
literal|0
argument_list|)
block|{}
operator|~
name|BumpVectorContext
argument_list|()
block|{
if|if
condition|(
name|Alloc
operator|.
name|getInt
argument_list|()
condition|)
name|delete
name|Alloc
operator|.
name|getPointer
parameter_list|()
function_decl|;
block|}
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|getAllocator
argument_list|()
block|{
return|return
operator|*
name|Alloc
operator|.
name|getPointer
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|BumpVector
block|{
name|T
operator|*
name|Begin
block|,
operator|*
name|End
block|,
operator|*
name|Capacity
block|;
name|public
operator|:
comment|// Default ctor - Initialize to empty.
name|explicit
name|BumpVector
argument_list|(
argument|BumpVectorContext&C
argument_list|,
argument|unsigned N
argument_list|)
operator|:
name|Begin
argument_list|(
name|NULL
argument_list|)
block|,
name|End
argument_list|(
name|NULL
argument_list|)
block|,
name|Capacity
argument_list|(
argument|NULL
argument_list|)
block|{
name|reserve
argument_list|(
name|C
argument_list|,
name|N
argument_list|)
block|;   }
operator|~
name|BumpVector
argument_list|()
block|{
if|if
condition|(
name|llvm
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
comment|// Destroy the constructed elements in the vector.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
block|}
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|T
modifier|*
name|iterator
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_iterator
typedef|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
typedef|typedef
name|T
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|T
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|T
modifier|*
name|pointer
typedef|;
typedef|typedef
specifier|const
name|T
modifier|*
name|const_pointer
typedef|;
comment|// forward iterator creation methods.
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Begin
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|Begin
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|End
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|End
return|;
block|}
comment|// reverse iterator creation methods.
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Begin
operator|==
name|End
return|;
block|}
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|End
operator|-
name|Begin
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|unsigned
name|idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|const_reference
name|operator
index|[]
argument_list|(
name|unsigned
name|idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Begin
operator|+
name|idx
operator|<
name|End
argument_list|)
expr_stmt|;
return|return
name|Begin
index|[
name|idx
index|]
return|;
block|}
name|reference
name|front
parameter_list|()
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|const_reference
name|front
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
index|[
literal|0
index|]
return|;
block|}
name|reference
name|back
parameter_list|()
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|const_reference
name|back
argument_list|()
specifier|const
block|{
return|return
name|end
argument_list|()
index|[
operator|-
literal|1
index|]
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
operator|--
name|End
expr_stmt|;
name|End
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
name|T
name|pop_back_val
parameter_list|()
block|{
name|T
name|Result
init|=
name|back
argument_list|()
decl_stmt|;
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|llvm
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
name|End
operator|=
name|Begin
expr_stmt|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|pointer
name|data
parameter_list|()
block|{
return|return
name|pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
comment|/// data - Return a pointer to the vector's buffer, even if empty().
name|const_pointer
name|data
argument_list|()
specifier|const
block|{
return|return
name|const_pointer
argument_list|(
name|Begin
argument_list|)
return|;
block|}
name|void
name|push_back
parameter_list|(
name|const_reference
name|Elt
parameter_list|,
name|BumpVectorContext
modifier|&
name|C
parameter_list|)
block|{
if|if
condition|(
name|End
operator|<
name|Capacity
condition|)
block|{
name|Retry
label|:
name|new
argument_list|(
argument|End
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
operator|++
name|End
expr_stmt|;
return|return;
block|}
name|grow
argument_list|(
name|C
argument_list|)
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
comment|/// insert - Insert some number of copies of element into a position. Return
comment|/// iterator to position after last inserted copy.
name|iterator
name|insert
parameter_list|(
name|iterator
name|I
parameter_list|,
name|size_t
name|Cnt
parameter_list|,
name|const_reference
name|E
parameter_list|,
name|BumpVectorContext
modifier|&
name|C
parameter_list|)
block|{
name|assert
argument_list|(
name|I
operator|>=
name|Begin
operator|&&
name|I
operator|<=
name|End
operator|&&
literal|"Iterator out of bounds."
argument_list|)
expr_stmt|;
if|if
condition|(
name|End
operator|+
name|Cnt
operator|<=
name|Capacity
condition|)
block|{
name|Retry
label|:
name|move_range_right
argument_list|(
name|I
argument_list|,
name|End
argument_list|,
name|Cnt
argument_list|)
expr_stmt|;
name|construct_range
argument_list|(
name|I
argument_list|,
name|I
operator|+
name|Cnt
argument_list|,
name|E
argument_list|)
expr_stmt|;
name|End
operator|+=
name|Cnt
expr_stmt|;
return|return
name|I
operator|+
name|Cnt
return|;
block|}
name|ptrdiff_t
name|D
init|=
name|I
operator|-
name|Begin
decl_stmt|;
name|grow
argument_list|(
name|C
argument_list|,
name|size
argument_list|()
operator|+
name|Cnt
argument_list|)
expr_stmt|;
name|I
operator|=
name|Begin
operator|+
name|D
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
name|void
name|reserve
parameter_list|(
name|BumpVectorContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|unsigned
argument_list|(
name|Capacity
operator|-
name|Begin
argument_list|)
operator|<
name|N
condition|)
name|grow
argument_list|(
name|C
argument_list|,
name|N
argument_list|)
expr_stmt|;
block|}
comment|/// capacity - Return the total number of elements in the currently allocated
comment|/// buffer.
name|size_t
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|Capacity
operator|-
name|Begin
return|;
block|}
name|private
label|:
comment|/// grow - double the size of the allocated memory, guaranteeing space for at
comment|/// least one more element or MinSize if specified.
name|void
name|grow
parameter_list|(
name|BumpVectorContext
modifier|&
name|C
parameter_list|,
name|size_type
name|MinSize
init|=
literal|1
parameter_list|)
function_decl|;
name|void
name|construct_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|,
specifier|const
name|T
modifier|&
name|Elt
parameter_list|)
block|{
for|for
control|(
init|;
name|S
operator|!=
name|E
condition|;
operator|++
name|S
control|)
name|new
argument_list|(
argument|S
argument_list|)
name|T
argument_list|(
name|Elt
argument_list|)
expr_stmt|;
block|}
name|void
name|destroy_range
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|)
block|{
while|while
condition|(
name|S
operator|!=
name|E
condition|)
block|{
operator|--
name|E
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|move_range_right
parameter_list|(
name|T
modifier|*
name|S
parameter_list|,
name|T
modifier|*
name|E
parameter_list|,
name|size_t
name|D
parameter_list|)
block|{
for|for
control|(
name|T
modifier|*
name|I
init|=
name|E
operator|+
name|D
operator|-
literal|1
init|,
modifier|*
name|IL
init|=
name|S
operator|+
name|D
operator|-
literal|1
init|;
name|I
operator|!=
name|IL
condition|;
operator|--
name|I
control|)
block|{
operator|--
name|E
expr_stmt|;
name|new
argument_list|(
argument|I
argument_list|)
name|T
argument_list|(
operator|*
name|E
argument_list|)
expr_stmt|;
name|E
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Define this out-of-line to dissuade the C++ compiler from inlining it.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|BumpVector
operator|<
name|T
operator|>
operator|::
name|grow
argument_list|(
argument|BumpVectorContext&C
argument_list|,
argument|size_t MinSize
argument_list|)
block|{
name|size_t
name|CurCapacity
operator|=
name|Capacity
operator|-
name|Begin
block|;
name|size_t
name|CurSize
operator|=
name|size
argument_list|()
block|;
name|size_t
name|NewCapacity
operator|=
literal|2
operator|*
name|CurCapacity
block|;
if|if
condition|(
name|NewCapacity
operator|<
name|MinSize
condition|)
name|NewCapacity
operator|=
name|MinSize
expr_stmt|;
comment|// Allocate the memory from the BumpPtrAllocator.
name|T
operator|*
name|NewElts
operator|=
name|C
operator|.
name|getAllocator
argument_list|()
operator|.
name|template
name|Allocate
operator|<
name|T
operator|>
operator|(
name|NewCapacity
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Copy the elements over.
end_comment

begin_if
if|if
condition|(
name|llvm
operator|::
name|is_class
operator|<
name|T
operator|>
operator|::
name|value
condition|)
block|{
name|std
operator|::
name|uninitialized_copy
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|NewElts
argument_list|)
expr_stmt|;
comment|// Destroy the original elements.
name|destroy_range
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).
name|memcpy
argument_list|(
name|NewElts
argument_list|,
name|Begin
argument_list|,
name|CurSize
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// For now, leak 'Begin'.  We can add it back to a freelist in
end_comment

begin_comment
comment|// BumpVectorContext.
end_comment

begin_expr_stmt
name|Begin
operator|=
name|NewElts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|End
operator|=
name|NewElts
operator|+
name|CurSize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Capacity
operator|=
name|Begin
operator|+
name|NewCapacity
expr_stmt|;
end_expr_stmt

begin_comment
unit|}  }
comment|// end: clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// end: LLVM_CLANG_BUMP_VECTOR
end_comment

end_unit

