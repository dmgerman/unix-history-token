begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ThreadSafetyTIL.h ---------------------------------------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT in the llvm repository for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines a simple Typed Intermediate Language, or TIL, that is used
end_comment

begin_comment
comment|// by the thread safety analysis (See ThreadSafety.cpp).  The TIL is intended
end_comment

begin_comment
comment|// to be largely independent of clang, in the hope that the analysis can be
end_comment

begin_comment
comment|// reused for other non-C++ languages.  All dependencies on clang/llvm should
end_comment

begin_comment
comment|// go in ThreadSafetyUtil.h.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Thread safety analysis works by comparing mutex expressions, e.g.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// class A { Mutex mu; int dat GUARDED_BY(this->mu); }
end_comment

begin_comment
comment|// class B { A a; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// void foo(B* b) {
end_comment

begin_comment
comment|//   (*b).a.mu.lock();     // locks (*b).a.mu
end_comment

begin_comment
comment|//   b->a.dat = 0;         // substitute&b->a for 'this';
end_comment

begin_comment
comment|//                         // requires lock on (&b->a)->mu
end_comment

begin_comment
comment|//   (b->a.mu).unlock();   // unlocks (b->a.mu)
end_comment

begin_comment
comment|// }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// As illustrated by the above example, clang Exprs are not well-suited to
end_comment

begin_comment
comment|// represent mutex expressions directly, since there is no easy way to compare
end_comment

begin_comment
comment|// Exprs for equivalence.  The thread safety analysis thus lowers clang Exprs
end_comment

begin_comment
comment|// into a simple intermediate language (IL).  The IL supports:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// (1) comparisons for semantic equality of expressions
end_comment

begin_comment
comment|// (2) SSA renaming of variables
end_comment

begin_comment
comment|// (3) wildcards and pattern matching over expressions
end_comment

begin_comment
comment|// (4) hash-based expression lookup
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The TIL is currently very experimental, is intended only for use within
end_comment

begin_comment
comment|// the thread safety analysis, and is subject to change without notice.
end_comment

begin_comment
comment|// After the API stabilizes and matures, it may be appropriate to make this
end_comment

begin_comment
comment|// more generally available to other analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_THREAD_SAFETY_TIL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_THREAD_SAFETY_TIL_H
end_define

begin_comment
comment|// All clang include dependencies for this file must be put in
end_comment

begin_comment
comment|// ThreadSafetyUtil.h.
end_comment

begin_include
include|#
directive|include
file|"ThreadSafetyUtil.h"
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|threadSafety
block|{
name|namespace
name|til
block|{
enum|enum
name|TIL_Opcode
block|{
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
value|COP_##X,
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
block|}
enum|;
enum|enum
name|TIL_UnaryOpcode
enum|:
name|unsigned
name|char
block|{
name|UOP_Minus
block|,
comment|//  -
name|UOP_BitNot
block|,
comment|//  ~
name|UOP_LogicNot
comment|//  !
block|}
enum|;
enum|enum
name|TIL_BinaryOpcode
enum|:
name|unsigned
name|char
block|{
name|BOP_Mul
block|,
comment|//  *
name|BOP_Div
block|,
comment|//  /
name|BOP_Rem
block|,
comment|//  %
name|BOP_Add
block|,
comment|//  +
name|BOP_Sub
block|,
comment|//  -
name|BOP_Shl
block|,
comment|//<<
name|BOP_Shr
block|,
comment|//>>
name|BOP_BitAnd
block|,
comment|//&
name|BOP_BitXor
block|,
comment|//  ^
name|BOP_BitOr
block|,
comment|//  |
name|BOP_Eq
block|,
comment|//  ==
name|BOP_Neq
block|,
comment|//  !=
name|BOP_Lt
block|,
comment|//<
name|BOP_Leq
block|,
comment|//<=
name|BOP_LogicAnd
block|,
comment|//&&
name|BOP_LogicOr
comment|//  ||
block|}
enum|;
enum|enum
name|TIL_CastOpcode
enum|:
name|unsigned
name|char
block|{
name|CAST_none
init|=
literal|0
block|,
name|CAST_extendNum
block|,
comment|// extend precision of numeric type
name|CAST_truncNum
block|,
comment|// truncate precision of numeric type
name|CAST_toFloat
block|,
comment|// convert to floating point type
name|CAST_toInt
block|,
comment|// convert to integer type
block|}
enum|;
specifier|const
name|TIL_Opcode
name|COP_Min
init|=
name|COP_Future
decl_stmt|;
specifier|const
name|TIL_Opcode
name|COP_Max
init|=
name|COP_Branch
decl_stmt|;
specifier|const
name|TIL_UnaryOpcode
name|UOP_Min
init|=
name|UOP_Minus
decl_stmt|;
specifier|const
name|TIL_UnaryOpcode
name|UOP_Max
init|=
name|UOP_LogicNot
decl_stmt|;
specifier|const
name|TIL_BinaryOpcode
name|BOP_Min
init|=
name|BOP_Mul
decl_stmt|;
specifier|const
name|TIL_BinaryOpcode
name|BOP_Max
init|=
name|BOP_LogicOr
decl_stmt|;
specifier|const
name|TIL_CastOpcode
name|CAST_Min
init|=
name|CAST_none
decl_stmt|;
specifier|const
name|TIL_CastOpcode
name|CAST_Max
init|=
name|CAST_toInt
decl_stmt|;
name|StringRef
name|getUnaryOpcodeString
parameter_list|(
name|TIL_UnaryOpcode
name|Op
parameter_list|)
function_decl|;
name|StringRef
name|getBinaryOpcodeString
parameter_list|(
name|TIL_BinaryOpcode
name|Op
parameter_list|)
function_decl|;
comment|// ValueTypes are data types that can actually be held in registers.
comment|// All variables and expressions must have a vBNF_Nonealue type.
comment|// Pointer types are further subdivided into the various heap-allocated
comment|// types, such as functions, records, etc.
comment|// Structured types that are passed by value (e.g. complex numbers)
comment|// require special handling; they use BT_ValueRef, and size ST_0.
struct|struct
name|ValueType
block|{
enum|enum
name|BaseType
enum|:
name|unsigned
name|char
block|{
name|BT_Void
init|=
literal|0
block|,
name|BT_Bool
block|,
name|BT_Int
block|,
name|BT_Float
block|,
name|BT_String
block|,
comment|// String literals
name|BT_Pointer
block|,
name|BT_ValueRef
block|}
enum|;
enum|enum
name|SizeType
enum|:
name|unsigned
name|char
block|{
name|ST_0
init|=
literal|0
block|,
name|ST_1
block|,
name|ST_8
block|,
name|ST_16
block|,
name|ST_32
block|,
name|ST_64
block|,
name|ST_128
block|}
enum|;
specifier|inline
specifier|static
name|SizeType
name|getSizeType
parameter_list|(
name|unsigned
name|nbytes
parameter_list|)
function_decl|;
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
specifier|static
name|ValueType
name|getValueType
argument_list|()
expr_stmt|;
name|ValueType
argument_list|(
argument|BaseType B
argument_list|,
argument|SizeType Sz
argument_list|,
argument|bool S
argument_list|,
argument|unsigned char VS
argument_list|)
block|:
name|Base
argument_list|(
name|B
argument_list|)
operator|,
name|Size
argument_list|(
name|Sz
argument_list|)
operator|,
name|Signed
argument_list|(
name|S
argument_list|)
operator|,
name|VectSize
argument_list|(
argument|VS
argument_list|)
block|{ }
name|BaseType
name|Base
expr_stmt|;
name|SizeType
name|Size
decl_stmt|;
name|bool
name|Signed
decl_stmt|;
name|unsigned
name|char
name|VectSize
decl_stmt|;
comment|// 0 for scalar, otherwise num elements in vector
block|}
struct|;
specifier|inline
name|ValueType
operator|::
name|SizeType
name|ValueType
operator|::
name|getSizeType
argument_list|(
argument|unsigned nbytes
argument_list|)
block|{
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
return|return
name|ST_8
return|;
case|case
literal|2
case|:
return|return
name|ST_16
return|;
case|case
literal|4
case|:
return|return
name|ST_32
return|;
case|case
literal|8
case|:
return|return
name|ST_64
return|;
case|case
literal|16
case|:
return|return
name|ST_128
return|;
default|default:
return|return
name|ST_0
return|;
block|}
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Void
argument_list|,
name|ST_0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|bool
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Bool
argument_list|,
name|ST_1
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int8_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint8_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int16_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint16_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int32_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint32_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int64_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint64_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|float
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|double
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|long
name|double
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_128
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|StringRef
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_String
argument_list|,
name|getSizeType
argument_list|(
sizeof|sizeof
argument_list|(
name|StringRef
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|*
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Pointer
argument_list|,
name|getSizeType
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// Base class for AST nodes in the typed intermediate language.
name|class
name|SExpr
block|{
name|public
label|:
name|TIL_Opcode
name|opcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_Opcode
operator|>
operator|(
name|Opcode
operator|)
return|;
block|}
comment|// Subclasses of SExpr must define the following:
comment|//
comment|// This(const This& E, ...) {
comment|//   copy constructor: construct copy of E, with some additional arguments.
comment|// }
comment|//
comment|// template<class V>
comment|// typename V::R_SExpr traverse(V&Vs, typename V::R_Ctx Ctx) {
comment|//   traverse all subexpressions, following the traversal/rewriter interface.
comment|// }
comment|//
comment|// template<class C> typename C::CType compare(CType* E, C& Cmp) {
comment|//   compare all subexpressions, following the comparator interface
comment|// }
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|S
parameter_list|,
name|MemRegionRef
modifier|&
name|R
parameter_list|)
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|S
argument_list|,
name|R
argument_list|)
return|;
block|}
comment|// SExpr objects cannot be deleted.
comment|// This declaration is public to workaround a gcc bug that breaks building
comment|// with REQUIRES_EH=1.
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
argument_list|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
name|protected
label|:
name|SExpr
argument_list|(
argument|TIL_Opcode Op
argument_list|)
block|:
name|Opcode
argument_list|(
name|Op
argument_list|)
operator|,
name|Reserved
argument_list|(
literal|0
argument_list|)
operator|,
name|Flags
argument_list|(
literal|0
argument_list|)
block|{}
name|SExpr
argument_list|(
specifier|const
name|SExpr
operator|&
name|E
argument_list|)
operator|:
name|Opcode
argument_list|(
name|E
operator|.
name|Opcode
argument_list|)
operator|,
name|Reserved
argument_list|(
literal|0
argument_list|)
operator|,
name|Flags
argument_list|(
argument|E.Flags
argument_list|)
block|{}
specifier|const
name|unsigned
name|char
name|Opcode
expr_stmt|;
name|unsigned
name|char
name|Reserved
decl_stmt|;
name|unsigned
name|short
name|Flags
decl_stmt|;
name|private
label|:
name|SExpr
argument_list|()
name|LLVM_DELETED_FUNCTION
expr_stmt|;
comment|// SExpr objects must be created in an arena.
name|void
modifier|*
name|operator
name|new
argument_list|(
name|size_t
argument_list|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
block|}
empty_stmt|;
comment|// Class for owning references to SExprs.
comment|// Includes attach/detach logic for counting variable references and lazy
comment|// rewriting strategies.
name|class
name|SExprRef
block|{
name|public
label|:
name|SExprRef
argument_list|()
operator|:
name|Ptr
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SExprRef
argument_list|(
argument|std::nullptr_t P
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SExprRef
argument_list|(
name|SExprRef
operator|&&
name|R
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|R.Ptr
argument_list|)
block|{
name|R
operator|.
name|Ptr
operator|=
name|nullptr
block|; }
comment|// Defined after Variable and Future, below.
specifier|inline
name|SExprRef
argument_list|(
name|SExpr
operator|*
name|P
argument_list|)
expr_stmt|;
specifier|inline
operator|~
name|SExprRef
argument_list|()
expr_stmt|;
name|SExpr
modifier|*
name|get
parameter_list|()
block|{
return|return
name|Ptr
return|;
block|}
specifier|const
name|SExpr
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
name|SExpr
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|SExpr
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|Ptr
return|;
block|}
specifier|const
name|SExpr
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|Ptr
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SExprRef
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|==
name|R
operator|.
name|Ptr
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SExprRef
operator|&
name|R
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|R
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|SExpr
operator|*
name|P
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|==
name|P
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|SExpr
operator|*
name|P
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|P
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|std
operator|::
name|nullptr_t
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|==
name|nullptr
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|std
operator|::
name|nullptr_t
operator|)
specifier|const
block|{
return|return
name|Ptr
operator|!=
name|nullptr
return|;
block|}
specifier|inline
name|void
name|reset
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|)
function_decl|;
name|private
label|:
specifier|inline
name|void
name|attach
parameter_list|()
function_decl|;
specifier|inline
name|void
name|detach
parameter_list|()
function_decl|;
name|SExpr
modifier|*
name|Ptr
decl_stmt|;
block|}
empty_stmt|;
comment|// Contains various helper functions for SExprs.
name|namespace
name|ThreadSafetyTIL
block|{
specifier|inline
name|bool
name|isTrivial
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
name|unsigned
name|Op
init|=
name|E
operator|->
name|opcode
argument_list|()
decl_stmt|;
return|return
name|Op
operator|==
name|COP_Variable
operator|||
name|Op
operator|==
name|COP_Literal
operator|||
name|Op
operator|==
name|COP_LiteralPtr
return|;
block|}
block|}
comment|// Nodes which declare variables
name|class
name|Function
decl_stmt|;
name|class
name|SFunction
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Let
decl_stmt|;
comment|// A named variable, e.g. "x".
comment|//
comment|// There are two distinct places in which a Variable can appear in the AST.
comment|// A variable declaration introduces a new variable, and can occur in 3 places:
comment|//   Let-expressions:           (Let (x = t) u)
comment|//   Functions:                 (Function (x : t) u)
comment|//   Self-applicable functions  (SFunction (x) t)
comment|//
comment|// If a variable occurs in any other location, it is a reference to an existing
comment|// variable declaration -- e.g. 'x' in (x * y + z). To save space, we don't
comment|// allocate a separate AST node for variable references; a reference is just a
comment|// pointer to the original declaration.
name|class
name|Variable
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Variable
return|;
block|}
comment|// Let-variable, function parameter, or self-variable
expr|enum
name|VariableKind
block|{
name|VK_Let
block|,
name|VK_LetBB
block|,
name|VK_Fun
block|,
name|VK_SFun
block|}
block|;
comment|// These are defined after SExprRef contructor, below
specifier|inline
name|Variable
argument_list|(
name|SExpr
operator|*
name|D
argument_list|,
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
operator|=
name|nullptr
argument_list|)
block|;
specifier|inline
name|Variable
argument_list|(
argument|StringRef s
argument_list|,
argument|SExpr *D = nullptr
argument_list|)
block|;
specifier|inline
name|Variable
argument_list|(
specifier|const
name|Variable
operator|&
name|Vd
argument_list|,
name|SExpr
operator|*
name|D
argument_list|)
block|;
name|VariableKind
name|kind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|VariableKind
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
specifier|const
name|StringRef
name|name
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
comment|// Returns the definition (for let vars) or type (for parameter& self vars)
name|SExpr
operator|*
name|definition
argument_list|()
block|{
return|return
name|Definition
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|definition
argument_list|()
specifier|const
block|{
return|return
name|Definition
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|attachVar
argument_list|()
specifier|const
block|{
operator|++
name|NumUses
block|; }
name|void
name|detachVar
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|NumUses
operator|>
literal|0
argument_list|)
block|;
operator|--
name|NumUses
block|; }
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|Id
return|;
block|}
name|unsigned
name|getBlockID
argument_list|()
specifier|const
block|{
return|return
name|BlockID
return|;
block|}
name|void
name|setName
argument_list|(
argument|StringRef S
argument_list|)
block|{
name|Name
operator|=
name|S
block|; }
name|void
name|setID
argument_list|(
argument|unsigned Bid
argument_list|,
argument|unsigned I
argument_list|)
block|{
name|BlockID
operator|=
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
name|Bid
operator|)
block|;
name|Id
operator|=
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
name|I
operator|)
block|;   }
name|void
name|setClangDecl
argument_list|(
argument|const clang::ValueDecl *VD
argument_list|)
block|{
name|Cvdecl
operator|=
name|VD
block|; }
name|void
name|setDefinition
argument_list|(
name|SExpr
operator|*
name|E
argument_list|)
block|;
name|void
name|setKind
argument_list|(
argument|VariableKind K
argument_list|)
block|{
name|Flags
operator|=
name|K
block|; }
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This routine is only called for variable references.
return|return
name|Vs
operator|.
name|reduceVariableRef
argument_list|(
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Variable* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|compareVariableRefs
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|friend
name|class
name|Function
block|;
name|friend
name|class
name|SFunction
block|;
name|friend
name|class
name|BasicBlock
block|;
name|friend
name|class
name|Let
block|;
name|StringRef
name|Name
block|;
comment|// The name of the variable.
name|SExprRef
name|Definition
block|;
comment|// The TIL type or definition
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
block|;
comment|// The clang declaration for this variable.
name|unsigned
name|short
name|BlockID
block|;
name|unsigned
name|short
name|Id
block|;
name|mutable
name|unsigned
name|NumUses
block|; }
decl_stmt|;
comment|// Placeholder for an expression that has not yet been created.
comment|// Used to implement lazy copy and rewriting strategies.
name|class
name|Future
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Future
return|;
block|}
expr|enum
name|FutureStatus
block|{
name|FS_pending
block|,
name|FS_evaluating
block|,
name|FS_done
block|}
block|;
name|Future
argument_list|()
operator|:
name|SExpr
argument_list|(
name|COP_Future
argument_list|)
block|,
name|Status
argument_list|(
name|FS_pending
argument_list|)
block|,
name|Result
argument_list|(
name|nullptr
argument_list|)
block|,
name|Location
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|private
operator|:
name|virtual
operator|~
name|Future
argument_list|()
name|LLVM_DELETED_FUNCTION
block|;
name|public
operator|:
comment|// Registers the location in the AST where this future is stored.
comment|// Forcing the future will automatically update the AST.
specifier|static
specifier|inline
name|void
name|registerLocation
argument_list|(
argument|SExprRef *Member
argument_list|)
block|{
if|if
condition|(
name|Future
modifier|*
name|F
init|=
name|dyn_cast_or_null
operator|<
name|Future
operator|>
operator|(
name|Member
operator|->
name|get
argument_list|()
operator|)
condition|)
name|F
operator|->
name|Location
operator|=
name|Member
expr_stmt|;
block|}
comment|// A lazy rewriting strategy should subclass Future and override this method.
name|virtual
name|SExpr
operator|*
name|create
argument_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|// Return the result of this future if it exists, otherwise return null.
name|SExpr
operator|*
name|maybeGetResult
argument_list|()
block|{
return|return
name|Result
return|;
block|}
comment|// Return the result of this future; forcing it if necessary.
name|SExpr
operator|*
name|result
argument_list|()
block|{
switch|switch
condition|(
name|Status
condition|)
block|{
case|case
name|FS_pending
case|:
name|force
argument_list|()
expr_stmt|;
return|return
name|Result
return|;
case|case
name|FS_evaluating
case|:
return|return
name|nullptr
return|;
comment|// infinite loop; illegal recursion.
case|case
name|FS_done
case|:
return|return
name|Result
return|;
block|}
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|assert
argument_list|(
name|Result
operator|&&
literal|"Cannot traverse Future that has not been forced."
argument_list|)
block|;
return|return
name|Vs
operator|.
name|traverse
argument_list|(
name|Result
argument_list|,
name|Ctx
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Future* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
if|if
condition|(
operator|!
name|Result
operator|||
operator|!
name|E
operator|->
name|Result
condition|)
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|Result
argument_list|,
name|E
operator|->
name|Result
argument_list|)
return|;
block|}
name|private
label|:
comment|// Force the future.
specifier|inline
name|void
name|force
parameter_list|()
function_decl|;
name|FutureStatus
name|Status
decl_stmt|;
name|SExpr
modifier|*
name|Result
decl_stmt|;
name|SExprRef
modifier|*
name|Location
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|inline
name|void
name|SExprRef
operator|::
name|attach
argument_list|()
block|{
if|if
condition|(
operator|!
name|Ptr
condition|)
return|return;
name|TIL_Opcode
name|Op
operator|=
name|Ptr
operator|->
name|opcode
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Op
operator|==
name|COP_Variable
condition|)
block|{
name|cast
operator|<
name|Variable
operator|>
operator|(
name|Ptr
operator|)
operator|->
name|attachVar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Op
operator|==
name|COP_Future
condition|)
block|{
name|cast
operator|<
name|Future
operator|>
operator|(
name|Ptr
operator|)
operator|->
name|registerLocation
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  inline
name|void
name|SExprRef
operator|::
name|detach
argument_list|()
block|{
if|if
condition|(
name|Ptr
operator|&&
name|Ptr
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Variable
condition|)
block|{
name|cast
operator|<
name|Variable
operator|>
operator|(
name|Ptr
operator|)
operator|->
name|detachVar
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  inline
name|SExprRef
operator|::
name|SExprRef
argument_list|(
name|SExpr
operator|*
name|P
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|P
argument_list|)
block|{
name|attach
argument_list|()
block|; }
specifier|inline
name|SExprRef
operator|::
operator|~
name|SExprRef
argument_list|()
block|{
name|detach
argument_list|()
block|; }
specifier|inline
name|void
name|SExprRef
operator|::
name|reset
argument_list|(
argument|SExpr *P
argument_list|)
block|{
name|detach
argument_list|()
block|;
name|Ptr
operator|=
name|P
block|;
name|attach
argument_list|()
block|; }
specifier|inline
name|Variable
operator|::
name|Variable
argument_list|(
argument|StringRef s
argument_list|,
argument|SExpr *D
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Variable
argument_list|)
operator|,
name|Name
argument_list|(
name|s
argument_list|)
operator|,
name|Definition
argument_list|(
name|D
argument_list|)
operator|,
name|Cvdecl
argument_list|(
name|nullptr
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Id
argument_list|(
literal|0
argument_list|)
operator|,
name|NumUses
argument_list|(
literal|0
argument_list|)
block|{
name|Flags
operator|=
name|VK_Let
block|; }
specifier|inline
name|Variable
operator|::
name|Variable
argument_list|(
name|SExpr
operator|*
name|D
argument_list|,
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Variable
argument_list|)
operator|,
name|Name
argument_list|(
name|Cvd
condition|?
name|Cvd
operator|->
name|getName
argument_list|()
else|:
literal|"_x"
argument_list|)
operator|,
name|Definition
argument_list|(
name|D
argument_list|)
operator|,
name|Cvdecl
argument_list|(
name|Cvd
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Id
argument_list|(
literal|0
argument_list|)
operator|,
name|NumUses
argument_list|(
literal|0
argument_list|)
block|{
name|Flags
operator|=
name|VK_Let
block|; }
specifier|inline
name|Variable
operator|::
name|Variable
argument_list|(
specifier|const
name|Variable
operator|&
name|Vd
argument_list|,
name|SExpr
operator|*
name|D
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|Vd
argument_list|)
operator|,
name|Name
argument_list|(
name|Vd
operator|.
name|Name
argument_list|)
operator|,
name|Definition
argument_list|(
name|D
argument_list|)
operator|,
name|Cvdecl
argument_list|(
name|Vd
operator|.
name|Cvdecl
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Id
argument_list|(
literal|0
argument_list|)
operator|,
name|NumUses
argument_list|(
literal|0
argument_list|)
block|{
name|Flags
operator|=
name|Vd
operator|.
name|kind
argument_list|()
block|; }
specifier|inline
name|void
name|Variable
operator|::
name|setDefinition
argument_list|(
argument|SExpr *E
argument_list|)
block|{
name|Definition
operator|.
name|reset
argument_list|(
name|E
argument_list|)
block|; }
name|void
name|Future
operator|::
name|force
argument_list|()
block|{
name|Status
operator|=
name|FS_evaluating
block|;
name|SExpr
operator|*
name|R
operator|=
name|create
argument_list|()
block|;
name|Result
operator|=
name|R
block|;
if|if
condition|(
name|Location
condition|)
name|Location
operator|->
name|reset
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FS_done
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Placeholder for C++ expressions that cannot be represented in the TIL.
end_comment

begin_label
unit|class
name|Undefined
label|:
end_label

begin_decl_stmt
name|public
name|SExpr
block|{
name|public
label|:
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Undefined
return|;
block|}
name|Undefined
argument_list|(
specifier|const
name|clang
operator|::
name|Stmt
operator|*
name|S
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Undefined
argument_list|)
operator|,
name|Cstmt
argument_list|(
argument|S
argument_list|)
block|{}
name|Undefined
argument_list|(
specifier|const
name|Undefined
operator|&
name|U
argument_list|)
operator|:
name|SExpr
argument_list|(
name|U
argument_list|)
operator|,
name|Cstmt
argument_list|(
argument|U.Cstmt
argument_list|)
block|{}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceUndefined
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Undefined* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cstmt
argument_list|,
name|E
operator|->
name|Cstmt
argument_list|)
return|;
block|}
name|private
label|:
specifier|const
name|clang
operator|::
name|Stmt
operator|*
name|Cstmt
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Placeholder for a wildcard that matches any other expression.
end_comment

begin_decl_stmt
name|class
name|Wildcard
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Wildcard
return|;
block|}
name|Wildcard
argument_list|()
operator|:
name|SExpr
argument_list|(
argument|COP_Wildcard
argument_list|)
block|{}
name|Wildcard
argument_list|(
specifier|const
name|Wildcard
operator|&
name|W
argument_list|)
operator|:
name|SExpr
argument_list|(
argument|W
argument_list|)
block|{}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceWildcard
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Wildcard* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|trueResult
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|T
operator|>
name|class
name|LiteralT
block|;
comment|// Base class for literal values.
name|class
name|Literal
operator|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Literal
return|;
block|}
name|Literal
argument_list|(
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|C
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Literal
argument_list|)
block|,
name|ValType
argument_list|(
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|>
operator|(
operator|)
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|C
argument_list|)
block|{ }
name|Literal
argument_list|(
argument|ValueType VT
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Literal
argument_list|)
block|,
name|ValType
argument_list|(
name|VT
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|Literal
argument_list|(
specifier|const
name|Literal
operator|&
name|L
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|ValType
argument_list|(
name|L
operator|.
name|ValType
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|L.Cexpr
argument_list|)
block|{}
comment|// The clang expression for this literal.
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|clangExpr
argument_list|()
specifier|const
block|{
return|return
name|Cexpr
return|;
block|}
name|ValueType
name|valueType
argument_list|()
specifier|const
block|{
return|return
name|ValType
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|as
argument_list|()
specifier|const
block|{
return|return
operator|*
name|static_cast
operator|<
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|as
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|LiteralT
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|;
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Literal* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
comment|// TODO -- use value, not pointer equality
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cexpr
argument_list|,
name|E
operator|->
name|Cexpr
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|ValueType
name|ValType
block|;
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|Cexpr
block|; }
block|;
comment|// Derived class for literal values, which stores the actual value.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|LiteralT
operator|:
name|public
name|Literal
block|{
name|public
operator|:
name|LiteralT
argument_list|(
argument|T Dat
argument_list|)
operator|:
name|Literal
argument_list|(
name|ValueType
operator|::
name|getValueType
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
block|,
name|Val
argument_list|(
argument|Dat
argument_list|)
block|{ }
name|LiteralT
argument_list|(
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|L
argument_list|)
operator|:
name|Literal
argument_list|(
name|L
argument_list|)
block|,
name|Val
argument_list|(
argument|L.Val
argument_list|)
block|{ }
name|T
name|value
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|T
operator|&
name|value
argument_list|()
block|{
return|return
name|Val
return|;
block|}
name|private
operator|:
name|T
name|Val
block|; }
block|;
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|Literal
operator|::
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
if|if
condition|(
name|Cexpr
condition|)
return|return
name|Vs
operator|.
name|reduceLiteral
argument_list|(
operator|*
name|this
argument_list|)
return|;
switch|switch
condition|(
name|ValType
operator|.
name|Base
condition|)
block|{
case|case
name|ValueType
operator|::
name|BT_Void
case|:
break|break;
case|case
name|ValueType
operator|::
name|BT_Bool
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|bool
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|BT_Int
case|:
block|{
switch|switch
condition|(
name|ValType
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_8
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int8_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint8_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_16
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int16_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint16_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_32
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int32_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint32_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_64
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int64_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint64_t
operator|>
operator|(
operator|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
case|case
name|ValueType
operator|::
name|BT_Float
case|:
block|{
switch|switch
condition|(
name|ValType
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_32
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|float
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_64
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|double
operator|>
operator|(
operator|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
case|case
name|ValueType
operator|::
name|BT_String
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|StringRef
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|BT_Pointer
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|void
operator|*
operator|>
operator|(
operator|)
argument_list|)
return|;
end_decl_stmt

begin_case
case|case
name|ValueType
operator|::
name|BT_ValueRef
case|:
end_case

begin_break
break|break;
end_break

begin_expr_stmt
unit|}   return
name|Vs
operator|.
name|reduceLiteral
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Literal pointer to an object allocated in memory.
end_comment

begin_comment
comment|// At compile time, pointer literals are represented by symbolic names.
end_comment

begin_label
unit|class
name|LiteralPtr
label|:
end_label

begin_decl_stmt
name|public
name|SExpr
block|{
name|public
label|:
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_LiteralPtr
return|;
block|}
name|LiteralPtr
argument_list|(
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|D
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_LiteralPtr
argument_list|)
operator|,
name|Cvdecl
argument_list|(
argument|D
argument_list|)
block|{}
name|LiteralPtr
argument_list|(
specifier|const
name|LiteralPtr
operator|&
name|R
argument_list|)
operator|:
name|SExpr
argument_list|(
name|R
argument_list|)
operator|,
name|Cvdecl
argument_list|(
argument|R.Cvdecl
argument_list|)
block|{}
comment|// The clang declaration for the value that this pointer points to.
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceLiteralPtr
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|LiteralPtr* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cvdecl
argument_list|,
name|E
operator|->
name|Cvdecl
argument_list|)
return|;
block|}
name|private
label|:
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// A function -- a.k.a. lambda abstraction.
end_comment

begin_comment
comment|// Functions with multiple arguments are created by currying,
end_comment

begin_comment
comment|// e.g. (function (x: Int) (function (y: Int) (add x y)))
end_comment

begin_decl_stmt
name|class
name|Function
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Function
return|;
block|}
name|Function
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Function
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Fun
argument_list|)
block|;   }
name|Function
argument_list|(
specifier|const
name|Function
operator|&
name|F
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|F
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Fun
argument_list|)
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This is a variable declaration, so traverse the definition.
name|auto
name|E0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|VarDecl
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
comment|// Tell the rewriter to enter the scope of the function.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|E0
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceFunction
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Function* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|,
name|E
operator|->
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|Variable
modifier|*
name|VarDecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A self-applicable function.
end_comment

begin_comment
comment|// A self-applicable function can be applied to itself.  It's useful for
end_comment

begin_comment
comment|// implementing objects and late binding
end_comment

begin_decl_stmt
name|class
name|SFunction
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SFunction
return|;
block|}
name|SFunction
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_SFunction
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|Vd
operator|->
name|Definition
operator|==
name|nullptr
argument_list|)
block|;
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_SFun
argument_list|)
block|;
name|Vd
operator|->
name|Definition
operator|.
name|reset
argument_list|(
name|this
argument_list|)
block|;   }
name|SFunction
argument_list|(
specifier|const
name|SFunction
operator|&
name|F
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|F
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|Vd
operator|->
name|Definition
operator|==
name|nullptr
argument_list|)
block|;
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_SFun
argument_list|)
block|;
name|Vd
operator|->
name|Definition
operator|.
name|reset
argument_list|(
name|this
argument_list|)
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// A self-variable points to the SFunction itself.
comment|// A rewrite must introduce the variable with a null definition, and update
comment|// it after 'this' has been rewritten.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|nullptr
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
comment|// A rewrite operation will call SFun constructor to set Vvd->Definition.
return|return
name|Vs
operator|.
name|reduceSFunction
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|SFunction* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
name|private
operator|:
name|Variable
operator|*
name|VarDecl
block|;
name|SExprRef
name|Body
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// A block of code -- e.g. the body of a function.
end_comment

begin_decl_stmt
name|class
name|Code
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Code
return|;
block|}
name|Code
argument_list|(
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Code
argument_list|)
block|,
name|ReturnType
argument_list|(
name|T
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|Code
argument_list|(
specifier|const
name|Code
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|ReturnType
argument_list|(
name|T
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|SExpr
operator|*
name|returnType
argument_list|()
block|{
return|return
name|ReturnType
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|returnType
argument_list|()
specifier|const
block|{
return|return
name|ReturnType
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ReturnType
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nb
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|lazyCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCode
argument_list|(
operator|*
name|this
argument_list|,
name|Nt
argument_list|,
name|Nb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Code* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|returnType
argument_list|()
argument_list|,
name|E
operator|->
name|returnType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|ReturnType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A typed, writable location in memory
end_comment

begin_decl_stmt
name|class
name|Field
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Field
return|;
block|}
name|Field
argument_list|(
name|SExpr
operator|*
name|R
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Field
argument_list|)
block|,
name|Range
argument_list|(
name|R
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|Field
argument_list|(
specifier|const
name|Field
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|R
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Range
argument_list|(
name|R
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|SExpr
operator|*
name|range
argument_list|()
block|{
return|return
name|Range
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|range
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nr
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Range
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nb
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|lazyCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceField
argument_list|(
operator|*
name|this
argument_list|,
name|Nr
argument_list|,
name|Nb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Field* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|range
argument_list|()
argument_list|,
name|E
operator|->
name|range
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Apply an argument to a function
end_comment

begin_decl_stmt
name|class
name|Apply
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Apply
return|;
block|}
name|Apply
argument_list|(
name|SExpr
operator|*
name|F
argument_list|,
name|SExpr
operator|*
name|A
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Apply
argument_list|)
block|,
name|Fun
argument_list|(
name|F
argument_list|)
block|,
name|Arg
argument_list|(
argument|A
argument_list|)
block|{}
name|Apply
argument_list|(
specifier|const
name|Apply
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|F
argument_list|,
name|SExpr
operator|*
name|Ar
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Fun
argument_list|(
name|F
argument_list|)
block|,
name|Arg
argument_list|(
argument|Ar
argument_list|)
block|{}
name|SExpr
operator|*
name|fun
argument_list|()
block|{
return|return
name|Fun
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|fun
argument_list|()
specifier|const
block|{
return|return
name|Fun
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|arg
argument_list|()
block|{
return|return
name|Arg
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|arg
argument_list|()
specifier|const
block|{
return|return
name|Arg
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nf
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Fun
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Arg
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceApply
argument_list|(
operator|*
name|this
argument_list|,
name|Nf
argument_list|,
name|Na
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Apply* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|fun
argument_list|()
argument_list|,
name|E
operator|->
name|fun
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|arg
argument_list|()
argument_list|,
name|E
operator|->
name|arg
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Fun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Arg
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Apply a self-argument to a self-applicable function
end_comment

begin_decl_stmt
name|class
name|SApply
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SApply
return|;
block|}
name|SApply
argument_list|(
name|SExpr
operator|*
name|Sf
argument_list|,
name|SExpr
operator|*
name|A
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_SApply
argument_list|)
block|,
name|Sfun
argument_list|(
name|Sf
argument_list|)
block|,
name|Arg
argument_list|(
argument|A
argument_list|)
block|{}
name|SApply
argument_list|(
name|SApply
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|Sf
argument_list|,
name|SExpr
operator|*
name|Ar
operator|=
name|nullptr
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Sfun
argument_list|(
name|Sf
argument_list|)
block|,
name|Arg
argument_list|(
argument|Ar
argument_list|)
block|{}
name|SExpr
operator|*
name|sfun
argument_list|()
block|{
return|return
name|Sfun
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|sfun
argument_list|()
specifier|const
block|{
return|return
name|Sfun
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|arg
argument_list|()
block|{
return|return
name|Arg
operator|.
name|get
argument_list|()
operator|?
name|Arg
operator|.
name|get
argument_list|()
operator|:
name|Sfun
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|arg
argument_list|()
specifier|const
block|{
return|return
name|Arg
operator|.
name|get
argument_list|()
condition|?
name|Arg
operator|.
name|get
argument_list|()
else|:
name|Sfun
operator|.
name|get
argument_list|()
return|;
block|}
name|bool
name|isDelegation
argument_list|()
specifier|const
block|{
return|return
name|Arg
operator|==
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nf
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Sfun
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|typename
name|V
operator|::
name|R_SExpr
name|Na
operator|=
name|Arg
operator|.
name|get
argument_list|()
condition|?
name|Vs
operator|.
name|traverse
argument_list|(
name|Arg
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
else|:
name|nullptr
block|;
return|return
name|Vs
operator|.
name|reduceSApply
argument_list|(
operator|*
name|this
argument_list|,
name|Nf
argument_list|,
name|Na
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|SApply* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|sfun
argument_list|()
argument_list|,
name|E
operator|->
name|sfun
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
operator|||
operator|(
operator|!
name|arg
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|arg
argument_list|()
operator|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|arg
argument_list|()
argument_list|,
name|E
operator|->
name|arg
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Sfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Arg
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Project a named slot from a C++ struct or class.
end_comment

begin_decl_stmt
name|class
name|Project
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Project
return|;
block|}
name|Project
argument_list|(
argument|SExpr *R
argument_list|,
argument|StringRef SName
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Project
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|SName
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|Project
argument_list|(
name|SExpr
operator|*
name|R
argument_list|,
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Project
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|Cvd
operator|->
name|getName
argument_list|()
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|Cvd
argument_list|)
block|{ }
name|Project
argument_list|(
specifier|const
name|Project
operator|&
name|P
argument_list|,
name|SExpr
operator|*
name|R
argument_list|)
operator|:
name|SExpr
argument_list|(
name|P
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|P
operator|.
name|SlotName
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|P.Cvdecl
argument_list|)
block|{ }
name|SExpr
operator|*
name|record
argument_list|()
block|{
return|return
name|Rec
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|record
argument_list|()
specifier|const
block|{
return|return
name|Rec
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangValueDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
name|StringRef
name|slotName
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Cvdecl
condition|)
return|return
name|Cvdecl
operator|->
name|getName
argument_list|()
return|;
else|else
return|return
name|SlotName
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nr
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Rec
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceProject
argument_list|(
operator|*
name|this
argument_list|,
name|Nr
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Project* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|record
argument_list|()
argument_list|,
name|E
operator|->
name|record
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cvdecl
argument_list|,
name|E
operator|->
name|Cvdecl
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Rec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|SlotName
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Call a function (after all arguments have been applied).
end_comment

begin_decl_stmt
name|class
name|Call
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Call
return|;
block|}
name|Call
argument_list|(
name|SExpr
operator|*
name|T
argument_list|,
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|Ce
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Call
argument_list|)
block|,
name|Target
argument_list|(
name|T
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|Ce
argument_list|)
block|{}
name|Call
argument_list|(
specifier|const
name|Call
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|)
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Target
argument_list|(
name|T
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|C.Cexpr
argument_list|)
block|{}
name|SExpr
operator|*
name|target
argument_list|()
block|{
return|return
name|Target
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|target
argument_list|()
specifier|const
block|{
return|return
name|Target
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|clangCallExpr
argument_list|()
specifier|const
block|{
return|return
name|Cexpr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Target
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCall
argument_list|(
operator|*
name|this
argument_list|,
name|Nt
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Call* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|target
argument_list|()
argument_list|,
name|E
operator|->
name|target
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|SExprRef
name|Target
block|;
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|Cexpr
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Allocate memory for a new value on the heap or stack.
end_comment

begin_decl_stmt
name|class
name|Alloc
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Call
return|;
block|}
expr|enum
name|AllocKind
block|{
name|AK_Stack
block|,
name|AK_Heap
block|}
block|;
name|Alloc
argument_list|(
argument|SExpr *D
argument_list|,
argument|AllocKind K
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Alloc
argument_list|)
block|,
name|Dtype
argument_list|(
argument|D
argument_list|)
block|{
name|Flags
operator|=
name|K
block|; }
name|Alloc
argument_list|(
specifier|const
name|Alloc
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|Dt
argument_list|)
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Dtype
argument_list|(
argument|Dt
argument_list|)
block|{
name|Flags
operator|=
name|A
operator|.
name|kind
argument_list|()
block|; }
name|AllocKind
name|kind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|AllocKind
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|dataType
argument_list|()
block|{
return|return
name|Dtype
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|dataType
argument_list|()
specifier|const
block|{
return|return
name|Dtype
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nd
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Dtype
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceAlloc
argument_list|(
operator|*
name|this
argument_list|,
name|Nd
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Alloc* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|kind
argument_list|()
argument_list|,
name|E
operator|->
name|kind
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|dataType
argument_list|()
argument_list|,
name|E
operator|->
name|dataType
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Dtype
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Load a value from memory.
end_comment

begin_decl_stmt
name|class
name|Load
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Load
return|;
block|}
name|Load
argument_list|(
name|SExpr
operator|*
name|P
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Load
argument_list|)
block|,
name|Ptr
argument_list|(
argument|P
argument_list|)
block|{}
name|Load
argument_list|(
specifier|const
name|Load
operator|&
name|L
argument_list|,
name|SExpr
operator|*
name|P
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|Ptr
argument_list|(
argument|P
argument_list|)
block|{}
name|SExpr
operator|*
name|pointer
argument_list|()
block|{
return|return
name|Ptr
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|pointer
argument_list|()
specifier|const
block|{
return|return
name|Ptr
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Np
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Ptr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceLoad
argument_list|(
operator|*
name|this
argument_list|,
name|Np
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Load* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|pointer
argument_list|()
argument_list|,
name|E
operator|->
name|pointer
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|SExprRef
name|Ptr
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Store a value to memory.
end_comment

begin_comment
comment|// Source is a pointer, destination is the value to store.
end_comment

begin_decl_stmt
name|class
name|Store
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Store
return|;
block|}
name|Store
argument_list|(
name|SExpr
operator|*
name|P
argument_list|,
name|SExpr
operator|*
name|V
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Store
argument_list|)
block|,
name|Dest
argument_list|(
name|P
argument_list|)
block|,
name|Source
argument_list|(
argument|V
argument_list|)
block|{}
name|Store
argument_list|(
specifier|const
name|Store
operator|&
name|S
argument_list|,
name|SExpr
operator|*
name|P
argument_list|,
name|SExpr
operator|*
name|V
argument_list|)
operator|:
name|SExpr
argument_list|(
name|S
argument_list|)
block|,
name|Dest
argument_list|(
name|P
argument_list|)
block|,
name|Source
argument_list|(
argument|V
argument_list|)
block|{}
name|SExpr
operator|*
name|destination
argument_list|()
block|{
return|return
name|Dest
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Address to store to
specifier|const
name|SExpr
operator|*
name|destination
argument_list|()
specifier|const
block|{
return|return
name|Dest
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|source
argument_list|()
block|{
return|return
name|Source
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|source
argument_list|()
specifier|const
block|{
return|return
name|Source
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Np
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Dest
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nv
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Source
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceStore
argument_list|(
operator|*
name|this
argument_list|,
name|Np
argument_list|,
name|Nv
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Store* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|destination
argument_list|()
argument_list|,
name|E
operator|->
name|destination
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|source
argument_list|()
argument_list|,
name|E
operator|->
name|source
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Dest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Source
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// If p is a reference to an array, then first(p) is a reference to the first
end_comment

begin_comment
comment|// element.  The usual array notation p[i]  becomes first(p + i).
end_comment

begin_decl_stmt
name|class
name|ArrayIndex
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_ArrayIndex
return|;
block|}
name|ArrayIndex
argument_list|(
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_ArrayIndex
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|ArrayIndex
argument_list|(
specifier|const
name|ArrayIndex
operator|&
name|E
argument_list|,
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|E
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|SExpr
operator|*
name|array
argument_list|()
block|{
return|return
name|Array
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|array
argument_list|()
specifier|const
block|{
return|return
name|Array
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|index
argument_list|()
block|{
return|return
name|Index
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Array
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ni
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Index
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceArrayIndex
argument_list|(
operator|*
name|this
argument_list|,
name|Na
argument_list|,
name|Ni
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|ArrayIndex* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|array
argument_list|()
argument_list|,
name|E
operator|->
name|array
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|index
argument_list|()
argument_list|,
name|E
operator|->
name|index
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Index
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Pointer arithmetic, restricted to arrays only.
end_comment

begin_comment
comment|// If p is a reference to an array, then p + n, where n is an integer, is
end_comment

begin_comment
comment|// a reference to a subarray.
end_comment

begin_decl_stmt
name|class
name|ArrayAdd
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_ArrayAdd
return|;
block|}
name|ArrayAdd
argument_list|(
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_ArrayAdd
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|ArrayAdd
argument_list|(
specifier|const
name|ArrayAdd
operator|&
name|E
argument_list|,
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|E
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|SExpr
operator|*
name|array
argument_list|()
block|{
return|return
name|Array
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|array
argument_list|()
specifier|const
block|{
return|return
name|Array
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|index
argument_list|()
block|{
return|return
name|Index
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Array
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ni
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Index
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceArrayAdd
argument_list|(
operator|*
name|this
argument_list|,
name|Na
argument_list|,
name|Ni
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|ArrayAdd* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|array
argument_list|()
argument_list|,
name|E
operator|->
name|array
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|index
argument_list|()
argument_list|,
name|E
operator|->
name|index
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Index
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Simple unary operation -- e.g. !, ~, etc.
end_comment

begin_decl_stmt
name|class
name|UnaryOp
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_UnaryOp
return|;
block|}
name|UnaryOp
argument_list|(
argument|TIL_UnaryOpcode Op
argument_list|,
argument|SExpr *E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_UnaryOp
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|;   }
name|UnaryOp
argument_list|(
specifier|const
name|UnaryOp
operator|&
name|U
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|U
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|U
operator|.
name|Flags
block|; }
name|TIL_UnaryOpcode
name|unaryOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_UnaryOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr
argument_list|()
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr
argument_list|()
specifier|const
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceUnaryOp
argument_list|(
operator|*
name|this
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|UnaryOp* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|unaryOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|unaryOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr
argument_list|()
argument_list|,
name|E
operator|->
name|expr
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Expr0
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Simple binary operation -- e.g. +, -, etc.
end_comment

begin_decl_stmt
name|class
name|BinaryOp
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_BinaryOp
return|;
block|}
name|BinaryOp
argument_list|(
argument|TIL_BinaryOpcode Op
argument_list|,
argument|SExpr *E0
argument_list|,
argument|SExpr *E1
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_BinaryOp
argument_list|)
block|,
name|Expr0
argument_list|(
name|E0
argument_list|)
block|,
name|Expr1
argument_list|(
argument|E1
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|;   }
name|BinaryOp
argument_list|(
specifier|const
name|BinaryOp
operator|&
name|B
argument_list|,
name|SExpr
operator|*
name|E0
argument_list|,
name|SExpr
operator|*
name|E1
argument_list|)
operator|:
name|SExpr
argument_list|(
name|B
argument_list|)
block|,
name|Expr0
argument_list|(
name|E0
argument_list|)
block|,
name|Expr1
argument_list|(
argument|E1
argument_list|)
block|{
name|Flags
operator|=
name|B
operator|.
name|Flags
block|;   }
name|TIL_BinaryOpcode
name|binaryOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_BinaryOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr0
argument_list|()
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr0
argument_list|()
specifier|const
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|expr1
argument_list|()
block|{
return|return
name|Expr1
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr1
argument_list|()
specifier|const
block|{
return|return
name|Expr1
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ne1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr1
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceBinaryOp
argument_list|(
operator|*
name|this
argument_list|,
name|Ne0
argument_list|,
name|Ne1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|BinaryOp* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|binaryOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|binaryOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|expr0
argument_list|()
argument_list|,
name|E
operator|->
name|expr0
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
end_decl_stmt

begin_return
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr1
argument_list|()
argument_list|,
name|E
operator|->
name|expr1
argument_list|()
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}  private:
name|SExprRef
name|Expr0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Expr1
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Cast expression
end_comment

begin_decl_stmt
name|class
name|Cast
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Cast
return|;
block|}
name|Cast
argument_list|(
argument|TIL_CastOpcode Op
argument_list|,
argument|SExpr *E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Cast
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|; }
name|Cast
argument_list|(
specifier|const
name|Cast
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|C
operator|.
name|Flags
block|; }
name|TIL_CastOpcode
name|castOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_CastOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr
argument_list|()
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr
argument_list|()
specifier|const
block|{
return|return
name|Expr0
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCast
argument_list|(
operator|*
name|this
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Cast* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|castOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|castOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr
argument_list|()
argument_list|,
name|E
operator|->
name|expr
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExprRef
name|Expr0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|SCFG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|Phi
range|:
name|public
name|SExpr
block|{
name|public
operator|:
comment|// TODO: change to SExprRef
typedef|typedef
name|SimpleArray
operator|<
name|SExpr
operator|*
operator|>
name|ValArray
expr_stmt|;
comment|// In minimal SSA form, all Phi nodes are MultiVal.
comment|// During conversion to SSA, incomplete Phi nodes may be introduced, which
comment|// are later determined to be SingleVal, and are thus redundant.
block|enum
name|Status
block|{
name|PH_MultiVal
operator|=
literal|0
block|,
comment|// Phi node has multiple distinct values.  (Normal)
name|PH_SingleVal
block|,
comment|// Phi node has one distinct value, and can be eliminated
name|PH_Incomplete
comment|// Phi node is incomplete
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Phi
return|;
block|}
end_function

begin_expr_stmt
name|Phi
argument_list|()
operator|:
name|SExpr
argument_list|(
argument|COP_Phi
argument_list|)
block|{}
name|Phi
argument_list|(
argument|MemRegionRef A
argument_list|,
argument|unsigned Nvals
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Phi
argument_list|)
operator|,
name|Values
argument_list|(
argument|A
argument_list|,
argument|Nvals
argument_list|)
block|{}
name|Phi
argument_list|(
specifier|const
name|Phi
operator|&
name|P
argument_list|,
name|ValArray
operator|&&
name|Vs
argument_list|)
operator|:
name|SExpr
argument_list|(
name|P
argument_list|)
operator|,
name|Values
argument_list|(
argument|std::move(Vs)
argument_list|)
block|{}
specifier|const
name|ValArray
operator|&
name|values
argument_list|()
specifier|const
block|{
return|return
name|Values
return|;
block|}
end_expr_stmt

begin_function
name|ValArray
modifier|&
name|values
parameter_list|()
block|{
return|return
name|Values
return|;
block|}
end_function

begin_expr_stmt
name|Status
name|status
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Status
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setStatus
parameter_list|(
name|Status
name|s
parameter_list|)
block|{
name|Flags
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|typename
name|V
operator|::
name|R_SExpr
operator|>
name|Nvs
argument_list|(
name|Vs
argument_list|,
name|Values
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|Val
operator|:
name|Values
control|)
block|{
name|Nvs
operator|.
name|push_back
argument_list|(
name|Vs
operator|.
name|traverse
argument_list|(
name|Val
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reducePhi
argument_list|(
operator|*
name|this
argument_list|,
name|Nvs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Phi *E
argument_list|,
argument|C&Cmp
argument_list|)
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|ValArray
name|Values
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A basic block is part of an SCFG, and can be treated as a function in
end_comment

begin_comment
comment|// continuation passing style.  It consists of a sequence of phi nodes, which
end_comment

begin_comment
comment|// are "arguments" to the function, followed by a sequence of instructions.
end_comment

begin_comment
comment|// Both arguments and instructions define new variables.  It ends with a
end_comment

begin_comment
comment|// branch or goto to another basic block in the same SCFG.
end_comment

begin_decl_stmt
name|class
name|BasicBlock
range|:
name|public
name|SExpr
block|{
name|public
operator|:
typedef|typedef
name|SimpleArray
operator|<
name|Variable
operator|*
operator|>
name|VarArray
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
name|BlockArray
expr_stmt|;
end_typedef

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_BasicBlock
return|;
block|}
end_function

begin_macro
name|explicit
end_macro

begin_macro
name|BasicBlock
argument_list|(
argument|MemRegionRef A
argument_list|,
argument|BasicBlock* P = nullptr
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SExpr
argument_list|(
name|COP_BasicBlock
argument_list|)
operator|,
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|CFGPtr
argument_list|(
name|nullptr
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Terminator
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|BasicBlock
argument_list|(
name|BasicBlock
operator|&
name|B
argument_list|,
name|VarArray
operator|&&
name|As
argument_list|,
name|VarArray
operator|&&
name|Is
argument_list|,
name|SExpr
operator|*
name|T
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_BasicBlock
argument_list|)
operator|,
name|Arena
argument_list|(
name|B
operator|.
name|Arena
argument_list|)
operator|,
name|CFGPtr
argument_list|(
name|nullptr
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Parent
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Args
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|As
argument_list|)
argument_list|)
operator|,
name|Instrs
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Is
argument_list|)
argument_list|)
operator|,
name|Terminator
argument_list|(
argument|T
argument_list|)
block|{ }
name|unsigned
name|blockID
argument_list|()
specifier|const
block|{
return|return
name|BlockID
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|numPredecessors
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|SCFG
operator|*
name|cfg
argument_list|()
specifier|const
block|{
return|return
name|CFGPtr
return|;
block|}
end_expr_stmt

begin_function
name|SCFG
modifier|*
name|cfg
parameter_list|()
block|{
return|return
name|CFGPtr
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|parent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|parent
parameter_list|()
block|{
return|return
name|Parent
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|VarArray
operator|&
name|arguments
argument_list|()
specifier|const
block|{
return|return
name|Args
return|;
block|}
end_expr_stmt

begin_function
name|VarArray
modifier|&
name|arguments
parameter_list|()
block|{
return|return
name|Args
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|VarArray
operator|&
name|instructions
argument_list|()
specifier|const
block|{
return|return
name|Instrs
return|;
block|}
end_expr_stmt

begin_function
name|VarArray
modifier|&
name|instructions
parameter_list|()
block|{
return|return
name|Instrs
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BlockArray
operator|&
name|predecessors
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
return|;
block|}
end_expr_stmt

begin_function
name|BlockArray
modifier|&
name|predecessors
parameter_list|()
block|{
return|return
name|Predecessors
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|SExpr
operator|*
name|terminator
argument_list|()
specifier|const
block|{
return|return
name|Terminator
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|SExpr
modifier|*
name|terminator
parameter_list|()
block|{
return|return
name|Terminator
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|setBlockID
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|BlockID
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setParent
parameter_list|(
name|BasicBlock
modifier|*
name|P
parameter_list|)
block|{
name|Parent
operator|=
name|P
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setTerminator
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
name|Terminator
operator|.
name|reset
argument_list|(
name|E
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Add a new argument.  V must define a phi-node.
end_comment

begin_function
name|void
name|addArgument
parameter_list|(
name|Variable
modifier|*
name|V
parameter_list|)
block|{
name|V
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_LetBB
argument_list|)
expr_stmt|;
name|Args
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Add a new instruction.
end_comment

begin_function
name|void
name|addInstruction
parameter_list|(
name|Variable
modifier|*
name|V
parameter_list|)
block|{
name|V
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_LetBB
argument_list|)
expr_stmt|;
name|Instrs
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Instrs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Add a new predecessor, and return the phi-node index for it.
end_comment

begin_comment
comment|// Will add an argument to all phi-nodes, initialized to nullptr.
end_comment

begin_function_decl
name|unsigned
name|addPredecessor
parameter_list|(
name|BasicBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Reserve space for Nargs arguments.
end_comment

begin_function
name|void
name|reserveArguments
parameter_list|(
name|unsigned
name|Nargs
parameter_list|)
block|{
name|Args
operator|.
name|reserve
argument_list|(
name|Nargs
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Reserve space for Nins instructions.
end_comment

begin_function
name|void
name|reserveInstructions
parameter_list|(
name|unsigned
name|Nins
parameter_list|)
block|{
name|Instrs
operator|.
name|reserve
argument_list|(
name|Nins
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Reserve space for NumPreds predecessors, including space in phi nodes.
end_comment

begin_function_decl
name|void
name|reservePredecessors
parameter_list|(
name|unsigned
name|NumPreds
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Return the index of BB, or Predecessors.size if BB is not a predecessor.
end_comment

begin_decl_stmt
name|unsigned
name|findPredecessorIndex
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
block|{
name|auto
name|I
init|=
name|std
operator|::
name|find
argument_list|(
name|Predecessors
operator|.
name|cbegin
argument_list|()
argument_list|,
name|Predecessors
operator|.
name|cend
argument_list|()
argument_list|,
name|BB
argument_list|)
decl_stmt|;
return|return
name|std
operator|::
name|distance
argument_list|(
name|Predecessors
operator|.
name|cbegin
argument_list|()
argument_list|,
name|I
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Set id numbers for variables.
end_comment

begin_function_decl
name|void
name|renumberVars
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_BasicBlock
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|Variable
operator|*
operator|>
name|Nas
argument_list|(
name|Vs
argument_list|,
name|Args
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|Variable
operator|*
operator|>
name|Nis
argument_list|(
name|Vs
argument_list|,
name|Instrs
operator|.
name|size
argument_list|()
argument_list|)
block|;
comment|// Entering the basic block should do any scope initialization.
name|Vs
operator|.
name|enterBasicBlock
argument_list|(
operator|*
name|this
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|A
operator|:
name|Args
control|)
block|{
name|auto
name|Ne
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|A
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
decl_stmt|;
name|Variable
modifier|*
name|Nvd
init|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|A
argument_list|,
name|Ne
argument_list|)
decl_stmt|;
name|Nas
operator|.
name|push_back
argument_list|(
name|Nvd
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|auto
operator|*
name|I
operator|:
name|Instrs
control|)
block|{
name|auto
name|Ne
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|I
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
decl_stmt|;
name|Variable
modifier|*
name|Nvd
init|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|I
argument_list|,
name|Ne
argument_list|)
decl_stmt|;
name|Nis
operator|.
name|push_back
argument_list|(
name|Nvd
argument_list|)
expr_stmt|;
block|}
end_for

begin_decl_stmt
name|auto
name|Nt
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Terminator
argument_list|,
name|Ctx
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Exiting the basic block should handle any scope cleanup.
end_comment

begin_expr_stmt
name|Vs
operator|.
name|exitBasicBlock
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reduceBasicBlock
argument_list|(
operator|*
name|this
argument_list|,
name|Nas
argument_list|,
name|Nis
argument_list|,
name|Nt
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|BasicBlock *E
argument_list|,
argument|C&Cmp
argument_list|)
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|friend
name|class
name|SCFG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MemRegionRef
name|Arena
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SCFG
modifier|*
name|CFGPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The CFG that contains this block.
end_comment

begin_decl_stmt
name|unsigned
name|BlockID
decl_stmt|;
end_decl_stmt

begin_comment
comment|// unique id for this BB in the containing CFG
end_comment

begin_decl_stmt
name|BasicBlock
modifier|*
name|Parent
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The parent block is the enclosing lexical scope.
end_comment

begin_comment
comment|// The parent dominates this block.
end_comment

begin_decl_stmt
name|BlockArray
name|Predecessors
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Predecessor blocks in the CFG.
end_comment

begin_decl_stmt
name|VarArray
name|Args
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Phi nodes.  One argument per predecessor.
end_comment

begin_decl_stmt
name|VarArray
name|Instrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Instructions.
end_comment

begin_decl_stmt
name|SExprRef
name|Terminator
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Branch or Goto
end_comment

begin_comment
unit|};
comment|// An SCFG is a control-flow graph.  It consists of a set of basic blocks, each
end_comment

begin_comment
comment|// of which terminates in a branch to another basic block.  There is one
end_comment

begin_comment
comment|// entry point, and one exit point.
end_comment

begin_decl_stmt
name|class
name|SCFG
range|:
name|public
name|SExpr
block|{
name|public
operator|:
typedef|typedef
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
name|BlockArray
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|BlockArray
operator|::
name|iterator
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|BlockArray
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
end_typedef

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SCFG
return|;
block|}
end_function

begin_macro
name|SCFG
argument_list|(
argument|MemRegionRef A
argument_list|,
argument|unsigned Nblocks
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SExpr
argument_list|(
name|COP_SCFG
argument_list|)
operator|,
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|Blocks
argument_list|(
name|A
argument_list|,
name|Nblocks
argument_list|)
operator|,
name|Entry
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Exit
argument_list|(
argument|nullptr
argument_list|)
block|{
name|Entry
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|BasicBlock
argument_list|(
name|A
argument_list|,
name|nullptr
argument_list|)
block|;
name|Exit
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|BasicBlock
argument_list|(
name|A
argument_list|,
name|Entry
argument_list|)
block|;
name|auto
operator|*
name|V
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|Variable
argument_list|(
name|new
argument_list|(
argument|A
argument_list|)
name|Phi
argument_list|()
argument_list|)
block|;
name|Exit
operator|->
name|addArgument
argument_list|(
name|V
argument_list|)
block|;
name|add
argument_list|(
name|Entry
argument_list|)
block|;
name|add
argument_list|(
name|Exit
argument_list|)
block|;   }
name|SCFG
argument_list|(
specifier|const
name|SCFG
operator|&
name|Cfg
argument_list|,
name|BlockArray
operator|&&
name|Ba
argument_list|)
comment|// steals memory from Ba
operator|:
name|SExpr
argument_list|(
name|COP_SCFG
argument_list|)
operator|,
name|Arena
argument_list|(
name|Cfg
operator|.
name|Arena
argument_list|)
operator|,
name|Blocks
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Ba
argument_list|)
argument_list|)
operator|,
name|Entry
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Exit
argument_list|(
argument|nullptr
argument_list|)
block|{
comment|// TODO: set entry and exit!
block|}
name|iterator
name|begin
argument_list|()
block|{
return|return
name|Blocks
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Blocks
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|cbegin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|cend
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|cbegin
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|cbegin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|cend
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|cend
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|entry
argument_list|()
specifier|const
block|{
return|return
name|Entry
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|entry
parameter_list|()
block|{
return|return
name|Entry
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|exit
argument_list|()
specifier|const
block|{
return|return
name|Exit
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|exit
parameter_list|()
block|{
return|return
name|Exit
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|add
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|assert
argument_list|(
name|BB
operator|->
name|CFGPtr
operator|==
name|nullptr
operator|||
name|BB
operator|->
name|CFGPtr
operator|==
name|this
argument_list|)
expr_stmt|;
name|BB
operator|->
name|setBlockID
argument_list|(
name|Blocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|BB
operator|->
name|CFGPtr
operator|=
name|this
expr_stmt|;
name|Blocks
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setEntry
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|Entry
operator|=
name|BB
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setExit
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|Exit
operator|=
name|BB
expr_stmt|;
block|}
end_function

begin_comment
comment|// Set varable ids in all blocks.
end_comment

begin_function_decl
name|void
name|renumberVars
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|Vs
operator|.
name|enterCFG
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|BasicBlock
operator|*
operator|>
name|Bbs
argument_list|(
name|Vs
argument_list|,
name|Blocks
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|B
operator|:
name|Blocks
control|)
block|{
name|Bbs
operator|.
name|push_back
argument_list|(
name|B
operator|->
name|traverse
argument_list|(
name|Vs
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Vs
operator|.
name|exitCFG
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reduceSCFG
argument_list|(
operator|*
name|this
argument_list|,
name|Bbs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|SCFG *E
argument_list|,
argument|C&Cmp
argument_list|)
block|{
comment|// TODO -- implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|MemRegionRef
name|Arena
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BlockArray
name|Blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BasicBlock
modifier|*
name|Entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BasicBlock
modifier|*
name|Exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|Goto
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Goto
return|;
block|}
name|Goto
argument_list|(
argument|BasicBlock *B
argument_list|,
argument|unsigned I
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Goto
argument_list|)
block|,
name|TargetBlock
argument_list|(
name|B
argument_list|)
block|,
name|Index
argument_list|(
argument|I
argument_list|)
block|{}
name|Goto
argument_list|(
argument|const Goto&G
argument_list|,
argument|BasicBlock *B
argument_list|,
argument|unsigned I
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Goto
argument_list|)
block|,
name|TargetBlock
argument_list|(
name|B
argument_list|)
block|,
name|Index
argument_list|(
argument|I
argument_list|)
block|{}
specifier|const
name|BasicBlock
operator|*
name|targetBlock
argument_list|()
specifier|const
block|{
return|return
name|TargetBlock
return|;
block|}
name|BasicBlock
operator|*
name|targetBlock
argument_list|()
block|{
return|return
name|TargetBlock
return|;
block|}
name|unsigned
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|BasicBlock
operator|*
name|Ntb
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|TargetBlock
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceGoto
argument_list|(
operator|*
name|this
argument_list|,
name|Ntb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Goto *E
argument_list|,
argument|C&Cmp
argument_list|)
block|{
comment|// TODO -- implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|BasicBlock
operator|*
name|TargetBlock
block|;
name|unsigned
name|Index
block|;
comment|// Index into Phi nodes of target block.
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|Branch
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Branch
return|;
block|}
name|Branch
argument_list|(
argument|SExpr *C
argument_list|,
argument|BasicBlock *T
argument_list|,
argument|BasicBlock *E
argument_list|,
argument|unsigned TI
argument_list|,
argument|unsigned EI
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Branch
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenBlock
argument_list|(
name|T
argument_list|)
block|,
name|ElseBlock
argument_list|(
name|E
argument_list|)
block|,
name|ThenIndex
argument_list|(
name|TI
argument_list|)
block|,
name|ElseIndex
argument_list|(
argument|EI
argument_list|)
block|{}
name|Branch
argument_list|(
argument|const Branch&Br
argument_list|,
argument|SExpr *C
argument_list|,
argument|BasicBlock *T
argument_list|,
argument|BasicBlock *E
argument_list|,
argument|unsigned TI
argument_list|,
argument|unsigned EI
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Branch
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenBlock
argument_list|(
name|T
argument_list|)
block|,
name|ElseBlock
argument_list|(
name|E
argument_list|)
block|,
name|ThenIndex
argument_list|(
name|TI
argument_list|)
block|,
name|ElseIndex
argument_list|(
argument|EI
argument_list|)
block|{}
specifier|const
name|SExpr
operator|*
name|condition
argument_list|()
specifier|const
block|{
return|return
name|Condition
return|;
block|}
name|SExpr
operator|*
name|condition
argument_list|()
block|{
return|return
name|Condition
return|;
block|}
specifier|const
name|BasicBlock
operator|*
name|thenBlock
argument_list|()
specifier|const
block|{
return|return
name|ThenBlock
return|;
block|}
name|BasicBlock
operator|*
name|thenBlock
argument_list|()
block|{
return|return
name|ThenBlock
return|;
block|}
specifier|const
name|BasicBlock
operator|*
name|elseBlock
argument_list|()
specifier|const
block|{
return|return
name|ElseBlock
return|;
block|}
name|BasicBlock
operator|*
name|elseBlock
argument_list|()
block|{
return|return
name|ElseBlock
return|;
block|}
name|unsigned
name|thenIndex
argument_list|()
specifier|const
block|{
return|return
name|ThenIndex
return|;
block|}
name|unsigned
name|elseIndex
argument_list|()
specifier|const
block|{
return|return
name|ElseIndex
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nc
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Condition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|BasicBlock
operator|*
name|Ntb
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|ThenBlock
argument_list|)
block|;
name|BasicBlock
operator|*
name|Nte
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|ElseBlock
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceBranch
argument_list|(
operator|*
name|this
argument_list|,
name|Nc
argument_list|,
name|Ntb
argument_list|,
name|Nte
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Branch *E
argument_list|,
argument|C&Cmp
argument_list|)
block|{
comment|// TODO -- implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|SExpr
operator|*
name|Condition
block|;
name|BasicBlock
operator|*
name|ThenBlock
block|;
name|BasicBlock
operator|*
name|ElseBlock
block|;
name|unsigned
name|ThenIndex
block|;
name|unsigned
name|ElseIndex
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// An identifier, e.g. 'foo' or 'x'.
end_comment

begin_comment
comment|// This is a pseduo-term; it will be lowered to a variable or projection.
end_comment

begin_decl_stmt
name|class
name|Identifier
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Identifier
return|;
block|}
name|Identifier
argument_list|(
argument|StringRef Id
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Identifier
argument_list|)
block|,
name|Name
argument_list|(
argument|Id
argument_list|)
block|{ }
name|Identifier
argument_list|(
specifier|const
name|Identifier
operator|&
name|I
argument_list|)
operator|:
name|SExpr
argument_list|(
name|I
argument_list|)
block|,
name|Name
argument_list|(
argument|I.Name
argument_list|)
block|{ }
name|StringRef
name|name
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceIdentifier
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Identifier* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
return|return
name|Cmp
operator|.
name|compareStrings
argument_list|(
name|name
argument_list|()
argument_list|,
name|E
operator|->
name|name
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|StringRef
name|Name
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// An if-then-else expression.
end_comment

begin_comment
comment|// This is a pseduo-term; it will be lowered to a branch in a CFG.
end_comment

begin_decl_stmt
name|class
name|IfThenElse
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_IfThenElse
return|;
block|}
name|IfThenElse
argument_list|(
name|SExpr
operator|*
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_IfThenElse
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenExpr
argument_list|(
name|T
argument_list|)
block|,
name|ElseExpr
argument_list|(
argument|E
argument_list|)
block|{ }
name|IfThenElse
argument_list|(
specifier|const
name|IfThenElse
operator|&
name|I
argument_list|,
name|SExpr
operator|*
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|I
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenExpr
argument_list|(
name|T
argument_list|)
block|,
name|ElseExpr
argument_list|(
argument|E
argument_list|)
block|{ }
name|SExpr
operator|*
name|condition
argument_list|()
block|{
return|return
name|Condition
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Address to store to
specifier|const
name|SExpr
operator|*
name|condition
argument_list|()
specifier|const
block|{
return|return
name|Condition
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|thenExpr
argument_list|()
block|{
return|return
name|ThenExpr
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|thenExpr
argument_list|()
specifier|const
block|{
return|return
name|ThenExpr
operator|.
name|get
argument_list|()
return|;
block|}
name|SExpr
operator|*
name|elseExpr
argument_list|()
block|{
return|return
name|ElseExpr
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|elseExpr
argument_list|()
specifier|const
block|{
return|return
name|ElseExpr
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nc
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Condition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ThenExpr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ElseExpr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceIfThenElse
argument_list|(
operator|*
name|this
argument_list|,
name|Nc
argument_list|,
name|Nt
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|IfThenElse* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|condition
argument_list|()
argument_list|,
name|E
operator|->
name|condition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|thenExpr
argument_list|()
argument_list|,
name|E
operator|->
name|thenExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
end_decl_stmt

begin_return
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|elseExpr
argument_list|()
argument_list|,
name|E
operator|->
name|elseExpr
argument_list|()
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}  private:
name|SExprRef
name|Condition
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|ThenExpr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|ElseExpr
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A let-expression,  e.g.  let x=t; u.
end_comment

begin_comment
comment|// This is a pseduo-term; it will be lowered to instructions in a CFG.
end_comment

begin_decl_stmt
name|class
name|Let
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Let
return|;
block|}
name|Let
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Let
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Let
argument_list|)
block|;   }
name|Let
argument_list|(
specifier|const
name|Let
operator|&
name|L
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Let
argument_list|)
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|.
name|get
argument_list|()
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This is a variable declaration, so traverse the definition.
name|auto
name|E0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|VarDecl
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
comment|// Tell the rewriter to enter the scope of the let variable.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|E0
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Ctx
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceLet
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|Let* E
argument_list|,
argument|C& Cmp
argument_list|)
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|,
name|E
operator|->
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|Variable
modifier|*
name|VarDecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExprRef
name|Body
decl_stmt|;
end_decl_stmt

begin_function_decl
unit|};
name|SExpr
modifier|*
name|getCanonicalVal
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|simplifyIncompleteArg
argument_list|(
name|Variable
operator|*
name|V
argument_list|,
name|til
operator|::
name|Phi
operator|*
name|Ph
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace til
end_comment

begin_comment
unit|}
comment|// end namespace threadSafety
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_THREAD_SAFETY_TIL_H
end_comment

end_unit

