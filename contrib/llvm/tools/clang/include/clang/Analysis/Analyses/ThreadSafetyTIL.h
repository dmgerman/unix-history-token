begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ThreadSafetyTIL.h ---------------------------------------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT in the llvm repository for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines a simple Typed Intermediate Language, or TIL, that is used
end_comment

begin_comment
comment|// by the thread safety analysis (See ThreadSafety.cpp).  The TIL is intended
end_comment

begin_comment
comment|// to be largely independent of clang, in the hope that the analysis can be
end_comment

begin_comment
comment|// reused for other non-C++ languages.  All dependencies on clang/llvm should
end_comment

begin_comment
comment|// go in ThreadSafetyUtil.h.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Thread safety analysis works by comparing mutex expressions, e.g.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// class A { Mutex mu; int dat GUARDED_BY(this->mu); }
end_comment

begin_comment
comment|// class B { A a; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// void foo(B* b) {
end_comment

begin_comment
comment|//   (*b).a.mu.lock();     // locks (*b).a.mu
end_comment

begin_comment
comment|//   b->a.dat = 0;         // substitute&b->a for 'this';
end_comment

begin_comment
comment|//                         // requires lock on (&b->a)->mu
end_comment

begin_comment
comment|//   (b->a.mu).unlock();   // unlocks (b->a.mu)
end_comment

begin_comment
comment|// }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// As illustrated by the above example, clang Exprs are not well-suited to
end_comment

begin_comment
comment|// represent mutex expressions directly, since there is no easy way to compare
end_comment

begin_comment
comment|// Exprs for equivalence.  The thread safety analysis thus lowers clang Exprs
end_comment

begin_comment
comment|// into a simple intermediate language (IL).  The IL supports:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// (1) comparisons for semantic equality of expressions
end_comment

begin_comment
comment|// (2) SSA renaming of variables
end_comment

begin_comment
comment|// (3) wildcards and pattern matching over expressions
end_comment

begin_comment
comment|// (4) hash-based expression lookup
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The TIL is currently very experimental, is intended only for use within
end_comment

begin_comment
comment|// the thread safety analysis, and is subject to change without notice.
end_comment

begin_comment
comment|// After the API stabilizes and matures, it may be appropriate to make this
end_comment

begin_comment
comment|// more generally available to other analyses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H
end_define

begin_comment
comment|// All clang include dependencies for this file must be put in
end_comment

begin_comment
comment|// ThreadSafetyUtil.h.
end_comment

begin_include
include|#
directive|include
file|"ThreadSafetyUtil.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|threadSafety
block|{
name|namespace
name|til
block|{
comment|/// Enum for the different distinct classes of SExpr
enum|enum
name|TIL_Opcode
block|{
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
value|COP_##X,
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
block|}
enum|;
comment|/// Opcode for unary arithmetic operations.
enum|enum
name|TIL_UnaryOpcode
enum|:
name|unsigned
name|char
block|{
name|UOP_Minus
block|,
comment|//  -
name|UOP_BitNot
block|,
comment|//  ~
name|UOP_LogicNot
comment|//  !
block|}
enum|;
comment|/// Opcode for binary arithmetic operations.
enum|enum
name|TIL_BinaryOpcode
enum|:
name|unsigned
name|char
block|{
name|BOP_Add
block|,
comment|//  +
name|BOP_Sub
block|,
comment|//  -
name|BOP_Mul
block|,
comment|//  *
name|BOP_Div
block|,
comment|//  /
name|BOP_Rem
block|,
comment|//  %
name|BOP_Shl
block|,
comment|//<<
name|BOP_Shr
block|,
comment|//>>
name|BOP_BitAnd
block|,
comment|//&
name|BOP_BitXor
block|,
comment|//  ^
name|BOP_BitOr
block|,
comment|//  |
name|BOP_Eq
block|,
comment|//  ==
name|BOP_Neq
block|,
comment|//  !=
name|BOP_Lt
block|,
comment|//<
name|BOP_Leq
block|,
comment|//<=
name|BOP_LogicAnd
block|,
comment|//&&  (no short-circuit)
name|BOP_LogicOr
comment|//  ||  (no short-circuit)
block|}
enum|;
comment|/// Opcode for cast operations.
enum|enum
name|TIL_CastOpcode
enum|:
name|unsigned
name|char
block|{
name|CAST_none
init|=
literal|0
block|,
name|CAST_extendNum
block|,
comment|// extend precision of numeric type
name|CAST_truncNum
block|,
comment|// truncate precision of numeric type
name|CAST_toFloat
block|,
comment|// convert to floating point type
name|CAST_toInt
block|,
comment|// convert to integer type
name|CAST_objToPtr
comment|// convert smart pointer to pointer  (C++ only)
block|}
enum|;
specifier|const
name|TIL_Opcode
name|COP_Min
init|=
name|COP_Future
decl_stmt|;
specifier|const
name|TIL_Opcode
name|COP_Max
init|=
name|COP_Branch
decl_stmt|;
specifier|const
name|TIL_UnaryOpcode
name|UOP_Min
init|=
name|UOP_Minus
decl_stmt|;
specifier|const
name|TIL_UnaryOpcode
name|UOP_Max
init|=
name|UOP_LogicNot
decl_stmt|;
specifier|const
name|TIL_BinaryOpcode
name|BOP_Min
init|=
name|BOP_Add
decl_stmt|;
specifier|const
name|TIL_BinaryOpcode
name|BOP_Max
init|=
name|BOP_LogicOr
decl_stmt|;
specifier|const
name|TIL_CastOpcode
name|CAST_Min
init|=
name|CAST_none
decl_stmt|;
specifier|const
name|TIL_CastOpcode
name|CAST_Max
init|=
name|CAST_toInt
decl_stmt|;
comment|/// Return the name of a unary opcode.
name|StringRef
name|getUnaryOpcodeString
parameter_list|(
name|TIL_UnaryOpcode
name|Op
parameter_list|)
function_decl|;
comment|/// Return the name of a binary opcode.
name|StringRef
name|getBinaryOpcodeString
parameter_list|(
name|TIL_BinaryOpcode
name|Op
parameter_list|)
function_decl|;
comment|/// ValueTypes are data types that can actually be held in registers.
comment|/// All variables and expressions must have a value type.
comment|/// Pointer types are further subdivided into the various heap-allocated
comment|/// types, such as functions, records, etc.
comment|/// Structured types that are passed by value (e.g. complex numbers)
comment|/// require special handling; they use BT_ValueRef, and size ST_0.
struct|struct
name|ValueType
block|{
enum|enum
name|BaseType
enum|:
name|unsigned
name|char
block|{
name|BT_Void
init|=
literal|0
block|,
name|BT_Bool
block|,
name|BT_Int
block|,
name|BT_Float
block|,
name|BT_String
block|,
comment|// String literals
name|BT_Pointer
block|,
name|BT_ValueRef
block|}
enum|;
enum|enum
name|SizeType
enum|:
name|unsigned
name|char
block|{
name|ST_0
init|=
literal|0
block|,
name|ST_1
block|,
name|ST_8
block|,
name|ST_16
block|,
name|ST_32
block|,
name|ST_64
block|,
name|ST_128
block|}
enum|;
specifier|inline
specifier|static
name|SizeType
name|getSizeType
parameter_list|(
name|unsigned
name|nbytes
parameter_list|)
function_decl|;
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
specifier|static
name|ValueType
name|getValueType
argument_list|()
expr_stmt|;
name|ValueType
argument_list|(
argument|BaseType B
argument_list|,
argument|SizeType Sz
argument_list|,
argument|bool S
argument_list|,
argument|unsigned char VS
argument_list|)
block|:
name|Base
argument_list|(
name|B
argument_list|)
operator|,
name|Size
argument_list|(
name|Sz
argument_list|)
operator|,
name|Signed
argument_list|(
name|S
argument_list|)
operator|,
name|VectSize
argument_list|(
argument|VS
argument_list|)
block|{ }
name|BaseType
name|Base
expr_stmt|;
name|SizeType
name|Size
decl_stmt|;
name|bool
name|Signed
decl_stmt|;
name|unsigned
name|char
name|VectSize
decl_stmt|;
comment|// 0 for scalar, otherwise num elements in vector
block|}
struct|;
specifier|inline
name|ValueType
operator|::
name|SizeType
name|ValueType
operator|::
name|getSizeType
argument_list|(
argument|unsigned nbytes
argument_list|)
block|{
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
return|return
name|ST_8
return|;
case|case
literal|2
case|:
return|return
name|ST_16
return|;
case|case
literal|4
case|:
return|return
name|ST_32
return|;
case|case
literal|8
case|:
return|return
name|ST_64
return|;
case|case
literal|16
case|:
return|return
name|ST_128
return|;
default|default:
return|return
name|ST_0
return|;
block|}
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Void
argument_list|,
name|ST_0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|bool
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Bool
argument_list|,
name|ST_1
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int8_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint8_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int16_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint16_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int32_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint32_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|int64_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|uint64_t
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Int
argument_list|,
name|ST_64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|float
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|double
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|long
name|double
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Float
argument_list|,
name|ST_128
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|StringRef
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_String
argument_list|,
name|getSizeType
argument_list|(
sizeof|sizeof
argument_list|(
name|StringRef
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|template
operator|<
operator|>
specifier|inline
name|ValueType
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|*
operator|>
operator|(
operator|)
block|{
return|return
name|ValueType
argument_list|(
name|BT_Pointer
argument_list|,
name|getSizeType
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|class
name|BasicBlock
decl_stmt|;
comment|/// Base class for AST nodes in the typed intermediate language.
name|class
name|SExpr
block|{
name|public
label|:
name|TIL_Opcode
name|opcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_Opcode
operator|>
operator|(
name|Opcode
operator|)
return|;
block|}
comment|// Subclasses of SExpr must define the following:
comment|//
comment|// This(const This& E, ...) {
comment|//   copy constructor: construct copy of E, with some additional arguments.
comment|// }
comment|//
comment|// template<class V>
comment|// typename V::R_SExpr traverse(V&Vs, typename V::R_Ctx Ctx) {
comment|//   traverse all subexpressions, following the traversal/rewriter interface.
comment|// }
comment|//
comment|// template<class C> typename C::CType compare(CType* E, C& Cmp) {
comment|//   compare all subexpressions, following the comparator interface
comment|// }
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|S
parameter_list|,
name|MemRegionRef
modifier|&
name|R
parameter_list|)
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|S
argument_list|,
name|R
argument_list|)
return|;
block|}
comment|/// SExpr objects cannot be deleted.
comment|// This declaration is public to workaround a gcc bug that breaks building
comment|// with REQUIRES_EH=1.
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
argument_list|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
comment|/// Returns the instruction ID for this expression.
comment|/// All basic block instructions have a unique ID (i.e. virtual register).
name|unsigned
name|id
argument_list|()
specifier|const
block|{
return|return
name|SExprID
return|;
block|}
comment|/// Returns the block, if this is an instruction in a basic block,
comment|/// otherwise returns null.
name|BasicBlock
operator|*
name|block
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
comment|/// Set the basic block and instruction ID for this expression.
name|void
name|setID
parameter_list|(
name|BasicBlock
modifier|*
name|B
parameter_list|,
name|unsigned
name|id
parameter_list|)
block|{
name|Block
operator|=
name|B
expr_stmt|;
name|SExprID
operator|=
name|id
expr_stmt|;
block|}
name|protected
label|:
name|SExpr
argument_list|(
argument|TIL_Opcode Op
argument_list|)
block|:
name|Opcode
argument_list|(
name|Op
argument_list|)
operator|,
name|Reserved
argument_list|(
literal|0
argument_list|)
operator|,
name|Flags
argument_list|(
literal|0
argument_list|)
operator|,
name|SExprID
argument_list|(
literal|0
argument_list|)
operator|,
name|Block
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|SExpr
argument_list|(
specifier|const
name|SExpr
operator|&
name|E
argument_list|)
operator|:
name|Opcode
argument_list|(
name|E
operator|.
name|Opcode
argument_list|)
operator|,
name|Reserved
argument_list|(
literal|0
argument_list|)
operator|,
name|Flags
argument_list|(
name|E
operator|.
name|Flags
argument_list|)
operator|,
name|SExprID
argument_list|(
literal|0
argument_list|)
operator|,
name|Block
argument_list|(
argument|nullptr
argument_list|)
block|{}
specifier|const
name|unsigned
name|char
name|Opcode
expr_stmt|;
name|unsigned
name|char
name|Reserved
decl_stmt|;
name|unsigned
name|short
name|Flags
decl_stmt|;
name|unsigned
name|SExprID
decl_stmt|;
name|BasicBlock
modifier|*
name|Block
decl_stmt|;
name|private
label|:
name|SExpr
argument_list|()
name|LLVM_DELETED_FUNCTION
expr_stmt|;
comment|/// SExpr objects must be created in an arena.
name|void
modifier|*
name|operator
name|new
argument_list|(
name|size_t
argument_list|)
name|LLVM_DELETED_FUNCTION
decl_stmt|;
block|}
empty_stmt|;
comment|// Contains various helper functions for SExprs.
name|namespace
name|ThreadSafetyTIL
block|{
specifier|inline
name|bool
name|isTrivial
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
name|unsigned
name|Op
init|=
name|E
operator|->
name|opcode
argument_list|()
decl_stmt|;
return|return
name|Op
operator|==
name|COP_Variable
operator|||
name|Op
operator|==
name|COP_Literal
operator|||
name|Op
operator|==
name|COP_LiteralPtr
return|;
block|}
block|}
comment|// Nodes which declare variables
name|class
name|Function
decl_stmt|;
name|class
name|SFunction
decl_stmt|;
name|class
name|Let
decl_stmt|;
comment|/// A named variable, e.g. "x".
comment|///
comment|/// There are two distinct places in which a Variable can appear in the AST.
comment|/// A variable declaration introduces a new variable, and can occur in 3 places:
comment|///   Let-expressions:           (Let (x = t) u)
comment|///   Functions:                 (Function (x : t) u)
comment|///   Self-applicable functions  (SFunction (x) t)
comment|///
comment|/// If a variable occurs in any other location, it is a reference to an existing
comment|/// variable declaration -- e.g. 'x' in (x * y + z). To save space, we don't
comment|/// allocate a separate AST node for variable references; a reference is just a
comment|/// pointer to the original declaration.
name|class
name|Variable
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Variable
return|;
block|}
expr|enum
name|VariableKind
block|{
name|VK_Let
block|,
comment|///< Let-variable
name|VK_Fun
block|,
comment|///< Function parameter
name|VK_SFun
comment|///< SFunction (self) parameter
block|}
block|;
name|Variable
argument_list|(
argument|StringRef s
argument_list|,
argument|SExpr *D = nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Variable
argument_list|)
block|,
name|Name
argument_list|(
name|s
argument_list|)
block|,
name|Definition
argument_list|(
name|D
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{
name|Flags
operator|=
name|VK_Let
block|;   }
name|Variable
argument_list|(
name|SExpr
operator|*
name|D
argument_list|,
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Variable
argument_list|)
block|,
name|Name
argument_list|(
name|Cvd
condition|?
name|Cvd
operator|->
name|getName
argument_list|()
else|:
literal|"_x"
argument_list|)
block|,
name|Definition
argument_list|(
name|D
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|Cvd
argument_list|)
block|{
name|Flags
operator|=
name|VK_Let
block|;   }
name|Variable
argument_list|(
specifier|const
name|Variable
operator|&
name|Vd
argument_list|,
name|SExpr
operator|*
name|D
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|Vd
argument_list|)
block|,
name|Name
argument_list|(
name|Vd
operator|.
name|Name
argument_list|)
block|,
name|Definition
argument_list|(
name|D
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|Vd.Cvdecl
argument_list|)
block|{
name|Flags
operator|=
name|Vd
operator|.
name|kind
argument_list|()
block|;   }
comment|/// Return the kind of variable (let, function param, or self)
name|VariableKind
name|kind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|VariableKind
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
comment|/// Return the name of the variable, if any.
name|StringRef
name|name
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
comment|/// Return the clang declaration for this variable, if any.
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
comment|/// Return the definition of the variable.
comment|/// For let-vars, this is the setting expression.
comment|/// For function and self parameters, it is the type of the variable.
name|SExpr
operator|*
name|definition
argument_list|()
block|{
return|return
name|Definition
return|;
block|}
specifier|const
name|SExpr
operator|*
name|definition
argument_list|()
specifier|const
block|{
return|return
name|Definition
return|;
block|}
name|void
name|setName
argument_list|(
argument|StringRef S
argument_list|)
block|{
name|Name
operator|=
name|S
block|;  }
name|void
name|setKind
argument_list|(
argument|VariableKind K
argument_list|)
block|{
name|Flags
operator|=
name|K
block|; }
name|void
name|setDefinition
argument_list|(
argument|SExpr *E
argument_list|)
block|{
name|Definition
operator|=
name|E
block|; }
name|void
name|setClangDecl
argument_list|(
argument|const clang::ValueDecl *VD
argument_list|)
block|{
name|Cvdecl
operator|=
name|VD
block|; }
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This routine is only called for variable references.
return|return
name|Vs
operator|.
name|reduceVariableRef
argument_list|(
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Variable* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|compareVariableRefs
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|friend
name|class
name|Function
block|;
name|friend
name|class
name|SFunction
block|;
name|friend
name|class
name|BasicBlock
block|;
name|friend
name|class
name|Let
block|;
name|StringRef
name|Name
block|;
comment|// The name of the variable.
name|SExpr
operator|*
name|Definition
block|;
comment|// The TIL type or definition
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
block|;
comment|// The clang declaration for this variable.
block|}
decl_stmt|;
comment|/// Placeholder for an expression that has not yet been created.
comment|/// Used to implement lazy copy and rewriting strategies.
name|class
name|Future
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Future
return|;
block|}
expr|enum
name|FutureStatus
block|{
name|FS_pending
block|,
name|FS_evaluating
block|,
name|FS_done
block|}
block|;
name|Future
argument_list|()
operator|:
name|SExpr
argument_list|(
name|COP_Future
argument_list|)
block|,
name|Status
argument_list|(
name|FS_pending
argument_list|)
block|,
name|Result
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|private
operator|:
name|virtual
operator|~
name|Future
argument_list|()
name|LLVM_DELETED_FUNCTION
block|;
name|public
operator|:
comment|// A lazy rewriting strategy should subclass Future and override this method.
name|virtual
name|SExpr
operator|*
name|compute
argument_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|// Return the result of this future if it exists, otherwise return null.
name|SExpr
operator|*
name|maybeGetResult
argument_list|()
specifier|const
block|{
return|return
name|Result
return|;
block|}
comment|// Return the result of this future; forcing it if necessary.
name|SExpr
operator|*
name|result
argument_list|()
block|{
switch|switch
condition|(
name|Status
condition|)
block|{
case|case
name|FS_pending
case|:
return|return
name|force
argument_list|()
return|;
case|case
name|FS_evaluating
case|:
return|return
name|nullptr
return|;
comment|// infinite loop; illegal recursion.
case|case
name|FS_done
case|:
return|return
name|Result
return|;
block|}
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|assert
argument_list|(
name|Result
operator|&&
literal|"Cannot traverse Future that has not been forced."
argument_list|)
block|;
return|return
name|Vs
operator|.
name|traverse
argument_list|(
name|Result
argument_list|,
name|Ctx
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Future* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|Result
operator|||
operator|!
name|E
operator|->
name|Result
condition|)
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|Result
argument_list|,
name|E
operator|->
name|Result
argument_list|)
return|;
block|}
name|private
label|:
name|SExpr
modifier|*
name|force
parameter_list|()
function_decl|;
name|FutureStatus
name|Status
decl_stmt|;
name|SExpr
modifier|*
name|Result
decl_stmt|;
block|}
empty_stmt|;
comment|/// Placeholder for expressions that cannot be represented in the TIL.
name|class
name|Undefined
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Undefined
return|;
block|}
name|Undefined
argument_list|(
specifier|const
name|clang
operator|::
name|Stmt
operator|*
name|S
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Undefined
argument_list|)
block|,
name|Cstmt
argument_list|(
argument|S
argument_list|)
block|{}
name|Undefined
argument_list|(
specifier|const
name|Undefined
operator|&
name|U
argument_list|)
operator|:
name|SExpr
argument_list|(
name|U
argument_list|)
block|,
name|Cstmt
argument_list|(
argument|U.Cstmt
argument_list|)
block|{}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceUndefined
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Undefined* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|trueResult
argument_list|()
return|;
block|}
name|private
operator|:
specifier|const
name|clang
operator|::
name|Stmt
operator|*
name|Cstmt
block|; }
decl_stmt|;
comment|/// Placeholder for a wildcard that matches any other expression.
name|class
name|Wildcard
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Wildcard
return|;
block|}
name|Wildcard
argument_list|()
operator|:
name|SExpr
argument_list|(
argument|COP_Wildcard
argument_list|)
block|{}
name|Wildcard
argument_list|(
specifier|const
name|Wildcard
operator|&
name|W
argument_list|)
operator|:
name|SExpr
argument_list|(
argument|W
argument_list|)
block|{}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceWildcard
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Wildcard* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|trueResult
argument_list|()
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|T
operator|>
name|class
name|LiteralT
block|;
comment|// Base class for literal values.
name|class
name|Literal
operator|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Literal
return|;
block|}
name|Literal
argument_list|(
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|C
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Literal
argument_list|)
block|,
name|ValType
argument_list|(
name|ValueType
operator|::
name|getValueType
operator|<
name|void
operator|>
operator|(
operator|)
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|C
argument_list|)
block|{ }
name|Literal
argument_list|(
argument|ValueType VT
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Literal
argument_list|)
block|,
name|ValType
argument_list|(
name|VT
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|Literal
argument_list|(
specifier|const
name|Literal
operator|&
name|L
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|ValType
argument_list|(
name|L
operator|.
name|ValType
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|L.Cexpr
argument_list|)
block|{}
comment|// The clang expression for this literal.
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|clangExpr
argument_list|()
specifier|const
block|{
return|return
name|Cexpr
return|;
block|}
name|ValueType
name|valueType
argument_list|()
specifier|const
block|{
return|return
name|ValType
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|as
argument_list|()
specifier|const
block|{
return|return
operator|*
name|static_cast
operator|<
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|as
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|LiteralT
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|;
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Literal* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: defer actual comparison to LiteralT
return|return
name|Cmp
operator|.
name|trueResult
argument_list|()
return|;
block|}
name|private
operator|:
specifier|const
name|ValueType
name|ValType
block|;
specifier|const
name|clang
operator|::
name|Expr
operator|*
name|Cexpr
block|; }
block|;
comment|// Derived class for literal values, which stores the actual value.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|LiteralT
operator|:
name|public
name|Literal
block|{
name|public
operator|:
name|LiteralT
argument_list|(
argument|T Dat
argument_list|)
operator|:
name|Literal
argument_list|(
name|ValueType
operator|::
name|getValueType
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
block|,
name|Val
argument_list|(
argument|Dat
argument_list|)
block|{ }
name|LiteralT
argument_list|(
specifier|const
name|LiteralT
operator|<
name|T
operator|>
operator|&
name|L
argument_list|)
operator|:
name|Literal
argument_list|(
name|L
argument_list|)
block|,
name|Val
argument_list|(
argument|L.Val
argument_list|)
block|{ }
name|T
name|value
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|T
operator|&
name|value
argument_list|()
block|{
return|return
name|Val
return|;
block|}
name|private
operator|:
name|T
name|Val
block|; }
block|;
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|Literal
operator|::
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
if|if
condition|(
name|Cexpr
condition|)
return|return
name|Vs
operator|.
name|reduceLiteral
argument_list|(
operator|*
name|this
argument_list|)
return|;
switch|switch
condition|(
name|ValType
operator|.
name|Base
condition|)
block|{
case|case
name|ValueType
operator|::
name|BT_Void
case|:
break|break;
case|case
name|ValueType
operator|::
name|BT_Bool
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|bool
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|BT_Int
case|:
block|{
switch|switch
condition|(
name|ValType
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_8
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int8_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint8_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_16
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int16_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint16_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_32
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int32_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint32_t
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_64
case|:
if|if
condition|(
name|ValType
operator|.
name|Signed
condition|)
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|int64_t
operator|>
operator|(
operator|)
argument_list|)
return|;
else|else
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|uint64_t
operator|>
operator|(
operator|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
case|case
name|ValueType
operator|::
name|BT_Float
case|:
block|{
switch|switch
condition|(
name|ValType
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_32
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|float
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|ST_64
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|double
operator|>
operator|(
operator|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
case|case
name|ValueType
operator|::
name|BT_String
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|StringRef
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|BT_Pointer
case|:
return|return
name|Vs
operator|.
name|reduceLiteralT
argument_list|(
name|as
operator|<
name|void
operator|*
operator|>
operator|(
operator|)
argument_list|)
return|;
case|case
name|ValueType
operator|::
name|BT_ValueRef
case|:
break|break;
block|}
return|return
name|Vs
operator|.
name|reduceLiteral
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// A Literal pointer to an object allocated in memory.
end_comment

begin_comment
comment|/// At compile time, pointer literals are represented by symbolic names.
end_comment

begin_decl_stmt
name|class
name|LiteralPtr
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_LiteralPtr
return|;
block|}
name|LiteralPtr
argument_list|(
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|D
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_LiteralPtr
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|D
argument_list|)
block|{}
name|LiteralPtr
argument_list|(
specifier|const
name|LiteralPtr
operator|&
name|R
argument_list|)
operator|:
name|SExpr
argument_list|(
name|R
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|R.Cvdecl
argument_list|)
block|{}
comment|// The clang declaration for the value that this pointer points to.
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceLiteralPtr
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const LiteralPtr* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cvdecl
argument_list|,
name|E
operator|->
name|Cvdecl
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// A function -- a.k.a. lambda abstraction.
end_comment

begin_comment
comment|/// Functions with multiple arguments are created by currying,
end_comment

begin_comment
comment|/// e.g. (Function (x: Int) (Function (y: Int) (Code { return x + y })))
end_comment

begin_decl_stmt
name|class
name|Function
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Function
return|;
block|}
name|Function
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Function
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Fun
argument_list|)
block|;   }
name|Function
argument_list|(
specifier|const
name|Function
operator|&
name|F
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|F
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Fun
argument_list|)
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This is a variable declaration, so traverse the definition.
name|auto
name|E0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|VarDecl
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
comment|// Tell the rewriter to enter the scope of the function.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|E0
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceFunction
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Function* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|,
name|E
operator|->
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|Variable
modifier|*
name|VarDecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// A self-applicable function.
end_comment

begin_comment
comment|/// A self-applicable function can be applied to itself.  It's useful for
end_comment

begin_comment
comment|/// implementing objects and late binding.
end_comment

begin_decl_stmt
name|class
name|SFunction
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SFunction
return|;
block|}
name|SFunction
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_SFunction
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|Vd
operator|->
name|Definition
operator|==
name|nullptr
argument_list|)
block|;
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_SFun
argument_list|)
block|;
name|Vd
operator|->
name|Definition
operator|=
name|this
block|;   }
name|SFunction
argument_list|(
specifier|const
name|SFunction
operator|&
name|F
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|F
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{
name|assert
argument_list|(
name|Vd
operator|->
name|Definition
operator|==
name|nullptr
argument_list|)
block|;
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_SFun
argument_list|)
block|;
name|Vd
operator|->
name|Definition
operator|=
name|this
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// A self-variable points to the SFunction itself.
comment|// A rewrite must introduce the variable with a null definition, and update
comment|// it after 'this' has been rewritten.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|nullptr
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
comment|// A rewrite operation will call SFun constructor to set Vvd->Definition.
return|return
name|Vs
operator|.
name|reduceSFunction
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const SFunction* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
name|private
operator|:
name|Variable
operator|*
name|VarDecl
block|;
name|SExpr
operator|*
name|Body
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// A block of code -- e.g. the body of a function.
end_comment

begin_decl_stmt
name|class
name|Code
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Code
return|;
block|}
name|Code
argument_list|(
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Code
argument_list|)
block|,
name|ReturnType
argument_list|(
name|T
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|Code
argument_list|(
specifier|const
name|Code
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|ReturnType
argument_list|(
name|T
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|SExpr
operator|*
name|returnType
argument_list|()
block|{
return|return
name|ReturnType
return|;
block|}
specifier|const
name|SExpr
operator|*
name|returnType
argument_list|()
specifier|const
block|{
return|return
name|ReturnType
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ReturnType
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nb
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|lazyCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCode
argument_list|(
operator|*
name|this
argument_list|,
name|Nt
argument_list|,
name|Nb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Code* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|returnType
argument_list|()
argument_list|,
name|E
operator|->
name|returnType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|ReturnType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// A typed, writable location in memory
end_comment

begin_decl_stmt
name|class
name|Field
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Field
return|;
block|}
name|Field
argument_list|(
name|SExpr
operator|*
name|R
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Field
argument_list|)
block|,
name|Range
argument_list|(
name|R
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|Field
argument_list|(
specifier|const
name|Field
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|R
argument_list|,
name|SExpr
operator|*
name|B
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Range
argument_list|(
name|R
argument_list|)
block|,
name|Body
argument_list|(
argument|B
argument_list|)
block|{}
name|SExpr
operator|*
name|range
argument_list|()
block|{
return|return
name|Range
return|;
block|}
specifier|const
name|SExpr
operator|*
name|range
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nr
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Range
argument_list|,
name|Vs
operator|.
name|typeCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nb
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Vs
operator|.
name|lazyCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceField
argument_list|(
operator|*
name|this
argument_list|,
name|Nr
argument_list|,
name|Nb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Field* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|range
argument_list|()
argument_list|,
name|E
operator|->
name|range
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Body
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Apply an argument to a function.
end_comment

begin_comment
comment|/// Note that this does not actually call the function.  Functions are curried,
end_comment

begin_comment
comment|/// so this returns a closure in which the first parameter has been applied.
end_comment

begin_comment
comment|/// Once all parameters have been applied, Call can be used to invoke the
end_comment

begin_comment
comment|/// function.
end_comment

begin_decl_stmt
name|class
name|Apply
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Apply
return|;
block|}
name|Apply
argument_list|(
name|SExpr
operator|*
name|F
argument_list|,
name|SExpr
operator|*
name|A
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Apply
argument_list|)
block|,
name|Fun
argument_list|(
name|F
argument_list|)
block|,
name|Arg
argument_list|(
argument|A
argument_list|)
block|{}
name|Apply
argument_list|(
specifier|const
name|Apply
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|F
argument_list|,
name|SExpr
operator|*
name|Ar
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Fun
argument_list|(
name|F
argument_list|)
block|,
name|Arg
argument_list|(
argument|Ar
argument_list|)
block|{}
name|SExpr
operator|*
name|fun
argument_list|()
block|{
return|return
name|Fun
return|;
block|}
specifier|const
name|SExpr
operator|*
name|fun
argument_list|()
specifier|const
block|{
return|return
name|Fun
return|;
block|}
name|SExpr
operator|*
name|arg
argument_list|()
block|{
return|return
name|Arg
return|;
block|}
specifier|const
name|SExpr
operator|*
name|arg
argument_list|()
specifier|const
block|{
return|return
name|Arg
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nf
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Fun
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Arg
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceApply
argument_list|(
operator|*
name|this
argument_list|,
name|Nf
argument_list|,
name|Na
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Apply* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|fun
argument_list|()
argument_list|,
name|E
operator|->
name|fun
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|arg
argument_list|()
argument_list|,
name|E
operator|->
name|arg
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Fun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Arg
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Apply a self-argument to a self-applicable function.
end_comment

begin_decl_stmt
name|class
name|SApply
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SApply
return|;
block|}
name|SApply
argument_list|(
name|SExpr
operator|*
name|Sf
argument_list|,
name|SExpr
operator|*
name|A
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_SApply
argument_list|)
block|,
name|Sfun
argument_list|(
name|Sf
argument_list|)
block|,
name|Arg
argument_list|(
argument|A
argument_list|)
block|{}
name|SApply
argument_list|(
name|SApply
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|Sf
argument_list|,
name|SExpr
operator|*
name|Ar
operator|=
name|nullptr
argument_list|)
comment|// rewrite constructor
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Sfun
argument_list|(
name|Sf
argument_list|)
block|,
name|Arg
argument_list|(
argument|Ar
argument_list|)
block|{}
name|SExpr
operator|*
name|sfun
argument_list|()
block|{
return|return
name|Sfun
return|;
block|}
specifier|const
name|SExpr
operator|*
name|sfun
argument_list|()
specifier|const
block|{
return|return
name|Sfun
return|;
block|}
name|SExpr
operator|*
name|arg
argument_list|()
block|{
return|return
name|Arg
operator|?
name|Arg
operator|:
name|Sfun
return|;
block|}
specifier|const
name|SExpr
operator|*
name|arg
argument_list|()
specifier|const
block|{
return|return
name|Arg
condition|?
name|Arg
else|:
name|Sfun
return|;
block|}
name|bool
name|isDelegation
argument_list|()
specifier|const
block|{
return|return
name|Arg
operator|!=
name|nullptr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nf
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Sfun
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|typename
name|V
operator|::
name|R_SExpr
name|Na
operator|=
name|Arg
condition|?
name|Vs
operator|.
name|traverse
argument_list|(
name|Arg
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
else|:
name|nullptr
block|;
return|return
name|Vs
operator|.
name|reduceSApply
argument_list|(
operator|*
name|this
argument_list|,
name|Nf
argument_list|,
name|Na
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const SApply* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|sfun
argument_list|()
argument_list|,
name|E
operator|->
name|sfun
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
operator|||
operator|(
operator|!
name|arg
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|arg
argument_list|()
operator|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|arg
argument_list|()
argument_list|,
name|E
operator|->
name|arg
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Sfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Arg
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Project a named slot from a C++ struct or class.
end_comment

begin_decl_stmt
name|class
name|Project
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Project
return|;
block|}
name|Project
argument_list|(
argument|SExpr *R
argument_list|,
argument|StringRef SName
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Project
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|SName
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|Project
argument_list|(
name|SExpr
operator|*
name|R
argument_list|,
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Project
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|Cvd
operator|->
name|getName
argument_list|()
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|Cvd
argument_list|)
block|{ }
name|Project
argument_list|(
specifier|const
name|Project
operator|&
name|P
argument_list|,
name|SExpr
operator|*
name|R
argument_list|)
operator|:
name|SExpr
argument_list|(
name|P
argument_list|)
block|,
name|Rec
argument_list|(
name|R
argument_list|)
block|,
name|SlotName
argument_list|(
name|P
operator|.
name|SlotName
argument_list|)
block|,
name|Cvdecl
argument_list|(
argument|P.Cvdecl
argument_list|)
block|{ }
name|SExpr
operator|*
name|record
argument_list|()
block|{
return|return
name|Rec
return|;
block|}
specifier|const
name|SExpr
operator|*
name|record
argument_list|()
specifier|const
block|{
return|return
name|Rec
return|;
block|}
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
name|bool
name|isArrow
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Flags
operator|&
literal|0x01
operator|)
operator|!=
literal|0
return|;
block|}
name|void
name|setArrow
argument_list|(
argument|bool b
argument_list|)
block|{
if|if
condition|(
name|b
condition|)
name|Flags
operator||=
literal|0x01
expr_stmt|;
else|else
name|Flags
operator|&=
literal|0xFFFE
expr_stmt|;
block|}
name|StringRef
name|slotName
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Cvdecl
condition|)
return|return
name|Cvdecl
operator|->
name|getName
argument_list|()
return|;
else|else
return|return
name|SlotName
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nr
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Rec
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceProject
argument_list|(
operator|*
name|this
argument_list|,
name|Nr
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Project* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|record
argument_list|()
argument_list|,
name|E
operator|->
name|record
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|Cvdecl
argument_list|,
name|E
operator|->
name|Cvdecl
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Rec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|SlotName
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// Call a function (after all arguments have been applied).
end_comment

begin_decl_stmt
name|class
name|Call
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Call
return|;
block|}
name|Call
argument_list|(
name|SExpr
operator|*
name|T
argument_list|,
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|Ce
operator|=
name|nullptr
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Call
argument_list|)
block|,
name|Target
argument_list|(
name|T
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|Ce
argument_list|)
block|{}
name|Call
argument_list|(
specifier|const
name|Call
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|)
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Target
argument_list|(
name|T
argument_list|)
block|,
name|Cexpr
argument_list|(
argument|C.Cexpr
argument_list|)
block|{}
name|SExpr
operator|*
name|target
argument_list|()
block|{
return|return
name|Target
return|;
block|}
specifier|const
name|SExpr
operator|*
name|target
argument_list|()
specifier|const
block|{
return|return
name|Target
return|;
block|}
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|clangCallExpr
argument_list|()
specifier|const
block|{
return|return
name|Cexpr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Target
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCall
argument_list|(
operator|*
name|this
argument_list|,
name|Nt
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Call* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|target
argument_list|()
argument_list|,
name|E
operator|->
name|target
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|SExpr
operator|*
name|Target
block|;
specifier|const
name|clang
operator|::
name|CallExpr
operator|*
name|Cexpr
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Allocate memory for a new value on the heap or stack.
end_comment

begin_decl_stmt
name|class
name|Alloc
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Call
return|;
block|}
expr|enum
name|AllocKind
block|{
name|AK_Stack
block|,
name|AK_Heap
block|}
block|;
name|Alloc
argument_list|(
argument|SExpr *D
argument_list|,
argument|AllocKind K
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Alloc
argument_list|)
block|,
name|Dtype
argument_list|(
argument|D
argument_list|)
block|{
name|Flags
operator|=
name|K
block|; }
name|Alloc
argument_list|(
specifier|const
name|Alloc
operator|&
name|A
argument_list|,
name|SExpr
operator|*
name|Dt
argument_list|)
operator|:
name|SExpr
argument_list|(
name|A
argument_list|)
block|,
name|Dtype
argument_list|(
argument|Dt
argument_list|)
block|{
name|Flags
operator|=
name|A
operator|.
name|kind
argument_list|()
block|; }
name|AllocKind
name|kind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|AllocKind
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|dataType
argument_list|()
block|{
return|return
name|Dtype
return|;
block|}
specifier|const
name|SExpr
operator|*
name|dataType
argument_list|()
specifier|const
block|{
return|return
name|Dtype
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nd
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Dtype
argument_list|,
name|Vs
operator|.
name|declCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceAlloc
argument_list|(
operator|*
name|this
argument_list|,
name|Nd
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Alloc* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|kind
argument_list|()
argument_list|,
name|E
operator|->
name|kind
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|dataType
argument_list|()
argument_list|,
name|E
operator|->
name|dataType
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Dtype
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Load a value from memory.
end_comment

begin_decl_stmt
name|class
name|Load
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Load
return|;
block|}
name|Load
argument_list|(
name|SExpr
operator|*
name|P
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Load
argument_list|)
block|,
name|Ptr
argument_list|(
argument|P
argument_list|)
block|{}
name|Load
argument_list|(
specifier|const
name|Load
operator|&
name|L
argument_list|,
name|SExpr
operator|*
name|P
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|Ptr
argument_list|(
argument|P
argument_list|)
block|{}
name|SExpr
operator|*
name|pointer
argument_list|()
block|{
return|return
name|Ptr
return|;
block|}
specifier|const
name|SExpr
operator|*
name|pointer
argument_list|()
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Np
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Ptr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceLoad
argument_list|(
operator|*
name|this
argument_list|,
name|Np
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Load* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|pointer
argument_list|()
argument_list|,
name|E
operator|->
name|pointer
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|SExpr
operator|*
name|Ptr
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Store a value to memory.
end_comment

begin_comment
comment|/// The destination is a pointer to a field, the source is the value to store.
end_comment

begin_decl_stmt
name|class
name|Store
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Store
return|;
block|}
name|Store
argument_list|(
name|SExpr
operator|*
name|P
argument_list|,
name|SExpr
operator|*
name|V
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Store
argument_list|)
block|,
name|Dest
argument_list|(
name|P
argument_list|)
block|,
name|Source
argument_list|(
argument|V
argument_list|)
block|{}
name|Store
argument_list|(
specifier|const
name|Store
operator|&
name|S
argument_list|,
name|SExpr
operator|*
name|P
argument_list|,
name|SExpr
operator|*
name|V
argument_list|)
operator|:
name|SExpr
argument_list|(
name|S
argument_list|)
block|,
name|Dest
argument_list|(
name|P
argument_list|)
block|,
name|Source
argument_list|(
argument|V
argument_list|)
block|{}
name|SExpr
operator|*
name|destination
argument_list|()
block|{
return|return
name|Dest
return|;
block|}
comment|// Address to store to
specifier|const
name|SExpr
operator|*
name|destination
argument_list|()
specifier|const
block|{
return|return
name|Dest
return|;
block|}
name|SExpr
operator|*
name|source
argument_list|()
block|{
return|return
name|Source
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|source
argument_list|()
specifier|const
block|{
return|return
name|Source
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Np
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Dest
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nv
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Source
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceStore
argument_list|(
operator|*
name|this
argument_list|,
name|Np
argument_list|,
name|Nv
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Store* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|destination
argument_list|()
argument_list|,
name|E
operator|->
name|destination
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|source
argument_list|()
argument_list|,
name|E
operator|->
name|source
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Dest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Source
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// If p is a reference to an array, then p[i] is a reference to the i'th
end_comment

begin_comment
comment|/// element of the array.
end_comment

begin_decl_stmt
name|class
name|ArrayIndex
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_ArrayIndex
return|;
block|}
name|ArrayIndex
argument_list|(
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_ArrayIndex
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|ArrayIndex
argument_list|(
specifier|const
name|ArrayIndex
operator|&
name|E
argument_list|,
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|E
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|SExpr
operator|*
name|array
argument_list|()
block|{
return|return
name|Array
return|;
block|}
specifier|const
name|SExpr
operator|*
name|array
argument_list|()
specifier|const
block|{
return|return
name|Array
return|;
block|}
name|SExpr
operator|*
name|index
argument_list|()
block|{
return|return
name|Index
return|;
block|}
specifier|const
name|SExpr
operator|*
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Array
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ni
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Index
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceArrayIndex
argument_list|(
operator|*
name|this
argument_list|,
name|Na
argument_list|,
name|Ni
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const ArrayIndex* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|array
argument_list|()
argument_list|,
name|E
operator|->
name|array
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|index
argument_list|()
argument_list|,
name|E
operator|->
name|index
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Index
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Pointer arithmetic, restricted to arrays only.
end_comment

begin_comment
comment|/// If p is a reference to an array, then p + n, where n is an integer, is
end_comment

begin_comment
comment|/// a reference to a subarray.
end_comment

begin_decl_stmt
name|class
name|ArrayAdd
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_ArrayAdd
return|;
block|}
name|ArrayAdd
argument_list|(
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_ArrayAdd
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|ArrayAdd
argument_list|(
specifier|const
name|ArrayAdd
operator|&
name|E
argument_list|,
name|SExpr
operator|*
name|A
argument_list|,
name|SExpr
operator|*
name|N
argument_list|)
operator|:
name|SExpr
argument_list|(
name|E
argument_list|)
block|,
name|Array
argument_list|(
name|A
argument_list|)
block|,
name|Index
argument_list|(
argument|N
argument_list|)
block|{}
name|SExpr
operator|*
name|array
argument_list|()
block|{
return|return
name|Array
return|;
block|}
specifier|const
name|SExpr
operator|*
name|array
argument_list|()
specifier|const
block|{
return|return
name|Array
return|;
block|}
name|SExpr
operator|*
name|index
argument_list|()
block|{
return|return
name|Index
return|;
block|}
specifier|const
name|SExpr
operator|*
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Na
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Array
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ni
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Index
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceArrayAdd
argument_list|(
operator|*
name|this
argument_list|,
name|Na
argument_list|,
name|Ni
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const ArrayAdd* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|array
argument_list|()
argument_list|,
name|E
operator|->
name|array
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|index
argument_list|()
argument_list|,
name|E
operator|->
name|index
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Index
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Simple arithmetic unary operations, e.g. negate and not.
end_comment

begin_comment
comment|/// These operations have no side-effects.
end_comment

begin_decl_stmt
name|class
name|UnaryOp
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_UnaryOp
return|;
block|}
name|UnaryOp
argument_list|(
argument|TIL_UnaryOpcode Op
argument_list|,
argument|SExpr *E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_UnaryOp
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|;   }
name|UnaryOp
argument_list|(
specifier|const
name|UnaryOp
operator|&
name|U
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|U
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|U
operator|.
name|Flags
block|; }
name|TIL_UnaryOpcode
name|unaryOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_UnaryOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr
argument_list|()
block|{
return|return
name|Expr0
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr
argument_list|()
specifier|const
block|{
return|return
name|Expr0
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceUnaryOp
argument_list|(
operator|*
name|this
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const UnaryOp* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|unaryOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|unaryOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr
argument_list|()
argument_list|,
name|E
operator|->
name|expr
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Expr0
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Simple arithmetic binary operations, e.g. +, -, etc.
end_comment

begin_comment
comment|/// These operations have no side effects.
end_comment

begin_decl_stmt
name|class
name|BinaryOp
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_BinaryOp
return|;
block|}
name|BinaryOp
argument_list|(
argument|TIL_BinaryOpcode Op
argument_list|,
argument|SExpr *E0
argument_list|,
argument|SExpr *E1
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_BinaryOp
argument_list|)
block|,
name|Expr0
argument_list|(
name|E0
argument_list|)
block|,
name|Expr1
argument_list|(
argument|E1
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|;   }
name|BinaryOp
argument_list|(
specifier|const
name|BinaryOp
operator|&
name|B
argument_list|,
name|SExpr
operator|*
name|E0
argument_list|,
name|SExpr
operator|*
name|E1
argument_list|)
operator|:
name|SExpr
argument_list|(
name|B
argument_list|)
block|,
name|Expr0
argument_list|(
name|E0
argument_list|)
block|,
name|Expr1
argument_list|(
argument|E1
argument_list|)
block|{
name|Flags
operator|=
name|B
operator|.
name|Flags
block|;   }
name|TIL_BinaryOpcode
name|binaryOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_BinaryOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr0
argument_list|()
block|{
return|return
name|Expr0
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr0
argument_list|()
specifier|const
block|{
return|return
name|Expr0
return|;
block|}
name|SExpr
operator|*
name|expr1
argument_list|()
block|{
return|return
name|Expr1
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr1
argument_list|()
specifier|const
block|{
return|return
name|Expr1
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ne1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr1
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceBinaryOp
argument_list|(
operator|*
name|this
argument_list|,
name|Ne0
argument_list|,
name|Ne1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const BinaryOp* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|binaryOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|binaryOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|expr0
argument_list|()
argument_list|,
name|E
operator|->
name|expr0
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
end_decl_stmt

begin_return
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr1
argument_list|()
argument_list|,
name|E
operator|->
name|expr1
argument_list|()
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}  private:
name|SExpr
modifier|*
name|Expr0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Expr1
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// Cast expressions.
end_comment

begin_comment
comment|/// Cast expressions are essentially unary operations, but we treat them
end_comment

begin_comment
comment|/// as a distinct AST node because they only change the type of the result.
end_comment

begin_decl_stmt
name|class
name|Cast
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Cast
return|;
block|}
name|Cast
argument_list|(
argument|TIL_CastOpcode Op
argument_list|,
argument|SExpr *E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Cast
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|Op
block|; }
name|Cast
argument_list|(
specifier|const
name|Cast
operator|&
name|C
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|C
argument_list|)
block|,
name|Expr0
argument_list|(
argument|E
argument_list|)
block|{
name|Flags
operator|=
name|C
operator|.
name|Flags
block|; }
name|TIL_CastOpcode
name|castOpcode
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|TIL_CastOpcode
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
name|SExpr
operator|*
name|expr
argument_list|()
block|{
return|return
name|Expr0
return|;
block|}
specifier|const
name|SExpr
operator|*
name|expr
argument_list|()
specifier|const
block|{
return|return
name|Expr0
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Expr0
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceCast
argument_list|(
operator|*
name|this
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Cast* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compareIntegers
argument_list|(
name|castOpcode
argument_list|()
argument_list|,
name|E
operator|->
name|castOpcode
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|expr
argument_list|()
argument_list|,
name|E
operator|->
name|expr
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SExpr
modifier|*
name|Expr0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|SCFG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Phi Node, for code in SSA form.
end_comment

begin_comment
comment|/// Each Phi node has an array of possible values that it can take,
end_comment

begin_comment
comment|/// depending on where control flow comes from.
end_comment

begin_decl_stmt
name|class
name|Phi
range|:
name|public
name|SExpr
block|{
name|public
operator|:
typedef|typedef
name|SimpleArray
operator|<
name|SExpr
operator|*
operator|>
name|ValArray
expr_stmt|;
comment|// In minimal SSA form, all Phi nodes are MultiVal.
comment|// During conversion to SSA, incomplete Phi nodes may be introduced, which
comment|// are later determined to be SingleVal, and are thus redundant.
block|enum
name|Status
block|{
name|PH_MultiVal
operator|=
literal|0
block|,
comment|// Phi node has multiple distinct values.  (Normal)
name|PH_SingleVal
block|,
comment|// Phi node has one distinct value, and can be eliminated
name|PH_Incomplete
comment|// Phi node is incomplete
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Phi
return|;
block|}
end_function

begin_expr_stmt
name|Phi
argument_list|()
operator|:
name|SExpr
argument_list|(
name|COP_Phi
argument_list|)
operator|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|Phi
argument_list|(
argument|MemRegionRef A
argument_list|,
argument|unsigned Nvals
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Phi
argument_list|)
operator|,
name|Values
argument_list|(
name|A
argument_list|,
name|Nvals
argument_list|)
operator|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|Phi
argument_list|(
specifier|const
name|Phi
operator|&
name|P
argument_list|,
name|ValArray
operator|&&
name|Vs
argument_list|)
operator|:
name|SExpr
argument_list|(
name|P
argument_list|)
operator|,
name|Values
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Vs
argument_list|)
argument_list|)
operator|,
name|Cvdecl
argument_list|(
argument|nullptr
argument_list|)
block|{}
specifier|const
name|ValArray
operator|&
name|values
argument_list|()
specifier|const
block|{
return|return
name|Values
return|;
block|}
end_expr_stmt

begin_function
name|ValArray
modifier|&
name|values
parameter_list|()
block|{
return|return
name|Values
return|;
block|}
end_function

begin_expr_stmt
name|Status
name|status
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|Status
operator|>
operator|(
name|Flags
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setStatus
parameter_list|(
name|Status
name|s
parameter_list|)
block|{
name|Flags
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Return the clang declaration of the variable for this Phi node, if any.
end_comment

begin_expr_stmt
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|clangDecl
argument_list|()
specifier|const
block|{
return|return
name|Cvdecl
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Set the clang variable associated with this Phi node.
end_comment

begin_decl_stmt
name|void
name|setClangDecl
argument_list|(
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvd
argument_list|)
block|{
name|Cvdecl
operator|=
name|Cvd
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|typename
name|V
operator|::
name|R_SExpr
operator|>
name|Nvs
argument_list|(
name|Vs
argument_list|,
name|Values
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|Val
operator|:
name|Values
control|)
block|{
name|Nvs
operator|.
name|push_back
argument_list|(
name|Vs
operator|.
name|traverse
argument_list|(
name|Val
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reducePhi
argument_list|(
operator|*
name|this
argument_list|,
name|Nvs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Phi *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|ValArray
name|Values
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|clang
operator|::
name|ValueDecl
operator|*
name|Cvdecl
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// Base class for basic block terminators:  Branch, Goto, and Return.
end_comment

begin_decl_stmt
name|class
name|Terminator
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|>=
name|COP_Goto
operator|&&
name|E
operator|->
name|opcode
argument_list|()
operator|<=
name|COP_Return
return|;
block|}
name|protected
operator|:
name|Terminator
argument_list|(
argument|TIL_Opcode Op
argument_list|)
operator|:
name|SExpr
argument_list|(
argument|Op
argument_list|)
block|{}
name|Terminator
argument_list|(
specifier|const
name|SExpr
operator|&
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
argument|E
argument_list|)
block|{}
name|public
operator|:
comment|/// Return the list of basic blocks that this terminator can branch to.
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
block|;
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Terminator
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|successors
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// Jump to another basic block.
comment|/// A goto instruction is essentially a tail-recursive call into another
comment|/// block.  In addition to the block pointer, it specifies an index into the
comment|/// phi nodes of that block.  The index can be used to retrieve the "arguments"
comment|/// of the call.
name|class
name|Goto
operator|:
name|public
name|Terminator
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Goto
return|;
block|}
name|Goto
argument_list|(
argument|BasicBlock *B
argument_list|,
argument|unsigned I
argument_list|)
operator|:
name|Terminator
argument_list|(
name|COP_Goto
argument_list|)
block|,
name|TargetBlock
argument_list|(
name|B
argument_list|)
block|,
name|Index
argument_list|(
argument|I
argument_list|)
block|{}
name|Goto
argument_list|(
argument|const Goto&G
argument_list|,
argument|BasicBlock *B
argument_list|,
argument|unsigned I
argument_list|)
operator|:
name|Terminator
argument_list|(
name|COP_Goto
argument_list|)
block|,
name|TargetBlock
argument_list|(
name|B
argument_list|)
block|,
name|Index
argument_list|(
argument|I
argument_list|)
block|{}
specifier|const
name|BasicBlock
operator|*
name|targetBlock
argument_list|()
specifier|const
block|{
return|return
name|TargetBlock
return|;
block|}
name|BasicBlock
operator|*
name|targetBlock
argument_list|()
block|{
return|return
name|TargetBlock
return|;
block|}
comment|/// Returns the index into the
name|unsigned
name|index
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
comment|/// Return the list of basic blocks that this terminator can branch to.
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
block|{
return|return
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
operator|(
operator|&
name|TargetBlock
expr|,
literal|1
operator|)
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|BasicBlock
operator|*
name|Ntb
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|TargetBlock
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceGoto
argument_list|(
operator|*
name|this
argument_list|,
name|Ntb
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Goto *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|BasicBlock
operator|*
name|TargetBlock
block|;
name|unsigned
name|Index
block|; }
block|;
comment|/// A conditional branch to two other blocks.
comment|/// Note that unlike Goto, Branch does not have an index.  The target blocks
comment|/// must be child-blocks, and cannot have Phi nodes.
name|class
name|Branch
operator|:
name|public
name|Terminator
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Branch
return|;
block|}
name|Branch
argument_list|(
name|SExpr
operator|*
name|C
argument_list|,
name|BasicBlock
operator|*
name|T
argument_list|,
name|BasicBlock
operator|*
name|E
argument_list|)
operator|:
name|Terminator
argument_list|(
name|COP_Branch
argument_list|)
block|,
name|Condition
argument_list|(
argument|C
argument_list|)
block|{
name|Branches
index|[
literal|0
index|]
operator|=
name|T
block|;
name|Branches
index|[
literal|1
index|]
operator|=
name|E
block|;   }
name|Branch
argument_list|(
specifier|const
name|Branch
operator|&
name|Br
argument_list|,
name|SExpr
operator|*
name|C
argument_list|,
name|BasicBlock
operator|*
name|T
argument_list|,
name|BasicBlock
operator|*
name|E
argument_list|)
operator|:
name|Terminator
argument_list|(
name|Br
argument_list|)
block|,
name|Condition
argument_list|(
argument|C
argument_list|)
block|{
name|Branches
index|[
literal|0
index|]
operator|=
name|T
block|;
name|Branches
index|[
literal|1
index|]
operator|=
name|E
block|;   }
specifier|const
name|SExpr
operator|*
name|condition
argument_list|()
specifier|const
block|{
return|return
name|Condition
return|;
block|}
name|SExpr
operator|*
name|condition
argument_list|()
block|{
return|return
name|Condition
return|;
block|}
specifier|const
name|BasicBlock
operator|*
name|thenBlock
argument_list|()
specifier|const
block|{
return|return
name|Branches
index|[
literal|0
index|]
return|;
block|}
name|BasicBlock
operator|*
name|thenBlock
argument_list|()
block|{
return|return
name|Branches
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|BasicBlock
operator|*
name|elseBlock
argument_list|()
specifier|const
block|{
return|return
name|Branches
index|[
literal|1
index|]
return|;
block|}
name|BasicBlock
operator|*
name|elseBlock
argument_list|()
block|{
return|return
name|Branches
index|[
literal|1
index|]
return|;
block|}
comment|/// Return the list of basic blocks that this terminator can branch to.
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
block|{
return|return
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
operator|(
name|Branches
expr|,
literal|2
operator|)
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nc
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Condition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|BasicBlock
operator|*
name|Ntb
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|Branches
index|[
literal|0
index|]
argument_list|)
block|;
name|BasicBlock
operator|*
name|Nte
operator|=
name|Vs
operator|.
name|reduceBasicBlockRef
argument_list|(
name|Branches
index|[
literal|1
index|]
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceBranch
argument_list|(
operator|*
name|this
argument_list|,
name|Nc
argument_list|,
name|Ntb
argument_list|,
name|Nte
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Branch *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
name|private
operator|:
name|SExpr
operator|*
name|Condition
block|;
name|BasicBlock
operator|*
name|Branches
index|[
literal|2
index|]
block|; }
block|;
comment|/// Return from the enclosing function, passing the return value to the caller.
comment|/// Only the exit block should end with a return statement.
name|class
name|Return
operator|:
name|public
name|Terminator
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Return
return|;
block|}
name|Return
argument_list|(
name|SExpr
operator|*
name|Rval
argument_list|)
operator|:
name|Terminator
argument_list|(
name|COP_Return
argument_list|)
block|,
name|Retval
argument_list|(
argument|Rval
argument_list|)
block|{}
name|Return
argument_list|(
specifier|const
name|Return
operator|&
name|R
argument_list|,
name|SExpr
operator|*
name|Rval
argument_list|)
operator|:
name|Terminator
argument_list|(
name|R
argument_list|)
block|,
name|Retval
argument_list|(
argument|Rval
argument_list|)
block|{}
comment|/// Return an empty list.
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
block|{
return|return
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|SExpr
operator|*
name|returnValue
argument_list|()
block|{
return|return
name|Retval
return|;
block|}
specifier|const
name|SExpr
operator|*
name|returnValue
argument_list|()
specifier|const
block|{
return|return
name|Retval
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Retval
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceReturn
argument_list|(
operator|*
name|this
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Return *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|Retval
argument_list|,
name|E
operator|->
name|Retval
argument_list|)
return|;
block|}
name|private
operator|:
name|SExpr
operator|*
name|Retval
block|; }
block|;
specifier|inline
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|Terminator
operator|::
name|successors
argument_list|()
block|{
switch|switch
condition|(
name|opcode
argument_list|()
condition|)
block|{
case|case
name|COP_Goto
case|:
return|return
name|cast
operator|<
name|Goto
operator|>
operator|(
name|this
operator|)
operator|->
name|successors
argument_list|()
return|;
case|case
name|COP_Branch
case|:
return|return
name|cast
operator|<
name|Branch
operator|>
operator|(
name|this
operator|)
operator|->
name|successors
argument_list|()
return|;
case|case
name|COP_Return
case|:
return|return
name|cast
operator|<
name|Return
operator|>
operator|(
name|this
operator|)
operator|->
name|successors
argument_list|()
return|;
default|default:
return|return
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
operator|(
operator|)
return|;
block|}
block|}
comment|/// A basic block is part of an SCFG.  It can be treated as a function in
comment|/// continuation passing style.  A block consists of a sequence of phi nodes,
comment|/// which are "arguments" to the function, followed by a sequence of
comment|/// instructions.  It ends with a Terminator, which is a Branch or Goto to
comment|/// another basic block in the same SCFG.
name|class
name|BasicBlock
operator|:
name|public
name|SExpr
block|{
name|public
operator|:
typedef|typedef
name|SimpleArray
operator|<
name|SExpr
operator|*
operator|>
name|InstrArray
expr_stmt|;
typedef|typedef
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
name|BlockArray
expr_stmt|;
comment|// TopologyNodes are used to overlay tree structures on top of the CFG,
comment|// such as dominator and postdominator trees.  Each block is assigned an
comment|// ID in the tree according to a depth-first search.  Tree traversals are
comment|// always up, towards the parents.
block|struct
name|TopologyNode
block|{
name|TopologyNode
argument_list|()
operator|:
name|NodeID
argument_list|(
literal|0
argument_list|)
block|,
name|SizeOfSubTree
argument_list|(
literal|0
argument_list|)
block|,
name|Parent
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|bool
name|isParentOf
argument_list|(
argument|const TopologyNode& OtherNode
argument_list|)
block|{
return|return
name|OtherNode
operator|.
name|NodeID
operator|>
name|NodeID
operator|&&
name|OtherNode
operator|.
name|NodeID
operator|<
name|NodeID
operator|+
name|SizeOfSubTree
return|;
block|}
name|bool
name|isParentOfOrEqual
argument_list|(
argument|const TopologyNode& OtherNode
argument_list|)
block|{
return|return
name|OtherNode
operator|.
name|NodeID
operator|>=
name|NodeID
operator|&&
name|OtherNode
operator|.
name|NodeID
operator|<
name|NodeID
operator|+
name|SizeOfSubTree
return|;
block|}
name|int
name|NodeID
block|;
name|int
name|SizeOfSubTree
block|;
comment|// Includes this node, so must be> 1.
name|BasicBlock
operator|*
name|Parent
block|;
comment|// Pointer to parent.
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_BasicBlock
return|;
block|}
end_function

begin_macro
name|explicit
end_macro

begin_macro
name|BasicBlock
argument_list|(
argument|MemRegionRef A
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SExpr
argument_list|(
name|COP_BasicBlock
argument_list|)
operator|,
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|CFGPtr
argument_list|(
name|nullptr
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Visited
argument_list|(
literal|0
argument_list|)
operator|,
name|TermInstr
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|BasicBlock
argument_list|(
argument|BasicBlock&B
argument_list|,
argument|MemRegionRef A
argument_list|,
argument|InstrArray&&As
argument_list|,
argument|InstrArray&&Is
argument_list|,
argument|Terminator *T
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_BasicBlock
argument_list|)
operator|,
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|CFGPtr
argument_list|(
name|nullptr
argument_list|)
operator|,
name|BlockID
argument_list|(
literal|0
argument_list|)
operator|,
name|Visited
argument_list|(
literal|0
argument_list|)
operator|,
name|Args
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|As
argument_list|)
argument_list|)
operator|,
name|Instrs
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Is
argument_list|)
argument_list|)
operator|,
name|TermInstr
argument_list|(
argument|T
argument_list|)
block|{}
comment|/// Returns the block ID.  Every block has a unique ID in the CFG.
name|int
name|blockID
argument_list|()
specifier|const
block|{
return|return
name|BlockID
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns the number of predecessors.
end_comment

begin_expr_stmt
name|size_t
name|numPredecessors
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|numSuccessors
argument_list|()
specifier|const
block|{
return|return
name|successors
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|SCFG
operator|*
name|cfg
argument_list|()
specifier|const
block|{
return|return
name|CFGPtr
return|;
block|}
end_expr_stmt

begin_function
name|SCFG
modifier|*
name|cfg
parameter_list|()
block|{
return|return
name|CFGPtr
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|parent
argument_list|()
specifier|const
block|{
return|return
name|DominatorNode
operator|.
name|Parent
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|parent
parameter_list|()
block|{
return|return
name|DominatorNode
operator|.
name|Parent
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|InstrArray
operator|&
name|arguments
argument_list|()
specifier|const
block|{
return|return
name|Args
return|;
block|}
end_expr_stmt

begin_function
name|InstrArray
modifier|&
name|arguments
parameter_list|()
block|{
return|return
name|Args
return|;
block|}
end_function

begin_function
name|InstrArray
modifier|&
name|instructions
parameter_list|()
block|{
return|return
name|Instrs
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|InstrArray
operator|&
name|instructions
argument_list|()
specifier|const
block|{
return|return
name|Instrs
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns a list of predecessors.
end_comment

begin_comment
comment|/// The order of predecessors in the list is important; each phi node has
end_comment

begin_comment
comment|/// exactly one argument for each precessor, in the same order.
end_comment

begin_function
name|BlockArray
modifier|&
name|predecessors
parameter_list|()
block|{
return|return
name|Predecessors
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BlockArray
operator|&
name|predecessors
argument_list|()
specifier|const
block|{
return|return
name|Predecessors
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
block|{
return|return
name|TermInstr
operator|->
name|successors
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|BasicBlock
operator|*
operator|>
name|successors
argument_list|()
specifier|const
block|{
return|return
name|TermInstr
operator|->
name|successors
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Terminator
operator|*
name|terminator
argument_list|()
specifier|const
block|{
return|return
name|TermInstr
return|;
block|}
end_expr_stmt

begin_function
name|Terminator
modifier|*
name|terminator
parameter_list|()
block|{
return|return
name|TermInstr
return|;
block|}
end_function

begin_function
name|void
name|setTerminator
parameter_list|(
name|Terminator
modifier|*
name|E
parameter_list|)
block|{
name|TermInstr
operator|=
name|E
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Dominates
parameter_list|(
specifier|const
name|BasicBlock
modifier|&
name|Other
parameter_list|)
block|{
return|return
name|DominatorNode
operator|.
name|isParentOfOrEqual
argument_list|(
name|Other
operator|.
name|DominatorNode
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|PostDominates
parameter_list|(
specifier|const
name|BasicBlock
modifier|&
name|Other
parameter_list|)
block|{
return|return
name|PostDominatorNode
operator|.
name|isParentOfOrEqual
argument_list|(
name|Other
operator|.
name|PostDominatorNode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Add a new argument.
end_comment

begin_function
name|void
name|addArgument
parameter_list|(
name|Phi
modifier|*
name|V
parameter_list|)
block|{
name|Args
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Add a new instruction.
end_comment

begin_function
name|void
name|addInstruction
parameter_list|(
name|SExpr
modifier|*
name|V
parameter_list|)
block|{
name|Instrs
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Instrs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Add a new predecessor, and return the phi-node index for it.
end_comment

begin_comment
comment|// Will add an argument to all phi-nodes, initialized to nullptr.
end_comment

begin_function_decl
name|unsigned
name|addPredecessor
parameter_list|(
name|BasicBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Reserve space for Nargs arguments.
end_comment

begin_function
name|void
name|reserveArguments
parameter_list|(
name|unsigned
name|Nargs
parameter_list|)
block|{
name|Args
operator|.
name|reserve
argument_list|(
name|Nargs
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Reserve space for Nins instructions.
end_comment

begin_function
name|void
name|reserveInstructions
parameter_list|(
name|unsigned
name|Nins
parameter_list|)
block|{
name|Instrs
operator|.
name|reserve
argument_list|(
name|Nins
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Reserve space for NumPreds predecessors, including space in phi nodes.
end_comment

begin_function_decl
name|void
name|reservePredecessors
parameter_list|(
name|unsigned
name|NumPreds
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Return the index of BB, or Predecessors.size if BB is not a predecessor.
end_comment

begin_decl_stmt
name|unsigned
name|findPredecessorIndex
argument_list|(
specifier|const
name|BasicBlock
operator|*
name|BB
argument_list|)
decl|const
block|{
name|auto
name|I
init|=
name|std
operator|::
name|find
argument_list|(
name|Predecessors
operator|.
name|cbegin
argument_list|()
argument_list|,
name|Predecessors
operator|.
name|cend
argument_list|()
argument_list|,
name|BB
argument_list|)
decl_stmt|;
return|return
name|std
operator|::
name|distance
argument_list|(
name|Predecessors
operator|.
name|cbegin
argument_list|()
argument_list|,
name|I
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_BasicBlock
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|SExpr
operator|*
operator|>
name|Nas
argument_list|(
name|Vs
argument_list|,
name|Args
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|SExpr
operator|*
operator|>
name|Nis
argument_list|(
name|Vs
argument_list|,
name|Instrs
operator|.
name|size
argument_list|()
argument_list|)
block|;
comment|// Entering the basic block should do any scope initialization.
name|Vs
operator|.
name|enterBasicBlock
argument_list|(
operator|*
name|this
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|E
operator|:
name|Args
control|)
block|{
name|auto
name|Ne
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|E
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
decl_stmt|;
name|Nas
operator|.
name|push_back
argument_list|(
name|Ne
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|auto
operator|*
name|E
operator|:
name|Instrs
control|)
block|{
name|auto
name|Ne
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|E
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
decl_stmt|;
name|Nis
operator|.
name|push_back
argument_list|(
name|Ne
argument_list|)
expr_stmt|;
block|}
end_for

begin_decl_stmt
name|auto
name|Nt
init|=
name|Vs
operator|.
name|traverse
argument_list|(
name|TermInstr
argument_list|,
name|Ctx
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Exiting the basic block should handle any scope cleanup.
end_comment

begin_expr_stmt
name|Vs
operator|.
name|exitBasicBlock
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reduceBasicBlock
argument_list|(
operator|*
name|this
argument_list|,
name|Nas
argument_list|,
name|Nis
argument_list|,
name|Nt
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const BasicBlock *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|friend
name|class
name|SCFG
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|renumberInstrs
parameter_list|(
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// assign unique ids to all instructions
end_comment

begin_decl_stmt
name|int
name|topologicalSort
argument_list|(
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
operator|&
name|Blocks
argument_list|,
name|int
name|ID
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|topologicalFinalSort
argument_list|(
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
operator|&
name|Blocks
argument_list|,
name|int
name|ID
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|computeDominator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|computePostDominator
parameter_list|()
function_decl|;
end_function_decl

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|MemRegionRef
name|Arena
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The arena used to allocate this block.
end_comment

begin_decl_stmt
name|SCFG
modifier|*
name|CFGPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The CFG that contains this block.
end_comment

begin_decl_stmt
name|int
name|BlockID
range|:
literal|31
decl_stmt|;
end_decl_stmt

begin_comment
comment|// unique id for this BB in the containing CFG.
end_comment

begin_comment
comment|// IDs are in topological order.
end_comment

begin_decl_stmt
name|bool
name|Visited
range|:
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Bit to determine if a block has been visited
end_comment

begin_comment
comment|// during a traversal.
end_comment

begin_decl_stmt
name|BlockArray
name|Predecessors
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Predecessor blocks in the CFG.
end_comment

begin_decl_stmt
name|InstrArray
name|Args
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Phi nodes.  One argument per predecessor.
end_comment

begin_decl_stmt
name|InstrArray
name|Instrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Instructions.
end_comment

begin_decl_stmt
name|Terminator
modifier|*
name|TermInstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Terminating instruction
end_comment

begin_decl_stmt
name|TopologyNode
name|DominatorNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The dominator tree
end_comment

begin_decl_stmt
name|TopologyNode
name|PostDominatorNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The post-dominator tree
end_comment

begin_comment
unit|};
comment|/// An SCFG is a control-flow graph.  It consists of a set of basic blocks,
end_comment

begin_comment
comment|/// each of which terminates in a branch to another basic block.  There is one
end_comment

begin_comment
comment|/// entry point, and one exit point.
end_comment

begin_decl_stmt
name|class
name|SCFG
range|:
name|public
name|SExpr
block|{
name|public
operator|:
typedef|typedef
name|SimpleArray
operator|<
name|BasicBlock
operator|*
operator|>
name|BlockArray
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|BlockArray
operator|::
name|iterator
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|BlockArray
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
end_typedef

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_SCFG
return|;
block|}
end_function

begin_macro
name|SCFG
argument_list|(
argument|MemRegionRef A
argument_list|,
argument|unsigned Nblocks
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|SExpr
argument_list|(
name|COP_SCFG
argument_list|)
operator|,
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|Blocks
argument_list|(
name|A
argument_list|,
name|Nblocks
argument_list|)
operator|,
name|Entry
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Exit
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NumInstructions
argument_list|(
literal|0
argument_list|)
operator|,
name|Normal
argument_list|(
argument|false
argument_list|)
block|{
name|Entry
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|BasicBlock
argument_list|(
name|A
argument_list|)
block|;
name|Exit
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|BasicBlock
argument_list|(
name|A
argument_list|)
block|;
name|auto
operator|*
name|V
operator|=
name|new
argument_list|(
argument|A
argument_list|)
name|Phi
argument_list|()
block|;
name|Exit
operator|->
name|addArgument
argument_list|(
name|V
argument_list|)
block|;
name|Exit
operator|->
name|setTerminator
argument_list|(
name|new
argument_list|(
argument|A
argument_list|)
name|Return
argument_list|(
name|V
argument_list|)
argument_list|)
block|;
name|add
argument_list|(
name|Entry
argument_list|)
block|;
name|add
argument_list|(
name|Exit
argument_list|)
block|;   }
name|SCFG
argument_list|(
specifier|const
name|SCFG
operator|&
name|Cfg
argument_list|,
name|BlockArray
operator|&&
name|Ba
argument_list|)
comment|// steals memory from Ba
operator|:
name|SExpr
argument_list|(
name|COP_SCFG
argument_list|)
operator|,
name|Arena
argument_list|(
name|Cfg
operator|.
name|Arena
argument_list|)
operator|,
name|Blocks
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Ba
argument_list|)
argument_list|)
operator|,
name|Entry
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Exit
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NumInstructions
argument_list|(
literal|0
argument_list|)
operator|,
name|Normal
argument_list|(
argument|false
argument_list|)
block|{
comment|// TODO: set entry and exit!
block|}
comment|/// Return true if this CFG is valid.
name|bool
name|valid
argument_list|()
specifier|const
block|{
return|return
name|Entry
operator|&&
name|Exit
operator|&&
name|Blocks
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return true if this CFG has been normalized.
end_comment

begin_comment
comment|/// After normalization, blocks are in topological order, and block and
end_comment

begin_comment
comment|/// instruction IDs have been assigned.
end_comment

begin_expr_stmt
name|bool
name|normal
argument_list|()
specifier|const
block|{
return|return
name|Normal
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|Blocks
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Blocks
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|cbegin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|cend
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|cbegin
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|cbegin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|cend
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|cend
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|entry
argument_list|()
specifier|const
block|{
return|return
name|Entry
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|entry
parameter_list|()
block|{
return|return
name|Entry
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|BasicBlock
operator|*
name|exit
argument_list|()
specifier|const
block|{
return|return
name|Exit
return|;
block|}
end_expr_stmt

begin_function
name|BasicBlock
modifier|*
name|exit
parameter_list|()
block|{
return|return
name|Exit
return|;
block|}
end_function

begin_comment
comment|/// Return the number of blocks in the CFG.
end_comment

begin_comment
comment|/// Block::blockID() will return a number less than numBlocks();
end_comment

begin_expr_stmt
name|size_t
name|numBlocks
argument_list|()
specifier|const
block|{
return|return
name|Blocks
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the total number of instructions in the CFG.
end_comment

begin_comment
comment|/// This is useful for building instruction side-tables;
end_comment

begin_comment
comment|/// A call to SExpr::id() will return a number less than numInstructions().
end_comment

begin_function
name|unsigned
name|numInstructions
parameter_list|()
block|{
return|return
name|NumInstructions
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|add
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|assert
argument_list|(
name|BB
operator|->
name|CFGPtr
operator|==
name|nullptr
argument_list|)
expr_stmt|;
name|BB
operator|->
name|CFGPtr
operator|=
name|this
expr_stmt|;
name|Blocks
operator|.
name|reserveCheck
argument_list|(
literal|1
argument_list|,
name|Arena
argument_list|)
expr_stmt|;
name|Blocks
operator|.
name|push_back
argument_list|(
name|BB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setEntry
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|Entry
operator|=
name|BB
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setExit
parameter_list|(
name|BasicBlock
modifier|*
name|BB
parameter_list|)
block|{
name|Exit
operator|=
name|BB
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|computeNormalForm
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|Vs
operator|.
name|enterCFG
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|typename
name|V
operator|::
name|template
name|Container
operator|<
name|BasicBlock
operator|*
operator|>
name|Bbs
argument_list|(
name|Vs
argument_list|,
name|Blocks
operator|.
name|size
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
operator|*
name|B
operator|:
name|Blocks
control|)
block|{
name|Bbs
operator|.
name|push_back
argument_list|(
name|B
operator|->
name|traverse
argument_list|(
name|Vs
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Vs
operator|.
name|exitCFG
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Vs
operator|.
name|reduceSCFG
argument_list|(
operator|*
name|this
argument_list|,
name|Bbs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const SCFG *E
argument_list|,
argument|C&Cmp
argument_list|)
specifier|const
block|{
comment|// TODO: implement CFG comparisons
return|return
name|Cmp
operator|.
name|comparePointers
argument_list|(
name|this
argument_list|,
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function_decl
name|void
name|renumberInstrs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// assign unique ids to all instructions
end_comment

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|MemRegionRef
name|Arena
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BlockArray
name|Blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BasicBlock
modifier|*
name|Entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BasicBlock
modifier|*
name|Exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumInstructions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|Normal
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// An identifier, e.g. 'foo' or 'x'.
end_comment

begin_comment
comment|/// This is a pseduo-term; it will be lowered to a variable or projection.
end_comment

begin_decl_stmt
name|class
name|Identifier
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Identifier
return|;
block|}
name|Identifier
argument_list|(
argument|StringRef Id
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Identifier
argument_list|)
block|,
name|Name
argument_list|(
argument|Id
argument_list|)
block|{ }
name|Identifier
argument_list|(
specifier|const
name|Identifier
operator|&
name|I
argument_list|)
operator|:
name|SExpr
argument_list|(
name|I
argument_list|)
block|,
name|Name
argument_list|(
argument|I.Name
argument_list|)
block|{ }
name|StringRef
name|name
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
return|return
name|Vs
operator|.
name|reduceIdentifier
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Identifier* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|compareStrings
argument_list|(
name|name
argument_list|()
argument_list|,
name|E
operator|->
name|name
argument_list|()
argument_list|)
return|;
block|}
name|private
operator|:
name|StringRef
name|Name
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// An if-then-else expression.
end_comment

begin_comment
comment|/// This is a pseduo-term; it will be lowered to a branch in a CFG.
end_comment

begin_decl_stmt
name|class
name|IfThenElse
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_IfThenElse
return|;
block|}
name|IfThenElse
argument_list|(
name|SExpr
operator|*
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_IfThenElse
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenExpr
argument_list|(
name|T
argument_list|)
block|,
name|ElseExpr
argument_list|(
argument|E
argument_list|)
block|{ }
name|IfThenElse
argument_list|(
specifier|const
name|IfThenElse
operator|&
name|I
argument_list|,
name|SExpr
operator|*
name|C
argument_list|,
name|SExpr
operator|*
name|T
argument_list|,
name|SExpr
operator|*
name|E
argument_list|)
operator|:
name|SExpr
argument_list|(
name|I
argument_list|)
block|,
name|Condition
argument_list|(
name|C
argument_list|)
block|,
name|ThenExpr
argument_list|(
name|T
argument_list|)
block|,
name|ElseExpr
argument_list|(
argument|E
argument_list|)
block|{ }
name|SExpr
operator|*
name|condition
argument_list|()
block|{
return|return
name|Condition
return|;
block|}
comment|// Address to store to
specifier|const
name|SExpr
operator|*
name|condition
argument_list|()
specifier|const
block|{
return|return
name|Condition
return|;
block|}
name|SExpr
operator|*
name|thenExpr
argument_list|()
block|{
return|return
name|ThenExpr
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|thenExpr
argument_list|()
specifier|const
block|{
return|return
name|ThenExpr
return|;
block|}
name|SExpr
operator|*
name|elseExpr
argument_list|()
block|{
return|return
name|ElseExpr
return|;
block|}
comment|// Value to store
specifier|const
name|SExpr
operator|*
name|elseExpr
argument_list|()
specifier|const
block|{
return|return
name|ElseExpr
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
name|auto
name|Nc
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Condition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Nt
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ThenExpr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
name|auto
name|Ne
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|ElseExpr
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceIfThenElse
argument_list|(
operator|*
name|this
argument_list|,
name|Nc
argument_list|,
name|Nt
argument_list|,
name|Ne
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const IfThenElse* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|condition
argument_list|()
argument_list|,
name|E
operator|->
name|condition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|thenExpr
argument_list|()
argument_list|,
name|E
operator|->
name|thenExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
end_decl_stmt

begin_return
return|return
name|Cmp
operator|.
name|compare
argument_list|(
name|elseExpr
argument_list|()
argument_list|,
name|E
operator|->
name|elseExpr
argument_list|()
argument_list|)
return|;
end_return

begin_decl_stmt
unit|}  private:
name|SExpr
modifier|*
name|Condition
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|ThenExpr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|ElseExpr
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// A let-expression,  e.g.  let x=t; u.
end_comment

begin_comment
comment|/// This is a pseduo-term; it will be lowered to instructions in a CFG.
end_comment

begin_decl_stmt
name|class
name|Let
range|:
name|public
name|SExpr
block|{
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const SExpr *E
argument_list|)
block|{
return|return
name|E
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Let
return|;
block|}
name|Let
argument_list|(
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|COP_Let
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Let
argument_list|)
block|;   }
name|Let
argument_list|(
specifier|const
name|Let
operator|&
name|L
argument_list|,
name|Variable
operator|*
name|Vd
argument_list|,
name|SExpr
operator|*
name|Bd
argument_list|)
operator|:
name|SExpr
argument_list|(
name|L
argument_list|)
block|,
name|VarDecl
argument_list|(
name|Vd
argument_list|)
block|,
name|Body
argument_list|(
argument|Bd
argument_list|)
block|{
name|Vd
operator|->
name|setKind
argument_list|(
name|Variable
operator|::
name|VK_Let
argument_list|)
block|;   }
name|Variable
operator|*
name|variableDecl
argument_list|()
block|{
return|return
name|VarDecl
return|;
block|}
specifier|const
name|Variable
operator|*
name|variableDecl
argument_list|()
specifier|const
block|{
return|return
name|VarDecl
return|;
block|}
name|SExpr
operator|*
name|body
argument_list|()
block|{
return|return
name|Body
return|;
block|}
specifier|const
name|SExpr
operator|*
name|body
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
name|template
operator|<
name|class
name|V
operator|>
name|typename
name|V
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|V&Vs
argument_list|,
argument|typename V::R_Ctx Ctx
argument_list|)
block|{
comment|// This is a variable declaration, so traverse the definition.
name|auto
name|E0
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|VarDecl
operator|->
name|Definition
argument_list|,
name|Vs
operator|.
name|subExprCtx
argument_list|(
name|Ctx
argument_list|)
argument_list|)
block|;
comment|// Tell the rewriter to enter the scope of the let variable.
name|Variable
operator|*
name|Nvd
operator|=
name|Vs
operator|.
name|enterScope
argument_list|(
operator|*
name|VarDecl
argument_list|,
name|E0
argument_list|)
block|;
name|auto
name|E1
operator|=
name|Vs
operator|.
name|traverse
argument_list|(
name|Body
argument_list|,
name|Ctx
argument_list|)
block|;
name|Vs
operator|.
name|exitScope
argument_list|(
operator|*
name|VarDecl
argument_list|)
block|;
return|return
name|Vs
operator|.
name|reduceLet
argument_list|(
operator|*
name|this
argument_list|,
name|Nvd
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|C
operator|>
name|typename
name|C
operator|::
name|CType
name|compare
argument_list|(
argument|const Let* E
argument_list|,
argument|C& Cmp
argument_list|)
specifier|const
block|{
name|typename
name|C
operator|::
name|CType
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|,
name|E
operator|->
name|VarDecl
operator|->
name|definition
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cmp
operator|.
name|notTrue
argument_list|(
name|Ct
argument_list|)
condition|)
return|return
name|Ct
return|;
name|Cmp
operator|.
name|enterScope
argument_list|(
name|variableDecl
argument_list|()
argument_list|,
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|)
block|;
name|Ct
operator|=
name|Cmp
operator|.
name|compare
argument_list|(
name|body
argument_list|()
argument_list|,
name|E
operator|->
name|body
argument_list|()
argument_list|)
block|;
name|Cmp
operator|.
name|leaveScope
argument_list|()
block|;
return|return
name|Ct
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|Variable
modifier|*
name|VarDecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SExpr
modifier|*
name|Body
decl_stmt|;
end_decl_stmt

begin_function_decl
unit|};
specifier|const
name|SExpr
modifier|*
name|getCanonicalVal
parameter_list|(
specifier|const
name|SExpr
modifier|*
name|E
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|SExpr
modifier|*
name|simplifyToCanonicalVal
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|simplifyIncompleteArg
argument_list|(
name|til
operator|::
name|Phi
operator|*
name|Ph
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace til
end_comment

begin_comment
unit|}
comment|// end namespace threadSafety
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

