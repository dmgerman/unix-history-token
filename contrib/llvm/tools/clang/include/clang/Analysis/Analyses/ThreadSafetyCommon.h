begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ThreadSafetyCommon.h ------------------------------------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Parts of thread safety analysis that are not specific to thread safety
end_comment

begin_comment
comment|// itself have been factored into classes here, where they can be potentially
end_comment

begin_comment
comment|// used by other analyses.  Currently these include:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// * Generalize clang CFG visitors.
end_comment

begin_comment
comment|// * Conversion of the clang CFG to SSA form.
end_comment

begin_comment
comment|// * Translation of clang Exprs to TIL SExprs
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMMON_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMMON_H
end_define

begin_include
include|#
directive|include
file|"clang/Analysis/Analyses/PostOrderCFGView.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/Analyses/ThreadSafetyTIL.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/Analyses/ThreadSafetyTraverse.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/AnalysisContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<ostream>
end_include

begin_include
include|#
directive|include
file|<sstream>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|threadSafety
block|{
comment|// Various helper functions on til::SExpr
name|namespace
name|sx
block|{
specifier|inline
name|bool
name|equals
argument_list|(
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E1
argument_list|,
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E2
argument_list|)
block|{
return|return
name|til
operator|::
name|EqualsComparator
operator|::
name|compareExprs
argument_list|(
name|E1
argument_list|,
name|E2
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|matches
argument_list|(
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E1
argument_list|,
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E2
argument_list|)
block|{
comment|// We treat a top-level wildcard as the "univsersal" lock.
comment|// It matches everything for the purpose of checking locks, but not
comment|// for unlocking them.
if|if
condition|(
name|isa
operator|<
name|til
operator|::
name|Wildcard
operator|>
operator|(
name|E1
operator|)
condition|)
return|return
name|isa
operator|<
name|til
operator|::
name|Wildcard
operator|>
operator|(
name|E2
operator|)
return|;
if|if
condition|(
name|isa
operator|<
name|til
operator|::
name|Wildcard
operator|>
operator|(
name|E2
operator|)
condition|)
return|return
name|isa
operator|<
name|til
operator|::
name|Wildcard
operator|>
operator|(
name|E1
operator|)
return|;
return|return
name|til
operator|::
name|MatchComparator
operator|::
name|compareExprs
argument_list|(
name|E1
argument_list|,
name|E2
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|partiallyMatches
argument_list|(
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E1
argument_list|,
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|E2
argument_list|)
block|{
specifier|const
specifier|auto
modifier|*
name|PE1
init|=
name|dyn_cast_or_null
operator|<
name|til
operator|::
name|Project
operator|>
operator|(
name|E1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|PE1
condition|)
return|return
name|false
return|;
specifier|const
specifier|auto
modifier|*
name|PE2
init|=
name|dyn_cast_or_null
operator|<
name|til
operator|::
name|Project
operator|>
operator|(
name|E2
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|PE2
condition|)
return|return
name|false
return|;
return|return
name|PE1
operator|->
name|clangDecl
argument_list|()
operator|==
name|PE2
operator|->
name|clangDecl
argument_list|()
return|;
block|}
specifier|inline
name|std
operator|::
name|string
name|toString
argument_list|(
argument|const til::SExpr *E
argument_list|)
block|{
name|std
operator|::
name|stringstream
name|ss
block|;
name|til
operator|::
name|StdPrinter
operator|::
name|print
argument_list|(
name|E
argument_list|,
name|ss
argument_list|)
block|;
return|return
name|ss
operator|.
name|str
argument_list|()
return|;
block|}
block|}
comment|// end namespace sx
comment|// This class defines the interface of a clang CFG Visitor.
comment|// CFGWalker will invoke the following methods.
comment|// Note that methods are not virtual; the visitor is templatized.
name|class
name|CFGVisitor
block|{
comment|// Enter the CFG for Decl D, and perform any initial setup operations.
name|void
name|enterCFG
parameter_list|(
name|CFG
modifier|*
name|Cfg
parameter_list|,
specifier|const
name|NamedDecl
modifier|*
name|D
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|First
parameter_list|)
block|{}
comment|// Enter a CFGBlock.
name|void
name|enterCFGBlock
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{}
comment|// Returns true if this visitor implements handlePredecessor
name|bool
name|visitPredecessors
parameter_list|()
block|{
return|return
name|true
return|;
block|}
comment|// Process a predecessor edge.
name|void
name|handlePredecessor
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Pred
parameter_list|)
block|{}
comment|// Process a successor back edge to a previously visited block.
name|void
name|handlePredecessorBackEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Pred
parameter_list|)
block|{}
comment|// Called just before processing statements.
name|void
name|enterCFGBlockBody
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{}
comment|// Process an ordinary statement.
name|void
name|handleStatement
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|S
parameter_list|)
block|{}
comment|// Process a destructor call
name|void
name|handleDestructorCall
parameter_list|(
specifier|const
name|VarDecl
modifier|*
name|VD
parameter_list|,
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
block|{}
comment|// Called after all statements have been handled.
name|void
name|exitCFGBlockBody
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{}
comment|// Return true
name|bool
name|visitSuccessors
parameter_list|()
block|{
return|return
name|true
return|;
block|}
comment|// Process a successor edge.
name|void
name|handleSuccessor
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Succ
parameter_list|)
block|{}
comment|// Process a successor back edge to a previously visited block.
name|void
name|handleSuccessorBackEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Succ
parameter_list|)
block|{}
comment|// Leave a CFGBlock.
name|void
name|exitCFGBlock
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
block|{}
comment|// Leave the CFG, and perform any final cleanup operations.
name|void
name|exitCFG
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Last
parameter_list|)
block|{}
block|}
empty_stmt|;
comment|// Walks the clang CFG, and invokes methods on a given CFGVisitor.
name|class
name|CFGWalker
block|{
name|public
label|:
name|CFGWalker
argument_list|()
operator|:
name|CFGraph
argument_list|(
name|nullptr
argument_list|)
operator|,
name|ACtx
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SortedGraph
argument_list|(
argument|nullptr
argument_list|)
block|{}
comment|// Initialize the CFGWalker.  This setup only needs to be done once, even
comment|// if there are multiple passes over the CFG.
name|bool
name|init
argument_list|(
argument|AnalysisDeclContext&AC
argument_list|)
block|{
name|ACtx
operator|=
operator|&
name|AC
block|;
name|CFGraph
operator|=
name|AC
operator|.
name|getCFG
argument_list|()
block|;
if|if
condition|(
operator|!
name|CFGraph
condition|)
return|return
name|false
return|;
comment|// Ignore anonymous functions.
if|if
condition|(
operator|!
name|dyn_cast_or_null
operator|<
name|NamedDecl
operator|>
operator|(
name|AC
operator|.
name|getDecl
argument_list|()
operator|)
condition|)
return|return
name|false
return|;
name|SortedGraph
operator|=
name|AC
operator|.
name|getAnalysis
operator|<
name|PostOrderCFGView
operator|>
operator|(
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|SortedGraph
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|// Traverse the CFG, calling methods on V as appropriate.
name|template
operator|<
name|class
name|Visitor
operator|>
name|void
name|walk
argument_list|(
argument|Visitor&V
argument_list|)
block|{
name|PostOrderCFGView
operator|::
name|CFGBlockSet
name|VisitedBlocks
argument_list|(
name|CFGraph
argument_list|)
block|;
name|V
operator|.
name|enterCFG
argument_list|(
name|CFGraph
argument_list|,
name|getDecl
argument_list|()
argument_list|,
operator|&
name|CFGraph
operator|->
name|getEntry
argument_list|()
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|CurrBlock
range|:
operator|*
name|SortedGraph
control|)
block|{
name|VisitedBlocks
operator|.
name|insert
argument_list|(
name|CurrBlock
argument_list|)
expr_stmt|;
name|V
operator|.
name|enterCFGBlock
argument_list|(
name|CurrBlock
argument_list|)
expr_stmt|;
comment|// Process predecessors, handling back edges last
if|if
condition|(
name|V
operator|.
name|visitPredecessors
argument_list|()
condition|)
block|{
name|SmallVector
operator|<
name|CFGBlock
operator|*
operator|,
literal|4
operator|>
name|BackEdges
expr_stmt|;
comment|// Process successors
for|for
control|(
name|CFGBlock
operator|::
name|const_pred_iterator
name|SI
operator|=
name|CurrBlock
operator|->
name|pred_begin
argument_list|()
operator|,
name|SE
operator|=
name|CurrBlock
operator|->
name|pred_end
argument_list|()
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|*
name|SI
operator|==
name|nullptr
condition|)
continue|continue;
if|if
condition|(
operator|!
name|VisitedBlocks
operator|.
name|alreadySet
argument_list|(
operator|*
name|SI
argument_list|)
condition|)
block|{
name|BackEdges
operator|.
name|push_back
argument_list|(
operator|*
name|SI
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|V
operator|.
name|handlePredecessor
argument_list|(
operator|*
name|SI
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
operator|*
name|Blk
operator|:
name|BackEdges
control|)
name|V
operator|.
name|handlePredecessorBackEdge
argument_list|(
name|Blk
argument_list|)
expr_stmt|;
block|}
name|V
operator|.
name|enterCFGBlockBody
argument_list|(
name|CurrBlock
argument_list|)
expr_stmt|;
comment|// Process statements
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|BI
range|:
operator|*
name|CurrBlock
control|)
block|{
switch|switch
condition|(
name|BI
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CFGElement
operator|::
name|Statement
case|:
block|{
name|V
operator|.
name|handleStatement
argument_list|(
name|BI
operator|.
name|castAs
operator|<
name|CFGStmt
operator|>
operator|(
operator|)
operator|.
name|getStmt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CFGElement
operator|::
name|AutomaticObjectDtor
case|:
block|{
name|CFGAutomaticObjDtor
name|AD
init|=
name|BI
operator|.
name|castAs
operator|<
name|CFGAutomaticObjDtor
operator|>
operator|(
operator|)
decl_stmt|;
name|CXXDestructorDecl
modifier|*
name|DD
init|=
name|const_cast
operator|<
name|CXXDestructorDecl
operator|*
operator|>
operator|(
name|AD
operator|.
name|getDestructorDecl
argument_list|(
name|ACtx
operator|->
name|getASTContext
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|VarDecl
modifier|*
name|VD
init|=
name|const_cast
operator|<
name|VarDecl
operator|*
operator|>
operator|(
name|AD
operator|.
name|getVarDecl
argument_list|()
operator|)
decl_stmt|;
name|V
operator|.
name|handleDestructorCall
argument_list|(
name|VD
argument_list|,
name|DD
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|V
operator|.
name|exitCFGBlockBody
argument_list|(
name|CurrBlock
argument_list|)
expr_stmt|;
comment|// Process successors, handling back edges first.
if|if
condition|(
name|V
operator|.
name|visitSuccessors
argument_list|()
condition|)
block|{
name|SmallVector
operator|<
name|CFGBlock
operator|*
operator|,
literal|8
operator|>
name|ForwardEdges
expr_stmt|;
comment|// Process successors
for|for
control|(
name|CFGBlock
operator|::
name|const_succ_iterator
name|SI
operator|=
name|CurrBlock
operator|->
name|succ_begin
argument_list|()
operator|,
name|SE
operator|=
name|CurrBlock
operator|->
name|succ_end
argument_list|()
init|;
name|SI
operator|!=
name|SE
condition|;
operator|++
name|SI
control|)
block|{
if|if
condition|(
operator|*
name|SI
operator|==
name|nullptr
condition|)
continue|continue;
if|if
condition|(
operator|!
name|VisitedBlocks
operator|.
name|alreadySet
argument_list|(
operator|*
name|SI
argument_list|)
condition|)
block|{
name|ForwardEdges
operator|.
name|push_back
argument_list|(
operator|*
name|SI
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|V
operator|.
name|handleSuccessorBackEdge
argument_list|(
operator|*
name|SI
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
operator|*
name|Blk
operator|:
name|ForwardEdges
control|)
name|V
operator|.
name|handleSuccessor
argument_list|(
name|Blk
argument_list|)
expr_stmt|;
block|}
name|V
operator|.
name|exitCFGBlock
argument_list|(
name|CurrBlock
argument_list|)
expr_stmt|;
block|}
name|V
operator|.
name|exitCFG
argument_list|(
operator|&
name|CFGraph
operator|->
name|getExit
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|const
name|CFG
operator|*
name|getGraph
argument_list|()
specifier|const
block|{
return|return
name|CFGraph
return|;
block|}
end_expr_stmt

begin_function
name|CFG
modifier|*
name|getGraph
parameter_list|()
block|{
return|return
name|CFGraph
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|NamedDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|dyn_cast
operator|<
name|NamedDecl
operator|>
operator|(
name|ACtx
operator|->
name|getDecl
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|PostOrderCFGView
operator|*
name|getSortedGraph
argument_list|()
specifier|const
block|{
return|return
name|SortedGraph
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|CFG
modifier|*
name|CFGraph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AnalysisDeclContext
modifier|*
name|ACtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PostOrderCFGView
modifier|*
name|SortedGraph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|CapabilityExpr
block|{
comment|// TODO: move this back into ThreadSafety.cpp
comment|// This is specific to thread safety.  It is here because
comment|// translateAttrExpr needs it, but that should be moved too.
name|private
label|:
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|CapExpr
expr_stmt|;
comment|///< The capability expression.
name|bool
name|Negated
decl_stmt|;
comment|///< True if this is a negative capability
name|public
label|:
name|CapabilityExpr
argument_list|(
argument|const til::SExpr *E
argument_list|,
argument|bool Neg
argument_list|)
block|:
name|CapExpr
argument_list|(
name|E
argument_list|)
operator|,
name|Negated
argument_list|(
argument|Neg
argument_list|)
block|{}
specifier|const
name|til
operator|::
name|SExpr
operator|*
name|sexpr
argument_list|()
specifier|const
block|{
return|return
name|CapExpr
return|;
block|}
name|bool
name|negative
argument_list|()
specifier|const
block|{
return|return
name|Negated
return|;
block|}
name|CapabilityExpr
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
name|CapabilityExpr
argument_list|(
name|CapExpr
argument_list|,
operator|!
name|Negated
argument_list|)
return|;
block|}
name|bool
name|equals
argument_list|(
specifier|const
name|CapabilityExpr
operator|&
name|other
argument_list|)
decl|const
block|{
return|return
operator|(
name|Negated
operator|==
name|other
operator|.
name|Negated
operator|)
operator|&&
name|sx
operator|::
name|equals
argument_list|(
name|CapExpr
argument_list|,
name|other
operator|.
name|CapExpr
argument_list|)
return|;
block|}
name|bool
name|matches
argument_list|(
specifier|const
name|CapabilityExpr
operator|&
name|other
argument_list|)
decl|const
block|{
return|return
operator|(
name|Negated
operator|==
name|other
operator|.
name|Negated
operator|)
operator|&&
name|sx
operator|::
name|matches
argument_list|(
name|CapExpr
argument_list|,
name|other
operator|.
name|CapExpr
argument_list|)
return|;
block|}
name|bool
name|matchesUniv
argument_list|(
specifier|const
name|CapabilityExpr
operator|&
name|CapE
argument_list|)
decl|const
block|{
return|return
name|isUniversal
argument_list|()
operator|||
name|matches
argument_list|(
name|CapE
argument_list|)
return|;
block|}
name|bool
name|partiallyMatches
argument_list|(
specifier|const
name|CapabilityExpr
operator|&
name|other
argument_list|)
decl|const
block|{
return|return
operator|(
name|Negated
operator|==
name|other
operator|.
name|Negated
operator|)
operator|&&
name|sx
operator|::
name|partiallyMatches
argument_list|(
name|CapExpr
argument_list|,
name|other
operator|.
name|CapExpr
argument_list|)
return|;
block|}
specifier|const
name|ValueDecl
operator|*
name|valueDecl
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Negated
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
name|auto
operator|*
name|P
operator|=
name|dyn_cast
operator|<
name|til
operator|::
name|Project
operator|>
operator|(
name|CapExpr
operator|)
condition|)
return|return
name|P
operator|->
name|clangDecl
argument_list|()
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|string
name|toString
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Negated
condition|)
return|return
literal|"!"
operator|+
name|sx
operator|::
name|toString
argument_list|(
name|CapExpr
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|sx
operator|::
name|toString
argument_list|(
name|CapExpr
argument_list|)
return|;
end_return

begin_macro
unit|}    bool
name|shouldIgnore
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|CapExpr
operator|==
name|nullptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|sexpr
argument_list|()
operator|&&
name|isa
operator|<
name|til
operator|::
name|Undefined
operator|>
operator|(
name|sexpr
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isUniversal
argument_list|()
specifier|const
block|{
return|return
name|sexpr
argument_list|()
operator|&&
name|isa
operator|<
name|til
operator|::
name|Wildcard
operator|>
operator|(
name|sexpr
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Translate clang::Expr to til::SExpr.
end_comment

begin_decl_stmt
name|class
name|SExprBuilder
block|{
name|public
label|:
comment|/// \brief Encapsulates the lexical context of a function call.  The lexical
comment|/// context includes the arguments to the call, including the implicit object
comment|/// argument.  When an attribute containing a mutex expression is attached to
comment|/// a method, the expression may refer to formal parameters of the method.
comment|/// Actual arguments must be substituted for formal parameters to derive
comment|/// the appropriate mutex expression in the lexical context where the function
comment|/// is called.  PrevCtx holds the context in which the arguments themselves
comment|/// should be evaluated; multiple calling contexts can be chained together
comment|/// by the lock_returned attribute.
struct|struct
name|CallingContext
block|{
name|CallingContext
modifier|*
name|Prev
decl_stmt|;
comment|// The previous context; or 0 if none.
specifier|const
name|NamedDecl
modifier|*
name|AttrDecl
decl_stmt|;
comment|// The decl to which the attr is attached.
specifier|const
name|Expr
modifier|*
name|SelfArg
decl_stmt|;
comment|// Implicit object argument -- e.g. 'this'
name|unsigned
name|NumArgs
decl_stmt|;
comment|// Number of funArgs
specifier|const
name|Expr
modifier|*
specifier|const
modifier|*
name|FunArgs
decl_stmt|;
comment|// Function arguments
name|bool
name|SelfArrow
decl_stmt|;
comment|// is Self referred to with -> or .?
name|CallingContext
argument_list|(
name|CallingContext
operator|*
name|P
argument_list|,
specifier|const
name|NamedDecl
operator|*
name|D
operator|=
name|nullptr
argument_list|)
operator|:
name|Prev
argument_list|(
name|P
argument_list|)
operator|,
name|AttrDecl
argument_list|(
name|D
argument_list|)
operator|,
name|SelfArg
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|FunArgs
argument_list|(
name|nullptr
argument_list|)
operator|,
name|SelfArrow
argument_list|(
argument|false
argument_list|)
block|{}
block|}
struct|;
name|SExprBuilder
argument_list|(
argument|til::MemRegionRef A
argument_list|)
block|:
name|Arena
argument_list|(
name|A
argument_list|)
operator|,
name|SelfVar
argument_list|(
name|nullptr
argument_list|)
operator|,
name|Scfg
argument_list|(
name|nullptr
argument_list|)
operator|,
name|CurrentBB
argument_list|(
name|nullptr
argument_list|)
operator|,
name|CurrentBlockInfo
argument_list|(
argument|nullptr
argument_list|)
block|{
comment|// FIXME: we don't always have a self-variable.
name|SelfVar
operator|=
name|new
argument_list|(
argument|Arena
argument_list|)
name|til
operator|::
name|Variable
argument_list|(
name|nullptr
argument_list|)
block|;
name|SelfVar
operator|->
name|setKind
argument_list|(
name|til
operator|::
name|Variable
operator|::
name|VK_SFun
argument_list|)
block|;   }
comment|// Translate a clang expression in an attribute to a til::SExpr.
comment|// Constructs the context from D, DeclExp, and SelfDecl.
name|CapabilityExpr
name|translateAttrExpr
argument_list|(
specifier|const
name|Expr
operator|*
name|AttrExp
argument_list|,
specifier|const
name|NamedDecl
operator|*
name|D
argument_list|,
specifier|const
name|Expr
operator|*
name|DeclExp
argument_list|,
name|VarDecl
operator|*
name|SelfD
operator|=
name|nullptr
argument_list|)
expr_stmt|;
name|CapabilityExpr
name|translateAttrExpr
parameter_list|(
specifier|const
name|Expr
modifier|*
name|AttrExp
parameter_list|,
name|CallingContext
modifier|*
name|Ctx
parameter_list|)
function_decl|;
comment|// Translate a clang statement or expression to a TIL expression.
comment|// Also performs substitution of variables; Ctx provides the context.
comment|// Dispatches on the type of S.
name|til
operator|::
name|SExpr
operator|*
name|translate
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SCFG
operator|*
name|buildCFG
argument_list|(
name|CFGWalker
operator|&
name|Walker
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|lookupStmt
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|)
expr_stmt|;
name|til
operator|::
name|BasicBlock
operator|*
name|lookupBlock
argument_list|(
argument|const CFGBlock *B
argument_list|)
block|{
return|return
name|BlockMap
index|[
name|B
operator|->
name|getBlockID
argument_list|()
index|]
return|;
block|}
specifier|const
name|til
operator|::
name|SCFG
operator|*
name|getCFG
argument_list|()
specifier|const
block|{
return|return
name|Scfg
return|;
block|}
name|til
operator|::
name|SCFG
operator|*
name|getCFG
argument_list|()
block|{
return|return
name|Scfg
return|;
block|}
name|private
label|:
name|til
operator|::
name|SExpr
operator|*
name|translateDeclRefExpr
argument_list|(
specifier|const
name|DeclRefExpr
operator|*
name|DRE
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateCXXThisExpr
argument_list|(
specifier|const
name|CXXThisExpr
operator|*
name|TE
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateMemberExpr
argument_list|(
specifier|const
name|MemberExpr
operator|*
name|ME
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateCallExpr
argument_list|(
specifier|const
name|CallExpr
operator|*
name|CE
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|,
specifier|const
name|Expr
operator|*
name|SelfE
operator|=
name|nullptr
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateCXXMemberCallExpr
argument_list|(
specifier|const
name|CXXMemberCallExpr
operator|*
name|ME
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateCXXOperatorCallExpr
argument_list|(
specifier|const
name|CXXOperatorCallExpr
operator|*
name|OCE
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateUnaryOperator
argument_list|(
specifier|const
name|UnaryOperator
operator|*
name|UO
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateBinOp
argument_list|(
argument|til::TIL_BinaryOpcode Op
argument_list|,
argument|const BinaryOperator *BO
argument_list|,
argument|CallingContext *Ctx
argument_list|,
argument|bool Reverse = false
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateBinAssign
argument_list|(
argument|til::TIL_BinaryOpcode Op
argument_list|,
argument|const BinaryOperator *BO
argument_list|,
argument|CallingContext *Ctx
argument_list|,
argument|bool Assign = false
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateBinaryOperator
argument_list|(
specifier|const
name|BinaryOperator
operator|*
name|BO
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateCastExpr
argument_list|(
specifier|const
name|CastExpr
operator|*
name|CE
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateArraySubscriptExpr
argument_list|(
specifier|const
name|ArraySubscriptExpr
operator|*
name|E
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateAbstractConditionalOperator
argument_list|(
specifier|const
name|AbstractConditionalOperator
operator|*
name|C
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|translateDeclStmt
argument_list|(
specifier|const
name|DeclStmt
operator|*
name|S
argument_list|,
name|CallingContext
operator|*
name|Ctx
argument_list|)
expr_stmt|;
comment|// Map from statements in the clang CFG to SExprs in the til::SCFG.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Stmt
operator|*
operator|,
name|til
operator|::
name|SExpr
operator|*
operator|>
name|StatementMap
expr_stmt|;
comment|// Map from clang local variables to indices in a LVarDefinitionMap.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|ValueDecl
operator|*
operator|,
name|unsigned
operator|>
name|LVarIndexMap
expr_stmt|;
comment|// Map from local variable indices to SSA variables (or constants).
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|ValueDecl
operator|*
operator|,
name|til
operator|::
name|SExpr
operator|*
operator|>
name|NameVarPair
expr_stmt|;
typedef|typedef
name|CopyOnWriteVector
operator|<
name|NameVarPair
operator|>
name|LVarDefinitionMap
expr_stmt|;
struct|struct
name|BlockInfo
block|{
name|LVarDefinitionMap
name|ExitMap
decl_stmt|;
name|bool
name|HasBackEdges
decl_stmt|;
name|unsigned
name|UnprocessedSuccessors
decl_stmt|;
comment|// Successors yet to be processed
name|unsigned
name|ProcessedPredecessors
decl_stmt|;
comment|// Predecessors already processed
name|BlockInfo
argument_list|()
operator|:
name|HasBackEdges
argument_list|(
name|false
argument_list|)
operator|,
name|UnprocessedSuccessors
argument_list|(
literal|0
argument_list|)
operator|,
name|ProcessedPredecessors
argument_list|(
literal|0
argument_list|)
block|{}
name|BlockInfo
argument_list|(
name|BlockInfo
operator|&&
name|RHS
argument_list|)
operator|:
name|ExitMap
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|ExitMap
argument_list|)
argument_list|)
operator|,
name|HasBackEdges
argument_list|(
name|RHS
operator|.
name|HasBackEdges
argument_list|)
operator|,
name|UnprocessedSuccessors
argument_list|(
name|RHS
operator|.
name|UnprocessedSuccessors
argument_list|)
operator|,
name|ProcessedPredecessors
argument_list|(
argument|RHS.ProcessedPredecessors
argument_list|)
block|{}
name|BlockInfo
operator|&
name|operator
operator|=
operator|(
name|BlockInfo
operator|&&
name|RHS
operator|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|RHS
condition|)
block|{
name|ExitMap
operator|=
name|std
operator|::
name|move
argument_list|(
name|RHS
operator|.
name|ExitMap
argument_list|)
expr_stmt|;
name|HasBackEdges
operator|=
name|RHS
operator|.
name|HasBackEdges
expr_stmt|;
name|UnprocessedSuccessors
operator|=
name|RHS
operator|.
name|UnprocessedSuccessors
expr_stmt|;
name|ProcessedPredecessors
operator|=
name|RHS
operator|.
name|ProcessedPredecessors
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|private
label|:
name|BlockInfo
argument_list|(
specifier|const
name|BlockInfo
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|BlockInfo
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
block|}
struct|;
comment|// We implement the CFGVisitor API
name|friend
name|class
name|CFGWalker
decl_stmt|;
name|void
name|enterCFG
parameter_list|(
name|CFG
modifier|*
name|Cfg
parameter_list|,
specifier|const
name|NamedDecl
modifier|*
name|D
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|First
parameter_list|)
function_decl|;
name|void
name|enterCFGBlock
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
function_decl|;
name|bool
name|visitPredecessors
parameter_list|()
block|{
return|return
name|true
return|;
block|}
name|void
name|handlePredecessor
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|handlePredecessorBackEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Pred
parameter_list|)
function_decl|;
name|void
name|enterCFGBlockBody
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
function_decl|;
name|void
name|handleStatement
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|S
parameter_list|)
function_decl|;
name|void
name|handleDestructorCall
parameter_list|(
specifier|const
name|VarDecl
modifier|*
name|VD
parameter_list|,
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
function_decl|;
name|void
name|exitCFGBlockBody
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
function_decl|;
name|bool
name|visitSuccessors
parameter_list|()
block|{
return|return
name|true
return|;
block|}
name|void
name|handleSuccessor
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Succ
parameter_list|)
function_decl|;
name|void
name|handleSuccessorBackEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Succ
parameter_list|)
function_decl|;
name|void
name|exitCFGBlock
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|B
parameter_list|)
function_decl|;
name|void
name|exitCFG
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Last
parameter_list|)
function_decl|;
name|void
name|insertStmt
argument_list|(
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
name|til
operator|::
name|SExpr
operator|*
name|E
argument_list|)
block|{
name|SMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|S
argument_list|,
name|E
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|til
operator|::
name|SExpr
operator|*
name|getCurrentLVarDefinition
argument_list|(
specifier|const
name|ValueDecl
operator|*
name|VD
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|addStatement
argument_list|(
name|til
operator|::
name|SExpr
operator|*
name|E
argument_list|,
specifier|const
name|Stmt
operator|*
name|S
argument_list|,
specifier|const
name|ValueDecl
operator|*
name|VD
operator|=
name|nullptr
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|lookupVarDecl
argument_list|(
specifier|const
name|ValueDecl
operator|*
name|VD
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|addVarDecl
argument_list|(
specifier|const
name|ValueDecl
operator|*
name|VD
argument_list|,
name|til
operator|::
name|SExpr
operator|*
name|E
argument_list|)
expr_stmt|;
name|til
operator|::
name|SExpr
operator|*
name|updateVarDecl
argument_list|(
specifier|const
name|ValueDecl
operator|*
name|VD
argument_list|,
name|til
operator|::
name|SExpr
operator|*
name|E
argument_list|)
expr_stmt|;
name|void
name|makePhiNodeVar
argument_list|(
name|unsigned
name|i
argument_list|,
name|unsigned
name|NPreds
argument_list|,
name|til
operator|::
name|SExpr
operator|*
name|E
argument_list|)
decl_stmt|;
name|void
name|mergeEntryMap
parameter_list|(
name|LVarDefinitionMap
name|Map
parameter_list|)
function_decl|;
name|void
name|mergeEntryMapBackEdge
parameter_list|()
function_decl|;
name|void
name|mergePhiNodesBackEdge
parameter_list|(
specifier|const
name|CFGBlock
modifier|*
name|Blk
parameter_list|)
function_decl|;
name|private
label|:
comment|// Set to true when parsing capability expressions, which get translated
comment|// inaccurately in order to hack around smart pointers etc.
specifier|static
specifier|const
name|bool
name|CapabilityExprMode
init|=
name|true
decl_stmt|;
name|til
operator|::
name|MemRegionRef
name|Arena
expr_stmt|;
name|til
operator|::
name|Variable
operator|*
name|SelfVar
expr_stmt|;
comment|// Variable to use for 'this'.  May be null.
name|til
operator|::
name|SCFG
operator|*
name|Scfg
expr_stmt|;
name|StatementMap
name|SMap
decl_stmt|;
comment|// Map from Stmt to TIL Variables
name|LVarIndexMap
name|LVarIdxMap
decl_stmt|;
comment|// Indices of clang local vars.
name|std
operator|::
name|vector
operator|<
name|til
operator|::
name|BasicBlock
operator|*
operator|>
name|BlockMap
expr_stmt|;
comment|// Map from clang to til BBs.
name|std
operator|::
name|vector
operator|<
name|BlockInfo
operator|>
name|BBInfo
expr_stmt|;
comment|// Extra information per BB.
comment|// Indexed by clang BlockID.
name|LVarDefinitionMap
name|CurrentLVarMap
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|til
operator|::
name|Phi
operator|*
operator|>
name|CurrentArguments
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|til
operator|::
name|SExpr
operator|*
operator|>
name|CurrentInstructions
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|til
operator|::
name|Phi
operator|*
operator|>
name|IncompleteArgs
expr_stmt|;
name|til
operator|::
name|BasicBlock
operator|*
name|CurrentBB
expr_stmt|;
name|BlockInfo
modifier|*
name|CurrentBlockInfo
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Dump an SCFG to llvm::errs().
end_comment

begin_function_decl
name|void
name|printSCFG
parameter_list|(
name|CFGWalker
modifier|&
name|Walker
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|}
comment|// end namespace threadSafety
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_THREAD_SAFETY_COMMON_H
end_comment

end_unit

