begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ThreadSafetyTraverse.h ----------------------------------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines a framework for doing generic traversals and rewriting
end_comment

begin_comment
comment|// operations over the Thread Safety TIL.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UNDER CONSTRUCTION.  USE AT YOUR OWN RISK.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_THREAD_SAFETY_TRAVERSE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_THREAD_SAFETY_TRAVERSE_H
end_define

begin_include
include|#
directive|include
file|"ThreadSafetyTIL.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|threadSafety
block|{
name|namespace
name|til
block|{
comment|// Defines an interface used to traverse SExprs.  Traversals have been made as
comment|// generic as possible, and are intended to handle any kind of pass over the
comment|// AST, e.g. visiters, copying, non-destructive rewriting, destructive
comment|// (in-place) rewriting, hashing, typing, etc.
comment|//
comment|// Traversals implement the functional notion of a "fold" operation on SExprs.
comment|// Each SExpr class provides a traverse method, which does the following:
comment|//   * e->traverse(v):
comment|//       // compute a result r_i for each subexpression e_i
comment|//       for (i = 1..n)  r_i = v.traverse(e_i);
comment|//       // combine results into a result for e,  where X is the class of e
comment|//       return v.reduceX(*e, r_1, .. r_n).
comment|//
comment|// A visitor can control the traversal by overriding the following methods:
comment|//   * v.traverse(e):
comment|//       return v.traverseByCase(e), which returns v.traverseX(e)
comment|//   * v.traverseX(e):   (X is the class of e)
comment|//       return e->traverse(v).
comment|//   * v.reduceX(*e, r_1, .. r_n):
comment|//       compute a result for a node of type X
comment|//
comment|// The reduceX methods control the kind of traversal (visitor, copy, etc.).
comment|// They are defined in derived classes.
comment|//
comment|// Class R defines the basic interface types (R_SExpr).
name|template
operator|<
name|class
name|Self
operator|,
name|class
name|R
operator|>
name|class
name|Traversal
block|{
name|public
operator|:
name|Self
operator|*
name|self
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|Self
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
comment|// Traverse an expression -- returning a result of type R_SExpr.
comment|// Override this method to do something for every expression, regardless
comment|// of which kind it is.
name|typename
name|R
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|SExprRef&E
argument_list|,
argument|typename R::R_Ctx Ctx
argument_list|)
block|{
return|return
name|traverse
argument_list|(
name|E
operator|.
name|get
argument_list|()
argument_list|,
name|Ctx
argument_list|)
return|;
block|}
name|typename
name|R
operator|::
name|R_SExpr
name|traverse
argument_list|(
argument|SExpr *E
argument_list|,
argument|typename R::R_Ctx Ctx
argument_list|)
block|{
return|return
name|traverseByCase
argument_list|(
name|E
argument_list|,
name|Ctx
argument_list|)
return|;
block|}
comment|// Helper method to call traverseX(e) on the appropriate type.
name|typename
name|R
operator|::
name|R_SExpr
name|traverseByCase
argument_list|(
argument|SExpr *E
argument_list|,
argument|typename R::R_Ctx Ctx
argument_list|)
block|{
switch|switch
condition|(
name|E
operator|->
name|opcode
argument_list|()
condition|)
block|{
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
define|\
value|case COP_##X:                                                           \       return self()->traverse##X(cast<X>(E), Ctx);
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
block|}
block|}
comment|// Traverse e, by static dispatch on the type "X" of e.
comment|// Override these methods to do something for a particular kind of term.
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
define|\
value|typename R::R_SExpr traverse##X(X *e, typename R::R_Ctx Ctx) {            \     return e->traverse(*self(), Ctx);                                       \   }
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
expr|}
block|;
comment|// Base class for simple reducers that don't much care about the context.
name|class
name|SimpleReducerBase
block|{
name|public
operator|:
expr|enum
name|TraversalKind
block|{
name|TRV_Normal
block|,
name|TRV_Decl
block|,
name|TRV_Lazy
block|,
name|TRV_Type
block|}
block|;
comment|// R_Ctx defines a "context" for the traversal, which encodes information
comment|// about where a term appears.  This can be used to encoding the
comment|// "current continuation" for CPS transforms, or other information.
typedef|typedef
name|TraversalKind
name|R_Ctx
typedef|;
comment|// Create context for an ordinary subexpression.
name|R_Ctx
name|subExprCtx
argument_list|(
argument|R_Ctx Ctx
argument_list|)
block|{
return|return
name|TRV_Normal
return|;
block|}
comment|// Create context for a subexpression that occurs in a declaration position
comment|// (e.g. function body).
name|R_Ctx
name|declCtx
argument_list|(
argument|R_Ctx Ctx
argument_list|)
block|{
return|return
name|TRV_Decl
return|;
block|}
comment|// Create context for a subexpression that occurs in a position that
comment|// should be reduced lazily.  (e.g. code body).
name|R_Ctx
name|lazyCtx
argument_list|(
argument|R_Ctx Ctx
argument_list|)
block|{
return|return
name|TRV_Lazy
return|;
block|}
comment|// Create context for a subexpression that occurs in a type position.
name|R_Ctx
name|typeCtx
argument_list|(
argument|R_Ctx Ctx
argument_list|)
block|{
return|return
name|TRV_Type
return|;
block|}
expr|}
block|;
comment|// Base class for traversals that rewrite an SExpr to another SExpr.
name|class
name|CopyReducerBase
operator|:
name|public
name|SimpleReducerBase
block|{
name|public
operator|:
comment|// R_SExpr is the result type for a traversal.
comment|// A copy or non-destructive rewrite returns a newly allocated term.
typedef|typedef
name|SExpr
modifier|*
name|R_SExpr
typedef|;
typedef|typedef
name|BasicBlock
modifier|*
name|R_BasicBlock
typedef|;
comment|// Container is a minimal interface used to store results when traversing
comment|// SExprs of variable arity, such as Phi, Goto, and SCFG.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|Container
block|{
name|public
operator|:
comment|// Allocate a new container with a capacity for n elements.
name|Container
argument_list|(
argument|CopyReducerBase&S
argument_list|,
argument|unsigned N
argument_list|)
operator|:
name|Elems
argument_list|(
argument|S.Arena
argument_list|,
argument|N
argument_list|)
block|{}
comment|// Push a new element onto the container.
name|void
name|push_back
argument_list|(
argument|T E
argument_list|)
block|{
name|Elems
operator|.
name|push_back
argument_list|(
name|E
argument_list|)
block|; }
name|SimpleArray
operator|<
name|T
operator|>
name|Elems
block|;   }
expr_stmt|;
name|CopyReducerBase
argument_list|(
argument|MemRegionRef A
argument_list|)
block|:
name|Arena
argument_list|(
argument|A
argument_list|)
block|{}
name|protected
label|:
name|MemRegionRef
name|Arena
decl_stmt|;
block|}
empty_stmt|;
comment|// Implements a traversal that makes a deep copy of an SExpr.
comment|// The default behavior of reduce##X(...) is to create a copy of the original.
comment|// Subclasses can override reduce##X to implement non-destructive rewriting
comment|// passes.
name|template
operator|<
name|class
name|Self
operator|>
name|class
name|CopyReducer
operator|:
name|public
name|Traversal
operator|<
name|Self
operator|,
name|CopyReducerBase
operator|>
operator|,
name|public
name|CopyReducerBase
block|{
name|public
operator|:
name|CopyReducer
argument_list|(
argument|MemRegionRef A
argument_list|)
operator|:
name|CopyReducerBase
argument_list|(
argument|A
argument_list|)
block|{}
name|public
operator|:
name|R_SExpr
name|reduceNull
argument_list|()
block|{
return|return
name|nullptr
return|;
block|}
comment|// R_SExpr reduceFuture(...)  is never used.
name|R_SExpr
name|reduceUndefined
argument_list|(
argument|Undefined&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Undefined
argument_list|(
name|Orig
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceWildcard
argument_list|(
argument|Wildcard&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Wildcard
argument_list|(
name|Orig
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceLiteral
argument_list|(
argument|Literal&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Literal
argument_list|(
name|Orig
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|R_SExpr
name|reduceLiteralT
argument_list|(
argument|LiteralT<T>&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|LiteralT
operator|<
name|T
operator|>
operator|(
name|Orig
operator|)
return|;
block|}
name|R_SExpr
name|reduceLiteralPtr
argument_list|(
argument|LiteralPtr&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|LiteralPtr
argument_list|(
name|Orig
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceFunction
argument_list|(
argument|Function&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Function
argument_list|(
name|Orig
argument_list|,
name|Nvd
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceSFunction
argument_list|(
argument|SFunction&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|SFunction
argument_list|(
name|Orig
argument_list|,
name|Nvd
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceCode
argument_list|(
argument|Code&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Code
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceField
argument_list|(
argument|Field&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Field
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceApply
argument_list|(
argument|Apply&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Apply
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceSApply
argument_list|(
argument|SApply&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|SApply
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceProject
argument_list|(
argument|Project&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Project
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceCall
argument_list|(
argument|Call&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Call
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceAlloc
argument_list|(
argument|Alloc&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Alloc
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceLoad
argument_list|(
argument|Load&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Load
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceStore
argument_list|(
argument|Store&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Store
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceArrayIndex
argument_list|(
argument|ArrayIndex&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|ArrayIndex
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceArrayAdd
argument_list|(
argument|ArrayAdd&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|ArrayAdd
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceUnaryOp
argument_list|(
argument|UnaryOp&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|UnaryOp
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceBinaryOp
argument_list|(
argument|BinaryOp&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|BinaryOp
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|,
name|E1
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceCast
argument_list|(
argument|Cast&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Cast
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceSCFG
argument_list|(
argument|SCFG&Orig
argument_list|,
argument|Container<BasicBlock *>&Bbs
argument_list|)
block|{
return|return
name|nullptr
return|;
comment|// FIXME: implement CFG rewriting
block|}
name|R_BasicBlock
name|reduceBasicBlock
argument_list|(
argument|BasicBlock&Orig
argument_list|,
argument|Container<Variable *>&As
argument_list|,
argument|Container<Variable *>&Is
argument_list|,
argument|R_SExpr T
argument_list|)
block|{
return|return
name|nullptr
return|;
comment|// FIXME: implement CFG rewriting
block|}
name|R_SExpr
name|reducePhi
argument_list|(
argument|Phi&Orig
argument_list|,
argument|Container<R_SExpr>&As
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Phi
argument_list|(
name|Orig
argument_list|,
name|std
operator|::
name|move
argument_list|(
name|As
operator|.
name|Elems
argument_list|)
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceGoto
argument_list|(
argument|Goto&Orig
argument_list|,
argument|BasicBlock *B
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Goto
argument_list|(
name|Orig
argument_list|,
name|B
argument_list|,
literal|0
argument_list|)
return|;
comment|// FIXME: set index
block|}
name|R_SExpr
name|reduceBranch
argument_list|(
argument|Branch&O
argument_list|,
argument|R_SExpr C
argument_list|,
argument|BasicBlock *B0
argument_list|,
argument|BasicBlock *B1
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Branch
argument_list|(
name|O
argument_list|,
name|C
argument_list|,
name|B0
argument_list|,
name|B1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
comment|// FIXME: set indices
block|}
name|R_SExpr
name|reduceIdentifier
argument_list|(
argument|Identifier&Orig
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Identifier
argument_list|(
name|Orig
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceIfThenElse
argument_list|(
argument|IfThenElse&Orig
argument_list|,
argument|R_SExpr C
argument_list|,
argument|R_SExpr T
argument_list|,
argument|R_SExpr E
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|IfThenElse
argument_list|(
name|Orig
argument_list|,
name|C
argument_list|,
name|T
argument_list|,
name|E
argument_list|)
return|;
block|}
name|R_SExpr
name|reduceLet
argument_list|(
argument|Let&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr B
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Let
argument_list|(
name|Orig
argument_list|,
name|Nvd
argument_list|,
name|B
argument_list|)
return|;
block|}
comment|// Create a new variable from orig, and push it onto the lexical scope.
name|Variable
operator|*
name|enterScope
argument_list|(
argument|Variable&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|Arena
argument_list|)
name|Variable
argument_list|(
name|Orig
argument_list|,
name|E0
argument_list|)
return|;
block|}
comment|// Exit the lexical scope of orig.
name|void
name|exitScope
argument_list|(
argument|const Variable&Orig
argument_list|)
block|{}
name|void
name|enterCFG
argument_list|(
argument|SCFG&Cfg
argument_list|)
block|{}
name|void
name|exitCFG
argument_list|(
argument|SCFG&Cfg
argument_list|)
block|{}
name|void
name|enterBasicBlock
argument_list|(
argument|BasicBlock&BB
argument_list|)
block|{}
name|void
name|exitBasicBlock
argument_list|(
argument|BasicBlock&BB
argument_list|)
block|{}
comment|// Map Variable references to their rewritten definitions.
name|Variable
operator|*
name|reduceVariableRef
argument_list|(
argument|Variable *Ovd
argument_list|)
block|{
return|return
name|Ovd
return|;
block|}
comment|// Map BasicBlock references to their rewritten definitions.
name|BasicBlock
operator|*
name|reduceBasicBlockRef
argument_list|(
argument|BasicBlock *Obb
argument_list|)
block|{
return|return
name|Obb
return|;
block|}
expr|}
block|;
name|class
name|SExprCopier
operator|:
name|public
name|CopyReducer
operator|<
name|SExprCopier
operator|>
block|{
name|public
operator|:
typedef|typedef
name|SExpr
modifier|*
name|R_SExpr
typedef|;
name|SExprCopier
argument_list|(
argument|MemRegionRef A
argument_list|)
operator|:
name|CopyReducer
argument_list|(
argument|A
argument_list|)
block|{ }
comment|// Create a copy of e in region a.
specifier|static
name|SExpr
operator|*
name|copy
argument_list|(
argument|SExpr *E
argument_list|,
argument|MemRegionRef A
argument_list|)
block|{
name|SExprCopier
name|Copier
argument_list|(
name|A
argument_list|)
block|;
return|return
name|Copier
operator|.
name|traverse
argument_list|(
name|E
argument_list|,
name|TRV_Normal
argument_list|)
return|;
block|}
expr|}
block|;
comment|// Base class for visit traversals.
name|class
name|VisitReducerBase
operator|:
name|public
name|SimpleReducerBase
block|{
name|public
operator|:
comment|// A visitor returns a bool, representing success or failure.
typedef|typedef
name|bool
name|R_SExpr
typedef|;
typedef|typedef
name|bool
name|R_BasicBlock
typedef|;
comment|// A visitor "container" is a single bool, which accumulates success.
name|template
operator|<
name|class
name|T
operator|>
name|class
name|Container
block|{
name|public
operator|:
name|Container
argument_list|(
argument|VisitReducerBase&S
argument_list|,
argument|unsigned N
argument_list|)
operator|:
name|Success
argument_list|(
argument|true
argument_list|)
block|{}
name|void
name|push_back
argument_list|(
argument|bool E
argument_list|)
block|{
name|Success
operator|=
name|Success
operator|&&
name|E
block|; }
name|bool
name|Success
block|;   }
expr_stmt|;
block|}
empty_stmt|;
comment|// Implements a traversal that visits each subexpression, and returns either
comment|// true or false.
name|template
operator|<
name|class
name|Self
operator|>
name|class
name|VisitReducer
operator|:
name|public
name|Traversal
operator|<
name|Self
operator|,
name|VisitReducerBase
operator|>
operator|,
name|public
name|VisitReducerBase
block|{
name|public
operator|:
name|VisitReducer
argument_list|()
block|{}
name|public
operator|:
name|R_SExpr
name|reduceNull
argument_list|()
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceUndefined
argument_list|(
argument|Undefined&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceWildcard
argument_list|(
argument|Wildcard&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceLiteral
argument_list|(
argument|Literal&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|R_SExpr
name|reduceLiteralT
argument_list|(
argument|LiteralT<T>&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceLiteralPtr
argument_list|(
argument|Literal&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceFunction
argument_list|(
argument|Function&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|Nvd
operator|&&
name|E0
return|;
block|}
name|R_SExpr
name|reduceSFunction
argument_list|(
argument|SFunction&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|Nvd
operator|&&
name|E0
return|;
block|}
name|R_SExpr
name|reduceCode
argument_list|(
argument|Code&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceField
argument_list|(
argument|Field&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceApply
argument_list|(
argument|Apply&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceSApply
argument_list|(
argument|SApply&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceProject
argument_list|(
argument|Project&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceCall
argument_list|(
argument|Call&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceAlloc
argument_list|(
argument|Alloc&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceLoad
argument_list|(
argument|Load&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceStore
argument_list|(
argument|Store&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceArrayIndex
argument_list|(
argument|Store&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceArrayAdd
argument_list|(
argument|Store&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceUnaryOp
argument_list|(
argument|UnaryOp&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceBinaryOp
argument_list|(
argument|BinaryOp&Orig
argument_list|,
argument|R_SExpr E0
argument_list|,
argument|R_SExpr E1
argument_list|)
block|{
return|return
name|E0
operator|&&
name|E1
return|;
block|}
name|R_SExpr
name|reduceCast
argument_list|(
argument|Cast&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
name|E0
return|;
block|}
name|R_SExpr
name|reduceSCFG
argument_list|(
argument|SCFG&Orig
argument_list|,
argument|Container<BasicBlock *> Bbs
argument_list|)
block|{
return|return
name|Bbs
operator|.
name|Success
return|;
block|}
name|R_BasicBlock
name|reduceBasicBlock
argument_list|(
argument|BasicBlock&Orig
argument_list|,
argument|Container<Variable *>&As
argument_list|,
argument|Container<Variable *>&Is
argument_list|,
argument|R_SExpr T
argument_list|)
block|{
return|return
operator|(
name|As
operator|.
name|Success
operator|&&
name|Is
operator|.
name|Success
operator|&&
name|T
operator|)
return|;
block|}
name|R_SExpr
name|reducePhi
argument_list|(
argument|Phi&Orig
argument_list|,
argument|Container<R_SExpr>&As
argument_list|)
block|{
return|return
name|As
operator|.
name|Success
return|;
block|}
name|R_SExpr
name|reduceGoto
argument_list|(
argument|Goto&Orig
argument_list|,
argument|BasicBlock *B
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceBranch
argument_list|(
argument|Branch&O
argument_list|,
argument|R_SExpr C
argument_list|,
argument|BasicBlock *B0
argument_list|,
argument|BasicBlock *B1
argument_list|)
block|{
return|return
name|C
return|;
block|}
name|R_SExpr
name|reduceIdentifier
argument_list|(
argument|Identifier&Orig
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|R_SExpr
name|reduceIfThenElse
argument_list|(
argument|IfThenElse&Orig
argument_list|,
argument|R_SExpr C
argument_list|,
argument|R_SExpr T
argument_list|,
argument|R_SExpr E
argument_list|)
block|{
return|return
name|C
operator|&&
name|T
operator|&&
name|E
return|;
block|}
name|R_SExpr
name|reduceLet
argument_list|(
argument|Let&Orig
argument_list|,
argument|Variable *Nvd
argument_list|,
argument|R_SExpr B
argument_list|)
block|{
return|return
name|Nvd
operator|&&
name|B
return|;
block|}
name|Variable
operator|*
name|enterScope
argument_list|(
argument|Variable&Orig
argument_list|,
argument|R_SExpr E0
argument_list|)
block|{
return|return
operator|&
name|Orig
return|;
block|}
name|void
name|exitScope
argument_list|(
argument|const Variable&Orig
argument_list|)
block|{}
name|void
name|enterCFG
argument_list|(
argument|SCFG&Cfg
argument_list|)
block|{}
name|void
name|exitCFG
argument_list|(
argument|SCFG&Cfg
argument_list|)
block|{}
name|void
name|enterBasicBlock
argument_list|(
argument|BasicBlock&BB
argument_list|)
block|{}
name|void
name|exitBasicBlock
argument_list|(
argument|BasicBlock&BB
argument_list|)
block|{}
name|Variable
operator|*
name|reduceVariableRef
argument_list|(
argument|Variable *Ovd
argument_list|)
block|{
return|return
name|Ovd
return|;
block|}
name|BasicBlock
operator|*
name|reduceBasicBlockRef
argument_list|(
argument|BasicBlock *Obb
argument_list|)
block|{
return|return
name|Obb
return|;
block|}
name|public
operator|:
name|bool
name|traverse
argument_list|(
argument|SExpr *E
argument_list|,
argument|TraversalKind K = TRV_Normal
argument_list|)
block|{
name|Success
operator|=
name|Success
operator|&&
name|this
operator|->
name|traverseByCase
argument_list|(
name|E
argument_list|)
block|;
return|return
name|Success
return|;
block|}
specifier|static
name|bool
name|visit
argument_list|(
argument|SExpr *E
argument_list|)
block|{
name|Self
name|Visitor
block|;
return|return
name|Visitor
operator|.
name|traverse
argument_list|(
name|E
argument_list|,
name|TRV_Normal
argument_list|)
return|;
block|}
name|private
operator|:
name|bool
name|Success
block|; }
expr_stmt|;
comment|// Basic class for comparison operations over expressions.
name|template
operator|<
name|typename
name|Self
operator|>
name|class
name|Comparator
block|{
name|protected
operator|:
name|Self
operator|*
name|self
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Self
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|public
operator|:
name|bool
name|compareByCase
argument_list|(
argument|SExpr *E1
argument_list|,
argument|SExpr* E2
argument_list|)
block|{
switch|switch
condition|(
name|E1
operator|->
name|opcode
argument_list|()
condition|)
block|{
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
define|\
value|case COP_##X:                                                             \       return cast<X>(E1)->compare(cast<X>(E2), *self());
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
block|}
block|}
expr|}
block|;
name|class
name|EqualsComparator
operator|:
name|public
name|Comparator
operator|<
name|EqualsComparator
operator|>
block|{
name|public
operator|:
comment|// Result type for the comparison, e.g. bool for simple equality,
comment|// or int for lexigraphic comparison (-1, 0, 1).  Must have one value which
comment|// denotes "true".
typedef|typedef
name|bool
name|CType
typedef|;
name|CType
name|trueResult
argument_list|()
block|{
return|return
name|true
return|;
block|}
name|bool
name|notTrue
argument_list|(
argument|CType ct
argument_list|)
block|{
return|return
operator|!
name|ct
return|;
block|}
name|bool
name|compareIntegers
argument_list|(
argument|unsigned i
argument_list|,
argument|unsigned j
argument_list|)
block|{
return|return
name|i
operator|==
name|j
return|;
block|}
name|bool
name|compareStrings
argument_list|(
argument|StringRef s
argument_list|,
argument|StringRef r
argument_list|)
block|{
return|return
name|s
operator|==
name|r
return|;
block|}
name|bool
name|comparePointers
argument_list|(
argument|const void* P
argument_list|,
argument|const void* Q
argument_list|)
block|{
return|return
name|P
operator|==
name|Q
return|;
block|}
name|bool
name|compare
argument_list|(
argument|SExpr *E1
argument_list|,
argument|SExpr* E2
argument_list|)
block|{
if|if
condition|(
name|E1
operator|->
name|opcode
argument_list|()
operator|!=
name|E2
operator|->
name|opcode
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|compareByCase
argument_list|(
name|E1
argument_list|,
name|E2
argument_list|)
return|;
block|}
comment|// TODO -- handle alpha-renaming of variables
name|void
name|enterScope
parameter_list|(
name|Variable
modifier|*
name|V1
parameter_list|,
name|Variable
modifier|*
name|V2
parameter_list|)
block|{ }
name|void
name|leaveScope
parameter_list|()
block|{ }
name|bool
name|compareVariableRefs
parameter_list|(
name|Variable
modifier|*
name|V1
parameter_list|,
name|Variable
modifier|*
name|V2
parameter_list|)
block|{
return|return
name|V1
operator|==
name|V2
return|;
block|}
specifier|static
name|bool
name|compareExprs
parameter_list|(
name|SExpr
modifier|*
name|E1
parameter_list|,
name|SExpr
modifier|*
name|E2
parameter_list|)
block|{
name|EqualsComparator
name|Eq
decl_stmt|;
return|return
name|Eq
operator|.
name|compare
argument_list|(
name|E1
argument_list|,
name|E2
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Pretty printer for TIL expressions
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Self
operator|,
name|typename
name|StreamType
operator|>
name|class
name|PrettyPrinter
block|{
name|private
operator|:
name|bool
name|Verbose
block|;
comment|// Print out additional information
name|bool
name|Cleanup
block|;
comment|// Omit redundant decls.
name|public
operator|:
name|PrettyPrinter
argument_list|(
argument|bool V = false
argument_list|,
argument|bool C = true
argument_list|)
operator|:
name|Verbose
argument_list|(
name|V
argument_list|)
block|,
name|Cleanup
argument_list|(
argument|C
argument_list|)
block|{ }
specifier|static
name|void
name|print
argument_list|(
argument|SExpr *E
argument_list|,
argument|StreamType&SS
argument_list|)
block|{
name|Self
name|printer
block|;
name|printer
operator|.
name|printSExpr
argument_list|(
name|E
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
block|;   }
name|protected
operator|:
name|Self
operator|*
name|self
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Self
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|void
name|newline
argument_list|(
argument|StreamType&SS
argument_list|)
block|{
name|SS
operator|<<
literal|"\n"
block|;   }
comment|// TODO: further distinguish between binary operations.
specifier|static
specifier|const
name|unsigned
name|Prec_Atom
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_Postfix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_Unary
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_Binary
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_Other
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_Decl
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|Prec_MAX
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Return the precedence of a given node, for use in pretty printing.
end_comment

begin_function
name|unsigned
name|precedence
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|)
block|{
switch|switch
condition|(
name|E
operator|->
name|opcode
argument_list|()
condition|)
block|{
case|case
name|COP_Future
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Undefined
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Wildcard
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Literal
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_LiteralPtr
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Variable
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Function
case|:
return|return
name|Prec_Decl
return|;
case|case
name|COP_SFunction
case|:
return|return
name|Prec_Decl
return|;
case|case
name|COP_Code
case|:
return|return
name|Prec_Decl
return|;
case|case
name|COP_Field
case|:
return|return
name|Prec_Decl
return|;
case|case
name|COP_Apply
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_SApply
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_Project
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_Call
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_Alloc
case|:
return|return
name|Prec_Other
return|;
case|case
name|COP_Load
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_Store
case|:
return|return
name|Prec_Other
return|;
case|case
name|COP_ArrayIndex
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_ArrayAdd
case|:
return|return
name|Prec_Postfix
return|;
case|case
name|COP_UnaryOp
case|:
return|return
name|Prec_Unary
return|;
case|case
name|COP_BinaryOp
case|:
return|return
name|Prec_Binary
return|;
case|case
name|COP_Cast
case|:
return|return
name|Prec_Unary
return|;
case|case
name|COP_SCFG
case|:
return|return
name|Prec_Decl
return|;
case|case
name|COP_BasicBlock
case|:
return|return
name|Prec_MAX
return|;
case|case
name|COP_Phi
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Goto
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Branch
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_Identifier
case|:
return|return
name|Prec_Atom
return|;
case|case
name|COP_IfThenElse
case|:
return|return
name|Prec_Other
return|;
case|case
name|COP_Let
case|:
return|return
name|Prec_Decl
return|;
block|}
return|return
name|Prec_MAX
return|;
block|}
end_function

begin_function
name|void
name|printBlockLabel
parameter_list|(
name|StreamType
modifier|&
name|SS
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|unsigned
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BB
condition|)
block|{
name|SS
operator|<<
literal|"BB_null"
expr_stmt|;
return|return;
block|}
name|SS
operator|<<
literal|"BB_"
expr_stmt|;
name|SS
operator|<<
name|BB
operator|->
name|blockID
argument_list|()
expr_stmt|;
name|SS
operator|<<
literal|":"
expr_stmt|;
name|SS
operator|<<
name|index
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printSExpr
parameter_list|(
name|SExpr
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|,
name|unsigned
name|P
parameter_list|)
block|{
if|if
condition|(
operator|!
name|E
condition|)
block|{
name|self
argument_list|()
operator|->
name|printNull
argument_list|(
name|SS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|self
argument_list|()
operator|->
name|precedence
argument_list|(
name|E
argument_list|)
operator|>
name|P
condition|)
block|{
comment|// Wrap expr in () if necessary.
name|SS
operator|<<
literal|"("
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|")"
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|E
operator|->
name|opcode
argument_list|()
condition|)
block|{
define|#
directive|define
name|TIL_OPCODE_DEF
parameter_list|(
name|X
parameter_list|)
define|\
value|case COP_##X:                                                          \       self()->print##X(cast<X>(E), SS);                                    \       return;
include|#
directive|include
file|"ThreadSafetyOps.def"
undef|#
directive|undef
name|TIL_OPCODE_DEF
block|}
block|}
end_function

begin_function
name|void
name|printNull
parameter_list|(
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"#null"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printFuture
parameter_list|(
name|Future
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|maybeGetResult
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Atom
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printUndefined
parameter_list|(
name|Undefined
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"#undefined"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printWildcard
parameter_list|(
name|Wildcard
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"_"
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|void
name|printLiteralT
argument_list|(
argument|LiteralT<T> *E
argument_list|,
argument|StreamType&SS
argument_list|)
block|{
name|SS
operator|<<
name|E
operator|->
name|value
argument_list|()
block|;   }
name|void
name|printLiteralT
argument_list|(
argument|LiteralT<uint8_t> *E
argument_list|,
argument|StreamType&SS
argument_list|)
block|{
name|SS
operator|<<
literal|"'"
operator|<<
name|E
operator|->
name|value
argument_list|()
operator|<<
literal|"'"
block|;   }
name|void
name|printLiteral
argument_list|(
argument|Literal *E
argument_list|,
argument|StreamType&SS
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|clangExpr
argument_list|()
condition|)
block|{
name|SS
operator|<<
name|getSourceLiteralString
argument_list|(
name|E
operator|->
name|clangExpr
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|ValueType
name|VT
init|=
name|E
operator|->
name|valueType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|VT
operator|.
name|Base
condition|)
block|{
case|case
name|ValueType
operator|::
name|BT_Void
case|:
block|{
name|SS
operator|<<
literal|"void"
expr_stmt|;
return|return;
block|}
case|case
name|ValueType
operator|::
name|BT_Bool
case|:
block|{
if|if
condition|(
name|E
operator|->
name|as
operator|<
name|bool
operator|>
operator|(
operator|)
operator|.
name|value
argument_list|()
condition|)
name|SS
operator|<<
literal|"true"
expr_stmt|;
else|else
name|SS
operator|<<
literal|"false"
expr_stmt|;
return|return;
block|}
case|case
name|ValueType
operator|::
name|BT_Int
case|:
block|{
switch|switch
condition|(
name|VT
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_8
case|:
if|if
condition|(
name|VT
operator|.
name|Signed
condition|)
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|int8_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
else|else
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|uint8_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
case|case
name|ValueType
operator|::
name|ST_16
case|:
if|if
condition|(
name|VT
operator|.
name|Signed
condition|)
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|int16_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
else|else
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|uint16_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
case|case
name|ValueType
operator|::
name|ST_32
case|:
if|if
condition|(
name|VT
operator|.
name|Signed
condition|)
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|int32_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
else|else
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|uint32_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
case|case
name|ValueType
operator|::
name|ST_64
case|:
if|if
condition|(
name|VT
operator|.
name|Signed
condition|)
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|int64_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
else|else
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|uint64_t
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|ValueType
operator|::
name|BT_Float
case|:
block|{
switch|switch
condition|(
name|VT
operator|.
name|Size
condition|)
block|{
case|case
name|ValueType
operator|::
name|ST_32
case|:
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|float
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
case|case
name|ValueType
operator|::
name|ST_64
case|:
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|double
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|ValueType
operator|::
name|BT_String
case|:
block|{
name|SS
operator|<<
literal|"\""
expr_stmt|;
name|printLiteralT
argument_list|(
operator|&
name|E
operator|->
name|as
operator|<
name|StringRef
operator|>
operator|(
operator|)
argument_list|,
name|SS
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"\""
expr_stmt|;
return|return;
block|}
case|case
name|ValueType
operator|::
name|BT_Pointer
case|:
block|{
name|SS
operator|<<
literal|"#ptr"
expr_stmt|;
return|return;
block|}
case|case
name|ValueType
operator|::
name|BT_ValueRef
case|:
block|{
name|SS
operator|<<
literal|"#vref"
expr_stmt|;
return|return;
block|}
block|}
block|}
end_else

begin_expr_stmt
name|SS
operator|<<
literal|"#lit"
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    void
name|printLiteralPtr
argument_list|(
argument|LiteralPtr *E
argument_list|,
argument|StreamType&SS
argument_list|)
end_macro

begin_block
block|{
name|SS
operator|<<
name|E
operator|->
name|clangDecl
argument_list|()
operator|->
name|getNameAsString
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|void
name|printVariable
parameter_list|(
name|Variable
modifier|*
name|V
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|,
name|bool
name|IsVarDecl
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IsVarDecl
operator|&&
name|Cleanup
condition|)
block|{
name|SExpr
modifier|*
name|E
init|=
name|getCanonicalVal
argument_list|(
name|V
argument_list|)
decl_stmt|;
if|if
condition|(
name|E
operator|!=
name|V
condition|)
block|{
name|printSExpr
argument_list|(
name|E
argument_list|,
name|SS
argument_list|,
name|Prec_Atom
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|V
operator|->
name|kind
argument_list|()
operator|==
name|Variable
operator|::
name|VK_LetBB
condition|)
name|SS
operator|<<
name|V
operator|->
name|name
argument_list|()
operator|<<
name|V
operator|->
name|getBlockID
argument_list|()
operator|<<
literal|"_"
operator|<<
name|V
operator|->
name|getID
argument_list|()
expr_stmt|;
else|else
name|SS
operator|<<
name|V
operator|->
name|name
argument_list|()
operator|<<
name|V
operator|->
name|getID
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printFunction
parameter_list|(
name|Function
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|,
name|unsigned
name|sugared
init|=
literal|0
parameter_list|)
block|{
switch|switch
condition|(
name|sugared
condition|)
block|{
default|default:
name|SS
operator|<<
literal|"\\("
expr_stmt|;
comment|// Lambda
break|break;
case|case
literal|1
case|:
name|SS
operator|<<
literal|"("
expr_stmt|;
comment|// Slot declarations
break|break;
case|case
literal|2
case|:
name|SS
operator|<<
literal|", "
expr_stmt|;
comment|// Curried functions
break|break;
block|}
name|self
argument_list|()
operator|->
name|printVariable
argument_list|(
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|": "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|variableDecl
argument_list|()
operator|->
name|definition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SExpr
modifier|*
name|B
init|=
name|E
operator|->
name|body
argument_list|()
decl_stmt|;
if|if
condition|(
name|B
operator|&&
name|B
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Function
condition|)
name|self
argument_list|()
operator|->
name|printFunction
argument_list|(
name|cast
operator|<
name|Function
operator|>
operator|(
name|B
operator|)
argument_list|,
name|SS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|SS
operator|<<
literal|")"
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|B
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|printSFunction
parameter_list|(
name|SFunction
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"@"
expr_stmt|;
name|self
argument_list|()
operator|->
name|printVariable
argument_list|(
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|body
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printCode
parameter_list|(
name|Code
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|": "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|returnType
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" -> "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|body
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printField
parameter_list|(
name|Field
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|": "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|range
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" = "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|body
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printApply
parameter_list|(
name|Apply
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|,
name|bool
name|sugared
init|=
name|false
parameter_list|)
block|{
name|SExpr
modifier|*
name|F
init|=
name|E
operator|->
name|fun
argument_list|()
decl_stmt|;
if|if
condition|(
name|F
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Apply
condition|)
block|{
name|printApply
argument_list|(
name|cast
operator|<
name|Apply
operator|>
operator|(
name|F
operator|)
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|", "
expr_stmt|;
block|}
else|else
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|F
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"("
expr_stmt|;
block|}
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|arg
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sugared
condition|)
name|SS
operator|<<
literal|")$"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printSApply
parameter_list|(
name|SApply
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|sfun
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|->
name|isDelegation
argument_list|()
condition|)
block|{
name|SS
operator|<<
literal|"@("
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|arg
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|printProject
parameter_list|(
name|Project
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|record
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"."
expr_stmt|;
name|SS
operator|<<
name|E
operator|->
name|slotName
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printCall
parameter_list|(
name|Call
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SExpr
modifier|*
name|T
init|=
name|E
operator|->
name|target
argument_list|()
decl_stmt|;
if|if
condition|(
name|T
operator|->
name|opcode
argument_list|()
operator|==
name|COP_Apply
condition|)
block|{
name|self
argument_list|()
operator|->
name|printApply
argument_list|(
name|cast
operator|<
name|Apply
operator|>
operator|(
name|T
operator|)
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|T
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"()"
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|printAlloc
parameter_list|(
name|Alloc
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"new "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|dataType
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Other
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printLoad
parameter_list|(
name|Load
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|pointer
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"^"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printStore
parameter_list|(
name|Store
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|destination
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Other
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" := "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|source
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Other
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printArrayIndex
parameter_list|(
name|ArrayIndex
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|array
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"["
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|index
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"]"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printArrayAdd
parameter_list|(
name|ArrayAdd
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|array
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Postfix
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" + "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|index
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Atom
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printUnaryOp
parameter_list|(
name|UnaryOp
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
name|getUnaryOpcodeString
argument_list|(
name|E
operator|->
name|unaryOpcode
argument_list|()
argument_list|)
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|expr
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Unary
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printBinaryOp
parameter_list|(
name|BinaryOp
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|expr0
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Binary
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" "
operator|<<
name|getBinaryOpcodeString
argument_list|(
name|E
operator|->
name|binaryOpcode
argument_list|()
argument_list|)
operator|<<
literal|" "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|expr1
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Binary
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printCast
parameter_list|(
name|Cast
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"%"
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|expr
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Unary
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printSCFG
parameter_list|(
name|SCFG
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"CFG {\n"
expr_stmt|;
for|for
control|(
name|auto
name|BBI
range|:
operator|*
name|E
control|)
block|{
name|printBasicBlock
argument_list|(
name|BBI
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
name|SS
operator|<<
literal|"}"
expr_stmt|;
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printBasicBlock
parameter_list|(
name|BasicBlock
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"BB_"
operator|<<
name|E
operator|->
name|blockID
argument_list|()
operator|<<
literal|":"
expr_stmt|;
if|if
condition|(
name|E
operator|->
name|parent
argument_list|()
condition|)
name|SS
operator|<<
literal|" BB_"
operator|<<
name|E
operator|->
name|parent
argument_list|()
operator|->
name|blockID
argument_list|()
expr_stmt|;
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|*
name|A
operator|:
name|E
operator|->
name|arguments
argument_list|()
control|)
block|{
name|SS
operator|<<
literal|"let "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printVariable
argument_list|(
name|A
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" = "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|A
operator|->
name|definition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|";"
expr_stmt|;
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|auto
operator|*
name|I
operator|:
name|E
operator|->
name|instructions
argument_list|()
control|)
block|{
if|if
condition|(
name|I
operator|->
name|definition
argument_list|()
operator|->
name|opcode
argument_list|()
operator|!=
name|COP_Store
condition|)
block|{
name|SS
operator|<<
literal|"let "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printVariable
argument_list|(
name|I
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" = "
expr_stmt|;
block|}
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|I
operator|->
name|definition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|";"
expr_stmt|;
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
block|}
name|SExpr
modifier|*
name|T
init|=
name|E
operator|->
name|terminator
argument_list|()
decl_stmt|;
if|if
condition|(
name|T
condition|)
block|{
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|T
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|";"
expr_stmt|;
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
block|}
name|newline
argument_list|(
name|SS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printPhi
parameter_list|(
name|Phi
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"phi("
expr_stmt|;
if|if
condition|(
name|E
operator|->
name|status
argument_list|()
operator|==
name|Phi
operator|::
name|PH_SingleVal
condition|)
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|values
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|auto
name|V
range|:
name|E
operator|->
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
name|SS
operator|<<
literal|", "
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|V
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
block|}
block|}
name|SS
operator|<<
literal|")"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printGoto
parameter_list|(
name|Goto
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"goto "
expr_stmt|;
name|printBlockLabel
argument_list|(
name|SS
argument_list|,
name|E
operator|->
name|targetBlock
argument_list|()
argument_list|,
name|E
operator|->
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printBranch
parameter_list|(
name|Branch
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"branch ("
expr_stmt|;
name|self
argument_list|()
operator|->
name|printSExpr
argument_list|(
name|E
operator|->
name|condition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|") "
expr_stmt|;
name|printBlockLabel
argument_list|(
name|SS
argument_list|,
name|E
operator|->
name|thenBlock
argument_list|()
argument_list|,
name|E
operator|->
name|thenIndex
argument_list|()
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" "
expr_stmt|;
name|printBlockLabel
argument_list|(
name|SS
argument_list|,
name|E
operator|->
name|elseBlock
argument_list|()
argument_list|,
name|E
operator|->
name|elseIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printIdentifier
parameter_list|(
name|Identifier
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
name|E
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printIfThenElse
parameter_list|(
name|IfThenElse
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"if ("
expr_stmt|;
name|printSExpr
argument_list|(
name|E
operator|->
name|condition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_MAX
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|") then "
expr_stmt|;
name|printSExpr
argument_list|(
name|E
operator|->
name|thenExpr
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Other
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" else "
expr_stmt|;
name|printSExpr
argument_list|(
name|E
operator|->
name|elseExpr
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Other
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printLet
parameter_list|(
name|Let
modifier|*
name|E
parameter_list|,
name|StreamType
modifier|&
name|SS
parameter_list|)
block|{
name|SS
operator|<<
literal|"let "
expr_stmt|;
name|printVariable
argument_list|(
name|E
operator|->
name|variableDecl
argument_list|()
argument_list|,
name|SS
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|" = "
expr_stmt|;
name|printSExpr
argument_list|(
name|E
operator|->
name|variableDecl
argument_list|()
operator|->
name|definition
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SS
operator|<<
literal|"; "
expr_stmt|;
name|printSExpr
argument_list|(
name|E
operator|->
name|body
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Prec_Decl
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};   }
comment|// end namespace til
end_comment

begin_comment
unit|}
comment|// end namespace threadSafety
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_THREAD_SAFETY_TRAVERSE_H
end_comment

end_unit

