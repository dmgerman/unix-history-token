begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=== AnalysisContext.h - Analysis context for Path Sens analysis --*- C++ -*-//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines AnalysisDeclContext, a class that manages the analysis
end_comment

begin_comment
comment|// context data for path sensitive analysis.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_ANALYSISCONTEXT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_ANALYSISCONTEXT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/Analysis/CFG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Stmt
decl_stmt|;
name|class
name|CFGReverseBlockReachabilityAnalysis
decl_stmt|;
name|class
name|CFGStmtMap
decl_stmt|;
name|class
name|LiveVariables
decl_stmt|;
name|class
name|ManagedAnalysis
decl_stmt|;
name|class
name|ParentMap
decl_stmt|;
name|class
name|PseudoConstantAnalysis
decl_stmt|;
name|class
name|LocationContextManager
decl_stmt|;
name|class
name|StackFrameContext
decl_stmt|;
name|class
name|BlockInvocationContext
decl_stmt|;
name|class
name|AnalysisDeclContextManager
decl_stmt|;
name|class
name|LocationContext
decl_stmt|;
name|namespace
name|idx
block|{
name|class
name|TranslationUnit
decl_stmt|;
block|}
comment|/// The base class of a hierarchy of objects representing analyses tied
comment|/// to AnalysisDeclContext.
name|class
name|ManagedAnalysis
block|{
name|protected
label|:
name|ManagedAnalysis
argument_list|()
block|{}
name|public
label|:
name|virtual
operator|~
name|ManagedAnalysis
argument_list|()
expr_stmt|;
comment|// Subclasses need to implement:
comment|//
comment|//  static const void *getTag();
comment|//
comment|// Which returns a fixed pointer address to distinguish classes of
comment|// analysis objects.  They also need to implement:
comment|//
comment|//  static [Derived*] create(AnalysisDeclContext&Ctx);
comment|//
comment|// which creates the analysis object given an AnalysisDeclContext.
block|}
empty_stmt|;
comment|/// AnalysisDeclContext contains the context data for the function or method
comment|/// under analysis.
name|class
name|AnalysisDeclContext
block|{
comment|/// Backpoint to the AnalysisManager object that created this
comment|/// AnalysisDeclContext. This may be null.
name|AnalysisDeclContextManager
modifier|*
name|Manager
decl_stmt|;
specifier|const
name|Decl
modifier|*
specifier|const
name|D
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|CFG
operator|>
name|cfg
operator|,
name|completeCFG
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|CFGStmtMap
operator|>
name|cfgStmtMap
expr_stmt|;
name|CFG
operator|::
name|BuildOptions
name|cfgBuildOptions
expr_stmt|;
name|CFG
operator|::
name|BuildOptions
operator|::
name|ForcedBlkExprs
operator|*
name|forcedBlkExprs
expr_stmt|;
name|bool
name|builtCFG
decl_stmt|,
name|builtCompleteCFG
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ParentMap
operator|>
name|PM
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|PseudoConstantAnalysis
operator|>
name|PCA
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|CFGReverseBlockReachabilityAnalysis
operator|>
name|CFA
expr_stmt|;
name|llvm
operator|::
name|BumpPtrAllocator
name|A
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|BlockDecl
operator|*
operator|,
name|void
operator|*
operator|>
operator|*
name|ReferencedBlockVars
expr_stmt|;
name|void
modifier|*
name|ManagedAnalyses
decl_stmt|;
name|public
label|:
name|AnalysisDeclContext
argument_list|(
name|AnalysisDeclContextManager
operator|*
name|Mgr
argument_list|,
specifier|const
name|Decl
operator|*
name|D
argument_list|)
expr_stmt|;
name|AnalysisDeclContext
argument_list|(
name|AnalysisDeclContextManager
operator|*
name|Mgr
argument_list|,
specifier|const
name|Decl
operator|*
name|D
argument_list|,
specifier|const
name|CFG
operator|::
name|BuildOptions
operator|&
name|BuildOptions
argument_list|)
expr_stmt|;
operator|~
name|AnalysisDeclContext
argument_list|()
expr_stmt|;
name|ASTContext
operator|&
name|getASTContext
argument_list|()
specifier|const
block|{
return|return
name|D
operator|->
name|getASTContext
argument_list|()
return|;
block|}
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|D
return|;
block|}
comment|/// Return the AnalysisDeclContextManager (if any) that created
comment|/// this AnalysisDeclContext.
name|AnalysisDeclContextManager
operator|*
name|getManager
argument_list|()
specifier|const
block|{
return|return
name|Manager
return|;
block|}
comment|/// Return the build options used to construct the CFG.
name|CFG
operator|::
name|BuildOptions
operator|&
name|getCFGBuildOptions
argument_list|()
block|{
return|return
name|cfgBuildOptions
return|;
block|}
specifier|const
name|CFG
operator|::
name|BuildOptions
operator|&
name|getCFGBuildOptions
argument_list|()
specifier|const
block|{
return|return
name|cfgBuildOptions
return|;
block|}
comment|/// getAddEHEdges - Return true iff we are adding exceptional edges from
comment|/// callExprs.  If this is false, then try/catch statements and blocks
comment|/// reachable from them can appear to be dead in the CFG, analysis passes must
comment|/// cope with that.
name|bool
name|getAddEHEdges
argument_list|()
specifier|const
block|{
return|return
name|cfgBuildOptions
operator|.
name|AddEHEdges
return|;
block|}
name|bool
name|getUseUnoptimizedCFG
argument_list|()
specifier|const
block|{
return|return
operator|!
name|cfgBuildOptions
operator|.
name|PruneTriviallyFalseEdges
return|;
block|}
name|bool
name|getAddImplicitDtors
argument_list|()
specifier|const
block|{
return|return
name|cfgBuildOptions
operator|.
name|AddImplicitDtors
return|;
block|}
name|bool
name|getAddInitializers
argument_list|()
specifier|const
block|{
return|return
name|cfgBuildOptions
operator|.
name|AddInitializers
return|;
block|}
name|void
name|registerForcedBlockExpression
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|stmt
parameter_list|)
function_decl|;
specifier|const
name|CFGBlock
modifier|*
name|getBlockForRegisteredExpression
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|stmt
parameter_list|)
function_decl|;
comment|/// \brief Get the body of the Declaration.
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Get the body of the Declaration.
comment|/// \param[out] IsAutosynthesized Specifies if the body is auto-generated
comment|///             by the BodyFarm.
name|Stmt
modifier|*
name|getBody
argument_list|(
name|bool
operator|&
name|IsAutosynthesized
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Checks if the body of the Decl is generated by the BodyFarm.
comment|///
comment|/// Note, the lookup is not free. We are going to call getBody behind
comment|/// the scenes.
comment|/// \sa getBody
name|bool
name|isBodyAutosynthesized
argument_list|()
specifier|const
expr_stmt|;
name|CFG
modifier|*
name|getCFG
parameter_list|()
function_decl|;
name|CFGStmtMap
modifier|*
name|getCFGStmtMap
parameter_list|()
function_decl|;
name|CFGReverseBlockReachabilityAnalysis
modifier|*
name|getCFGReachablityAnalysis
parameter_list|()
function_decl|;
comment|/// Return a version of the CFG without any edges pruned.
name|CFG
modifier|*
name|getUnoptimizedCFG
parameter_list|()
function_decl|;
name|void
name|dumpCFG
parameter_list|(
name|bool
name|ShowColors
parameter_list|)
function_decl|;
comment|/// \brief Returns true if we have built a CFG for this analysis context.
comment|/// Note that this doesn't correspond to whether or not a valid CFG exists, it
comment|/// corresponds to whether we *attempted* to build one.
name|bool
name|isCFGBuilt
argument_list|()
specifier|const
block|{
return|return
name|builtCFG
return|;
block|}
name|ParentMap
modifier|&
name|getParentMap
parameter_list|()
function_decl|;
name|PseudoConstantAnalysis
modifier|*
name|getPseudoConstantAnalysis
parameter_list|()
function_decl|;
typedef|typedef
specifier|const
name|VarDecl
modifier|*
specifier|const
modifier|*
name|referenced_decls_iterator
typedef|;
name|std
operator|::
name|pair
operator|<
name|referenced_decls_iterator
operator|,
name|referenced_decls_iterator
operator|>
name|getReferencedBlockVars
argument_list|(
specifier|const
name|BlockDecl
operator|*
name|BD
argument_list|)
expr_stmt|;
comment|/// Return the ImplicitParamDecl* associated with 'self' if this
comment|/// AnalysisDeclContext wraps an ObjCMethodDecl.  Returns NULL otherwise.
specifier|const
name|ImplicitParamDecl
operator|*
name|getSelfDecl
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|StackFrameContext
modifier|*
name|getStackFrame
parameter_list|(
name|LocationContext
specifier|const
modifier|*
name|Parent
parameter_list|,
specifier|const
name|Stmt
modifier|*
name|S
parameter_list|,
specifier|const
name|CFGBlock
modifier|*
name|Blk
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
specifier|const
name|BlockInvocationContext
modifier|*
name|getBlockInvocationContext
parameter_list|(
specifier|const
name|LocationContext
modifier|*
name|parent
parameter_list|,
specifier|const
name|BlockDecl
modifier|*
name|BD
parameter_list|,
specifier|const
name|void
modifier|*
name|ContextData
parameter_list|)
function_decl|;
comment|/// Return the specified analysis object, lazily running the analysis if
comment|/// necessary.  Return NULL if the analysis could not run.
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|getAnalysis
argument_list|()
block|{
specifier|const
name|void
operator|*
name|tag
operator|=
name|T
operator|::
name|getTag
argument_list|()
block|;
name|ManagedAnalysis
operator|*
operator|&
name|data
operator|=
name|getAnalysisImpl
argument_list|(
name|tag
argument_list|)
block|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|data
operator|=
name|T
operator|::
name|create
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|data
operator|)
return|;
block|}
name|private
label|:
name|ManagedAnalysis
modifier|*
modifier|&
name|getAnalysisImpl
parameter_list|(
specifier|const
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|LocationContextManager
modifier|&
name|getLocationContextManager
parameter_list|()
function_decl|;
block|}
empty_stmt|;
name|class
name|LocationContext
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|ContextKind
block|{
name|StackFrame
block|,
name|Scope
block|,
name|Block
block|}
block|;
name|private
operator|:
name|ContextKind
name|Kind
block|;
comment|// AnalysisDeclContext can't be const since some methods may modify its
comment|// member.
name|AnalysisDeclContext
operator|*
name|Ctx
block|;
specifier|const
name|LocationContext
operator|*
name|Parent
block|;
name|protected
operator|:
name|LocationContext
argument_list|(
argument|ContextKind k
argument_list|,
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|)
operator|:
name|Kind
argument_list|(
name|k
argument_list|)
block|,
name|Ctx
argument_list|(
name|ctx
argument_list|)
block|,
name|Parent
argument_list|(
argument|parent
argument_list|)
block|{}
name|public
operator|:
name|virtual
operator|~
name|LocationContext
argument_list|()
block|;
name|ContextKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|AnalysisDeclContext
operator|*
name|getAnalysisDeclContext
argument_list|()
specifier|const
block|{
return|return
name|Ctx
return|;
block|}
specifier|const
name|LocationContext
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
name|bool
name|isParentOf
argument_list|(
argument|const LocationContext *LC
argument_list|)
specifier|const
block|;
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisDeclContext
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
name|CFG
operator|*
name|getCFG
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisDeclContext
argument_list|()
operator|->
name|getCFG
argument_list|()
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|getAnalysis
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisDeclContext
argument_list|()
operator|->
name|getAnalysis
operator|<
name|T
operator|>
operator|(
operator|)
return|;
block|}
name|ParentMap
operator|&
name|getParentMap
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisDeclContext
argument_list|()
operator|->
name|getParentMap
argument_list|()
return|;
block|}
specifier|const
name|ImplicitParamDecl
operator|*
name|getSelfDecl
argument_list|()
specifier|const
block|{
return|return
name|Ctx
operator|->
name|getSelfDecl
argument_list|()
return|;
block|}
specifier|const
name|StackFrameContext
operator|*
name|getCurrentStackFrame
argument_list|()
specifier|const
block|;
comment|/// Return true if the current LocationContext has no caller context.
name|virtual
name|bool
name|inTopFrame
argument_list|()
specifier|const
block|;
name|virtual
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
operator|=
literal|0
block|;
name|void
name|dumpStack
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|StringRef Indent =
literal|""
argument_list|)
specifier|const
block|;
name|void
name|dumpStack
argument_list|()
specifier|const
block|;
name|public
operator|:
specifier|static
name|void
name|ProfileCommon
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|ContextKind ck
argument_list|,
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const void *data
argument_list|)
block|; }
decl_stmt|;
name|class
name|StackFrameContext
range|:
name|public
name|LocationContext
block|{
comment|// The callsite where this stack frame is established.
specifier|const
name|Stmt
operator|*
name|CallSite
block|;
comment|// The parent block of the callsite.
specifier|const
name|CFGBlock
operator|*
name|Block
block|;
comment|// The index of the callsite in the CFGBlock.
name|unsigned
name|Index
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|StackFrameContext
argument_list|(
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|StackFrame
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|CallSite
argument_list|(
name|s
argument_list|)
block|,
name|Block
argument_list|(
name|blk
argument_list|)
block|,
name|Index
argument_list|(
argument|idx
argument_list|)
block|{}
name|public
operator|:
operator|~
name|StackFrameContext
argument_list|()
block|{}
specifier|const
name|Stmt
operator|*
name|getCallSite
argument_list|()
specifier|const
block|{
return|return
name|CallSite
return|;
block|}
specifier|const
name|CFGBlock
operator|*
name|getCallSiteBlock
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
comment|/// Return true if the current LocationContext has no caller context.
name|bool
name|inTopFrame
argument_list|()
specifier|const
name|override
block|{
return|return
name|getParent
argument_list|()
operator|==
name|nullptr
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
name|override
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|StackFrame
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|s
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|blk
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|idx
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext *Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|StackFrame
return|;
block|}
expr|}
block|;
name|class
name|ScopeContext
operator|:
name|public
name|LocationContext
block|{
specifier|const
name|Stmt
operator|*
name|Enter
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|ScopeContext
argument_list|(
name|AnalysisDeclContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|Stmt
operator|*
name|s
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|Scope
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|Enter
argument_list|(
argument|s
argument_list|)
block|{}
name|public
operator|:
operator|~
name|ScopeContext
argument_list|()
block|{}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
name|override
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|Scope
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|s
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext *Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|Scope
return|;
block|}
expr|}
block|;
name|class
name|BlockInvocationContext
operator|:
name|public
name|LocationContext
block|{
specifier|const
name|BlockDecl
operator|*
name|BD
block|;
comment|// FIXME: Come up with a more type-safe way to model context-sensitivity.
specifier|const
name|void
operator|*
name|ContextData
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|BlockInvocationContext
argument_list|(
name|AnalysisDeclContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|BlockDecl
operator|*
name|bd
argument_list|,
specifier|const
name|void
operator|*
name|contextData
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|Block
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|BD
argument_list|(
name|bd
argument_list|)
block|,
name|ContextData
argument_list|(
argument|contextData
argument_list|)
block|{}
name|public
operator|:
operator|~
name|BlockInvocationContext
argument_list|()
block|{}
specifier|const
name|BlockDecl
operator|*
name|getBlockDecl
argument_list|()
specifier|const
block|{
return|return
name|BD
return|;
block|}
specifier|const
name|void
operator|*
name|getContextData
argument_list|()
specifier|const
block|{
return|return
name|ContextData
return|;
block|}
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|)
name|override
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const BlockDecl *bd
argument_list|,
argument|const void *contextData
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|Block
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|bd
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|contextData
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext *Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|Block
return|;
block|}
expr|}
block|;
name|class
name|LocationContextManager
block|{
name|llvm
operator|::
name|FoldingSet
operator|<
name|LocationContext
operator|>
name|Contexts
block|;
name|public
operator|:
operator|~
name|LocationContextManager
argument_list|()
block|;
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|(
argument|AnalysisDeclContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
block|;
specifier|const
name|ScopeContext
operator|*
name|getScope
argument_list|(
name|AnalysisDeclContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|Stmt
operator|*
name|s
argument_list|)
block|;
specifier|const
name|BlockInvocationContext
operator|*
name|getBlockInvocationContext
argument_list|(
name|AnalysisDeclContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|BlockDecl
operator|*
name|BD
argument_list|,
specifier|const
name|void
operator|*
name|ContextData
argument_list|)
block|;
comment|/// Discard all previously created LocationContext objects.
name|void
name|clear
argument_list|()
block|;
name|private
operator|:
name|template
operator|<
name|typename
name|LOC
block|,
name|typename
name|DATA
operator|>
specifier|const
name|LOC
operator|*
name|getLocationContext
argument_list|(
name|AnalysisDeclContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|DATA
operator|*
name|d
argument_list|)
block|; }
block|;
name|class
name|AnalysisDeclContextManager
block|{
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Decl
operator|*
operator|,
name|AnalysisDeclContext
operator|*
operator|>
name|ContextMap
expr_stmt|;
name|ContextMap
name|Contexts
block|;
name|LocationContextManager
name|LocContexts
block|;
name|CFG
operator|::
name|BuildOptions
name|cfgBuildOptions
block|;
comment|/// Flag to indicate whether or not bodies should be synthesized
comment|/// for well-known functions.
name|bool
name|SynthesizeBodies
block|;
name|public
operator|:
name|AnalysisDeclContextManager
argument_list|(
argument|bool useUnoptimizedCFG = false
argument_list|,
argument|bool addImplicitDtors = false
argument_list|,
argument|bool addInitializers = false
argument_list|,
argument|bool addTemporaryDtors = false
argument_list|,
argument|bool synthesizeBodies = false
argument_list|,
argument|bool addStaticInitBranches = false
argument_list|,
argument|bool addCXXNewAllocator = true
argument_list|)
block|;
operator|~
name|AnalysisDeclContextManager
argument_list|()
block|;
name|AnalysisDeclContext
operator|*
name|getContext
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|)
block|;
name|bool
name|getUseUnoptimizedCFG
argument_list|()
specifier|const
block|{
return|return
operator|!
name|cfgBuildOptions
operator|.
name|PruneTriviallyFalseEdges
return|;
block|}
name|CFG
operator|::
name|BuildOptions
operator|&
name|getCFGBuildOptions
argument_list|()
block|{
return|return
name|cfgBuildOptions
return|;
block|}
comment|/// Return true if faux bodies should be synthesized for well-known
comment|/// functions.
name|bool
name|synthesizeBodies
argument_list|()
specifier|const
block|{
return|return
name|SynthesizeBodies
return|;
block|}
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|(
argument|AnalysisDeclContext *Ctx
argument_list|,
argument|LocationContext const *Parent
argument_list|,
argument|const Stmt *S
argument_list|,
argument|const CFGBlock *Blk
argument_list|,
argument|unsigned Idx
argument_list|)
block|{
return|return
name|LocContexts
operator|.
name|getStackFrame
argument_list|(
name|Ctx
argument_list|,
name|Parent
argument_list|,
name|S
argument_list|,
name|Blk
argument_list|,
name|Idx
argument_list|)
return|;
block|}
comment|// Get the top level stack frame.
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|(
argument|const Decl *D
argument_list|)
block|{
return|return
name|LocContexts
operator|.
name|getStackFrame
argument_list|(
name|getContext
argument_list|(
name|D
argument_list|)
argument_list|,
name|nullptr
argument_list|,
name|nullptr
argument_list|,
name|nullptr
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// Get a stack frame with parent.
name|StackFrameContext
specifier|const
operator|*
name|getStackFrame
argument_list|(
argument|const Decl *D
argument_list|,
argument|LocationContext const *Parent
argument_list|,
argument|const Stmt *S
argument_list|,
argument|const CFGBlock *Blk
argument_list|,
argument|unsigned Idx
argument_list|)
block|{
return|return
name|LocContexts
operator|.
name|getStackFrame
argument_list|(
name|getContext
argument_list|(
name|D
argument_list|)
argument_list|,
name|Parent
argument_list|,
name|S
argument_list|,
name|Blk
argument_list|,
name|Idx
argument_list|)
return|;
block|}
comment|/// Discard all previously created AnalysisDeclContexts.
name|void
name|clear
argument_list|()
block|;
name|private
operator|:
name|friend
name|class
name|AnalysisDeclContext
block|;
name|LocationContextManager
operator|&
name|getLocationContextManager
argument_list|()
block|{
return|return
name|LocContexts
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

