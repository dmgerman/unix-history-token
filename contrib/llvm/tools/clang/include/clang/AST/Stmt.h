begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Stmt.h - Classes for representing statements -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Stmt interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_STMT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_STMT_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/PrettyPrinter.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtIterator.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclGroup.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_expr_stmt
name|using
name|llvm
operator|::
name|dyn_cast_or_null
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|FoldingSetNodeID
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|Decl
decl_stmt|;
name|class
name|ParmVarDecl
decl_stmt|;
name|class
name|QualType
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
name|class
name|StringLiteral
decl_stmt|;
name|class
name|SwitchStmt
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// ExprIterator - Iterators for iterating over Stmt* arrays that contain
comment|//  only Expr*.  This is needed because AST nodes use Stmt* arrays to store
comment|//  references to children (to be compatible with StmtIterator).
comment|//===----------------------------------------------------------------------===//
name|class
name|Stmt
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|ExprIterator
block|{
name|Stmt
modifier|*
modifier|*
name|I
decl_stmt|;
name|public
label|:
name|ExprIterator
argument_list|(
name|Stmt
operator|*
operator|*
name|i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|ExprIterator
argument_list|()
operator|:
name|I
argument_list|(
literal|0
argument_list|)
block|{}
name|ExprIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|ExprIterator
name|operator
operator|-
operator|(
name|size_t
name|i
operator|)
block|{
return|return
name|I
operator|-
name|i
return|;
block|}
name|ExprIterator
name|operator
operator|+
operator|(
name|size_t
name|i
operator|)
block|{
return|return
name|I
operator|+
name|i
return|;
block|}
name|Expr
modifier|*
name|operator
function_decl|[]
parameter_list|(
name|size_t
name|idx
parameter_list|)
function_decl|;
comment|// FIXME: Verify that this will correctly return a signed distance.
name|signed
name|operator
operator|-
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|R
operator|.
name|I
return|;
block|}
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
expr_stmt|;
name|Expr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|>
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>=
name|R
operator|.
name|I
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|ConstExprIterator
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
modifier|*
name|I
decl_stmt|;
name|public
label|:
name|ConstExprIterator
argument_list|(
specifier|const
name|Stmt
operator|*
specifier|const
operator|*
name|i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|ConstExprIterator
argument_list|()
operator|:
name|I
argument_list|(
literal|0
argument_list|)
block|{}
name|ConstExprIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|ConstExprIterator
name|operator
operator|+
operator|(
name|size_t
name|i
operator|)
specifier|const
block|{
return|return
name|I
operator|+
name|i
return|;
block|}
name|ConstExprIterator
name|operator
operator|-
operator|(
name|size_t
name|i
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|i
return|;
block|}
specifier|const
name|Expr
modifier|*
name|operator
index|[]
argument_list|(
name|size_t
name|idx
argument_list|)
decl|const
decl_stmt|;
name|signed
name|operator
operator|-
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|R
operator|.
name|I
return|;
block|}
specifier|const
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
expr_stmt|;
specifier|const
name|Expr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>=
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// AST classes for statements.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// Stmt - This represents one statement.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Stmt
block|{
name|public
label|:
enum|enum
name|StmtClass
block|{
name|NoStmtClass
init|=
literal|0
block|,
define|#
directive|define
name|STMT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
value|CLASS##Class,
define|#
directive|define
name|STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,
define|#
directive|define
name|LAST_STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|STMT
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|}
enum|;
comment|// Make vanilla 'new' and 'delete' illegal for Stmts.
name|protected
label|:
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Stmts cannot be allocated with regular 'new'."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Stmts cannot be released with regular 'delete'."
argument_list|)
expr_stmt|;
block|}
name|class
name|StmtBitfields
block|{
name|friend
name|class
name|Stmt
decl_stmt|;
comment|/// \brief The statement class.
name|unsigned
name|sClass
range|:
literal|8
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumStmtBits
init|=
literal|8
block|}
enum|;
name|class
name|CompoundStmtBitfields
block|{
name|friend
name|class
name|CompoundStmt
decl_stmt|;
name|unsigned
label|:
name|NumStmtBits
expr_stmt|;
name|unsigned
name|NumStmts
range|:
literal|32
operator|-
name|NumStmtBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ExprBitfields
block|{
name|friend
name|class
name|Expr
decl_stmt|;
name|friend
name|class
name|DeclRefExpr
decl_stmt|;
comment|// computeDependence
name|friend
name|class
name|InitListExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|DesignatedInitExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|BlockDeclRefExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|friend
name|class
name|CXXNewExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|DependentScopeDeclRefExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXConstructExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CallExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|OffsetOfExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ObjCMessageExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ShuffleVectorExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ParenListExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXUnresolvedConstructExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXDependentScopeMemberExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|OverloadExpr
decl_stmt|;
comment|// ctor
name|unsigned
label|:
name|NumStmtBits
expr_stmt|;
name|unsigned
name|ValueKind
range|:
literal|2
decl_stmt|;
name|unsigned
name|ObjectKind
range|:
literal|2
decl_stmt|;
name|unsigned
name|TypeDependent
range|:
literal|1
decl_stmt|;
name|unsigned
name|ValueDependent
range|:
literal|1
decl_stmt|;
name|unsigned
name|ContainsUnexpandedParameterPack
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumExprBits
init|=
literal|15
block|}
enum|;
name|class
name|DeclRefExprBitfields
block|{
name|friend
name|class
name|DeclRefExpr
decl_stmt|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|HasQualifier
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasExplicitTemplateArgs
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasFoundDecl
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CastExprBitfields
block|{
name|friend
name|class
name|CastExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|Kind
range|:
literal|6
decl_stmt|;
name|unsigned
name|BasePathSize
range|:
literal|32
operator|-
literal|6
operator|-
name|NumExprBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CallExprBitfields
block|{
name|friend
name|class
name|CallExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|NumPreArgs
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
union|union
block|{
comment|// FIXME: this is wasteful on 64-bit platforms.
name|void
modifier|*
name|Aligner
decl_stmt|;
name|StmtBitfields
name|StmtBits
decl_stmt|;
name|CompoundStmtBitfields
name|CompoundStmtBits
decl_stmt|;
name|ExprBitfields
name|ExprBits
decl_stmt|;
name|DeclRefExprBitfields
name|DeclRefExprBits
decl_stmt|;
name|CastExprBitfields
name|CastExprBits
decl_stmt|;
name|CallExprBitfields
name|CallExprBits
decl_stmt|;
block|}
union|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
name|public
label|:
comment|// Only allow allocation of Stmts using the allocator in ASTContext
comment|// or by doing a placement new.
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|ASTContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|alignment
init|=
literal|8
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|bytes
argument_list|,
name|C
argument_list|,
name|alignment
argument_list|)
return|;
block|}
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|ASTContext
modifier|*
name|C
parameter_list|,
name|unsigned
name|alignment
init|=
literal|8
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|bytes
argument_list|,
operator|*
name|C
argument_list|,
name|alignment
argument_list|)
return|;
block|}
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
name|mem
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|ASTContext
modifier|&
parameter_list|,
name|unsigned
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|ASTContext
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
argument_list|,
name|std
operator|::
name|size_t
argument_list|)
name|throw
argument_list|()
block|{ }
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|public
label|:
comment|/// \brief A placeholder type used to construct an empty shell of a
comment|/// type, that will be filled in later (e.g., by some
comment|/// de-serialization).
struct|struct
name|EmptyShell
block|{ }
struct|;
name|protected
label|:
comment|/// \brief Construct an empty statement.
name|explicit
name|Stmt
parameter_list|(
name|StmtClass
name|SC
parameter_list|,
name|EmptyShell
parameter_list|)
block|{
name|StmtBits
operator|.
name|sClass
operator|=
name|SC
expr_stmt|;
if|if
condition|(
name|Stmt
operator|::
name|CollectingStats
argument_list|()
condition|)
name|Stmt
operator|::
name|addStmtClass
argument_list|(
name|SC
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|Stmt
argument_list|(
argument|StmtClass SC
argument_list|)
block|{
name|StmtBits
operator|.
name|sClass
operator|=
name|SC
expr_stmt|;
if|if
condition|(
name|Stmt
operator|::
name|CollectingStats
argument_list|()
condition|)
name|Stmt
operator|::
name|addStmtClass
argument_list|(
name|SC
argument_list|)
expr_stmt|;
block|}
name|StmtClass
name|getStmtClass
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|StmtClass
operator|>
operator|(
name|StmtBits
operator|.
name|sClass
operator|)
return|;
block|}
specifier|const
name|char
operator|*
name|getStmtClassName
argument_list|()
specifier|const
expr_stmt|;
comment|/// SourceLocation tokens are not useful in isolation - they are low level
comment|/// value objects created/interpreted by SourceManager. We assume AST
comment|/// clients will have a pointer to the respective SourceManager.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
expr_stmt|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
block|{
return|return
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
block|{
return|return
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
return|;
block|}
comment|// global temp stats (until we have a per-module visitor)
specifier|static
name|void
name|addStmtClass
parameter_list|(
specifier|const
name|StmtClass
name|s
parameter_list|)
function_decl|;
specifier|static
name|bool
name|CollectingStats
parameter_list|(
name|bool
name|Enable
init|=
name|false
parameter_list|)
function_decl|;
specifier|static
name|void
name|PrintStats
parameter_list|()
function_decl|;
comment|/// dump - This does a local dump of the specified AST fragment.  It dumps the
comment|/// specified node and a few nodes underneath it, but not the whole subtree.
comment|/// This is useful in a debugger.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|(
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
comment|/// dumpAll - This does a dump of the specified AST fragment and all subtrees.
name|void
name|dumpAll
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dumpAll
argument_list|(
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
comment|/// dumpPretty/printPretty - These two methods do a "pretty print" of the AST
comment|/// back to its original source language syntax.
name|void
name|dumpPretty
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
name|void
name|printPretty
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|PrinterHelper
operator|*
name|Helper
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|Indentation
operator|=
literal|0
argument_list|)
decl|const
block|{
name|printPretty
argument_list|(
name|OS
argument_list|,
operator|*
operator|(
name|ASTContext
operator|*
operator|)
literal|0
argument_list|,
name|Helper
argument_list|,
name|Policy
argument_list|,
name|Indentation
argument_list|)
expr_stmt|;
block|}
name|void
name|printPretty
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|PrinterHelper
operator|*
name|Helper
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|Indentation
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only
comment|///   works on systems with GraphViz (Mac OS X) or dot+gv installed.
name|void
name|viewAST
argument_list|()
specifier|const
expr_stmt|;
comment|// Implement isa<T> support.
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
comment|/// hasImplicitControlFlow - Some statements (e.g. short circuited operations)
comment|///  contain implicit control-flow in the order their subexpressions
comment|///  are evaluated.  This predicate returns true if this statement has
comment|///  such implicit control-flow.  Such statements are also specially handled
comment|///  within CFGs.
name|bool
name|hasImplicitControlFlow
argument_list|()
specifier|const
expr_stmt|;
comment|/// Child Iterators: All subclasses must implement 'children'
comment|/// to permit easy iteration over the substatements/subexpessions of an
comment|/// AST node.  This permits easy iteration over all nodes in the AST.
typedef|typedef
name|StmtIterator
name|child_iterator
typedef|;
typedef|typedef
name|ConstStmtIterator
name|const_child_iterator
typedef|;
typedef|typedef
name|StmtRange
name|child_range
typedef|;
typedef|typedef
name|ConstStmtRange
name|const_child_range
typedef|;
name|child_range
name|children
parameter_list|()
function_decl|;
name|const_child_range
name|children
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|children
argument_list|()
return|;
block|}
name|child_iterator
name|child_begin
parameter_list|()
block|{
return|return
name|children
argument_list|()
operator|.
name|first
return|;
block|}
name|child_iterator
name|child_end
parameter_list|()
block|{
return|return
name|children
argument_list|()
operator|.
name|second
return|;
block|}
name|const_child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|children
argument_list|()
operator|.
name|first
return|;
block|}
name|const_child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|children
argument_list|()
operator|.
name|second
return|;
block|}
comment|/// \brief Produce a unique representation of the given statement.
comment|///
comment|/// \brief ID once the profiling operation is complete, will contain
comment|/// the unique representation of the given statement.
comment|///
comment|/// \brief Context the AST context in which the statement resides
comment|///
comment|/// \brief Canonical whether the profile should be based on the canonical
comment|/// representation of this statement (e.g., where non-type template
comment|/// parameters are identified by index/level rather than their
comment|/// declaration pointers) or the exact representation of the statement as
comment|/// written in the source.
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|ASTContext
operator|&
name|Context
argument_list|,
name|bool
name|Canonical
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// DeclStmt - Adaptor class for mixing declarations with statements and
end_comment

begin_comment
comment|/// expressions. For example, CompoundStmt mixes statements, expressions
end_comment

begin_comment
comment|/// and declarations (variables, types). Another example is ForStmt, where
end_comment

begin_comment
comment|/// the first statement can be an expression or a declaration.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|DeclStmt
range|:
name|public
name|Stmt
block|{
name|DeclGroupRef
name|DG
block|;
name|SourceLocation
name|StartLoc
block|,
name|EndLoc
block|;
name|public
operator|:
name|DeclStmt
argument_list|(
argument|DeclGroupRef dg
argument_list|,
argument|SourceLocation startLoc
argument_list|,
argument|SourceLocation endLoc
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DeclStmtClass
argument_list|)
block|,
name|DG
argument_list|(
name|dg
argument_list|)
block|,
name|StartLoc
argument_list|(
name|startLoc
argument_list|)
block|,
name|EndLoc
argument_list|(
argument|endLoc
argument_list|)
block|{}
comment|/// \brief Build an empty declaration statement.
name|explicit
name|DeclStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DeclStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// isSingleDecl - This method returns true if this DeclStmt refers
comment|/// to a single Decl.
name|bool
name|isSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|isSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|Decl
operator|*
name|getSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
name|Decl
operator|*
name|getSingleDecl
argument_list|()
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|DeclGroupRef
name|getDeclGroup
argument_list|()
specifier|const
block|{
return|return
name|DG
return|;
block|}
name|DeclGroupRef
name|getDeclGroup
argument_list|()
block|{
return|return
name|DG
return|;
block|}
name|void
name|setDeclGroup
argument_list|(
argument|DeclGroupRef DGR
argument_list|)
block|{
name|DG
operator|=
name|DGR
block|; }
name|SourceLocation
name|getStartLoc
argument_list|()
specifier|const
block|{
return|return
name|StartLoc
return|;
block|}
name|void
name|setStartLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StartLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|EndLoc
return|;
block|}
name|void
name|setEndLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EndLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|StartLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DeclStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DeclStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators over subexpressions.
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|(
name|DG
operator|.
name|begin
argument_list|()
argument_list|,
name|DG
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|child_iterator
argument_list|(
name|DG
operator|.
name|end
argument_list|()
argument_list|,
name|DG
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
typedef|typedef
name|DeclGroupRef
operator|::
name|iterator
name|decl_iterator
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|DeclGroupRef
operator|::
name|const_iterator
name|const_decl_iterator
expr_stmt|;
end_typedef

begin_function
name|decl_iterator
name|decl_begin
parameter_list|()
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|decl_iterator
name|decl_end
parameter_list|()
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_decl_iterator
name|decl_begin
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_decl_iterator
name|decl_end
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// NullStmt - This is the null statement ";": C99 6.8.3p3.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|NullStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|SemiLoc
block|;
comment|/// \brief If the null statement was preceded by an empty macro this is
comment|/// its instantiation source location, e.g:
comment|/// @code
comment|///   #define CALL(x)
comment|///   CALL(0);
comment|/// @endcode
name|SourceLocation
name|LeadingEmptyMacro
block|;
name|public
operator|:
name|NullStmt
argument_list|(
argument|SourceLocation L
argument_list|,
argument|SourceLocation LeadingEmptyMacro =SourceLocation()
argument_list|)
operator|:
name|Stmt
argument_list|(
name|NullStmtClass
argument_list|)
block|,
name|SemiLoc
argument_list|(
name|L
argument_list|)
block|,
name|LeadingEmptyMacro
argument_list|(
argument|LeadingEmptyMacro
argument_list|)
block|{}
comment|/// \brief Build an empty null statement.
name|explicit
name|NullStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|NullStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getSemiLoc
argument_list|()
specifier|const
block|{
return|return
name|SemiLoc
return|;
block|}
name|void
name|setSemiLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SemiLoc
operator|=
name|L
block|; }
name|bool
name|hasLeadingEmptyMacro
argument_list|()
specifier|const
block|{
return|return
name|LeadingEmptyMacro
operator|.
name|isValid
argument_list|()
return|;
block|}
name|SourceLocation
name|getLeadingEmptyMacroLoc
argument_list|()
specifier|const
block|{
return|return
name|LeadingEmptyMacro
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|SemiLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|NullStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const NullStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|()
return|;
block|}
name|friend
name|class
name|ASTStmtReader
block|;
name|friend
name|class
name|ASTStmtWriter
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// CompoundStmt - This represents a group of statements like { stmt stmt }.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|CompoundStmt
range|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
operator|*
name|Body
block|;
name|SourceLocation
name|LBracLoc
block|,
name|RBracLoc
block|;
name|public
operator|:
name|CompoundStmt
argument_list|(
argument|ASTContext& C
argument_list|,
argument|Stmt **StmtStart
argument_list|,
argument|unsigned NumStmts
argument_list|,
argument|SourceLocation LB
argument_list|,
argument|SourceLocation RB
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|)
block|,
name|LBracLoc
argument_list|(
name|LB
argument_list|)
block|,
name|RBracLoc
argument_list|(
argument|RB
argument_list|)
block|{
name|CompoundStmtBits
operator|.
name|NumStmts
operator|=
name|NumStmts
block|;
name|assert
argument_list|(
name|CompoundStmtBits
operator|.
name|NumStmts
operator|==
name|NumStmts
operator|&&
literal|"NumStmts doesn't fit in bits of CompoundStmtBits.NumStmts!"
argument_list|)
block|;
if|if
condition|(
name|NumStmts
operator|==
literal|0
condition|)
block|{
name|Body
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|Body
operator|=
name|new
argument_list|(
argument|C
argument_list|)
name|Stmt
operator|*
index|[
name|NumStmts
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|Body
argument_list|,
name|StmtStart
argument_list|,
name|NumStmts
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|Body
argument_list|)
argument_list|)
block|;   }
comment|// \brief Build an empty compound statement.
name|explicit
name|CompoundStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|,
name|Empty
argument_list|)
decl_stmt|,
name|Body
argument_list|(
literal|0
argument_list|)
block|{
name|CompoundStmtBits
operator|.
name|NumStmts
operator|=
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_function_decl
name|void
name|setStmts
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|Stmt
modifier|*
modifier|*
name|Stmts
parameter_list|,
name|unsigned
name|NumStmts
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|bool
name|body_empty
argument_list|()
specifier|const
block|{
return|return
name|CompoundStmtBits
operator|.
name|NumStmts
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|CompoundStmtBits
operator|.
name|NumStmts
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|Stmt
modifier|*
modifier|*
name|body_iterator
typedef|;
end_typedef

begin_function
name|body_iterator
name|body_begin
parameter_list|()
block|{
return|return
name|Body
return|;
block|}
end_function

begin_function
name|body_iterator
name|body_end
parameter_list|()
block|{
return|return
name|Body
operator|+
name|size
argument_list|()
return|;
block|}
end_function

begin_function
name|Stmt
modifier|*
name|body_back
parameter_list|()
block|{
return|return
operator|!
name|body_empty
argument_list|()
condition|?
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|setLastStmt
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|body_empty
argument_list|()
operator|&&
literal|"setLastStmt"
argument_list|)
expr_stmt|;
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|S
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|Stmt
modifier|*
specifier|const
modifier|*
name|const_body_iterator
typedef|;
end_typedef

begin_expr_stmt
name|const_body_iterator
name|body_begin
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_body_iterator
name|body_end
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|+
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Stmt
operator|*
name|body_back
argument_list|()
specifier|const
block|{
return|return
operator|!
name|body_empty
argument_list|()
operator|?
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|body_iterator
operator|>
name|reverse_body_iterator
expr_stmt|;
end_typedef

begin_function
name|reverse_body_iterator
name|body_rbegin
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reverse_body_iterator
name|body_rend
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_body_iterator
operator|>
name|const_reverse_body_iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|LBracLoc
argument_list|,
name|RBracLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getLBracLoc
argument_list|()
specifier|const
block|{
return|return
name|LBracLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setLBracLoc
parameter_list|(
name|SourceLocation
name|L
parameter_list|)
block|{
name|LBracLoc
operator|=
name|L
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SourceLocation
name|getRBracLoc
argument_list|()
specifier|const
block|{
return|return
name|RBracLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setRBracLoc
parameter_list|(
name|SourceLocation
name|L
parameter_list|)
block|{
name|RBracLoc
operator|=
name|L
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|T
parameter_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CompoundStmtClass
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|CompoundStmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Iterators
end_comment

begin_function
name|child_range
name|children
parameter_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Body
index|[
literal|0
index|]
argument_list|,
operator|&
name|Body
index|[
literal|0
index|]
operator|+
name|CompoundStmtBits
operator|.
name|NumStmts
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};
comment|// SwitchCase is the base class for CaseStmt and DefaultStmt,
end_comment

begin_decl_stmt
name|class
name|SwitchCase
range|:
name|public
name|Stmt
block|{
name|protected
operator|:
comment|// A pointer to the following CaseStmt or DefaultStmt class,
comment|// used by SwitchStmt.
name|SwitchCase
operator|*
name|NextSwitchCase
block|;
name|SwitchCase
argument_list|(
argument|StmtClass SC
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|)
block|,
name|NextSwitchCase
argument_list|(
literal|0
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
specifier|const
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|void
name|setNextSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|NextSwitchCase
operator|=
name|SC
block|; }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|;
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|SwitchCase
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getSubStmt
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
operator|||
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SwitchCase *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|CaseStmt
operator|:
name|public
name|SwitchCase
block|{   enum
block|{
name|LHS
block|,
name|RHS
block|,
name|SUBSTMT
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// The expression for the RHS is Non-null for
comment|// GNU "case 1 ... 4" extension
name|SourceLocation
name|CaseLoc
block|;
name|SourceLocation
name|EllipsisLoc
block|;
name|SourceLocation
name|ColonLoc
block|;
name|public
operator|:
name|CaseStmt
argument_list|(
argument|Expr *lhs
argument_list|,
argument|Expr *rhs
argument_list|,
argument|SourceLocation caseLoc
argument_list|,
argument|SourceLocation ellipsisLoc
argument_list|,
argument|SourceLocation colonLoc
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
literal|0
block|;
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|lhs
operator|)
block|;
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|rhs
operator|)
block|;
name|CaseLoc
operator|=
name|caseLoc
block|;
name|EllipsisLoc
operator|=
name|ellipsisLoc
block|;
name|ColonLoc
operator|=
name|colonLoc
block|;   }
comment|/// \brief Build an empty switch case statement.
name|explicit
name|CaseStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|)
block|{ }
name|SourceLocation
name|getCaseLoc
argument_list|()
specifier|const
block|{
return|return
name|CaseLoc
return|;
block|}
name|void
name|setCaseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|CaseLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
name|void
name|setEllipsisLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EllipsisLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|Expr
operator|*
name|getLHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getRHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
name|S
block|; }
name|void
name|setLHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|void
name|setRHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
comment|// Handle deeply nested case statements with iteration instead of recursion.
specifier|const
name|CaseStmt
operator|*
name|CS
operator|=
name|this
block|;
while|while
condition|(
specifier|const
name|CaseStmt
modifier|*
name|CS2
init|=
name|dyn_cast
operator|<
name|CaseStmt
operator|>
operator|(
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|)
condition|)
name|CS
operator|=
name|CS2
expr_stmt|;
return|return
name|SourceRange
argument_list|(
name|CaseLoc
argument_list|,
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const CaseStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
name|END_EXPR
index|]
argument_list|)
return|;
block|}
expr|}
block|;
name|class
name|DefaultStmt
operator|:
name|public
name|SwitchCase
block|{
name|Stmt
operator|*
name|SubStmt
block|;
name|SourceLocation
name|DefaultLoc
block|;
name|SourceLocation
name|ColonLoc
block|;
name|public
operator|:
name|DefaultStmt
argument_list|(
argument|SourceLocation DL
argument_list|,
argument|SourceLocation CL
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|SwitchCase
argument_list|(
name|DefaultStmtClass
argument_list|)
block|,
name|SubStmt
argument_list|(
name|substmt
argument_list|)
block|,
name|DefaultLoc
argument_list|(
name|DL
argument_list|)
block|,
name|ColonLoc
argument_list|(
argument|CL
argument_list|)
block|{}
comment|/// \brief Build an empty default statement.
name|explicit
name|DefaultStmt
argument_list|(
name|EmptyShell
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|DefaultStmtClass
argument_list|)
block|{ }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubStmt
operator|=
name|S
block|; }
name|SourceLocation
name|getDefaultLoc
argument_list|()
specifier|const
block|{
return|return
name|DefaultLoc
return|;
block|}
name|void
name|setDefaultLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|DefaultLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|DefaultLoc
argument_list|,
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DefaultStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubStmt
argument_list|,
operator|&
name|SubStmt
operator|+
literal|1
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// LabelStmt - Represents a label, which has a substatement.  For example:
comment|///    foo: return;
comment|///
name|class
name|LabelStmt
operator|:
name|public
name|Stmt
block|{
name|LabelDecl
operator|*
name|TheDecl
block|;
name|Stmt
operator|*
name|SubStmt
block|;
name|SourceLocation
name|IdentLoc
block|;
name|public
operator|:
name|LabelStmt
argument_list|(
argument|SourceLocation IL
argument_list|,
argument|LabelDecl *D
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|Stmt
argument_list|(
name|LabelStmtClass
argument_list|)
block|,
name|TheDecl
argument_list|(
name|D
argument_list|)
block|,
name|SubStmt
argument_list|(
name|substmt
argument_list|)
block|,
name|IdentLoc
argument_list|(
argument|IL
argument_list|)
block|{   }
comment|// \brief Build an empty label statement.
name|explicit
name|LabelStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|LabelStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getIdentLoc
argument_list|()
specifier|const
block|{
return|return
name|IdentLoc
return|;
block|}
name|LabelDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|TheDecl
return|;
block|}
name|void
name|setDecl
argument_list|(
argument|LabelDecl *D
argument_list|)
block|{
name|TheDecl
operator|=
name|D
block|; }
specifier|const
name|char
operator|*
name|getName
argument_list|()
specifier|const
block|;
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setIdentLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IdentLoc
operator|=
name|L
block|; }
name|void
name|setSubStmt
argument_list|(
argument|Stmt *SS
argument_list|)
block|{
name|SubStmt
operator|=
name|SS
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|IdentLoc
argument_list|,
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubStmt
argument_list|,
operator|&
name|SubStmt
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|LabelStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const LabelStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// IfStmt - This represents an if/then/else.
comment|///
name|class
name|IfStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|THEN
block|,
name|ELSE
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|IfLoc
block|;
name|SourceLocation
name|ElseLoc
block|;
name|public
operator|:
name|IfStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation IL
argument_list|,
argument|VarDecl *var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *then
argument_list|,
argument|SourceLocation EL = SourceLocation()
argument_list|,
argument|Stmt *elsev =
literal|0
argument_list|)
block|;
comment|/// \brief Build an empty if/then/else statement
name|explicit
name|IfStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IfStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "if" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// if (int x = foo()) {
comment|///   printf("x is %d", x);
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this IfStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
specifier|const
name|Stmt
operator|*
name|getThen
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|void
name|setThen
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|THEN
index|]
operator|=
name|S
block|; }
specifier|const
name|Stmt
operator|*
name|getElse
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|void
name|setElse
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|ELSE
index|]
operator|=
name|S
block|; }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getThen
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|Stmt
operator|*
name|getElse
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|SourceLocation
name|getIfLoc
argument_list|()
specifier|const
block|{
return|return
name|IfLoc
return|;
block|}
name|void
name|setIfLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IfLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getElseLoc
argument_list|()
specifier|const
block|{
return|return
name|ElseLoc
return|;
block|}
name|void
name|setElseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ElseLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
if|if
condition|(
name|SubExprs
index|[
name|ELSE
index|]
condition|)
return|return
name|SourceRange
argument_list|(
name|IfLoc
argument_list|,
name|SubExprs
index|[
name|ELSE
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
else|else
return|return
name|SourceRange
argument_list|(
name|IfLoc
argument_list|,
name|SubExprs
index|[
name|THEN
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
comment|// Iterators over subexpressions.  The iterators will include iterating
comment|// over the initialization expression referenced by the condition variable.
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IfStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IfStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// SwitchStmt - This represents a 'switch' stmt.
comment|///
name|class
name|SwitchStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// This points to a linked list of case and default statements.
name|SwitchCase
operator|*
name|FirstCase
block|;
name|SourceLocation
name|SwitchLoc
block|;
comment|/// If the SwitchStmt is a switch on an enum value, this records whether
comment|/// all the enum values were covered by CaseStmts.  This value is meant to
comment|/// be a hint for possible clients.
name|unsigned
name|AllEnumCasesCovered
operator|:
literal|1
block|;
name|public
operator|:
name|SwitchStmt
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|Var
argument_list|,
name|Expr
operator|*
name|cond
argument_list|)
block|;
comment|/// \brief Build a empty switch statement.
name|explicit
name|SwitchStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SwitchStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "switch" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// switch (int x = foo()) {
comment|///   case 0: break;
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this SwitchStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
specifier|const
block|{
return|return
name|FirstCase
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
block|{
return|return
name|FirstCase
return|;
block|}
comment|/// \brief Set the case list for this switch statement.
comment|///
comment|/// The caller is responsible for incrementing the retain counts on
comment|/// all of the SwitchCase statements in this list.
name|void
name|setSwitchCaseList
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|FirstCase
operator|=
name|SC
block|; }
name|SourceLocation
name|getSwitchLoc
argument_list|()
specifier|const
block|{
return|return
name|SwitchLoc
return|;
block|}
name|void
name|setSwitchLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SwitchLoc
operator|=
name|L
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|,
argument|SourceLocation SL
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|;
name|SwitchLoc
operator|=
name|SL
block|;   }
name|void
name|addSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|SC
operator|->
name|getNextSwitchCase
argument_list|()
operator|&&
literal|"case/default already added to a switch"
argument_list|)
block|;
name|SC
operator|->
name|setNextSwitchCase
argument_list|(
name|FirstCase
argument_list|)
block|;
name|FirstCase
operator|=
name|SC
block|;   }
comment|/// Set a flag in the SwitchStmt indicating that if the 'switch (X)' is a
comment|/// switch over an enum value then all cases have been explicitly covered.
name|void
name|setAllEnumCasesCovered
argument_list|()
block|{
name|AllEnumCasesCovered
operator|=
literal|1
block|;   }
comment|/// Returns true if the SwitchStmt is a switch of an enum value and all cases
comment|/// have been explicitly covered.
name|bool
name|isAllEnumCasesCovered
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|AllEnumCasesCovered
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|SwitchLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SwitchStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SwitchStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
comment|/// WhileStmt - This represents a 'while' stmt.
comment|///
name|class
name|WhileStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|WhileLoc
block|;
name|public
operator|:
name|WhileStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|VarDecl *Var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *body
argument_list|,
argument|SourceLocation WL
argument_list|)
block|;
comment|/// \brief Build an empty while statement.
name|explicit
name|WhileStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|WhileStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "while" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// while (int x = random()) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this WhileStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|WhileLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|WhileStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const WhileStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// DoStmt - This represents a 'do/while' stmt.
comment|///
name|class
name|DoStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|BODY
block|,
name|COND
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|DoLoc
block|;
name|SourceLocation
name|WhileLoc
block|;
name|SourceLocation
name|RParenLoc
block|;
comment|// Location of final ')' in do stmt condition.
name|public
operator|:
name|DoStmt
argument_list|(
argument|Stmt *body
argument_list|,
argument|Expr *cond
argument_list|,
argument|SourceLocation DL
argument_list|,
argument|SourceLocation WL
argument_list|,
argument|SourceLocation RP
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DoStmtClass
argument_list|)
block|,
name|DoLoc
argument_list|(
name|DL
argument_list|)
block|,
name|WhileLoc
argument_list|(
name|WL
argument_list|)
block|,
name|RParenLoc
argument_list|(
argument|RP
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|cond
operator|)
block|;
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|body
block|;   }
comment|/// \brief Build an empty do-while statement.
name|explicit
name|DoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getDoLoc
argument_list|()
specifier|const
block|{
return|return
name|DoLoc
return|;
block|}
name|void
name|setDoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|DoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|DoLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of
comment|/// the init/cond/inc parts of the ForStmt will be null if they were not
comment|/// specified in the source.
comment|///
name|class
name|ForStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|INIT
block|,
name|CONDVAR
block|,
name|COND
block|,
name|INC
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// SubExprs[INIT] is an expression or declstmt.
name|SourceLocation
name|ForLoc
block|;
name|SourceLocation
name|LParenLoc
block|,
name|RParenLoc
block|;
name|public
operator|:
name|ForStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|Stmt *Init
argument_list|,
argument|Expr *Cond
argument_list|,
argument|VarDecl *condVar
argument_list|,
argument|Expr *Inc
argument_list|,
argument|Stmt *Body
argument_list|,
argument|SourceLocation FL
argument_list|,
argument|SourceLocation LP
argument_list|,
argument|SourceLocation RP
argument_list|)
block|;
comment|/// \brief Build an empty for statement.
name|explicit
name|ForStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ForStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Stmt
operator|*
name|getInit
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
comment|/// \brief Retrieve the variable declared in this "for" statement, if any.
comment|///
comment|/// In the following example, "y" is the condition variable.
comment|/// \code
comment|/// for (int x = random(); int y = mangle(x); ++x) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this ForStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|CONDVAR
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getInc
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getInit
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getInc
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setInit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|INIT
index|]
operator|=
name|S
block|; }
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setInc
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|INC
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getForLoc
argument_list|()
specifier|const
block|{
return|return
name|ForLoc
return|;
block|}
name|void
name|setForLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ForLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|LParenLoc
return|;
block|}
name|void
name|setLParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LParenLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|ForLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ForStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ForStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// GotoStmt - This represents a direct goto.
comment|///
name|class
name|GotoStmt
operator|:
name|public
name|Stmt
block|{
name|LabelDecl
operator|*
name|Label
block|;
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|LabelLoc
block|;
name|public
operator|:
name|GotoStmt
argument_list|(
argument|LabelDecl *label
argument_list|,
argument|SourceLocation GL
argument_list|,
argument|SourceLocation LL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|GotoStmtClass
argument_list|)
block|,
name|Label
argument_list|(
name|label
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|GL
argument_list|)
block|,
name|LabelLoc
argument_list|(
argument|LL
argument_list|)
block|{}
comment|/// \brief Build an empty goto statement.
name|explicit
name|GotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|GotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|LabelDecl
operator|*
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|void
name|setLabel
argument_list|(
argument|LabelDecl *D
argument_list|)
block|{
name|Label
operator|=
name|D
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLabelLoc
argument_list|()
specifier|const
block|{
return|return
name|LabelLoc
return|;
block|}
name|void
name|setLabelLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LabelLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|GotoLoc
argument_list|,
name|LabelLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|GotoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const GotoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// IndirectGotoStmt - This represents an indirect goto.
comment|///
name|class
name|IndirectGotoStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|StarLoc
block|;
name|Stmt
operator|*
name|Target
block|;
name|public
operator|:
name|IndirectGotoStmt
argument_list|(
argument|SourceLocation gotoLoc
argument_list|,
argument|SourceLocation starLoc
argument_list|,
argument|Expr *target
argument_list|)
operator|:
name|Stmt
argument_list|(
name|IndirectGotoStmtClass
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|gotoLoc
argument_list|)
block|,
name|StarLoc
argument_list|(
name|starLoc
argument_list|)
block|,
name|Target
argument_list|(
argument|(Stmt*)target
argument_list|)
block|{}
comment|/// \brief Build an empty indirect goto statement.
name|explicit
name|IndirectGotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IndirectGotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StarLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|StarLoc
return|;
block|}
name|Expr
operator|*
name|getTarget
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Target
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getTarget
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|Target
operator|)
return|;
block|}
name|void
name|setTarget
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|Target
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
comment|/// getConstantTarget - Returns the fixed target of this indirect
comment|/// goto, if one exists.
name|LabelDecl
operator|*
name|getConstantTarget
argument_list|()
block|;
specifier|const
name|LabelDecl
operator|*
name|getConstantTarget
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|IndirectGotoStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getConstantTarget
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|GotoLoc
argument_list|,
name|Target
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IndirectGotoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IndirectGotoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Target
argument_list|,
operator|&
name|Target
operator|+
literal|1
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ContinueStmt - This represents a continue.
comment|///
name|class
name|ContinueStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|ContinueLoc
block|;
name|public
operator|:
name|ContinueStmt
argument_list|(
argument|SourceLocation CL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ContinueStmtClass
argument_list|)
block|,
name|ContinueLoc
argument_list|(
argument|CL
argument_list|)
block|{}
comment|/// \brief Build an empty continue statement.
name|explicit
name|ContinueStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ContinueStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getContinueLoc
argument_list|()
specifier|const
block|{
return|return
name|ContinueLoc
return|;
block|}
name|void
name|setContinueLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ContinueLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|ContinueLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ContinueStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ContinueStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// BreakStmt - This represents a break.
comment|///
name|class
name|BreakStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|BreakLoc
block|;
name|public
operator|:
name|BreakStmt
argument_list|(
argument|SourceLocation BL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|BreakStmtClass
argument_list|)
block|,
name|BreakLoc
argument_list|(
argument|BL
argument_list|)
block|{}
comment|/// \brief Build an empty break statement.
name|explicit
name|BreakStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|BreakStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getBreakLoc
argument_list|()
specifier|const
block|{
return|return
name|BreakLoc
return|;
block|}
name|void
name|setBreakLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|BreakLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|BreakLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|BreakStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const BreakStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// ReturnStmt - This represents a return, optionally of an expression:
comment|///   return;
comment|///   return 4;
comment|///
comment|/// Note that GCC allows return with no argument in a function declared to
comment|/// return a value, and it allows returning a value in functions declared to
comment|/// return void.  We explicitly model this in the AST, which means you can't
comment|/// depend on the return type of the function and the presence of an argument.
comment|///
name|class
name|ReturnStmt
operator|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
name|RetExpr
block|;
name|SourceLocation
name|RetLoc
block|;
specifier|const
name|VarDecl
operator|*
name|NRVOCandidate
block|;
name|public
operator|:
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ReturnStmtClass
argument_list|)
block|,
name|RetExpr
argument_list|(
literal|0
argument_list|)
block|,
name|RetLoc
argument_list|(
name|RL
argument_list|)
block|,
name|NRVOCandidate
argument_list|(
literal|0
argument_list|)
block|{ }
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|,
argument|Expr *E
argument_list|,
argument|const VarDecl *NRVOCandidate
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ReturnStmtClass
argument_list|)
block|,
name|RetExpr
argument_list|(
operator|(
name|Stmt
operator|*
operator|)
name|E
argument_list|)
block|,
name|RetLoc
argument_list|(
name|RL
argument_list|)
block|,
name|NRVOCandidate
argument_list|(
argument|NRVOCandidate
argument_list|)
block|{}
comment|/// \brief Build an empty return expression.
name|explicit
name|ReturnStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ReturnStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
specifier|const
name|Expr
operator|*
name|getRetValue
argument_list|()
specifier|const
block|;
name|Expr
operator|*
name|getRetValue
argument_list|()
block|;
name|void
name|setRetValue
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|RetExpr
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|SourceLocation
name|getReturnLoc
argument_list|()
specifier|const
block|{
return|return
name|RetLoc
return|;
block|}
name|void
name|setReturnLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RetLoc
operator|=
name|L
block|; }
comment|/// \brief Retrieve the variable that might be used for the named return
comment|/// value optimization.
comment|///
comment|/// The optimization itself can only be performed if the variable is
comment|/// also marked as an NRVO object.
specifier|const
name|VarDecl
operator|*
name|getNRVOCandidate
argument_list|()
specifier|const
block|{
return|return
name|NRVOCandidate
return|;
block|}
name|void
name|setNRVOCandidate
argument_list|(
argument|const VarDecl *Var
argument_list|)
block|{
name|NRVOCandidate
operator|=
name|Var
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ReturnStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ReturnStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
if|if
condition|(
name|RetExpr
condition|)
return|return
name|child_range
argument_list|(
operator|&
name|RetExpr
argument_list|,
operator|&
name|RetExpr
operator|+
literal|1
argument_list|)
return|;
return|return
name|child_range
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// AsmStmt - This represents a GNU inline-assembly statement extension.
comment|///
name|class
name|AsmStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|AsmLoc
block|,
name|RParenLoc
block|;
name|StringLiteral
operator|*
name|AsmStr
block|;
name|bool
name|IsSimple
block|;
name|bool
name|IsVolatile
block|;
name|bool
name|MSAsm
block|;
name|unsigned
name|NumOutputs
block|;
name|unsigned
name|NumInputs
block|;
name|unsigned
name|NumClobbers
block|;
comment|// FIXME: If we wanted to, we could allocate all of these in one big array.
name|IdentifierInfo
operator|*
operator|*
name|Names
block|;
name|StringLiteral
operator|*
operator|*
name|Constraints
block|;
name|Stmt
operator|*
operator|*
name|Exprs
block|;
name|StringLiteral
operator|*
operator|*
name|Clobbers
block|;
name|public
operator|:
name|AsmStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation asmloc
argument_list|,
argument|bool issimple
argument_list|,
argument|bool isvolatile
argument_list|,
argument|bool msasm
argument_list|,
argument|unsigned numoutputs
argument_list|,
argument|unsigned numinputs
argument_list|,
argument|IdentifierInfo **names
argument_list|,
argument|StringLiteral **constraints
argument_list|,
argument|Expr **exprs
argument_list|,
argument|StringLiteral *asmstr
argument_list|,
argument|unsigned numclobbers
argument_list|,
argument|StringLiteral **clobbers
argument_list|,
argument|SourceLocation rparenloc
argument_list|)
block|;
comment|/// \brief Build an empty inline-assembly statement.
name|explicit
name|AsmStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|AsmStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|Names
argument_list|(
literal|0
argument_list|)
block|,
name|Constraints
argument_list|(
literal|0
argument_list|)
block|,
name|Exprs
argument_list|(
literal|0
argument_list|)
block|,
name|Clobbers
argument_list|(
literal|0
argument_list|)
block|{ }
name|SourceLocation
name|getAsmLoc
argument_list|()
specifier|const
block|{
return|return
name|AsmLoc
return|;
block|}
name|void
name|setAsmLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|AsmLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|IsVolatile
return|;
block|}
name|void
name|setVolatile
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsVolatile
operator|=
name|V
block|; }
name|bool
name|isSimple
argument_list|()
specifier|const
block|{
return|return
name|IsSimple
return|;
block|}
name|void
name|setSimple
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsSimple
operator|=
name|V
block|; }
name|bool
name|isMSAsm
argument_list|()
specifier|const
block|{
return|return
name|MSAsm
return|;
block|}
name|void
name|setMSAsm
argument_list|(
argument|bool V
argument_list|)
block|{
name|MSAsm
operator|=
name|V
block|; }
comment|//===--- Asm String Analysis ---===//
specifier|const
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
specifier|const
block|{
return|return
name|AsmStr
return|;
block|}
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
block|{
return|return
name|AsmStr
return|;
block|}
name|void
name|setAsmString
argument_list|(
argument|StringLiteral *E
argument_list|)
block|{
name|AsmStr
operator|=
name|E
block|; }
comment|/// AsmStringPiece - this is part of a decomposed asm string specification
comment|/// (for use with the AnalyzeAsmString function below).  An asm string is
comment|/// considered to be a concatenation of these parts.
name|class
name|AsmStringPiece
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|String
block|,
comment|// String in .ll asm string form, "$" -> "$$" and "%%" -> "%".
name|Operand
comment|// Operand reference, with optional modifier %c4.
block|}
block|;
name|private
operator|:
name|Kind
name|MyKind
block|;
name|std
operator|::
name|string
name|Str
block|;
name|unsigned
name|OperandNo
block|;
name|public
operator|:
name|AsmStringPiece
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|S
argument_list|)
operator|:
name|MyKind
argument_list|(
name|String
argument_list|)
block|,
name|Str
argument_list|(
argument|S
argument_list|)
block|{}
name|AsmStringPiece
argument_list|(
argument|unsigned OpNo
argument_list|,
argument|char Modifier
argument_list|)
operator|:
name|MyKind
argument_list|(
name|Operand
argument_list|)
block|,
name|Str
argument_list|()
block|,
name|OperandNo
argument_list|(
argument|OpNo
argument_list|)
block|{
name|Str
operator|+=
name|Modifier
block|;     }
name|bool
name|isString
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|String
return|;
block|}
name|bool
name|isOperand
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|Operand
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getString
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isString
argument_list|()
argument_list|)
block|;
return|return
name|Str
return|;
block|}
name|unsigned
name|getOperandNo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
argument_list|)
block|;
return|return
name|OperandNo
return|;
block|}
comment|/// getModifier - Get the modifier for this operand, if present.  This
comment|/// returns '\0' if there was no modifier.
name|char
name|getModifier
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
argument_list|)
block|;
return|return
name|Str
index|[
literal|0
index|]
return|;
block|}
expr|}
block|;
comment|/// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing
comment|/// it into pieces.  If the asm string is erroneous, emit errors and return
comment|/// true, otherwise return false.  This handles canonicalization and
comment|/// translation of strings from GCC syntax to LLVM IR syntax, and handles
comment|//// flattening of named references like %[foo] to Operand AsmStringPiece's.
name|unsigned
name|AnalyzeAsmString
argument_list|(
argument|llvm::SmallVectorImpl<AsmStringPiece>&Pieces
argument_list|,
argument|ASTContext&C
argument_list|,
argument|unsigned&DiagOffs
argument_list|)
specifier|const
block|;
comment|//===--- Output operands ---===//
name|unsigned
name|getNumOutputs
argument_list|()
specifier|const
block|{
return|return
name|NumOutputs
return|;
block|}
name|IdentifierInfo
operator|*
name|getOutputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
index|]
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getOutputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getOutputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|llvm
operator|::
name|StringRef
argument_list|()
return|;
block|}
comment|/// getOutputConstraint - Return the constraint string for the specified
comment|/// output operand.  All output constraints are known to be non-empty (either
comment|/// '=' or '+').
name|llvm
operator|::
name|StringRef
name|getOutputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|AsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getOutputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/// isOutputPlusConstraint - Return true if the specified output constraint
comment|/// is a "+" constraint (which is both an input and an output) or false if it
comment|/// is an "=" constraint (just an output).
name|bool
name|isOutputPlusConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getOutputConstraint
argument_list|(
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'+'
return|;
block|}
comment|/// getNumPlusOperands - Return the number of output operands that have a "+"
comment|/// constraint.
name|unsigned
name|getNumPlusOperands
argument_list|()
specifier|const
block|;
comment|//===--- Input operands ---===//
name|unsigned
name|getNumInputs
argument_list|()
specifier|const
block|{
return|return
name|NumInputs
return|;
block|}
name|IdentifierInfo
operator|*
name|getInputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getInputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getInputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|llvm
operator|::
name|StringRef
argument_list|()
return|;
block|}
comment|/// getInputConstraint - Return the specified input constraint.  Unlike output
comment|/// constraints, these can be empty.
name|llvm
operator|::
name|StringRef
name|getInputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|StringLiteral
operator|*
name|getInputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|StringLiteral
operator|*
name|getInputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
name|void
name|setInputExpr
argument_list|(
argument|unsigned i
argument_list|,
argument|Expr *E
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|AsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getInputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
name|void
name|setOutputsAndInputsAndClobbers
argument_list|(
argument|ASTContext&C
argument_list|,
argument|IdentifierInfo **Names
argument_list|,
argument|StringLiteral **Constraints
argument_list|,
argument|Stmt **Exprs
argument_list|,
argument|unsigned NumOutputs
argument_list|,
argument|unsigned NumInputs
argument_list|,
argument|StringLiteral **Clobbers
argument_list|,
argument|unsigned NumClobbers
argument_list|)
block|;
comment|//===--- Other ---===//
comment|/// getNamedOperand - Given a symbolic operand reference like %[foo],
comment|/// translate this into a numeric value needed to reference the same operand.
comment|/// This returns -1 if the operand name is invalid.
name|int
name|getNamedOperand
argument_list|(
argument|llvm::StringRef SymbolicName
argument_list|)
specifier|const
block|;
name|unsigned
name|getNumClobbers
argument_list|()
specifier|const
block|{
return|return
name|NumClobbers
return|;
block|}
name|StringLiteral
operator|*
name|getClobber
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
specifier|const
name|StringLiteral
operator|*
name|getClobber
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|AsmLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|AsmStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const AsmStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Input expr iterators.
typedef|typedef
name|ExprIterator
name|inputs_iterator
typedef|;
typedef|typedef
name|ConstExprIterator
name|const_inputs_iterator
typedef|;
name|inputs_iterator
name|begin_inputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|inputs_iterator
name|end_inputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
name|const_inputs_iterator
name|begin_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|const_inputs_iterator
name|end_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
comment|// Output expr iterators.
typedef|typedef
name|ExprIterator
name|outputs_iterator
typedef|;
typedef|typedef
name|ConstExprIterator
name|const_outputs_iterator
typedef|;
name|outputs_iterator
name|begin_outputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
name|outputs_iterator
name|end_outputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|const_outputs_iterator
name|begin_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
name|const_outputs_iterator
name|end_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Exprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
argument_list|)
return|;
block|}
expr|}
block|;
name|class
name|SEHExceptStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|Loc
block|;
name|Stmt
operator|*
name|Children
index|[
literal|2
index|]
block|;    enum
block|{
name|FILTER_EXPR
block|,
name|BLOCK
block|}
block|;
name|SEHExceptStmt
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Expr *FilterExpr
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|public
operator|:
specifier|static
name|SEHExceptStmt
operator|*
name|Create
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation ExceptLoc
argument_list|,
argument|Expr *FilterExpr
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getExceptLoc
argument_list|()
argument_list|,
name|getEndLoc
argument_list|()
argument_list|)
return|;
block|}
name|SourceLocation
name|getExceptLoc
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|getBlock
argument_list|()
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|Expr
operator|*
name|getFilterExpr
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Children
index|[
name|FILTER_EXPR
index|]
operator|)
return|;
block|}
name|CompoundStmt
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Children
index|[
name|BLOCK
index|]
operator|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|Children
argument_list|,
name|Children
operator|+
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHExceptStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|SEHExceptStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|SEHFinallyStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|Loc
block|;
name|Stmt
operator|*
name|Block
block|;
name|SEHFinallyStmt
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|public
operator|:
specifier|static
name|SEHFinallyStmt
operator|*
name|Create
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation FinallyLoc
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getFinallyLoc
argument_list|()
argument_list|,
name|getEndLoc
argument_list|()
argument_list|)
return|;
block|}
name|SourceLocation
name|getFinallyLoc
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Block
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|CompoundStmt
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Block
operator|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Block
argument_list|,
operator|&
name|Block
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHFinallyStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|SEHFinallyStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;
name|class
name|SEHTryStmt
operator|:
name|public
name|Stmt
block|{
name|bool
name|IsCXXTry
block|;
name|SourceLocation
name|TryLoc
block|;
name|Stmt
operator|*
name|Children
index|[
literal|2
index|]
block|;    enum
block|{
name|TRY
operator|=
literal|0
block|,
name|HANDLER
operator|=
literal|1
block|}
block|;
name|SEHTryStmt
argument_list|(
argument|bool isCXXTry
argument_list|,
comment|// true if 'try' otherwise '__try'
argument|SourceLocation TryLoc
argument_list|,
argument|Stmt *TryBlock
argument_list|,
argument|Stmt *Handler
argument_list|)
block|;
name|public
operator|:
specifier|static
name|SEHTryStmt
operator|*
name|Create
argument_list|(
argument|ASTContext&C
argument_list|,
argument|bool isCXXTry
argument_list|,
argument|SourceLocation TryLoc
argument_list|,
argument|Stmt *TryBlock
argument_list|,
argument|Stmt *Handler
argument_list|)
block|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getTryLoc
argument_list|()
argument_list|,
name|getEndLoc
argument_list|()
argument_list|)
return|;
block|}
name|SourceLocation
name|getTryLoc
argument_list|()
specifier|const
block|{
return|return
name|TryLoc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Children
index|[
name|HANDLER
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|bool
name|getIsCXXTry
argument_list|()
specifier|const
block|{
return|return
name|IsCXXTry
return|;
block|}
name|CompoundStmt
operator|*
name|getTryBlock
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Children
index|[
name|TRY
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getHandler
argument_list|()
specifier|const
block|{
return|return
name|Children
index|[
name|HANDLER
index|]
return|;
block|}
comment|/// Returns 0 if not defined
name|SEHExceptStmt
operator|*
name|getExceptHandler
argument_list|()
specifier|const
block|;
name|SEHFinallyStmt
operator|*
name|getFinallyHandler
argument_list|()
specifier|const
block|;
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|Children
argument_list|,
name|Children
operator|+
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHTryStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|SEHTryStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

