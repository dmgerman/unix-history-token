begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Stmt.h - Classes for representing statements -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Stmt interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_STMT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_STMT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/DeclGroup.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtIterator.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/CapturedStmt.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/IdentifierTable.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/iterator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|FoldingSetNodeID
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|Attr
decl_stmt|;
name|class
name|CapturedDecl
decl_stmt|;
name|class
name|Decl
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|LabelDecl
decl_stmt|;
name|class
name|ODRHash
decl_stmt|;
name|class
name|ParmVarDecl
decl_stmt|;
name|class
name|PrinterHelper
decl_stmt|;
struct_decl|struct
name|PrintingPolicy
struct_decl|;
name|class
name|QualType
decl_stmt|;
name|class
name|RecordDecl
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
name|class
name|StringLiteral
decl_stmt|;
name|class
name|SwitchStmt
decl_stmt|;
name|class
name|Token
decl_stmt|;
name|class
name|VarDecl
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// AST classes for statements.
comment|//===----------------------------------------------------------------------===//
comment|/// Stmt - This represents one statement.
comment|///
name|class
name|alignas
parameter_list|(
name|void
modifier|*
parameter_list|)
function|Stmt
block|{
name|public
label|:
enum|enum
name|StmtClass
block|{
name|NoStmtClass
init|=
literal|0
block|,
define|#
directive|define
name|STMT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
value|CLASS##Class,
define|#
directive|define
name|STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,
define|#
directive|define
name|LAST_STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|STMT
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|}
enum|;
comment|// Make vanilla 'new' and 'delete' illegal for Stmts.
name|protected
label|:
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|)
function|noexcept
block|{
name|llvm_unreachable
argument_list|(
literal|"Stmts cannot be allocated with regular 'new'."
argument_list|)
expr_stmt|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function|noexcept
block|{
name|llvm_unreachable
argument_list|(
literal|"Stmts cannot be released with regular 'delete'."
argument_list|)
expr_stmt|;
block|}
name|class
name|StmtBitfields
block|{
name|friend
name|class
name|Stmt
decl_stmt|;
comment|/// \brief The statement class.
name|unsigned
name|sClass
range|:
literal|8
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumStmtBits
init|=
literal|8
block|}
enum|;
name|class
name|CompoundStmtBitfields
block|{
name|friend
name|class
name|CompoundStmt
decl_stmt|;
name|unsigned
label|:
name|NumStmtBits
expr_stmt|;
name|unsigned
name|NumStmts
range|:
literal|32
operator|-
name|NumStmtBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|IfStmtBitfields
block|{
name|friend
name|class
name|IfStmt
decl_stmt|;
name|unsigned
label|:
name|NumStmtBits
expr_stmt|;
name|unsigned
name|IsConstexpr
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ExprBitfields
block|{
name|friend
name|class
name|Expr
decl_stmt|;
name|friend
name|class
name|DeclRefExpr
decl_stmt|;
comment|// computeDependence
name|friend
name|class
name|InitListExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|DesignatedInitExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|BlockDeclRefExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|friend
name|class
name|CXXNewExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|DependentScopeDeclRefExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXConstructExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CallExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|OffsetOfExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ObjCMessageExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ObjCArrayLiteral
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ObjCDictionaryLiteral
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ShuffleVectorExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|ParenListExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXUnresolvedConstructExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|CXXDependentScopeMemberExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|OverloadExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|PseudoObjectExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|AtomicExpr
decl_stmt|;
comment|// ctor
name|friend
name|class
name|OpaqueValueExpr
decl_stmt|;
comment|// ctor
name|unsigned
label|:
name|NumStmtBits
expr_stmt|;
name|unsigned
name|ValueKind
range|:
literal|2
decl_stmt|;
name|unsigned
name|ObjectKind
range|:
literal|3
decl_stmt|;
name|unsigned
name|TypeDependent
range|:
literal|1
decl_stmt|;
name|unsigned
name|ValueDependent
range|:
literal|1
decl_stmt|;
name|unsigned
name|InstantiationDependent
range|:
literal|1
decl_stmt|;
name|unsigned
name|ContainsUnexpandedParameterPack
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumExprBits
init|=
literal|17
block|}
enum|;
name|class
name|CharacterLiteralBitfields
block|{
name|friend
name|class
name|CharacterLiteral
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|Kind
range|:
literal|3
decl_stmt|;
block|}
empty_stmt|;
enum|enum
name|APFloatSemantics
block|{
name|IEEEhalf
block|,
name|IEEEsingle
block|,
name|IEEEdouble
block|,
name|x87DoubleExtended
block|,
name|IEEEquad
block|,
name|PPCDoubleDouble
block|}
enum|;
name|class
name|FloatingLiteralBitfields
block|{
name|friend
name|class
name|FloatingLiteral
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|Semantics
range|:
literal|3
decl_stmt|;
comment|// Provides semantics for APFloat construction
name|unsigned
name|IsExact
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|UnaryExprOrTypeTraitExprBitfields
block|{
name|friend
name|class
name|UnaryExprOrTypeTraitExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|Kind
range|:
literal|2
decl_stmt|;
name|unsigned
name|IsType
range|:
literal|1
decl_stmt|;
comment|// true if operand is a type, false if an expression.
block|}
empty_stmt|;
name|class
name|DeclRefExprBitfields
block|{
name|friend
name|class
name|DeclRefExpr
decl_stmt|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|HasQualifier
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasTemplateKWAndArgsInfo
range|:
literal|1
decl_stmt|;
name|unsigned
name|HasFoundDecl
range|:
literal|1
decl_stmt|;
name|unsigned
name|HadMultipleCandidates
range|:
literal|1
decl_stmt|;
name|unsigned
name|RefersToEnclosingVariableOrCapture
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CastExprBitfields
block|{
name|friend
name|class
name|CastExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|Kind
range|:
literal|6
decl_stmt|;
name|unsigned
name|BasePathSize
range|:
literal|32
operator|-
literal|6
operator|-
name|NumExprBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CallExprBitfields
block|{
name|friend
name|class
name|CallExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|NumPreArgs
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ExprWithCleanupsBitfields
block|{
name|friend
name|class
name|ExprWithCleanups
decl_stmt|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
comment|// When false, it must not have side effects.
name|unsigned
name|CleanupsHaveSideEffects
range|:
literal|1
decl_stmt|;
name|unsigned
name|NumObjects
range|:
literal|32
operator|-
literal|1
operator|-
name|NumExprBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|PseudoObjectExprBitfields
block|{
name|friend
name|class
name|PseudoObjectExpr
decl_stmt|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
comment|// deserialization
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
comment|// These don't need to be particularly wide, because they're
comment|// strictly limited by the forms of expressions we permit.
name|unsigned
name|NumSubExprs
range|:
literal|8
decl_stmt|;
name|unsigned
name|ResultIndex
range|:
literal|32
operator|-
literal|8
operator|-
name|NumExprBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ObjCIndirectCopyRestoreExprBitfields
block|{
name|friend
name|class
name|ObjCIndirectCopyRestoreExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|ShouldCopy
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|InitListExprBitfields
block|{
name|friend
name|class
name|InitListExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
comment|/// Whether this initializer list originally had a GNU array-range
comment|/// designator in it. This is a temporary marker used by CodeGen.
name|unsigned
name|HadArrayRangeDesignator
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
name|class
name|TypeTraitExprBitfields
block|{
name|friend
name|class
name|TypeTraitExpr
decl_stmt|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
name|friend
name|class
name|ASTStmtWriter
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
comment|/// \brief The kind of type trait, which is a value of a TypeTrait enumerator.
name|unsigned
name|Kind
range|:
literal|8
decl_stmt|;
comment|/// \brief If this expression is not value-dependent, this indicates whether
comment|/// the trait evaluated true or false.
name|unsigned
name|Value
range|:
literal|1
decl_stmt|;
comment|/// \brief The number of arguments to this type trait.
name|unsigned
name|NumArgs
range|:
literal|32
operator|-
literal|8
operator|-
literal|1
operator|-
name|NumExprBits
decl_stmt|;
block|}
empty_stmt|;
name|class
name|CoawaitExprBitfields
block|{
name|friend
name|class
name|CoawaitExpr
decl_stmt|;
name|unsigned
label|:
name|NumExprBits
expr_stmt|;
name|unsigned
name|IsImplicit
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
union|union
block|{
name|StmtBitfields
name|StmtBits
decl_stmt|;
name|CompoundStmtBitfields
name|CompoundStmtBits
decl_stmt|;
name|IfStmtBitfields
name|IfStmtBits
decl_stmt|;
name|ExprBitfields
name|ExprBits
decl_stmt|;
name|CharacterLiteralBitfields
name|CharacterLiteralBits
decl_stmt|;
name|FloatingLiteralBitfields
name|FloatingLiteralBits
decl_stmt|;
name|UnaryExprOrTypeTraitExprBitfields
name|UnaryExprOrTypeTraitExprBits
decl_stmt|;
name|DeclRefExprBitfields
name|DeclRefExprBits
decl_stmt|;
name|CastExprBitfields
name|CastExprBits
decl_stmt|;
name|CallExprBitfields
name|CallExprBits
decl_stmt|;
name|ExprWithCleanupsBitfields
name|ExprWithCleanupsBits
decl_stmt|;
name|PseudoObjectExprBitfields
name|PseudoObjectExprBits
decl_stmt|;
name|ObjCIndirectCopyRestoreExprBitfields
name|ObjCIndirectCopyRestoreExprBits
decl_stmt|;
name|InitListExprBitfields
name|InitListExprBits
decl_stmt|;
name|TypeTraitExprBitfields
name|TypeTraitExprBits
decl_stmt|;
name|CoawaitExprBitfields
name|CoawaitBits
decl_stmt|;
block|}
union|;
name|friend
name|class
name|ASTStmtReader
decl_stmt|;
name|friend
name|class
name|ASTStmtWriter
decl_stmt|;
name|public
label|:
comment|// Only allow allocation of Stmts using the allocator in ASTContext
comment|// or by doing a placement new.
name|void
modifier|*
name|operator
name|new
argument_list|(
name|size_t
name|bytes
argument_list|,
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|unsigned
name|alignment
operator|=
literal|8
argument_list|)
decl_stmt|;
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
specifier|const
name|ASTContext
modifier|*
name|C
parameter_list|,
name|unsigned
name|alignment
init|=
literal|8
parameter_list|)
block|{
return|return
name|operator
name|new
argument_list|(
name|bytes
argument_list|,
operator|*
name|C
argument_list|,
name|alignment
argument_list|)
return|;
block|}
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function|noexcept
block|{
return|return
name|mem
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|ASTContext
modifier|&
parameter_list|,
name|unsigned
parameter_list|)
function|noexcept
block|{}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|ASTContext
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function|noexcept
block|{}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function|noexcept
block|{}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function|noexcept
block|{}
name|public
label|:
comment|/// \brief A placeholder type used to construct an empty shell of a
comment|/// type, that will be filled in later (e.g., by some
comment|/// de-serialization).
struct|struct
name|EmptyShell
block|{ }
struct|;
name|protected
label|:
comment|/// Iterator for iterating over Stmt * arrays that contain only Expr *
comment|///
comment|/// This is needed because AST nodes use Stmt* arrays to store
comment|/// references to children (to be compatible with StmtIterator).
name|struct
name|ExprIterator
range|:
name|llvm
operator|::
name|iterator_adaptor_base
operator|<
name|ExprIterator
decl_stmt|,
name|Stmt
modifier|*
modifier|*
decl_stmt|,
name|std
decl|::
name|random_access_iterator_tag
decl_stmt|,
name|Expr
modifier|*
decl|>
block|{
name|ExprIterator
argument_list|()
operator|:
name|iterator_adaptor_base
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|ExprIterator
argument_list|(
name|Stmt
operator|*
operator|*
name|I
argument_list|)
operator|:
name|iterator_adaptor_base
argument_list|(
argument|I
argument_list|)
block|{}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|*
name|I
operator|)
operator|->
name|getStmtClass
argument_list|()
operator|>=
name|firstExprConstant
operator|&&
operator|(
operator|*
name|I
operator|)
operator|->
name|getStmtClass
argument_list|()
operator|<=
name|lastExprConstant
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|*
operator|>
operator|(
name|I
operator|)
return|;
block|}
block|}
empty_stmt|;
comment|/// Const iterator for iterating over Stmt * arrays that contain only Expr *
name|struct
name|ConstExprIterator
range|:
name|llvm
operator|::
name|iterator_adaptor_base
operator|<
name|ConstExprIterator
decl_stmt|, const
name|Stmt
modifier|*
decl|const
modifier|*
decl_stmt|,
name|std
decl|::
name|random_access_iterator_tag
decl_stmt|,                                     const
name|Expr
modifier|*
decl|const>
block|{
name|ConstExprIterator
argument_list|()
operator|:
name|iterator_adaptor_base
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|ConstExprIterator
argument_list|(
specifier|const
name|Stmt
operator|*
specifier|const
operator|*
name|I
argument_list|)
operator|:
name|iterator_adaptor_base
argument_list|(
argument|I
argument_list|)
block|{}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
operator|*
name|I
operator|)
operator|->
name|getStmtClass
argument_list|()
operator|>=
name|firstExprConstant
operator|&&
operator|(
operator|*
name|I
operator|)
operator|->
name|getStmtClass
argument_list|()
operator|<=
name|lastExprConstant
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
specifier|const
operator|*
operator|>
operator|(
name|I
operator|)
return|;
block|}
block|}
empty_stmt|;
name|private
label|:
comment|/// \brief Whether statistic collection is enabled.
specifier|static
name|bool
name|StatisticsEnabled
decl_stmt|;
name|protected
label|:
comment|/// \brief Construct an empty statement.
name|explicit
name|Stmt
argument_list|(
argument|StmtClass SC
argument_list|,
argument|EmptyShell
argument_list|)
block|:
name|Stmt
argument_list|(
argument|SC
argument_list|)
block|{}
name|public
label|:
name|Stmt
argument_list|(
argument|StmtClass SC
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|"changing bitfields changed sizeof(Stmt)"
argument_list|)
expr_stmt|;
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|%
name|alignof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|0
argument_list|,
literal|"Insufficient alignment!"
argument_list|)
expr_stmt|;
name|StmtBits
operator|.
name|sClass
operator|=
name|SC
expr_stmt|;
if|if
condition|(
name|StatisticsEnabled
condition|)
name|Stmt
operator|::
name|addStmtClass
argument_list|(
name|SC
argument_list|)
expr_stmt|;
block|}
name|StmtClass
name|getStmtClass
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|StmtClass
operator|>
operator|(
name|StmtBits
operator|.
name|sClass
operator|)
return|;
block|}
specifier|const
name|char
operator|*
name|getStmtClassName
argument_list|()
specifier|const
expr_stmt|;
comment|/// SourceLocation tokens are not useful in isolation - they are low level
comment|/// value objects created/interpreted by SourceManager. We assume AST
comment|/// clients will have a pointer to the respective SourceManager.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
comment|// global temp stats (until we have a per-module visitor)
specifier|static
name|void
name|addStmtClass
argument_list|(
specifier|const
name|StmtClass
name|s
argument_list|)
decl_stmt|;
specifier|static
name|void
name|EnableStatistics
parameter_list|()
function_decl|;
specifier|static
name|void
name|PrintStats
parameter_list|()
function_decl|;
comment|/// \brief Dumps the specified AST fragment and all subtrees to
comment|/// \c llvm::errs().
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|(
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
comment|/// dumpColor - same as dump(), but forces color highlighting.
name|void
name|dumpColor
argument_list|()
specifier|const
expr_stmt|;
comment|/// dumpPretty/printPretty - These two methods do a "pretty print" of the AST
comment|/// back to its original source language syntax.
name|void
name|dumpPretty
argument_list|(
specifier|const
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
name|void
name|printPretty
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|PrinterHelper
operator|*
name|Helper
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|Indentation
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only
comment|///   works on systems with GraphViz (Mac OS X) or dot+gv installed.
name|void
name|viewAST
argument_list|()
specifier|const
expr_stmt|;
comment|/// Skip past any implicit AST nodes which might surround this
comment|/// statement, such as ExprWithCleanups or ImplicitCastExpr nodes.
name|Stmt
modifier|*
name|IgnoreImplicit
parameter_list|()
function_decl|;
specifier|const
name|Stmt
operator|*
name|IgnoreImplicit
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|IgnoreImplicit
argument_list|()
return|;
block|}
comment|/// \brief Skip no-op (attributed, compound) container stmts and skip captured
comment|/// stmt at the top, if \a IgnoreCaptured is true.
name|Stmt
modifier|*
name|IgnoreContainers
argument_list|(
name|bool
name|IgnoreCaptured
operator|=
name|false
argument_list|)
decl_stmt|;
specifier|const
name|Stmt
operator|*
name|stripLabelLikeStatements
argument_list|()
specifier|const
expr_stmt|;
name|Stmt
modifier|*
name|stripLabelLikeStatements
parameter_list|()
block|{
return|return
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|const_cast
operator|<
specifier|const
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|stripLabelLikeStatements
argument_list|()
operator|)
return|;
block|}
comment|/// Child Iterators: All subclasses must implement 'children'
comment|/// to permit easy iteration over the substatements/subexpessions of an
comment|/// AST node.  This permits easy iteration over all nodes in the AST.
typedef|typedef
name|StmtIterator
name|child_iterator
typedef|;
typedef|typedef
name|ConstStmtIterator
name|const_child_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|child_iterator
operator|>
name|child_range
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_child_iterator
operator|>
name|const_child_range
expr_stmt|;
name|child_range
name|children
parameter_list|()
function_decl|;
name|const_child_range
name|children
argument_list|()
specifier|const
block|{
name|auto
name|Children
operator|=
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|children
argument_list|()
block|;
return|return
name|const_child_range
argument_list|(
name|Children
operator|.
name|begin
argument_list|()
argument_list|,
name|Children
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
name|child_iterator
name|child_begin
parameter_list|()
block|{
return|return
name|children
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
name|child_iterator
name|child_end
parameter_list|()
block|{
return|return
name|children
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
name|const_child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|children
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|children
argument_list|()
operator|.
name|end
argument_list|()
return|;
block|}
comment|/// \brief Produce a unique representation of the given statement.
comment|///
comment|/// \param ID once the profiling operation is complete, will contain
comment|/// the unique representation of the given statement.
comment|///
comment|/// \param Context the AST context in which the statement resides
comment|///
comment|/// \param Canonical whether the profile should be based on the canonical
comment|/// representation of this statement (e.g., where non-type template
comment|/// parameters are identified by index/level rather than their
comment|/// declaration pointers) or the exact representation of the statement as
comment|/// written in the source.
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
specifier|const
name|ASTContext
operator|&
name|Context
argument_list|,
name|bool
name|Canonical
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Calculate a unique representation for a statement that is
comment|/// stable across compiler invocations.
comment|///
comment|/// \param ID profile information will be stored in ID.
comment|///
comment|/// \param Hash an ODRHash object which will be called where pointers would
comment|/// have been used in the Profile function.
name|void
name|ProcessODRHash
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
name|ODRHash
operator|&
name|Hash
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|/// DeclStmt - Adaptor class for mixing declarations with statements and
comment|/// expressions. For example, CompoundStmt mixes statements, expressions
comment|/// and declarations (variables, types). Another example is ForStmt, where
comment|/// the first statement can be an expression or a declaration.
comment|///
name|class
name|DeclStmt
range|:
name|public
name|Stmt
block|{
name|DeclGroupRef
name|DG
block|;
name|SourceLocation
name|StartLoc
block|,
name|EndLoc
block|;
name|public
operator|:
name|DeclStmt
argument_list|(
argument|DeclGroupRef dg
argument_list|,
argument|SourceLocation startLoc
argument_list|,
argument|SourceLocation endLoc
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DeclStmtClass
argument_list|)
block|,
name|DG
argument_list|(
name|dg
argument_list|)
block|,
name|StartLoc
argument_list|(
name|startLoc
argument_list|)
block|,
name|EndLoc
argument_list|(
argument|endLoc
argument_list|)
block|{}
comment|/// \brief Build an empty declaration statement.
name|explicit
name|DeclStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DeclStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// isSingleDecl - This method returns true if this DeclStmt refers
comment|/// to a single Decl.
name|bool
name|isSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|isSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|Decl
operator|*
name|getSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
name|Decl
operator|*
name|getSingleDecl
argument_list|()
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|DeclGroupRef
name|getDeclGroup
argument_list|()
specifier|const
block|{
return|return
name|DG
return|;
block|}
name|DeclGroupRef
name|getDeclGroup
argument_list|()
block|{
return|return
name|DG
return|;
block|}
name|void
name|setDeclGroup
argument_list|(
argument|DeclGroupRef DGR
argument_list|)
block|{
name|DG
operator|=
name|DGR
block|; }
name|SourceLocation
name|getStartLoc
argument_list|()
specifier|const
block|{
return|return
name|StartLoc
return|;
block|}
name|void
name|setStartLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StartLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|EndLoc
return|;
block|}
name|void
name|setEndLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EndLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|StartLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|EndLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DeclStmtClass
return|;
block|}
comment|// Iterators over subexpressions.
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|(
name|DG
operator|.
name|begin
argument_list|()
argument_list|,
name|DG
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|child_iterator
argument_list|(
name|DG
operator|.
name|end
argument_list|()
argument_list|,
name|DG
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
typedef|typedef
name|DeclGroupRef
operator|::
name|iterator
name|decl_iterator
expr_stmt|;
typedef|typedef
name|DeclGroupRef
operator|::
name|const_iterator
name|const_decl_iterator
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|decl_iterator
operator|>
name|decl_range
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_decl_iterator
operator|>
name|decl_const_range
expr_stmt|;
name|decl_range
name|decls
parameter_list|()
block|{
return|return
name|decl_range
argument_list|(
name|decl_begin
argument_list|()
argument_list|,
name|decl_end
argument_list|()
argument_list|)
return|;
block|}
name|decl_const_range
name|decls
argument_list|()
specifier|const
block|{
return|return
name|decl_const_range
argument_list|(
name|decl_begin
argument_list|()
argument_list|,
name|decl_end
argument_list|()
argument_list|)
return|;
block|}
name|decl_iterator
name|decl_begin
parameter_list|()
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
name|decl_iterator
name|decl_end
parameter_list|()
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
name|const_decl_iterator
name|decl_begin
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
name|const_decl_iterator
name|decl_end
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|decl_iterator
operator|>
name|reverse_decl_iterator
expr_stmt|;
name|reverse_decl_iterator
name|decl_rbegin
parameter_list|()
block|{
return|return
name|reverse_decl_iterator
argument_list|(
name|decl_end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_decl_iterator
name|decl_rend
parameter_list|()
block|{
return|return
name|reverse_decl_iterator
argument_list|(
name|decl_begin
argument_list|()
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// NullStmt - This is the null statement ";": C99 6.8.3p3.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|NullStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|SemiLoc
block|;
comment|/// \brief True if the null statement was preceded by an empty macro, e.g:
comment|/// @code
comment|///   #define CALL(x)
comment|///   CALL(0);
comment|/// @endcode
name|bool
name|HasLeadingEmptyMacro
block|;
name|public
operator|:
name|NullStmt
argument_list|(
argument|SourceLocation L
argument_list|,
argument|bool hasLeadingEmptyMacro = false
argument_list|)
operator|:
name|Stmt
argument_list|(
name|NullStmtClass
argument_list|)
block|,
name|SemiLoc
argument_list|(
name|L
argument_list|)
block|,
name|HasLeadingEmptyMacro
argument_list|(
argument|hasLeadingEmptyMacro
argument_list|)
block|{}
comment|/// \brief Build an empty null statement.
name|explicit
name|NullStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|NullStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|HasLeadingEmptyMacro
argument_list|(
argument|false
argument_list|)
block|{ }
name|SourceLocation
name|getSemiLoc
argument_list|()
specifier|const
block|{
return|return
name|SemiLoc
return|;
block|}
name|void
name|setSemiLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SemiLoc
operator|=
name|L
block|; }
name|bool
name|hasLeadingEmptyMacro
argument_list|()
specifier|const
block|{
return|return
name|HasLeadingEmptyMacro
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SemiLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SemiLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|NullStmtClass
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
name|friend
name|class
name|ASTStmtReader
block|;
name|friend
name|class
name|ASTStmtWriter
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// CompoundStmt - This represents a group of statements like { stmt stmt }.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|CompoundStmt
range|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
operator|*
name|Body
block|;
name|SourceLocation
name|LBraceLoc
block|,
name|RBraceLoc
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|public
operator|:
name|CompoundStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|ArrayRef<Stmt*> Stmts
argument_list|,
argument|SourceLocation LB
argument_list|,
argument|SourceLocation RB
argument_list|)
block|;
comment|// \brief Build an empty compound statement with a location.
name|explicit
name|CompoundStmt
argument_list|(
argument|SourceLocation Loc
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|)
block|,
name|Body
argument_list|(
name|nullptr
argument_list|)
block|,
name|LBraceLoc
argument_list|(
name|Loc
argument_list|)
block|,
name|RBraceLoc
argument_list|(
argument|Loc
argument_list|)
block|{
name|CompoundStmtBits
operator|.
name|NumStmts
operator|=
literal|0
block|;   }
comment|// \brief Build an empty compound statement.
name|explicit
name|CompoundStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|Body
argument_list|(
argument|nullptr
argument_list|)
block|{
name|CompoundStmtBits
operator|.
name|NumStmts
operator|=
literal|0
block|;   }
name|void
name|setStmts
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|ArrayRef
operator|<
name|Stmt
operator|*
operator|>
name|Stmts
argument_list|)
block|;
name|bool
name|body_empty
argument_list|()
specifier|const
block|{
return|return
name|CompoundStmtBits
operator|.
name|NumStmts
operator|==
literal|0
return|;
block|}
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|CompoundStmtBits
operator|.
name|NumStmts
return|;
block|}
typedef|typedef
name|Stmt
modifier|*
modifier|*
name|body_iterator
typedef|;
end_decl_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|body_iterator
operator|>
name|body_range
expr_stmt|;
end_typedef

begin_function
name|body_range
name|body
parameter_list|()
block|{
return|return
name|body_range
argument_list|(
name|body_begin
argument_list|()
argument_list|,
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|body_iterator
name|body_begin
parameter_list|()
block|{
return|return
name|Body
return|;
block|}
end_function

begin_function
name|body_iterator
name|body_end
parameter_list|()
block|{
return|return
name|Body
operator|+
name|size
argument_list|()
return|;
block|}
end_function

begin_function
name|Stmt
modifier|*
name|body_front
parameter_list|()
block|{
return|return
operator|!
name|body_empty
argument_list|()
condition|?
name|Body
index|[
literal|0
index|]
else|:
name|nullptr
return|;
block|}
end_function

begin_function
name|Stmt
modifier|*
name|body_back
parameter_list|()
block|{
return|return
operator|!
name|body_empty
argument_list|()
condition|?
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
else|:
name|nullptr
return|;
block|}
end_function

begin_function
name|void
name|setLastStmt
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|body_empty
argument_list|()
operator|&&
literal|"setLastStmt"
argument_list|)
expr_stmt|;
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|S
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|Stmt
modifier|*
specifier|const
modifier|*
name|const_body_iterator
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_body_iterator
operator|>
name|body_const_range
expr_stmt|;
end_typedef

begin_expr_stmt
name|body_const_range
name|body
argument_list|()
specifier|const
block|{
return|return
name|body_const_range
argument_list|(
name|body_begin
argument_list|()
argument_list|,
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_body_iterator
name|body_begin
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_body_iterator
name|body_end
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|+
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Stmt
operator|*
name|body_front
argument_list|()
specifier|const
block|{
return|return
operator|!
name|body_empty
argument_list|()
operator|?
name|Body
index|[
literal|0
index|]
operator|:
name|nullptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Stmt
operator|*
name|body_back
argument_list|()
specifier|const
block|{
return|return
operator|!
name|body_empty
argument_list|()
operator|?
name|Body
index|[
name|size
argument_list|()
operator|-
literal|1
index|]
operator|:
name|nullptr
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|body_iterator
operator|>
name|reverse_body_iterator
expr_stmt|;
end_typedef

begin_function
name|reverse_body_iterator
name|body_rbegin
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reverse_body_iterator
name|body_rend
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_body_iterator
operator|>
name|const_reverse_body_iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|LBraceLoc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|RBraceLoc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getLBracLoc
argument_list|()
specifier|const
block|{
return|return
name|LBraceLoc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getRBracLoc
argument_list|()
specifier|const
block|{
return|return
name|RBraceLoc
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|T
parameter_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CompoundStmtClass
return|;
block|}
end_function

begin_comment
comment|// Iterators
end_comment

begin_function
name|child_range
name|children
parameter_list|()
block|{
return|return
name|child_range
argument_list|(
name|Body
argument_list|,
name|Body
operator|+
name|CompoundStmtBits
operator|.
name|NumStmts
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_child_range
name|children
argument_list|()
specifier|const
block|{
return|return
name|const_child_range
argument_list|(
name|child_iterator
argument_list|(
name|Body
argument_list|)
argument_list|,
name|child_iterator
argument_list|(
name|Body
operator|+
name|CompoundStmtBits
operator|.
name|NumStmts
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// SwitchCase is the base class for CaseStmt and DefaultStmt,
end_comment

begin_decl_stmt
name|class
name|SwitchCase
range|:
name|public
name|Stmt
block|{
name|protected
operator|:
comment|// A pointer to the following CaseStmt or DefaultStmt class,
comment|// used by SwitchStmt.
name|SwitchCase
operator|*
name|NextSwitchCase
block|;
name|SourceLocation
name|KeywordLoc
block|;
name|SourceLocation
name|ColonLoc
block|;
name|SwitchCase
argument_list|(
argument|StmtClass SC
argument_list|,
argument|SourceLocation KWLoc
argument_list|,
argument|SourceLocation ColonLoc
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|)
block|,
name|NextSwitchCase
argument_list|(
name|nullptr
argument_list|)
block|,
name|KeywordLoc
argument_list|(
name|KWLoc
argument_list|)
block|,
name|ColonLoc
argument_list|(
argument|ColonLoc
argument_list|)
block|{   }
name|SwitchCase
argument_list|(
argument|StmtClass SC
argument_list|,
argument|EmptyShell
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|)
block|,
name|NextSwitchCase
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
specifier|const
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|void
name|setNextSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|NextSwitchCase
operator|=
name|SC
block|; }
name|SourceLocation
name|getKeywordLoc
argument_list|()
specifier|const
block|{
return|return
name|KeywordLoc
return|;
block|}
name|void
name|setKeywordLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|KeywordLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|;
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|SwitchCase
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getSubStmt
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|KeywordLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
operator|||
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
expr|}
block|;
name|class
name|CaseStmt
operator|:
name|public
name|SwitchCase
block|{
name|SourceLocation
name|EllipsisLoc
block|;   enum
block|{
name|LHS
block|,
name|RHS
block|,
name|SUBSTMT
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// The expression for the RHS is Non-null for
comment|// GNU "case 1 ... 4" extension
name|public
operator|:
name|CaseStmt
argument_list|(
argument|Expr *lhs
argument_list|,
argument|Expr *rhs
argument_list|,
argument|SourceLocation caseLoc
argument_list|,
argument|SourceLocation ellipsisLoc
argument_list|,
argument|SourceLocation colonLoc
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|,
argument|caseLoc
argument_list|,
argument|colonLoc
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
name|nullptr
block|;
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|lhs
operator|)
block|;
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|rhs
operator|)
block|;
name|EllipsisLoc
operator|=
name|ellipsisLoc
block|;   }
comment|/// \brief Build an empty switch case statement.
name|explicit
name|CaseStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getCaseLoc
argument_list|()
specifier|const
block|{
return|return
name|KeywordLoc
return|;
block|}
name|void
name|setCaseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|KeywordLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
name|void
name|setEllipsisLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EllipsisLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|Expr
operator|*
name|getLHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getRHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
name|S
block|; }
name|void
name|setLHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|void
name|setRHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|KeywordLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
comment|// Handle deeply nested case statements with iteration instead of recursion.
specifier|const
name|CaseStmt
operator|*
name|CS
operator|=
name|this
block|;
while|while
condition|(
specifier|const
name|CaseStmt
modifier|*
name|CS2
init|=
name|dyn_cast
operator|<
name|CaseStmt
operator|>
operator|(
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|)
condition|)
name|CS
operator|=
name|CS2
expr_stmt|;
return|return
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
name|END_EXPR
index|]
argument_list|)
return|;
block|}
expr|}
block|;
name|class
name|DefaultStmt
operator|:
name|public
name|SwitchCase
block|{
name|Stmt
operator|*
name|SubStmt
block|;
name|public
operator|:
name|DefaultStmt
argument_list|(
argument|SourceLocation DL
argument_list|,
argument|SourceLocation CL
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|SwitchCase
argument_list|(
name|DefaultStmtClass
argument_list|,
name|DL
argument_list|,
name|CL
argument_list|)
block|,
name|SubStmt
argument_list|(
argument|substmt
argument_list|)
block|{}
comment|/// \brief Build an empty default statement.
name|explicit
name|DefaultStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|DefaultStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubStmt
operator|=
name|S
block|; }
name|SourceLocation
name|getDefaultLoc
argument_list|()
specifier|const
block|{
return|return
name|KeywordLoc
return|;
block|}
name|void
name|setDefaultLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|KeywordLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|KeywordLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubStmt
argument_list|,
operator|&
name|SubStmt
operator|+
literal|1
argument_list|)
return|;
block|}
expr|}
block|;
specifier|inline
name|SourceLocation
name|SwitchCase
operator|::
name|getLocEnd
argument_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|CaseStmt
modifier|*
name|CS
init|=
name|dyn_cast
operator|<
name|CaseStmt
operator|>
operator|(
name|this
operator|)
condition|)
return|return
name|CS
operator|->
name|getLocEnd
argument_list|()
return|;
return|return
name|cast
operator|<
name|DefaultStmt
operator|>
operator|(
name|this
operator|)
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
comment|/// LabelStmt - Represents a label, which has a substatement.  For example:
comment|///    foo: return;
comment|///
name|class
name|LabelStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|IdentLoc
block|;
name|LabelDecl
operator|*
name|TheDecl
block|;
name|Stmt
operator|*
name|SubStmt
block|;
name|public
operator|:
name|LabelStmt
argument_list|(
argument|SourceLocation IL
argument_list|,
argument|LabelDecl *D
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|Stmt
argument_list|(
name|LabelStmtClass
argument_list|)
block|,
name|IdentLoc
argument_list|(
name|IL
argument_list|)
block|,
name|TheDecl
argument_list|(
name|D
argument_list|)
block|,
name|SubStmt
argument_list|(
argument|substmt
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|LabelStmt
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|SourceLocation
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|"LabelStmt too big"
argument_list|)
block|;   }
comment|// \brief Build an empty label statement.
name|explicit
name|LabelStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|LabelStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getIdentLoc
argument_list|()
specifier|const
block|{
return|return
name|IdentLoc
return|;
block|}
name|LabelDecl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|TheDecl
return|;
block|}
name|void
name|setDecl
argument_list|(
argument|LabelDecl *D
argument_list|)
block|{
name|TheDecl
operator|=
name|D
block|; }
specifier|const
name|char
operator|*
name|getName
argument_list|()
specifier|const
block|;
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setIdentLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IdentLoc
operator|=
name|L
block|; }
name|void
name|setSubStmt
argument_list|(
argument|Stmt *SS
argument_list|)
block|{
name|SubStmt
operator|=
name|SS
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|IdentLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubStmt
argument_list|,
operator|&
name|SubStmt
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|LabelStmtClass
return|;
block|}
expr|}
block|;
comment|/// \brief Represents an attribute applied to a statement.
comment|///
comment|/// Represents an attribute applied to a statement. For example:
comment|///   [[omp::for(...)]] for (...) { ... }
comment|///
name|class
name|AttributedStmt
operator|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
name|SubStmt
block|;
name|SourceLocation
name|AttrLoc
block|;
name|unsigned
name|NumAttrs
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|AttributedStmt
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|ArrayRef<const Attr*> Attrs
argument_list|,
argument|Stmt *SubStmt
argument_list|)
operator|:
name|Stmt
argument_list|(
name|AttributedStmtClass
argument_list|)
block|,
name|SubStmt
argument_list|(
name|SubStmt
argument_list|)
block|,
name|AttrLoc
argument_list|(
name|Loc
argument_list|)
block|,
name|NumAttrs
argument_list|(
argument|Attrs.size()
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|Attrs
operator|.
name|begin
argument_list|()
argument_list|,
name|Attrs
operator|.
name|end
argument_list|()
argument_list|,
name|getAttrArrayPtr
argument_list|()
argument_list|)
block|;   }
name|explicit
name|AttributedStmt
argument_list|(
argument|EmptyShell Empty
argument_list|,
argument|unsigned NumAttrs
argument_list|)
operator|:
name|Stmt
argument_list|(
name|AttributedStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|NumAttrs
argument_list|(
argument|NumAttrs
argument_list|)
block|{
name|std
operator|::
name|fill_n
argument_list|(
name|getAttrArrayPtr
argument_list|()
argument_list|,
name|NumAttrs
argument_list|,
name|nullptr
argument_list|)
block|;   }
specifier|const
name|Attr
operator|*
specifier|const
operator|*
name|getAttrArrayPtr
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Attr
operator|*
specifier|const
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|Attr
operator|*
operator|*
name|getAttrArrayPtr
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Attr
operator|*
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|public
operator|:
specifier|static
name|AttributedStmt
operator|*
name|Create
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|ArrayRef<const Attr*> Attrs
argument_list|,
argument|Stmt *SubStmt
argument_list|)
block|;
comment|// \brief Build an empty attributed statement.
specifier|static
name|AttributedStmt
operator|*
name|CreateEmpty
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|unsigned NumAttrs
argument_list|)
block|;
name|SourceLocation
name|getAttrLoc
argument_list|()
specifier|const
block|{
return|return
name|AttrLoc
return|;
block|}
name|ArrayRef
operator|<
specifier|const
name|Attr
operator|*
operator|>
name|getAttrs
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|getAttrArrayPtr
argument_list|()
argument_list|,
name|NumAttrs
argument_list|)
return|;
block|}
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|AttrLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubStmt
argument_list|,
operator|&
name|SubStmt
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|AttributedStmtClass
return|;
block|}
expr|}
block|;
comment|/// IfStmt - This represents an if/then/else.
comment|///
name|class
name|IfStmt
operator|:
name|public
name|Stmt
block|{   enum
block|{
name|INIT
block|,
name|VAR
block|,
name|COND
block|,
name|THEN
block|,
name|ELSE
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|IfLoc
block|;
name|SourceLocation
name|ElseLoc
block|;
name|public
operator|:
name|IfStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation IL
argument_list|,
argument|bool IsConstexpr
argument_list|,
argument|Stmt *init
argument_list|,
argument|VarDecl *var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *then
argument_list|,
argument|SourceLocation EL = SourceLocation()
argument_list|,
argument|Stmt *elsev = nullptr
argument_list|)
block|;
comment|/// \brief Build an empty if/then/else statement
name|explicit
name|IfStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IfStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "if" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// if (int x = foo()) {
comment|///   printf("x is %d", x);
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this IfStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getInit
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getInit
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
name|void
name|setInit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|INIT
index|]
operator|=
name|S
block|; }
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
specifier|const
name|Stmt
operator|*
name|getThen
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|void
name|setThen
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|THEN
index|]
operator|=
name|S
block|; }
specifier|const
name|Stmt
operator|*
name|getElse
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|void
name|setElse
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|ELSE
index|]
operator|=
name|S
block|; }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getThen
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|Stmt
operator|*
name|getElse
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|SourceLocation
name|getIfLoc
argument_list|()
specifier|const
block|{
return|return
name|IfLoc
return|;
block|}
name|void
name|setIfLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IfLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getElseLoc
argument_list|()
specifier|const
block|{
return|return
name|ElseLoc
return|;
block|}
name|void
name|setElseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ElseLoc
operator|=
name|L
block|; }
name|bool
name|isConstexpr
argument_list|()
specifier|const
block|{
return|return
name|IfStmtBits
operator|.
name|IsConstexpr
return|;
block|}
name|void
name|setConstexpr
argument_list|(
argument|bool C
argument_list|)
block|{
name|IfStmtBits
operator|.
name|IsConstexpr
operator|=
name|C
block|; }
name|bool
name|isObjCAvailabilityCheck
argument_list|()
specifier|const
block|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|IfLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
if|if
condition|(
name|SubExprs
index|[
name|ELSE
index|]
condition|)
return|return
name|SubExprs
index|[
name|ELSE
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
else|else
return|return
name|SubExprs
index|[
name|THEN
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
comment|// Iterators over subexpressions.  The iterators will include iterating
comment|// over the initialization expression referenced by the condition variable.
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IfStmtClass
return|;
block|}
expr|}
block|;
comment|/// SwitchStmt - This represents a 'switch' stmt.
comment|///
name|class
name|SwitchStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|SwitchLoc
block|;   enum
block|{
name|INIT
block|,
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// This points to a linked list of case and default statements and, if the
comment|// SwitchStmt is a switch on an enum value, records whether all the enum
comment|// values were covered by CaseStmts.  The coverage information value is meant
comment|// to be a hint for possible clients.
name|llvm
operator|::
name|PointerIntPair
operator|<
name|SwitchCase
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|FirstCase
block|;
name|public
operator|:
name|SwitchStmt
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|Stmt
operator|*
name|Init
argument_list|,
name|VarDecl
operator|*
name|Var
argument_list|,
name|Expr
operator|*
name|cond
argument_list|)
block|;
comment|/// \brief Build a empty switch statement.
name|explicit
name|SwitchStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SwitchStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "switch" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// switch (int x = foo()) {
comment|///   case 0: break;
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this SwitchStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getInit
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getInit
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
name|void
name|setInit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|INIT
index|]
operator|=
name|S
block|; }
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
specifier|const
block|{
return|return
name|FirstCase
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
block|{
return|return
name|FirstCase
operator|.
name|getPointer
argument_list|()
return|;
block|}
comment|/// \brief Set the case list for this switch statement.
name|void
name|setSwitchCaseList
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|FirstCase
operator|.
name|setPointer
argument_list|(
name|SC
argument_list|)
block|; }
name|SourceLocation
name|getSwitchLoc
argument_list|()
specifier|const
block|{
return|return
name|SwitchLoc
return|;
block|}
name|void
name|setSwitchLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SwitchLoc
operator|=
name|L
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|,
argument|SourceLocation SL
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|;
name|SwitchLoc
operator|=
name|SL
block|;   }
name|void
name|addSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|SC
operator|->
name|getNextSwitchCase
argument_list|()
operator|&&
literal|"case/default already added to a switch"
argument_list|)
block|;
name|SC
operator|->
name|setNextSwitchCase
argument_list|(
name|FirstCase
operator|.
name|getPointer
argument_list|()
argument_list|)
block|;
name|FirstCase
operator|.
name|setPointer
argument_list|(
name|SC
argument_list|)
block|;   }
comment|/// Set a flag in the SwitchStmt indicating that if the 'switch (X)' is a
comment|/// switch over an enum value then all cases have been explicitly covered.
name|void
name|setAllEnumCasesCovered
argument_list|()
block|{
name|FirstCase
operator|.
name|setInt
argument_list|(
name|true
argument_list|)
block|; }
comment|/// Returns true if the SwitchStmt is a switch of an enum value and all cases
comment|/// have been explicitly covered.
name|bool
name|isAllEnumCasesCovered
argument_list|()
specifier|const
block|{
return|return
name|FirstCase
operator|.
name|getInt
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SwitchLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
operator|?
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
operator|:
name|SubExprs
index|[
name|COND
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SwitchStmtClass
return|;
block|}
expr|}
block|;
comment|/// WhileStmt - This represents a 'while' stmt.
comment|///
name|class
name|WhileStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|WhileLoc
block|;   enum
block|{
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|public
operator|:
name|WhileStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|VarDecl *Var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *body
argument_list|,
argument|SourceLocation WL
argument_list|)
block|;
comment|/// \brief Build an empty while statement.
name|explicit
name|WhileStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|WhileStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "while" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// while (int x = random()) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this WhileStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|VAR
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|WhileLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|WhileStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// DoStmt - This represents a 'do/while' stmt.
comment|///
name|class
name|DoStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|DoLoc
block|;   enum
block|{
name|BODY
block|,
name|COND
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|WhileLoc
block|;
name|SourceLocation
name|RParenLoc
block|;
comment|// Location of final ')' in do stmt condition.
name|public
operator|:
name|DoStmt
argument_list|(
argument|Stmt *body
argument_list|,
argument|Expr *cond
argument_list|,
argument|SourceLocation DL
argument_list|,
argument|SourceLocation WL
argument_list|,
argument|SourceLocation RP
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DoStmtClass
argument_list|)
block|,
name|DoLoc
argument_list|(
name|DL
argument_list|)
block|,
name|WhileLoc
argument_list|(
name|WL
argument_list|)
block|,
name|RParenLoc
argument_list|(
argument|RP
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|cond
operator|)
block|;
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|body
block|;   }
comment|/// \brief Build an empty do-while statement.
name|explicit
name|DoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getDoLoc
argument_list|()
specifier|const
block|{
return|return
name|DoLoc
return|;
block|}
name|void
name|setDoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|DoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|DoLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|RParenLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DoStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of
comment|/// the init/cond/inc parts of the ForStmt will be null if they were not
comment|/// specified in the source.
comment|///
name|class
name|ForStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|ForLoc
block|;   enum
block|{
name|INIT
block|,
name|CONDVAR
block|,
name|COND
block|,
name|INC
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// SubExprs[INIT] is an expression or declstmt.
name|SourceLocation
name|LParenLoc
block|,
name|RParenLoc
block|;
name|public
operator|:
name|ForStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|Stmt *Init
argument_list|,
argument|Expr *Cond
argument_list|,
argument|VarDecl *condVar
argument_list|,
argument|Expr *Inc
argument_list|,
argument|Stmt *Body
argument_list|,
argument|SourceLocation FL
argument_list|,
argument|SourceLocation LP
argument_list|,
argument|SourceLocation RP
argument_list|)
block|;
comment|/// \brief Build an empty for statement.
name|explicit
name|ForStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ForStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Stmt
operator|*
name|getInit
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
comment|/// \brief Retrieve the variable declared in this "for" statement, if any.
comment|///
comment|/// In the following example, "y" is the condition variable.
comment|/// \code
comment|/// for (int x = random(); int y = mangle(x); ++x) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
specifier|const
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
comment|/// If this ForStmt has a condition variable, return the faux DeclStmt
comment|/// associated with the creation of that condition variable.
specifier|const
name|DeclStmt
operator|*
name|getConditionVariableDeclStmt
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|DeclStmt
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|CONDVAR
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getInc
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getInit
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getInc
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setInit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|INIT
index|]
operator|=
name|S
block|; }
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setInc
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|INC
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getForLoc
argument_list|()
specifier|const
block|{
return|return
name|ForLoc
return|;
block|}
name|void
name|setForLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ForLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|LParenLoc
return|;
block|}
name|void
name|setLParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LParenLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ForLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ForStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|SubExprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|SubExprs
index|[
literal|0
index|]
operator|+
name|END_EXPR
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// GotoStmt - This represents a direct goto.
comment|///
name|class
name|GotoStmt
operator|:
name|public
name|Stmt
block|{
name|LabelDecl
operator|*
name|Label
block|;
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|LabelLoc
block|;
name|public
operator|:
name|GotoStmt
argument_list|(
argument|LabelDecl *label
argument_list|,
argument|SourceLocation GL
argument_list|,
argument|SourceLocation LL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|GotoStmtClass
argument_list|)
block|,
name|Label
argument_list|(
name|label
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|GL
argument_list|)
block|,
name|LabelLoc
argument_list|(
argument|LL
argument_list|)
block|{}
comment|/// \brief Build an empty goto statement.
name|explicit
name|GotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|GotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|LabelDecl
operator|*
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|void
name|setLabel
argument_list|(
argument|LabelDecl *D
argument_list|)
block|{
name|Label
operator|=
name|D
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLabelLoc
argument_list|()
specifier|const
block|{
return|return
name|LabelLoc
return|;
block|}
name|void
name|setLabelLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LabelLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|GotoLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|LabelLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|GotoStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// IndirectGotoStmt - This represents an indirect goto.
comment|///
name|class
name|IndirectGotoStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|StarLoc
block|;
name|Stmt
operator|*
name|Target
block|;
name|public
operator|:
name|IndirectGotoStmt
argument_list|(
argument|SourceLocation gotoLoc
argument_list|,
argument|SourceLocation starLoc
argument_list|,
argument|Expr *target
argument_list|)
operator|:
name|Stmt
argument_list|(
name|IndirectGotoStmtClass
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|gotoLoc
argument_list|)
block|,
name|StarLoc
argument_list|(
name|starLoc
argument_list|)
block|,
name|Target
argument_list|(
argument|(Stmt*)target
argument_list|)
block|{}
comment|/// \brief Build an empty indirect goto statement.
name|explicit
name|IndirectGotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IndirectGotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StarLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|StarLoc
return|;
block|}
name|Expr
operator|*
name|getTarget
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Target
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getTarget
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|Target
operator|)
return|;
block|}
name|void
name|setTarget
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|Target
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
comment|/// getConstantTarget - Returns the fixed target of this indirect
comment|/// goto, if one exists.
name|LabelDecl
operator|*
name|getConstantTarget
argument_list|()
block|;
specifier|const
name|LabelDecl
operator|*
name|getConstantTarget
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|IndirectGotoStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getConstantTarget
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|GotoLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Target
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IndirectGotoStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Target
argument_list|,
operator|&
name|Target
operator|+
literal|1
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ContinueStmt - This represents a continue.
comment|///
name|class
name|ContinueStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|ContinueLoc
block|;
name|public
operator|:
name|ContinueStmt
argument_list|(
argument|SourceLocation CL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ContinueStmtClass
argument_list|)
block|,
name|ContinueLoc
argument_list|(
argument|CL
argument_list|)
block|{}
comment|/// \brief Build an empty continue statement.
name|explicit
name|ContinueStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ContinueStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getContinueLoc
argument_list|()
specifier|const
block|{
return|return
name|ContinueLoc
return|;
block|}
name|void
name|setContinueLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ContinueLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ContinueLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ContinueLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ContinueStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// BreakStmt - This represents a break.
comment|///
name|class
name|BreakStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|BreakLoc
block|;
name|public
operator|:
name|BreakStmt
argument_list|(
argument|SourceLocation BL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|BreakStmtClass
argument_list|)
block|,
name|BreakLoc
argument_list|(
argument|BL
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|BreakStmt
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|SourceLocation
argument_list|)
argument_list|,
literal|"BreakStmt too large"
argument_list|)
block|;   }
comment|/// \brief Build an empty break statement.
name|explicit
name|BreakStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|BreakStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getBreakLoc
argument_list|()
specifier|const
block|{
return|return
name|BreakLoc
return|;
block|}
name|void
name|setBreakLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|BreakLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|BreakLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|BreakLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|BreakStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// ReturnStmt - This represents a return, optionally of an expression:
comment|///   return;
comment|///   return 4;
comment|///
comment|/// Note that GCC allows return with no argument in a function declared to
comment|/// return a value, and it allows returning a value in functions declared to
comment|/// return void.  We explicitly model this in the AST, which means you can't
comment|/// depend on the return type of the function and the presence of an argument.
comment|///
name|class
name|ReturnStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|RetLoc
block|;
name|Stmt
operator|*
name|RetExpr
block|;
specifier|const
name|VarDecl
operator|*
name|NRVOCandidate
block|;
name|public
operator|:
name|explicit
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|)
operator|:
name|ReturnStmt
argument_list|(
argument|RL
argument_list|,
argument|nullptr
argument_list|,
argument|nullptr
argument_list|)
block|{}
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|,
argument|Expr *E
argument_list|,
argument|const VarDecl *NRVOCandidate
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ReturnStmtClass
argument_list|)
block|,
name|RetLoc
argument_list|(
name|RL
argument_list|)
block|,
name|RetExpr
argument_list|(
operator|(
name|Stmt
operator|*
operator|)
name|E
argument_list|)
block|,
name|NRVOCandidate
argument_list|(
argument|NRVOCandidate
argument_list|)
block|{}
comment|/// \brief Build an empty return expression.
name|explicit
name|ReturnStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ReturnStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
specifier|const
name|Expr
operator|*
name|getRetValue
argument_list|()
specifier|const
block|;
name|Expr
operator|*
name|getRetValue
argument_list|()
block|;
name|void
name|setRetValue
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|RetExpr
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|SourceLocation
name|getReturnLoc
argument_list|()
specifier|const
block|{
return|return
name|RetLoc
return|;
block|}
name|void
name|setReturnLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RetLoc
operator|=
name|L
block|; }
comment|/// \brief Retrieve the variable that might be used for the named return
comment|/// value optimization.
comment|///
comment|/// The optimization itself can only be performed if the variable is
comment|/// also marked as an NRVO object.
specifier|const
name|VarDecl
operator|*
name|getNRVOCandidate
argument_list|()
specifier|const
block|{
return|return
name|NRVOCandidate
return|;
block|}
name|void
name|setNRVOCandidate
argument_list|(
argument|const VarDecl *Var
argument_list|)
block|{
name|NRVOCandidate
operator|=
name|Var
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|RetLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|RetExpr
condition|?
name|RetExpr
operator|->
name|getLocEnd
argument_list|()
else|:
name|RetLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ReturnStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
if|if
condition|(
name|RetExpr
condition|)
return|return
name|child_range
argument_list|(
operator|&
name|RetExpr
argument_list|,
operator|&
name|RetExpr
operator|+
literal|1
argument_list|)
return|;
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// AsmStmt is the base class for GCCAsmStmt and MSAsmStmt.
comment|///
name|class
name|AsmStmt
operator|:
name|public
name|Stmt
block|{
name|protected
operator|:
name|SourceLocation
name|AsmLoc
block|;
comment|/// \brief True if the assembly statement does not have any input or output
comment|/// operands.
name|bool
name|IsSimple
block|;
comment|/// \brief If true, treat this inline assembly as having side effects.
comment|/// This assembly statement should not be optimized, deleted or moved.
name|bool
name|IsVolatile
block|;
name|unsigned
name|NumOutputs
block|;
name|unsigned
name|NumInputs
block|;
name|unsigned
name|NumClobbers
block|;
name|Stmt
operator|*
operator|*
name|Exprs
block|;
name|AsmStmt
argument_list|(
argument|StmtClass SC
argument_list|,
argument|SourceLocation asmloc
argument_list|,
argument|bool issimple
argument_list|,
argument|bool isvolatile
argument_list|,
argument|unsigned numoutputs
argument_list|,
argument|unsigned numinputs
argument_list|,
argument|unsigned numclobbers
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|)
block|,
name|AsmLoc
argument_list|(
name|asmloc
argument_list|)
block|,
name|IsSimple
argument_list|(
name|issimple
argument_list|)
block|,
name|IsVolatile
argument_list|(
name|isvolatile
argument_list|)
block|,
name|NumOutputs
argument_list|(
name|numoutputs
argument_list|)
block|,
name|NumInputs
argument_list|(
name|numinputs
argument_list|)
block|,
name|NumClobbers
argument_list|(
argument|numclobbers
argument_list|)
block|{ }
name|friend
name|class
name|ASTStmtReader
block|;
name|public
operator|:
comment|/// \brief Build an empty inline-assembly statement.
name|explicit
name|AsmStmt
argument_list|(
argument|StmtClass SC
argument_list|,
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|,
name|Empty
argument_list|)
block|,
name|Exprs
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SourceLocation
name|getAsmLoc
argument_list|()
specifier|const
block|{
return|return
name|AsmLoc
return|;
block|}
name|void
name|setAsmLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|AsmLoc
operator|=
name|L
block|; }
name|bool
name|isSimple
argument_list|()
specifier|const
block|{
return|return
name|IsSimple
return|;
block|}
name|void
name|setSimple
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsSimple
operator|=
name|V
block|; }
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|IsVolatile
return|;
block|}
name|void
name|setVolatile
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsVolatile
operator|=
name|V
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SourceLocation
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|SourceLocation
argument_list|()
return|;
block|}
comment|//===--- Asm String Analysis ---===//
comment|/// Assemble final IR asm string.
name|std
operator|::
name|string
name|generateAsmString
argument_list|(
argument|const ASTContext&C
argument_list|)
specifier|const
block|;
comment|//===--- Output operands ---===//
name|unsigned
name|getNumOutputs
argument_list|()
specifier|const
block|{
return|return
name|NumOutputs
return|;
block|}
comment|/// getOutputConstraint - Return the constraint string for the specified
comment|/// output operand.  All output constraints are known to be non-empty (either
comment|/// '=' or '+').
name|StringRef
name|getOutputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
comment|/// isOutputPlusConstraint - Return true if the specified output constraint
comment|/// is a "+" constraint (which is both an input and an output) or false if it
comment|/// is an "=" constraint (just an output).
name|bool
name|isOutputPlusConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getOutputConstraint
argument_list|(
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'+'
return|;
block|}
specifier|const
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
comment|/// getNumPlusOperands - Return the number of output operands that have a "+"
comment|/// constraint.
name|unsigned
name|getNumPlusOperands
argument_list|()
specifier|const
block|;
comment|//===--- Input operands ---===//
name|unsigned
name|getNumInputs
argument_list|()
specifier|const
block|{
return|return
name|NumInputs
return|;
block|}
comment|/// getInputConstraint - Return the specified input constraint.  Unlike output
comment|/// constraints, these can be empty.
name|StringRef
name|getInputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
comment|//===--- Other ---===//
name|unsigned
name|getNumClobbers
argument_list|()
specifier|const
block|{
return|return
name|NumClobbers
return|;
block|}
name|StringRef
name|getClobber
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|GCCAsmStmtClass
operator|||
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|MSAsmStmtClass
return|;
block|}
comment|// Input expr iterators.
typedef|typedef
name|ExprIterator
name|inputs_iterator
typedef|;
typedef|typedef
name|ConstExprIterator
name|const_inputs_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|inputs_iterator
operator|>
name|inputs_range
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_inputs_iterator
operator|>
name|inputs_const_range
expr_stmt|;
name|inputs_iterator
name|begin_inputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|inputs_iterator
name|end_inputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
name|inputs_range
name|inputs
argument_list|()
block|{
return|return
name|inputs_range
argument_list|(
name|begin_inputs
argument_list|()
argument_list|,
name|end_inputs
argument_list|()
argument_list|)
return|;
block|}
name|const_inputs_iterator
name|begin_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|const_inputs_iterator
name|end_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
name|inputs_const_range
name|inputs
argument_list|()
specifier|const
block|{
return|return
name|inputs_const_range
argument_list|(
name|begin_inputs
argument_list|()
argument_list|,
name|end_inputs
argument_list|()
argument_list|)
return|;
block|}
comment|// Output expr iterators.
typedef|typedef
name|ExprIterator
name|outputs_iterator
typedef|;
typedef|typedef
name|ConstExprIterator
name|const_outputs_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|outputs_iterator
operator|>
name|outputs_range
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_outputs_iterator
operator|>
name|outputs_const_range
expr_stmt|;
name|outputs_iterator
name|begin_outputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
name|outputs_iterator
name|end_outputs
argument_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|outputs_range
name|outputs
argument_list|()
block|{
return|return
name|outputs_range
argument_list|(
name|begin_outputs
argument_list|()
argument_list|,
name|end_outputs
argument_list|()
argument_list|)
return|;
block|}
name|const_outputs_iterator
name|begin_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
name|const_outputs_iterator
name|end_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
name|outputs_const_range
name|outputs
argument_list|()
specifier|const
block|{
return|return
name|outputs_const_range
argument_list|(
name|begin_outputs
argument_list|()
argument_list|,
name|end_outputs
argument_list|()
argument_list|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Exprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// This represents a GCC inline-assembly statement extension.
comment|///
name|class
name|GCCAsmStmt
operator|:
name|public
name|AsmStmt
block|{
name|SourceLocation
name|RParenLoc
block|;
name|StringLiteral
operator|*
name|AsmStr
block|;
comment|// FIXME: If we wanted to, we could allocate all of these in one big array.
name|StringLiteral
operator|*
operator|*
name|Constraints
block|;
name|StringLiteral
operator|*
operator|*
name|Clobbers
block|;
name|IdentifierInfo
operator|*
operator|*
name|Names
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|public
operator|:
name|GCCAsmStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation asmloc
argument_list|,
argument|bool issimple
argument_list|,
argument|bool isvolatile
argument_list|,
argument|unsigned numoutputs
argument_list|,
argument|unsigned numinputs
argument_list|,
argument|IdentifierInfo **names
argument_list|,
argument|StringLiteral **constraints
argument_list|,
argument|Expr **exprs
argument_list|,
argument|StringLiteral *asmstr
argument_list|,
argument|unsigned numclobbers
argument_list|,
argument|StringLiteral **clobbers
argument_list|,
argument|SourceLocation rparenloc
argument_list|)
block|;
comment|/// \brief Build an empty inline-assembly statement.
name|explicit
name|GCCAsmStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|AsmStmt
argument_list|(
name|GCCAsmStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|Constraints
argument_list|(
name|nullptr
argument_list|)
block|,
name|Clobbers
argument_list|(
name|nullptr
argument_list|)
block|,
name|Names
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
comment|//===--- Asm String Analysis ---===//
specifier|const
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
specifier|const
block|{
return|return
name|AsmStr
return|;
block|}
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
block|{
return|return
name|AsmStr
return|;
block|}
name|void
name|setAsmString
argument_list|(
argument|StringLiteral *E
argument_list|)
block|{
name|AsmStr
operator|=
name|E
block|; }
comment|/// AsmStringPiece - this is part of a decomposed asm string specification
comment|/// (for use with the AnalyzeAsmString function below).  An asm string is
comment|/// considered to be a concatenation of these parts.
name|class
name|AsmStringPiece
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|String
block|,
comment|// String in .ll asm string form, "$" -> "$$" and "%%" -> "%".
name|Operand
comment|// Operand reference, with optional modifier %c4.
block|}
block|;
name|private
operator|:
name|Kind
name|MyKind
block|;
name|std
operator|::
name|string
name|Str
block|;
name|unsigned
name|OperandNo
block|;
comment|// Source range for operand references.
name|CharSourceRange
name|Range
block|;
name|public
operator|:
name|AsmStringPiece
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|S
argument_list|)
operator|:
name|MyKind
argument_list|(
name|String
argument_list|)
block|,
name|Str
argument_list|(
argument|S
argument_list|)
block|{}
name|AsmStringPiece
argument_list|(
argument|unsigned OpNo
argument_list|,
argument|const std::string&S
argument_list|,
argument|SourceLocation Begin
argument_list|,
argument|SourceLocation End
argument_list|)
operator|:
name|MyKind
argument_list|(
name|Operand
argument_list|)
block|,
name|Str
argument_list|(
name|S
argument_list|)
block|,
name|OperandNo
argument_list|(
name|OpNo
argument_list|)
block|,
name|Range
argument_list|(
argument|CharSourceRange::getCharRange(Begin, End)
argument_list|)
block|{     }
name|bool
name|isString
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|String
return|;
block|}
name|bool
name|isOperand
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|Operand
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getString
argument_list|()
specifier|const
block|{
return|return
name|Str
return|;
block|}
name|unsigned
name|getOperandNo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
argument_list|)
block|;
return|return
name|OperandNo
return|;
block|}
name|CharSourceRange
name|getRange
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
operator|&&
literal|"Range is currently used only for Operands."
argument_list|)
block|;
return|return
name|Range
return|;
block|}
comment|/// getModifier - Get the modifier for this operand, if present.  This
comment|/// returns '\0' if there was no modifier.
name|char
name|getModifier
argument_list|()
specifier|const
block|;   }
block|;
comment|/// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing
comment|/// it into pieces.  If the asm string is erroneous, emit errors and return
comment|/// true, otherwise return false.  This handles canonicalization and
comment|/// translation of strings from GCC syntax to LLVM IR syntax, and handles
comment|//// flattening of named references like %[foo] to Operand AsmStringPiece's.
name|unsigned
name|AnalyzeAsmString
argument_list|(
argument|SmallVectorImpl<AsmStringPiece>&Pieces
argument_list|,
argument|const ASTContext&C
argument_list|,
argument|unsigned&DiagOffs
argument_list|)
specifier|const
block|;
comment|/// Assemble final IR asm string.
name|std
operator|::
name|string
name|generateAsmString
argument_list|(
argument|const ASTContext&C
argument_list|)
specifier|const
block|;
comment|//===--- Output operands ---===//
name|IdentifierInfo
operator|*
name|getOutputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
index|]
return|;
block|}
name|StringRef
name|getOutputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getOutputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
name|StringRef
name|getOutputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|GCCAsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getOutputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|//===--- Input operands ---===//
name|IdentifierInfo
operator|*
name|getInputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|StringRef
name|getInputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getInputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|StringRef
argument_list|()
return|;
block|}
name|StringRef
name|getInputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|StringLiteral
operator|*
name|getInputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|StringLiteral
operator|*
name|getInputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
name|void
name|setInputExpr
argument_list|(
argument|unsigned i
argument_list|,
argument|Expr *E
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|GCCAsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getInputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
name|private
operator|:
name|void
name|setOutputsAndInputsAndClobbers
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|IdentifierInfo **Names
argument_list|,
argument|StringLiteral **Constraints
argument_list|,
argument|Stmt **Exprs
argument_list|,
argument|unsigned NumOutputs
argument_list|,
argument|unsigned NumInputs
argument_list|,
argument|StringLiteral **Clobbers
argument_list|,
argument|unsigned NumClobbers
argument_list|)
block|;
name|public
operator|:
comment|//===--- Other ---===//
comment|/// getNamedOperand - Given a symbolic operand reference like %[foo],
comment|/// translate this into a numeric value needed to reference the same operand.
comment|/// This returns -1 if the operand name is invalid.
name|int
name|getNamedOperand
argument_list|(
argument|StringRef SymbolicName
argument_list|)
specifier|const
block|;
name|StringRef
name|getClobber
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
name|StringLiteral
operator|*
name|getClobberStringLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
specifier|const
name|StringLiteral
operator|*
name|getClobberStringLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|AsmLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|RParenLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|GCCAsmStmtClass
return|;
block|}
expr|}
block|;
comment|/// This represents a Microsoft inline-assembly statement extension.
comment|///
name|class
name|MSAsmStmt
operator|:
name|public
name|AsmStmt
block|{
name|SourceLocation
name|LBraceLoc
block|,
name|EndLoc
block|;
name|StringRef
name|AsmStr
block|;
name|unsigned
name|NumAsmToks
block|;
name|Token
operator|*
name|AsmToks
block|;
name|StringRef
operator|*
name|Constraints
block|;
name|StringRef
operator|*
name|Clobbers
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|public
operator|:
name|MSAsmStmt
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation asmloc
argument_list|,
argument|SourceLocation lbraceloc
argument_list|,
argument|bool issimple
argument_list|,
argument|bool isvolatile
argument_list|,
argument|ArrayRef<Token> asmtoks
argument_list|,
argument|unsigned numoutputs
argument_list|,
argument|unsigned numinputs
argument_list|,
argument|ArrayRef<StringRef> constraints
argument_list|,
argument|ArrayRef<Expr*> exprs
argument_list|,
argument|StringRef asmstr
argument_list|,
argument|ArrayRef<StringRef> clobbers
argument_list|,
argument|SourceLocation endloc
argument_list|)
block|;
comment|/// \brief Build an empty MS-style inline-assembly statement.
name|explicit
name|MSAsmStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|AsmStmt
argument_list|(
name|MSAsmStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|NumAsmToks
argument_list|(
literal|0
argument_list|)
block|,
name|AsmToks
argument_list|(
name|nullptr
argument_list|)
block|,
name|Constraints
argument_list|(
name|nullptr
argument_list|)
block|,
name|Clobbers
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|SourceLocation
name|getLBraceLoc
argument_list|()
specifier|const
block|{
return|return
name|LBraceLoc
return|;
block|}
name|void
name|setLBraceLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LBraceLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|EndLoc
return|;
block|}
name|void
name|setEndLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EndLoc
operator|=
name|L
block|; }
name|bool
name|hasBraces
argument_list|()
specifier|const
block|{
return|return
name|LBraceLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
name|unsigned
name|getNumAsmToks
argument_list|()
block|{
return|return
name|NumAsmToks
return|;
block|}
name|Token
operator|*
name|getAsmToks
argument_list|()
block|{
return|return
name|AsmToks
return|;
block|}
comment|//===--- Asm String Analysis ---===//
name|StringRef
name|getAsmString
argument_list|()
specifier|const
block|{
return|return
name|AsmStr
return|;
block|}
comment|/// Assemble final IR asm string.
name|std
operator|::
name|string
name|generateAsmString
argument_list|(
argument|const ASTContext&C
argument_list|)
specifier|const
block|;
comment|//===--- Output operands ---===//
name|StringRef
name|getOutputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumOutputs
argument_list|)
block|;
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MSAsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getOutputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|//===--- Input operands ---===//
name|StringRef
name|getInputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|NumInputs
argument_list|)
block|;
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
name|void
name|setInputExpr
argument_list|(
argument|unsigned i
argument_list|,
argument|Expr *E
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getInputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|MSAsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getInputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|//===--- Other ---===//
name|ArrayRef
operator|<
name|StringRef
operator|>
name|getAllConstraints
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|Constraints
argument_list|,
name|NumInputs
operator|+
name|NumOutputs
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|StringRef
operator|>
name|getClobbers
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|Clobbers
argument_list|,
name|NumClobbers
argument_list|)
return|;
block|}
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|getAllExprs
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|*
operator|>
operator|(
name|Exprs
operator|)
argument_list|,
name|NumInputs
operator|+
name|NumOutputs
argument_list|)
return|;
block|}
name|StringRef
name|getClobber
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getClobbers
argument_list|()
index|[
name|i
index|]
return|;
block|}
name|private
operator|:
name|void
name|initialize
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|StringRef AsmString
argument_list|,
argument|ArrayRef<Token> AsmToks
argument_list|,
argument|ArrayRef<StringRef> Constraints
argument_list|,
argument|ArrayRef<Expr*> Exprs
argument_list|,
argument|ArrayRef<StringRef> Clobbers
argument_list|)
block|;
name|public
operator|:
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|AsmLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|EndLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|MSAsmStmtClass
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Exprs
index|[
literal|0
index|]
argument_list|,
operator|&
name|Exprs
index|[
name|NumInputs
operator|+
name|NumOutputs
index|]
argument_list|)
return|;
block|}
expr|}
block|;
name|class
name|SEHExceptStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|Loc
block|;
name|Stmt
operator|*
name|Children
index|[
literal|2
index|]
block|;    enum
block|{
name|FILTER_EXPR
block|,
name|BLOCK
block|}
block|;
name|SEHExceptStmt
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Expr *FilterExpr
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|friend
name|class
name|ASTReader
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|explicit
name|SEHExceptStmt
argument_list|(
argument|EmptyShell E
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SEHExceptStmtClass
argument_list|,
argument|E
argument_list|)
block|{ }
name|public
operator|:
specifier|static
name|SEHExceptStmt
operator|*
name|Create
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation ExceptLoc
argument_list|,
argument|Expr *FilterExpr
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getExceptLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getEndLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getExceptLoc
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|getBlock
argument_list|()
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|Expr
operator|*
name|getFilterExpr
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Children
index|[
name|FILTER_EXPR
index|]
operator|)
return|;
block|}
name|CompoundStmt
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Children
index|[
name|BLOCK
index|]
operator|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|Children
argument_list|,
name|Children
operator|+
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHExceptStmtClass
return|;
block|}
expr|}
block|;
name|class
name|SEHFinallyStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|Loc
block|;
name|Stmt
operator|*
name|Block
block|;
name|SEHFinallyStmt
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|friend
name|class
name|ASTReader
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|explicit
name|SEHFinallyStmt
argument_list|(
argument|EmptyShell E
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SEHFinallyStmtClass
argument_list|,
argument|E
argument_list|)
block|{ }
name|public
operator|:
specifier|static
name|SEHFinallyStmt
operator|*
name|Create
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|SourceLocation FinallyLoc
argument_list|,
argument|Stmt *Block
argument_list|)
block|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getFinallyLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getEndLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getFinallyLoc
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Block
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|CompoundStmt
operator|*
name|getBlock
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Block
operator|)
return|;
block|}
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
operator|&
name|Block
argument_list|,
operator|&
name|Block
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHFinallyStmtClass
return|;
block|}
expr|}
block|;
name|class
name|SEHTryStmt
operator|:
name|public
name|Stmt
block|{
name|bool
name|IsCXXTry
block|;
name|SourceLocation
name|TryLoc
block|;
name|Stmt
operator|*
name|Children
index|[
literal|2
index|]
block|;    enum
block|{
name|TRY
operator|=
literal|0
block|,
name|HANDLER
operator|=
literal|1
block|}
block|;
name|SEHTryStmt
argument_list|(
argument|bool isCXXTry
argument_list|,
comment|// true if 'try' otherwise '__try'
argument|SourceLocation TryLoc
argument_list|,
argument|Stmt *TryBlock
argument_list|,
argument|Stmt *Handler
argument_list|)
block|;
name|friend
name|class
name|ASTReader
block|;
name|friend
name|class
name|ASTStmtReader
block|;
name|explicit
name|SEHTryStmt
argument_list|(
argument|EmptyShell E
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SEHTryStmtClass
argument_list|,
argument|E
argument_list|)
block|{ }
name|public
operator|:
specifier|static
name|SEHTryStmt
operator|*
name|Create
argument_list|(
argument|const ASTContext&C
argument_list|,
argument|bool isCXXTry
argument_list|,
argument|SourceLocation TryLoc
argument_list|,
argument|Stmt *TryBlock
argument_list|,
argument|Stmt *Handler
argument_list|)
block|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getTryLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getEndLoc
argument_list|()
return|;
block|}
name|SourceLocation
name|getTryLoc
argument_list|()
specifier|const
block|{
return|return
name|TryLoc
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Children
index|[
name|HANDLER
index|]
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|bool
name|getIsCXXTry
argument_list|()
specifier|const
block|{
return|return
name|IsCXXTry
return|;
block|}
name|CompoundStmt
operator|*
name|getTryBlock
argument_list|()
specifier|const
block|{
return|return
name|cast
operator|<
name|CompoundStmt
operator|>
operator|(
name|Children
index|[
name|TRY
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getHandler
argument_list|()
specifier|const
block|{
return|return
name|Children
index|[
name|HANDLER
index|]
return|;
block|}
comment|/// Returns 0 if not defined
name|SEHExceptStmt
operator|*
name|getExceptHandler
argument_list|()
specifier|const
block|;
name|SEHFinallyStmt
operator|*
name|getFinallyHandler
argument_list|()
specifier|const
block|;
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|Children
argument_list|,
name|Children
operator|+
literal|2
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHTryStmtClass
return|;
block|}
expr|}
block|;
comment|/// Represents a __leave statement.
comment|///
name|class
name|SEHLeaveStmt
operator|:
name|public
name|Stmt
block|{
name|SourceLocation
name|LeaveLoc
block|;
name|public
operator|:
name|explicit
name|SEHLeaveStmt
argument_list|(
argument|SourceLocation LL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SEHLeaveStmtClass
argument_list|)
block|,
name|LeaveLoc
argument_list|(
argument|LL
argument_list|)
block|{}
comment|/// \brief Build an empty __leave statement.
name|explicit
name|SEHLeaveStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SEHLeaveStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getLeaveLoc
argument_list|()
specifier|const
block|{
return|return
name|LeaveLoc
return|;
block|}
name|void
name|setLeaveLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LeaveLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|LeaveLoc
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|LeaveLoc
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SEHLeaveStmtClass
return|;
block|}
comment|// Iterators
name|child_range
name|children
argument_list|()
block|{
return|return
name|child_range
argument_list|(
name|child_iterator
argument_list|()
argument_list|,
name|child_iterator
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// \brief This captures a statement into a function. For example, the following
comment|/// pragma annotated compound statement can be represented as a CapturedStmt,
comment|/// and this compound statement is the body of an anonymous outlined function.
comment|/// @code
comment|/// #pragma omp parallel
comment|/// {
comment|///   compute();
comment|/// }
comment|/// @endcode
name|class
name|CapturedStmt
operator|:
name|public
name|Stmt
block|{
name|public
operator|:
comment|/// \brief The different capture forms: by 'this', by reference, capture for
comment|/// variable-length array type etc.
expr|enum
name|VariableCaptureKind
block|{
name|VCK_This
block|,
name|VCK_ByRef
block|,
name|VCK_ByCopy
block|,
name|VCK_VLAType
block|,   }
block|;
comment|/// \brief Describes the capture of either a variable, or 'this', or
comment|/// variable-length array type.
name|class
name|Capture
block|{
name|llvm
operator|::
name|PointerIntPair
operator|<
name|VarDecl
operator|*
block|,
literal|2
block|,
name|VariableCaptureKind
operator|>
name|VarAndKind
block|;
name|SourceLocation
name|Loc
block|;
name|public
operator|:
comment|/// \brief Create a new capture.
comment|///
comment|/// \param Loc The source location associated with this capture.
comment|///
comment|/// \param Kind The kind of capture (this, ByRef, ...).
comment|///
comment|/// \param Var The variable being captured, or null if capturing this.
comment|///
name|Capture
argument_list|(
argument|SourceLocation Loc
argument_list|,
argument|VariableCaptureKind Kind
argument_list|,
argument|VarDecl *Var = nullptr
argument_list|)
block|;
comment|/// \brief Determine the kind of capture.
name|VariableCaptureKind
name|getCaptureKind
argument_list|()
specifier|const
block|;
comment|/// \brief Retrieve the source location at which the variable or 'this' was
comment|/// first used.
name|SourceLocation
name|getLocation
argument_list|()
specifier|const
block|{
return|return
name|Loc
return|;
block|}
comment|/// \brief Determine whether this capture handles the C++ 'this' pointer.
name|bool
name|capturesThis
argument_list|()
specifier|const
block|{
return|return
name|getCaptureKind
argument_list|()
operator|==
name|VCK_This
return|;
block|}
comment|/// \brief Determine whether this capture handles a variable (by reference).
name|bool
name|capturesVariable
argument_list|()
specifier|const
block|{
return|return
name|getCaptureKind
argument_list|()
operator|==
name|VCK_ByRef
return|;
block|}
comment|/// \brief Determine whether this capture handles a variable by copy.
name|bool
name|capturesVariableByCopy
argument_list|()
specifier|const
block|{
return|return
name|getCaptureKind
argument_list|()
operator|==
name|VCK_ByCopy
return|;
block|}
comment|/// \brief Determine whether this capture handles a variable-length array
comment|/// type.
name|bool
name|capturesVariableArrayType
argument_list|()
specifier|const
block|{
return|return
name|getCaptureKind
argument_list|()
operator|==
name|VCK_VLAType
return|;
block|}
comment|/// \brief Retrieve the declaration of the variable being captured.
comment|///
comment|/// This operation is only valid if this capture captures a variable.
name|VarDecl
operator|*
name|getCapturedVar
argument_list|()
specifier|const
block|;
name|friend
name|class
name|ASTStmtReader
block|;   }
block|;
name|private
operator|:
comment|/// \brief The number of variable captured, including 'this'.
name|unsigned
name|NumCaptures
block|;
comment|/// \brief The pointer part is the implicit the outlined function and the
comment|/// int part is the captured region kind, 'CR_Default' etc.
name|llvm
operator|::
name|PointerIntPair
operator|<
name|CapturedDecl
operator|*
block|,
literal|1
block|,
name|CapturedRegionKind
operator|>
name|CapDeclAndKind
block|;
comment|/// \brief The record for captured variables, a RecordDecl or CXXRecordDecl.
name|RecordDecl
operator|*
name|TheRecordDecl
block|;
comment|/// \brief Construct a captured statement.
name|CapturedStmt
argument_list|(
argument|Stmt *S
argument_list|,
argument|CapturedRegionKind Kind
argument_list|,
argument|ArrayRef<Capture> Captures
argument_list|,
argument|ArrayRef<Expr *> CaptureInits
argument_list|,
argument|CapturedDecl *CD
argument_list|,
argument|RecordDecl *RD
argument_list|)
block|;
comment|/// \brief Construct an empty captured statement.
name|CapturedStmt
argument_list|(
argument|EmptyShell Empty
argument_list|,
argument|unsigned NumCaptures
argument_list|)
block|;
name|Stmt
operator|*
operator|*
name|getStoredStmts
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|Stmt
operator|*
specifier|const
operator|*
name|getStoredStmts
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Stmt
operator|*
specifier|const
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|Capture
operator|*
name|getStoredCaptures
argument_list|()
specifier|const
block|;
name|void
name|setCapturedStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|getStoredStmts
argument_list|()
index|[
name|NumCaptures
index|]
operator|=
name|S
block|; }
name|public
operator|:
specifier|static
name|CapturedStmt
operator|*
name|Create
argument_list|(
argument|const ASTContext&Context
argument_list|,
argument|Stmt *S
argument_list|,
argument|CapturedRegionKind Kind
argument_list|,
argument|ArrayRef<Capture> Captures
argument_list|,
argument|ArrayRef<Expr *> CaptureInits
argument_list|,
argument|CapturedDecl *CD
argument_list|,
argument|RecordDecl *RD
argument_list|)
block|;
specifier|static
name|CapturedStmt
operator|*
name|CreateDeserialized
argument_list|(
argument|const ASTContext&Context
argument_list|,
argument|unsigned NumCaptures
argument_list|)
block|;
comment|/// \brief Retrieve the statement being captured.
name|Stmt
operator|*
name|getCapturedStmt
argument_list|()
block|{
return|return
name|getStoredStmts
argument_list|()
index|[
name|NumCaptures
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getCapturedStmt
argument_list|()
specifier|const
block|{
return|return
name|getStoredStmts
argument_list|()
index|[
name|NumCaptures
index|]
return|;
block|}
comment|/// \brief Retrieve the outlined function declaration.
name|CapturedDecl
operator|*
name|getCapturedDecl
argument_list|()
block|;
specifier|const
name|CapturedDecl
operator|*
name|getCapturedDecl
argument_list|()
specifier|const
block|;
comment|/// \brief Set the outlined function declaration.
name|void
name|setCapturedDecl
argument_list|(
name|CapturedDecl
operator|*
name|D
argument_list|)
block|;
comment|/// \brief Retrieve the captured region kind.
name|CapturedRegionKind
name|getCapturedRegionKind
argument_list|()
specifier|const
block|;
comment|/// \brief Set the captured region kind.
name|void
name|setCapturedRegionKind
argument_list|(
argument|CapturedRegionKind Kind
argument_list|)
block|;
comment|/// \brief Retrieve the record declaration for captured variables.
specifier|const
name|RecordDecl
operator|*
name|getCapturedRecordDecl
argument_list|()
specifier|const
block|{
return|return
name|TheRecordDecl
return|;
block|}
comment|/// \brief Set the record declaration for captured variables.
name|void
name|setCapturedRecordDecl
argument_list|(
argument|RecordDecl *D
argument_list|)
block|{
name|assert
argument_list|(
name|D
operator|&&
literal|"null RecordDecl"
argument_list|)
block|;
name|TheRecordDecl
operator|=
name|D
block|;   }
comment|/// \brief True if this variable has been captured.
name|bool
name|capturesVariable
argument_list|(
argument|const VarDecl *Var
argument_list|)
specifier|const
block|;
comment|/// \brief An iterator that walks over the captures.
typedef|typedef
name|Capture
modifier|*
name|capture_iterator
typedef|;
typedef|typedef
specifier|const
name|Capture
modifier|*
name|const_capture_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|capture_iterator
operator|>
name|capture_range
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_capture_iterator
operator|>
name|capture_const_range
expr_stmt|;
name|capture_range
name|captures
argument_list|()
block|{
return|return
name|capture_range
argument_list|(
name|capture_begin
argument_list|()
argument_list|,
name|capture_end
argument_list|()
argument_list|)
return|;
block|}
name|capture_const_range
name|captures
argument_list|()
specifier|const
block|{
return|return
name|capture_const_range
argument_list|(
name|capture_begin
argument_list|()
argument_list|,
name|capture_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Retrieve an iterator pointing to the first capture.
name|capture_iterator
name|capture_begin
argument_list|()
block|{
return|return
name|getStoredCaptures
argument_list|()
return|;
block|}
name|const_capture_iterator
name|capture_begin
argument_list|()
specifier|const
block|{
return|return
name|getStoredCaptures
argument_list|()
return|;
block|}
comment|/// \brief Retrieve an iterator pointing past the end of the sequence of
comment|/// captures.
name|capture_iterator
name|capture_end
argument_list|()
specifier|const
block|{
return|return
name|getStoredCaptures
argument_list|()
operator|+
name|NumCaptures
return|;
block|}
comment|/// \brief Retrieve the number of captures, including 'this'.
name|unsigned
name|capture_size
argument_list|()
specifier|const
block|{
return|return
name|NumCaptures
return|;
block|}
comment|/// \brief Iterator that walks over the capture initialization arguments.
typedef|typedef
name|Expr
modifier|*
modifier|*
name|capture_init_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|capture_init_iterator
operator|>
name|capture_init_range
expr_stmt|;
comment|/// \brief Const iterator that walks over the capture initialization
comment|/// arguments.
typedef|typedef
name|Expr
modifier|*
specifier|const
modifier|*
name|const_capture_init_iterator
typedef|;
typedef|typedef
name|llvm
operator|::
name|iterator_range
operator|<
name|const_capture_init_iterator
operator|>
name|const_capture_init_range
expr_stmt|;
name|capture_init_range
name|capture_inits
argument_list|()
block|{
return|return
name|capture_init_range
argument_list|(
name|capture_init_begin
argument_list|()
argument_list|,
name|capture_init_end
argument_list|()
argument_list|)
return|;
block|}
name|const_capture_init_range
name|capture_inits
argument_list|()
specifier|const
block|{
return|return
name|const_capture_init_range
argument_list|(
name|capture_init_begin
argument_list|()
argument_list|,
name|capture_init_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the first initialization argument.
name|capture_init_iterator
name|capture_init_begin
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|*
operator|>
operator|(
name|getStoredStmts
argument_list|()
operator|)
return|;
block|}
name|const_capture_init_iterator
name|capture_init_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
specifier|const
operator|*
operator|>
operator|(
name|getStoredStmts
argument_list|()
operator|)
return|;
block|}
comment|/// \brief Retrieve the iterator pointing one past the last initialization
comment|/// argument.
name|capture_init_iterator
name|capture_init_end
argument_list|()
block|{
return|return
name|capture_init_begin
argument_list|()
operator|+
name|NumCaptures
return|;
block|}
name|const_capture_init_iterator
name|capture_init_end
argument_list|()
specifier|const
block|{
return|return
name|capture_init_begin
argument_list|()
operator|+
name|NumCaptures
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getCapturedStmt
argument_list|()
operator|->
name|getLocStart
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getCapturedStmt
argument_list|()
operator|->
name|getLocEnd
argument_list|()
return|;
block|}
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|getCapturedStmt
argument_list|()
operator|->
name|getSourceRange
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CapturedStmtClass
return|;
block|}
name|child_range
name|children
argument_list|()
block|;
name|friend
name|class
name|ASTStmtReader
block|; }
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

