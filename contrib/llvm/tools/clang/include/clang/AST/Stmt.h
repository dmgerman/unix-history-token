begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Stmt.h - Classes for representing statements -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Stmt interface and subclasses.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_STMT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_STMT_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/PrettyPrinter.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtIterator.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclGroup.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/FullExpr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_expr_stmt
name|using
name|llvm
operator|::
name|dyn_cast_or_null
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|FoldingSetNodeID
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|Decl
decl_stmt|;
name|class
name|ParmVarDecl
decl_stmt|;
name|class
name|QualType
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
name|class
name|StringLiteral
decl_stmt|;
name|class
name|SwitchStmt
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|// ExprIterator - Iterators for iterating over Stmt* arrays that contain
comment|//  only Expr*.  This is needed because AST nodes use Stmt* arrays to store
comment|//  references to children (to be compatible with StmtIterator).
comment|//===----------------------------------------------------------------------===//
name|class
name|Stmt
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|ExprIterator
block|{
name|Stmt
modifier|*
modifier|*
name|I
decl_stmt|;
name|public
label|:
name|ExprIterator
argument_list|(
name|Stmt
operator|*
operator|*
name|i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|ExprIterator
argument_list|()
operator|:
name|I
argument_list|(
literal|0
argument_list|)
block|{}
name|ExprIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|ExprIterator
name|operator
operator|-
operator|(
name|size_t
name|i
operator|)
block|{
return|return
name|I
operator|-
name|i
return|;
block|}
name|ExprIterator
name|operator
operator|+
operator|(
name|size_t
name|i
operator|)
block|{
return|return
name|I
operator|+
name|i
return|;
block|}
name|Expr
modifier|*
name|operator
function_decl|[]
parameter_list|(
name|size_t
name|idx
parameter_list|)
function_decl|;
comment|// FIXME: Verify that this will correctly return a signed distance.
name|signed
name|operator
operator|-
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|R
operator|.
name|I
return|;
block|}
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
expr_stmt|;
name|Expr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|>
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>
name|R
operator|.
name|I
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|ExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>=
name|R
operator|.
name|I
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|ConstExprIterator
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
modifier|*
name|I
decl_stmt|;
name|public
label|:
name|ConstExprIterator
argument_list|(
specifier|const
name|Stmt
operator|*
specifier|const
operator|*
name|i
argument_list|)
operator|:
name|I
argument_list|(
argument|i
argument_list|)
block|{}
name|ConstExprIterator
argument_list|()
operator|:
name|I
argument_list|(
literal|0
argument_list|)
block|{}
name|ConstExprIterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|I
block|;
return|return
operator|*
name|this
return|;
block|}
name|ConstExprIterator
name|operator
operator|+
operator|(
name|size_t
name|i
operator|)
specifier|const
block|{
return|return
name|I
operator|+
name|i
return|;
block|}
name|ConstExprIterator
name|operator
operator|-
operator|(
name|size_t
name|i
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|i
return|;
block|}
specifier|const
name|Expr
modifier|*
name|operator
index|[]
argument_list|(
name|size_t
name|idx
argument_list|)
decl|const
decl_stmt|;
name|signed
name|operator
operator|-
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|-
name|R
operator|.
name|I
return|;
block|}
specifier|const
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
expr_stmt|;
specifier|const
name|Expr
operator|*
name|operator
operator|->
expr|(
block|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|==
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|!=
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|ConstExprIterator
operator|&
name|R
operator|)
specifier|const
block|{
return|return
name|I
operator|>=
name|R
operator|.
name|I
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// AST classes for statements.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// Stmt - This represents one statement.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|Stmt
block|{
name|public
label|:
enum|enum
name|StmtClass
block|{
name|NoStmtClass
init|=
literal|0
block|,
define|#
directive|define
name|STMT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
value|CLASS##Class,
define|#
directive|define
name|STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,
define|#
directive|define
name|LAST_STMT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class
define|#
directive|define
name|ABSTRACT_STMT
parameter_list|(
name|STMT
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
block|}
enum|;
name|private
label|:
comment|/// \brief The statement class.
specifier|const
name|unsigned
name|sClass
range|:
literal|8
decl_stmt|;
comment|/// \brief The reference count for this statement.
name|unsigned
name|RefCount
range|:
literal|24
decl_stmt|;
comment|// Make vanilla 'new' and 'delete' illegal for Stmts.
name|protected
label|:
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Stmts cannot be allocated with regular 'new'."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function|throw
parameter_list|()
block|{
name|assert
argument_list|(
literal|0
operator|&&
literal|"Stmts cannot be released with regular 'delete'."
argument_list|)
expr_stmt|;
block|}
name|public
label|:
comment|// Only allow allocation of Stmts using the allocator in ASTContext
comment|// or by doing a placement new.
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|ASTContext
modifier|&
name|C
parameter_list|,
name|unsigned
name|alignment
init|=
literal|8
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|bytes
argument_list|,
name|C
argument_list|,
name|alignment
argument_list|)
return|;
block|}
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|ASTContext
modifier|*
name|C
parameter_list|,
name|unsigned
name|alignment
init|=
literal|8
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|bytes
argument_list|,
operator|*
name|C
argument_list|,
name|alignment
argument_list|)
return|;
block|}
name|void
modifier|*
name|operator
name|new
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
name|mem
return|;
block|}
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|ASTContext
modifier|&
parameter_list|,
name|unsigned
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|ASTContext
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|void
name|operator
name|delete
argument_list|(
name|void
operator|*
argument_list|,
name|std
operator|::
name|size_t
argument_list|)
name|throw
argument_list|()
block|{ }
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function|throw
parameter_list|()
block|{ }
name|public
label|:
comment|/// \brief A placeholder type used to construct an empty shell of a
comment|/// type, that will be filled in later (e.g., by some
comment|/// de-serialization).
struct|struct
name|EmptyShell
block|{ }
struct|;
name|protected
label|:
comment|/// DestroyChildren - Invoked by destructors of subclasses of Stmt to
comment|///  recursively release child AST nodes.
name|void
name|DestroyChildren
parameter_list|(
name|ASTContext
modifier|&
name|Ctx
parameter_list|)
function_decl|;
comment|/// \brief Construct an empty statement.
name|explicit
name|Stmt
argument_list|(
argument|StmtClass SC
argument_list|,
argument|EmptyShell
argument_list|)
block|:
name|sClass
argument_list|(
name|SC
argument_list|)
operator|,
name|RefCount
argument_list|(
literal|1
argument_list|)
block|{
if|if
condition|(
name|Stmt
operator|::
name|CollectingStats
argument_list|()
condition|)
name|Stmt
operator|::
name|addStmtClass
argument_list|(
name|SC
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Virtual method that performs the actual destruction of
comment|/// this statement.
comment|///
comment|/// Subclasses should override this method (not Destroy()) to
comment|/// provide class-specific destruction.
name|virtual
name|void
name|DoDestroy
parameter_list|(
name|ASTContext
modifier|&
name|Ctx
parameter_list|)
function_decl|;
name|public
label|:
name|Stmt
argument_list|(
argument|StmtClass SC
argument_list|)
block|:
name|sClass
argument_list|(
name|SC
argument_list|)
operator|,
name|RefCount
argument_list|(
literal|1
argument_list|)
block|{
if|if
condition|(
name|Stmt
operator|::
name|CollectingStats
argument_list|()
condition|)
name|Stmt
operator|::
name|addStmtClass
argument_list|(
name|SC
argument_list|)
expr_stmt|;
block|}
name|virtual
operator|~
name|Stmt
argument_list|()
block|{}
ifndef|#
directive|ifndef
name|NDEBUG
comment|/// \brief True if this statement's refcount is in a valid state.
comment|/// Should be used only in assertions.
name|bool
name|isRetained
argument_list|()
specifier|const
block|{
return|return
operator|(
name|RefCount
operator|>=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/// \brief Destroy the current statement and its children.
name|void
name|Destroy
parameter_list|(
name|ASTContext
modifier|&
name|Ctx
parameter_list|)
block|{
name|assert
argument_list|(
name|RefCount
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|RefCount
operator|==
literal|0
condition|)
name|DoDestroy
argument_list|(
name|Ctx
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Increases the reference count for this statement.
comment|///
comment|/// Invoke the Retain() operation when this statement or expression
comment|/// is being shared by another owner.
name|Stmt
modifier|*
name|Retain
parameter_list|()
block|{
name|assert
argument_list|(
name|RefCount
operator|>=
literal|1
argument_list|)
expr_stmt|;
operator|++
name|RefCount
expr_stmt|;
return|return
name|this
return|;
block|}
name|StmtClass
name|getStmtClass
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|RefCount
operator|>=
literal|1
operator|&&
literal|"Referencing already-destroyed statement!"
argument_list|)
block|;
return|return
operator|(
name|StmtClass
operator|)
name|sClass
return|;
block|}
specifier|const
name|char
operator|*
name|getStmtClassName
argument_list|()
specifier|const
expr_stmt|;
comment|/// SourceLocation tokens are not useful in isolation - they are low level
comment|/// value objects created/interpreted by SourceManager. We assume AST
comment|/// clients will have a pointer to the respective SourceManager.
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
operator|=
literal|0
expr_stmt|;
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
block|{
return|return
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
block|{
return|return
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
return|;
block|}
comment|// global temp stats (until we have a per-module visitor)
specifier|static
name|void
name|addStmtClass
parameter_list|(
specifier|const
name|StmtClass
name|s
parameter_list|)
function_decl|;
specifier|static
name|bool
name|CollectingStats
parameter_list|(
name|bool
name|Enable
init|=
name|false
parameter_list|)
function_decl|;
specifier|static
name|void
name|PrintStats
parameter_list|()
function_decl|;
comment|/// dump - This does a local dump of the specified AST fragment.  It dumps the
comment|/// specified node and a few nodes underneath it, but not the whole subtree.
comment|/// This is useful in a debugger.
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dump
argument_list|(
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
comment|/// dumpAll - This does a dump of the specified AST fragment and all subtrees.
name|void
name|dumpAll
argument_list|()
specifier|const
expr_stmt|;
name|void
name|dumpAll
argument_list|(
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
comment|/// dumpPretty/printPretty - These two methods do a "pretty print" of the AST
comment|/// back to its original source language syntax.
name|void
name|dumpPretty
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
name|void
name|printPretty
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|PrinterHelper
operator|*
name|Helper
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|Indentation
operator|=
literal|0
argument_list|)
decl|const
block|{
name|printPretty
argument_list|(
name|OS
argument_list|,
operator|*
operator|(
name|ASTContext
operator|*
operator|)
literal|0
argument_list|,
name|Helper
argument_list|,
name|Policy
argument_list|,
name|Indentation
argument_list|)
expr_stmt|;
block|}
name|void
name|printPretty
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|PrinterHelper
operator|*
name|Helper
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|Indentation
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
comment|/// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only
comment|///   works on systems with GraphViz (Mac OS X) or dot+gv installed.
name|void
name|viewAST
argument_list|()
specifier|const
expr_stmt|;
comment|// Implement isa<T> support.
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
comment|/// hasImplicitControlFlow - Some statements (e.g. short circuited operations)
comment|///  contain implicit control-flow in the order their subexpressions
comment|///  are evaluated.  This predicate returns true if this statement has
comment|///  such implicit control-flow.  Such statements are also specially handled
comment|///  within CFGs.
name|bool
name|hasImplicitControlFlow
argument_list|()
specifier|const
expr_stmt|;
comment|/// Child Iterators: All subclasses must implement child_begin and child_end
comment|///  to permit easy iteration over the substatements/subexpessions of an
comment|///  AST node.  This permits easy iteration over all nodes in the AST.
typedef|typedef
name|StmtIterator
name|child_iterator
typedef|;
typedef|typedef
name|ConstStmtIterator
name|const_child_iterator
typedef|;
name|virtual
name|child_iterator
name|child_begin
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|child_iterator
name|child_end
parameter_list|()
init|=
literal|0
function_decl|;
name|const_child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|const_child_iterator
argument_list|(
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|child_begin
argument_list|()
argument_list|)
return|;
block|}
name|const_child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|const_child_iterator
argument_list|(
name|const_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|child_end
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Produce a unique representation of the given statement.
comment|///
comment|/// \brief ID once the profiling operation is complete, will contain
comment|/// the unique representation of the given statement.
comment|///
comment|/// \brief Context the AST context in which the statement resides
comment|///
comment|/// \brief Canonical whether the profile should be based on the canonical
comment|/// representation of this statement (e.g., where non-type template
comment|/// parameters are identified by index/level rather than their
comment|/// declaration pointers) or the exact representation of the statement as
comment|/// written in the source.
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|bool
name|Canonical
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// DeclStmt - Adaptor class for mixing declarations with statements and
end_comment

begin_comment
comment|/// expressions. For example, CompoundStmt mixes statements, expressions
end_comment

begin_comment
comment|/// and declarations (variables, types). Another example is ForStmt, where
end_comment

begin_comment
comment|/// the first statement can be an expression or a declaration.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|DeclStmt
range|:
name|public
name|Stmt
block|{
name|DeclGroupRef
name|DG
block|;
name|SourceLocation
name|StartLoc
block|,
name|EndLoc
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|;
name|public
operator|:
name|DeclStmt
argument_list|(
argument|DeclGroupRef dg
argument_list|,
argument|SourceLocation startLoc
argument_list|,
argument|SourceLocation endLoc
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DeclStmtClass
argument_list|)
block|,
name|DG
argument_list|(
name|dg
argument_list|)
block|,
name|StartLoc
argument_list|(
name|startLoc
argument_list|)
block|,
name|EndLoc
argument_list|(
argument|endLoc
argument_list|)
block|{}
comment|/// \brief Build an empty declaration statement.
name|explicit
name|DeclStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DeclStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// isSingleDecl - This method returns true if this DeclStmt refers
comment|/// to a single Decl.
name|bool
name|isSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|isSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|Decl
operator|*
name|getSingleDecl
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
name|Decl
operator|*
name|getSingleDecl
argument_list|()
block|{
return|return
name|DG
operator|.
name|getSingleDecl
argument_list|()
return|;
block|}
specifier|const
name|DeclGroupRef
name|getDeclGroup
argument_list|()
specifier|const
block|{
return|return
name|DG
return|;
block|}
name|DeclGroupRef
name|getDeclGroup
argument_list|()
block|{
return|return
name|DG
return|;
block|}
name|void
name|setDeclGroup
argument_list|(
argument|DeclGroupRef DGR
argument_list|)
block|{
name|DG
operator|=
name|DGR
block|; }
name|SourceLocation
name|getStartLoc
argument_list|()
specifier|const
block|{
return|return
name|StartLoc
return|;
block|}
name|void
name|setStartLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StartLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|EndLoc
return|;
block|}
name|void
name|setEndLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EndLoc
operator|=
name|L
block|; }
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|StartLoc
argument_list|,
name|EndLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DeclStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DeclStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators over subexpressions.
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|;
typedef|typedef
name|DeclGroupRef
operator|::
name|iterator
name|decl_iterator
expr_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|DeclGroupRef
operator|::
name|const_iterator
name|const_decl_iterator
expr_stmt|;
end_typedef

begin_function
name|decl_iterator
name|decl_begin
parameter_list|()
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_function
name|decl_iterator
name|decl_end
parameter_list|()
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_decl_iterator
name|decl_begin
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_decl_iterator
name|decl_end
argument_list|()
specifier|const
block|{
return|return
name|DG
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// NullStmt - This is the null statement ";": C99 6.8.3p3.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|NullStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|SemiLoc
block|;
name|public
operator|:
name|NullStmt
argument_list|(
argument|SourceLocation L
argument_list|)
operator|:
name|Stmt
argument_list|(
name|NullStmtClass
argument_list|)
block|,
name|SemiLoc
argument_list|(
argument|L
argument_list|)
block|{}
comment|/// \brief Build an empty null statement.
name|explicit
name|NullStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|NullStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getSemiLoc
argument_list|()
specifier|const
block|{
return|return
name|SemiLoc
return|;
block|}
name|void
name|setSemiLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SemiLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|SemiLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|NullStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const NullStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// CompoundStmt - This represents a group of statements like { stmt stmt }.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|CompoundStmt
range|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
operator|*
name|Body
block|;
name|unsigned
name|NumStmts
block|;
name|SourceLocation
name|LBracLoc
block|,
name|RBracLoc
block|;
name|public
operator|:
name|CompoundStmt
argument_list|(
argument|ASTContext& C
argument_list|,
argument|Stmt **StmtStart
argument_list|,
argument|unsigned numStmts
argument_list|,
argument|SourceLocation LB
argument_list|,
argument|SourceLocation RB
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|)
block|,
name|NumStmts
argument_list|(
name|numStmts
argument_list|)
block|,
name|LBracLoc
argument_list|(
name|LB
argument_list|)
block|,
name|RBracLoc
argument_list|(
argument|RB
argument_list|)
block|{
if|if
condition|(
name|NumStmts
operator|==
literal|0
condition|)
block|{
name|Body
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|Body
operator|=
name|new
argument_list|(
argument|C
argument_list|)
name|Stmt
operator|*
index|[
name|NumStmts
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|Body
argument_list|,
name|StmtStart
argument_list|,
name|numStmts
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|Body
argument_list|)
argument_list|)
block|;   }
comment|// \brief Build an empty compound statement.
name|explicit
name|CompoundStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|CompoundStmtClass
argument_list|,
name|Empty
argument_list|)
decl_stmt|,
name|Body
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|NumStmts
argument_list|(
literal|0
argument_list|)
block|{ }
end_decl_stmt

begin_function_decl
name|void
name|setStmts
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|Stmt
modifier|*
modifier|*
name|Stmts
parameter_list|,
name|unsigned
name|NumStmts
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|bool
name|body_empty
argument_list|()
specifier|const
block|{
return|return
name|NumStmts
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|NumStmts
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|Stmt
modifier|*
modifier|*
name|body_iterator
typedef|;
end_typedef

begin_function
name|body_iterator
name|body_begin
parameter_list|()
block|{
return|return
name|Body
return|;
block|}
end_function

begin_function
name|body_iterator
name|body_end
parameter_list|()
block|{
return|return
name|Body
operator|+
name|NumStmts
return|;
block|}
end_function

begin_function
name|Stmt
modifier|*
name|body_back
parameter_list|()
block|{
return|return
name|NumStmts
condition|?
name|Body
index|[
name|NumStmts
operator|-
literal|1
index|]
else|:
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|Stmt
modifier|*
specifier|const
modifier|*
name|const_body_iterator
typedef|;
end_typedef

begin_expr_stmt
name|const_body_iterator
name|body_begin
argument_list|()
specifier|const
block|{
return|return
name|Body
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_body_iterator
name|body_end
argument_list|()
specifier|const
block|{
return|return
name|Body
operator|+
name|NumStmts
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Stmt
operator|*
name|body_back
argument_list|()
specifier|const
block|{
return|return
name|NumStmts
operator|?
name|Body
index|[
name|NumStmts
operator|-
literal|1
index|]
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|body_iterator
operator|>
name|reverse_body_iterator
expr_stmt|;
end_typedef

begin_function
name|reverse_body_iterator
name|body_rbegin
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reverse_body_iterator
name|body_rend
parameter_list|()
block|{
return|return
name|reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|std
operator|::
name|reverse_iterator
operator|<
name|const_body_iterator
operator|>
name|const_reverse_body_iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_body_iterator
name|body_rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_body_iterator
argument_list|(
name|body_begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|LBracLoc
argument_list|,
name|RBracLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getLBracLoc
argument_list|()
specifier|const
block|{
return|return
name|LBracLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setLBracLoc
parameter_list|(
name|SourceLocation
name|L
parameter_list|)
block|{
name|LBracLoc
operator|=
name|L
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SourceLocation
name|getRBracLoc
argument_list|()
specifier|const
block|{
return|return
name|RBracLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setRBracLoc
parameter_list|(
name|SourceLocation
name|L
parameter_list|)
block|{
name|RBracLoc
operator|=
name|L
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|T
parameter_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CompoundStmtClass
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|CompoundStmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Iterators
end_comment

begin_function_decl
name|virtual
name|child_iterator
name|child_begin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|child_iterator
name|child_end
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};
comment|// SwitchCase is the base class for CaseStmt and DefaultStmt,
end_comment

begin_decl_stmt
name|class
name|SwitchCase
range|:
name|public
name|Stmt
block|{
name|protected
operator|:
comment|// A pointer to the following CaseStmt or DefaultStmt class,
comment|// used by SwitchStmt.
name|SwitchCase
operator|*
name|NextSwitchCase
block|;
name|SwitchCase
argument_list|(
argument|StmtClass SC
argument_list|)
operator|:
name|Stmt
argument_list|(
name|SC
argument_list|)
block|,
name|NextSwitchCase
argument_list|(
literal|0
argument_list|)
block|{}
name|public
operator|:
specifier|const
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
specifier|const
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|SwitchCase
operator|*
name|getNextSwitchCase
argument_list|()
block|{
return|return
name|NextSwitchCase
return|;
block|}
name|void
name|setNextSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|NextSwitchCase
operator|=
name|SC
block|; }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|v_getSubStmt
argument_list|()
return|;
block|}
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|()
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
operator|||
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SwitchCase *
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|protected
operator|:
name|virtual
name|Stmt
operator|*
name|v_getSubStmt
argument_list|()
operator|=
literal|0
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|CaseStmt
range|:
name|public
name|SwitchCase
block|{   enum
block|{
name|SUBSTMT
block|,
name|LHS
block|,
name|RHS
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// The expression for the RHS is Non-null for
comment|// GNU "case 1 ... 4" extension
name|SourceLocation
name|CaseLoc
block|;
name|SourceLocation
name|EllipsisLoc
block|;
name|SourceLocation
name|ColonLoc
block|;
name|virtual
name|Stmt
operator|*
name|v_getSubStmt
argument_list|()
block|{
return|return
name|getSubStmt
argument_list|()
return|;
block|}
name|public
operator|:
name|CaseStmt
argument_list|(
argument|Expr *lhs
argument_list|,
argument|Expr *rhs
argument_list|,
argument|SourceLocation caseLoc
argument_list|,
argument|SourceLocation ellipsisLoc
argument_list|,
argument|SourceLocation colonLoc
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
literal|0
block|;
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|lhs
operator|)
block|;
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|rhs
operator|)
block|;
name|CaseLoc
operator|=
name|caseLoc
block|;
name|EllipsisLoc
operator|=
name|ellipsisLoc
block|;
name|ColonLoc
operator|=
name|colonLoc
block|;   }
comment|/// \brief Build an empty switch case statement.
name|explicit
name|CaseStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|CaseStmtClass
argument_list|)
block|{ }
name|SourceLocation
name|getCaseLoc
argument_list|()
specifier|const
block|{
return|return
name|CaseLoc
return|;
block|}
name|void
name|setCaseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|CaseLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
name|void
name|setEllipsisLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|EllipsisLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|Expr
operator|*
name|getLHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getRHS
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getLHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|LHS
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getRHS
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|RHS
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|SUBSTMT
index|]
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|SUBSTMT
index|]
operator|=
name|S
block|; }
name|void
name|setLHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|LHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|void
name|setRHS
argument_list|(
argument|Expr *Val
argument_list|)
block|{
name|SubExprs
index|[
name|RHS
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|Val
operator|)
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
comment|// Handle deeply nested case statements with iteration instead of recursion.
specifier|const
name|CaseStmt
operator|*
name|CS
operator|=
name|this
block|;
while|while
condition|(
specifier|const
name|CaseStmt
modifier|*
name|CS2
init|=
name|dyn_cast
operator|<
name|CaseStmt
operator|>
operator|(
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|)
condition|)
name|CS
operator|=
name|CS2
expr_stmt|;
return|return
name|SourceRange
argument_list|(
name|CaseLoc
argument_list|,
name|CS
operator|->
name|getSubStmt
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|T
parameter_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|CaseStmtClass
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|CaseStmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Iterators
end_comment

begin_function_decl
name|virtual
name|child_iterator
name|child_begin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|child_iterator
name|child_end
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
unit|};
name|class
name|DefaultStmt
range|:
name|public
name|SwitchCase
block|{
name|Stmt
operator|*
name|SubStmt
block|;
name|SourceLocation
name|DefaultLoc
block|;
name|SourceLocation
name|ColonLoc
block|;
name|virtual
name|Stmt
operator|*
name|v_getSubStmt
argument_list|()
block|{
return|return
name|getSubStmt
argument_list|()
return|;
block|}
name|public
operator|:
name|DefaultStmt
argument_list|(
argument|SourceLocation DL
argument_list|,
argument|SourceLocation CL
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|SwitchCase
argument_list|(
name|DefaultStmtClass
argument_list|)
block|,
name|SubStmt
argument_list|(
name|substmt
argument_list|)
block|,
name|DefaultLoc
argument_list|(
name|DL
argument_list|)
block|,
name|ColonLoc
argument_list|(
argument|CL
argument_list|)
block|{}
comment|/// \brief Build an empty default statement.
name|explicit
name|DefaultStmt
argument_list|(
name|EmptyShell
argument_list|)
operator|:
name|SwitchCase
argument_list|(
argument|DefaultStmtClass
argument_list|)
block|{ }
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setSubStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubStmt
operator|=
name|S
block|; }
name|SourceLocation
name|getDefaultLoc
argument_list|()
specifier|const
block|{
return|return
name|DefaultLoc
return|;
block|}
name|void
name|setDefaultLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|DefaultLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getColonLoc
argument_list|()
specifier|const
block|{
return|return
name|ColonLoc
return|;
block|}
name|void
name|setColonLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ColonLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|DefaultLoc
argument_list|,
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DefaultStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DefaultStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|LabelStmt
range|:
name|public
name|Stmt
block|{
name|IdentifierInfo
operator|*
name|Label
block|;
name|Stmt
operator|*
name|SubStmt
block|;
name|SourceLocation
name|IdentLoc
block|;
name|public
operator|:
name|LabelStmt
argument_list|(
argument|SourceLocation IL
argument_list|,
argument|IdentifierInfo *label
argument_list|,
argument|Stmt *substmt
argument_list|)
operator|:
name|Stmt
argument_list|(
name|LabelStmtClass
argument_list|)
block|,
name|Label
argument_list|(
name|label
argument_list|)
block|,
name|SubStmt
argument_list|(
name|substmt
argument_list|)
block|,
name|IdentLoc
argument_list|(
argument|IL
argument_list|)
block|{}
comment|// \brief Build an empty label statement.
name|explicit
name|LabelStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|LabelStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getIdentLoc
argument_list|()
specifier|const
block|{
return|return
name|IdentLoc
return|;
block|}
name|IdentifierInfo
operator|*
name|getID
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|void
name|setID
argument_list|(
argument|IdentifierInfo *II
argument_list|)
block|{
name|Label
operator|=
name|II
block|; }
specifier|const
name|char
operator|*
name|getName
argument_list|()
specifier|const
block|;
name|Stmt
operator|*
name|getSubStmt
argument_list|()
block|{
return|return
name|SubStmt
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getSubStmt
argument_list|()
specifier|const
block|{
return|return
name|SubStmt
return|;
block|}
name|void
name|setIdentLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IdentLoc
operator|=
name|L
block|; }
name|void
name|setSubStmt
argument_list|(
argument|Stmt *SS
argument_list|)
block|{
name|SubStmt
operator|=
name|SS
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|IdentLoc
argument_list|,
name|SubStmt
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|LabelStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const LabelStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// IfStmt - This represents an if/then/else.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|IfStmt
range|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|THEN
block|,
name|ELSE
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|IfLoc
block|;
name|SourceLocation
name|ElseLoc
block|;
name|public
operator|:
name|IfStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation IL
argument_list|,
argument|VarDecl *var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *then
argument_list|,
argument|SourceLocation EL = SourceLocation()
argument_list|,
argument|Stmt *elsev =
literal|0
argument_list|)
block|;
comment|/// \brief Build an empty if/then/else statement
name|explicit
name|IfStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IfStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "if" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// if (int x = foo()) {
comment|///   printf("x is %d", x);
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
specifier|const
name|Stmt
operator|*
name|getThen
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|void
name|setThen
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|THEN
index|]
operator|=
name|S
block|; }
specifier|const
name|Stmt
operator|*
name|getElse
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|void
name|setElse
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|ELSE
index|]
operator|=
name|S
block|; }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getThen
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|THEN
index|]
return|;
block|}
name|Stmt
operator|*
name|getElse
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|ELSE
index|]
return|;
block|}
name|SourceLocation
name|getIfLoc
argument_list|()
specifier|const
block|{
return|return
name|IfLoc
return|;
block|}
name|void
name|setIfLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|IfLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getElseLoc
argument_list|()
specifier|const
block|{
return|return
name|ElseLoc
return|;
block|}
name|void
name|setElseLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ElseLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
if|if
condition|(
name|SubExprs
index|[
name|ELSE
index|]
condition|)
return|return
name|SourceRange
argument_list|(
name|IfLoc
argument_list|,
name|SubExprs
index|[
name|ELSE
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
else|else
return|return
name|SourceRange
argument_list|(
name|IfLoc
argument_list|,
name|SubExprs
index|[
name|THEN
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IfStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IfStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators over subexpressions.  The iterators will include iterating
comment|// over the initialization expression referenced by the condition variable.
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// SwitchStmt - This represents a 'switch' stmt.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|SwitchStmt
range|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// This points to a linked list of case and default statements.
name|SwitchCase
operator|*
name|FirstCase
block|;
name|SourceLocation
name|SwitchLoc
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|;
name|public
operator|:
name|SwitchStmt
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|Var
argument_list|,
name|Expr
operator|*
name|cond
argument_list|)
block|;
comment|/// \brief Build a empty switch statement.
name|explicit
name|SwitchStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|SwitchStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "switch" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// switch (int x = foo()) {
comment|///   case 0: break;
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
specifier|const
block|{
return|return
name|FirstCase
return|;
block|}
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SwitchCase
operator|*
name|getSwitchCaseList
argument_list|()
block|{
return|return
name|FirstCase
return|;
block|}
comment|/// \brief Set the case list for this switch statement.
comment|///
comment|/// The caller is responsible for incrementing the retain counts on
comment|/// all of the SwitchCase statements in this list.
name|void
name|setSwitchCaseList
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|FirstCase
operator|=
name|SC
block|; }
name|SourceLocation
name|getSwitchLoc
argument_list|()
specifier|const
block|{
return|return
name|SwitchLoc
return|;
block|}
name|void
name|setSwitchLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|SwitchLoc
operator|=
name|L
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|,
argument|SourceLocation SL
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|;
name|SwitchLoc
operator|=
name|SL
block|;   }
name|void
name|addSwitchCase
argument_list|(
argument|SwitchCase *SC
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|SC
operator|->
name|getNextSwitchCase
argument_list|()
operator|&&
literal|"case/default already added to a switch"
argument_list|)
block|;
name|SC
operator|->
name|Retain
argument_list|()
block|;
name|SC
operator|->
name|setNextSwitchCase
argument_list|(
name|FirstCase
argument_list|)
block|;
name|FirstCase
operator|=
name|SC
block|;   }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|SwitchLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|SwitchStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const SwitchStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// WhileStmt - This represents a 'while' stmt.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|WhileStmt
range|:
name|public
name|Stmt
block|{   enum
block|{
name|VAR
block|,
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|WhileLoc
block|;
name|public
operator|:
name|WhileStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|VarDecl *Var
argument_list|,
argument|Expr *cond
argument_list|,
argument|Stmt *body
argument_list|,
argument|SourceLocation WL
argument_list|)
block|;
comment|/// \brief Build an empty while statement.
name|explicit
name|WhileStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|WhileStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
comment|/// \brief Retrieve the variable declared in this "while" statement, if any.
comment|///
comment|/// In the following example, "x" is the condition variable.
comment|/// \code
comment|/// while (int x = random()) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|WhileLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|WhileStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const WhileStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// DoStmt - This represents a 'do/while' stmt.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|DoStmt
range|:
name|public
name|Stmt
block|{   enum
block|{
name|COND
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
name|SourceLocation
name|DoLoc
block|;
name|SourceLocation
name|WhileLoc
block|;
name|SourceLocation
name|RParenLoc
block|;
comment|// Location of final ')' in do stmt condition.
name|public
operator|:
name|DoStmt
argument_list|(
argument|Stmt *body
argument_list|,
argument|Expr *cond
argument_list|,
argument|SourceLocation DL
argument_list|,
argument|SourceLocation WL
argument_list|,
argument|SourceLocation RP
argument_list|)
operator|:
name|Stmt
argument_list|(
name|DoStmtClass
argument_list|)
block|,
name|DoLoc
argument_list|(
name|DL
argument_list|)
block|,
name|WhileLoc
argument_list|(
name|WL
argument_list|)
block|,
name|RParenLoc
argument_list|(
argument|RP
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|cond
operator|)
block|;
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|body
block|;   }
comment|/// \brief Build an empty do-while statement.
name|explicit
name|DoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|DoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getDoLoc
argument_list|()
specifier|const
block|{
return|return
name|DoLoc
return|;
block|}
name|void
name|setDoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|DoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getWhileLoc
argument_list|()
specifier|const
block|{
return|return
name|WhileLoc
return|;
block|}
name|void
name|setWhileLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|WhileLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|DoLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|DoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const DoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of
end_comment

begin_comment
comment|/// the init/cond/inc parts of the ForStmt will be null if they were not
end_comment

begin_comment
comment|/// specified in the source.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|ForStmt
range|:
name|public
name|Stmt
block|{   enum
block|{
name|INIT
block|,
name|CONDVAR
block|,
name|COND
block|,
name|INC
block|,
name|BODY
block|,
name|END_EXPR
block|}
block|;
name|Stmt
operator|*
name|SubExprs
index|[
name|END_EXPR
index|]
block|;
comment|// SubExprs[INIT] is an expression or declstmt.
name|SourceLocation
name|ForLoc
block|;
name|SourceLocation
name|LParenLoc
block|,
name|RParenLoc
block|;
name|public
operator|:
name|ForStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|Stmt *Init
argument_list|,
argument|Expr *Cond
argument_list|,
argument|VarDecl *condVar
argument_list|,
argument|Expr *Inc
argument_list|,
argument|Stmt *Body
argument_list|,
argument|SourceLocation FL
argument_list|,
argument|SourceLocation LP
argument_list|,
argument|SourceLocation RP
argument_list|)
block|;
comment|/// \brief Build an empty for statement.
name|explicit
name|ForStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ForStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|Stmt
operator|*
name|getInit
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
comment|/// \brief Retrieve the variable declared in this "for" statement, if any.
comment|///
comment|/// In the following example, "y" is the condition variable.
comment|/// \code
comment|/// for (int x = random(); int y = mangle(x); ++x) {
comment|///   // ...
comment|/// }
comment|/// \endcode
name|VarDecl
operator|*
name|getConditionVariable
argument_list|()
specifier|const
block|;
name|void
name|setConditionVariable
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|VarDecl
operator|*
name|V
argument_list|)
block|;
name|Expr
operator|*
name|getCond
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
name|Expr
operator|*
name|getInc
argument_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
name|Stmt
operator|*
name|getBody
argument_list|()
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getInit
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|INIT
index|]
return|;
block|}
specifier|const
name|Expr
operator|*
name|getCond
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|COND
index|]
operator|)
return|;
block|}
specifier|const
name|Expr
operator|*
name|getInc
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SubExprs
index|[
name|INC
index|]
operator|)
return|;
block|}
specifier|const
name|Stmt
operator|*
name|getBody
argument_list|()
specifier|const
block|{
return|return
name|SubExprs
index|[
name|BODY
index|]
return|;
block|}
name|void
name|setInit
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|INIT
index|]
operator|=
name|S
block|; }
name|void
name|setCond
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|COND
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setInc
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|SubExprs
index|[
name|INC
index|]
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|void
name|setBody
argument_list|(
argument|Stmt *S
argument_list|)
block|{
name|SubExprs
index|[
name|BODY
index|]
operator|=
name|S
block|; }
name|SourceLocation
name|getForLoc
argument_list|()
specifier|const
block|{
return|return
name|ForLoc
return|;
block|}
name|void
name|setForLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ForLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLParenLoc
argument_list|()
specifier|const
block|{
return|return
name|LParenLoc
return|;
block|}
name|void
name|setLParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LParenLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|ForLoc
argument_list|,
name|SubExprs
index|[
name|BODY
index|]
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ForStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ForStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// GotoStmt - This represents a direct goto.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|GotoStmt
range|:
name|public
name|Stmt
block|{
name|LabelStmt
operator|*
name|Label
block|;
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|LabelLoc
block|;
name|public
operator|:
name|GotoStmt
argument_list|(
argument|LabelStmt *label
argument_list|,
argument|SourceLocation GL
argument_list|,
argument|SourceLocation LL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|GotoStmtClass
argument_list|)
block|,
name|Label
argument_list|(
name|label
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|GL
argument_list|)
block|,
name|LabelLoc
argument_list|(
argument|LL
argument_list|)
block|{}
comment|/// \brief Build an empty goto statement.
name|explicit
name|GotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|GotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|LabelStmt
operator|*
name|getLabel
argument_list|()
specifier|const
block|{
return|return
name|Label
return|;
block|}
name|void
name|setLabel
argument_list|(
argument|LabelStmt *S
argument_list|)
block|{
name|Label
operator|=
name|S
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getLabelLoc
argument_list|()
specifier|const
block|{
return|return
name|LabelLoc
return|;
block|}
name|void
name|setLabelLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|LabelLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|GotoLoc
argument_list|,
name|LabelLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|GotoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const GotoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// IndirectGotoStmt - This represents an indirect goto.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|IndirectGotoStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|GotoLoc
block|;
name|SourceLocation
name|StarLoc
block|;
name|Stmt
operator|*
name|Target
block|;
name|public
operator|:
name|IndirectGotoStmt
argument_list|(
argument|SourceLocation gotoLoc
argument_list|,
argument|SourceLocation starLoc
argument_list|,
argument|Expr *target
argument_list|)
operator|:
name|Stmt
argument_list|(
name|IndirectGotoStmtClass
argument_list|)
block|,
name|GotoLoc
argument_list|(
name|gotoLoc
argument_list|)
block|,
name|StarLoc
argument_list|(
name|starLoc
argument_list|)
block|,
name|Target
argument_list|(
argument|(Stmt*)target
argument_list|)
block|{}
comment|/// \brief Build an empty indirect goto statement.
name|explicit
name|IndirectGotoStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|IndirectGotoStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|void
name|setGotoLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|GotoLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getGotoLoc
argument_list|()
specifier|const
block|{
return|return
name|GotoLoc
return|;
block|}
name|void
name|setStarLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|StarLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getStarLoc
argument_list|()
specifier|const
block|{
return|return
name|StarLoc
return|;
block|}
name|Expr
operator|*
name|getTarget
argument_list|()
block|;
specifier|const
name|Expr
operator|*
name|getTarget
argument_list|()
specifier|const
block|;
name|void
name|setTarget
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|Target
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|GotoLoc
argument_list|,
name|Target
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|IndirectGotoStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const IndirectGotoStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// ContinueStmt - This represents a continue.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|ContinueStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|ContinueLoc
block|;
name|public
operator|:
name|ContinueStmt
argument_list|(
argument|SourceLocation CL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ContinueStmtClass
argument_list|)
block|,
name|ContinueLoc
argument_list|(
argument|CL
argument_list|)
block|{}
comment|/// \brief Build an empty continue statement.
name|explicit
name|ContinueStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ContinueStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getContinueLoc
argument_list|()
specifier|const
block|{
return|return
name|ContinueLoc
return|;
block|}
name|void
name|setContinueLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|ContinueLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|ContinueLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ContinueStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ContinueStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// BreakStmt - This represents a break.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|BreakStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|BreakLoc
block|;
name|public
operator|:
name|BreakStmt
argument_list|(
argument|SourceLocation BL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|BreakStmtClass
argument_list|)
block|,
name|BreakLoc
argument_list|(
argument|BL
argument_list|)
block|{}
comment|/// \brief Build an empty break statement.
name|explicit
name|BreakStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|BreakStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
name|SourceLocation
name|getBreakLoc
argument_list|()
specifier|const
block|{
return|return
name|BreakLoc
return|;
block|}
name|void
name|setBreakLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|BreakLoc
operator|=
name|L
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|BreakLoc
argument_list|)
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|BreakStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const BreakStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// ReturnStmt - This represents a return, optionally of an expression:
end_comment

begin_comment
comment|///   return;
end_comment

begin_comment
comment|///   return 4;
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that GCC allows return with no argument in a function declared to
end_comment

begin_comment
comment|/// return a value, and it allows returning a value in functions declared to
end_comment

begin_comment
comment|/// return void.  We explicitly model this in the AST, which means you can't
end_comment

begin_comment
comment|/// depend on the return type of the function and the presence of an argument.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|ReturnStmt
range|:
name|public
name|Stmt
block|{
name|Stmt
operator|*
name|RetExpr
block|;
name|SourceLocation
name|RetLoc
block|;
specifier|const
name|VarDecl
operator|*
name|NRVOCandidate
block|;
name|public
operator|:
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ReturnStmtClass
argument_list|)
block|,
name|RetExpr
argument_list|(
literal|0
argument_list|)
block|,
name|RetLoc
argument_list|(
name|RL
argument_list|)
block|,
name|NRVOCandidate
argument_list|(
literal|0
argument_list|)
block|{ }
name|ReturnStmt
argument_list|(
argument|SourceLocation RL
argument_list|,
argument|Expr *E
argument_list|,
argument|const VarDecl *NRVOCandidate
argument_list|)
operator|:
name|Stmt
argument_list|(
name|ReturnStmtClass
argument_list|)
block|,
name|RetExpr
argument_list|(
operator|(
name|Stmt
operator|*
operator|)
name|E
argument_list|)
block|,
name|RetLoc
argument_list|(
name|RL
argument_list|)
block|,
name|NRVOCandidate
argument_list|(
argument|NRVOCandidate
argument_list|)
block|{}
comment|/// \brief Build an empty return expression.
name|explicit
name|ReturnStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
argument|ReturnStmtClass
argument_list|,
argument|Empty
argument_list|)
block|{ }
specifier|const
name|Expr
operator|*
name|getRetValue
argument_list|()
specifier|const
block|;
name|Expr
operator|*
name|getRetValue
argument_list|()
block|;
name|void
name|setRetValue
argument_list|(
argument|Expr *E
argument_list|)
block|{
name|RetExpr
operator|=
name|reinterpret_cast
operator|<
name|Stmt
operator|*
operator|>
operator|(
name|E
operator|)
block|; }
name|SourceLocation
name|getReturnLoc
argument_list|()
specifier|const
block|{
return|return
name|RetLoc
return|;
block|}
name|void
name|setReturnLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RetLoc
operator|=
name|L
block|; }
comment|/// \brief Retrieve the variable that might be used for the named return
comment|/// value optimization.
comment|///
comment|/// The optimization itself can only be performed if the variable is
comment|/// also marked as an NRVO object.
specifier|const
name|VarDecl
operator|*
name|getNRVOCandidate
argument_list|()
specifier|const
block|{
return|return
name|NRVOCandidate
return|;
block|}
name|void
name|setNRVOCandidate
argument_list|(
argument|const VarDecl *Var
argument_list|)
block|{
name|NRVOCandidate
operator|=
name|Var
block|; }
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const Stmt *T
argument_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|ReturnStmtClass
return|;
block|}
specifier|static
name|bool
name|classof
argument_list|(
argument|const ReturnStmt *
argument_list|)
block|{
return|return
name|true
return|;
block|}
comment|// Iterators
name|virtual
name|child_iterator
name|child_begin
argument_list|()
block|;
name|virtual
name|child_iterator
name|child_end
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// AsmStmt - This represents a GNU inline-assembly statement extension.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|AsmStmt
range|:
name|public
name|Stmt
block|{
name|SourceLocation
name|AsmLoc
block|,
name|RParenLoc
block|;
name|StringLiteral
operator|*
name|AsmStr
block|;
name|bool
name|IsSimple
block|;
name|bool
name|IsVolatile
block|;
name|bool
name|MSAsm
block|;
name|unsigned
name|NumOutputs
block|;
name|unsigned
name|NumInputs
block|;
name|unsigned
name|NumClobbers
block|;
comment|// FIXME: If we wanted to, we could allocate all of these in one big array.
name|IdentifierInfo
operator|*
operator|*
name|Names
block|;
name|StringLiteral
operator|*
operator|*
name|Constraints
block|;
name|Stmt
operator|*
operator|*
name|Exprs
block|;
name|StringLiteral
operator|*
operator|*
name|Clobbers
block|;
name|protected
operator|:
name|virtual
name|void
name|DoDestroy
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
block|;
name|public
operator|:
name|AsmStmt
argument_list|(
argument|ASTContext&C
argument_list|,
argument|SourceLocation asmloc
argument_list|,
argument|bool issimple
argument_list|,
argument|bool isvolatile
argument_list|,
argument|bool msasm
argument_list|,
argument|unsigned numoutputs
argument_list|,
argument|unsigned numinputs
argument_list|,
argument|IdentifierInfo **names
argument_list|,
argument|StringLiteral **constraints
argument_list|,
argument|Expr **exprs
argument_list|,
argument|StringLiteral *asmstr
argument_list|,
argument|unsigned numclobbers
argument_list|,
argument|StringLiteral **clobbers
argument_list|,
argument|SourceLocation rparenloc
argument_list|)
block|;
comment|/// \brief Build an empty inline-assembly statement.
name|explicit
name|AsmStmt
argument_list|(
argument|EmptyShell Empty
argument_list|)
operator|:
name|Stmt
argument_list|(
name|AsmStmtClass
argument_list|,
name|Empty
argument_list|)
block|,
name|Names
argument_list|(
literal|0
argument_list|)
block|,
name|Constraints
argument_list|(
literal|0
argument_list|)
block|,
name|Exprs
argument_list|(
literal|0
argument_list|)
block|,
name|Clobbers
argument_list|(
literal|0
argument_list|)
block|{ }
name|SourceLocation
name|getAsmLoc
argument_list|()
specifier|const
block|{
return|return
name|AsmLoc
return|;
block|}
name|void
name|setAsmLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|AsmLoc
operator|=
name|L
block|; }
name|SourceLocation
name|getRParenLoc
argument_list|()
specifier|const
block|{
return|return
name|RParenLoc
return|;
block|}
name|void
name|setRParenLoc
argument_list|(
argument|SourceLocation L
argument_list|)
block|{
name|RParenLoc
operator|=
name|L
block|; }
name|bool
name|isVolatile
argument_list|()
specifier|const
block|{
return|return
name|IsVolatile
return|;
block|}
name|void
name|setVolatile
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsVolatile
operator|=
name|V
block|; }
name|bool
name|isSimple
argument_list|()
specifier|const
block|{
return|return
name|IsSimple
return|;
block|}
name|void
name|setSimple
argument_list|(
argument|bool V
argument_list|)
block|{
name|IsSimple
operator|=
name|V
block|; }
name|bool
name|isMSAsm
argument_list|()
specifier|const
block|{
return|return
name|MSAsm
return|;
block|}
name|void
name|setMSAsm
argument_list|(
argument|bool V
argument_list|)
block|{
name|MSAsm
operator|=
name|V
block|; }
comment|//===--- Asm String Analysis ---===//
specifier|const
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
specifier|const
block|{
return|return
name|AsmStr
return|;
block|}
name|StringLiteral
operator|*
name|getAsmString
argument_list|()
block|{
return|return
name|AsmStr
return|;
block|}
name|void
name|setAsmString
argument_list|(
argument|StringLiteral *E
argument_list|)
block|{
name|AsmStr
operator|=
name|E
block|; }
comment|/// AsmStringPiece - this is part of a decomposed asm string specification
comment|/// (for use with the AnalyzeAsmString function below).  An asm string is
comment|/// considered to be a concatenation of these parts.
name|class
name|AsmStringPiece
block|{
name|public
operator|:
expr|enum
name|Kind
block|{
name|String
block|,
comment|// String in .ll asm string form, "$" -> "$$" and "%%" -> "%".
name|Operand
comment|// Operand reference, with optional modifier %c4.
block|}
block|;
name|private
operator|:
name|Kind
name|MyKind
block|;
name|std
operator|::
name|string
name|Str
block|;
name|unsigned
name|OperandNo
block|;
name|public
operator|:
name|AsmStringPiece
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|S
argument_list|)
operator|:
name|MyKind
argument_list|(
name|String
argument_list|)
block|,
name|Str
argument_list|(
argument|S
argument_list|)
block|{}
name|AsmStringPiece
argument_list|(
argument|unsigned OpNo
argument_list|,
argument|char Modifier
argument_list|)
operator|:
name|MyKind
argument_list|(
name|Operand
argument_list|)
block|,
name|Str
argument_list|()
block|,
name|OperandNo
argument_list|(
argument|OpNo
argument_list|)
block|{
name|Str
operator|+=
name|Modifier
block|;     }
name|bool
name|isString
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|String
return|;
block|}
name|bool
name|isOperand
argument_list|()
specifier|const
block|{
return|return
name|MyKind
operator|==
name|Operand
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getString
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isString
argument_list|()
argument_list|)
block|;
return|return
name|Str
return|;
block|}
name|unsigned
name|getOperandNo
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
argument_list|)
block|;
return|return
name|OperandNo
return|;
block|}
comment|/// getModifier - Get the modifier for this operand, if present.  This
comment|/// returns '\0' if there was no modifier.
name|char
name|getModifier
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isOperand
argument_list|()
argument_list|)
block|;
return|return
name|Str
index|[
literal|0
index|]
return|;
block|}
expr|}
block|;
comment|/// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing
comment|/// it into pieces.  If the asm string is erroneous, emit errors and return
comment|/// true, otherwise return false.  This handles canonicalization and
comment|/// translation of strings from GCC syntax to LLVM IR syntax, and handles
comment|//// flattening of named references like %[foo] to Operand AsmStringPiece's.
name|unsigned
name|AnalyzeAsmString
argument_list|(
argument|llvm::SmallVectorImpl<AsmStringPiece>&Pieces
argument_list|,
argument|ASTContext&C
argument_list|,
argument|unsigned&DiagOffs
argument_list|)
specifier|const
block|;
comment|//===--- Output operands ---===//
name|unsigned
name|getNumOutputs
argument_list|()
specifier|const
block|{
return|return
name|NumOutputs
return|;
block|}
name|IdentifierInfo
operator|*
name|getOutputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
index|]
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getOutputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getOutputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|llvm
operator|::
name|StringRef
argument_list|()
return|;
block|}
comment|/// getOutputConstraint - Return the constraint string for the specified
comment|/// output operand.  All output constraints are known to be non-empty (either
comment|/// '=' or '+').
name|llvm
operator|::
name|StringRef
name|getOutputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|;
specifier|const
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|StringLiteral
operator|*
name|getOutputConstraintLiteral
argument_list|(
argument|unsigned i
argument_list|)
block|{
return|return
name|Constraints
index|[
name|i
index|]
return|;
block|}
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
block|;
specifier|const
name|Expr
operator|*
name|getOutputExpr
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|const_cast
operator|<
name|AsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getOutputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/// isOutputPlusConstraint - Return true if the specified output constraint
comment|/// is a "+" constraint (which is both an input and an output) or false if it
comment|/// is an "=" constraint (just an output).
name|bool
name|isOutputPlusConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|getOutputConstraint
argument_list|(
name|i
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'+'
return|;
block|}
comment|/// getNumPlusOperands - Return the number of output operands that have a "+"
comment|/// constraint.
name|unsigned
name|getNumPlusOperands
argument_list|()
specifier|const
block|;
comment|//===--- Input operands ---===//
name|unsigned
name|getNumInputs
argument_list|()
specifier|const
block|{
return|return
name|NumInputs
return|;
block|}
name|IdentifierInfo
operator|*
name|getInputIdentifier
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
return|return
name|Names
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getInputName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
if|if
condition|(
name|IdentifierInfo
modifier|*
name|II
init|=
name|getInputIdentifier
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|II
operator|->
name|getName
argument_list|()
return|;
return|return
name|llvm
operator|::
name|StringRef
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getInputConstraint - Return the specified input constraint.  Unlike output
end_comment

begin_comment
comment|/// constraints, these can be empty.
end_comment

begin_expr_stmt
name|llvm
operator|::
name|StringRef
name|getInputConstraint
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|StringLiteral
modifier|*
name|getInputConstraintLiteral
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
end_decl_stmt

begin_function
name|StringLiteral
modifier|*
name|getInputConstraintLiteral
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
return|return
name|Constraints
index|[
name|i
operator|+
name|NumOutputs
index|]
return|;
block|}
end_function

begin_function_decl
name|Expr
modifier|*
name|getInputExpr
parameter_list|(
name|unsigned
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|Expr
modifier|*
name|getInputExpr
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|AsmStmt
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getInputExpr
argument_list|(
name|i
argument_list|)
return|;
block|}
end_decl_stmt

begin_function_decl
name|void
name|setOutputsAndInputsAndClobbers
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|IdentifierInfo
modifier|*
modifier|*
name|Names
parameter_list|,
name|StringLiteral
modifier|*
modifier|*
name|Constraints
parameter_list|,
name|Stmt
modifier|*
modifier|*
name|Exprs
parameter_list|,
name|unsigned
name|NumOutputs
parameter_list|,
name|unsigned
name|NumInputs
parameter_list|,
name|StringLiteral
modifier|*
modifier|*
name|Clobbers
parameter_list|,
name|unsigned
name|NumClobbers
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//===--- Other ---===//
end_comment

begin_comment
comment|/// getNamedOperand - Given a symbolic operand reference like %[foo],
end_comment

begin_comment
comment|/// translate this into a numeric value needed to reference the same operand.
end_comment

begin_comment
comment|/// This returns -1 if the operand name is invalid.
end_comment

begin_decl_stmt
name|int
name|getNamedOperand
argument_list|(
name|llvm
operator|::
name|StringRef
name|SymbolicName
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|unsigned
name|getNumClobbers
argument_list|()
specifier|const
block|{
return|return
name|NumClobbers
return|;
block|}
end_expr_stmt

begin_function
name|StringLiteral
modifier|*
name|getClobber
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|StringLiteral
modifier|*
name|getClobber
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|Clobbers
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|virtual
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|AsmLoc
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|Stmt
modifier|*
name|T
parameter_list|)
block|{
return|return
name|T
operator|->
name|getStmtClass
argument_list|()
operator|==
name|AsmStmtClass
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|AsmStmt
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Input expr iterators.
end_comment

begin_typedef
typedef|typedef
name|ExprIterator
name|inputs_iterator
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ConstExprIterator
name|const_inputs_iterator
typedef|;
end_typedef

begin_function
name|inputs_iterator
name|begin_inputs
parameter_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
end_function

begin_function
name|inputs_iterator
name|end_inputs
parameter_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
end_function

begin_expr_stmt
name|const_inputs_iterator
name|begin_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_inputs_iterator
name|end_inputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
operator|+
name|NumInputs
return|;
block|}
end_expr_stmt

begin_comment
comment|// Output expr iterators.
end_comment

begin_typedef
typedef|typedef
name|ExprIterator
name|outputs_iterator
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ConstExprIterator
name|const_outputs_iterator
typedef|;
end_typedef

begin_function
name|outputs_iterator
name|begin_outputs
parameter_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|outputs_iterator
name|end_outputs
parameter_list|()
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
end_function

begin_expr_stmt
name|const_outputs_iterator
name|begin_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_outputs_iterator
name|end_outputs
argument_list|()
specifier|const
block|{
return|return
operator|&
name|Exprs
index|[
literal|0
index|]
operator|+
name|NumOutputs
return|;
block|}
end_expr_stmt

begin_comment
comment|// Child iterators
end_comment

begin_function_decl
name|virtual
name|child_iterator
name|child_begin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|child_iterator
name|child_end
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};  }
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

