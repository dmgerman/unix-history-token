begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- DeclContextInternals.h - DeclContext Representation -----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the data structures used in the implementation
end_comment

begin_comment
comment|//  of DeclContext.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_DECLCONTEXTINTERNALS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_DECLCONTEXTINTERNALS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclarationName.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|DependentDiagnostic
decl_stmt|;
comment|/// \brief An array of decls optimized for the common case of only containing
comment|/// one entry.
struct|struct
name|StoredDeclsList
block|{
comment|/// \brief When in vector form, this is what the Data pointer points to.
typedef|typedef
name|SmallVector
operator|<
name|NamedDecl
operator|*
operator|,
literal|4
operator|>
name|DeclsTy
expr_stmt|;
comment|/// \brief A collection of declarations, with a flag to indicate if we have
comment|/// further external declarations.
typedef|typedef
name|llvm
operator|::
name|PointerIntPair
operator|<
name|DeclsTy
operator|*
operator|,
literal|1
operator|,
name|bool
operator|>
name|DeclsAndHasExternalTy
expr_stmt|;
comment|/// \brief The stored data, which will be either a pointer to a NamedDecl,
comment|/// or a pointer to a vector with a flag to indicate if there are further
comment|/// external declarations.
name|llvm
operator|::
name|PointerUnion
operator|<
name|NamedDecl
operator|*
operator|,
name|DeclsAndHasExternalTy
operator|>
name|Data
expr_stmt|;
name|public
label|:
name|StoredDeclsList
argument_list|()
block|{}
name|StoredDeclsList
argument_list|(
name|StoredDeclsList
operator|&&
name|RHS
argument_list|)
operator|:
name|Data
argument_list|(
argument|RHS.Data
argument_list|)
block|{
name|RHS
operator|.
name|Data
operator|=
operator|(
name|NamedDecl
operator|*
operator|)
name|nullptr
block|;   }
operator|~
name|StoredDeclsList
argument_list|()
block|{
comment|// If this is a vector-form, free the vector.
if|if
condition|(
name|DeclsTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
condition|)
name|delete
name|Vector
decl_stmt|;
block|}
name|StoredDeclsList
modifier|&
name|operator
init|=
operator|(
name|StoredDeclsList
operator|&&
name|RHS
operator|)
block|{
if|if
condition|(
name|DeclsTy
modifier|*
name|Vector
init|=
name|getAsVector
argument_list|()
condition|)
name|delete
name|Vector
decl_stmt|;
name|Data
operator|=
name|RHS
operator|.
name|Data
decl_stmt|;
name|RHS
operator|.
name|Data
operator|=
operator|(
name|NamedDecl
operator|*
operator|)
name|nullptr
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|isNull
argument_list|()
decl|const
block|{
return|return
name|Data
operator|.
name|isNull
argument_list|()
return|;
block|}
name|NamedDecl
modifier|*
name|getAsDecl
argument_list|()
decl|const
block|{
return|return
name|Data
operator|.
name|dyn_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|DeclsAndHasExternalTy
name|getAsVectorAndHasExternal
argument_list|()
decl|const
block|{
return|return
name|Data
operator|.
name|dyn_cast
operator|<
name|DeclsAndHasExternalTy
operator|>
operator|(
operator|)
return|;
block|}
name|DeclsTy
modifier|*
name|getAsVector
argument_list|()
decl|const
block|{
return|return
name|getAsVectorAndHasExternal
argument_list|()
operator|.
name|getPointer
argument_list|()
return|;
block|}
name|bool
name|hasExternalDecls
argument_list|()
decl|const
block|{
return|return
name|getAsVectorAndHasExternal
argument_list|()
operator|.
name|getInt
argument_list|()
return|;
block|}
name|void
name|setHasExternalDecls
argument_list|()
block|{
if|if
condition|(
name|DeclsTy
modifier|*
name|Vec
init|=
name|getAsVector
argument_list|()
condition|)
name|Data
operator|=
name|DeclsAndHasExternalTy
argument_list|(
name|Vec
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|DeclsTy
modifier|*
name|VT
init|=
name|new
name|DeclsTy
argument_list|()
decl_stmt|;
if|if
condition|(
name|NamedDecl
modifier|*
name|OldD
init|=
name|getAsDecl
argument_list|()
condition|)
name|VT
operator|->
name|push_back
argument_list|(
name|OldD
argument_list|)
expr_stmt|;
name|Data
operator|=
name|DeclsAndHasExternalTy
argument_list|(
name|VT
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|setOnlyValue
argument_list|(
name|NamedDecl
operator|*
name|ND
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|getAsVector
argument_list|()
operator|&&
literal|"Not inline"
argument_list|)
expr_stmt|;
name|Data
operator|=
name|ND
expr_stmt|;
comment|// Make sure that Data is a plain NamedDecl* so we can use its address
comment|// at getLookupResult.
name|assert
argument_list|(
operator|*
operator|(
name|NamedDecl
operator|*
operator|*
operator|)
operator|&
name|Data
operator|==
name|ND
operator|&&
literal|"PointerUnion mangles the NamedDecl pointer!"
argument_list|)
expr_stmt|;
block|}
name|void
name|remove
argument_list|(
name|NamedDecl
operator|*
name|D
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|isNull
argument_list|()
operator|&&
literal|"removing from empty list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NamedDecl
modifier|*
name|Singleton
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|Singleton
operator|==
name|D
operator|&&
literal|"list is different singleton"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Singleton
expr_stmt|;
name|Data
operator|=
operator|(
name|NamedDecl
operator|*
operator|)
name|nullptr
expr_stmt|;
return|return;
block|}
name|DeclsTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
name|DeclsTy
operator|::
name|iterator
name|I
operator|=
name|std
operator|::
name|find
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|Vec
operator|.
name|end
argument_list|()
operator|&&
literal|"list does not contain decl"
argument_list|)
expr_stmt|;
name|Vec
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
name|D
argument_list|)
operator|==
name|Vec
operator|.
name|end
argument_list|()
operator|&&
literal|"list still contains decl"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Remove any declarations which were imported from an external
comment|/// AST source.
name|void
name|removeExternalDecls
argument_list|()
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
comment|// Nothing to do.
block|}
elseif|else
if|if
condition|(
name|NamedDecl
modifier|*
name|Singleton
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
if|if
condition|(
name|Singleton
operator|->
name|isFromASTFile
argument_list|()
condition|)
operator|*
name|this
operator|=
name|StoredDeclsList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|DeclsTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
name|Vec
operator|.
name|erase
argument_list|(
name|std
operator|::
name|remove_if
argument_list|(
name|Vec
operator|.
name|begin
argument_list|()
argument_list|,
name|Vec
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
name|Decl
operator|*
name|D
operator|)
block|{
return|return
name|D
operator|->
name|isFromASTFile
argument_list|()
return|;
block|}
block|)
operator|,
name|Vec
operator|.
name|end
argument_list|()
block|)
struct|;
comment|// Don't have any external decls any more.
name|Data
operator|=
name|DeclsAndHasExternalTy
argument_list|(
operator|&
name|Vec
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
unit|}
comment|/// getLookupResult - Return an array of all the decls that this list
end_comment

begin_comment
comment|/// represents.
end_comment

begin_expr_stmt
unit|DeclContext
operator|::
name|lookup_result
name|getLookupResult
argument_list|()
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// If we have a single NamedDecl, return it.
end_comment

begin_if
if|if
condition|(
name|NamedDecl
modifier|*
name|ND
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
name|assert
argument_list|(
operator|!
name|isNull
argument_list|()
operator|&&
literal|"Empty list isn't allowed"
argument_list|)
expr_stmt|;
comment|// Data is a raw pointer to a NamedDecl*, return it.
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|(
name|ND
argument_list|)
return|;
block|}
end_if

begin_expr_stmt
name|assert
argument_list|(
name|getAsVector
argument_list|()
operator|&&
literal|"Must have a vector at this point"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DeclsTy
modifier|&
name|Vector
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Otherwise, we have a range result.
end_comment

begin_return
return|return
name|DeclContext
operator|::
name|lookup_result
argument_list|(
name|Vector
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// HandleRedeclaration - If this is a redeclaration of an existing decl,
end_comment

begin_comment
comment|/// replace the old one with D and return true.  Otherwise return false.
end_comment

begin_macro
unit|bool
name|HandleRedeclaration
argument_list|(
argument|NamedDecl *D
argument_list|,
argument|bool IsKnownNewer
argument_list|)
end_macro

begin_block
block|{
comment|// Most decls only have one entry in their list, special case it.
if|if
condition|(
name|NamedDecl
modifier|*
name|OldD
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|D
operator|->
name|declarationReplaces
argument_list|(
name|OldD
argument_list|,
name|IsKnownNewer
argument_list|)
condition|)
return|return
name|false
return|;
name|setOnlyValue
argument_list|(
name|D
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Determine if this declaration is actually a redeclaration.
name|DeclsTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
for|for
control|(
name|DeclsTy
operator|::
name|iterator
name|OD
operator|=
name|Vec
operator|.
name|begin
argument_list|()
operator|,
name|ODEnd
operator|=
name|Vec
operator|.
name|end
argument_list|()
init|;
name|OD
operator|!=
name|ODEnd
condition|;
operator|++
name|OD
control|)
block|{
name|NamedDecl
modifier|*
name|OldD
init|=
operator|*
name|OD
decl_stmt|;
if|if
condition|(
name|D
operator|->
name|declarationReplaces
argument_list|(
name|OldD
argument_list|,
name|IsKnownNewer
argument_list|)
condition|)
block|{
operator|*
name|OD
operator|=
name|D
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_block

begin_comment
comment|/// AddSubsequentDecl - This is called on the second and later decl when it is
end_comment

begin_comment
comment|/// not a redeclaration to merge it into the appropriate place in our list.
end_comment

begin_comment
comment|///
end_comment

begin_function
name|void
name|AddSubsequentDecl
parameter_list|(
name|NamedDecl
modifier|*
name|D
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isNull
argument_list|()
operator|&&
literal|"don't AddSubsequentDecl when we have no decls"
argument_list|)
expr_stmt|;
comment|// If this is the second decl added to the list, convert this to vector
comment|// form.
if|if
condition|(
name|NamedDecl
modifier|*
name|OldD
init|=
name|getAsDecl
argument_list|()
condition|)
block|{
name|DeclsTy
modifier|*
name|VT
init|=
name|new
name|DeclsTy
argument_list|()
decl_stmt|;
name|VT
operator|->
name|push_back
argument_list|(
name|OldD
argument_list|)
expr_stmt|;
name|Data
operator|=
name|DeclsAndHasExternalTy
argument_list|(
name|VT
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|DeclsTy
modifier|&
name|Vec
init|=
operator|*
name|getAsVector
argument_list|()
decl_stmt|;
comment|// Using directives end up in a special entry which contains only
comment|// other using directives, so all this logic is wasted for them.
comment|// But avoiding the logic wastes time in the far-more-common case
comment|// that we're *not* adding a new using directive.
comment|// Tag declarations always go at the end of the list so that an
comment|// iterator which points at the first tag will start a span of
comment|// decls that only contains tags.
if|if
condition|(
name|D
operator|->
name|hasTagIdentifierNamespace
argument_list|()
condition|)
name|Vec
operator|.
name|push_back
argument_list|(
name|D
argument_list|)
expr_stmt|;
comment|// Resolved using declarations go at the front of the list so that
comment|// they won't show up in other lookup results.  Unresolved using
comment|// declarations (which are always in IDNS_Using | IDNS_Ordinary)
comment|// follow that so that the using declarations will be contiguous.
elseif|else
if|if
condition|(
name|D
operator|->
name|getIdentifierNamespace
argument_list|()
operator|&
name|Decl
operator|::
name|IDNS_Using
condition|)
block|{
name|DeclsTy
operator|::
name|iterator
name|I
operator|=
name|Vec
operator|.
name|begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|D
operator|->
name|getIdentifierNamespace
argument_list|()
operator|!=
name|Decl
operator|::
name|IDNS_Using
condition|)
block|{
while|while
condition|(
name|I
operator|!=
name|Vec
operator|.
name|end
argument_list|()
operator|&&
operator|(
operator|*
name|I
operator|)
operator|->
name|getIdentifierNamespace
argument_list|()
operator|==
name|Decl
operator|::
name|IDNS_Using
condition|)
operator|++
name|I
expr_stmt|;
block|}
name|Vec
operator|.
name|insert
argument_list|(
name|I
argument_list|,
name|D
argument_list|)
expr_stmt|;
comment|// All other declarations go at the end of the list, but before any
comment|// tag declarations.  But we can be clever about tag declarations
comment|// because there can only ever be one in a scope.
block|}
elseif|else
if|if
condition|(
operator|!
name|Vec
operator|.
name|empty
argument_list|()
operator|&&
name|Vec
operator|.
name|back
argument_list|()
operator|->
name|hasTagIdentifierNamespace
argument_list|()
condition|)
block|{
name|NamedDecl
modifier|*
name|TagD
init|=
name|Vec
operator|.
name|back
argument_list|()
decl_stmt|;
name|Vec
operator|.
name|back
argument_list|()
operator|=
name|D
expr_stmt|;
name|Vec
operator|.
name|push_back
argument_list|(
name|TagD
argument_list|)
expr_stmt|;
block|}
else|else
name|Vec
operator|.
name|push_back
argument_list|(
name|D
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
unit|};
name|class
name|StoredDeclsMap
range|:
name|public
name|llvm
operator|::
name|SmallDenseMap
operator|<
name|DeclarationName
decl_stmt|,
name|StoredDeclsList
decl_stmt|, 4>
block|{
name|public
label|:
specifier|static
name|void
name|DestroyAll
parameter_list|(
name|StoredDeclsMap
modifier|*
name|Map
parameter_list|,
name|bool
name|Dependent
parameter_list|)
function_decl|;
name|private
label|:
name|friend
name|class
name|ASTContext
decl_stmt|;
comment|// walks the chain deleting these
name|friend
name|class
name|DeclContext
decl_stmt|;
name|llvm
operator|::
name|PointerIntPair
operator|<
name|StoredDeclsMap
operator|*
operator|,
literal|1
operator|>
name|Previous
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|DependentStoredDeclsMap
range|:
name|public
name|StoredDeclsMap
block|{
name|public
operator|:
name|DependentStoredDeclsMap
argument_list|()
operator|:
name|FirstDiagnostic
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|private
operator|:
name|friend
name|class
name|DependentDiagnostic
block|;
name|friend
name|class
name|DeclContext
block|;
comment|// iterates over diagnostics
name|DependentDiagnostic
operator|*
name|FirstDiagnostic
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

