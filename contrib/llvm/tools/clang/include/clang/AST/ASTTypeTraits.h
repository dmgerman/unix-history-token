begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ASTTypeTraits.h ----------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Provides a dynamic type identifier and a dynamically typed node container
end_comment

begin_comment
comment|//  that can be used to store an AST base node at runtime in the same storage in
end_comment

begin_comment
comment|//  a type safe way.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_ASTTYPETRAITS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_ASTTYPETRAITS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTFwd.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/NestedNameSpecifier.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Stmt.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateBase.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TypeLoc.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMapInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/AlignOf.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|raw_ostream
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
struct_decl|struct
name|PrintingPolicy
struct_decl|;
name|namespace
name|ast_type_traits
block|{
comment|/// \brief Kind identifier.
comment|///
comment|/// It can be constructed from any node kind and allows for runtime type
comment|/// hierarchy checks.
comment|/// Use getFromNodeKind<T>() to construct them.
name|class
name|ASTNodeKind
block|{
name|public
label|:
comment|/// \brief Empty identifier. It matches nothing.
name|ASTNodeKind
argument_list|()
operator|:
name|KindId
argument_list|(
argument|NKI_None
argument_list|)
block|{}
comment|/// \brief Construct an identifier for T.
name|template
operator|<
name|class
name|T
operator|>
specifier|static
name|ASTNodeKind
name|getFromNodeKind
argument_list|()
block|{
return|return
name|ASTNodeKind
argument_list|(
name|KindToKindId
operator|<
name|T
operator|>
operator|::
name|Id
argument_list|)
return|;
block|}
comment|/// \{
comment|/// \brief Construct an identifier for the dynamic type of the node
specifier|static
name|ASTNodeKind
name|getFromNode
parameter_list|(
specifier|const
name|Decl
modifier|&
name|D
parameter_list|)
function_decl|;
specifier|static
name|ASTNodeKind
name|getFromNode
parameter_list|(
specifier|const
name|Stmt
modifier|&
name|S
parameter_list|)
function_decl|;
specifier|static
name|ASTNodeKind
name|getFromNode
parameter_list|(
specifier|const
name|Type
modifier|&
name|T
parameter_list|)
function_decl|;
comment|/// \}
comment|/// \brief Returns \c true if \c this and \c Other represent the same kind.
name|bool
name|isSame
argument_list|(
name|ASTNodeKind
name|Other
argument_list|)
decl|const
block|{
return|return
name|KindId
operator|!=
name|NKI_None
operator|&&
name|KindId
operator|==
name|Other
operator|.
name|KindId
return|;
block|}
comment|/// \brief Returns \c true only for the default \c ASTNodeKind()
name|bool
name|isNone
argument_list|()
specifier|const
block|{
return|return
name|KindId
operator|==
name|NKI_None
return|;
block|}
comment|/// \brief Returns \c true if \c this is a base kind of (or same as) \c Other.
comment|/// \param Distance If non-null, used to return the distance between \c this
comment|/// and \c Other in the class hierarchy.
name|bool
name|isBaseOf
argument_list|(
name|ASTNodeKind
name|Other
argument_list|,
name|unsigned
operator|*
name|Distance
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief String representation of the kind.
name|StringRef
name|asStringRef
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Strict weak ordering for ASTNodeKind.
name|bool
name|operator
operator|<
operator|(
specifier|const
name|ASTNodeKind
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
name|KindId
operator|<
name|Other
operator|.
name|KindId
return|;
block|}
comment|/// \brief Return the most derived type between \p Kind1 and \p Kind2.
comment|///
comment|/// Return ASTNodeKind() if they are not related.
specifier|static
name|ASTNodeKind
name|getMostDerivedType
parameter_list|(
name|ASTNodeKind
name|Kind1
parameter_list|,
name|ASTNodeKind
name|Kind2
parameter_list|)
function_decl|;
comment|/// \brief Return the most derived common ancestor between Kind1 and Kind2.
comment|///
comment|/// Return ASTNodeKind() if they are not related.
specifier|static
name|ASTNodeKind
name|getMostDerivedCommonAncestor
parameter_list|(
name|ASTNodeKind
name|Kind1
parameter_list|,
name|ASTNodeKind
name|Kind2
parameter_list|)
function_decl|;
comment|/// \brief Hooks for using ASTNodeKind as a key in a DenseMap.
struct|struct
name|DenseMapInfo
block|{
comment|// ASTNodeKind() is a good empty key because it is represented as a 0.
specifier|static
specifier|inline
name|ASTNodeKind
name|getEmptyKey
parameter_list|()
block|{
return|return
name|ASTNodeKind
argument_list|()
return|;
block|}
comment|// NKI_NumberOfKinds is not a valid value, so it is good for a
comment|// tombstone key.
specifier|static
specifier|inline
name|ASTNodeKind
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|ASTNodeKind
argument_list|(
name|NKI_NumberOfKinds
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|ASTNodeKind
modifier|&
name|Val
parameter_list|)
block|{
return|return
name|Val
operator|.
name|KindId
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|ASTNodeKind
modifier|&
name|LHS
parameter_list|,
specifier|const
name|ASTNodeKind
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|.
name|KindId
operator|==
name|RHS
operator|.
name|KindId
return|;
block|}
block|}
struct|;
comment|/// Check if the given ASTNodeKind identifies a type that offers pointer
comment|/// identity. This is useful for the fast path in DynTypedNode.
name|bool
name|hasPointerIdentity
argument_list|()
specifier|const
block|{
return|return
name|KindId
operator|>
name|NKI_LastKindWithoutPointerIdentity
return|;
block|}
name|private
label|:
comment|/// \brief Kind ids.
comment|///
comment|/// Includes all possible base and derived kinds.
enum|enum
name|NodeKindId
block|{
name|NKI_None
block|,
name|NKI_TemplateArgument
block|,
name|NKI_NestedNameSpecifierLoc
block|,
name|NKI_QualType
block|,
name|NKI_TypeLoc
block|,
name|NKI_LastKindWithoutPointerIdentity
init|=
name|NKI_TypeLoc
block|,
name|NKI_CXXCtorInitializer
block|,
name|NKI_NestedNameSpecifier
block|,
name|NKI_Decl
block|,
define|#
directive|define
name|DECL
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|NKI_##DERIVED##Decl,
include|#
directive|include
file|"clang/AST/DeclNodes.inc"
name|NKI_Stmt
block|,
define|#
directive|define
name|STMT
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|NKI_##DERIVED,
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
name|NKI_Type
block|,
define|#
directive|define
name|TYPE
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|NKI_##DERIVED##Type,
include|#
directive|include
file|"clang/AST/TypeNodes.def"
name|NKI_NumberOfKinds
block|}
enum|;
comment|/// \brief Use getFromNodeKind<T>() to construct the kind.
name|ASTNodeKind
argument_list|(
argument|NodeKindId KindId
argument_list|)
block|:
name|KindId
argument_list|(
argument|KindId
argument_list|)
block|{}
comment|/// \brief Returns \c true if \c Base is a base kind of (or same as) \c
comment|///   Derived.
comment|/// \param Distance If non-null, used to return the distance between \c Base
comment|/// and \c Derived in the class hierarchy.
specifier|static
name|bool
name|isBaseOf
parameter_list|(
name|NodeKindId
name|Base
parameter_list|,
name|NodeKindId
name|Derived
parameter_list|,
name|unsigned
modifier|*
name|Distance
parameter_list|)
function_decl|;
comment|/// \brief Helper meta-function to convert a kind T to its enum value.
comment|///
comment|/// This struct is specialized below for all known kinds.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|KindToKindId
block|{
specifier|static
specifier|const
name|NodeKindId
name|Id
operator|=
name|NKI_None
block|;   }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|KindToKindId
operator|<
specifier|const
name|T
operator|>
operator|:
name|KindToKindId
operator|<
name|T
operator|>
block|{}
expr_stmt|;
comment|/// \brief Per kind info.
struct|struct
name|KindInfo
block|{
comment|/// \brief The id of the parent kind, or None if it has no parent.
name|NodeKindId
name|ParentId
decl_stmt|;
comment|/// \brief Name of the kind.
specifier|const
name|char
modifier|*
name|Name
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|KindInfo
name|AllKindInfo
index|[
name|NKI_NumberOfKinds
index|]
decl_stmt|;
name|NodeKindId
name|KindId
decl_stmt|;
block|}
empty_stmt|;
define|#
directive|define
name|KIND_TO_KIND_ID
parameter_list|(
name|Class
parameter_list|)
define|\
value|template<> struct ASTNodeKind::KindToKindId<Class> {                        \     static const NodeKindId Id = NKI_##Class;                                  \   };
name|KIND_TO_KIND_ID
argument_list|(
argument|CXXCtorInitializer
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|TemplateArgument
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|NestedNameSpecifier
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|NestedNameSpecifierLoc
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|QualType
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|TypeLoc
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|Decl
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|Stmt
argument_list|)
name|KIND_TO_KIND_ID
argument_list|(
argument|Type
argument_list|)
define|#
directive|define
name|DECL
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|KIND_TO_KIND_ID(DERIVED##Decl)
include|#
directive|include
file|"clang/AST/DeclNodes.inc"
define|#
directive|define
name|STMT
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|KIND_TO_KIND_ID(DERIVED)
include|#
directive|include
file|"clang/AST/StmtNodes.inc"
define|#
directive|define
name|TYPE
parameter_list|(
name|DERIVED
parameter_list|,
name|BASE
parameter_list|)
value|KIND_TO_KIND_ID(DERIVED##Type)
include|#
directive|include
file|"clang/AST/TypeNodes.def"
undef|#
directive|undef
name|KIND_TO_KIND_ID
specifier|inline
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
name|ASTNodeKind
name|K
operator|)
block|{
name|OS
operator|<<
name|K
operator|.
name|asStringRef
argument_list|()
block|;
return|return
name|OS
return|;
block|}
comment|/// \brief A dynamically typed AST node container.
comment|///
comment|/// Stores an AST node in a type safe way. This allows writing code that
comment|/// works with different kinds of AST nodes, despite the fact that they don't
comment|/// have a common base class.
comment|///
comment|/// Use \c create(Node) to create a \c DynTypedNode from an AST node,
comment|/// and \c get<T>() to retrieve the node as type T if the types match.
comment|///
comment|/// See \c ASTNodeKind for which node base types are currently supported;
comment|/// You can create DynTypedNodes for all nodes in the inheritance hierarchy of
comment|/// the supported base types.
name|class
name|DynTypedNode
block|{
name|public
label|:
comment|/// \brief Creates a \c DynTypedNode from \c Node.
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|DynTypedNode
name|create
argument_list|(
argument|const T&Node
argument_list|)
block|{
return|return
name|BaseConverter
operator|<
name|T
operator|>
operator|::
name|create
argument_list|(
name|Node
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the stored node as type \c T.
comment|///
comment|/// Returns NULL if the stored node does not have a type that is
comment|/// convertible to \c T.
comment|///
comment|/// For types that have identity via their pointer in the AST
comment|/// (like \c Stmt, \c Decl, \c Type and \c NestedNameSpecifier) the returned
comment|/// pointer points to the referenced AST node.
comment|/// For other types (like \c QualType) the value is stored directly
comment|/// in the \c DynTypedNode, and the returned pointer points at
comment|/// the storage inside DynTypedNode. For those nodes, do not
comment|/// use the pointer outside the scope of the DynTypedNode.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|BaseConverter
operator|<
name|T
operator|>
operator|::
name|get
argument_list|(
name|NodeKind
argument_list|,
name|Storage
operator|.
name|buffer
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the stored node as type \c T.
comment|///
comment|/// Similar to \c get(), but asserts that the type is what we are expecting.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|&
name|getUnchecked
argument_list|()
specifier|const
block|{
return|return
name|BaseConverter
operator|<
name|T
operator|>
operator|::
name|getUnchecked
argument_list|(
name|NodeKind
argument_list|,
name|Storage
operator|.
name|buffer
argument_list|)
return|;
block|}
name|ASTNodeKind
name|getNodeKind
argument_list|()
specifier|const
block|{
return|return
name|NodeKind
return|;
block|}
comment|/// \brief Returns a pointer that identifies the stored AST node.
comment|///
comment|/// Note that this is not supported by all AST nodes. For AST nodes
comment|/// that don't have a pointer-defined identity inside the AST, this
comment|/// method returns NULL.
specifier|const
name|void
operator|*
name|getMemoizationData
argument_list|()
specifier|const
block|{
return|return
name|NodeKind
operator|.
name|hasPointerIdentity
argument_list|()
operator|?
operator|*
name|reinterpret_cast
operator|<
name|void
operator|*
specifier|const
operator|*
operator|>
operator|(
name|Storage
operator|.
name|buffer
operator|)
operator|:
name|nullptr
return|;
block|}
comment|/// \brief Prints the node to the given output stream.
name|void
name|print
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|PrintingPolicy
operator|&
name|PP
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Dumps the node to the given output stream.
name|void
name|dump
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|OS
argument_list|,
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief For nodes which represent textual entities in the source code,
comment|/// return their SourceRange.  For all other nodes, return SourceRange().
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
expr_stmt|;
comment|/// @{
comment|/// \brief Imposes an order on \c DynTypedNode.
comment|///
comment|/// Supports comparison of nodes that support memoization.
comment|/// FIXME: Implement comparsion for other node types (currently
comment|/// only Stmt, Decl, Type and NestedNameSpecifier return memoization data).
name|bool
name|operator
operator|<
operator|(
specifier|const
name|DynTypedNode
operator|&
name|Other
operator|)
specifier|const
block|{
if|if
condition|(
operator|!
name|NodeKind
operator|.
name|isSame
argument_list|(
name|Other
operator|.
name|NodeKind
argument_list|)
condition|)
return|return
name|NodeKind
operator|<
name|Other
operator|.
name|NodeKind
return|;
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|QualType
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
name|getUnchecked
operator|<
name|QualType
operator|>
operator|(
operator|)
operator|.
name|getAsOpaquePtr
argument_list|()
operator|<
name|Other
operator|.
name|getUnchecked
operator|<
name|QualType
operator|>
operator|(
operator|)
operator|.
name|getAsOpaquePtr
argument_list|()
return|;
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
block|{
name|auto
name|TLA
init|=
name|getUnchecked
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|auto
name|TLB
init|=
name|Other
operator|.
name|getUnchecked
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|TLA
operator|.
name|getType
argument_list|()
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|TLA
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
operator|<
name|std
operator|::
name|make_pair
argument_list|(
name|TLB
operator|.
name|getType
argument_list|()
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|TLB
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
block|{
name|auto
name|NNSLA
init|=
name|getUnchecked
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
decl_stmt|;
name|auto
name|NNSLB
init|=
name|Other
operator|.
name|getUnchecked
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
decl_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|NNSLA
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|NNSLA
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
operator|<
name|std
operator|::
name|make_pair
argument_list|(
name|NNSLB
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|NNSLB
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
return|;
block|}
name|assert
argument_list|(
name|getMemoizationData
argument_list|()
operator|&&
name|Other
operator|.
name|getMemoizationData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getMemoizationData
argument_list|()
operator|<
name|Other
operator|.
name|getMemoizationData
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|DynTypedNode
operator|&
name|Other
operator|)
specifier|const
block|{
comment|// DynTypedNode::create() stores the exact kind of the node in NodeKind.
comment|// If they contain the same node, their NodeKind must be the same.
if|if
condition|(
operator|!
name|NodeKind
operator|.
name|isSame
argument_list|(
name|Other
operator|.
name|NodeKind
argument_list|)
condition|)
return|return
name|false
return|;
comment|// FIXME: Implement for other types.
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|QualType
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
name|getUnchecked
operator|<
name|QualType
operator|>
operator|(
operator|)
operator|==
name|Other
operator|.
name|getUnchecked
operator|<
name|QualType
operator|>
operator|(
operator|)
return|;
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
name|getUnchecked
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
operator|==
name|Other
operator|.
name|getUnchecked
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
return|;
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
name|getUnchecked
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
operator|==
name|Other
operator|.
name|getUnchecked
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
return|;
name|assert
argument_list|(
name|getMemoizationData
argument_list|()
operator|&&
name|Other
operator|.
name|getMemoizationData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getMemoizationData
argument_list|()
operator|==
name|Other
operator|.
name|getMemoizationData
argument_list|()
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|DynTypedNode
operator|&
name|Other
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|Other
operator|)
return|;
block|}
comment|/// @}
comment|/// \brief Hooks for using DynTypedNode as a key in a DenseMap.
struct|struct
name|DenseMapInfo
block|{
specifier|static
specifier|inline
name|DynTypedNode
name|getEmptyKey
parameter_list|()
block|{
name|DynTypedNode
name|Node
decl_stmt|;
name|Node
operator|.
name|NodeKind
operator|=
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|getEmptyKey
argument_list|()
expr_stmt|;
return|return
name|Node
return|;
block|}
specifier|static
specifier|inline
name|DynTypedNode
name|getTombstoneKey
parameter_list|()
block|{
name|DynTypedNode
name|Node
decl_stmt|;
name|Node
operator|.
name|NodeKind
operator|=
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|getTombstoneKey
argument_list|()
expr_stmt|;
return|return
name|Node
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|DynTypedNode
modifier|&
name|Val
parameter_list|)
block|{
comment|// FIXME: Add hashing support for the remaining types.
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|Val
operator|.
name|NodeKind
argument_list|)
condition|)
block|{
name|auto
name|TL
init|=
name|Val
operator|.
name|getUnchecked
operator|<
name|TypeLoc
operator|>
operator|(
operator|)
decl_stmt|;
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
name|TL
operator|.
name|getType
argument_list|()
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|TL
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|Val
operator|.
name|NodeKind
argument_list|)
condition|)
block|{
name|auto
name|NNSL
init|=
name|Val
operator|.
name|getUnchecked
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
operator|)
decl_stmt|;
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
name|NNSL
operator|.
name|getNestedNameSpecifier
argument_list|()
argument_list|,
name|NNSL
operator|.
name|getOpaqueData
argument_list|()
argument_list|)
return|;
block|}
name|assert
argument_list|(
name|Val
operator|.
name|getMemoizationData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|llvm
operator|::
name|hash_value
argument_list|(
name|Val
operator|.
name|getMemoizationData
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|DynTypedNode
modifier|&
name|LHS
parameter_list|,
specifier|const
name|DynTypedNode
modifier|&
name|RHS
parameter_list|)
block|{
name|auto
name|Empty
init|=
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|getEmptyKey
argument_list|()
decl_stmt|;
name|auto
name|TombStone
init|=
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|getTombstoneKey
argument_list|()
decl_stmt|;
return|return
operator|(
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|isEqual
argument_list|(
name|LHS
operator|.
name|NodeKind
argument_list|,
name|Empty
argument_list|)
operator|&&
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|isEqual
argument_list|(
name|RHS
operator|.
name|NodeKind
argument_list|,
name|Empty
argument_list|)
operator|)
operator|||
operator|(
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|isEqual
argument_list|(
name|LHS
operator|.
name|NodeKind
argument_list|,
name|TombStone
argument_list|)
operator|&&
name|ASTNodeKind
operator|::
name|DenseMapInfo
operator|::
name|isEqual
argument_list|(
name|RHS
operator|.
name|NodeKind
argument_list|,
name|TombStone
argument_list|)
operator|)
operator|||
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
struct|;
name|private
label|:
comment|/// \brief Takes care of converting from and to \c T.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|EnablerT
operator|=
name|void
operator|>
expr|struct
name|BaseConverter
expr_stmt|;
comment|/// \brief Converter that uses dyn_cast<T> from a stored BaseT*.
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|BaseT
operator|>
expr|struct
name|DynCastPtrConverter
block|{
specifier|static
specifier|const
name|T
operator|*
name|get
argument_list|(
argument|ASTNodeKind NodeKind
argument_list|,
argument|const char Storage[]
argument_list|)
block|{
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isBaseOf
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
operator|&
name|getUnchecked
argument_list|(
name|NodeKind
argument_list|,
name|Storage
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
specifier|static
specifier|const
name|T
modifier|&
name|getUnchecked
parameter_list|(
name|ASTNodeKind
name|NodeKind
parameter_list|,
specifier|const
name|char
name|Storage
index|[]
parameter_list|)
block|{
name|assert
argument_list|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isBaseOf
argument_list|(
name|NodeKind
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|cast
operator|<
name|T
operator|>
operator|(
name|static_cast
operator|<
specifier|const
name|BaseT
operator|*
operator|>
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|>
operator|(
name|Storage
operator|)
operator|)
operator|)
return|;
block|}
specifier|static
name|DynTypedNode
name|create
parameter_list|(
specifier|const
name|BaseT
modifier|&
name|Node
parameter_list|)
block|{
name|DynTypedNode
name|Result
decl_stmt|;
name|Result
operator|.
name|NodeKind
operator|=
name|ASTNodeKind
operator|::
name|getFromNode
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|new
argument_list|(
argument|Result.Storage.buffer
argument_list|)
specifier|const
name|void
operator|*
operator|(
operator|&
name|Node
operator|)
expr_stmt|;
return|return
name|Result
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Converter that stores T* (by pointer).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|PtrConverter
block|{
specifier|static
specifier|const
name|T
operator|*
name|get
argument_list|(
argument|ASTNodeKind NodeKind
argument_list|,
argument|const char Storage[]
argument_list|)
block|{
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
operator|&
name|getUnchecked
argument_list|(
name|NodeKind
argument_list|,
name|Storage
argument_list|)
return|;
return|return
name|nullptr
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|const
name|T
modifier|&
name|getUnchecked
parameter_list|(
name|ASTNodeKind
name|NodeKind
parameter_list|,
specifier|const
name|char
name|Storage
index|[]
parameter_list|)
block|{
name|assert
argument_list|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|static_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|>
operator|(
name|Storage
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|DynTypedNode
name|create
parameter_list|(
specifier|const
name|T
modifier|&
name|Node
parameter_list|)
block|{
name|DynTypedNode
name|Result
decl_stmt|;
name|Result
operator|.
name|NodeKind
operator|=
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|Result.Storage.buffer
argument_list|)
specifier|const
name|void
operator|*
operator|(
operator|&
name|Node
operator|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_comment
unit|};
comment|/// \brief Converter that stores T (by value).
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|ValueConverter
block|{
specifier|static
specifier|const
name|T
operator|*
name|get
argument_list|(
argument|ASTNodeKind NodeKind
argument_list|,
argument|const char Storage[]
argument_list|)
block|{
if|if
condition|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
condition|)
return|return
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|Storage
operator|)
return|;
return|return
name|nullptr
return|;
block|}
end_expr_stmt

begin_function
specifier|static
specifier|const
name|T
modifier|&
name|getUnchecked
parameter_list|(
name|ASTNodeKind
name|NodeKind
parameter_list|,
specifier|const
name|char
name|Storage
index|[]
parameter_list|)
block|{
name|assert
argument_list|(
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
operator|.
name|isSame
argument_list|(
name|NodeKind
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|T
operator|*
operator|>
operator|(
name|Storage
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|DynTypedNode
name|create
parameter_list|(
specifier|const
name|T
modifier|&
name|Node
parameter_list|)
block|{
name|DynTypedNode
name|Result
decl_stmt|;
name|Result
operator|.
name|NodeKind
operator|=
name|ASTNodeKind
operator|::
name|getFromNodeKind
operator|<
name|T
operator|>
operator|(
operator|)
expr_stmt|;
name|new
argument_list|(
argument|Result.Storage.buffer
argument_list|)
name|T
argument_list|(
name|Node
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_decl_stmt
unit|};
name|ASTNodeKind
name|NodeKind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Stores the data of the node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that we can store \c Decls, \c Stmts, \c Types,
end_comment

begin_comment
comment|/// \c NestedNameSpecifiers and \c CXXCtorInitializer by pointer as they are
end_comment

begin_comment
comment|/// guaranteed to be unique pointers pointing to dedicated storage in the AST.
end_comment

begin_comment
comment|/// \c QualTypes, \c NestedNameSpecifierLocs, \c TypeLocs and
end_comment

begin_comment
comment|/// \c TemplateArguments on the other hand do not have storage or unique
end_comment

begin_comment
comment|/// pointers and thus need to be stored by value.
end_comment

begin_expr_stmt
name|llvm
operator|::
name|AlignedCharArrayUnion
operator|<
specifier|const
name|void
operator|*
operator|,
name|TemplateArgument
operator|,
name|NestedNameSpecifierLoc
operator|,
name|QualType
operator|,
name|TypeLoc
operator|>
name|Storage
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|T
operator|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|Decl
operator|,
name|T
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
operator|:
name|public
name|DynCastPtrConverter
operator|<
name|T
operator|,
name|Decl
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|T
operator|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|Stmt
operator|,
name|T
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
operator|:
name|public
name|DynCastPtrConverter
operator|<
name|T
operator|,
name|Stmt
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|T
operator|,
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_base_of
operator|<
name|Type
operator|,
name|T
operator|>
operator|::
name|value
operator|>
operator|::
name|type
operator|>
operator|:
name|public
name|DynCastPtrConverter
operator|<
name|T
operator|,
name|Type
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|NestedNameSpecifier
operator|,
name|void
operator|>
operator|:
name|public
name|PtrConverter
operator|<
name|NestedNameSpecifier
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|CXXCtorInitializer
operator|,
name|void
operator|>
operator|:
name|public
name|PtrConverter
operator|<
name|CXXCtorInitializer
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|TemplateArgument
operator|,
name|void
operator|>
operator|:
name|public
name|ValueConverter
operator|<
name|TemplateArgument
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|NestedNameSpecifierLoc
operator|,
name|void
operator|>
operator|:
name|public
name|ValueConverter
operator|<
name|NestedNameSpecifierLoc
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|QualType
operator|,
name|void
operator|>
operator|:
name|public
name|ValueConverter
operator|<
name|QualType
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
operator|<
name|TypeLoc
operator|,
name|void
operator|>
operator|:
name|public
name|ValueConverter
operator|<
name|TypeLoc
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// The only operation we allow on unsupported types is \c get.
end_comment

begin_comment
comment|// This allows to conveniently use \c DynTypedNode when having an arbitrary
end_comment

begin_comment
comment|// AST node that is not supported, but prevents misuse - a user cannot create
end_comment

begin_comment
comment|// a DynTypedNode from arbitrary types.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|EnablerT
operator|>
expr|struct
name|DynTypedNode
operator|::
name|BaseConverter
block|{
specifier|static
specifier|const
name|T
operator|*
name|get
argument_list|(
argument|ASTNodeKind NodeKind
argument_list|,
argument|const char Storage[]
argument_list|)
block|{
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace ast_type_traits
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|clang
operator|::
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|>
operator|:
name|clang
operator|::
name|ast_type_traits
operator|::
name|ASTNodeKind
operator|::
name|DenseMapInfo
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|DenseMapInfo
operator|<
name|clang
operator|::
name|ast_type_traits
operator|::
name|DynTypedNode
operator|>
operator|:
name|clang
operator|::
name|ast_type_traits
operator|::
name|DynTypedNode
operator|::
name|DenseMapInfo
block|{}
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

