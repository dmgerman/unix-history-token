begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- CommentLexer.h - Lexer for structured comments ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines lexer for structured comments and supporting token class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_COMMENT_LEXER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_COMMENT_LEXER_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/SourceManager.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallString.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|comments
block|{
name|class
name|Lexer
decl_stmt|;
name|class
name|TextTokenRetokenizer
decl_stmt|;
name|class
name|CommandTraits
decl_stmt|;
name|namespace
name|tok
block|{
enum|enum
name|TokenKind
block|{
name|eof
block|,
name|newline
block|,
name|text
block|,
name|command
block|,
name|verbatim_block_begin
block|,
name|verbatim_block_line
block|,
name|verbatim_block_end
block|,
name|verbatim_line_name
block|,
name|verbatim_line_text
block|,
name|html_start_tag
block|,
comment|//<tag
name|html_ident
block|,
comment|// attr
name|html_equals
block|,
comment|// =
name|html_quoted_string
block|,
comment|// "blah\"blah" or 'blah\'blah'
name|html_greater
block|,
comment|//>
name|html_slash_greater
block|,
comment|// />
name|html_end_tag
comment|//</tag
block|}
enum|;
block|}
comment|// end namespace tok
name|class
name|CommentOptions
block|{
name|public
label|:
name|bool
name|Markdown
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief Comment token.
name|class
name|Token
block|{
name|friend
name|class
name|Lexer
decl_stmt|;
name|friend
name|class
name|TextTokenRetokenizer
decl_stmt|;
comment|/// The location of the token.
name|SourceLocation
name|Loc
decl_stmt|;
comment|/// The actual kind of the token.
name|tok
operator|::
name|TokenKind
name|Kind
expr_stmt|;
comment|/// Length of the token spelling in comment.  Can be 0 for synthenized
comment|/// tokens.
name|unsigned
name|Length
decl_stmt|;
comment|/// Contains text value associated with a token.
specifier|const
name|char
modifier|*
name|TextPtr1
decl_stmt|;
name|unsigned
name|TextLen1
decl_stmt|;
name|public
label|:
name|SourceLocation
name|getLocation
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Loc
return|;
block|}
name|void
name|setLocation
parameter_list|(
name|SourceLocation
name|SL
parameter_list|)
block|{
name|Loc
operator|=
name|SL
expr_stmt|;
block|}
name|SourceLocation
name|getEndLocation
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
if|if
condition|(
name|Length
operator|==
literal|0
operator|||
name|Length
operator|==
literal|1
condition|)
return|return
name|Loc
return|;
return|return
name|Loc
operator|.
name|getLocWithOffset
argument_list|(
name|Length
operator|-
literal|1
argument_list|)
return|;
block|}
name|tok
operator|::
name|TokenKind
name|getKind
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Kind
return|;
block|}
name|void
name|setKind
argument_list|(
name|tok
operator|::
name|TokenKind
name|K
argument_list|)
block|{
name|Kind
operator|=
name|K
expr_stmt|;
block|}
name|bool
name|is
argument_list|(
name|tok
operator|::
name|TokenKind
name|K
argument_list|)
decl|const
name|LLVM_READONLY
block|{
return|return
name|Kind
operator|==
name|K
return|;
block|}
name|bool
name|isNot
argument_list|(
name|tok
operator|::
name|TokenKind
name|K
argument_list|)
decl|const
name|LLVM_READONLY
block|{
return|return
name|Kind
operator|!=
name|K
return|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Length
return|;
block|}
name|void
name|setLength
parameter_list|(
name|unsigned
name|L
parameter_list|)
block|{
name|Length
operator|=
name|L
expr_stmt|;
block|}
name|StringRef
name|getText
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|text
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setText
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Text
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Text
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getCommandName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|command
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setCommandName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getVerbatimBlockName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_begin
argument_list|)
operator|||
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_end
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setVerbatimBlockName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_begin
argument_list|)
operator|||
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_end
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getVerbatimBlockText
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_line
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setVerbatimBlockText
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_block_line
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Text
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Text
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/// Returns the name of verbatim line command.
name|StringRef
name|getVerbatimLineName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_line_name
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setVerbatimLineName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_line_name
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getVerbatimLineText
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_line_text
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setVerbatimLineText
parameter_list|(
name|StringRef
name|Text
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|verbatim_line_text
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Text
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Text
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getHTMLTagStartName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_start_tag
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setHTMLTagStartName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_start_tag
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getHTMLIdent
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_ident
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setHTMLIdent
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_ident
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getHTMLQuotedString
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_quoted_string
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setHTMLQuotedString
parameter_list|(
name|StringRef
name|Str
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_quoted_string
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Str
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Str
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|StringRef
name|getHTMLTagEndName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_end_tag
argument_list|)
argument_list|)
block|;
return|return
name|StringRef
argument_list|(
name|TextPtr1
argument_list|,
name|TextLen1
argument_list|)
return|;
block|}
name|void
name|setHTMLTagEndName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|assert
argument_list|(
name|is
argument_list|(
name|tok
operator|::
name|html_end_tag
argument_list|)
argument_list|)
expr_stmt|;
name|TextPtr1
operator|=
name|Name
operator|.
name|data
argument_list|()
expr_stmt|;
name|TextLen1
operator|=
name|Name
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|void
name|dump
argument_list|(
specifier|const
name|Lexer
operator|&
name|L
argument_list|,
specifier|const
name|SourceManager
operator|&
name|SM
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief Comment lexer.
name|class
name|Lexer
block|{
name|private
label|:
name|Lexer
argument_list|(
specifier|const
name|Lexer
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|Lexer
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
comment|/// Allocator for strings that are semantic values of tokens and have to be
comment|/// computed (for example, resolved decimal character references).
name|llvm
operator|::
name|BumpPtrAllocator
operator|&
name|Allocator
expr_stmt|;
specifier|const
name|CommandTraits
modifier|&
name|Traits
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|BufferStart
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|BufferEnd
decl_stmt|;
name|SourceLocation
name|FileLoc
decl_stmt|;
name|CommentOptions
name|CommOpts
decl_stmt|;
specifier|const
name|char
modifier|*
name|BufferPtr
decl_stmt|;
comment|/// One past end pointer for the current comment.  For BCPL comments points
comment|/// to newline or BufferEnd, for C comments points to star in '*/'.
specifier|const
name|char
modifier|*
name|CommentEnd
decl_stmt|;
enum|enum
name|LexerCommentState
block|{
name|LCS_BeforeComment
block|,
name|LCS_InsideBCPLComment
block|,
name|LCS_InsideCComment
block|,
name|LCS_BetweenComments
block|}
enum|;
comment|/// Low-level lexer state, track if we are inside or outside of comment.
name|LexerCommentState
name|CommentState
decl_stmt|;
enum|enum
name|LexerState
block|{
comment|/// Lexing normal comment text
name|LS_Normal
block|,
comment|/// Finished lexing verbatim block beginning command, will lex first body
comment|/// line.
name|LS_VerbatimBlockFirstLine
block|,
comment|/// Lexing verbatim block body line-by-line, skipping line-starting
comment|/// decorations.
name|LS_VerbatimBlockBody
block|,
comment|/// Finished lexing verbatim line beginning command, will lex text (one
comment|/// line).
name|LS_VerbatimLineText
block|,
comment|/// Finished lexing \verbatim<TAG \endverbatim part, lexing tag attributes.
name|LS_HTMLStartTag
block|,
comment|/// Finished lexing \verbatim</TAG \endverbatim part, lexing '>'.
name|LS_HTMLEndTag
block|}
enum|;
comment|/// Current lexing mode.
name|LexerState
name|State
decl_stmt|;
comment|/// If State is LS_VerbatimBlock, contains the name of verbatim end
comment|/// command, including command marker.
name|SmallString
operator|<
literal|16
operator|>
name|VerbatimBlockEndCommandName
expr_stmt|;
comment|/// Given a character reference name (e.g., "lt"), return the character that
comment|/// it stands for (e.g., "<").
name|StringRef
name|resolveHTMLNamedCharacterReference
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
decl_stmt|;
comment|/// Given a Unicode codepoint as base-10 integer, return the character.
name|StringRef
name|resolveHTMLDecimalCharacterReference
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
decl_stmt|;
comment|/// Given a Unicode codepoint as base-16 integer, return the character.
name|StringRef
name|resolveHTMLHexCharacterReference
argument_list|(
name|StringRef
name|Name
argument_list|)
decl|const
decl_stmt|;
name|void
name|formTokenWithChars
argument_list|(
name|Token
operator|&
name|Result
argument_list|,
specifier|const
name|char
operator|*
name|TokEnd
argument_list|,
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
block|{
specifier|const
name|unsigned
name|TokLen
init|=
name|TokEnd
operator|-
name|BufferPtr
decl_stmt|;
name|Result
operator|.
name|setLocation
argument_list|(
name|getSourceLocation
argument_list|(
name|BufferPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Result
operator|.
name|setKind
argument_list|(
name|Kind
argument_list|)
expr_stmt|;
name|Result
operator|.
name|setLength
argument_list|(
name|TokLen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|Result
operator|.
name|TextPtr1
operator|=
literal|"<UNSET>"
expr_stmt|;
name|Result
operator|.
name|TextLen1
operator|=
literal|7
expr_stmt|;
endif|#
directive|endif
name|BufferPtr
operator|=
name|TokEnd
expr_stmt|;
block|}
name|void
name|formTextToken
parameter_list|(
name|Token
modifier|&
name|Result
parameter_list|,
specifier|const
name|char
modifier|*
name|TokEnd
parameter_list|)
block|{
name|StringRef
name|Text
argument_list|(
name|BufferPtr
argument_list|,
name|TokEnd
operator|-
name|BufferPtr
argument_list|)
decl_stmt|;
name|formTokenWithChars
argument_list|(
name|Result
argument_list|,
name|TokEnd
argument_list|,
name|tok
operator|::
name|text
argument_list|)
expr_stmt|;
name|Result
operator|.
name|setText
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
name|SourceLocation
name|getSourceLocation
argument_list|(
specifier|const
name|char
operator|*
name|Loc
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Loc
operator|>=
name|BufferStart
operator|&&
name|Loc
operator|<=
name|BufferEnd
operator|&&
literal|"Location out of range for this buffer!"
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|CharNo
init|=
name|Loc
operator|-
name|BufferStart
decl_stmt|;
return|return
name|FileLoc
operator|.
name|getLocWithOffset
argument_list|(
name|CharNo
argument_list|)
return|;
block|}
comment|/// Eat string matching regexp \code \s*\* \endcode.
name|void
name|skipLineStartingDecorations
parameter_list|()
function_decl|;
comment|/// Lex stuff inside comments.  CommentEnd should be set correctly.
name|void
name|lexCommentText
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|setupAndLexVerbatimBlock
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|,
specifier|const
name|char
modifier|*
name|TextBegin
parameter_list|,
name|char
name|Marker
parameter_list|,
name|StringRef
name|EndName
parameter_list|)
function_decl|;
name|void
name|lexVerbatimBlockFirstLine
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|lexVerbatimBlockBody
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|setupAndLexVerbatimLine
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|,
specifier|const
name|char
modifier|*
name|TextBegin
parameter_list|)
function_decl|;
name|void
name|lexVerbatimLineText
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|lexHTMLCharacterReference
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|setupAndLexHTMLStartTag
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|lexHTMLStartTag
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|setupAndLexHTMLEndTag
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|void
name|lexHTMLEndTag
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|public
label|:
name|Lexer
argument_list|(
argument|llvm::BumpPtrAllocator&Allocator
argument_list|,
argument|const CommandTraits&Traits
argument_list|,
argument|SourceLocation FileLoc
argument_list|,
argument|const CommentOptions&CommOpts
argument_list|,
argument|const char *BufferStart
argument_list|,
argument|const char *BufferEnd
argument_list|)
empty_stmt|;
name|void
name|lex
parameter_list|(
name|Token
modifier|&
name|T
parameter_list|)
function_decl|;
name|StringRef
name|getSpelling
argument_list|(
specifier|const
name|Token
operator|&
name|Tok
argument_list|,
specifier|const
name|SourceManager
operator|&
name|SourceMgr
argument_list|,
name|bool
operator|*
name|Invalid
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace comments
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

