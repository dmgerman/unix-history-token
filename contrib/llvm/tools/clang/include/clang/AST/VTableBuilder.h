begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- VTableBuilder.h - C++ vtable layout builder --------------*- C++ -*-=//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This contains code dealing with generation of the layout of virtual tables.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_VTABLEBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_VTABLEBUILDER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/BaseSubobject.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/CXXInheritance.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/GlobalDecl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/RecordLayout.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/ABI.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|CXXRecordDecl
decl_stmt|;
comment|/// \brief Represents a single component in a vtable.
name|class
name|VTableComponent
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|CK_VCallOffset
block|,
name|CK_VBaseOffset
block|,
name|CK_OffsetToTop
block|,
name|CK_RTTI
block|,
name|CK_FunctionPointer
block|,
comment|/// \brief A pointer to the complete destructor.
name|CK_CompleteDtorPointer
block|,
comment|/// \brief A pointer to the deleting destructor.
name|CK_DeletingDtorPointer
block|,
comment|/// \brief An entry that is never used.
comment|///
comment|/// In some cases, a vtable function pointer will end up never being
comment|/// called. Such vtable function pointers are represented as a
comment|/// CK_UnusedFunctionPointer.
name|CK_UnusedFunctionPointer
block|}
enum|;
name|VTableComponent
argument_list|()
operator|=
expr|default
expr_stmt|;
specifier|static
name|VTableComponent
name|MakeVCallOffset
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_VCallOffset
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeVBaseOffset
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_VBaseOffset
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeOffsetToTop
parameter_list|(
name|CharUnits
name|Offset
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_OffsetToTop
argument_list|,
name|Offset
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeRTTI
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_RTTI
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|RD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeFunction
parameter_list|(
specifier|const
name|CXXMethodDecl
modifier|*
name|MD
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|MD
operator|)
operator|&&
literal|"Don't use MakeFunction with destructors!"
argument_list|)
expr_stmt|;
return|return
name|VTableComponent
argument_list|(
name|CK_FunctionPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|MD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeCompleteDtor
parameter_list|(
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_CompleteDtorPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|DD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeDeletingDtor
parameter_list|(
specifier|const
name|CXXDestructorDecl
modifier|*
name|DD
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|CK_DeletingDtorPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|DD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|MakeUnusedFunction
parameter_list|(
specifier|const
name|CXXMethodDecl
modifier|*
name|MD
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|MD
operator|)
operator|&&
literal|"Don't use MakeUnusedFunction with destructors!"
argument_list|)
expr_stmt|;
return|return
name|VTableComponent
argument_list|(
name|CK_UnusedFunctionPointer
argument_list|,
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|MD
operator|)
argument_list|)
return|;
block|}
specifier|static
name|VTableComponent
name|getFromOpaqueInteger
parameter_list|(
name|uint64_t
name|I
parameter_list|)
block|{
return|return
name|VTableComponent
argument_list|(
name|I
argument_list|)
return|;
block|}
comment|/// \brief Get the kind of this vtable component.
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
call|(
name|Kind
call|)
argument_list|(
name|Value
operator|&
literal|0x7
argument_list|)
return|;
block|}
name|CharUnits
name|getVCallOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_VCallOffset
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
name|CharUnits
name|getVBaseOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_VBaseOffset
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
name|CharUnits
name|getOffsetToTop
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_OffsetToTop
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|getOffset
argument_list|()
return|;
block|}
specifier|const
name|CXXRecordDecl
operator|*
name|getRTTIDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isRTTIKind
argument_list|()
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXRecordDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXMethodDecl
operator|*
name|getFunctionDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isFunctionPointerKind
argument_list|()
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
if|if
condition|(
name|isDestructorKind
argument_list|()
condition|)
return|return
name|getDestructorDecl
argument_list|()
return|;
return|return
name|reinterpret_cast
operator|<
name|CXXMethodDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXDestructorDecl
operator|*
name|getDestructorDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDestructorKind
argument_list|()
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXDestructorDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
specifier|const
name|CXXMethodDecl
operator|*
name|getUnusedFunctionDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|CK_UnusedFunctionPointer
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|CXXMethodDecl
operator|*
operator|>
operator|(
name|getPointer
argument_list|()
operator|)
return|;
block|}
name|bool
name|isDestructorKind
argument_list|()
specifier|const
block|{
return|return
name|isDestructorKind
argument_list|(
name|getKind
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isUsedFunctionPointerKind
argument_list|()
specifier|const
block|{
return|return
name|isUsedFunctionPointerKind
argument_list|(
name|getKind
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isFunctionPointerKind
argument_list|()
specifier|const
block|{
return|return
name|isFunctionPointerKind
argument_list|(
name|getKind
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|isRTTIKind
argument_list|()
specifier|const
block|{
return|return
name|isRTTIKind
argument_list|(
name|getKind
argument_list|()
argument_list|)
return|;
block|}
name|GlobalDecl
name|getGlobalDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isUsedFunctionPointerKind
argument_list|()
operator|&&
literal|"GlobalDecl can be created only from virtual function"
argument_list|)
block|;
name|auto
operator|*
name|DtorDecl
operator|=
name|dyn_cast
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|getFunctionDecl
argument_list|()
operator|)
block|;
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CK_FunctionPointer
case|:
return|return
name|GlobalDecl
argument_list|(
name|getFunctionDecl
argument_list|()
argument_list|)
return|;
case|case
name|CK_CompleteDtorPointer
case|:
return|return
name|GlobalDecl
argument_list|(
name|DtorDecl
argument_list|,
name|CXXDtorType
operator|::
name|Dtor_Complete
argument_list|)
return|;
case|case
name|CK_DeletingDtorPointer
case|:
return|return
name|GlobalDecl
argument_list|(
name|DtorDecl
argument_list|,
name|CXXDtorType
operator|::
name|Dtor_Deleting
argument_list|)
return|;
case|case
name|CK_VCallOffset
case|:
case|case
name|CK_VBaseOffset
case|:
case|case
name|CK_OffsetToTop
case|:
case|case
name|CK_RTTI
case|:
case|case
name|CK_UnusedFunctionPointer
case|:
name|llvm_unreachable
argument_list|(
literal|"Only function pointers kinds"
argument_list|)
expr_stmt|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Should already return"
argument_list|)
expr_stmt|;
block|}
name|private
operator|:
specifier|static
name|bool
name|isFunctionPointerKind
argument_list|(
argument|Kind ComponentKind
argument_list|)
block|{
return|return
name|isUsedFunctionPointerKind
argument_list|(
name|ComponentKind
argument_list|)
operator|||
name|ComponentKind
operator|==
name|CK_UnusedFunctionPointer
return|;
block|}
specifier|static
name|bool
name|isUsedFunctionPointerKind
parameter_list|(
name|Kind
name|ComponentKind
parameter_list|)
block|{
return|return
name|ComponentKind
operator|==
name|CK_FunctionPointer
operator|||
name|isDestructorKind
argument_list|(
name|ComponentKind
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isDestructorKind
parameter_list|(
name|Kind
name|ComponentKind
parameter_list|)
block|{
return|return
name|ComponentKind
operator|==
name|CK_CompleteDtorPointer
operator|||
name|ComponentKind
operator|==
name|CK_DeletingDtorPointer
return|;
block|}
specifier|static
name|bool
name|isRTTIKind
parameter_list|(
name|Kind
name|ComponentKind
parameter_list|)
block|{
return|return
name|ComponentKind
operator|==
name|CK_RTTI
return|;
block|}
name|VTableComponent
argument_list|(
argument|Kind ComponentKind
argument_list|,
argument|CharUnits Offset
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|ComponentKind
operator|==
name|CK_VCallOffset
operator|||
name|ComponentKind
operator|==
name|CK_VBaseOffset
operator|||
name|ComponentKind
operator|==
name|CK_OffsetToTop
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
operator|<
operator|(
literal|1LL
operator|<<
literal|56
operator|)
operator|&&
literal|"Offset is too big!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
operator|>=
operator|-
operator|(
literal|1LL
operator|<<
literal|56
operator|)
operator|&&
literal|"Offset is too small!"
argument_list|)
expr_stmt|;
name|Value
operator|=
operator|(
name|uint64_t
argument_list|(
name|Offset
operator|.
name|getQuantity
argument_list|()
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|ComponentKind
expr_stmt|;
block|}
name|VTableComponent
argument_list|(
argument|Kind ComponentKind
argument_list|,
argument|uintptr_t Ptr
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|isRTTIKind
argument_list|(
name|ComponentKind
argument_list|)
operator|||
name|isFunctionPointerKind
argument_list|(
name|ComponentKind
argument_list|)
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|Ptr
operator|&
literal|7
operator|)
operator|==
literal|0
operator|&&
literal|"Pointer not sufficiently aligned!"
argument_list|)
expr_stmt|;
name|Value
operator|=
name|Ptr
operator||
name|ComponentKind
expr_stmt|;
block|}
name|CharUnits
name|getOffset
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getKind
argument_list|()
operator|==
name|CK_VCallOffset
operator|||
name|getKind
argument_list|()
operator|==
name|CK_VBaseOffset
operator|||
name|getKind
argument_list|()
operator|==
name|CK_OffsetToTop
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|CharUnits
operator|::
name|fromQuantity
argument_list|(
name|Value
operator|>>
literal|3
argument_list|)
return|;
block|}
name|uintptr_t
name|getPointer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|getKind
argument_list|()
operator|==
name|CK_RTTI
operator|||
name|isFunctionPointerKind
argument_list|()
operator|)
operator|&&
literal|"Invalid component kind!"
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Value
operator|&
operator|~
literal|7ULL
operator|)
return|;
block|}
name|explicit
name|VTableComponent
argument_list|(
argument|uint64_t Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
comment|/// The kind is stored in the lower 3 bits of the value. For offsets, we
comment|/// make use of the facts that classes can't be larger than 2^55 bytes,
comment|/// so we store the offset in the lower part of the 61 bits that remain.
comment|/// (The reason that we're not simply using a PointerIntPair here is that we
comment|/// need the offsets to be 64-bit, even when on a 32-bit machine).
name|int64_t
name|Value
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|VTableLayout
block|{
name|public
label|:
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|ThunkInfo
operator|>
name|VTableThunkTy
expr_stmt|;
struct|struct
name|AddressPointLocation
block|{
name|unsigned
name|VTableIndex
decl_stmt|,
name|AddressPointIndex
decl_stmt|;
block|}
struct|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|BaseSubobject
operator|,
name|AddressPointLocation
operator|>
name|AddressPointsMapTy
expr_stmt|;
name|private
label|:
comment|// Stores the component indices of the first component of each virtual table in
comment|// the virtual table group. To save a little memory in the common case where
comment|// the vtable group contains a single vtable, an empty vector here represents
comment|// the vector {0}.
name|OwningArrayRef
operator|<
name|size_t
operator|>
name|VTableIndices
expr_stmt|;
name|OwningArrayRef
operator|<
name|VTableComponent
operator|>
name|VTableComponents
expr_stmt|;
comment|/// \brief Contains thunks needed by vtables, sorted by indices.
name|OwningArrayRef
operator|<
name|VTableThunkTy
operator|>
name|VTableThunks
expr_stmt|;
comment|/// \brief Address points for all vtables.
name|AddressPointsMapTy
name|AddressPoints
decl_stmt|;
name|public
label|:
name|VTableLayout
argument_list|(
name|ArrayRef
operator|<
name|size_t
operator|>
name|VTableIndices
argument_list|,
name|ArrayRef
operator|<
name|VTableComponent
operator|>
name|VTableComponents
argument_list|,
name|ArrayRef
operator|<
name|VTableThunkTy
operator|>
name|VTableThunks
argument_list|,
specifier|const
name|AddressPointsMapTy
operator|&
name|AddressPoints
argument_list|)
expr_stmt|;
operator|~
name|VTableLayout
argument_list|()
expr_stmt|;
name|ArrayRef
operator|<
name|VTableComponent
operator|>
name|vtable_components
argument_list|()
specifier|const
block|{
return|return
name|VTableComponents
return|;
block|}
name|ArrayRef
operator|<
name|VTableThunkTy
operator|>
name|vtable_thunks
argument_list|()
specifier|const
block|{
return|return
name|VTableThunks
return|;
block|}
name|AddressPointLocation
name|getAddressPoint
argument_list|(
name|BaseSubobject
name|Base
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|AddressPoints
operator|.
name|count
argument_list|(
name|Base
argument_list|)
operator|&&
literal|"Did not find address point!"
argument_list|)
expr_stmt|;
return|return
name|AddressPoints
operator|.
name|find
argument_list|(
name|Base
argument_list|)
operator|->
name|second
return|;
block|}
specifier|const
name|AddressPointsMapTy
operator|&
name|getAddressPoints
argument_list|()
specifier|const
block|{
return|return
name|AddressPoints
return|;
block|}
name|size_t
name|getNumVTables
argument_list|()
specifier|const
block|{
if|if
condition|(
name|VTableIndices
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|1
return|;
return|return
name|VTableIndices
operator|.
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_t
name|getVTableOffset
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
if|if
condition|(
name|VTableIndices
operator|.
name|empty
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|VTableIndices
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_t
name|getVTableSize
argument_list|(
name|size_t
name|i
argument_list|)
decl|const
block|{
if|if
condition|(
name|VTableIndices
operator|.
name|empty
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|vtable_components
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
name|size_t
name|thisIndex
init|=
name|VTableIndices
index|[
name|i
index|]
decl_stmt|;
name|size_t
name|nextIndex
init|=
operator|(
name|i
operator|+
literal|1
operator|==
name|VTableIndices
operator|.
name|size
argument_list|()
operator|)
condition|?
name|vtable_components
argument_list|()
operator|.
name|size
argument_list|()
else|:
name|VTableIndices
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
return|return
name|nextIndex
operator|-
name|thisIndex
return|;
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|VTableContextBase
block|{
name|public
label|:
typedef|typedef
name|SmallVector
operator|<
name|ThunkInfo
operator|,
literal|1
operator|>
name|ThunkInfoVectorTy
expr_stmt|;
name|bool
name|isMicrosoft
argument_list|()
specifier|const
block|{
return|return
name|IsMicrosoftABI
return|;
block|}
name|virtual
operator|~
name|VTableContextBase
argument_list|()
block|{}
name|protected
operator|:
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXMethodDecl
operator|*
operator|,
name|ThunkInfoVectorTy
operator|>
name|ThunksMapTy
expr_stmt|;
comment|/// \brief Contains all thunks that a given method decl will need.
name|ThunksMapTy
name|Thunks
decl_stmt|;
comment|/// Compute and store all vtable related information (vtable layout, vbase
comment|/// offset offsets, thunks etc) for the given record decl.
name|virtual
name|void
name|computeVTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
init|=
literal|0
function_decl|;
name|VTableContextBase
argument_list|(
argument|bool MS
argument_list|)
block|:
name|IsMicrosoftABI
argument_list|(
argument|MS
argument_list|)
block|{}
name|public
label|:
name|virtual
specifier|const
name|ThunkInfoVectorTy
modifier|*
name|getThunkInfo
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
block|{
specifier|const
name|CXXMethodDecl
modifier|*
name|MD
init|=
name|cast
operator|<
name|CXXMethodDecl
operator|>
operator|(
name|GD
operator|.
name|getDecl
argument_list|()
operator|->
name|getCanonicalDecl
argument_list|()
operator|)
decl_stmt|;
name|computeVTableRelatedInformation
argument_list|(
name|MD
operator|->
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
comment|// This assumes that all the destructors present in the vtable
comment|// use exactly the same set of thunks.
name|ThunksMapTy
operator|::
name|const_iterator
name|I
operator|=
name|Thunks
operator|.
name|find
argument_list|(
name|MD
argument_list|)
expr_stmt|;
if|if
condition|(
name|I
operator|==
name|Thunks
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// We did not find a thunk for this method.
return|return
name|nullptr
return|;
block|}
return|return
operator|&
name|I
operator|->
name|second
return|;
block|}
name|bool
name|IsMicrosoftABI
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|ItaniumVTableContext
range|:
name|public
name|VTableContextBase
block|{
name|private
operator|:
comment|/// \brief Contains the index (relative to the vtable address point)
comment|/// where the function pointer for a virtual function is stored.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|GlobalDecl
operator|,
name|int64_t
operator|>
name|MethodVTableIndicesTy
expr_stmt|;
name|MethodVTableIndicesTy
name|MethodVTableIndices
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
specifier|const
name|VTableLayout
operator|>>
name|VTableLayoutMapTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VTableLayoutMapTy
name|VTableLayouts
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
specifier|const
name|CXXRecordDecl
operator|*
operator|>
name|ClassPairTy
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief vtable offsets for offsets of virtual bases of a class.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Contains the vtable offset (relative to the address point) in chars
end_comment

begin_comment
comment|/// where the offsets for virtual bases of a class are stored.
end_comment

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|ClassPairTy
operator|,
name|CharUnits
operator|>
name|VirtualBaseClassOffsetOffsetsMapTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VirtualBaseClassOffsetOffsetsMapTy
name|VirtualBaseClassOffsetOffsets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|computeVTableRelatedInformation
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|RD
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|ItaniumVTableContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|ItaniumVTableContext
argument_list|()
name|override
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|VTableLayout
modifier|&
name|getVTableLayout
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
block|{
name|computeVTableRelatedInformation
argument_list|(
name|RD
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|VTableLayouts
operator|.
name|count
argument_list|(
name|RD
argument_list|)
operator|&&
literal|"No layout for this record decl!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|VTableLayouts
index|[
name|RD
index|]
return|;
block|}
end_function

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|VTableLayout
operator|>
name|createConstructionVTableLayout
argument_list|(
argument|const CXXRecordDecl *MostDerivedClass
argument_list|,
argument|CharUnits MostDerivedClassOffset
argument_list|,
argument|bool MostDerivedClassIsVirtual
argument_list|,
argument|const CXXRecordDecl *LayoutClass
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Locate a virtual function in the vtable.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Return the index (relative to the vtable address point) where the
end_comment

begin_comment
comment|/// function pointer for the given virtual function is stored.
end_comment

begin_function_decl
name|uint64_t
name|getMethodVTableIndex
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Return the offset in chars (relative to the vtable address point) where
end_comment

begin_comment
comment|/// the offset of the virtual base that contains the given base is stored,
end_comment

begin_comment
comment|/// otherwise, if no virtual base contains the given class, return 0.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Base must be a virtual base class or an unambiguous base.
end_comment

begin_function_decl
name|CharUnits
name|getVirtualBaseOffsetOffset
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|VBase
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|VTableContextBase
modifier|*
name|VT
parameter_list|)
block|{
return|return
operator|!
name|VT
operator|->
name|isMicrosoft
argument_list|()
return|;
block|}
end_function

begin_comment
unit|};
comment|/// Holds information about the inheritance path to a virtual base or function
end_comment

begin_comment
comment|/// table pointer.  A record may contain as many vfptrs or vbptrs as there are
end_comment

begin_comment
comment|/// base subobjects.
end_comment

begin_struct
struct|struct
name|VPtrInfo
block|{
typedef|typedef
name|SmallVector
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
literal|1
operator|>
name|BasePath
expr_stmt|;
name|VPtrInfo
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|RD
argument_list|)
operator|:
name|ObjectWithVPtr
argument_list|(
name|RD
argument_list|)
operator|,
name|IntroducingObject
argument_list|(
name|RD
argument_list|)
operator|,
name|NextBaseToMangle
argument_list|(
argument|RD
argument_list|)
block|{}
comment|/// This is the most derived class that has this vptr at offset zero. When
comment|/// single inheritance is used, this is always the most derived class. If
comment|/// multiple inheritance is used, it may be any direct or indirect base.
specifier|const
name|CXXRecordDecl
operator|*
name|ObjectWithVPtr
expr_stmt|;
comment|/// This is the class that introduced the vptr by declaring new virtual
comment|/// methods or virtual bases.
specifier|const
name|CXXRecordDecl
modifier|*
name|IntroducingObject
decl_stmt|;
comment|/// IntroducingObject is at this offset from its containing complete object or
comment|/// virtual base.
name|CharUnits
name|NonVirtualOffset
decl_stmt|;
comment|/// The bases from the inheritance path that got used to mangle the vbtable
comment|/// name.  This is not really a full path like a CXXBasePath.  It holds the
comment|/// subset of records that need to be mangled into the vbtable symbol name in
comment|/// order to get a unique name.
name|BasePath
name|MangledPath
decl_stmt|;
comment|/// The next base to push onto the mangled path if this path is ambiguous in a
comment|/// derived class.  If it's null, then it's already been pushed onto the path.
specifier|const
name|CXXRecordDecl
modifier|*
name|NextBaseToMangle
decl_stmt|;
comment|/// The set of possibly indirect vbases that contain this vbtable.  When a
comment|/// derived class indirectly inherits from the same vbase twice, we only keep
comment|/// vtables and their paths from the first instance.
name|BasePath
name|ContainingVBases
decl_stmt|;
comment|/// This holds the base classes path from the complete type to the first base
comment|/// with the given vfptr offset, in the base-to-derived order.  Only used for
comment|/// vftables.
name|BasePath
name|PathToIntroducingObject
decl_stmt|;
comment|/// Static offset from the top of the most derived class to this vfptr,
comment|/// including any virtual base offset.  Only used for vftables.
name|CharUnits
name|FullOffsetInMDC
decl_stmt|;
comment|/// The vptr is stored inside the non-virtual component of this virtual base.
specifier|const
name|CXXRecordDecl
operator|*
name|getVBaseWithVPtr
argument_list|()
specifier|const
block|{
return|return
name|ContainingVBases
operator|.
name|empty
argument_list|()
operator|?
name|nullptr
operator|:
name|ContainingVBases
operator|.
name|front
argument_list|()
return|;
block|}
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|SmallVector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|VPtrInfo
operator|>
operator|,
literal|2
operator|>
name|VPtrInfoVector
expr_stmt|;
end_typedef

begin_comment
comment|/// All virtual base related information about a given record decl.  Includes
end_comment

begin_comment
comment|/// information on all virtual base tables and the path components that are used
end_comment

begin_comment
comment|/// to mangle them.
end_comment

begin_struct
struct|struct
name|VirtualBaseInfo
block|{
comment|/// A map from virtual base to vbtable index for doing a conversion from the
comment|/// the derived class to the a base.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|unsigned
operator|>
name|VBTableIndices
expr_stmt|;
comment|/// Information on all virtual base tables used when this record is the most
comment|/// derived class.
name|VPtrInfoVector
name|VBPtrPaths
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|MicrosoftVTableContext
range|:
name|public
name|VTableContextBase
block|{
name|public
operator|:
expr|struct
name|MethodVFTableLocation
block|{
comment|/// If nonzero, holds the vbtable index of the virtual base with the vfptr.
name|uint64_t
name|VBTableIndex
block|;
comment|/// If nonnull, holds the last vbase which contains the vfptr that the
comment|/// method definition is adjusted to.
specifier|const
name|CXXRecordDecl
operator|*
name|VBase
block|;
comment|/// This is the offset of the vfptr from the start of the last vbase, or the
comment|/// complete type if there are no virtual bases.
name|CharUnits
name|VFPtrOffset
block|;
comment|/// Method's index in the vftable.
name|uint64_t
name|Index
block|;
name|MethodVFTableLocation
argument_list|()
operator|:
name|VBTableIndex
argument_list|(
literal|0
argument_list|)
block|,
name|VBase
argument_list|(
name|nullptr
argument_list|)
block|,
name|VFPtrOffset
argument_list|(
name|CharUnits
operator|::
name|Zero
argument_list|()
argument_list|)
block|,
name|Index
argument_list|(
literal|0
argument_list|)
block|{}
name|MethodVFTableLocation
argument_list|(
argument|uint64_t VBTableIndex
argument_list|,
argument|const CXXRecordDecl *VBase
argument_list|,
argument|CharUnits VFPtrOffset
argument_list|,
argument|uint64_t Index
argument_list|)
operator|:
name|VBTableIndex
argument_list|(
name|VBTableIndex
argument_list|)
block|,
name|VBase
argument_list|(
name|VBase
argument_list|)
block|,
name|VFPtrOffset
argument_list|(
name|VFPtrOffset
argument_list|)
block|,
name|Index
argument_list|(
argument|Index
argument_list|)
block|{}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|MethodVFTableLocation
operator|&
name|other
operator|)
specifier|const
block|{
if|if
condition|(
name|VBTableIndex
operator|!=
name|other
operator|.
name|VBTableIndex
condition|)
block|{
name|assert
argument_list|(
name|VBase
operator|!=
name|other
operator|.
name|VBase
argument_list|)
expr_stmt|;
return|return
name|VBTableIndex
operator|<
name|other
operator|.
name|VBTableIndex
return|;
block|}
return|return
name|std
operator|::
name|tie
argument_list|(
name|VFPtrOffset
argument_list|,
name|Index
argument_list|)
operator|<
name|std
operator|::
name|tie
argument_list|(
name|other
operator|.
name|VFPtrOffset
argument_list|,
name|other
operator|.
name|Index
argument_list|)
return|;
block|}
expr|}
block|;
name|private
operator|:
name|ASTContext
operator|&
name|Context
block|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|GlobalDecl
operator|,
name|MethodVFTableLocation
operator|>
name|MethodVFTableLocationsTy
expr_stmt|;
name|MethodVFTableLocationsTy
name|MethodVFTableLocations
block|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|VPtrInfoVector
operator|>
name|VFPtrLocationsMapTy
expr_stmt|;
name|VFPtrLocationsMapTy
name|VFPtrLocations
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|CharUnits
operator|>
name|VFTableIdTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|VFTableIdTy
operator|,
name|std
operator|::
name|unique_ptr
operator|<
specifier|const
name|VTableLayout
operator|>>
name|VFTableLayoutMapTy
expr_stmt|;
end_typedef

begin_decl_stmt
name|VFTableLayoutMapTy
name|VFTableLayouts
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|CXXRecordDecl
operator|*
operator|,
name|std
operator|::
name|unique_ptr
operator|<
name|VirtualBaseInfo
operator|>>
name|VBaseInfo
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|enumerateVFPtrs
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|ForClass
parameter_list|,
name|VPtrInfoVector
modifier|&
name|Result
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|computeVTableRelatedInformation
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|RD
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|dumpMethodLocations
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
specifier|const
name|MethodVFTableLocationsTy
modifier|&
name|NewMethods
parameter_list|,
name|raw_ostream
modifier|&
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|VirtualBaseInfo
modifier|&
name|computeVBTableRelatedInformation
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|computeVTablePaths
parameter_list|(
name|bool
name|ForVBTables
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
name|VPtrInfoVector
modifier|&
name|Paths
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|MicrosoftVTableContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
operator|:
name|VTableContextBase
argument_list|(
comment|/*MS=*/
name|true
argument_list|)
operator|,
name|Context
argument_list|(
argument|Context
argument_list|)
block|{}
operator|~
name|MicrosoftVTableContext
argument_list|()
name|override
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|const
name|VPtrInfoVector
modifier|&
name|getVFPtrOffsets
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|VTableLayout
modifier|&
name|getVFTableLayout
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|,
name|CharUnits
name|VFPtrOffset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|MethodVFTableLocation
modifier|&
name|getMethodVFTableLocation
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|const
name|ThunkInfoVectorTy
modifier|*
name|getThunkInfo
parameter_list|(
name|GlobalDecl
name|GD
parameter_list|)
function|override
block|{
comment|// Complete destructors don't have a slot in a vftable, so no thunks needed.
if|if
condition|(
name|isa
operator|<
name|CXXDestructorDecl
operator|>
operator|(
name|GD
operator|.
name|getDecl
argument_list|()
operator|)
operator|&&
name|GD
operator|.
name|getDtorType
argument_list|()
operator|==
name|Dtor_Complete
condition|)
return|return
name|nullptr
return|;
return|return
name|VTableContextBase
operator|::
name|getThunkInfo
argument_list|(
name|GD
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// \brief Returns the index of VBase in the vbtable of Derived.
end_comment

begin_comment
comment|/// VBase must be a morally virtual base of Derived.
end_comment

begin_comment
comment|/// The vbtable is an array of i32 offsets.  The first entry is a self entry,
end_comment

begin_comment
comment|/// and the rest are offsets from the vbptr to virtual bases.
end_comment

begin_function_decl
name|unsigned
name|getVBTableIndex
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|Derived
parameter_list|,
specifier|const
name|CXXRecordDecl
modifier|*
name|VBase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|VPtrInfoVector
modifier|&
name|enumerateVBTables
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|RD
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|classof
parameter_list|(
specifier|const
name|VTableContextBase
modifier|*
name|VT
parameter_list|)
block|{
return|return
name|VT
operator|->
name|isMicrosoft
argument_list|()
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

