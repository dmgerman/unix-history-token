begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Comment.h - Comment AST nodes --------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines comment AST nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_COMMENT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_COMMENT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/CommentCommandTraits.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Decl
decl_stmt|;
name|class
name|ParmVarDecl
decl_stmt|;
name|class
name|TemplateParameterList
decl_stmt|;
name|namespace
name|comments
block|{
name|class
name|FullComment
decl_stmt|;
comment|/// Describes the syntax that was used in a documentation command.
comment|///
comment|/// Exact values of this enumeration are important because they used to select
comment|/// parts of diagnostic messages.  Audit diagnostics before changing or adding
comment|/// a new value.
enum|enum
name|CommandMarkerKind
block|{
comment|/// Command started with a backslash character:
comment|/// \code
comment|///   \foo
comment|/// \endcode
name|CMK_Backslash
init|=
literal|0
block|,
comment|/// Command started with an 'at' character:
comment|/// \code
comment|///   @foo
comment|/// \endcode
name|CMK_At
init|=
literal|1
block|}
enum|;
comment|/// Any part of the comment.
comment|/// Abstract class.
name|class
name|Comment
block|{
name|protected
label|:
comment|/// Preferred location to show caret.
name|SourceLocation
name|Loc
decl_stmt|;
comment|/// Source range of this AST node.
name|SourceRange
name|Range
decl_stmt|;
name|class
name|CommentBitfields
block|{
name|friend
name|class
name|Comment
decl_stmt|;
comment|/// Type of this AST node.
name|unsigned
name|Kind
range|:
literal|8
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumCommentBits
init|=
literal|8
block|}
enum|;
name|class
name|InlineContentCommentBitfields
block|{
name|friend
name|class
name|InlineContentComment
decl_stmt|;
name|unsigned
label|:
name|NumCommentBits
expr_stmt|;
comment|/// True if there is a newline after this inline content node.
comment|/// (There is no separate AST node for a newline.)
name|unsigned
name|HasTrailingNewline
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumInlineContentCommentBits
init|=
name|NumCommentBits
operator|+
literal|1
block|}
enum|;
name|class
name|TextCommentBitfields
block|{
name|friend
name|class
name|TextComment
decl_stmt|;
name|unsigned
label|:
name|NumInlineContentCommentBits
expr_stmt|;
comment|/// True if \c IsWhitespace field contains a valid value.
name|mutable
name|unsigned
name|IsWhitespaceValid
range|:
literal|1
decl_stmt|;
comment|/// True if this comment AST node contains only whitespace.
name|mutable
name|unsigned
name|IsWhitespace
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumTextCommentBits
init|=
name|NumInlineContentCommentBits
operator|+
literal|2
block|}
enum|;
name|class
name|InlineCommandCommentBitfields
block|{
name|friend
name|class
name|InlineCommandComment
decl_stmt|;
name|unsigned
label|:
name|NumInlineContentCommentBits
expr_stmt|;
name|unsigned
name|RenderKind
range|:
literal|2
decl_stmt|;
name|unsigned
name|CommandID
range|:
literal|8
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumInlineCommandCommentBits
init|=
name|NumInlineContentCommentBits
operator|+
literal|10
block|}
enum|;
name|class
name|HTMLStartTagCommentBitfields
block|{
name|friend
name|class
name|HTMLStartTagComment
decl_stmt|;
name|unsigned
label|:
name|NumInlineContentCommentBits
expr_stmt|;
comment|/// True if this tag is self-closing (e. g.,<br />).  This is based on tag
comment|/// spelling in comment (plain<br> would not set this flag).
name|unsigned
name|IsSelfClosing
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumHTMLStartTagCommentBits
init|=
name|NumInlineContentCommentBits
operator|+
literal|1
block|}
enum|;
name|class
name|ParagraphCommentBitfields
block|{
name|friend
name|class
name|ParagraphComment
decl_stmt|;
name|unsigned
label|:
name|NumCommentBits
expr_stmt|;
comment|/// True if \c IsWhitespace field contains a valid value.
name|mutable
name|unsigned
name|IsWhitespaceValid
range|:
literal|1
decl_stmt|;
comment|/// True if this comment AST node contains only whitespace.
name|mutable
name|unsigned
name|IsWhitespace
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumParagraphCommentBits
init|=
name|NumCommentBits
operator|+
literal|2
block|}
enum|;
name|class
name|BlockCommandCommentBitfields
block|{
name|friend
name|class
name|BlockCommandComment
decl_stmt|;
name|unsigned
label|:
name|NumCommentBits
expr_stmt|;
name|unsigned
name|CommandID
range|:
literal|8
decl_stmt|;
comment|/// Describes the syntax that was used in a documentation command.
comment|/// Contains values from CommandMarkerKind enum.
name|unsigned
name|CommandMarker
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumBlockCommandCommentBits
init|=
name|NumCommentBits
operator|+
literal|9
block|}
enum|;
name|class
name|ParamCommandCommentBitfields
block|{
name|friend
name|class
name|ParamCommandComment
decl_stmt|;
name|unsigned
label|:
name|NumBlockCommandCommentBits
expr_stmt|;
comment|/// Parameter passing direction, see ParamCommandComment::PassDirection.
name|unsigned
name|Direction
range|:
literal|2
decl_stmt|;
comment|/// True if direction was specified explicitly in the comment.
name|unsigned
name|IsDirectionExplicit
range|:
literal|1
decl_stmt|;
block|}
empty_stmt|;
enum|enum
block|{
name|NumParamCommandCommentBits
init|=
name|NumBlockCommandCommentBits
operator|+
literal|3
block|}
enum|;
union|union
block|{
name|CommentBitfields
name|CommentBits
decl_stmt|;
name|InlineContentCommentBitfields
name|InlineContentCommentBits
decl_stmt|;
name|TextCommentBitfields
name|TextCommentBits
decl_stmt|;
name|InlineCommandCommentBitfields
name|InlineCommandCommentBits
decl_stmt|;
name|HTMLStartTagCommentBitfields
name|HTMLStartTagCommentBits
decl_stmt|;
name|ParagraphCommentBitfields
name|ParagraphCommentBits
decl_stmt|;
name|BlockCommandCommentBitfields
name|BlockCommandCommentBits
decl_stmt|;
name|ParamCommandCommentBitfields
name|ParamCommandCommentBits
decl_stmt|;
block|}
union|;
name|void
name|setSourceRange
parameter_list|(
name|SourceRange
name|SR
parameter_list|)
block|{
name|Range
operator|=
name|SR
expr_stmt|;
block|}
name|void
name|setLocation
parameter_list|(
name|SourceLocation
name|L
parameter_list|)
block|{
name|Loc
operator|=
name|L
expr_stmt|;
block|}
name|public
label|:
enum|enum
name|CommentKind
block|{
name|NoCommentKind
init|=
literal|0
block|,
define|#
directive|define
name|COMMENT
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
value|CLASS##Kind,
define|#
directive|define
name|COMMENT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind,
define|#
directive|define
name|LAST_COMMENT_RANGE
parameter_list|(
name|BASE
parameter_list|,
name|FIRST
parameter_list|,
name|LAST
parameter_list|)
define|\
value|First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind
define|#
directive|define
name|ABSTRACT_COMMENT
parameter_list|(
name|COMMENT
parameter_list|)
include|#
directive|include
file|"clang/AST/CommentNodes.inc"
block|}
enum|;
name|Comment
argument_list|(
argument|CommentKind K
argument_list|,
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|)
block|:
name|Loc
argument_list|(
name|LocBegin
argument_list|)
operator|,
name|Range
argument_list|(
argument|SourceRange(LocBegin, LocEnd)
argument_list|)
block|{
name|CommentBits
operator|.
name|Kind
operator|=
name|K
block|;   }
name|CommentKind
name|getCommentKind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|CommentKind
operator|>
operator|(
name|CommentBits
operator|.
name|Kind
operator|)
return|;
block|}
specifier|const
name|char
operator|*
name|getCommentKindName
argument_list|()
specifier|const
expr_stmt|;
name|LLVM_ATTRIBUTE_USED
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|LLVM_ATTRIBUTE_USED
name|void
name|dumpColor
argument_list|()
specifier|const
expr_stmt|;
name|LLVM_ATTRIBUTE_USED
name|void
name|dump
argument_list|(
specifier|const
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
specifier|const
name|CommandTraits
operator|*
name|Traits
argument_list|,
specifier|const
name|SourceManager
operator|*
name|SM
argument_list|)
decl|const
decl_stmt|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
return|;
block|}
name|SourceLocation
name|getLocStart
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocEnd
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|SourceLocation
name|getLocation
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Loc
return|;
block|}
typedef|typedef
name|Comment
modifier|*
specifier|const
modifier|*
name|child_iterator
typedef|;
name|child_iterator
name|child_begin
argument_list|()
specifier|const
expr_stmt|;
name|child_iterator
name|child_end
argument_list|()
specifier|const
expr_stmt|;
comment|// TODO: const child iterator
name|unsigned
name|child_count
argument_list|()
specifier|const
block|{
return|return
name|child_end
argument_list|()
operator|-
name|child_begin
argument_list|()
return|;
block|}
block|}
empty_stmt|;
comment|/// Inline content (contained within a block).
comment|/// Abstract class.
name|class
name|InlineContentComment
range|:
name|public
name|Comment
block|{
name|protected
operator|:
name|InlineContentComment
argument_list|(
argument|CommentKind K
argument_list|,
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|)
operator|:
name|Comment
argument_list|(
argument|K
argument_list|,
argument|LocBegin
argument_list|,
argument|LocEnd
argument_list|)
block|{
name|InlineContentCommentBits
operator|.
name|HasTrailingNewline
operator|=
literal|0
block|;   }
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|>=
name|FirstInlineContentCommentConstant
operator|&&
name|C
operator|->
name|getCommentKind
argument_list|()
operator|<=
name|LastInlineContentCommentConstant
return|;
block|}
name|void
name|addTrailingNewline
argument_list|()
block|{
name|InlineContentCommentBits
operator|.
name|HasTrailingNewline
operator|=
literal|1
block|;   }
name|bool
name|hasTrailingNewline
argument_list|()
specifier|const
block|{
return|return
name|InlineContentCommentBits
operator|.
name|HasTrailingNewline
return|;
block|}
expr|}
block|;
comment|/// Plain text.
name|class
name|TextComment
operator|:
name|public
name|InlineContentComment
block|{
name|StringRef
name|Text
block|;
name|public
operator|:
name|TextComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|StringRef Text
argument_list|)
operator|:
name|InlineContentComment
argument_list|(
name|TextCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|)
block|,
name|Text
argument_list|(
argument|Text
argument_list|)
block|{
name|TextCommentBits
operator|.
name|IsWhitespaceValid
operator|=
name|false
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|TextCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|StringRef
name|getText
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Text
return|;
block|}
name|bool
name|isWhitespace
argument_list|()
specifier|const
block|{
if|if
condition|(
name|TextCommentBits
operator|.
name|IsWhitespaceValid
condition|)
return|return
name|TextCommentBits
operator|.
name|IsWhitespace
return|;
name|TextCommentBits
operator|.
name|IsWhitespace
operator|=
name|isWhitespaceNoCache
argument_list|()
block|;
name|TextCommentBits
operator|.
name|IsWhitespaceValid
operator|=
name|true
block|;
return|return
name|TextCommentBits
operator|.
name|IsWhitespace
return|;
block|}
name|private
operator|:
name|bool
name|isWhitespaceNoCache
argument_list|()
specifier|const
block|; }
decl_stmt|;
comment|/// A command with word-like arguments that is considered inline content.
name|class
name|InlineCommandComment
range|:
name|public
name|InlineContentComment
block|{
name|public
operator|:
expr|struct
name|Argument
block|{
name|SourceRange
name|Range
block|;
name|StringRef
name|Text
block|;
name|Argument
argument_list|(
argument|SourceRange Range
argument_list|,
argument|StringRef Text
argument_list|)
operator|:
name|Range
argument_list|(
name|Range
argument_list|)
block|,
name|Text
argument_list|(
argument|Text
argument_list|)
block|{ }
block|}
block|;
comment|/// The most appropriate rendering mode for this command, chosen on command
comment|/// semantics in Doxygen.
block|enum
name|RenderKind
block|{
name|RenderNormal
block|,
name|RenderBold
block|,
name|RenderMonospaced
block|,
name|RenderEmphasized
block|}
block|;
name|protected
operator|:
comment|/// Command arguments.
name|ArrayRef
operator|<
name|Argument
operator|>
name|Args
block|;
name|public
operator|:
name|InlineCommandComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|RenderKind RK
argument_list|,
argument|ArrayRef<Argument> Args
argument_list|)
operator|:
name|InlineContentComment
argument_list|(
name|InlineCommandCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|)
block|,
name|Args
argument_list|(
argument|Args
argument_list|)
block|{
name|InlineCommandCommentBits
operator|.
name|RenderKind
operator|=
name|RK
block|;
name|InlineCommandCommentBits
operator|.
name|CommandID
operator|=
name|CommandID
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|InlineCommandCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|unsigned
name|getCommandID
argument_list|()
specifier|const
block|{
return|return
name|InlineCommandCommentBits
operator|.
name|CommandID
return|;
block|}
name|StringRef
name|getCommandName
argument_list|(
argument|const CommandTraits&Traits
argument_list|)
specifier|const
block|{
return|return
name|Traits
operator|.
name|getCommandInfo
argument_list|(
name|getCommandID
argument_list|()
argument_list|)
operator|->
name|Name
return|;
block|}
name|SourceRange
name|getCommandNameRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|getLocStart
argument_list|()
operator|.
name|getLocWithOffset
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
name|RenderKind
name|getRenderKind
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
name|RenderKind
operator|>
operator|(
name|InlineCommandCommentBits
operator|.
name|RenderKind
operator|)
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
name|StringRef
name|getArgText
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|Args
index|[
name|Idx
index|]
operator|.
name|Text
return|;
block|}
name|SourceRange
name|getArgRange
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|Args
index|[
name|Idx
index|]
operator|.
name|Range
return|;
block|}
expr|}
block|;
comment|/// Abstract class for opening and closing HTML tags.  HTML tags are always
comment|/// treated as inline content (regardless HTML semantics); opening and closing
comment|/// tags are not matched.
name|class
name|HTMLTagComment
operator|:
name|public
name|InlineContentComment
block|{
name|protected
operator|:
name|StringRef
name|TagName
block|;
name|SourceRange
name|TagNameRange
block|;
name|HTMLTagComment
argument_list|(
argument|CommentKind K
argument_list|,
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|StringRef TagName
argument_list|,
argument|SourceLocation TagNameBegin
argument_list|,
argument|SourceLocation TagNameEnd
argument_list|)
operator|:
name|InlineContentComment
argument_list|(
name|K
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|)
block|,
name|TagName
argument_list|(
name|TagName
argument_list|)
block|,
name|TagNameRange
argument_list|(
argument|TagNameBegin
argument_list|,
argument|TagNameEnd
argument_list|)
block|{
name|setLocation
argument_list|(
name|TagNameBegin
argument_list|)
block|;   }
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|>=
name|FirstHTMLTagCommentConstant
operator|&&
name|C
operator|->
name|getCommentKind
argument_list|()
operator|<=
name|LastHTMLTagCommentConstant
return|;
block|}
name|StringRef
name|getTagName
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|TagName
return|;
block|}
name|SourceRange
name|getTagNameSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|SourceLocation
name|L
operator|=
name|getLocation
argument_list|()
block|;
return|return
name|SourceRange
argument_list|(
name|L
operator|.
name|getLocWithOffset
argument_list|(
literal|1
argument_list|)
argument_list|,
name|L
operator|.
name|getLocWithOffset
argument_list|(
literal|1
operator|+
name|TagName
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// An opening HTML tag with attributes.
name|class
name|HTMLStartTagComment
operator|:
name|public
name|HTMLTagComment
block|{
name|public
operator|:
name|class
name|Attribute
block|{
name|public
operator|:
name|SourceLocation
name|NameLocBegin
block|;
name|StringRef
name|Name
block|;
name|SourceLocation
name|EqualsLoc
block|;
name|SourceRange
name|ValueRange
block|;
name|StringRef
name|Value
block|;
name|Attribute
argument_list|()
block|{ }
name|Attribute
argument_list|(
argument|SourceLocation NameLocBegin
argument_list|,
argument|StringRef Name
argument_list|)
operator|:
name|NameLocBegin
argument_list|(
name|NameLocBegin
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|EqualsLoc
argument_list|(
name|SourceLocation
argument_list|()
argument_list|)
block|,
name|ValueRange
argument_list|(
name|SourceRange
argument_list|()
argument_list|)
block|,
name|Value
argument_list|(
argument|StringRef()
argument_list|)
block|{ }
name|Attribute
argument_list|(
argument|SourceLocation NameLocBegin
argument_list|,
argument|StringRef Name
argument_list|,
argument|SourceLocation EqualsLoc
argument_list|,
argument|SourceRange ValueRange
argument_list|,
argument|StringRef Value
argument_list|)
operator|:
name|NameLocBegin
argument_list|(
name|NameLocBegin
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|EqualsLoc
argument_list|(
name|EqualsLoc
argument_list|)
block|,
name|ValueRange
argument_list|(
name|ValueRange
argument_list|)
block|,
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
name|SourceLocation
name|getNameLocEnd
argument_list|()
specifier|const
block|{
return|return
name|NameLocBegin
operator|.
name|getLocWithOffset
argument_list|(
name|Name
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
name|SourceRange
name|getNameRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|NameLocBegin
argument_list|,
name|getNameLocEnd
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|private
operator|:
name|ArrayRef
operator|<
name|Attribute
operator|>
name|Attributes
block|;
name|public
operator|:
name|HTMLStartTagComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|StringRef TagName
argument_list|)
operator|:
name|HTMLTagComment
argument_list|(
argument|HTMLStartTagCommentKind
argument_list|,
argument|LocBegin
argument_list|,
argument|LocBegin.getLocWithOffset(
literal|1
argument|+ TagName.size())
argument_list|,
argument|TagName
argument_list|,
argument|LocBegin.getLocWithOffset(
literal|1
argument|)
argument_list|,
argument|LocBegin.getLocWithOffset(
literal|1
argument|+ TagName.size())
argument_list|)
block|{
name|HTMLStartTagCommentBits
operator|.
name|IsSelfClosing
operator|=
name|false
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|HTMLStartTagCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|unsigned
name|getNumAttrs
argument_list|()
specifier|const
block|{
return|return
name|Attributes
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|Attribute
operator|&
name|getAttr
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|Attributes
index|[
name|Idx
index|]
return|;
block|}
name|void
name|setAttrs
argument_list|(
argument|ArrayRef<Attribute> Attrs
argument_list|)
block|{
name|Attributes
operator|=
name|Attrs
block|;
if|if
condition|(
operator|!
name|Attrs
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|Attribute
modifier|&
name|Attr
init|=
name|Attrs
operator|.
name|back
argument_list|()
decl_stmt|;
name|SourceLocation
name|L
init|=
name|Attr
operator|.
name|ValueRange
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|L
operator|.
name|isValid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|L
argument_list|)
expr_stmt|;
else|else
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Attr
operator|.
name|getNameLocEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|setGreaterLoc
argument_list|(
argument|SourceLocation GreaterLoc
argument_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|GreaterLoc
argument_list|)
block|;   }
name|bool
name|isSelfClosing
argument_list|()
specifier|const
block|{
return|return
name|HTMLStartTagCommentBits
operator|.
name|IsSelfClosing
return|;
block|}
name|void
name|setSelfClosing
argument_list|()
block|{
name|HTMLStartTagCommentBits
operator|.
name|IsSelfClosing
operator|=
name|true
block|;   }
expr|}
block|;
comment|/// A closing HTML tag.
name|class
name|HTMLEndTagComment
operator|:
name|public
name|HTMLTagComment
block|{
name|public
operator|:
name|HTMLEndTagComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|StringRef TagName
argument_list|)
operator|:
name|HTMLTagComment
argument_list|(
argument|HTMLEndTagCommentKind
argument_list|,
argument|LocBegin
argument_list|,
argument|LocEnd
argument_list|,
argument|TagName
argument_list|,
argument|LocBegin.getLocWithOffset(
literal|2
argument|)
argument_list|,
argument|LocBegin.getLocWithOffset(
literal|2
argument|+ TagName.size())
argument_list|)
block|{ }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|HTMLEndTagCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
expr|}
block|;
comment|/// Block content (contains inline content).
comment|/// Abstract class.
name|class
name|BlockContentComment
operator|:
name|public
name|Comment
block|{
name|protected
operator|:
name|BlockContentComment
argument_list|(
argument|CommentKind K
argument_list|,
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|)
operator|:
name|Comment
argument_list|(
argument|K
argument_list|,
argument|LocBegin
argument_list|,
argument|LocEnd
argument_list|)
block|{ }
name|public
operator|:
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|>=
name|FirstBlockContentCommentConstant
operator|&&
name|C
operator|->
name|getCommentKind
argument_list|()
operator|<=
name|LastBlockContentCommentConstant
return|;
block|}
expr|}
block|;
comment|/// A single paragraph that contains inline content.
name|class
name|ParagraphComment
operator|:
name|public
name|BlockContentComment
block|{
name|ArrayRef
operator|<
name|InlineContentComment
operator|*
operator|>
name|Content
block|;
name|public
operator|:
name|ParagraphComment
argument_list|(
name|ArrayRef
operator|<
name|InlineContentComment
operator|*
operator|>
name|Content
argument_list|)
operator|:
name|BlockContentComment
argument_list|(
name|ParagraphCommentKind
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
name|SourceLocation
argument_list|()
argument_list|)
block|,
name|Content
argument_list|(
argument|Content
argument_list|)
block|{
if|if
condition|(
name|Content
operator|.
name|empty
argument_list|()
condition|)
block|{
name|ParagraphCommentBits
operator|.
name|IsWhitespace
operator|=
name|true
expr_stmt|;
name|ParagraphCommentBits
operator|.
name|IsWhitespaceValid
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|ParagraphCommentBits
operator|.
name|IsWhitespaceValid
operator|=
name|false
expr_stmt|;
name|setSourceRange
argument_list|(
name|SourceRange
argument_list|(
name|Content
operator|.
name|front
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Content
operator|.
name|back
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
argument_list|)
block|;
name|setLocation
argument_list|(
name|Content
operator|.
name|front
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|ParagraphCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Content
operator|.
name|begin
argument_list|()
operator|)
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Content
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|bool
name|isWhitespace
argument_list|()
specifier|const
block|{
if|if
condition|(
name|ParagraphCommentBits
operator|.
name|IsWhitespaceValid
condition|)
return|return
name|ParagraphCommentBits
operator|.
name|IsWhitespace
return|;
name|ParagraphCommentBits
operator|.
name|IsWhitespace
operator|=
name|isWhitespaceNoCache
argument_list|()
block|;
name|ParagraphCommentBits
operator|.
name|IsWhitespaceValid
operator|=
name|true
block|;
return|return
name|ParagraphCommentBits
operator|.
name|IsWhitespace
return|;
block|}
name|private
operator|:
name|bool
name|isWhitespaceNoCache
argument_list|()
specifier|const
block|; }
block|;
comment|/// A command that has zero or more word-like arguments (number of word-like
comment|/// arguments depends on command name) and a paragraph as an argument
comment|/// (e. g., \\brief).
name|class
name|BlockCommandComment
operator|:
name|public
name|BlockContentComment
block|{
name|public
operator|:
expr|struct
name|Argument
block|{
name|SourceRange
name|Range
block|;
name|StringRef
name|Text
block|;
name|Argument
argument_list|()
block|{ }
name|Argument
argument_list|(
argument|SourceRange Range
argument_list|,
argument|StringRef Text
argument_list|)
operator|:
name|Range
argument_list|(
name|Range
argument_list|)
block|,
name|Text
argument_list|(
argument|Text
argument_list|)
block|{ }
block|}
block|;
name|protected
operator|:
comment|/// Word-like arguments.
name|ArrayRef
operator|<
name|Argument
operator|>
name|Args
block|;
comment|/// Paragraph argument.
name|ParagraphComment
operator|*
name|Paragraph
block|;
name|BlockCommandComment
argument_list|(
argument|CommentKind K
argument_list|,
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|CommandMarkerKind CommandMarker
argument_list|)
operator|:
name|BlockContentComment
argument_list|(
name|K
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|)
block|,
name|Paragraph
argument_list|(
argument|NULL
argument_list|)
block|{
name|setLocation
argument_list|(
name|getCommandNameBeginLoc
argument_list|()
argument_list|)
block|;
name|BlockCommandCommentBits
operator|.
name|CommandID
operator|=
name|CommandID
block|;
name|BlockCommandCommentBits
operator|.
name|CommandMarker
operator|=
name|CommandMarker
block|;   }
name|public
operator|:
name|BlockCommandComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|CommandMarkerKind CommandMarker
argument_list|)
operator|:
name|BlockContentComment
argument_list|(
name|BlockCommandCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|)
block|,
name|Paragraph
argument_list|(
argument|NULL
argument_list|)
block|{
name|setLocation
argument_list|(
name|getCommandNameBeginLoc
argument_list|()
argument_list|)
block|;
name|BlockCommandCommentBits
operator|.
name|CommandID
operator|=
name|CommandID
block|;
name|BlockCommandCommentBits
operator|.
name|CommandMarker
operator|=
name|CommandMarker
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|>=
name|FirstBlockCommandCommentConstant
operator|&&
name|C
operator|->
name|getCommentKind
argument_list|()
operator|<=
name|LastBlockCommandCommentConstant
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
operator|&
name|Paragraph
operator|)
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
operator|&
name|Paragraph
operator|+
literal|1
operator|)
return|;
block|}
name|unsigned
name|getCommandID
argument_list|()
specifier|const
block|{
return|return
name|BlockCommandCommentBits
operator|.
name|CommandID
return|;
block|}
name|StringRef
name|getCommandName
argument_list|(
argument|const CommandTraits&Traits
argument_list|)
specifier|const
block|{
return|return
name|Traits
operator|.
name|getCommandInfo
argument_list|(
name|getCommandID
argument_list|()
argument_list|)
operator|->
name|Name
return|;
block|}
name|SourceLocation
name|getCommandNameBeginLoc
argument_list|()
specifier|const
block|{
return|return
name|getLocStart
argument_list|()
operator|.
name|getLocWithOffset
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|SourceRange
name|getCommandNameRange
argument_list|(
argument|const CommandTraits&Traits
argument_list|)
specifier|const
block|{
name|StringRef
name|Name
operator|=
name|getCommandName
argument_list|(
name|Traits
argument_list|)
block|;
return|return
name|SourceRange
argument_list|(
name|getCommandNameBeginLoc
argument_list|()
argument_list|,
name|getLocStart
argument_list|()
operator|.
name|getLocWithOffset
argument_list|(
literal|1
operator|+
name|Name
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
name|StringRef
name|getArgText
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|Args
index|[
name|Idx
index|]
operator|.
name|Text
return|;
block|}
name|SourceRange
name|getArgRange
argument_list|(
argument|unsigned Idx
argument_list|)
specifier|const
block|{
return|return
name|Args
index|[
name|Idx
index|]
operator|.
name|Range
return|;
block|}
name|void
name|setArgs
argument_list|(
argument|ArrayRef<Argument> A
argument_list|)
block|{
name|Args
operator|=
name|A
block|;
if|if
condition|(
name|Args
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|SourceLocation
name|NewLocEnd
init|=
name|Args
operator|.
name|back
argument_list|()
operator|.
name|Range
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|NewLocEnd
operator|.
name|isValid
argument_list|()
condition|)
name|setSourceRange
argument_list|(
name|SourceRange
argument_list|(
name|getLocStart
argument_list|()
argument_list|,
name|NewLocEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ParagraphComment
operator|*
name|getParagraph
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Paragraph
return|;
block|}
name|bool
name|hasNonWhitespaceParagraph
argument_list|()
specifier|const
block|{
return|return
name|Paragraph
operator|&&
operator|!
name|Paragraph
operator|->
name|isWhitespace
argument_list|()
return|;
block|}
name|void
name|setParagraph
argument_list|(
argument|ParagraphComment *PC
argument_list|)
block|{
name|Paragraph
operator|=
name|PC
block|;
name|SourceLocation
name|NewLocEnd
operator|=
name|PC
operator|->
name|getLocEnd
argument_list|()
block|;
if|if
condition|(
name|NewLocEnd
operator|.
name|isValid
argument_list|()
condition|)
name|setSourceRange
argument_list|(
name|SourceRange
argument_list|(
name|getLocStart
argument_list|()
argument_list|,
name|NewLocEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CommandMarkerKind
name|getCommandMarker
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|static_cast
operator|<
name|CommandMarkerKind
operator|>
operator|(
name|BlockCommandCommentBits
operator|.
name|CommandMarker
operator|)
return|;
block|}
expr|}
block|;
comment|/// Doxygen \\param command.
name|class
name|ParamCommandComment
operator|:
name|public
name|BlockCommandComment
block|{
name|private
operator|:
comment|/// Parameter index in the function declaration.
name|unsigned
name|ParamIndex
block|;
name|public
operator|:
expr|enum
name|LLVM_ENUM_INT_TYPE
argument_list|(
argument|unsigned
argument_list|)
block|{
name|InvalidParamIndex
operator|=
operator|~
literal|0U
block|,
name|VarArgParamIndex
operator|=
operator|~
literal|0U
comment|/*InvalidParamIndex*/
operator|-
literal|1U
block|}
block|;
name|ParamCommandComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|CommandMarkerKind CommandMarker
argument_list|)
operator|:
name|BlockCommandComment
argument_list|(
name|ParamCommandCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|,
name|CommandID
argument_list|,
name|CommandMarker
argument_list|)
block|,
name|ParamIndex
argument_list|(
argument|InvalidParamIndex
argument_list|)
block|{
name|ParamCommandCommentBits
operator|.
name|Direction
operator|=
name|In
block|;
name|ParamCommandCommentBits
operator|.
name|IsDirectionExplicit
operator|=
name|false
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|ParamCommandCommentKind
return|;
block|}
expr|enum
name|PassDirection
block|{
name|In
block|,
name|Out
block|,
name|InOut
block|}
block|;
specifier|static
specifier|const
name|char
operator|*
name|getDirectionAsString
argument_list|(
argument|PassDirection D
argument_list|)
block|;
name|PassDirection
name|getDirection
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|static_cast
operator|<
name|PassDirection
operator|>
operator|(
name|ParamCommandCommentBits
operator|.
name|Direction
operator|)
return|;
block|}
name|bool
name|isDirectionExplicit
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ParamCommandCommentBits
operator|.
name|IsDirectionExplicit
return|;
block|}
name|void
name|setDirection
argument_list|(
argument|PassDirection Direction
argument_list|,
argument|bool Explicit
argument_list|)
block|{
name|ParamCommandCommentBits
operator|.
name|Direction
operator|=
name|Direction
block|;
name|ParamCommandCommentBits
operator|.
name|IsDirectionExplicit
operator|=
name|Explicit
block|;   }
name|bool
name|hasParamName
argument_list|()
specifier|const
block|{
return|return
name|getNumArgs
argument_list|()
operator|>
literal|0
return|;
block|}
name|StringRef
name|getParamName
argument_list|(
argument|const FullComment *FC
argument_list|)
specifier|const
block|;
name|StringRef
name|getParamNameAsWritten
argument_list|()
specifier|const
block|{
return|return
name|Args
index|[
literal|0
index|]
operator|.
name|Text
return|;
block|}
name|SourceRange
name|getParamNameRange
argument_list|()
specifier|const
block|{
return|return
name|Args
index|[
literal|0
index|]
operator|.
name|Range
return|;
block|}
name|bool
name|isParamIndexValid
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ParamIndex
operator|!=
name|InvalidParamIndex
return|;
block|}
name|bool
name|isVarArgParam
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ParamIndex
operator|==
name|VarArgParamIndex
return|;
block|}
name|void
name|setIsVarArgParam
argument_list|()
block|{
name|ParamIndex
operator|=
name|VarArgParamIndex
block|;
name|assert
argument_list|(
name|isParamIndexValid
argument_list|()
argument_list|)
block|;   }
name|unsigned
name|getParamIndex
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
name|assert
argument_list|(
name|isParamIndexValid
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|isVarArgParam
argument_list|()
argument_list|)
block|;
return|return
name|ParamIndex
return|;
block|}
name|void
name|setParamIndex
argument_list|(
argument|unsigned Index
argument_list|)
block|{
name|ParamIndex
operator|=
name|Index
block|;
name|assert
argument_list|(
name|isParamIndexValid
argument_list|()
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|isVarArgParam
argument_list|()
argument_list|)
block|;   }
expr|}
block|;
comment|/// Doxygen \\tparam command, describes a template parameter.
name|class
name|TParamCommandComment
operator|:
name|public
name|BlockCommandComment
block|{
name|private
operator|:
comment|/// If this template parameter name was resolved (found in template parameter
comment|/// list), then this stores a list of position indexes in all template
comment|/// parameter lists.
comment|///
comment|/// For example:
comment|/// \verbatim
comment|///     template<typename C, template<typename T> class TT>
comment|///     void test(TT<int> aaa);
comment|/// \endverbatim
comment|/// For C:  Position = { 0 }
comment|/// For TT: Position = { 1 }
comment|/// For T:  Position = { 1, 0 }
name|ArrayRef
operator|<
name|unsigned
operator|>
name|Position
block|;
name|public
operator|:
name|TParamCommandComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|CommandMarkerKind CommandMarker
argument_list|)
operator|:
name|BlockCommandComment
argument_list|(
argument|TParamCommandCommentKind
argument_list|,
argument|LocBegin
argument_list|,
argument|LocEnd
argument_list|,
argument|CommandID
argument_list|,
argument|CommandMarker
argument_list|)
block|{ }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|TParamCommandCommentKind
return|;
block|}
name|bool
name|hasParamName
argument_list|()
specifier|const
block|{
return|return
name|getNumArgs
argument_list|()
operator|>
literal|0
return|;
block|}
name|StringRef
name|getParamName
argument_list|(
argument|const FullComment *FC
argument_list|)
specifier|const
block|;
name|StringRef
name|getParamNameAsWritten
argument_list|()
specifier|const
block|{
return|return
name|Args
index|[
literal|0
index|]
operator|.
name|Text
return|;
block|}
name|SourceRange
name|getParamNameRange
argument_list|()
specifier|const
block|{
return|return
name|Args
index|[
literal|0
index|]
operator|.
name|Range
return|;
block|}
name|bool
name|isPositionValid
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
operator|!
name|Position
operator|.
name|empty
argument_list|()
return|;
block|}
name|unsigned
name|getDepth
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isPositionValid
argument_list|()
argument_list|)
block|;
return|return
name|Position
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getIndex
argument_list|(
argument|unsigned Depth
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|isPositionValid
argument_list|()
argument_list|)
block|;
return|return
name|Position
index|[
name|Depth
index|]
return|;
block|}
name|void
name|setPosition
argument_list|(
argument|ArrayRef<unsigned> NewPosition
argument_list|)
block|{
name|Position
operator|=
name|NewPosition
block|;
name|assert
argument_list|(
name|isPositionValid
argument_list|()
argument_list|)
block|;   }
expr|}
block|;
comment|/// A line of text contained in a verbatim block.
name|class
name|VerbatimBlockLineComment
operator|:
name|public
name|Comment
block|{
name|StringRef
name|Text
block|;
name|public
operator|:
name|VerbatimBlockLineComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|StringRef Text
argument_list|)
operator|:
name|Comment
argument_list|(
name|VerbatimBlockLineCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocBegin
operator|.
name|getLocWithOffset
argument_list|(
name|Text
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
block|,
name|Text
argument_list|(
argument|Text
argument_list|)
block|{ }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|VerbatimBlockLineCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|StringRef
name|getText
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|Text
return|;
block|}
expr|}
block|;
comment|/// A verbatim block command (e. g., preformatted code).  Verbatim block has an
comment|/// opening and a closing command and contains multiple lines of text
comment|/// (VerbatimBlockLineComment nodes).
name|class
name|VerbatimBlockComment
operator|:
name|public
name|BlockCommandComment
block|{
name|protected
operator|:
name|StringRef
name|CloseName
block|;
name|SourceLocation
name|CloseNameLocBegin
block|;
name|ArrayRef
operator|<
name|VerbatimBlockLineComment
operator|*
operator|>
name|Lines
block|;
name|public
operator|:
name|VerbatimBlockComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|)
operator|:
name|BlockCommandComment
argument_list|(
argument|VerbatimBlockCommentKind
argument_list|,
argument|LocBegin
argument_list|,
argument|LocEnd
argument_list|,
argument|CommandID
argument_list|,
argument|CMK_At
argument_list|)
comment|// FIXME: improve source fidelity.
block|{ }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|VerbatimBlockCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Lines
operator|.
name|begin
argument_list|()
operator|)
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Lines
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
name|void
name|setCloseName
argument_list|(
argument|StringRef Name
argument_list|,
argument|SourceLocation LocBegin
argument_list|)
block|{
name|CloseName
operator|=
name|Name
block|;
name|CloseNameLocBegin
operator|=
name|LocBegin
block|;   }
name|void
name|setLines
argument_list|(
argument|ArrayRef<VerbatimBlockLineComment *> L
argument_list|)
block|{
name|Lines
operator|=
name|L
block|;   }
name|StringRef
name|getCloseName
argument_list|()
specifier|const
block|{
return|return
name|CloseName
return|;
block|}
name|unsigned
name|getNumLines
argument_list|()
specifier|const
block|{
return|return
name|Lines
operator|.
name|size
argument_list|()
return|;
block|}
name|StringRef
name|getText
argument_list|(
argument|unsigned LineIdx
argument_list|)
specifier|const
block|{
return|return
name|Lines
index|[
name|LineIdx
index|]
operator|->
name|getText
argument_list|()
return|;
block|}
expr|}
block|;
comment|/// A verbatim line command.  Verbatim line has an opening command, a single
comment|/// line of text (up to the newline after the opening command) and has no
comment|/// closing command.
name|class
name|VerbatimLineComment
operator|:
name|public
name|BlockCommandComment
block|{
name|protected
operator|:
name|StringRef
name|Text
block|;
name|SourceLocation
name|TextBegin
block|;
name|public
operator|:
name|VerbatimLineComment
argument_list|(
argument|SourceLocation LocBegin
argument_list|,
argument|SourceLocation LocEnd
argument_list|,
argument|unsigned CommandID
argument_list|,
argument|SourceLocation TextBegin
argument_list|,
argument|StringRef Text
argument_list|)
operator|:
name|BlockCommandComment
argument_list|(
name|VerbatimLineCommentKind
argument_list|,
name|LocBegin
argument_list|,
name|LocEnd
argument_list|,
name|CommandID
argument_list|,
name|CMK_At
argument_list|)
block|,
comment|// FIXME: improve source fidelity.
name|Text
argument_list|(
name|Text
argument_list|)
block|,
name|TextBegin
argument_list|(
argument|TextBegin
argument_list|)
block|{ }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|VerbatimLineCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|NULL
return|;
block|}
name|StringRef
name|getText
argument_list|()
specifier|const
block|{
return|return
name|Text
return|;
block|}
name|SourceRange
name|getTextRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|TextBegin
argument_list|,
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// Information about the declaration, useful to clients of FullComment.
block|struct
name|DeclInfo
block|{
comment|/// Declaration the comment is actually attached to (in the source).
comment|/// Should not be NULL.
specifier|const
name|Decl
operator|*
name|CommentDecl
block|;
comment|/// CurrentDecl is the declaration with which the FullComment is associated.
comment|///
comment|/// It can be different from \c CommentDecl.  It happens when we we decide
comment|/// that the comment originally attached to \c CommentDecl is fine for
comment|/// \c CurrentDecl too (for example, for a redeclaration or an overrider of
comment|/// \c CommentDecl).
comment|///
comment|/// The information in the DeclInfo corresponds to CurrentDecl.
specifier|const
name|Decl
operator|*
name|CurrentDecl
block|;
comment|/// Parameters that can be referenced by \\param if \c CommentDecl is something
comment|/// that we consider a "function".
name|ArrayRef
operator|<
specifier|const
name|ParmVarDecl
operator|*
operator|>
name|ParamVars
block|;
comment|/// Function result type if \c CommentDecl is something that we consider
comment|/// a "function".
name|QualType
name|ResultType
block|;
comment|/// Template parameters that can be referenced by \\tparam if \c CommentDecl is
comment|/// a template (\c IsTemplateDecl or \c IsTemplatePartialSpecialization is
comment|/// true).
specifier|const
name|TemplateParameterList
operator|*
name|TemplateParameters
block|;
comment|/// A simplified description of \c CommentDecl kind that should be good enough
comment|/// for documentation rendering purposes.
block|enum
name|DeclKind
block|{
comment|/// Everything else not explicitly mentioned below.
name|OtherKind
block|,
comment|/// Something that we consider a "function":
comment|/// \li function,
comment|/// \li function template,
comment|/// \li function template specialization,
comment|/// \li member function,
comment|/// \li member function template,
comment|/// \li member function template specialization,
comment|/// \li ObjC method,
comment|/// \li a typedef for a function pointer, member function pointer,
comment|///     ObjC block.
name|FunctionKind
block|,
comment|/// Something that we consider a "class":
comment|/// \li class/struct,
comment|/// \li class template,
comment|/// \li class template (partial) specialization.
name|ClassKind
block|,
comment|/// Something that we consider a "variable":
comment|/// \li namespace scope variables;
comment|/// \li static and non-static class data members;
comment|/// \li enumerators.
name|VariableKind
block|,
comment|/// A C++ namespace.
name|NamespaceKind
block|,
comment|/// A C++ typedef-name (a 'typedef' decl specifier or alias-declaration),
comment|/// see \c TypedefNameDecl.
name|TypedefKind
block|,
comment|/// An enumeration or scoped enumeration.
name|EnumKind
block|}
block|;
comment|/// What kind of template specialization \c CommentDecl is.
block|enum
name|TemplateDeclKind
block|{
name|NotTemplate
block|,
name|Template
block|,
name|TemplateSpecialization
block|,
name|TemplatePartialSpecialization
block|}
block|;
comment|/// If false, only \c CommentDecl is valid.
name|unsigned
name|IsFilled
operator|:
literal|1
block|;
comment|/// Simplified kind of \c CommentDecl, see \c DeclKind enum.
name|unsigned
name|Kind
operator|:
literal|3
block|;
comment|/// Is \c CommentDecl a template declaration.
name|unsigned
name|TemplateKind
operator|:
literal|2
block|;
comment|/// Is \c CommentDecl an ObjCMethodDecl.
name|unsigned
name|IsObjCMethod
operator|:
literal|1
block|;
comment|/// Is \c CommentDecl a non-static member function of C++ class or
comment|/// instance method of ObjC class.
comment|/// Can be true only if \c IsFunctionDecl is true.
name|unsigned
name|IsInstanceMethod
operator|:
literal|1
block|;
comment|/// Is \c CommentDecl a static member function of C++ class or
comment|/// class method of ObjC class.
comment|/// Can be true only if \c IsFunctionDecl is true.
name|unsigned
name|IsClassMethod
operator|:
literal|1
block|;
name|void
name|fill
argument_list|()
block|;
name|DeclKind
name|getKind
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|static_cast
operator|<
name|DeclKind
operator|>
operator|(
name|Kind
operator|)
return|;
block|}
name|TemplateDeclKind
name|getTemplateKind
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|static_cast
operator|<
name|TemplateDeclKind
operator|>
operator|(
name|TemplateKind
operator|)
return|;
block|}
expr|}
block|;
comment|/// A full comment attached to a declaration, contains block content.
name|class
name|FullComment
operator|:
name|public
name|Comment
block|{
name|ArrayRef
operator|<
name|BlockContentComment
operator|*
operator|>
name|Blocks
block|;
name|DeclInfo
operator|*
name|ThisDeclInfo
block|;
name|public
operator|:
name|FullComment
argument_list|(
name|ArrayRef
operator|<
name|BlockContentComment
operator|*
operator|>
name|Blocks
argument_list|,
name|DeclInfo
operator|*
name|D
argument_list|)
operator|:
name|Comment
argument_list|(
name|FullCommentKind
argument_list|,
name|SourceLocation
argument_list|()
argument_list|,
name|SourceLocation
argument_list|()
argument_list|)
block|,
name|Blocks
argument_list|(
name|Blocks
argument_list|)
block|,
name|ThisDeclInfo
argument_list|(
argument|D
argument_list|)
block|{
if|if
condition|(
name|Blocks
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|setSourceRange
argument_list|(
name|SourceRange
argument_list|(
name|Blocks
operator|.
name|front
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Blocks
operator|.
name|back
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
argument_list|)
block|;
name|setLocation
argument_list|(
name|Blocks
operator|.
name|front
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Comment *C
argument_list|)
block|{
return|return
name|C
operator|->
name|getCommentKind
argument_list|()
operator|==
name|FullCommentKind
return|;
block|}
name|child_iterator
name|child_begin
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Blocks
operator|.
name|begin
argument_list|()
operator|)
return|;
block|}
name|child_iterator
name|child_end
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|child_iterator
operator|>
operator|(
name|Blocks
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
return|return
name|ThisDeclInfo
operator|->
name|CommentDecl
return|;
block|}
specifier|const
name|DeclInfo
operator|*
name|getDeclInfo
argument_list|()
specifier|const
name|LLVM_READONLY
block|{
if|if
condition|(
operator|!
name|ThisDeclInfo
operator|->
name|IsFilled
condition|)
name|ThisDeclInfo
operator|->
name|fill
argument_list|()
expr_stmt|;
return|return
name|ThisDeclInfo
return|;
block|}
name|ArrayRef
operator|<
name|BlockContentComment
operator|*
operator|>
name|getBlocks
argument_list|()
specifier|const
block|{
return|return
name|Blocks
return|;
block|}
expr|}
block|; }
comment|// end namespace comments
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

