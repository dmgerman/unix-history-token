begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ObjCRuntime.h - Objective-C Runtime Configuration ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Defines types useful for describing an Objective-C runtime.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_BASIC_OBJCRUNTIME_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_BASIC_OBJCRUNTIME_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|/// \brief The basic abstraction for the target Objective-C runtime.
name|class
name|ObjCRuntime
block|{
name|public
label|:
comment|/// \brief The basic Objective-C runtimes that we know about.
enum|enum
name|Kind
block|{
comment|/// 'macosx' is the Apple-provided NeXT-derived runtime on Mac OS
comment|/// X platforms that use the non-fragile ABI; the version is a
comment|/// release of that OS.
name|MacOSX
block|,
comment|/// 'macosx-fragile' is the Apple-provided NeXT-derived runtime on
comment|/// Mac OS X platforms that use the fragile ABI; the version is a
comment|/// release of that OS.
name|FragileMacOSX
block|,
comment|/// 'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS
comment|/// simulator;  it is always non-fragile.  The version is a release
comment|/// version of iOS.
name|iOS
block|,
comment|/// 'watchos' is a variant of iOS for Apple's watchOS. The version
comment|/// is a release version of watchOS.
name|WatchOS
block|,
comment|/// 'gcc' is the Objective-C runtime shipped with GCC, implementing a
comment|/// fragile Objective-C ABI
name|GCC
block|,
comment|/// 'gnustep' is the modern non-fragile GNUstep runtime.
name|GNUstep
block|,
comment|/// 'objfw' is the Objective-C runtime included in ObjFW
name|ObjFW
block|}
enum|;
name|private
label|:
name|Kind
name|TheKind
decl_stmt|;
name|VersionTuple
name|Version
decl_stmt|;
name|public
label|:
comment|/// A bogus initialization of the runtime.
name|ObjCRuntime
argument_list|()
operator|:
name|TheKind
argument_list|(
argument|MacOSX
argument_list|)
block|{}
name|ObjCRuntime
argument_list|(
argument|Kind kind
argument_list|,
argument|const VersionTuple&version
argument_list|)
operator|:
name|TheKind
argument_list|(
name|kind
argument_list|)
operator|,
name|Version
argument_list|(
argument|version
argument_list|)
block|{}
name|void
name|set
argument_list|(
argument|Kind kind
argument_list|,
argument|VersionTuple version
argument_list|)
block|{
name|TheKind
operator|=
name|kind
block|;
name|Version
operator|=
name|version
block|;   }
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|TheKind
return|;
block|}
specifier|const
name|VersionTuple
operator|&
name|getVersion
argument_list|()
specifier|const
block|{
return|return
name|Version
return|;
block|}
comment|/// \brief Does this runtime follow the set of implied behaviors for a
comment|/// "non-fragile" ABI?
name|bool
name|isNonFragile
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
return|return
name|false
return|;
case|case
name|GCC
case|:
return|return
name|false
return|;
case|case
name|MacOSX
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|true
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
case|case
name|iOS
case|:
return|return
name|true
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// The inverse of isNonFragile():  does this runtime follow the set of
comment|/// implied behaviors for a "fragile" ABI?
name|bool
name|isFragile
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isNonFragile
argument_list|()
return|;
block|}
comment|/// The default dispatch mechanism to use for the specified architecture
name|bool
name|isLegacyDispatchDefaultForArch
argument_list|(
name|llvm
operator|::
name|Triple
operator|::
name|ArchType
name|Arch
argument_list|)
block|{
comment|// The GNUstep runtime uses a newer dispatch method by default from
comment|// version 1.6 onwards
if|if
condition|(
name|getKind
argument_list|()
operator|==
name|GNUstep
operator|&&
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
name|Arch
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|arm
operator|||
name|Arch
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|x86
operator|||
name|Arch
operator|==
name|llvm
operator|::
name|Triple
operator|::
name|x86_64
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|getKind
argument_list|()
operator|==
name|MacOSX
operator|)
operator|&&
name|isNonFragile
argument_list|()
operator|&&
operator|(
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|getVersion
argument_list|()
operator|<
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
return|return
name|Arch
operator|!=
name|llvm
operator|::
name|Triple
operator|::
name|x86_64
return|;
comment|// Except for deployment target of 10.5 or less,
comment|// Mac runtimes use legacy dispatch everywhere now.
return|return
name|true
return|;
block|}
comment|/// \brief Is this runtime basically of the GNU family of runtimes?
name|bool
name|isGNUFamily
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
case|case
name|MacOSX
case|:
case|case
name|iOS
case|:
case|case
name|WatchOS
case|:
return|return
name|false
return|;
case|case
name|GCC
case|:
case|case
name|GNUstep
case|:
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Is this runtime basically of the NeXT family of runtimes?
name|bool
name|isNeXTFamily
argument_list|()
specifier|const
block|{
comment|// For now, this is just the inverse of isGNUFamily(), but that's
comment|// not inherently true.
return|return
operator|!
name|isGNUFamily
argument_list|()
return|;
block|}
comment|/// \brief Does this runtime allow ARC at all?
name|bool
name|allowsARC
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
comment|// No stub library for the fragile runtime.
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|7
argument_list|)
return|;
case|case
name|MacOSX
case|:
return|return
name|true
return|;
case|case
name|iOS
case|:
return|return
name|true
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|GCC
case|:
return|return
name|false
return|;
case|case
name|GNUstep
case|:
return|return
name|true
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Does this runtime natively provide the ARC entrypoints?
comment|///
comment|/// ARC cannot be directly supported on a platform that does not provide
comment|/// these entrypoints, although it may be supportable via a stub
comment|/// library.
name|bool
name|hasNativeARC
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|7
argument_list|)
return|;
case|case
name|MacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|7
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|5
argument_list|)
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|GCC
case|:
return|return
name|false
return|;
case|case
name|GNUstep
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Does this runtime supports optimized setter entrypoints?
name|bool
name|hasOptimizedSetter
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
operator|(
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|6
argument_list|)
operator|)
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Does this runtime allow the use of __weak?
name|bool
name|allowsWeak
argument_list|()
specifier|const
block|{
return|return
name|hasNativeWeak
argument_list|()
return|;
block|}
comment|/// \brief Does this runtime natively provide ARC-compliant 'weak'
comment|/// entrypoints?
name|bool
name|hasNativeWeak
argument_list|()
specifier|const
block|{
comment|// Right now, this is always equivalent to whether the runtime
comment|// natively supports ARC decision.
return|return
name|hasNativeARC
argument_list|()
return|;
block|}
comment|/// \brief Does this runtime directly support the subscripting methods?
comment|///
comment|/// This is really a property of the library, not the runtime.
name|bool
name|hasSubscripting
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
return|return
name|false
return|;
case|case
name|MacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|6
argument_list|)
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
comment|// This is really a lie, because some implementations and versions
comment|// of the runtime do not support ARC.  Probably -fgnu-runtime
comment|// should imply a "maximal" runtime or something?
case|case
name|GCC
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|true
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Does this runtime allow sizeof or alignof on object types?
name|bool
name|allowsSizeofAlignof
argument_list|()
specifier|const
block|{
return|return
name|isFragile
argument_list|()
return|;
block|}
comment|/// \brief Does this runtime allow pointer arithmetic on objects?
comment|///
comment|/// This covers +, -, ++, --, and (if isSubscriptPointerArithmetic()
comment|/// yields true) [].
name|bool
name|allowsPointerArithmetic
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
case|case
name|GCC
case|:
return|return
name|true
return|;
case|case
name|MacOSX
case|:
case|case
name|iOS
case|:
case|case
name|WatchOS
case|:
case|case
name|GNUstep
case|:
case|case
name|ObjFW
case|:
return|return
name|false
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Is subscripting pointer arithmetic?
name|bool
name|isSubscriptPointerArithmetic
argument_list|()
specifier|const
block|{
return|return
name|allowsPointerArithmetic
argument_list|()
return|;
block|}
comment|/// \brief Does this runtime provide an objc_terminate function?
comment|///
comment|/// This is used in handlers for exceptions during the unwind process;
comment|/// without it, abort() must be used in pure ObjC files.
name|bool
name|hasTerminate
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|)
return|;
case|case
name|MacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|5
argument_list|)
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|GCC
case|:
return|return
name|false
return|;
case|case
name|GNUstep
case|:
return|return
name|false
return|;
case|case
name|ObjFW
case|:
return|return
name|false
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Does this runtime support weakly importing classes?
name|bool
name|hasWeakClassImport
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MacOSX
case|:
return|return
name|true
return|;
case|case
name|iOS
case|:
return|return
name|true
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|FragileMacOSX
case|:
return|return
name|false
return|;
case|case
name|GCC
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|true
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Does this runtime use zero-cost exceptions?
name|bool
name|hasUnwindExceptions
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MacOSX
case|:
return|return
name|true
return|;
case|case
name|iOS
case|:
return|return
name|true
return|;
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|FragileMacOSX
case|:
return|return
name|false
return|;
case|case
name|GCC
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|true
return|;
case|case
name|ObjFW
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"bad kind"
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasAtomicCopyHelper
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FragileMacOSX
case|:
case|case
name|MacOSX
case|:
case|case
name|iOS
case|:
case|case
name|WatchOS
case|:
return|return
name|true
return|;
case|case
name|GNUstep
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Is objc_unsafeClaimAutoreleasedReturnValue available?
name|bool
name|hasARCUnsafeClaimAutoreleasedReturnValue
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MacOSX
case|:
case|case
name|FragileMacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|11
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|9
argument_list|)
return|;
case|case
name|WatchOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|2
argument_list|)
return|;
case|case
name|GNUstep
case|:
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
comment|/// Are the empty collection symbols available?
name|bool
name|hasEmptyCollections
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|getKind
argument_list|()
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
name|MacOSX
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|10
argument_list|,
literal|11
argument_list|)
return|;
case|case
name|iOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|9
argument_list|)
return|;
case|case
name|WatchOS
case|:
return|return
name|getVersion
argument_list|()
operator|>=
name|VersionTuple
argument_list|(
literal|2
argument_list|)
return|;
block|}
block|}
comment|/// \brief Try to parse an Objective-C runtime specification from the given
comment|/// string.
comment|///
comment|/// \return true on error.
name|bool
name|tryParse
argument_list|(
argument|StringRef input
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|getAsString
argument_list|()
specifier|const
expr_stmt|;
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|ObjCRuntime
operator|&
name|left
operator|,
specifier|const
name|ObjCRuntime
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|getKind
argument_list|()
operator|==
name|right
operator|.
name|getKind
argument_list|()
operator|&&
name|left
operator|.
name|getVersion
argument_list|()
operator|==
name|right
operator|.
name|getVersion
argument_list|()
return|;
block|}
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|ObjCRuntime
operator|&
name|left
operator|,
specifier|const
name|ObjCRuntime
operator|&
name|right
operator|)
block|{
return|return
operator|!
operator|(
name|left
operator|==
name|right
operator|)
return|;
block|}
block|}
empty_stmt|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|out
operator|,
specifier|const
name|ObjCRuntime
operator|&
name|value
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

