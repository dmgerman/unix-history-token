begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ASTWriter.h - AST File Writer --------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the ASTWriter class, which writes an AST file
end_comment

begin_comment
comment|//  containing a serialized representation of a translation unit.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SERIALIZATION_ASTWRITER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SERIALIZATION_ASTWRITER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTMutationListener.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TemplateBase.h"
end_include

begin_include
include|#
directive|include
file|"clang/Frontend/PCHContainerOperations.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/SemaConsumer.h"
end_include

begin_include
include|#
directive|include
file|"clang/Serialization/ASTBitCodes.h"
end_include

begin_include
include|#
directive|include
file|"clang/Serialization/ASTDeserializationListener.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/MapVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SetVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitstreamWriter.h"
end_include

begin_include
include|#
directive|include
file|<queue>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|APFloat
decl_stmt|;
name|class
name|APInt
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|DeclarationName
decl_stmt|;
name|class
name|ASTContext
decl_stmt|;
name|class
name|Attr
decl_stmt|;
name|class
name|NestedNameSpecifier
decl_stmt|;
name|class
name|CXXBaseSpecifier
decl_stmt|;
name|class
name|CXXCtorInitializer
decl_stmt|;
name|class
name|FileEntry
decl_stmt|;
name|class
name|FPOptions
decl_stmt|;
name|class
name|HeaderSearch
decl_stmt|;
name|class
name|HeaderSearchOptions
decl_stmt|;
name|class
name|IdentifierResolver
decl_stmt|;
name|class
name|MacroDefinitionRecord
decl_stmt|;
name|class
name|MacroDirective
decl_stmt|;
name|class
name|MacroInfo
decl_stmt|;
name|class
name|OpaqueValueExpr
decl_stmt|;
name|class
name|OpenCLOptions
decl_stmt|;
name|class
name|ASTReader
decl_stmt|;
name|class
name|MemoryBufferCache
decl_stmt|;
name|class
name|Module
decl_stmt|;
name|class
name|ModuleFileExtension
decl_stmt|;
name|class
name|ModuleFileExtensionWriter
decl_stmt|;
name|class
name|PreprocessedEntity
decl_stmt|;
name|class
name|PreprocessingRecord
decl_stmt|;
name|class
name|Preprocessor
decl_stmt|;
name|class
name|RecordDecl
decl_stmt|;
name|class
name|Sema
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
struct_decl|struct
name|StoredDeclsList
struct_decl|;
name|class
name|SwitchCase
decl_stmt|;
name|class
name|TargetInfo
decl_stmt|;
name|class
name|Token
decl_stmt|;
name|class
name|VersionTuple
decl_stmt|;
name|class
name|ASTUnresolvedSet
decl_stmt|;
name|namespace
name|SrcMgr
block|{
name|class
name|SLocEntry
decl_stmt|;
block|}
comment|/// \brief Writes an AST file containing the contents of a translation unit.
comment|///
comment|/// The ASTWriter class produces a bitstream containing the serialized
comment|/// representation of a given abstract syntax tree and its supporting
comment|/// data structures. This bitstream can be de-serialized via an
comment|/// instance of the ASTReader class.
name|class
name|ASTWriter
range|:
name|public
name|ASTDeserializationListener
decl_stmt|,
name|public
name|ASTMutationListener
block|{
name|public
label|:
typedef|typedef
name|SmallVector
operator|<
name|uint64_t
operator|,
literal|64
operator|>
name|RecordData
expr_stmt|;
typedef|typedef
name|SmallVectorImpl
operator|<
name|uint64_t
operator|>
name|RecordDataImpl
expr_stmt|;
typedef|typedef
name|ArrayRef
operator|<
name|uint64_t
operator|>
name|RecordDataRef
expr_stmt|;
name|friend
name|class
name|ASTDeclWriter
decl_stmt|;
name|friend
name|class
name|ASTStmtWriter
decl_stmt|;
name|friend
name|class
name|ASTTypeWriter
decl_stmt|;
name|friend
name|class
name|ASTRecordWriter
decl_stmt|;
name|private
label|:
comment|/// \brief Map that provides the ID numbers of each type within the
comment|/// output stream, plus those deserialized from a chained PCH.
comment|///
comment|/// The ID numbers of types are consecutive (in order of discovery)
comment|/// and start at 1. 0 is reserved for NULL. When types are actually
comment|/// stored in the stream, the ID number is shifted by 2 bits to
comment|/// allow for the const/volatile qualifiers.
comment|///
comment|/// Keys in the map never have const/volatile qualifiers.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|QualType
operator|,
name|serialization
operator|::
name|TypeIdx
operator|,
name|serialization
operator|::
name|UnsafeQualTypeDenseMapInfo
operator|>
name|TypeIdxMap
expr_stmt|;
comment|/// \brief The bitstream writer used to emit this precompiled header.
name|llvm
operator|::
name|BitstreamWriter
operator|&
name|Stream
expr_stmt|;
comment|/// The buffer associated with the bitstream.
specifier|const
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Buffer
expr_stmt|;
comment|/// \brief The PCM manager which manages memory buffers for pcm files.
name|MemoryBufferCache
modifier|&
name|PCMCache
decl_stmt|;
comment|/// \brief The ASTContext we're writing.
name|ASTContext
modifier|*
name|Context
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The preprocessor we're writing.
name|Preprocessor
modifier|*
name|PP
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The reader of existing AST files, if we're chaining.
name|ASTReader
modifier|*
name|Chain
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The module we're currently writing, if any.
name|Module
modifier|*
name|WritingModule
init|=
name|nullptr
decl_stmt|;
comment|/// \brief The base directory for any relative paths we emit.
name|std
operator|::
name|string
name|BaseDirectory
expr_stmt|;
comment|/// \brief Indicates whether timestamps should be written to the produced
comment|/// module file. This is the case for files implicitly written to the
comment|/// module cache, where we need the timestamps to determine if the module
comment|/// file is up to date, but not otherwise.
name|bool
name|IncludeTimestamps
decl_stmt|;
comment|/// \brief Indicates when the AST writing is actively performing
comment|/// serialization, rather than just queueing updates.
name|bool
name|WritingAST
init|=
name|false
decl_stmt|;
comment|/// \brief Indicates that we are done serializing the collection of decls
comment|/// and types to emit.
name|bool
name|DoneWritingDeclsAndTypes
init|=
name|false
decl_stmt|;
comment|/// \brief Indicates that the AST contained compiler errors.
name|bool
name|ASTHasCompilerErrors
init|=
name|false
decl_stmt|;
comment|/// \brief Mapping from input file entries to the index into the
comment|/// offset table where information about that input file is stored.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|FileEntry
operator|*
operator|,
name|uint32_t
operator|>
name|InputFileIDs
expr_stmt|;
comment|/// \brief Stores a declaration or a type to be written to the AST file.
name|class
name|DeclOrType
block|{
name|public
label|:
name|DeclOrType
argument_list|(
name|Decl
operator|*
name|D
argument_list|)
operator|:
name|Stored
argument_list|(
name|D
argument_list|)
operator|,
name|IsType
argument_list|(
argument|false
argument_list|)
block|{ }
name|DeclOrType
argument_list|(
argument|QualType T
argument_list|)
operator|:
name|Stored
argument_list|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
operator|,
name|IsType
argument_list|(
argument|true
argument_list|)
block|{ }
name|bool
name|isType
argument_list|()
specifier|const
block|{
return|return
name|IsType
return|;
block|}
name|bool
name|isDecl
argument_list|()
specifier|const
block|{
return|return
operator|!
name|IsType
return|;
block|}
name|QualType
name|getType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isType
argument_list|()
operator|&&
literal|"Not a type!"
argument_list|)
block|;
return|return
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Stored
argument_list|)
return|;
block|}
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDecl
argument_list|()
operator|&&
literal|"Not a decl!"
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|Decl
operator|*
operator|>
operator|(
name|Stored
operator|)
return|;
block|}
name|private
label|:
name|void
modifier|*
name|Stored
decl_stmt|;
name|bool
name|IsType
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief The declarations and types to emit.
name|std
operator|::
name|queue
operator|<
name|DeclOrType
operator|>
name|DeclTypesToEmit
expr_stmt|;
comment|/// \brief The first ID number we can use for our own declarations.
name|serialization
operator|::
name|DeclID
name|FirstDeclID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_DECL_IDS
expr_stmt|;
comment|/// \brief The decl ID that will be assigned to the next new decl.
name|serialization
operator|::
name|DeclID
name|NextDeclID
operator|=
name|FirstDeclID
expr_stmt|;
comment|/// \brief Map that provides the ID numbers of each declaration within
comment|/// the output stream, as well as those deserialized from a chained PCH.
comment|///
comment|/// The ID numbers of declarations are consecutive (in order of
comment|/// discovery) and start at 2. 1 is reserved for the translation
comment|/// unit, while 0 is reserved for NULL.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Decl
operator|*
operator|,
name|serialization
operator|::
name|DeclID
operator|>
name|DeclIDs
expr_stmt|;
comment|/// \brief Offset of each declaration in the bitstream, indexed by
comment|/// the declaration's ID.
name|std
operator|::
name|vector
operator|<
name|serialization
operator|::
name|DeclOffset
operator|>
name|DeclOffsets
expr_stmt|;
comment|/// \brief Sorted (by file offset) vector of pairs of file offset/DeclID.
typedef|typedef
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|serialization
operator|::
name|DeclID
operator|>
operator|,
literal|64
operator|>
name|LocDeclIDsTy
expr_stmt|;
struct|struct
name|DeclIDInFileInfo
block|{
name|LocDeclIDsTy
name|DeclIDs
decl_stmt|;
comment|/// \brief Set when the DeclIDs vectors from all files are joined, this
comment|/// indicates the index that this particular vector has in the global one.
name|unsigned
name|FirstDeclIndex
decl_stmt|;
block|}
struct|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|FileID
operator|,
name|DeclIDInFileInfo
operator|*
operator|>
name|FileDeclIDsTy
expr_stmt|;
comment|/// \brief Map from file SLocEntries to info about the file-level declarations
comment|/// that it contains.
name|FileDeclIDsTy
name|FileDeclIDs
decl_stmt|;
name|void
name|associateDeclWithFile
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|,
name|serialization
operator|::
name|DeclID
argument_list|)
decl_stmt|;
comment|/// \brief The first ID number we can use for our own types.
name|serialization
operator|::
name|TypeID
name|FirstTypeID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_TYPE_IDS
expr_stmt|;
comment|/// \brief The type ID that will be assigned to the next new type.
name|serialization
operator|::
name|TypeID
name|NextTypeID
operator|=
name|FirstTypeID
expr_stmt|;
comment|/// \brief Map that provides the ID numbers of each type within the
comment|/// output stream, plus those deserialized from a chained PCH.
comment|///
comment|/// The ID numbers of types are consecutive (in order of discovery)
comment|/// and start at 1. 0 is reserved for NULL. When types are actually
comment|/// stored in the stream, the ID number is shifted by 2 bits to
comment|/// allow for the const/volatile qualifiers.
comment|///
comment|/// Keys in the map never have const/volatile qualifiers.
name|TypeIdxMap
name|TypeIdxs
decl_stmt|;
comment|/// \brief Offset of each type in the bitstream, indexed by
comment|/// the type's ID.
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|TypeOffsets
expr_stmt|;
comment|/// \brief The first ID number we can use for our own identifiers.
name|serialization
operator|::
name|IdentID
name|FirstIdentID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_IDENT_IDS
expr_stmt|;
comment|/// \brief The identifier ID that will be assigned to the next new identifier.
name|serialization
operator|::
name|IdentID
name|NextIdentID
operator|=
name|FirstIdentID
expr_stmt|;
comment|/// \brief Map that provides the ID numbers of each identifier in
comment|/// the output stream.
comment|///
comment|/// The ID numbers for identifiers are consecutive (in order of
comment|/// discovery), starting at 1. An ID of zero refers to a NULL
comment|/// IdentifierInfo.
name|llvm
operator|::
name|MapVector
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|,
name|serialization
operator|::
name|IdentID
operator|>
name|IdentifierIDs
expr_stmt|;
comment|/// \brief The first ID number we can use for our own macros.
name|serialization
operator|::
name|MacroID
name|FirstMacroID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_MACRO_IDS
expr_stmt|;
comment|/// \brief The identifier ID that will be assigned to the next new identifier.
name|serialization
operator|::
name|MacroID
name|NextMacroID
operator|=
name|FirstMacroID
expr_stmt|;
comment|/// \brief Map that provides the ID numbers of each macro.
name|llvm
operator|::
name|DenseMap
operator|<
name|MacroInfo
operator|*
operator|,
name|serialization
operator|::
name|MacroID
operator|>
name|MacroIDs
expr_stmt|;
struct|struct
name|MacroInfoToEmitData
block|{
specifier|const
name|IdentifierInfo
modifier|*
name|Name
decl_stmt|;
name|MacroInfo
modifier|*
name|MI
decl_stmt|;
name|serialization
operator|::
name|MacroID
name|ID
expr_stmt|;
block|}
struct|;
comment|/// \brief The macro infos to emit.
name|std
operator|::
name|vector
operator|<
name|MacroInfoToEmitData
operator|>
name|MacroInfosToEmit
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|,
name|uint64_t
operator|>
name|IdentMacroDirectivesOffsetMap
expr_stmt|;
comment|/// @name FlushStmt Caches
comment|/// @{
comment|/// \brief Set of parent Stmts for the currently serializing sub-stmt.
name|llvm
operator|::
name|DenseSet
operator|<
name|Stmt
operator|*
operator|>
name|ParentStmts
expr_stmt|;
comment|/// \brief Offsets of sub-stmts already serialized. The offset points
comment|/// just after the stmt record.
name|llvm
operator|::
name|DenseMap
operator|<
name|Stmt
operator|*
operator|,
name|uint64_t
operator|>
name|SubStmtEntries
expr_stmt|;
comment|/// @}
comment|/// \brief Offsets of each of the identifier IDs into the identifier
comment|/// table.
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|IdentifierOffsets
expr_stmt|;
comment|/// \brief The first ID number we can use for our own submodules.
name|serialization
operator|::
name|SubmoduleID
name|FirstSubmoduleID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_SUBMODULE_IDS
expr_stmt|;
comment|/// \brief The submodule ID that will be assigned to the next new submodule.
name|serialization
operator|::
name|SubmoduleID
name|NextSubmoduleID
operator|=
name|FirstSubmoduleID
expr_stmt|;
comment|/// \brief The first ID number we can use for our own selectors.
name|serialization
operator|::
name|SelectorID
name|FirstSelectorID
operator|=
name|serialization
operator|::
name|NUM_PREDEF_SELECTOR_IDS
expr_stmt|;
comment|/// \brief The selector ID that will be assigned to the next new selector.
name|serialization
operator|::
name|SelectorID
name|NextSelectorID
operator|=
name|FirstSelectorID
expr_stmt|;
comment|/// \brief Map that provides the ID numbers of each Selector.
name|llvm
operator|::
name|MapVector
operator|<
name|Selector
operator|,
name|serialization
operator|::
name|SelectorID
operator|>
name|SelectorIDs
expr_stmt|;
comment|/// \brief Offset of each selector within the method pool/selector
comment|/// table, indexed by the Selector ID (-1).
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|SelectorOffsets
expr_stmt|;
comment|/// \brief Mapping from macro definitions (as they occur in the preprocessing
comment|/// record) to the macro IDs.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|MacroDefinitionRecord
operator|*
operator|,
name|serialization
operator|::
name|PreprocessedEntityID
operator|>
name|MacroDefinitions
expr_stmt|;
comment|/// \brief Cache of indices of anonymous declarations within their lexical
comment|/// contexts.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Decl
operator|*
operator|,
name|unsigned
operator|>
name|AnonymousDeclarationNumbers
expr_stmt|;
comment|/// An update to a Decl.
name|class
name|DeclUpdate
block|{
comment|/// A DeclUpdateKind.
name|unsigned
name|Kind
decl_stmt|;
union|union
block|{
specifier|const
name|Decl
modifier|*
name|Dcl
decl_stmt|;
name|void
modifier|*
name|Type
decl_stmt|;
name|unsigned
name|Loc
decl_stmt|;
name|unsigned
name|Val
decl_stmt|;
name|Module
modifier|*
name|Mod
decl_stmt|;
specifier|const
name|Attr
modifier|*
name|Attribute
decl_stmt|;
block|}
union|;
name|public
label|:
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|)
block|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Dcl
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|const Decl *Dcl
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Dcl
argument_list|(
argument|Dcl
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|QualType Type
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Type
argument_list|(
argument|Type.getAsOpaquePtr()
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|SourceLocation Loc
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Loc
argument_list|(
argument|Loc.getRawEncoding()
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|unsigned Val
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Val
argument_list|(
argument|Val
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|Module *M
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Mod
argument_list|(
argument|M
argument_list|)
block|{}
name|DeclUpdate
argument_list|(
argument|unsigned Kind
argument_list|,
argument|const Attr *Attribute
argument_list|)
operator|:
name|Kind
argument_list|(
name|Kind
argument_list|)
operator|,
name|Attribute
argument_list|(
argument|Attribute
argument_list|)
block|{}
name|unsigned
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|Dcl
return|;
block|}
name|QualType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Type
argument_list|)
return|;
block|}
name|SourceLocation
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|Loc
argument_list|)
return|;
block|}
name|unsigned
name|getNumber
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|Module
operator|*
name|getModule
argument_list|()
specifier|const
block|{
return|return
name|Mod
return|;
block|}
specifier|const
name|Attr
operator|*
name|getAttr
argument_list|()
specifier|const
block|{
return|return
name|Attribute
return|;
block|}
block|}
empty_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|DeclUpdate
operator|,
literal|1
operator|>
name|UpdateRecord
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|MapVector
operator|<
specifier|const
name|Decl
operator|*
operator|,
name|UpdateRecord
operator|>
name|DeclUpdateMap
expr_stmt|;
comment|/// \brief Mapping from declarations that came from a chained PCH to the
comment|/// record containing modifications to them.
name|DeclUpdateMap
name|DeclUpdates
decl_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|Decl
operator|*
operator|,
name|Decl
operator|*
operator|>
name|FirstLatestDeclMap
expr_stmt|;
comment|/// \brief Map of first declarations from a chained PCH that point to the
comment|/// most recent declarations in another PCH.
name|FirstLatestDeclMap
name|FirstLatestDecls
decl_stmt|;
comment|/// \brief Declarations encountered that might be external
comment|/// definitions.
comment|///
comment|/// We keep track of external definitions and other 'interesting' declarations
comment|/// as we are emitting declarations to the AST file. The AST file contains a
comment|/// separate record for these declarations, which are provided to the AST
comment|/// consumer by the AST reader. This is behavior is required to properly cope with,
comment|/// e.g., tentative variable definitions that occur within
comment|/// headers. The declarations themselves are stored as declaration
comment|/// IDs, since they will be written out to an EAGERLY_DESERIALIZED_DECLS
comment|/// record.
name|SmallVector
operator|<
name|uint64_t
operator|,
literal|16
operator|>
name|EagerlyDeserializedDecls
expr_stmt|;
name|SmallVector
operator|<
name|uint64_t
operator|,
literal|16
operator|>
name|ModularCodegenDecls
expr_stmt|;
comment|/// \brief DeclContexts that have received extensions since their serialized
comment|/// form.
comment|///
comment|/// For namespaces, when we're chaining and encountering a namespace, we check
comment|/// if its primary namespace comes from the chain. If it does, we add the
comment|/// primary to this set, so that we can write out lexical content updates for
comment|/// it.
name|llvm
operator|::
name|SmallSetVector
operator|<
specifier|const
name|DeclContext
operator|*
operator|,
literal|16
operator|>
name|UpdatedDeclContexts
expr_stmt|;
comment|/// \brief Keeps track of declarations that we must emit, even though we're
comment|/// not guaranteed to be able to find them by walking the AST starting at the
comment|/// translation unit.
name|SmallVector
operator|<
specifier|const
name|Decl
operator|*
operator|,
literal|16
operator|>
name|DeclsToEmitEvenIfUnreferenced
expr_stmt|;
comment|/// \brief The set of Objective-C class that have categories we
comment|/// should serialize.
name|llvm
operator|::
name|SetVector
operator|<
name|ObjCInterfaceDecl
operator|*
operator|>
name|ObjCClassesWithCategories
expr_stmt|;
comment|/// \brief The set of declarations that may have redeclaration chains that
comment|/// need to be serialized.
name|llvm
operator|::
name|SmallVector
operator|<
specifier|const
name|Decl
operator|*
operator|,
literal|16
operator|>
name|Redeclarations
expr_stmt|;
comment|/// \brief A cache of the first local declaration for "interesting"
comment|/// redeclaration chains.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Decl
operator|*
operator|,
specifier|const
name|Decl
operator|*
operator|>
name|FirstLocalDeclCache
expr_stmt|;
comment|/// \brief Mapping from SwitchCase statements to IDs.
name|llvm
operator|::
name|DenseMap
operator|<
name|SwitchCase
operator|*
operator|,
name|unsigned
operator|>
name|SwitchCaseIDs
expr_stmt|;
comment|/// \brief The number of statements written to the AST file.
name|unsigned
name|NumStatements
init|=
literal|0
decl_stmt|;
comment|/// \brief The number of macros written to the AST file.
name|unsigned
name|NumMacros
init|=
literal|0
decl_stmt|;
comment|/// \brief The number of lexical declcontexts written to the AST
comment|/// file.
name|unsigned
name|NumLexicalDeclContexts
init|=
literal|0
decl_stmt|;
comment|/// \brief The number of visible declcontexts written to the AST
comment|/// file.
name|unsigned
name|NumVisibleDeclContexts
init|=
literal|0
decl_stmt|;
comment|/// \brief A mapping from each known submodule to its ID number, which will
comment|/// be a positive integer.
name|llvm
operator|::
name|DenseMap
operator|<
name|Module
operator|*
operator|,
name|unsigned
operator|>
name|SubmoduleIDs
expr_stmt|;
comment|/// \brief A list of the module file extension writers.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ModuleFileExtensionWriter
operator|>>
name|ModuleFileExtensionWriters
expr_stmt|;
comment|/// \brief Retrieve or create a submodule ID for this module.
name|unsigned
name|getSubmoduleID
parameter_list|(
name|Module
modifier|*
name|Mod
parameter_list|)
function_decl|;
comment|/// \brief Write the given subexpression to the bitstream.
name|void
name|WriteSubStmt
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|)
function_decl|;
name|void
name|WriteBlockInfoBlock
parameter_list|()
function_decl|;
name|void
name|WriteControlBlock
argument_list|(
name|Preprocessor
operator|&
name|PP
argument_list|,
name|ASTContext
operator|&
name|Context
argument_list|,
name|StringRef
name|isysroot
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|OutputFile
argument_list|)
decl_stmt|;
comment|/// Write out the signature and diagnostic options, and return the signature.
name|ASTFileSignature
name|writeUnhashedControlBlock
parameter_list|(
name|Preprocessor
modifier|&
name|PP
parameter_list|,
name|ASTContext
modifier|&
name|Context
parameter_list|)
function_decl|;
comment|/// Calculate hash of the pcm content.
specifier|static
name|ASTFileSignature
name|createSignature
parameter_list|(
name|StringRef
name|Bytes
parameter_list|)
function_decl|;
name|void
name|WriteInputFiles
parameter_list|(
name|SourceManager
modifier|&
name|SourceMgr
parameter_list|,
name|HeaderSearchOptions
modifier|&
name|HSOpts
parameter_list|,
name|bool
name|Modules
parameter_list|)
function_decl|;
name|void
name|WriteSourceManagerBlock
parameter_list|(
name|SourceManager
modifier|&
name|SourceMgr
parameter_list|,
specifier|const
name|Preprocessor
modifier|&
name|PP
parameter_list|)
function_decl|;
name|void
name|WritePreprocessor
parameter_list|(
specifier|const
name|Preprocessor
modifier|&
name|PP
parameter_list|,
name|bool
name|IsModule
parameter_list|)
function_decl|;
name|void
name|WriteHeaderSearch
parameter_list|(
specifier|const
name|HeaderSearch
modifier|&
name|HS
parameter_list|)
function_decl|;
name|void
name|WritePreprocessorDetail
parameter_list|(
name|PreprocessingRecord
modifier|&
name|PPRec
parameter_list|)
function_decl|;
name|void
name|WriteSubmodules
parameter_list|(
name|Module
modifier|*
name|WritingModule
parameter_list|)
function_decl|;
name|void
name|WritePragmaDiagnosticMappings
parameter_list|(
specifier|const
name|DiagnosticsEngine
modifier|&
name|Diag
parameter_list|,
name|bool
name|isModule
parameter_list|)
function_decl|;
name|unsigned
name|TypeExtQualAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|TypeFunctionProtoAbbrev
init|=
literal|0
decl_stmt|;
name|void
name|WriteTypeAbbrevs
parameter_list|()
function_decl|;
name|void
name|WriteType
parameter_list|(
name|QualType
name|T
parameter_list|)
function_decl|;
name|bool
name|isLookupResultExternal
parameter_list|(
name|StoredDeclsList
modifier|&
name|Result
parameter_list|,
name|DeclContext
modifier|*
name|DC
parameter_list|)
function_decl|;
name|bool
name|isLookupResultEntirelyExternal
parameter_list|(
name|StoredDeclsList
modifier|&
name|Result
parameter_list|,
name|DeclContext
modifier|*
name|DC
parameter_list|)
function_decl|;
name|void
name|GenerateNameLookupTable
argument_list|(
specifier|const
name|DeclContext
operator|*
name|DC
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|LookupTable
argument_list|)
decl_stmt|;
name|uint64_t
name|WriteDeclContextLexicalBlock
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|DeclContext
modifier|*
name|DC
parameter_list|)
function_decl|;
name|uint64_t
name|WriteDeclContextVisibleBlock
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|DeclContext
modifier|*
name|DC
parameter_list|)
function_decl|;
name|void
name|WriteTypeDeclOffsets
parameter_list|()
function_decl|;
name|void
name|WriteFileDeclIDsMap
parameter_list|()
function_decl|;
name|void
name|WriteComments
parameter_list|()
function_decl|;
name|void
name|WriteSelectors
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteReferencedSelectorsPool
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteIdentifierTable
parameter_list|(
name|Preprocessor
modifier|&
name|PP
parameter_list|,
name|IdentifierResolver
modifier|&
name|IdResolver
parameter_list|,
name|bool
name|IsModule
parameter_list|)
function_decl|;
name|void
name|WriteDeclUpdatesBlocks
parameter_list|(
name|RecordDataImpl
modifier|&
name|OffsetsRecord
parameter_list|)
function_decl|;
name|void
name|WriteDeclContextVisibleUpdate
parameter_list|(
specifier|const
name|DeclContext
modifier|*
name|DC
parameter_list|)
function_decl|;
name|void
name|WriteFPPragmaOptions
parameter_list|(
specifier|const
name|FPOptions
modifier|&
name|Opts
parameter_list|)
function_decl|;
name|void
name|WriteOpenCLExtensions
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteOpenCLExtensionTypes
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteOpenCLExtensionDecls
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteCUDAPragmas
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteObjCCategories
parameter_list|()
function_decl|;
name|void
name|WriteLateParsedTemplates
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteOptimizePragmaOptions
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteMSStructPragmaOptions
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteMSPointersToMembersPragmaOptions
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WritePackPragmaOptions
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|)
function_decl|;
name|void
name|WriteModuleFileExtension
parameter_list|(
name|Sema
modifier|&
name|SemaRef
parameter_list|,
name|ModuleFileExtensionWriter
modifier|&
name|Writer
parameter_list|)
function_decl|;
name|unsigned
name|DeclParmVarAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclContextLexicalAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclContextVisibleLookupAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|UpdateVisibleAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclRecordAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclTypedefAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclVarAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclFieldAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclEnumAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclObjCIvarAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclCXXMethodAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|DeclRefExprAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|CharacterLiteralAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|IntegerLiteralAbbrev
init|=
literal|0
decl_stmt|;
name|unsigned
name|ExprImplicitCastAbbrev
init|=
literal|0
decl_stmt|;
name|void
name|WriteDeclAbbrevs
parameter_list|()
function_decl|;
name|void
name|WriteDecl
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
name|ASTFileSignature
name|WriteASTCore
argument_list|(
name|Sema
operator|&
name|SemaRef
argument_list|,
name|StringRef
name|isysroot
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|OutputFile
argument_list|,
name|Module
operator|*
name|WritingModule
argument_list|)
decl_stmt|;
name|public
label|:
comment|/// \brief Create a new precompiled header writer that outputs to
comment|/// the given bitstream.
name|ASTWriter
argument_list|(
argument|llvm::BitstreamWriter&Stream
argument_list|,
argument|SmallVectorImpl<char>&Buffer
argument_list|,
argument|MemoryBufferCache&PCMCache
argument_list|,
argument|ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions
argument_list|,
argument|bool IncludeTimestamps = true
argument_list|)
empty_stmt|;
operator|~
name|ASTWriter
argument_list|()
name|override
expr_stmt|;
specifier|const
name|LangOptions
operator|&
name|getLangOpts
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief Get a timestamp for output into the AST file. The actual timestamp
comment|/// of the specified file may be ignored if we have been instructed to not
comment|/// include timestamps in the output file.
name|time_t
name|getTimestampForOutput
argument_list|(
specifier|const
name|FileEntry
operator|*
name|E
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Write a precompiled header for the given semantic analysis.
comment|///
comment|/// \param SemaRef a reference to the semantic analysis object that processed
comment|/// the AST to be written into the precompiled header.
comment|///
comment|/// \param WritingModule The module that we are writing. If null, we are
comment|/// writing a precompiled header.
comment|///
comment|/// \param isysroot if non-empty, write a relocatable file whose headers
comment|/// are relative to the given system root. If we're writing a module, its
comment|/// build directory will be used in preference to this if both are available.
comment|///
comment|/// \return the module signature, which eventually will be a hash of
comment|/// the module but currently is merely a random 32-bit number.
name|ASTFileSignature
name|WriteAST
argument_list|(
name|Sema
operator|&
name|SemaRef
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|OutputFile
argument_list|,
name|Module
operator|*
name|WritingModule
argument_list|,
name|StringRef
name|isysroot
argument_list|,
name|bool
name|hasErrors
operator|=
name|false
argument_list|)
decl_stmt|;
comment|/// \brief Emit a token.
name|void
name|AddToken
parameter_list|(
specifier|const
name|Token
modifier|&
name|Tok
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Emit a source location.
name|void
name|AddSourceLocation
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Emit a source range.
name|void
name|AddSourceRange
parameter_list|(
name|SourceRange
name|Range
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Emit a reference to an identifier.
name|void
name|AddIdentifierRef
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|II
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Get the unique number used to refer to the given selector.
name|serialization
operator|::
name|SelectorID
name|getSelectorRef
argument_list|(
argument|Selector Sel
argument_list|)
expr_stmt|;
comment|/// \brief Get the unique number used to refer to the given identifier.
name|serialization
operator|::
name|IdentID
name|getIdentifierRef
argument_list|(
specifier|const
name|IdentifierInfo
operator|*
name|II
argument_list|)
expr_stmt|;
comment|/// \brief Get the unique number used to refer to the given macro.
name|serialization
operator|::
name|MacroID
name|getMacroRef
argument_list|(
name|MacroInfo
operator|*
name|MI
argument_list|,
specifier|const
name|IdentifierInfo
operator|*
name|Name
argument_list|)
expr_stmt|;
comment|/// \brief Determine the ID of an already-emitted macro.
name|serialization
operator|::
name|MacroID
name|getMacroID
argument_list|(
name|MacroInfo
operator|*
name|MI
argument_list|)
expr_stmt|;
name|uint64_t
name|getMacroDirectivesOffset
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|)
function_decl|;
comment|/// \brief Emit a reference to a type.
name|void
name|AddTypeRef
parameter_list|(
name|QualType
name|T
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Force a type to be emitted and get its ID.
name|serialization
operator|::
name|TypeID
name|GetOrCreateTypeID
argument_list|(
argument|QualType T
argument_list|)
expr_stmt|;
comment|/// \brief Determine the type ID of an already-emitted type.
name|serialization
operator|::
name|TypeID
name|getTypeID
argument_list|(
argument|QualType T
argument_list|)
specifier|const
expr_stmt|;
comment|/// \brief Find the first local declaration of a given local redeclarable
comment|/// decl.
specifier|const
name|Decl
modifier|*
name|getFirstLocalDecl
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|/// \brief Is this a local declaration (that is, one that will be written to
comment|/// our AST file)? This is the case for declarations that are neither imported
comment|/// from another AST file nor predefined.
name|bool
name|IsLocalDecl
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
block|{
if|if
condition|(
name|D
operator|->
name|isFromASTFile
argument_list|()
condition|)
return|return
name|false
return|;
name|auto
name|I
init|=
name|DeclIDs
operator|.
name|find
argument_list|(
name|D
argument_list|)
decl_stmt|;
return|return
operator|(
name|I
operator|==
name|DeclIDs
operator|.
name|end
argument_list|()
operator|||
name|I
operator|->
name|second
operator|>=
name|serialization
operator|::
name|NUM_PREDEF_DECL_IDS
operator|)
return|;
block|}
empty_stmt|;
comment|/// \brief Emit a reference to a declaration.
name|void
name|AddDeclRef
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Force a declaration to be emitted and get its ID.
name|serialization
operator|::
name|DeclID
name|GetDeclRef
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|)
expr_stmt|;
comment|/// \brief Determine the declaration ID of an already-emitted
comment|/// declaration.
name|serialization
operator|::
name|DeclID
name|getDeclID
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|)
expr_stmt|;
name|unsigned
name|getAnonymousDeclarationNumber
parameter_list|(
specifier|const
name|NamedDecl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|/// \brief Add a string to the given record.
name|void
name|AddString
parameter_list|(
name|StringRef
name|Str
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Convert a path from this build process into one that is appropriate
comment|/// for emission in the module file.
name|bool
name|PreparePathForOutput
argument_list|(
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|Path
argument_list|)
decl_stmt|;
comment|/// \brief Add a path to the given record.
name|void
name|AddPath
parameter_list|(
name|StringRef
name|Path
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Emit the current record with the given path as a blob.
name|void
name|EmitRecordWithPath
parameter_list|(
name|unsigned
name|Abbrev
parameter_list|,
name|RecordDataRef
name|Record
parameter_list|,
name|StringRef
name|Path
parameter_list|)
function_decl|;
comment|/// \brief Add a version tuple to the given record
name|void
name|AddVersionTuple
parameter_list|(
specifier|const
name|VersionTuple
modifier|&
name|Version
parameter_list|,
name|RecordDataImpl
modifier|&
name|Record
parameter_list|)
function_decl|;
comment|/// \brief Retrieve or create a submodule ID for this module, or return 0 if
comment|/// the submodule is neither local (a submodle of the currently-written module)
comment|/// nor from an imported module.
name|unsigned
name|getLocalOrImportedSubmoduleID
parameter_list|(
name|Module
modifier|*
name|Mod
parameter_list|)
function_decl|;
comment|/// \brief Note that the identifier II occurs at the given offset
comment|/// within the identifier table.
name|void
name|SetIdentifierOffset
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|II
parameter_list|,
name|uint32_t
name|Offset
parameter_list|)
function_decl|;
comment|/// \brief Note that the selector Sel occurs at the given offset
comment|/// within the method pool/selector table.
name|void
name|SetSelectorOffset
parameter_list|(
name|Selector
name|Sel
parameter_list|,
name|uint32_t
name|Offset
parameter_list|)
function_decl|;
comment|/// \brief Record an ID for the given switch-case statement.
name|unsigned
name|RecordSwitchCaseID
parameter_list|(
name|SwitchCase
modifier|*
name|S
parameter_list|)
function_decl|;
comment|/// \brief Retrieve the ID for the given switch-case statement.
name|unsigned
name|getSwitchCaseID
parameter_list|(
name|SwitchCase
modifier|*
name|S
parameter_list|)
function_decl|;
name|void
name|ClearSwitchCaseIDs
parameter_list|()
function_decl|;
name|unsigned
name|getTypeExtQualAbbrev
argument_list|()
specifier|const
block|{
return|return
name|TypeExtQualAbbrev
return|;
block|}
name|unsigned
name|getTypeFunctionProtoAbbrev
argument_list|()
specifier|const
block|{
return|return
name|TypeFunctionProtoAbbrev
return|;
block|}
name|unsigned
name|getDeclParmVarAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclParmVarAbbrev
return|;
block|}
name|unsigned
name|getDeclRecordAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclRecordAbbrev
return|;
block|}
name|unsigned
name|getDeclTypedefAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclTypedefAbbrev
return|;
block|}
name|unsigned
name|getDeclVarAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclVarAbbrev
return|;
block|}
name|unsigned
name|getDeclFieldAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclFieldAbbrev
return|;
block|}
name|unsigned
name|getDeclEnumAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclEnumAbbrev
return|;
block|}
name|unsigned
name|getDeclObjCIvarAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclObjCIvarAbbrev
return|;
block|}
name|unsigned
name|getDeclCXXMethodAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclCXXMethodAbbrev
return|;
block|}
name|unsigned
name|getDeclRefExprAbbrev
argument_list|()
specifier|const
block|{
return|return
name|DeclRefExprAbbrev
return|;
block|}
name|unsigned
name|getCharacterLiteralAbbrev
argument_list|()
specifier|const
block|{
return|return
name|CharacterLiteralAbbrev
return|;
block|}
name|unsigned
name|getIntegerLiteralAbbrev
argument_list|()
specifier|const
block|{
return|return
name|IntegerLiteralAbbrev
return|;
block|}
name|unsigned
name|getExprImplicitCastAbbrev
argument_list|()
specifier|const
block|{
return|return
name|ExprImplicitCastAbbrev
return|;
block|}
name|bool
name|hasChain
argument_list|()
specifier|const
block|{
return|return
name|Chain
return|;
block|}
name|ASTReader
operator|*
name|getChain
argument_list|()
specifier|const
block|{
return|return
name|Chain
return|;
block|}
name|private
label|:
comment|// ASTDeserializationListener implementation
name|void
name|ReaderInitialized
argument_list|(
name|ASTReader
operator|*
name|Reader
argument_list|)
name|override
decl_stmt|;
name|void
name|IdentifierRead
argument_list|(
name|serialization
operator|::
name|IdentID
name|ID
argument_list|,
name|IdentifierInfo
operator|*
name|II
argument_list|)
name|override
decl_stmt|;
name|void
name|MacroRead
argument_list|(
name|serialization
operator|::
name|MacroID
name|ID
argument_list|,
name|MacroInfo
operator|*
name|MI
argument_list|)
name|override
decl_stmt|;
name|void
name|TypeRead
argument_list|(
name|serialization
operator|::
name|TypeIdx
name|Idx
argument_list|,
name|QualType
name|T
argument_list|)
name|override
decl_stmt|;
name|void
name|SelectorRead
argument_list|(
name|serialization
operator|::
name|SelectorID
name|ID
argument_list|,
name|Selector
name|Sel
argument_list|)
name|override
decl_stmt|;
name|void
name|MacroDefinitionRead
argument_list|(
name|serialization
operator|::
name|PreprocessedEntityID
name|ID
argument_list|,
name|MacroDefinitionRecord
operator|*
name|MD
argument_list|)
name|override
decl_stmt|;
name|void
name|ModuleRead
argument_list|(
name|serialization
operator|::
name|SubmoduleID
name|ID
argument_list|,
name|Module
operator|*
name|Mod
argument_list|)
name|override
decl_stmt|;
comment|// ASTMutationListener implementation.
name|void
name|CompletedTagDefinition
argument_list|(
specifier|const
name|TagDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedVisibleDecl
argument_list|(
specifier|const
name|DeclContext
operator|*
name|DC
argument_list|,
specifier|const
name|Decl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedCXXImplicitMember
argument_list|(
specifier|const
name|CXXRecordDecl
operator|*
name|RD
argument_list|,
specifier|const
name|Decl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedCXXTemplateSpecialization
argument_list|(
specifier|const
name|ClassTemplateDecl
operator|*
name|TD
argument_list|,
specifier|const
name|ClassTemplateSpecializationDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedCXXTemplateSpecialization
argument_list|(
specifier|const
name|VarTemplateDecl
operator|*
name|TD
argument_list|,
specifier|const
name|VarTemplateSpecializationDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedCXXTemplateSpecialization
argument_list|(
specifier|const
name|FunctionTemplateDecl
operator|*
name|TD
argument_list|,
specifier|const
name|FunctionDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|ResolvedExceptionSpec
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|)
name|override
decl_stmt|;
name|void
name|DeducedReturnType
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|,
name|QualType
name|ReturnType
argument_list|)
name|override
decl_stmt|;
name|void
name|ResolvedOperatorDelete
argument_list|(
specifier|const
name|CXXDestructorDecl
operator|*
name|DD
argument_list|,
specifier|const
name|FunctionDecl
operator|*
name|Delete
argument_list|)
name|override
decl_stmt|;
name|void
name|CompletedImplicitDefinition
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|StaticDataMemberInstantiated
argument_list|(
specifier|const
name|VarDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|DefaultArgumentInstantiated
argument_list|(
specifier|const
name|ParmVarDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|DefaultMemberInitializerInstantiated
argument_list|(
specifier|const
name|FieldDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|FunctionDefinitionInstantiated
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedObjCCategoryToInterface
argument_list|(
specifier|const
name|ObjCCategoryDecl
operator|*
name|CatD
argument_list|,
specifier|const
name|ObjCInterfaceDecl
operator|*
name|IFD
argument_list|)
name|override
decl_stmt|;
name|void
name|DeclarationMarkedUsed
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|DeclarationMarkedOpenMPThreadPrivate
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|)
name|override
decl_stmt|;
name|void
name|DeclarationMarkedOpenMPDeclareTarget
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|,
specifier|const
name|Attr
operator|*
name|Attr
argument_list|)
name|override
decl_stmt|;
name|void
name|RedefinedHiddenDefinition
argument_list|(
specifier|const
name|NamedDecl
operator|*
name|D
argument_list|,
name|Module
operator|*
name|M
argument_list|)
name|override
decl_stmt|;
name|void
name|AddedAttributeToRecord
argument_list|(
specifier|const
name|Attr
operator|*
name|Attr
argument_list|,
specifier|const
name|RecordDecl
operator|*
name|Record
argument_list|)
name|override
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief An object for streaming information to a record.
name|class
name|ASTRecordWriter
block|{
name|ASTWriter
modifier|*
name|Writer
decl_stmt|;
name|ASTWriter
operator|::
name|RecordDataImpl
operator|*
name|Record
expr_stmt|;
comment|/// \brief Statements that we've encountered while serializing a
comment|/// declaration or type.
name|SmallVector
operator|<
name|Stmt
operator|*
operator|,
literal|16
operator|>
name|StmtsToEmit
expr_stmt|;
comment|/// \brief Indices of record elements that describe offsets within the
comment|/// bitcode. These will be converted to offsets relative to the current
comment|/// record when emitted.
name|SmallVector
operator|<
name|unsigned
operator|,
literal|8
operator|>
name|OffsetIndices
expr_stmt|;
comment|/// \brief Flush all of the statements and expressions that have
comment|/// been added to the queue via AddStmt().
name|void
name|FlushStmts
parameter_list|()
function_decl|;
name|void
name|FlushSubStmts
parameter_list|()
function_decl|;
name|void
name|PrepareToEmit
parameter_list|(
name|uint64_t
name|MyOffset
parameter_list|)
block|{
comment|// Convert offsets into relative form.
for|for
control|(
name|unsigned
name|I
range|:
name|OffsetIndices
control|)
block|{
name|auto
operator|&
name|StoredOffset
operator|=
operator|(
operator|*
name|Record
operator|)
index|[
name|I
index|]
expr_stmt|;
name|assert
argument_list|(
name|StoredOffset
operator|<
name|MyOffset
operator|&&
literal|"invalid offset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|StoredOffset
condition|)
name|StoredOffset
operator|=
name|MyOffset
operator|-
name|StoredOffset
expr_stmt|;
block|}
name|OffsetIndices
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|public
label|:
comment|/// Construct a ASTRecordWriter that uses the default encoding scheme.
name|ASTRecordWriter
argument_list|(
name|ASTWriter
operator|&
name|Writer
argument_list|,
name|ASTWriter
operator|::
name|RecordDataImpl
operator|&
name|Record
argument_list|)
operator|:
name|Writer
argument_list|(
operator|&
name|Writer
argument_list|)
operator|,
name|Record
argument_list|(
argument|&Record
argument_list|)
block|{}
comment|/// Construct a ASTRecordWriter that uses the same encoding scheme as another
comment|/// ASTRecordWriter.
name|ASTRecordWriter
argument_list|(
name|ASTRecordWriter
operator|&
name|Parent
argument_list|,
name|ASTWriter
operator|::
name|RecordDataImpl
operator|&
name|Record
argument_list|)
operator|:
name|Writer
argument_list|(
name|Parent
operator|.
name|Writer
argument_list|)
operator|,
name|Record
argument_list|(
argument|&Record
argument_list|)
block|{}
comment|/// Copying an ASTRecordWriter is almost certainly a bug.
name|ASTRecordWriter
argument_list|(
specifier|const
name|ASTRecordWriter
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|ASTRecordWriter
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
comment|/// \brief Extract the underlying record storage.
name|ASTWriter
operator|::
name|RecordDataImpl
operator|&
name|getRecordData
argument_list|()
specifier|const
block|{
return|return
operator|*
name|Record
return|;
block|}
comment|/// \brief Minimal vector-like interface.
comment|/// @{
name|void
name|push_back
parameter_list|(
name|uint64_t
name|N
parameter_list|)
block|{
name|Record
operator|->
name|push_back
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|InputIterator
operator|>
name|void
name|append
argument_list|(
argument|InputIterator begin
argument_list|,
argument|InputIterator end
argument_list|)
block|{
name|Record
operator|->
name|append
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
block|;   }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Record
operator|->
name|empty
argument_list|()
return|;
block|}
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Record
operator|->
name|size
argument_list|()
return|;
block|}
name|uint64_t
modifier|&
name|operator
function|[]
parameter_list|(
name|size_t
name|N
parameter_list|)
block|{
return|return
operator|(
operator|*
name|Record
operator|)
index|[
name|N
index|]
return|;
block|}
comment|/// @}
comment|/// \brief Emit the record to the stream, followed by its substatements, and
comment|/// return its offset.
comment|// FIXME: Allow record producers to suggest Abbrevs.
name|uint64_t
name|Emit
parameter_list|(
name|unsigned
name|Code
parameter_list|,
name|unsigned
name|Abbrev
init|=
literal|0
parameter_list|)
block|{
name|uint64_t
name|Offset
init|=
name|Writer
operator|->
name|Stream
operator|.
name|GetCurrentBitNo
argument_list|()
decl_stmt|;
name|PrepareToEmit
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
name|Writer
operator|->
name|Stream
operator|.
name|EmitRecord
argument_list|(
name|Code
argument_list|,
operator|*
name|Record
argument_list|,
name|Abbrev
argument_list|)
expr_stmt|;
name|FlushStmts
argument_list|()
expr_stmt|;
return|return
name|Offset
return|;
block|}
comment|/// \brief Emit the record to the stream, preceded by its substatements.
name|uint64_t
name|EmitStmt
parameter_list|(
name|unsigned
name|Code
parameter_list|,
name|unsigned
name|Abbrev
init|=
literal|0
parameter_list|)
block|{
name|FlushSubStmts
argument_list|()
expr_stmt|;
name|PrepareToEmit
argument_list|(
name|Writer
operator|->
name|Stream
operator|.
name|GetCurrentBitNo
argument_list|()
argument_list|)
expr_stmt|;
name|Writer
operator|->
name|Stream
operator|.
name|EmitRecord
argument_list|(
name|Code
argument_list|,
operator|*
name|Record
argument_list|,
name|Abbrev
argument_list|)
expr_stmt|;
return|return
name|Writer
operator|->
name|Stream
operator|.
name|GetCurrentBitNo
argument_list|()
return|;
block|}
comment|/// \brief Add a bit offset into the record. This will be converted into an
comment|/// offset relative to the current record when emitted.
name|void
name|AddOffset
parameter_list|(
name|uint64_t
name|BitOffset
parameter_list|)
block|{
name|OffsetIndices
operator|.
name|push_back
argument_list|(
name|Record
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Record
operator|->
name|push_back
argument_list|(
name|BitOffset
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Add the given statement or expression to the queue of
comment|/// statements to emit.
comment|///
comment|/// This routine should be used when emitting types and declarations
comment|/// that have expressions as part of their formulation. Once the
comment|/// type or declaration has been written, Emit() will write
comment|/// the corresponding statements just after the record.
name|void
name|AddStmt
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|)
block|{
name|StmtsToEmit
operator|.
name|push_back
argument_list|(
name|S
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Add a definition for the given function to the queue of statements
comment|/// to emit.
name|void
name|AddFunctionDefinition
parameter_list|(
specifier|const
name|FunctionDecl
modifier|*
name|FD
parameter_list|)
function_decl|;
comment|/// \brief Emit a source location.
name|void
name|AddSourceLocation
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddSourceLocation
argument_list|(
name|Loc
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a source range.
name|void
name|AddSourceRange
parameter_list|(
name|SourceRange
name|Range
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddSourceRange
argument_list|(
name|Range
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit an integral value.
name|void
name|AddAPInt
argument_list|(
specifier|const
name|llvm
operator|::
name|APInt
operator|&
name|Value
argument_list|)
decl_stmt|;
comment|/// \brief Emit a signed integral value.
name|void
name|AddAPSInt
argument_list|(
specifier|const
name|llvm
operator|::
name|APSInt
operator|&
name|Value
argument_list|)
decl_stmt|;
comment|/// \brief Emit a floating-point value.
name|void
name|AddAPFloat
argument_list|(
specifier|const
name|llvm
operator|::
name|APFloat
operator|&
name|Value
argument_list|)
decl_stmt|;
comment|/// \brief Emit a reference to an identifier.
name|void
name|AddIdentifierRef
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|II
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddIdentifierRef
argument_list|(
name|II
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a Selector (which is a smart pointer reference).
name|void
name|AddSelectorRef
parameter_list|(
name|Selector
name|S
parameter_list|)
function_decl|;
comment|/// \brief Emit a CXXTemporary.
name|void
name|AddCXXTemporary
parameter_list|(
specifier|const
name|CXXTemporary
modifier|*
name|Temp
parameter_list|)
function_decl|;
comment|/// \brief Emit a C++ base specifier.
name|void
name|AddCXXBaseSpecifier
parameter_list|(
specifier|const
name|CXXBaseSpecifier
modifier|&
name|Base
parameter_list|)
function_decl|;
comment|/// \brief Emit a set of C++ base specifiers.
name|void
name|AddCXXBaseSpecifiers
argument_list|(
name|ArrayRef
operator|<
name|CXXBaseSpecifier
operator|>
name|Bases
argument_list|)
decl_stmt|;
comment|/// \brief Emit a reference to a type.
name|void
name|AddTypeRef
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddTypeRef
argument_list|(
name|T
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emits a reference to a declarator info.
name|void
name|AddTypeSourceInfo
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|)
function_decl|;
comment|/// \brief Emits a type with source-location information.
name|void
name|AddTypeLoc
parameter_list|(
name|TypeLoc
name|TL
parameter_list|)
function_decl|;
comment|/// \brief Emits a template argument location info.
name|void
name|AddTemplateArgumentLocInfo
argument_list|(
name|TemplateArgument
operator|::
name|ArgKind
name|Kind
argument_list|,
specifier|const
name|TemplateArgumentLocInfo
operator|&
name|Arg
argument_list|)
decl_stmt|;
comment|/// \brief Emits a template argument location.
name|void
name|AddTemplateArgumentLoc
parameter_list|(
specifier|const
name|TemplateArgumentLoc
modifier|&
name|Arg
parameter_list|)
function_decl|;
comment|/// \brief Emits an AST template argument list info.
name|void
name|AddASTTemplateArgumentListInfo
parameter_list|(
specifier|const
name|ASTTemplateArgumentListInfo
modifier|*
name|ASTTemplArgList
parameter_list|)
function_decl|;
comment|/// \brief Emit a reference to a declaration.
name|void
name|AddDeclRef
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddDeclRef
argument_list|(
name|D
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a declaration name.
name|void
name|AddDeclarationName
parameter_list|(
name|DeclarationName
name|Name
parameter_list|)
function_decl|;
name|void
name|AddDeclarationNameLoc
parameter_list|(
specifier|const
name|DeclarationNameLoc
modifier|&
name|DNLoc
parameter_list|,
name|DeclarationName
name|Name
parameter_list|)
function_decl|;
name|void
name|AddDeclarationNameInfo
parameter_list|(
specifier|const
name|DeclarationNameInfo
modifier|&
name|NameInfo
parameter_list|)
function_decl|;
name|void
name|AddQualifierInfo
parameter_list|(
specifier|const
name|QualifierInfo
modifier|&
name|Info
parameter_list|)
function_decl|;
comment|/// \brief Emit a nested name specifier.
name|void
name|AddNestedNameSpecifier
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|)
function_decl|;
comment|/// \brief Emit a nested name specifier with source-location information.
name|void
name|AddNestedNameSpecifierLoc
parameter_list|(
name|NestedNameSpecifierLoc
name|NNS
parameter_list|)
function_decl|;
comment|/// \brief Emit a template name.
name|void
name|AddTemplateName
parameter_list|(
name|TemplateName
name|Name
parameter_list|)
function_decl|;
comment|/// \brief Emit a template argument.
name|void
name|AddTemplateArgument
parameter_list|(
specifier|const
name|TemplateArgument
modifier|&
name|Arg
parameter_list|)
function_decl|;
comment|/// \brief Emit a template parameter list.
name|void
name|AddTemplateParameterList
parameter_list|(
specifier|const
name|TemplateParameterList
modifier|*
name|TemplateParams
parameter_list|)
function_decl|;
comment|/// \brief Emit a template argument list.
name|void
name|AddTemplateArgumentList
parameter_list|(
specifier|const
name|TemplateArgumentList
modifier|*
name|TemplateArgs
parameter_list|)
function_decl|;
comment|/// \brief Emit a UnresolvedSet structure.
name|void
name|AddUnresolvedSet
parameter_list|(
specifier|const
name|ASTUnresolvedSet
modifier|&
name|Set
parameter_list|)
function_decl|;
comment|/// \brief Emit a CXXCtorInitializer array.
name|void
name|AddCXXCtorInitializers
argument_list|(
name|ArrayRef
operator|<
name|CXXCtorInitializer
operator|*
operator|>
name|CtorInits
argument_list|)
decl_stmt|;
name|void
name|AddCXXDefinitionData
parameter_list|(
specifier|const
name|CXXRecordDecl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|/// \brief Emit a string.
name|void
name|AddString
parameter_list|(
name|StringRef
name|Str
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddString
argument_list|(
name|Str
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a path.
name|void
name|AddPath
parameter_list|(
name|StringRef
name|Path
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddPath
argument_list|(
name|Path
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a version tuple.
name|void
name|AddVersionTuple
parameter_list|(
specifier|const
name|VersionTuple
modifier|&
name|Version
parameter_list|)
block|{
return|return
name|Writer
operator|->
name|AddVersionTuple
argument_list|(
name|Version
argument_list|,
operator|*
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Emit a list of attributes.
name|void
name|AddAttributes
argument_list|(
name|ArrayRef
operator|<
specifier|const
name|Attr
operator|*
operator|>
name|Attrs
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief AST and semantic-analysis consumer that generates a
comment|/// precompiled header from the parsed source code.
name|class
name|PCHGenerator
range|:
name|public
name|SemaConsumer
block|{
specifier|const
name|Preprocessor
operator|&
name|PP
block|;
name|std
operator|::
name|string
name|OutputFile
block|;
name|std
operator|::
name|string
name|isysroot
block|;
name|Sema
operator|*
name|SemaPtr
block|;
name|std
operator|::
name|shared_ptr
operator|<
name|PCHBuffer
operator|>
name|Buffer
block|;
name|llvm
operator|::
name|BitstreamWriter
name|Stream
block|;
name|ASTWriter
name|Writer
block|;
name|bool
name|AllowASTWithErrors
block|;
name|protected
operator|:
name|ASTWriter
operator|&
name|getWriter
argument_list|()
block|{
return|return
name|Writer
return|;
block|}
specifier|const
name|ASTWriter
operator|&
name|getWriter
argument_list|()
specifier|const
block|{
return|return
name|Writer
return|;
block|}
name|SmallVectorImpl
operator|<
name|char
operator|>
operator|&
name|getPCH
argument_list|()
specifier|const
block|{
return|return
name|Buffer
operator|->
name|Data
return|;
block|}
name|public
operator|:
name|PCHGenerator
argument_list|(
argument|const Preprocessor&PP
argument_list|,
argument|StringRef OutputFile
argument_list|,
argument|StringRef isysroot
argument_list|,
argument|std::shared_ptr<PCHBuffer> Buffer
argument_list|,
argument|ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions
argument_list|,
argument|bool AllowASTWithErrors = false
argument_list|,
argument|bool IncludeTimestamps = true
argument_list|)
block|;
operator|~
name|PCHGenerator
argument_list|()
name|override
block|;
name|void
name|InitializeSema
argument_list|(
argument|Sema&S
argument_list|)
name|override
block|{
name|SemaPtr
operator|=
operator|&
name|S
block|; }
name|void
name|HandleTranslationUnit
argument_list|(
argument|ASTContext&Ctx
argument_list|)
name|override
block|;
name|ASTMutationListener
operator|*
name|GetASTMutationListener
argument_list|()
name|override
block|;
name|ASTDeserializationListener
operator|*
name|GetASTDeserializationListener
argument_list|()
name|override
block|;
name|bool
name|hasEmittedPCH
argument_list|()
specifier|const
block|{
return|return
name|Buffer
operator|->
name|IsComplete
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

