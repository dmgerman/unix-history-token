begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Parser.h - C Language Parser ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Parser interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_PARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_PARSER_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/CodeCompletionHandler.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/DeclSpec.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PrettyStackTrace.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|<stack>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|PragmaHandler
decl_stmt|;
name|class
name|Scope
decl_stmt|;
name|class
name|DeclGroupRef
decl_stmt|;
name|class
name|DiagnosticBuilder
decl_stmt|;
name|class
name|Parser
decl_stmt|;
name|class
name|PragmaUnusedHandler
decl_stmt|;
name|class
name|ColonProtectionRAIIObject
decl_stmt|;
name|class
name|InMessageExpressionRAIIObject
decl_stmt|;
comment|/// PrettyStackTraceParserEntry - If a crash happens while the parser is active,
comment|/// an entry is printed for it.
name|class
name|PrettyStackTraceParserEntry
range|:
name|public
name|llvm
operator|::
name|PrettyStackTraceEntry
block|{
specifier|const
name|Parser
operator|&
name|P
block|;
name|public
operator|:
name|PrettyStackTraceParserEntry
argument_list|(
specifier|const
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{}
name|virtual
name|void
name|print
argument_list|(
argument|llvm::raw_ostream&OS
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// PrecedenceLevels - These are precedences for the binary/ternary
comment|/// operators in the C99 grammar.  These have been named to relate
comment|/// with the C99 grammar productions.  Low precedences numbers bind
comment|/// more weakly than high numbers.
name|namespace
name|prec
block|{
enum|enum
name|Level
block|{
name|Unknown
init|=
literal|0
block|,
comment|// Not binary operator.
name|Comma
init|=
literal|1
block|,
comment|// ,
name|Assignment
init|=
literal|2
block|,
comment|// =, *=, /=, %=, +=, -=,<<=,>>=,&=, ^=, |=
name|Conditional
init|=
literal|3
block|,
comment|// ?
name|LogicalOr
init|=
literal|4
block|,
comment|// ||
name|LogicalAnd
init|=
literal|5
block|,
comment|//&&
name|InclusiveOr
init|=
literal|6
block|,
comment|// |
name|ExclusiveOr
init|=
literal|7
block|,
comment|// ^
name|And
init|=
literal|8
block|,
comment|//&
name|Equality
init|=
literal|9
block|,
comment|// ==, !=
name|Relational
init|=
literal|10
block|,
comment|//>=,<=,>,<
name|Shift
init|=
literal|11
block|,
comment|//<<,>>
name|Additive
init|=
literal|12
block|,
comment|// -, +
name|Multiplicative
init|=
literal|13
block|,
comment|// *, /, %
name|PointerToMember
init|=
literal|14
comment|// .*, ->*
block|}
enum|;
block|}
comment|/// Parser - This implements a parser for the C family of languages.  After
comment|/// parsing units of the grammar, productions are invoked to handle whatever has
comment|/// been read.
comment|///
name|class
name|Parser
range|:
name|public
name|CodeCompletionHandler
block|{
name|friend
name|class
name|PragmaUnusedHandler
block|;
name|friend
name|class
name|ColonProtectionRAIIObject
block|;
name|friend
name|class
name|InMessageExpressionRAIIObject
block|;
name|friend
name|class
name|ParenBraceBracketBalancer
block|;
name|PrettyStackTraceParserEntry
name|CrashInfo
block|;
name|Preprocessor
operator|&
name|PP
block|;
comment|/// Tok - The current token we are peeking ahead.  All parsing methods assume
comment|/// that this is valid.
name|Token
name|Tok
block|;
comment|// PrevTokLocation - The location of the token we previously
comment|// consumed. This token is used for diagnostics where we expected to
comment|// see a token following another token (e.g., the ';' at the end of
comment|// a statement).
name|SourceLocation
name|PrevTokLocation
block|;
name|unsigned
name|short
name|ParenCount
block|,
name|BracketCount
block|,
name|BraceCount
block|;
comment|/// Actions - These are the callbacks we invoke as we parse various constructs
comment|/// in the file.
name|Sema
operator|&
name|Actions
block|;
name|Diagnostic
operator|&
name|Diags
block|;
comment|/// ScopeCache - Cache scopes to reduce malloc traffic.
block|enum
block|{
name|ScopeCacheSize
operator|=
literal|16
block|}
block|;
name|unsigned
name|NumCachedScopes
block|;
name|Scope
operator|*
name|ScopeCache
index|[
name|ScopeCacheSize
index|]
block|;
comment|/// Ident_super - IdentifierInfo for "super", to support fast
comment|/// comparison.
name|IdentifierInfo
operator|*
name|Ident_super
block|;
comment|/// Ident_vector and Ident_pixel - cached IdentifierInfo's for
comment|/// "vector" and "pixel" fast comparison.  Only present if
comment|/// AltiVec enabled.
name|IdentifierInfo
operator|*
name|Ident_vector
block|;
name|IdentifierInfo
operator|*
name|Ident_pixel
block|;
comment|/// C++0x contextual keywords.
name|mutable
name|IdentifierInfo
operator|*
name|Ident_final
block|;
name|mutable
name|IdentifierInfo
operator|*
name|Ident_override
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|AlignHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|GCCVisibilityHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|OptionsHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|PackHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|UnusedHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|WeakHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|FPContractHandler
block|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|OpenCLExtensionHandler
block|;
comment|/// Whether the '>' token acts as an operator or not. This will be
comment|/// true except when we are parsing an expression within a C++
comment|/// template argument list, where the '>' closes the template
comment|/// argument list.
name|bool
name|GreaterThanIsOperator
block|;
comment|/// ColonIsSacred - When this is false, we aggressively try to recover from
comment|/// code like "foo : bar" as if it were a typo for "foo :: bar".  This is not
comment|/// safe in case statements and a few other things.  This is managed by the
comment|/// ColonProtectionRAIIObject RAII object.
name|bool
name|ColonIsSacred
block|;
comment|/// \brief When true, we are directly inside an Ojective-C messsage
comment|/// send expression.
comment|///
comment|/// This is managed by the \c InMessageExpressionRAIIObject class, and
comment|/// should not be set directly.
name|bool
name|InMessageExpression
block|;
comment|/// The "depth" of the template parameters currently being parsed.
name|unsigned
name|TemplateParameterDepth
block|;
comment|/// Factory object for creating AttributeList objects.
name|AttributeList
operator|::
name|Factory
name|AttrFactory
block|;
name|public
operator|:
name|Parser
argument_list|(
name|Preprocessor
operator|&
name|PP
argument_list|,
name|Sema
operator|&
name|Actions
argument_list|)
block|;
operator|~
name|Parser
argument_list|()
block|;
specifier|const
name|LangOptions
operator|&
name|getLang
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getLangOptions
argument_list|()
return|;
block|}
specifier|const
name|TargetInfo
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getTargetInfo
argument_list|()
return|;
block|}
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
specifier|const
block|{
return|return
name|PP
return|;
block|}
name|Sema
operator|&
name|getActions
argument_list|()
specifier|const
block|{
return|return
name|Actions
return|;
block|}
specifier|const
name|Token
operator|&
name|getCurToken
argument_list|()
specifier|const
block|{
return|return
name|Tok
return|;
block|}
name|Scope
operator|*
name|getCurScope
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|getCurScope
argument_list|()
return|;
block|}
comment|// Type forwarding.  All of these are statically 'void*', but they may all be
comment|// different actual classes based on the actions in place.
typedef|typedef
name|Expr
name|ExprTy
typedef|;
typedef|typedef
name|Stmt
name|StmtTy
typedef|;
typedef|typedef
name|OpaquePtr
operator|<
name|DeclGroupRef
operator|>
name|DeclGroupPtrTy
expr_stmt|;
typedef|typedef
name|CXXBaseSpecifier
name|BaseTy
typedef|;
typedef|typedef
name|CXXCtorInitializer
name|MemInitTy
typedef|;
typedef|typedef
name|NestedNameSpecifier
name|CXXScopeTy
typedef|;
typedef|typedef
name|TemplateParameterList
name|TemplateParamsTy
typedef|;
typedef|typedef
name|OpaquePtr
operator|<
name|TemplateName
operator|>
name|TemplateTy
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|TemplateParameterList
operator|*
operator|,
literal|4
operator|>
name|TemplateParameterLists
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|ExprResult
name|ExprResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|StmtResult
name|StmtResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|BaseResult
name|BaseResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|MemInitResult
name|MemInitResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|TypeResult
name|TypeResult
expr_stmt|;
typedef|typedef
name|Expr
modifier|*
name|ExprArg
typedef|;
typedef|typedef
name|ASTMultiPtr
operator|<
name|Stmt
operator|*
operator|>
name|MultiStmtArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|FullExprArg
name|FullExprArg
expr_stmt|;
comment|/// Adorns a ExprResult with Actions to make it an ExprResult
name|ExprResult
name|Owned
parameter_list|(
name|ExprResult
name|res
parameter_list|)
block|{
return|return
name|ExprResult
argument_list|(
name|res
argument_list|)
return|;
block|}
comment|/// Adorns a StmtResult with Actions to make it an StmtResult
name|StmtResult
name|Owned
parameter_list|(
name|StmtResult
name|res
parameter_list|)
block|{
return|return
name|StmtResult
argument_list|(
name|res
argument_list|)
return|;
block|}
name|ExprResult
name|ExprError
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|StmtResult
name|StmtError
parameter_list|()
block|{
return|return
name|StmtResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|ExprResult
name|ExprError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|ExprError
argument_list|()
return|;
block|}
name|StmtResult
name|StmtError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|StmtError
argument_list|()
return|;
block|}
name|ExprResult
name|ExprEmpty
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|false
argument_list|)
return|;
block|}
comment|// Parsing methods.
comment|/// ParseTranslationUnit - All in one method that initializes parses, and
comment|/// shuts down the parser.
name|void
name|ParseTranslationUnit
parameter_list|()
function_decl|;
comment|/// Initialize - Warm up the parser.
comment|///
name|void
name|Initialize
parameter_list|()
function_decl|;
comment|/// ParseTopLevelDecl - Parse one top-level declaration. Returns true if
comment|/// the EOF was encountered.
name|bool
name|ParseTopLevelDecl
parameter_list|(
name|DeclGroupPtrTy
modifier|&
name|Result
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|FinishPendingObjCActions
parameter_list|()
function_decl|;
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Low-Level token peeking and consumption methods.
comment|//
comment|/// isTokenParen - Return true if the cur token is '(' or ')'.
name|bool
name|isTokenParen
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_paren
return|;
block|}
comment|/// isTokenBracket - Return true if the cur token is '[' or ']'.
name|bool
name|isTokenBracket
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_square
return|;
block|}
comment|/// isTokenBrace - Return true if the cur token is '{' or '}'.
name|bool
name|isTokenBrace
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_brace
return|;
block|}
comment|/// isTokenStringLiteral - True if this token is a string-literal.
comment|///
name|bool
name|isTokenStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|wide_string_literal
return|;
block|}
comment|/// \brief Returns true if the current token is a '=' or '==' and
comment|/// false otherwise. If it's '==', we assume that it's a typo and we emit
comment|/// DiagID and a fixit hint to turn '==' -> '='.
name|bool
name|isTokenEqualOrMistypedEqualEqual
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
comment|/// ConsumeToken - Consume the current 'peek token' and lex the next one.
comment|/// This does not work with all kinds of tokens: strings and specific other
comment|/// tokens must be consumed with custom methods below.  This returns the
comment|/// location of the consumed token.
name|SourceLocation
name|ConsumeToken
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|isTokenStringLiteral
argument_list|()
operator|&&
operator|!
name|isTokenParen
argument_list|()
operator|&&
operator|!
name|isTokenBracket
argument_list|()
operator|&&
operator|!
name|isTokenBrace
argument_list|()
operator|&&
literal|"Should consume special tokens with Consume*Token"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
condition|)
block|{
name|CodeCompletionRecovery
argument_list|()
expr_stmt|;
return|return
name|ConsumeCodeCompletionToken
argument_list|()
return|;
block|}
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeAnyToken - Dispatch to the right Consume* method based on the
comment|/// current token type.  This should only be used in cases where the type of
comment|/// the token really isn't known, e.g. in error recovery.
name|SourceLocation
name|ConsumeAnyToken
parameter_list|()
block|{
if|if
condition|(
name|isTokenParen
argument_list|()
condition|)
return|return
name|ConsumeParen
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBracket
argument_list|()
condition|)
return|return
name|ConsumeBracket
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBrace
argument_list|()
condition|)
return|return
name|ConsumeBrace
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenStringLiteral
argument_list|()
condition|)
return|return
name|ConsumeStringToken
argument_list|()
return|;
else|else
return|return
name|ConsumeToken
argument_list|()
return|;
block|}
comment|/// ConsumeParen - This consume method keeps the paren count up-to-date.
comment|///
name|SourceLocation
name|ConsumeParen
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenParen
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
condition|)
operator|++
name|ParenCount
expr_stmt|;
elseif|else
if|if
condition|(
name|ParenCount
condition|)
operator|--
name|ParenCount
expr_stmt|;
comment|// Don't let unbalanced )'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBracket - This consume method keeps the bracket count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBracket
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBracket
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
condition|)
operator|++
name|BracketCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BracketCount
condition|)
operator|--
name|BracketCount
expr_stmt|;
comment|// Don't let unbalanced ]'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBrace - This consume method keeps the brace count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBrace
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBrace
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
condition|)
operator|++
name|BraceCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BraceCount
condition|)
operator|--
name|BraceCount
expr_stmt|;
comment|// Don't let unbalanced }'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeStringToken - Consume the current 'peek token', lexing a new one
comment|/// and returning the token kind.  This method is specific to strings, as it
comment|/// handles string literal concatenation, as per C99 5.1.1.2, translation
comment|/// phase #6.
name|SourceLocation
name|ConsumeStringToken
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenStringLiteral
argument_list|()
operator|&&
literal|"Should only consume string literals with this method"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// \brief Consume the current code-completion token.
comment|///
comment|/// This routine should be called to consume the code-completion token once
comment|/// a code-completion action has already been invoked.
name|SourceLocation
name|ConsumeCodeCompletionToken
parameter_list|()
block|{
name|assert
argument_list|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|///\ brief When we are consuming a code-completion token within having
comment|/// matched specific position in the grammar, provide code-completion results
comment|/// based on context.
name|void
name|CodeCompletionRecovery
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for #pragma unused(...)
name|void
name|HandlePragmaUnused
parameter_list|()
function_decl|;
comment|/// GetLookAheadToken - This peeks ahead N tokens and returns that token
comment|/// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
comment|/// returns the token after Tok, etc.
comment|///
comment|/// Note that this differs from the Preprocessor's LookAhead method, because
comment|/// the Parser always has one token lexed that the preprocessor doesn't.
comment|///
specifier|const
name|Token
modifier|&
name|GetLookAheadToken
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|==
literal|0
operator|||
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
condition|)
return|return
name|Tok
return|;
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
name|N
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// NextToken - This peeks ahead one token and returns it without
comment|/// consuming it.
specifier|const
name|Token
modifier|&
name|NextToken
parameter_list|()
block|{
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// getTypeAnnotation - Read a parsed type out of an annotation token.
specifier|static
name|ParsedType
name|getTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|)
block|{
return|return
name|ParsedType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|void
name|setTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|,
name|ParsedType
name|T
parameter_list|)
block|{
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// TryAnnotateTypeOrScopeToken - If the current token position is on a
comment|/// typename (possibly qualified in C++) or a C++ scope specifier not followed
comment|/// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens
comment|/// with a single annotation token representing the typename or C++ scope
comment|/// respectively.
comment|/// This simplifies handling of C++ scope specifiers and allows efficient
comment|/// backtracking without the need to re-parse and resolve nested-names and
comment|/// typenames.
comment|/// It will mainly be called when we expect to treat identifiers as typenames
comment|/// (if they are typenames). For example, in C we do not expect identifiers
comment|/// inside expressions to be treated as typenames so it will not be called
comment|/// for expressions in C.
comment|///
comment|/// This returns true if the token was annotated.
name|bool
name|TryAnnotateTypeOrScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|)
function_decl|;
comment|/// TryAnnotateCXXScopeToken - Like TryAnnotateTypeOrScopeToken but
comment|/// only annotates C++ scope specifiers.  This returns true if there
comment|/// was an unrecoverable error.
name|bool
name|TryAnnotateCXXScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|)
function_decl|;
comment|/// TryAltiVecToken - Check for context-sensitive AltiVec identifier tokens,
comment|/// replacing them with the non-context-sensitive keywords.  This returns
comment|/// true if the token was replaced.
name|bool
name|TryAltiVecToken
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getLang
argument_list|()
operator|.
name|AltiVec
operator|||
operator|(
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
operator|&&
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_pixel
operator|)
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecTokenOutOfLine
argument_list|(
name|DS
argument_list|,
name|Loc
argument_list|,
name|PrevSpec
argument_list|,
name|DiagID
argument_list|,
name|isInvalid
argument_list|)
return|;
block|}
comment|/// TryAltiVecVectorToken - Check for context-sensitive AltiVec vector
comment|/// identifier token, replacing it with the non-context-sensitive __vector.
comment|/// This returns true if the token was replaced.
name|bool
name|TryAltiVecVectorToken
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getLang
argument_list|()
operator|.
name|AltiVec
operator|||
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecVectorTokenOutOfLine
argument_list|()
return|;
block|}
name|bool
name|TryAltiVecVectorTokenOutOfLine
parameter_list|()
function_decl|;
name|bool
name|TryAltiVecTokenOutOfLine
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
function_decl|;
comment|/// TentativeParsingAction - An object that is used as a kind of "tentative
comment|/// parsing transaction". It gets instantiated to mark the token position and
comment|/// after the token consumption is done, Commit() or Revert() is called to
comment|/// either "commit the consumed tokens" or revert to the previously marked
comment|/// token position. Example:
comment|///
comment|///   TentativeParsingAction TPA(*this);
comment|///   ConsumeToken();
comment|///   ....
comment|///   TPA.Revert();
comment|///
name|class
name|TentativeParsingAction
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Token
name|PrevTok
decl_stmt|;
name|bool
name|isActive
decl_stmt|;
name|public
label|:
name|explicit
name|TentativeParsingAction
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{
name|PrevTok
operator|=
name|P
operator|.
name|Tok
block|;
name|P
operator|.
name|PP
operator|.
name|EnableBacktrackAtThisPos
argument_list|()
block|;
name|isActive
operator|=
name|true
block|;     }
name|void
name|Commit
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|CommitBacktrackedTokens
argument_list|()
block|;
name|isActive
operator|=
name|false
block|;     }
name|void
name|Revert
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|Backtrack
argument_list|()
block|;
name|P
operator|.
name|Tok
operator|=
name|PrevTok
block|;
name|isActive
operator|=
name|false
block|;     }
operator|~
name|TentativeParsingAction
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isActive
operator|&&
literal|"Forgot to call Commit or Revert!"
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|/// MatchRHSPunctuation - For punctuation with a LHS and RHS (e.g. '['/']'),
comment|/// this helper function matches and consumes the specified RHS token if
comment|/// present.  If not present, it emits the specified diagnostic indicating
comment|/// that the parser failed to match the RHS of the token at LHSLoc.  LHSName
comment|/// should be the name of the unmatched LHS token.  This returns the location
comment|/// of the consumed token.
name|SourceLocation
name|MatchRHSPunctuation
argument_list|(
name|tok
operator|::
name|TokenKind
name|RHSTok
argument_list|,
name|SourceLocation
name|LHSLoc
argument_list|)
decl_stmt|;
comment|/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the
comment|/// input.  If so, it is consumed and false is returned.
comment|///
comment|/// If the input is malformed, this emits the specified diagnostic.  Next, if
comment|/// SkipToTok is specified, it calls SkipUntil(SkipToTok).  Finally, true is
comment|/// returned.
name|bool
name|ExpectAndConsume
argument_list|(
name|tok
operator|::
name|TokenKind
name|ExpectedTok
argument_list|,
name|unsigned
name|Diag
argument_list|,
specifier|const
name|char
operator|*
name|DiagMsg
operator|=
literal|""
argument_list|,
name|tok
operator|::
name|TokenKind
name|SkipToTok
operator|=
name|tok
operator|::
name|unknown
argument_list|)
decl_stmt|;
comment|/// \brief The parser expects a semicolon and, if present, will consume it.
comment|///
comment|/// If the next token is not a semicolon, this emits the specified diagnostic,
comment|/// or, if there's just some closing-delimiter noise (e.g., ')' or ']') prior
comment|/// to the semicolon, consumes that extra token.
name|bool
name|ExpectAndConsumeSemi
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Scope manipulation
comment|/// ParseScope - Introduces a new scope for parsing. The kind of
comment|/// scope is determined by ScopeFlags. Objects of this type should
comment|/// be created on the stack to coincide with the position where the
comment|/// parser enters the new scope, and this object's constructor will
comment|/// create that new scope. Similarly, once the object is destroyed
comment|/// the parser will exit the scope.
name|class
name|ParseScope
block|{
name|Parser
modifier|*
name|Self
decl_stmt|;
name|ParseScope
argument_list|(
specifier|const
name|ParseScope
operator|&
argument_list|)
expr_stmt|;
comment|// do not implement
name|ParseScope
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ParseScope
operator|&
operator|)
decl_stmt|;
comment|// do not implement
name|public
label|:
comment|// ParseScope - Construct a new object to manage a scope in the
comment|// parser Self where the new Scope is created with the flags
comment|// ScopeFlags, but only when ManageScope is true (the default). If
comment|// ManageScope is false, this object does nothing.
name|ParseScope
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool ManageScope = true
argument_list|)
block|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
if|if
condition|(
name|ManageScope
condition|)
name|Self
operator|->
name|EnterScope
argument_list|(
name|ScopeFlags
argument_list|)
expr_stmt|;
else|else
name|this
operator|->
name|Self
operator|=
literal|0
expr_stmt|;
block|}
comment|// Exit - Exit the scope associated with this object now, rather
comment|// than waiting until the object is destroyed.
name|void
name|Exit
parameter_list|()
block|{
if|if
condition|(
name|Self
condition|)
block|{
name|Self
operator|->
name|ExitScope
argument_list|()
expr_stmt|;
name|Self
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|~
name|ParseScope
argument_list|()
block|{
name|Exit
argument_list|()
block|;     }
block|}
empty_stmt|;
comment|/// EnterScope - Start a new scope.
name|void
name|EnterScope
parameter_list|(
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
comment|/// ExitScope - Pop a scope off the scope stack.
name|void
name|ExitScope
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Diagnostic Emission and Error recovery.
name|public
label|:
name|DiagnosticBuilder
name|Diag
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|DiagnosticBuilder
name|Diag
parameter_list|(
specifier|const
name|Token
modifier|&
name|Tok
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|SuggestParentheses
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DK
parameter_list|,
name|SourceRange
name|ParenRange
parameter_list|)
function_decl|;
comment|/// SkipUntil - Read tokens until we get to the specified token, then consume
comment|/// it (unless DontConsume is true).  Because we cannot guarantee that the
comment|/// token will ever occur, this skips to the next token, or to some likely
comment|/// good stopping point.  If StopAtSemi is true, skipping will stop at a ';'
comment|/// character.
comment|///
comment|/// If SkipUntil finds the specified token, it returns true, otherwise it
comment|/// returns false.
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
block|{
return|return
name|SkipUntil
argument_list|(
operator|&
name|T
argument_list|,
literal|1
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|,
name|StopAtCodeCompletion
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
literal|2
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|,
name|StopAtCodeCompletion
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
specifier|const
name|tok
operator|::
name|TokenKind
operator|*
name|Toks
argument_list|,
name|unsigned
name|NumToks
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Lexing and parsing of C++ inline methods.
struct_decl|struct
name|ParsingClass
struct_decl|;
comment|/// [class.mem]p1: "... the class is regarded as complete within
comment|/// - function bodies
comment|/// - default arguments
comment|/// - exception-specifications (TODO: C++0x)
comment|/// - and brace-or-equal-initializers (TODO: C++0x)
comment|/// for non-static data members (including such things in nested classes)."
comment|/// LateParsedDeclarations build the tree of those elements so they can
comment|/// be parsed after parsing the top-level class.
name|class
name|LateParsedDeclaration
block|{
name|public
label|:
name|virtual
operator|~
name|LateParsedDeclaration
argument_list|()
expr_stmt|;
name|virtual
name|void
name|ParseLexedMethodDeclarations
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedMethodDefs
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// Inner node of the LateParsedDeclaration tree that parses
comment|/// all its members recursively.
name|class
name|LateParsedClass
range|:
name|public
name|LateParsedDeclaration
block|{
name|public
operator|:
name|LateParsedClass
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|ParsingClass
operator|*
name|C
argument_list|)
block|;
name|virtual
operator|~
name|LateParsedClass
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedMethodDeclarations
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedMethodDefs
argument_list|()
block|;
name|private
operator|:
name|Parser
operator|*
name|Self
block|;
name|ParsingClass
operator|*
name|Class
block|;   }
decl_stmt|;
comment|/// Contains the lexed tokens of a member function definition
comment|/// which needs to be parsed at the end of the class declaration
comment|/// after parsing all other member declarations.
name|struct
name|LexedMethod
range|:
name|public
name|LateParsedDeclaration
block|{
name|Parser
operator|*
name|Self
block|;
name|Decl
operator|*
name|D
block|;
name|CachedTokens
name|Toks
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// othewise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
name|explicit
name|LexedMethod
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|MD
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|D
argument_list|(
name|MD
argument_list|)
block|,
name|TemplateScope
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|void
name|ParseLexedMethodDefs
argument_list|()
block|;   }
decl_stmt|;
comment|/// LateParsedDefaultArgument - Keeps track of a parameter that may
comment|/// have a default argument that cannot be parsed yet because it
comment|/// occurs within a member function declaration inside the class
comment|/// (C++ [class.mem]p2).
struct|struct
name|LateParsedDefaultArgument
block|{
name|explicit
name|LateParsedDefaultArgument
argument_list|(
name|Decl
operator|*
name|P
argument_list|,
name|CachedTokens
operator|*
name|Toks
operator|=
literal|0
argument_list|)
operator|:
name|Param
argument_list|(
name|P
argument_list|)
operator|,
name|Toks
argument_list|(
argument|Toks
argument_list|)
block|{ }
comment|/// Param - The parameter declaration for this parameter.
name|Decl
operator|*
name|Param
expr_stmt|;
comment|/// Toks - The sequence of tokens that comprises the default
comment|/// argument expression, not including the '=' or the terminating
comment|/// ')' or ','. This will be NULL for parameters that have no
comment|/// default argument.
name|CachedTokens
modifier|*
name|Toks
decl_stmt|;
block|}
struct|;
comment|/// LateParsedMethodDeclaration - A method declaration inside a class that
comment|/// contains at least one entity whose parsing needs to be delayed
comment|/// until the class itself is completely-defined, such as a default
comment|/// argument (C++ [class.mem]p2).
name|struct
name|LateParsedMethodDeclaration
range|:
name|public
name|LateParsedDeclaration
block|{
name|explicit
name|LateParsedMethodDeclaration
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|M
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|Method
argument_list|(
name|M
argument_list|)
block|,
name|TemplateScope
argument_list|(
argument|false
argument_list|)
block|{ }
name|virtual
name|void
name|ParseLexedMethodDeclarations
argument_list|()
block|;
name|Parser
operator|*
name|Self
block|;
comment|/// Method - The method declaration.
name|Decl
operator|*
name|Method
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// othewise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
comment|/// DefaultArgs - Contains the parameters of the function and
comment|/// their default arguments. At least one of the parameters will
comment|/// have a default argument, but all of the parameters of the
comment|/// method will be stored so that they can be reintroduced into
comment|/// scope at the appropriate times.
name|llvm
operator|::
name|SmallVector
operator|<
name|LateParsedDefaultArgument
block|,
literal|8
operator|>
name|DefaultArgs
block|;   }
decl_stmt|;
comment|/// LateParsedDeclarationsContainer - During parsing of a top (non-nested)
comment|/// C++ class, its method declarations that contain parts that won't be
comment|/// parsed until after the definiton is completed (C++ [class.mem]p2),
comment|/// the method declarations and possibly attached inline definitions
comment|/// will be stored here with the tokens that will be parsed to create those entities.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|LateParsedDeclaration
operator|*
operator|,
literal|2
operator|>
name|LateParsedDeclarationsContainer
expr_stmt|;
comment|/// \brief Representation of a class that has been parsed, including
comment|/// any member function declarations or definitions that need to be
comment|/// parsed after the corresponding top-level class is complete.
struct|struct
name|ParsingClass
block|{
name|ParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|:
name|TopLevelClass
argument_list|(
name|TopLevelClass
argument_list|)
operator|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
operator|,
name|TagOrTemplate
argument_list|(
argument|TagOrTemplate
argument_list|)
block|{ }
comment|/// \brief Whether this is a "top-level" class, meaning that it is
comment|/// not nested within another class.
name|bool
name|TopLevelClass
operator|:
literal|1
expr_stmt|;
comment|/// \brief Whether this class had an associated template
comment|/// scope. When true, TagOrTemplate is a template declaration;
comment|/// othewise, it is a tag declaration.
name|bool
name|TemplateScope
range|:
literal|1
decl_stmt|;
comment|/// \brief The class or class template whose definition we are parsing.
name|Decl
modifier|*
name|TagOrTemplate
decl_stmt|;
comment|/// LateParsedDeclarations - Method declarations, inline definitions and
comment|/// nested classes that contain pieces whose parsing will be delayed until
comment|/// the top-level class is fully defined.
name|LateParsedDeclarationsContainer
name|LateParsedDeclarations
decl_stmt|;
block|}
struct|;
comment|/// \brief The stack of classes that is currently being
comment|/// parsed. Nested and local classes will be pushed onto this stack
comment|/// when they are parsed, and removed afterward.
name|std
operator|::
name|stack
operator|<
name|ParsingClass
operator|*
operator|>
name|ClassStack
expr_stmt|;
name|ParsingClass
modifier|&
name|getCurrentClass
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|ClassStack
operator|.
name|empty
argument_list|()
operator|&&
literal|"No lexed method stacks!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|ClassStack
operator|.
name|top
argument_list|()
return|;
block|}
comment|/// \brief RAII object used to inform the actions that we're
comment|/// currently parsing a declaration.  This is active when parsing a
comment|/// variable's initializer, but not when parsing the body of a
comment|/// class or function definition.
name|class
name|ParsingDeclRAIIObject
block|{
name|Sema
modifier|&
name|Actions
decl_stmt|;
name|Sema
operator|::
name|ParsingDeclState
name|State
expr_stmt|;
name|bool
name|Popped
decl_stmt|;
name|public
label|:
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|Actions
argument_list|(
argument|P.Actions
argument_list|)
block|{
name|push
argument_list|()
block|;     }
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|Other
argument_list|)
operator|:
name|Actions
argument_list|(
argument|P.Actions
argument_list|)
block|{
if|if
condition|(
name|Other
condition|)
name|steal
argument_list|(
operator|*
name|Other
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|()
expr_stmt|;
block|}
comment|/// Creates a RAII object which steals the state from a different
comment|/// object instead of pushing.
name|ParsingDeclRAIIObject
argument_list|(
name|ParsingDeclRAIIObject
operator|&
name|Other
argument_list|)
operator|:
name|Actions
argument_list|(
argument|Other.Actions
argument_list|)
block|{
name|steal
argument_list|(
name|Other
argument_list|)
block|;     }
operator|~
name|ParsingDeclRAIIObject
argument_list|()
block|{
name|abort
argument_list|()
block|;     }
comment|/// Resets the RAII object for a new declaration.
name|void
name|reset
argument_list|()
block|{
name|abort
argument_list|()
block|;
name|push
argument_list|()
block|;     }
comment|/// Signals that the context was completed without an appropriate
comment|/// declaration being parsed.
name|void
name|abort
argument_list|()
block|{
name|pop
argument_list|(
literal|0
argument_list|)
block|;     }
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"ParsingDeclaration has already been popped!"
argument_list|)
block|;
name|pop
argument_list|(
name|D
argument_list|)
block|;     }
name|private
operator|:
name|void
name|steal
argument_list|(
argument|ParsingDeclRAIIObject&Other
argument_list|)
block|{
name|State
operator|=
name|Other
operator|.
name|State
block|;
name|Popped
operator|=
name|Other
operator|.
name|Popped
block|;
name|Other
operator|.
name|Popped
operator|=
name|true
block|;     }
name|void
name|push
argument_list|()
block|{
name|State
operator|=
name|Actions
operator|.
name|PushParsingDeclaration
argument_list|()
block|;
name|Popped
operator|=
name|false
block|;     }
name|void
name|pop
argument_list|(
argument|Decl *D
argument_list|)
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
block|{
name|Actions
operator|.
name|PopParsingDeclaration
argument_list|(
name|State
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|Popped
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
empty_stmt|;
comment|/// A class for parsing a DeclSpec.
name|class
name|ParsingDeclSpec
range|:
name|public
name|DeclSpec
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|ParsingRAII
argument_list|(
argument|P
argument_list|)
block|{}
name|ParsingDeclSpec
argument_list|(
name|ParsingDeclRAIIObject
operator|&
name|RAII
argument_list|)
operator|:
name|ParsingRAII
argument_list|(
argument|RAII
argument_list|)
block|{}
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|RAII
argument_list|)
operator|:
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|RAII
argument_list|)
block|{}
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
name|void
name|abort
argument_list|()
block|{
name|ParsingRAII
operator|.
name|abort
argument_list|()
block|;     }
block|}
decl_stmt|;
comment|/// A class for parsing a declarator.
name|class
name|ParsingDeclarator
range|:
name|public
name|Declarator
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclarator
argument_list|(
argument|Parser&P
argument_list|,
argument|const ParsingDeclSpec&DS
argument_list|,
argument|TheContext C
argument_list|)
operator|:
name|Declarator
argument_list|(
name|DS
argument_list|,
name|C
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|)
block|{     }
specifier|const
name|ParsingDeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|Declarator
operator|::
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|ParsingDeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|Declarator
operator|::
name|clear
argument_list|()
block|;
name|ParsingRAII
operator|.
name|reset
argument_list|()
block|;     }
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
expr|}
block|;
comment|/// \brief RAII object used to
name|class
name|ParsingClassDefinition
block|{
name|Parser
operator|&
name|P
block|;
name|bool
name|Popped
block|;
name|Sema
operator|::
name|ParsingClassState
name|State
block|;
name|public
operator|:
name|ParsingClassDefinition
argument_list|(
argument|Parser&P
argument_list|,
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
operator|:
name|P
argument_list|(
name|P
argument_list|)
block|,
name|Popped
argument_list|(
name|false
argument_list|)
block|,
name|State
argument_list|(
argument|P.PushParsingClass(TagOrTemplate, TopLevelClass)
argument_list|)
block|{     }
comment|/// \brief Pop this class of the stack.
name|void
name|Pop
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"Nested class has already been popped"
argument_list|)
block|;
name|Popped
operator|=
name|true
block|;
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
block|;     }
operator|~
name|ParsingClassDefinition
argument_list|()
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
expr_stmt|;
block|}
expr|}
block|;
comment|/// \brief Contains information about any template-specific
comment|/// information that has been parsed prior to parsing declaration
comment|/// specifiers.
block|struct
name|ParsedTemplateInfo
block|{
name|ParsedTemplateInfo
argument_list|()
operator|:
name|Kind
argument_list|(
name|NonTemplate
argument_list|)
block|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
block|,
name|TemplateLoc
argument_list|()
block|{ }
name|ParsedTemplateInfo
argument_list|(
argument|TemplateParameterLists *TemplateParams
argument_list|,
argument|bool isSpecialization
argument_list|,
argument|bool lastParameterListWasEmpty = false
argument_list|)
operator|:
name|Kind
argument_list|(
name|isSpecialization
operator|?
name|ExplicitSpecialization
operator|:
name|Template
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|TemplateParams
argument_list|)
block|,
name|LastParameterListWasEmpty
argument_list|(
argument|lastParameterListWasEmpty
argument_list|)
block|{ }
name|explicit
name|ParsedTemplateInfo
argument_list|(
argument|SourceLocation ExternLoc
argument_list|,
argument|SourceLocation TemplateLoc
argument_list|)
operator|:
name|Kind
argument_list|(
name|ExplicitInstantiation
argument_list|)
block|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
block|,
name|ExternLoc
argument_list|(
name|ExternLoc
argument_list|)
block|,
name|TemplateLoc
argument_list|(
name|TemplateLoc
argument_list|)
block|,
name|LastParameterListWasEmpty
argument_list|(
argument|false
argument_list|)
block|{ }
comment|/// \brief The kind of template we are parsing.
expr|enum
block|{
comment|/// \brief We are not parsing a template at all.
name|NonTemplate
operator|=
literal|0
block|,
comment|/// \brief We are parsing a template declaration.
name|Template
block|,
comment|/// \brief We are parsing an explicit specialization.
name|ExplicitSpecialization
block|,
comment|/// \brief We are parsing an explicit instantiation.
name|ExplicitInstantiation
block|}
name|Kind
block|;
comment|/// \brief The template parameter lists, for template declarations
comment|/// and explicit specializations.
name|TemplateParameterLists
operator|*
name|TemplateParams
block|;
comment|/// \brief The location of the 'extern' keyword, if any, for an explicit
comment|/// instantiation
name|SourceLocation
name|ExternLoc
block|;
comment|/// \brief The location of the 'template' keyword, for an explicit
comment|/// instantiation.
name|SourceLocation
name|TemplateLoc
block|;
comment|/// \brief Whether the last template parameter list was empty.
name|bool
name|LastParameterListWasEmpty
block|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|;   }
block|;
name|Sema
operator|::
name|ParsingClassState
name|PushParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|;
name|void
name|DeallocateParsedClasses
argument_list|(
name|ParsingClass
operator|*
name|Class
argument_list|)
block|;
name|void
name|PopParsingClass
argument_list|(
name|Sema
operator|::
name|ParsingClassState
argument_list|)
block|;
name|Decl
operator|*
name|ParseCXXInlineMethodDef
argument_list|(
argument|AccessSpecifier AS
argument_list|,
argument|ParsingDeclarator&D
argument_list|,
argument|const ParsedTemplateInfo&TemplateInfo
argument_list|,
argument|const VirtSpecifiers& VS
argument_list|)
block|;
name|void
name|ParseLexedMethodDeclarations
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedMethodDeclaration
argument_list|(
name|LateParsedMethodDeclaration
operator|&
name|LM
argument_list|)
block|;
name|void
name|ParseLexedMethodDefs
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedMethodDef
argument_list|(
name|LexedMethod
operator|&
name|LM
argument_list|)
block|;
name|bool
name|ConsumeAndStoreUntil
argument_list|(
argument|tok::TokenKind T1
argument_list|,
argument|CachedTokens&Toks
argument_list|,
argument|bool StopAtSemi = true
argument_list|,
argument|bool ConsumeFinalToken = true
argument_list|)
block|{
return|return
name|ConsumeAndStoreUntil
argument_list|(
name|T1
argument_list|,
name|T1
argument_list|,
name|Toks
argument_list|,
name|StopAtSemi
argument_list|,
name|ConsumeFinalToken
argument_list|)
return|;
block|}
name|bool
name|ConsumeAndStoreUntil
argument_list|(
argument|tok::TokenKind T1
argument_list|,
argument|tok::TokenKind T2
argument_list|,
argument|CachedTokens&Toks
argument_list|,
argument|bool StopAtSemi = true
argument_list|,
argument|bool ConsumeFinalToken = true
argument_list|)
block|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.9: External Definitions.
block|struct
name|ParsedAttributesWithRange
operator|:
name|ParsedAttributes
block|{
name|SourceRange
name|Range
block|;   }
block|;
name|DeclGroupPtrTy
name|ParseExternalDeclaration
argument_list|(
name|ParsedAttributesWithRange
operator|&
name|attrs
argument_list|,
name|ParsingDeclSpec
operator|*
name|DS
operator|=
literal|0
argument_list|)
block|;
name|bool
name|isDeclarationAfterDeclarator
argument_list|()
specifier|const
block|;
name|bool
name|isStartOfFunctionDefinition
argument_list|(
specifier|const
name|ParsingDeclarator
operator|&
name|Declarator
argument_list|)
block|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
argument_list|(
argument|ParsedAttributes&attrs
argument_list|,
argument|AccessSpecifier AS = AS_none
argument_list|)
block|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
argument_list|(
argument|ParsingDeclSpec&DS
argument_list|,
argument|AccessSpecifier AS = AS_none
argument_list|)
block|;
name|Decl
operator|*
name|ParseFunctionDefinition
argument_list|(
name|ParsingDeclarator
operator|&
name|D
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
operator|=
name|ParsedTemplateInfo
argument_list|()
argument_list|)
block|;
name|void
name|ParseKNRParamDeclarations
argument_list|(
name|Declarator
operator|&
name|D
argument_list|)
block|;
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the simple-asm.
name|ExprResult
name|ParseSimpleAsm
argument_list|(
name|SourceLocation
operator|*
name|EndLoc
operator|=
literal|0
argument_list|)
block|;
name|ExprResult
name|ParseAsmStringLiteral
argument_list|()
block|;
comment|// Objective-C External Declarations
name|Decl
operator|*
name|ParseObjCAtDirectives
argument_list|()
block|;
name|Decl
operator|*
name|ParseObjCAtClassDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCAtInterfaceDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|,
argument|ParsedAttributes&prefixAttrs
argument_list|)
block|;
name|void
name|ParseObjCClassInstanceVariables
argument_list|(
argument|Decl *interfaceDecl
argument_list|,
argument|tok::ObjCKeywordKind visibility
argument_list|,
argument|SourceLocation atLoc
argument_list|)
block|;
name|bool
name|ParseObjCProtocolReferences
argument_list|(
argument|llvm::SmallVectorImpl<Decl *>&P
argument_list|,
argument|llvm::SmallVectorImpl<SourceLocation>&PLocs
argument_list|,
argument|bool WarnOnDeclarations
argument_list|,
argument|SourceLocation&LAngleLoc
argument_list|,
argument|SourceLocation&EndProtoLoc
argument_list|)
block|;
name|bool
name|ParseObjCProtocolQualifiers
argument_list|(
name|DeclSpec
operator|&
name|DS
argument_list|)
block|;
name|void
name|ParseObjCInterfaceDeclList
argument_list|(
argument|Decl *interfaceDecl
argument_list|,
argument|tok::ObjCKeywordKind contextKey
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCAtProtocolDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|,
argument|ParsedAttributes&prefixAttrs
argument_list|)
block|;
name|Decl
operator|*
name|ObjCImpDecl
block|;
name|llvm
operator|::
name|SmallVector
operator|<
name|Decl
operator|*
block|,
literal|4
operator|>
name|PendingObjCImpDecl
block|;
name|Decl
operator|*
name|ParseObjCAtImplementationDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCAtEndDeclaration
argument_list|(
argument|SourceRange atEnd
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCAtAliasDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCPropertySynthesize
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCPropertyDynamic
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|IdentifierInfo
operator|*
name|ParseObjCSelectorPiece
argument_list|(
name|SourceLocation
operator|&
name|MethodLocation
argument_list|)
block|;
comment|// Definitions for Objective-c context sensitive keywords recognition.
block|enum
name|ObjCTypeQual
block|{
name|objc_in
operator|=
literal|0
block|,
name|objc_out
block|,
name|objc_inout
block|,
name|objc_oneway
block|,
name|objc_bycopy
block|,
name|objc_byref
block|,
name|objc_NumQuals
block|}
block|;
name|IdentifierInfo
operator|*
name|ObjCTypeQuals
index|[
name|objc_NumQuals
index|]
block|;
name|bool
name|isTokIdentifier_in
argument_list|()
specifier|const
block|;
name|ParsedType
name|ParseObjCTypeName
argument_list|(
argument|ObjCDeclSpec&DS
argument_list|,
argument|bool IsParameter
argument_list|)
block|;
name|void
name|ParseObjCMethodRequirement
argument_list|()
block|;
name|Decl
operator|*
name|ParseObjCMethodPrototype
argument_list|(
argument|Decl *classOrCat
argument_list|,
argument|tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCMethodDecl
argument_list|(
argument|SourceLocation mLoc
argument_list|,
argument|tok::TokenKind mType
argument_list|,
argument|Decl *classDecl
argument_list|,
argument|tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword
argument_list|)
block|;
name|void
name|ParseObjCPropertyAttribute
argument_list|(
name|ObjCDeclSpec
operator|&
name|DS
argument_list|,
name|Decl
operator|*
name|ClassDecl
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCMethodDefinition
argument_list|()
block|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.5: Expressions.
name|ExprResult
name|ParseExpression
argument_list|()
block|;
name|ExprResult
name|ParseConstantExpression
argument_list|()
block|;
comment|// Expr that doesn't include commas.
name|ExprResult
name|ParseAssignmentExpression
argument_list|()
block|;
name|ExprResult
name|ParseExpressionWithLeadingAt
argument_list|(
argument|SourceLocation AtLoc
argument_list|)
block|;
name|ExprResult
name|ParseExpressionWithLeadingExtension
argument_list|(
argument|SourceLocation ExtLoc
argument_list|)
block|;
name|ExprResult
name|ParseRHSOfBinaryExpression
argument_list|(
argument|ExprResult LHS
argument_list|,
argument|prec::Level MinPrec
argument_list|)
block|;
name|ExprResult
name|ParseCastExpression
argument_list|(
argument|bool isUnaryExpression
argument_list|,
argument|bool isAddressOfOperand
argument_list|,
argument|bool&NotCastExpr
argument_list|,
argument|ParsedType TypeOfCast
argument_list|)
block|;
name|ExprResult
name|ParseCastExpression
argument_list|(
argument|bool isUnaryExpression
argument_list|,
argument|bool isAddressOfOperand = false
argument_list|,
argument|ParsedType TypeOfCast = ParsedType()
argument_list|)
block|;
comment|/// Returns true if the next token would start a postfix-expression
comment|/// suffix.
name|bool
name|isPostfixExpressionSuffixStart
argument_list|()
block|{
name|tok
operator|::
name|TokenKind
name|K
operator|=
name|Tok
operator|.
name|getKind
argument_list|()
block|;
return|return
operator|(
name|K
operator|==
name|tok
operator|::
name|l_square
operator|||
name|K
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|K
operator|==
name|tok
operator|::
name|period
operator|||
name|K
operator|==
name|tok
operator|::
name|arrow
operator|||
name|K
operator|==
name|tok
operator|::
name|plusplus
operator|||
name|K
operator|==
name|tok
operator|::
name|minusminus
operator|)
return|;
block|}
name|ExprResult
name|ParsePostfixExpressionSuffix
argument_list|(
argument|ExprResult LHS
argument_list|)
block|;
name|ExprResult
name|ParseSizeofAlignofExpression
argument_list|()
block|;
name|ExprResult
name|ParseBuiltinPrimaryExpression
argument_list|()
block|;
name|ExprResult
name|ParseExprAfterTypeofSizeofAlignof
argument_list|(
specifier|const
name|Token
operator|&
name|OpTok
argument_list|,
name|bool
operator|&
name|isCastExpr
argument_list|,
name|ParsedType
operator|&
name|CastTy
argument_list|,
name|SourceRange
operator|&
name|CastRange
argument_list|)
block|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|20
operator|>
name|ExprListTy
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|20
operator|>
name|CommaLocsTy
expr_stmt|;
comment|/// ParseExpressionList - Used for C/C++ (argument-)expression-list.
name|bool
name|ParseExpressionList
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|CommaLocs
argument_list|,
name|void
argument_list|(
argument|Sema::*Completer
argument_list|)
operator|(
name|Scope
operator|*
name|S
expr|,
name|Expr
operator|*
name|Data
expr|,
name|Expr
operator|*
operator|*
name|Args
expr|,
name|unsigned
name|NumArgs
operator|)
operator|=
literal|0
argument_list|,
name|Expr
operator|*
name|Data
operator|=
literal|0
argument_list|)
decl_stmt|;
comment|/// ParenParseOption - Control what ParseParenExpression will parse.
enum|enum
name|ParenParseOption
block|{
name|SimpleExpr
block|,
comment|// Only parse '(' expression ')'
name|CompoundStmt
block|,
comment|// Also allow '(' compound-statement ')'
name|CompoundLiteral
block|,
comment|// Also allow '(' type-name ')' '{' ... '}'
name|CastExpr
comment|// Also allow '(' type-name ')'<anything>
block|}
enum|;
name|ExprResult
name|ParseParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|bool
name|stopIfCastExpr
parameter_list|,
name|ParsedType
name|TypeOfCast
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXAmbiguousParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCompoundLiteralExpression
parameter_list|(
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseStringLiteralExpression
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ Expressions
name|ExprResult
name|ParseCXXIdExpression
parameter_list|(
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCXXScopeSpecifier
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
modifier|*
name|MayBePseudoDestructor
init|=
literal|0
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Casts
name|ExprResult
name|ParseCXXCasts
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Type Identification
name|ExprResult
name|ParseCXXTypeid
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|//  C++ : Microsoft __uuidof Expression
name|ExprResult
name|ParseCXXUuidof
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.4: C++ Pseudo-Destructor Expressions
name|ExprResult
name|ParseCXXPseudoDestructor
argument_list|(
name|ExprArg
name|Base
argument_list|,
name|SourceLocation
name|OpLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|OpKind
argument_list|,
name|CXXScopeSpec
operator|&
name|SS
argument_list|,
name|ParsedType
name|ObjectType
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9.3.2: C++ 'this' pointer
name|ExprResult
name|ParseCXXThis
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 15: C++ Throw Expression
name|ExprResult
name|ParseThrowExpression
parameter_list|()
function_decl|;
comment|// EndLoc is filled with the location of the last token of the specification.
name|bool
name|ParseExceptionSpecification
argument_list|(
name|SourceLocation
operator|&
name|EndLoc
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|Exns
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|SourceRange
operator|>
operator|&
name|Ranges
argument_list|,
name|bool
operator|&
name|hasAnyExceptionSpec
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++0x 8: Function declaration trailing-return-type
name|TypeResult
name|ParseTrailingReturnType
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 2.13.5: C++ Boolean Literals
name|ExprResult
name|ParseCXXBoolLiteral
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.3: Explicit type conversion (functional notation)
name|ExprResult
name|ParseCXXTypeConstructExpression
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|isCXXSimpleTypeSpecifier
argument_list|()
specifier|const
expr_stmt|;
comment|/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.
comment|/// This should only be called when the current token is known to be part of
comment|/// simple-type-specifier.
name|void
name|ParseCXXSimpleTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|ParseCXXTypeSpecifierSeq
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.3.4 and 5.3.5: C++ new and delete
name|bool
name|ParseExpressionListOrTypeId
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|Declarator
operator|&
name|D
argument_list|)
decl_stmt|;
name|void
name|ParseDirectNewDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXNewExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXDeleteExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ if/switch/while condition expression.
name|bool
name|ParseCXXCondition
parameter_list|(
name|ExprResult
modifier|&
name|ExprResult
parameter_list|,
name|Decl
modifier|*
modifier|&
name|DeclResult
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|bool
name|ConvertToBoolean
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ types
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7.8: Initialization.
comment|/// ParseInitializer
comment|///       initializer: [C99 6.7.8]
comment|///         assignment-expression
comment|///         '{' ...
name|ExprResult
name|ParseInitializer
parameter_list|()
block|{
if|if
condition|(
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_brace
argument_list|)
condition|)
return|return
name|ParseAssignmentExpression
argument_list|()
return|;
return|return
name|ParseBraceInitializer
argument_list|()
return|;
block|}
name|ExprResult
name|ParseBraceInitializer
parameter_list|()
function_decl|;
name|ExprResult
name|ParseInitializerWithPotentialDesignator
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// clang Expressions
name|ExprResult
name|ParseBlockLiteralExpression
parameter_list|()
function_decl|;
comment|// ^{...}
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Expressions
name|ExprResult
name|ParseObjCAtExpression
parameter_list|(
name|SourceLocation
name|AtLocation
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCStringLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCEncodeExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCSelectorExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCProtocolExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|bool
name|isSimpleObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpressionBody
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAssignmentExprWithObjCMessageExprStart
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
name|bool
name|ParseObjCXXMessageReceiver
parameter_list|(
name|bool
modifier|&
name|IsExpr
parameter_list|,
name|void
modifier|*
modifier|&
name|TypeOrExpr
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.8: Statements and Blocks.
name|StmtResult
name|ParseStatement
parameter_list|()
block|{
name|StmtVector
name|Stmts
argument_list|(
name|Actions
argument_list|)
decl_stmt|;
return|return
name|ParseStatementOrDeclaration
argument_list|(
name|Stmts
argument_list|,
name|true
argument_list|)
return|;
block|}
name|StmtResult
name|ParseStatementOrDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|bool
name|OnlyStatement
init|=
name|false
parameter_list|)
function_decl|;
name|StmtResult
name|ParseLabeledStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCaseStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDefaultStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCompoundStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|,
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCompoundStatementBody
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseParenExprOrCondition
parameter_list|(
name|ExprResult
modifier|&
name|ExprResult
parameter_list|,
name|Decl
modifier|*
modifier|&
name|DeclResult
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|bool
name|ConvertToBoolean
parameter_list|)
function_decl|;
name|StmtResult
name|ParseIfStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSwitchStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseWhileStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDoStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseForStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseGotoStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseContinueStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseBreakStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseReturnStatement
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseAsmStatement
parameter_list|(
name|bool
modifier|&
name|msAsm
parameter_list|)
function_decl|;
name|StmtResult
name|FuzzyParseMicrosoftAsmStatement
parameter_list|(
name|SourceLocation
name|AsmLoc
parameter_list|)
function_decl|;
name|bool
name|ParseAsmOperandsOpt
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|&
name|Names
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ExprTy
operator|*
operator|>
operator|&
name|Constraints
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ExprTy
operator|*
operator|>
operator|&
name|Exprs
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 6: Statements and Blocks
name|StmtResult
name|ParseCXXTryBlock
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCXXTryBlockCommon
parameter_list|(
name|SourceLocation
name|TryLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCXXCatchBlock
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Statements
name|StmtResult
name|ParseObjCAtStatement
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCTryStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCThrowStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCSynchronizedStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7: Declarations.
comment|/// A context for parsing declaration specifiers.  TODO: flesh this
comment|/// out, there are other significant restrictions on specifiers than
comment|/// would be best implemented in the parser.
enum|enum
name|DeclSpecContext
block|{
name|DSC_normal
block|,
comment|// normal context
name|DSC_class
block|,
comment|// class context, enables 'friend'
name|DSC_top_level
comment|// top-level/namespace declaration context
block|}
enum|;
name|DeclGroupPtrTy
name|ParseDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseSimpleDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|bool
name|RequireSemi
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclGroup
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|bool
name|AllowFunctionDefinitions
parameter_list|,
name|SourceLocation
modifier|*
name|DeclEnd
init|=
literal|0
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseDeclarationAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionStatementBody
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionTryBlock
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|)
function_decl|;
comment|/// \brief When in code-completion, skip parsing of the function/method body
comment|/// unless the body contains the code-completion point.
comment|///
comment|/// \returns true if the function body was skipped.
name|bool
name|trySkippingFunctionBodyForCodeCompletion
parameter_list|()
function_decl|;
name|bool
name|ParseImplicitInt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|DeclSpecContext
name|getDeclSpecContextFromDeclaratorContext
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|void
name|ParseDeclarationSpecifiers
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|DeclSpecContext
name|DSC
init|=
name|DSC_normal
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|bool
name|SuppressDeclarations
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|ParseSpecifierQualifierList
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseObjCTypeQualifierList
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|,
name|bool
name|IsParameter
parameter_list|)
function_decl|;
name|void
name|ParseEnumSpecifier
parameter_list|(
name|SourceLocation
name|TagLoc
parameter_list|,
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|void
name|ParseEnumBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructUnionBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
struct|struct
name|FieldCallback
block|{
name|virtual
name|Decl
modifier|*
name|invoke
parameter_list|(
name|FieldDeclarator
modifier|&
name|Field
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
operator|~
name|FieldCallback
argument_list|()
block|{}
name|private
operator|:
name|virtual
name|void
name|_anchor
argument_list|()
expr_stmt|;
block|}
struct|;
struct_decl|struct
name|ObjCPropertyCallback
struct_decl|;
name|void
name|ParseStructDeclaration
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|FieldCallback
modifier|&
name|Callback
parameter_list|)
function_decl|;
name|bool
name|isDeclarationSpecifier
parameter_list|(
name|bool
name|DisambiguatingWithExpression
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|isTypeSpecifierQualifier
parameter_list|()
function_decl|;
name|bool
name|isTypeQualifier
argument_list|()
specifier|const
expr_stmt|;
comment|/// isKnownToBeTypeSpecifier - Return true if we know that the specified token
comment|/// is definitely a type-specifier.  Return false if it isn't part of a type
comment|/// specifier or if we're not sure.
name|bool
name|isKnownToBeTypeSpecifier
argument_list|(
specifier|const
name|Token
operator|&
name|Tok
argument_list|)
decl|const
decl_stmt|;
comment|/// isDeclarationStatement - Disambiguates between a declaration or an
comment|/// expression statement, when parsing function bodies.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isDeclarationStatement
parameter_list|()
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXDeclarationStatement
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// isSimpleDeclaration - Disambiguates between a declaration or an
comment|/// expression, mainly used for the C 'clause-1' or the C++
comment|// 'for-init-statement' part of a 'for' statement.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isSimpleDeclaration
parameter_list|()
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXSimpleDeclaration
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// \brief Determine whether we are currently at the start of an Objective-C
comment|/// class message that appears to be missing the open bracket '['.
name|bool
name|isStartOfObjCClassMessageMissingOpenBracket
parameter_list|()
function_decl|;
comment|/// \brief Starting with a scope specifier, identifier, or
comment|/// template-id that refers to the current class, determine whether
comment|/// this is a constructor declarator.
name|bool
name|isConstructorDeclarator
parameter_list|()
function_decl|;
comment|/// \brief Specifies the context in which type-id/expression
comment|/// disambiguation will occur.
enum|enum
name|TentativeCXXTypeIdContext
block|{
name|TypeIdInParens
block|,
name|TypeIdAsTemplateArgument
block|}
enum|;
comment|/// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know
comment|/// whether the parens contain an expression or a type-id.
comment|/// Returns true for a type-id and false for an expression.
name|bool
name|isTypeIdInParens
parameter_list|(
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXTypeId
argument_list|(
name|TypeIdInParens
argument_list|,
name|isAmbiguous
argument_list|)
return|;
name|isAmbiguous
operator|=
name|false
expr_stmt|;
return|return
name|isTypeSpecifierQualifier
argument_list|()
return|;
block|}
name|bool
name|isTypeIdInParens
parameter_list|()
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isTypeIdInParens
argument_list|(
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// isCXXDeclarationStatement - C++-specialized function that disambiguates
comment|/// between a declaration or an expression statement, when parsing function
comment|/// bodies. Returns true for declaration, false for expression.
name|bool
name|isCXXDeclarationStatement
parameter_list|()
function_decl|;
comment|/// isCXXSimpleDeclaration - C++-specialized function that disambiguates
comment|/// between a simple-declaration or an expression-statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
comment|/// Returns false if the statement is disambiguated as expression.
name|bool
name|isCXXSimpleDeclaration
parameter_list|()
function_decl|;
comment|/// isCXXFunctionDeclarator - Disambiguates between a function declarator or
comment|/// a constructor-style initializer, when parsing declaration statements.
comment|/// Returns true for function declarator and false for constructor-style
comment|/// initializer. If 'warnIfAmbiguous' is true a warning will be emitted to
comment|/// indicate that the parens were disambiguated as function declarator.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXFunctionDeclarator
parameter_list|(
name|bool
name|warnIfAmbiguous
parameter_list|)
function_decl|;
comment|/// isCXXConditionDeclaration - Disambiguates between a declaration or an
comment|/// expression for a condition of a if/switch/while/for statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXConditionDeclaration
parameter_list|()
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|,
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|)
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isCXXTypeId
argument_list|(
name|Context
argument_list|,
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// TPResult - Used as the result value for functions whose purpose is to
comment|/// disambiguate C++ constructs by "tentatively parsing" them.
comment|/// This is a class instead of a simple enum because the implicit enum-to-bool
comment|/// conversions may cause subtle bugs.
name|class
name|TPResult
block|{
enum|enum
name|Result
block|{
name|TPR_true
block|,
name|TPR_false
block|,
name|TPR_ambiguous
block|,
name|TPR_error
block|}
enum|;
name|Result
name|Res
decl_stmt|;
name|TPResult
argument_list|(
argument|Result result
argument_list|)
block|:
name|Res
argument_list|(
argument|result
argument_list|)
block|{}
name|public
label|:
specifier|static
name|TPResult
name|True
parameter_list|()
block|{
return|return
name|TPR_true
return|;
block|}
specifier|static
name|TPResult
name|False
parameter_list|()
block|{
return|return
name|TPR_false
return|;
block|}
specifier|static
name|TPResult
name|Ambiguous
parameter_list|()
block|{
return|return
name|TPR_ambiguous
return|;
block|}
specifier|static
name|TPResult
name|Error
parameter_list|()
block|{
return|return
name|TPR_error
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|==
name|RHS
operator|.
name|Res
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|!=
name|RHS
operator|.
name|Res
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief Based only on the given token kind, determine whether we know that
comment|/// we're at the start of an expression or a type-specifier-seq (which may
comment|/// be an expression, in C++).
comment|///
comment|/// This routine does not attempt to resolve any of the trick cases, e.g.,
comment|/// those involving lookup of identifiers.
comment|///
comment|/// \returns \c TPR_true if this token starts an expression, \c TPR_false if
comment|/// this token starts a type-specifier-seq, or \c TPR_ambiguous if it cannot
comment|/// tell.
name|TPResult
name|isExpressionOrTypeSpecifierSimple
argument_list|(
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// isCXXDeclarationSpecifier - Returns TPResult::True() if it is a
comment|/// declaration specifier, TPResult::False() if it is not,
comment|/// TPResult::Ambiguous() if it could be either a decl-specifier or a
comment|/// function-style cast, and TPResult::Error() if a parsing error was
comment|/// encountered.
comment|/// Doesn't consume tokens.
name|TPResult
name|isCXXDeclarationSpecifier
parameter_list|()
function_decl|;
comment|// "Tentative parsing" functions, used for disambiguation. If a parsing error
comment|// is encountered they will return TPResult::Error().
comment|// Returning TPResult::True()/False() indicates that the ambiguity was
comment|// resolved and tentative parsing may stop. TPResult::Ambiguous() indicates
comment|// that more tentative parsing is necessary for disambiguation.
comment|// They all consume tokens, so backtracking should be used after calling them.
name|TPResult
name|TryParseDeclarationSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseSimpleDeclaration
parameter_list|()
function_decl|;
name|TPResult
name|TryParseTypeofSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseProtocolQualifiers
parameter_list|()
function_decl|;
name|TPResult
name|TryParseInitDeclaratorList
parameter_list|()
function_decl|;
name|TPResult
name|TryParseDeclarator
parameter_list|(
name|bool
name|mayBeAbstract
parameter_list|,
name|bool
name|mayHaveIdentifier
init|=
name|true
parameter_list|)
function_decl|;
name|TPResult
name|TryParseParameterDeclarationClause
parameter_list|()
function_decl|;
name|TPResult
name|TryParseFunctionDeclarator
parameter_list|()
function_decl|;
name|TPResult
name|TryParseBracketDeclarator
parameter_list|()
function_decl|;
name|TypeResult
name|ParseTypeName
argument_list|(
name|SourceRange
operator|*
name|Range
operator|=
literal|0
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Context
operator|=
name|Declarator
operator|::
name|TypeNameContext
argument_list|)
decl_stmt|;
name|void
name|ParseBlockId
parameter_list|()
function_decl|;
name|void
name|ProhibitAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|attrs
operator|.
name|Range
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|DiagnoseProhibitedAttributes
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
name|void
name|DiagnoseProhibitedAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
block|{
name|ParsedAttributes
name|attrs
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|)
expr_stmt|;
name|D
operator|.
name|addAttributes
argument_list|(
name|attrs
operator|.
name|getList
argument_list|()
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX0XAttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrs
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseCXX0XAttributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|)
expr_stmt|;
name|D
operator|.
name|addAttributes
argument_list|(
name|attrs
operator|.
name|getList
argument_list|()
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX0XAttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrsWithRange
decl_stmt|;
name|ParseCXX0XAttributes
argument_list|(
name|attrsWithRange
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|append
argument_list|(
name|attrsWithRange
operator|.
name|getList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX0XAttributeSpecifier
argument_list|()
condition|)
name|ParseCXX0XAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseCXX0XAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|MaybeParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|Microsoft
operator|&&
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
condition|)
name|ParseMicrosoftAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftDeclSpec
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseBorlandTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseOpenCLAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseTypeofSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseDecltypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXX0XAlignArgument
parameter_list|(
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
name|VirtSpecifiers
operator|::
name|Specifier
name|isCXX0XVirtSpecifier
argument_list|()
specifier|const
expr_stmt|;
name|void
name|ParseOptionalCXX0XVirtSpecifierSeq
parameter_list|(
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|)
function_decl|;
name|ClassVirtSpecifiers
operator|::
name|Specifier
name|isCXX0XClassVirtSpecifier
argument_list|()
specifier|const
expr_stmt|;
name|void
name|ParseOptionalCXX0XClassVirtSpecifierSeq
parameter_list|(
name|ClassVirtSpecifiers
modifier|&
name|CVS
parameter_list|)
function_decl|;
comment|/// DeclaratorScopeObj - RAII object used in Parser::ParseDirectDeclarator to
comment|/// enter a new C++ declarator scope and exit it when the function is
comment|/// finished.
name|class
name|DeclaratorScopeObj
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|CXXScopeSpec
modifier|&
name|SS
decl_stmt|;
name|bool
name|EnteredScope
decl_stmt|;
name|bool
name|CreatedScope
decl_stmt|;
name|public
label|:
name|DeclaratorScopeObj
argument_list|(
name|Parser
operator|&
name|p
argument_list|,
name|CXXScopeSpec
operator|&
name|ss
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|SS
argument_list|(
name|ss
argument_list|)
operator|,
name|EnteredScope
argument_list|(
name|false
argument_list|)
operator|,
name|CreatedScope
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|EnterDeclaratorScope
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|EnteredScope
operator|&&
literal|"Already entered the scope!"
argument_list|)
block|;
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was not set!"
argument_list|)
block|;
name|CreatedScope
operator|=
name|true
block|;
name|P
operator|.
name|EnterScope
argument_list|(
literal|0
argument_list|)
block|;
comment|// Not a decl scope.
if|if
condition|(
operator|!
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXEnterDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
condition|)
name|EnteredScope
operator|=
name|true
expr_stmt|;
block|}
operator|~
name|DeclaratorScopeObj
argument_list|()
block|{
if|if
condition|(
name|EnteredScope
condition|)
block|{
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was cleared ?"
argument_list|)
expr_stmt|;
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXExitDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CreatedScope
condition|)
name|P
operator|.
name|ExitScope
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ParseDeclarator - Parse and verify a newly-initialized declarator.
name|void
name|ParseDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|/// A function that parses a variant of direct-declarator.
typedef|typedef
name|void
argument_list|(
name|Parser
operator|::
operator|*
name|DirectDeclParseFunction
argument_list|)
argument_list|(
name|Declarator
operator|&
argument_list|)
expr_stmt|;
name|void
name|ParseDeclaratorInternal
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|DirectDeclParseFunction
name|DirectDeclParser
parameter_list|)
function_decl|;
name|void
name|ParseTypeQualifierListOpt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|bool
name|GNUAttributesAllowed
init|=
name|true
parameter_list|,
name|bool
name|CXX0XAttributesAllowed
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|ParseDirectDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseParenDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclarator
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|bool
name|RequiresArg
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclaratorIdentifierList
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|FirstIdent
parameter_list|,
name|SourceLocation
name|FirstIdentLoc
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseBracketDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 7: Declarations [dcl.dcl]
name|bool
name|isCXX0XAttributeSpecifier
argument_list|(
name|bool
name|FullLookahead
operator|=
name|false
argument_list|,
name|tok
operator|::
name|TokenKind
operator|*
name|After
operator|=
literal|0
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|ParseNamespace
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|SourceLocation
name|InlineLoc
init|=
name|SourceLocation
argument_list|()
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseLinkage
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDirectiveOrDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDirective
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseStaticAssertDeclaration
parameter_list|(
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNamespaceAlias
parameter_list|(
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9: classes [class] and C structs/unions.
name|TypeResult
name|ParseClassName
parameter_list|(
name|SourceLocation
modifier|&
name|EndLocation
parameter_list|,
name|CXXScopeSpec
modifier|*
name|SS
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseClassSpecifier
argument_list|(
name|tok
operator|::
name|TokenKind
name|TagTokKind
argument_list|,
name|SourceLocation
name|TagLoc
argument_list|,
name|DeclSpec
operator|&
name|DS
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
operator|=
name|ParsedTemplateInfo
argument_list|()
argument_list|,
name|AccessSpecifier
name|AS
operator|=
name|AS_none
argument_list|,
name|bool
name|SuppressDeclarations
operator|=
name|false
argument_list|)
decl_stmt|;
name|void
name|ParseCXXMemberSpecification
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseCXXClassMemberDeclaration
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|ParsingDeclRAIIObject
modifier|*
name|DiagsFromTParams
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseConstructorInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|MemInitResult
name|ParseMemInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|void
name|HandleMemberFunctionDefaultArgs
parameter_list|(
name|Declarator
modifier|&
name|DeclaratorInfo
parameter_list|,
name|Decl
modifier|*
name|ThisDecl
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 10: Derived classes [class.derived]
name|void
name|ParseBaseClause
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|BaseResult
name|ParseBaseSpecifier
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|AccessSpecifier
name|getAccessSpecifierIfPresent
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|ParseUnqualifiedIdTemplateId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Id
parameter_list|,
name|bool
name|AssumeTemplateId
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|)
function_decl|;
name|bool
name|ParseUnqualifiedIdOperator
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
name|bool
name|ParseUnqualifiedId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
name|AllowDestructorName
parameter_list|,
name|bool
name|AllowConstructorName
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 14: Templates [temp]
comment|// C++ 14.1: Template Parameters [temp.param]
name|Decl
modifier|*
name|ParseDeclarationStartingWithTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateDeclarationOrSpecialization
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseSingleDeclarationAfterTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|ParsingDeclRAIIObject
modifier|&
name|DiagsFromParams
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateParameters
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|,
name|SourceLocation
operator|&
name|LAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|RAngleLoc
argument_list|)
decl_stmt|;
name|bool
name|ParseTemplateParameterList
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|)
decl_stmt|;
name|bool
name|isStartOfTemplateTypeParameter
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTypeParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNonTypeTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
comment|// C++ 14.3: Template arguments [temp.arg]
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ParsedTemplateArgument
operator|,
literal|16
operator|>
name|TemplateArgList
expr_stmt|;
name|bool
name|ParseTemplateIdAfterTemplateName
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|SourceLocation
name|TemplateNameLoc
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
name|bool
name|ConsumeLastToken
parameter_list|,
name|SourceLocation
modifier|&
name|LAngleLoc
parameter_list|,
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|,
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|)
function_decl|;
name|bool
name|AnnotateTemplateIdToken
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|TemplateNameKind
name|TNK
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
name|UnqualifiedId
modifier|&
name|TemplateName
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
init|=
name|SourceLocation
argument_list|()
parameter_list|,
name|bool
name|AllowTypeAnnotation
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|AnnotateTemplateIdTokenAsType
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|IsTemplateArgumentList
parameter_list|(
name|unsigned
name|Skip
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateArgumentList
parameter_list|(
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|)
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateTemplateArgument
parameter_list|()
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateArgument
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseExplicitInstantiation
parameter_list|(
name|SourceLocation
name|ExternLoc
parameter_list|,
name|SourceLocation
name|TemplateLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// GNU G++: Type Traits [Type-Traits.html in the GCC manual]
name|ExprResult
name|ParseUnaryTypeTrait
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBinaryTypeTrait
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Preprocessor code-completion pass-through
name|virtual
name|void
name|CodeCompleteDirective
parameter_list|(
name|bool
name|InConditional
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompleteInConditionalExclusion
parameter_list|()
function_decl|;
name|virtual
name|void
name|CodeCompleteMacroName
parameter_list|(
name|bool
name|IsDefinition
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompletePreprocessorExpression
parameter_list|()
function_decl|;
name|virtual
name|void
name|CodeCompleteMacroArgument
parameter_list|(
name|IdentifierInfo
modifier|*
name|Macro
parameter_list|,
name|MacroInfo
modifier|*
name|MacroInfo
parameter_list|,
name|unsigned
name|ArgumentIndex
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompleteNaturalLanguage
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

