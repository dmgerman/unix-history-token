begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Designator.h - Initialization Designator ---------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines interfaces used to represent Designators in the parser and
end_comment

begin_comment
comment|// is the input to Actions module.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_DESIGNATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_DESIGNATOR_H
end_define

begin_include
include|#
directive|include
file|"clang/Parse/Action.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|/// Designator - This class is a discriminated union which holds the various
comment|/// different sorts of designators possible.  A Designation is an array of
comment|/// these.  An example of a designator are things like this:
comment|///     [8] .field [47]        // C99 designation: 3 designators
comment|///     [8 ... 47]  field:     // GNU extensions: 2 designators
comment|/// These occur in initializers, e.g.:
comment|///  int a[10] = {2, 4, [8]=9, 10};
comment|///
name|class
name|Designator
block|{
name|public
label|:
enum|enum
name|DesignatorKind
block|{
name|FieldDesignator
block|,
name|ArrayDesignator
block|,
name|ArrayRangeDesignator
block|}
enum|;
name|private
label|:
name|DesignatorKind
name|Kind
decl_stmt|;
struct|struct
name|FieldDesignatorInfo
block|{
specifier|const
name|IdentifierInfo
modifier|*
name|II
decl_stmt|;
name|unsigned
name|DotLoc
decl_stmt|;
name|unsigned
name|NameLoc
decl_stmt|;
block|}
struct|;
struct|struct
name|ArrayDesignatorInfo
block|{
name|ActionBase
operator|::
name|ExprTy
operator|*
name|Index
expr_stmt|;
name|unsigned
name|LBracketLoc
decl_stmt|;
name|mutable
name|unsigned
name|RBracketLoc
decl_stmt|;
block|}
struct|;
struct|struct
name|ArrayRangeDesignatorInfo
block|{
name|ActionBase
operator|::
name|ExprTy
operator|*
name|Start
operator|,
operator|*
name|End
expr_stmt|;
name|unsigned
name|LBracketLoc
decl_stmt|,
name|EllipsisLoc
decl_stmt|;
name|mutable
name|unsigned
name|RBracketLoc
decl_stmt|;
block|}
struct|;
union|union
block|{
name|FieldDesignatorInfo
name|FieldInfo
decl_stmt|;
name|ArrayDesignatorInfo
name|ArrayInfo
decl_stmt|;
name|ArrayRangeDesignatorInfo
name|ArrayRangeInfo
decl_stmt|;
block|}
union|;
name|public
label|:
name|DesignatorKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|bool
name|isFieldDesignator
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|FieldDesignator
return|;
block|}
name|bool
name|isArrayDesignator
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|ArrayDesignator
return|;
block|}
name|bool
name|isArrayRangeDesignator
argument_list|()
specifier|const
block|{
return|return
name|Kind
operator|==
name|ArrayRangeDesignator
return|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getField
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isFieldDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|FieldInfo
operator|.
name|II
return|;
block|}
name|SourceLocation
name|getDotLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isFieldDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|FieldInfo
operator|.
name|DotLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getFieldLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isFieldDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|FieldInfo
operator|.
name|NameLoc
argument_list|)
return|;
block|}
name|ActionBase
operator|::
name|ExprTy
operator|*
name|getArrayIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isArrayDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|ArrayInfo
operator|.
name|Index
return|;
block|}
name|ActionBase
operator|::
name|ExprTy
operator|*
name|getArrayRangeStart
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isArrayRangeDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|ArrayRangeInfo
operator|.
name|Start
return|;
block|}
name|ActionBase
operator|::
name|ExprTy
operator|*
name|getArrayRangeEnd
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isArrayRangeDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|ArrayRangeInfo
operator|.
name|End
return|;
block|}
name|SourceLocation
name|getLBracketLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|isArrayDesignator
argument_list|()
operator|||
name|isArrayRangeDesignator
argument_list|()
operator|)
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
if|if
condition|(
name|isArrayDesignator
argument_list|()
condition|)
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ArrayInfo
operator|.
name|LBracketLoc
argument_list|)
return|;
else|else
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ArrayRangeInfo
operator|.
name|LBracketLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getRBracketLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|isArrayDesignator
argument_list|()
operator|||
name|isArrayRangeDesignator
argument_list|()
operator|)
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
if|if
condition|(
name|isArrayDesignator
argument_list|()
condition|)
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ArrayInfo
operator|.
name|RBracketLoc
argument_list|)
return|;
else|else
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ArrayRangeInfo
operator|.
name|RBracketLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isArrayRangeDesignator
argument_list|()
operator|&&
literal|"Invalid accessor"
argument_list|)
block|;
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ArrayRangeInfo
operator|.
name|EllipsisLoc
argument_list|)
return|;
block|}
specifier|static
name|Designator
name|getField
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|II
parameter_list|,
name|SourceLocation
name|DotLoc
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|)
block|{
name|Designator
name|D
decl_stmt|;
name|D
operator|.
name|Kind
operator|=
name|FieldDesignator
expr_stmt|;
name|D
operator|.
name|FieldInfo
operator|.
name|II
operator|=
name|II
expr_stmt|;
name|D
operator|.
name|FieldInfo
operator|.
name|DotLoc
operator|=
name|DotLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
name|D
operator|.
name|FieldInfo
operator|.
name|NameLoc
operator|=
name|NameLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
return|return
name|D
return|;
block|}
specifier|static
name|Designator
name|getArray
argument_list|(
name|ActionBase
operator|::
name|ExprTy
operator|*
name|Index
argument_list|,
name|SourceLocation
name|LBracketLoc
argument_list|)
block|{
name|Designator
name|D
decl_stmt|;
name|D
operator|.
name|Kind
operator|=
name|ArrayDesignator
expr_stmt|;
name|D
operator|.
name|ArrayInfo
operator|.
name|Index
operator|=
name|Index
expr_stmt|;
name|D
operator|.
name|ArrayInfo
operator|.
name|LBracketLoc
operator|=
name|LBracketLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
name|D
operator|.
name|ArrayInfo
operator|.
name|RBracketLoc
operator|=
literal|0
expr_stmt|;
return|return
name|D
return|;
block|}
specifier|static
name|Designator
name|getArrayRange
argument_list|(
name|ActionBase
operator|::
name|ExprTy
operator|*
name|Start
argument_list|,
name|ActionBase
operator|::
name|ExprTy
operator|*
name|End
argument_list|,
name|SourceLocation
name|LBracketLoc
argument_list|,
name|SourceLocation
name|EllipsisLoc
argument_list|)
block|{
name|Designator
name|D
decl_stmt|;
name|D
operator|.
name|Kind
operator|=
name|ArrayRangeDesignator
expr_stmt|;
name|D
operator|.
name|ArrayRangeInfo
operator|.
name|Start
operator|=
name|Start
expr_stmt|;
name|D
operator|.
name|ArrayRangeInfo
operator|.
name|End
operator|=
name|End
expr_stmt|;
name|D
operator|.
name|ArrayRangeInfo
operator|.
name|LBracketLoc
operator|=
name|LBracketLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
name|D
operator|.
name|ArrayRangeInfo
operator|.
name|EllipsisLoc
operator|=
name|EllipsisLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
name|D
operator|.
name|ArrayRangeInfo
operator|.
name|RBracketLoc
operator|=
literal|0
expr_stmt|;
return|return
name|D
return|;
block|}
name|void
name|setRBracketLoc
argument_list|(
name|SourceLocation
name|RBracketLoc
argument_list|)
decl|const
block|{
name|assert
argument_list|(
operator|(
name|isArrayDesignator
argument_list|()
operator|||
name|isArrayRangeDesignator
argument_list|()
operator|)
operator|&&
literal|"Invalid accessor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isArrayDesignator
argument_list|()
condition|)
name|ArrayInfo
operator|.
name|RBracketLoc
operator|=
name|RBracketLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
else|else
name|ArrayRangeInfo
operator|.
name|RBracketLoc
operator|=
name|RBracketLoc
operator|.
name|getRawEncoding
argument_list|()
expr_stmt|;
block|}
comment|/// ClearExprs - Null out any expression references, which prevents them from
comment|/// being 'delete'd later.
name|void
name|ClearExprs
parameter_list|(
name|Action
modifier|&
name|Actions
parameter_list|)
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
case|case
name|FieldDesignator
case|:
return|return;
case|case
name|ArrayDesignator
case|:
name|ArrayInfo
operator|.
name|Index
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|ArrayRangeDesignator
case|:
name|ArrayRangeInfo
operator|.
name|Start
operator|=
literal|0
expr_stmt|;
name|ArrayRangeInfo
operator|.
name|End
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/// FreeExprs - Release any unclaimed memory for the expressions in this
comment|/// designator.
name|void
name|FreeExprs
parameter_list|(
name|Action
modifier|&
name|Actions
parameter_list|)
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
case|case
name|FieldDesignator
case|:
return|return;
comment|// nothing to free.
case|case
name|ArrayDesignator
case|:
name|Actions
operator|.
name|DeleteExpr
argument_list|(
name|getArrayIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|ArrayRangeDesignator
case|:
name|Actions
operator|.
name|DeleteExpr
argument_list|(
name|getArrayRangeStart
argument_list|()
argument_list|)
expr_stmt|;
name|Actions
operator|.
name|DeleteExpr
argument_list|(
name|getArrayRangeEnd
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
empty_stmt|;
comment|/// Designation - Represent a full designation, which is a sequence of
comment|/// designators.  This class is mostly a helper for InitListDesignations.
name|class
name|Designation
block|{
comment|/// InitIndex - The index of the initializer expression this is for.  For
comment|/// example, if the initializer were "{ A, .foo=B, C }" a Designation would
comment|/// exist with InitIndex=1, because element #1 has a designation.
name|unsigned
name|InitIndex
decl_stmt|;
comment|/// Designators - The actual designators for this initializer.
name|llvm
operator|::
name|SmallVector
operator|<
name|Designator
operator|,
literal|2
operator|>
name|Designators
expr_stmt|;
name|Designation
argument_list|(
argument|unsigned Idx
argument_list|)
block|:
name|InitIndex
argument_list|(
argument|Idx
argument_list|)
block|{}
name|public
label|:
name|Designation
argument_list|()
operator|:
name|InitIndex
argument_list|(
literal|4000
argument_list|)
block|{}
comment|/// AddDesignator - Add a designator to the end of this list.
name|void
name|AddDesignator
argument_list|(
argument|Designator D
argument_list|)
block|{
name|Designators
operator|.
name|push_back
argument_list|(
name|D
argument_list|)
block|;   }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Designators
operator|.
name|empty
argument_list|()
return|;
block|}
name|unsigned
name|getNumDesignators
argument_list|()
specifier|const
block|{
return|return
name|Designators
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|Designator
modifier|&
name|getDesignator
argument_list|(
name|unsigned
name|Idx
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|Designators
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Designators
index|[
name|Idx
index|]
return|;
block|}
comment|/// ClearExprs - Null out any expression references, which prevents them from
comment|/// being 'delete'd later.
name|void
name|ClearExprs
parameter_list|(
name|Action
modifier|&
name|Actions
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Designators
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Designators
index|[
name|i
index|]
operator|.
name|ClearExprs
argument_list|(
name|Actions
argument_list|)
expr_stmt|;
block|}
comment|/// FreeExprs - Release any unclaimed memory for the expressions in this
comment|/// designation.
name|void
name|FreeExprs
parameter_list|(
name|Action
modifier|&
name|Actions
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Designators
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Designators
index|[
name|i
index|]
operator|.
name|FreeExprs
argument_list|(
name|Actions
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

