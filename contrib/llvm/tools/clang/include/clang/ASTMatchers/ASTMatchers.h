begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ASTMatchers.h - Structural query framework -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file implements matchers to be used together with the MatchFinder to
end_comment

begin_comment
comment|//  match AST nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Matchers are created by generator functions, which can be combined in
end_comment

begin_comment
comment|//  a functional in-language DSL to express queries over the C++ AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, to match a class with a certain name, one would call:
end_comment

begin_comment
comment|//    recordDecl(hasName("MyClass"))
end_comment

begin_comment
comment|//  which returns a matcher that can be used to find all AST nodes that declare
end_comment

begin_comment
comment|//  a class named 'MyClass'.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For more complicated match expressions we're often interested in accessing
end_comment

begin_comment
comment|//  multiple parts of the matched AST nodes once a match is found. In that case,
end_comment

begin_comment
comment|//  use the id(...) matcher around the match expressions that match the nodes
end_comment

begin_comment
comment|//  you want to access.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, when we're interested in child classes of a certain class, we
end_comment

begin_comment
comment|//  would write:
end_comment

begin_comment
comment|//    recordDecl(hasName("MyClass"), hasChild(id("child", recordDecl())))
end_comment

begin_comment
comment|//  When the match is found via the MatchFinder, a user provided callback will
end_comment

begin_comment
comment|//  be called with a BoundNodes instance that contains a mapping from the
end_comment

begin_comment
comment|//  strings that we provided for the id(...) calls to the nodes that were
end_comment

begin_comment
comment|//  matched.
end_comment

begin_comment
comment|//  In the given example, each time our matcher finds a match we get a callback
end_comment

begin_comment
comment|//  where "child" is bound to the CXXRecordDecl node of the matching child
end_comment

begin_comment
comment|//  class declaration.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchersInternal.h for a more in-depth explanation of the
end_comment

begin_comment
comment|//  implementation details of the matcher framework.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchFinder.h for how to use the generated matchers to run over
end_comment

begin_comment
comment|//  an AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/DeclTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersInternal.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersMacros.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Twine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Regex.h"
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|ast_matchers
block|{
comment|/// \brief Maps string IDs to AST nodes matched by parts of a matcher.
comment|///
comment|/// The bound nodes are generated by calling \c bind("id") on the node matchers
comment|/// of the nodes we want to access later.
comment|///
comment|/// The instances of BoundNodes are created by \c MatchFinder when the user's
comment|/// callbacks are executed every time a match is found.
name|class
name|BoundNodes
block|{
name|public
label|:
comment|/// \brief Returns the AST node bound to \c ID.
comment|///
comment|/// Returns NULL if there was no node bound to \c ID or if there is a node but
comment|/// it cannot be converted to the specified type.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getNodeAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|MyBoundNodes
operator|.
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|ID
operator|)
return|;
block|}
comment|/// \brief Deprecated. Please use \c getNodeAs instead.
comment|/// @{
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getDeclAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|ID
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getStmtAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|ID
operator|)
return|;
block|}
comment|/// @}
name|private
label|:
comment|/// \brief Create BoundNodes from a pre-filled map of bindings.
name|BoundNodes
argument_list|(
name|internal
operator|::
name|BoundNodesMap
operator|&
name|MyBoundNodes
argument_list|)
operator|:
name|MyBoundNodes
argument_list|(
argument|MyBoundNodes
argument_list|)
block|{}
name|internal
operator|::
name|BoundNodesMap
name|MyBoundNodes
expr_stmt|;
name|friend
name|class
name|internal
operator|::
name|BoundNodesTree
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief If the provided matcher matches a node, binds the node to \c ID.
comment|///
comment|/// FIXME: Do we want to support this now that we have bind()?
name|template
operator|<
name|typename
name|T
operator|>
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|id
argument_list|(
argument|const std::string&ID
argument_list|,
argument|const internal::BindableMatcher<T>&InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|bind
argument_list|(
name|ID
argument_list|)
return|;
block|}
comment|/// \brief Types of matchers for the top-level classes in the AST class
comment|/// hierarchy.
comment|/// @{
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
name|DeclarationMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|StatementMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|TypeMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|TypeLoc
operator|>
name|TypeLocMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifier
operator|>
name|NestedNameSpecifierMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|NestedNameSpecifierLocMatcher
expr_stmt|;
comment|/// @}
comment|/// \brief Matches any node.
comment|///
comment|/// Useful when another matcher requires a child matcher, but there's no
comment|/// additional constraint. This will often be used with an explicit conversion
comment|/// to an \c internal::Matcher<> type such as \c TypeMatcher.
comment|///
comment|/// Example: \c DeclarationMatcher(anything()) matches all declarations, e.g.,
comment|/// \code
comment|/// "int* p" and "void f()" in
comment|///   int* p;
comment|///   void f();
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|TrueMatcher
operator|>
name|anything
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|TrueMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches declarations.
comment|///
comment|/// Examples matches \c X, \c C, and the friend declaration inside \c C;
comment|/// \code
comment|///   void X();
comment|///   class C {
comment|///     friend X;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|Decl
operator|>
name|decl
expr_stmt|;
comment|/// \brief Matches a declaration of anything that could have a name.
comment|///
comment|/// Example matches \c X, \c S, the anonymous union type, \c i, and \c U;
comment|/// \code
comment|///   typedef int X;
comment|///   struct S {
comment|///     union {
comment|///       int i;
comment|///     } U;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NamedDecl
operator|>
name|namedDecl
expr_stmt|;
comment|/// \brief Matches C++ class declarations.
comment|///
comment|/// Example matches \c X, \c Z
comment|/// \code
comment|///   class X;
comment|///   template<class T> class Z {};
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXRecordDecl
operator|>
name|recordDecl
expr_stmt|;
comment|/// \brief Matches C++ class template declarations.
comment|///
comment|/// Example matches \c Z
comment|/// \code
comment|///   template<class T> class Z {};
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ClassTemplateDecl
operator|>
name|classTemplateDecl
expr_stmt|;
comment|/// \brief Matches C++ class template specializations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl()
comment|///   matches the specializations \c A<int> and \c A<double>
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ClassTemplateSpecializationDecl
operator|>
name|classTemplateSpecializationDecl
expr_stmt|;
comment|/// \brief Matches classTemplateSpecializations that have at least one
comment|/// TemplateArgument matching the given InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToType(asString("int"))))
comment|///   matches the specialization \c A<int>
name|AST_MATCHER_P
argument_list|(
argument|ClassTemplateSpecializationDecl
argument_list|,
argument|hasAnyTemplateArgument
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|TemplateArgumentList
modifier|&
name|List
init|=
name|Node
operator|.
name|getTemplateArgs
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|List
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|List
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after any implicit casts
comment|/// are stripped off.
comment|///
comment|/// Parentheses and explicit casts are not discarded.
comment|/// Given
comment|/// \code
comment|///   int arr[5];
comment|///   int a = 0;
comment|///   char b = 0;
comment|///   const int c = a;
comment|///   int *d = arr;
comment|///   long e = (long) 0l;
comment|/// \endcode
comment|/// The matchers
comment|/// \code
comment|///    varDecl(hasInitializer(ignoringImpCasts(integerLiteral())))
comment|///    varDecl(hasInitializer(ignoringImpCasts(declRefExpr())))
comment|/// \endcode
comment|/// would match the declarations for a, b, c, and d, but not e.
comment|/// While
comment|/// \code
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|///    varDecl(hasInitializer(declRefExpr()))
comment|/// \endcode
comment|/// only match the declarations for b, c, and d.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringImpCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after parentheses and
comment|/// casts are stripped off.
comment|///
comment|/// Implicit and non-C Style casts are also discarded.
comment|/// Given
comment|/// \code
comment|///   int a = 0;
comment|///   char b = (0);
comment|///   void* c = reinterpret_cast<char*>(0);
comment|///   char d = char(0);
comment|/// \endcode
comment|/// The matcher
comment|///    varDecl(hasInitializer(ignoringParenCasts(integerLiteral())))
comment|/// would match the declarations for a, b, c, and d.
comment|/// while
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|/// only match the declaration for a.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringParenCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreParenCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after implicit casts and
comment|/// parentheses are stripped off.
comment|///
comment|/// Explicit casts are not discarded.
comment|/// Given
comment|/// \code
comment|///   int arr[5];
comment|///   int a = 0;
comment|///   char b = (0);
comment|///   const int c = a;
comment|///   int *d = (arr);
comment|///   long e = ((long) 0l);
comment|/// \endcode
comment|/// The matchers
comment|///    varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral())))
comment|///    varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr())))
comment|/// would match the declarations for a, b, c, and d, but not e.
comment|/// while
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|///    varDecl(hasInitializer(declRefExpr()))
comment|/// would only match the declaration for a.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringParenImpCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches classTemplateSpecializations where the n'th TemplateArgument
comment|/// matches the given InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, typename U> class A {};
comment|///   A<bool, int> b;
comment|///   A<int, bool> c;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasTemplateArgument(
comment|///     1, refersToType(asString("int"))))
comment|///   matches the specialization \c A<bool, int>
name|AST_MATCHER_P2
argument_list|(
argument|ClassTemplateSpecializationDecl
argument_list|,
argument|hasTemplateArgument
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|TemplateArgumentList
modifier|&
name|List
init|=
name|Node
operator|.
name|getTemplateArgs
argument_list|()
decl_stmt|;
if|if
condition|(
name|List
operator|.
name|size
argument_list|()
operator|<=
name|N
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|List
operator|.
name|get
argument_list|(
name|N
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain type.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct X {};
comment|///   template<typename T> struct A {};
comment|///   A<X> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToType(class(hasName("X")))))
comment|///   matches the specialization \c A<X>
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Type
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getAsType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> struct A {};
comment|///   struct B { B* next; };
comment|///   A<&B::next> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToDeclaration(fieldDecl(hasName("next"))))
comment|///   matches the specialization \c A<&B::next> with \c fieldDecl(...) matching
comment|///     \c B::next
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToDeclaration
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Declaration
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getAsDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches C++ constructor declarations.
comment|///
comment|/// Example matches Foo::Foo() and Foo::Foo(int)
comment|/// \code
comment|///   class Foo {
comment|///    public:
comment|///     Foo();
comment|///     Foo(int);
comment|///     int DoSomething();
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXConstructorDecl
operator|>
name|constructorDecl
expr_stmt|;
comment|/// \brief Matches explicit C++ destructor declarations.
comment|///
comment|/// Example matches Foo::~Foo()
comment|/// \code
comment|///   class Foo {
comment|///    public:
comment|///     virtual ~Foo();
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXDestructorDecl
operator|>
name|destructorDecl
expr_stmt|;
comment|/// \brief Matches enum declarations.
comment|///
comment|/// Example matches X
comment|/// \code
comment|///   enum X {
comment|///     A, B, C
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumDecl
operator|>
name|enumDecl
expr_stmt|;
comment|/// \brief Matches enum constants.
comment|///
comment|/// Example matches A, B, C
comment|/// \code
comment|///   enum X {
comment|///     A, B, C
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumConstantDecl
operator|>
name|enumConstantDecl
expr_stmt|;
comment|/// \brief Matches method declarations.
comment|///
comment|/// Example matches y
comment|/// \code
comment|///   class X { void y() };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXMethodDecl
operator|>
name|methodDecl
expr_stmt|;
comment|/// \brief Matches variable declarations.
comment|///
comment|/// Note: this does not match declarations of member variables, which are
comment|/// "field" declarations in Clang parlance.
comment|///
comment|/// Example matches a
comment|/// \code
comment|///   int a;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|VarDecl
operator|>
name|varDecl
expr_stmt|;
comment|/// \brief Matches field declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { int m; };
comment|/// \endcode
comment|/// fieldDecl()
comment|///   matches 'm'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FieldDecl
operator|>
name|fieldDecl
expr_stmt|;
comment|/// \brief Matches function declarations.
comment|///
comment|/// Example matches f
comment|/// \code
comment|///   void f();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FunctionDecl
operator|>
name|functionDecl
expr_stmt|;
comment|/// \brief Matches C++ function template declarations.
comment|///
comment|/// Example matches f
comment|/// \code
comment|///   template<class T> void f(T t) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FunctionTemplateDecl
operator|>
name|functionTemplateDecl
expr_stmt|;
comment|/// \brief Matches statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   { ++a; }
comment|/// \endcode
comment|/// stmt()
comment|///   matches both the compound statement '{ ++a; }' and '++a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|Stmt
operator|>
name|stmt
expr_stmt|;
comment|/// \brief Matches declaration statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a;
comment|/// \endcode
comment|/// declStmt()
comment|///   matches 'int a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclStmt
operator|>
name|declStmt
expr_stmt|;
comment|/// \brief Matches member expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a; static int b;
comment|///   };
comment|/// \endcode
comment|/// memberExpr()
comment|///   matches this->x, x, y.x, a, this->b
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|MemberExpr
operator|>
name|memberExpr
expr_stmt|;
comment|/// \brief Matches call expressions.
comment|///
comment|/// Example matches x.y() and y()
comment|/// \code
comment|///   X x;
comment|///   x.y();
comment|///   y();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CallExpr
operator|>
name|callExpr
expr_stmt|;
comment|/// \brief Matches lambda expressions.
comment|///
comment|/// Example matches [&](){return 5;}
comment|/// \code
comment|///   [&](){return 5;}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|LambdaExpr
operator|>
name|lambdaExpr
expr_stmt|;
comment|/// \brief Matches member call expressions.
comment|///
comment|/// Example matches x.y()
comment|/// \code
comment|///   X x;
comment|///   x.y();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXMemberCallExpr
operator|>
name|memberCallExpr
expr_stmt|;
comment|/// \brief Matches init list expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 1, 2 };
comment|///   struct B { int x, y; };
comment|///   B b = { 5, 6 };
comment|/// \endcode
comment|/// initList()
comment|///   matches "{ 1, 2 }" and "{ 5, 6 }"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|InitListExpr
operator|>
name|initListExpr
expr_stmt|;
comment|/// \brief Matches using declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { int x; }
comment|///   using X::x;
comment|/// \endcode
comment|/// usingDecl()
comment|///   matches \code using X::x \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UsingDecl
operator|>
name|usingDecl
expr_stmt|;
comment|/// \brief Matches constructor call expressions (including implicit ones).
comment|///
comment|/// Example matches string(ptr, n) and ptr within arguments of f
comment|///     (matcher = constructExpr())
comment|/// \code
comment|///   void f(const string&a, const string&b);
comment|///   char *ptr;
comment|///   int n;
comment|///   f(string(ptr, n), ptr);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXConstructExpr
operator|>
name|constructExpr
expr_stmt|;
comment|/// \brief Matches implicit and explicit this expressions.
comment|///
comment|/// Example matches the implicit this expression in "return i".
comment|///     (matcher = thisExpr())
comment|/// \code
comment|/// struct foo {
comment|///   int i;
comment|///   int f() { return i; }
comment|/// };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXThisExpr
operator|>
name|thisExpr
expr_stmt|;
comment|/// \brief Matches nodes where temporaries are created.
comment|///
comment|/// Example matches FunctionTakesString(GetStringByValue())
comment|///     (matcher = bindTemporaryExpr())
comment|/// \code
comment|///   FunctionTakesString(GetStringByValue());
comment|///   FunctionTakesStringByPointer(GetStringPointer());
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXBindTemporaryExpr
operator|>
name|bindTemporaryExpr
expr_stmt|;
comment|/// \brief Matches nodes where temporaries are materialized.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   struct T {void func()};
comment|///   T f();
comment|///   void g(T);
comment|/// \endcode
comment|/// materializeTemporaryExpr() matches 'f()' in these statements
comment|/// \code
comment|///   T u(f());
comment|///   g(f());
comment|/// \endcode
comment|/// but does not match
comment|/// \code
comment|///   f();
comment|///   f().func();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|MaterializeTemporaryExpr
operator|>
name|materializeTemporaryExpr
expr_stmt|;
comment|/// \brief Matches new expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   new X;
comment|/// \endcode
comment|/// newExpr()
comment|///   matches 'new X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXNewExpr
operator|>
name|newExpr
expr_stmt|;
comment|/// \brief Matches delete expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   delete X;
comment|/// \endcode
comment|/// deleteExpr()
comment|///   matches 'delete X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDeleteExpr
operator|>
name|deleteExpr
expr_stmt|;
comment|/// \brief Matches array subscript expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i = a[1];
comment|/// \endcode
comment|/// arraySubscriptExpr()
comment|///   matches "a[1]"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ArraySubscriptExpr
operator|>
name|arraySubscriptExpr
expr_stmt|;
comment|/// \brief Matches the value of a default argument at the call site.
comment|///
comment|/// Example matches the CXXDefaultArgExpr placeholder inserted for the
comment|///     default value of the second parameter in the call expression f(42)
comment|///     (matcher = defaultArgExpr())
comment|/// \code
comment|///   void f(int x, int y = 0);
comment|///   f(42);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDefaultArgExpr
operator|>
name|defaultArgExpr
expr_stmt|;
comment|/// \brief Matches overloaded operator calls.
comment|///
comment|/// Note that if an operator isn't overloaded, it won't match. Instead, use
comment|/// binaryOperator matcher.
comment|/// Currently it does not match operators such as new delete.
comment|/// FIXME: figure out why these do not match?
comment|///
comment|/// Example matches both operator<<((o<< b), c) and operator<<(o, b)
comment|///     (matcher = operatorCallExpr())
comment|/// \code
comment|///   ostream&operator<< (ostream&out, int i) { };
comment|///   ostream&o; int b = 1, c = 1;
comment|///   o<< b<< c;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXOperatorCallExpr
operator|>
name|operatorCallExpr
expr_stmt|;
comment|/// \brief Matches expressions.
comment|///
comment|/// Example matches x()
comment|/// \code
comment|///   void f() { x(); }
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|Expr
operator|>
name|expr
expr_stmt|;
comment|/// \brief Matches expressions that refer to declarations.
comment|///
comment|/// Example matches x in if (x)
comment|/// \code
comment|///   bool x;
comment|///   if (x) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclRefExpr
operator|>
name|declRefExpr
expr_stmt|;
comment|/// \brief Matches if statements.
comment|///
comment|/// Example matches 'if (x) {}'
comment|/// \code
comment|///   if (x) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|IfStmt
operator|>
name|ifStmt
expr_stmt|;
comment|/// \brief Matches for statements.
comment|///
comment|/// Example matches 'for (;;) {}'
comment|/// \code
comment|///   for (;;) {}
comment|///   int i[] =  {1, 2, 3}; for (auto a : i);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ForStmt
operator|>
name|forStmt
expr_stmt|;
comment|/// \brief Matches range-based for statements.
comment|///
comment|/// forRangeStmt() matches 'for (auto a : i)'
comment|/// \code
comment|///   int i[] =  {1, 2, 3}; for (auto a : i);
comment|///   for(int j = 0; j< 5; ++j);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXForRangeStmt
operator|>
name|forRangeStmt
expr_stmt|;
comment|/// \brief Matches the increment statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasIncrement(unaryOperator(hasOperatorName("++"))))
comment|/// matches '++x' in
comment|/// \code
comment|///     for (x; x< N; ++x) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasIncrement
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Increment
init|=
name|Node
operator|.
name|getInc
argument_list|()
decl_stmt|;
return|return
operator|(
name|Increment
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Increment
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initialization statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasLoopInit(declStmt()))
comment|/// matches 'int x = 0' in
comment|/// \code
comment|///     for (int x = 0; x< N; ++x) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasLoopInit
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Init
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|Init
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Init
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches while statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) {}
comment|/// \endcode
comment|/// whileStmt()
comment|///   matches 'while (true) {}'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|WhileStmt
operator|>
name|whileStmt
expr_stmt|;
comment|/// \brief Matches do statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   do {} while (true);
comment|/// \endcode
comment|/// doStmt()
comment|///   matches 'do {} while(true)'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DoStmt
operator|>
name|doStmt
expr_stmt|;
comment|/// \brief Matches break statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) { break; }
comment|/// \endcode
comment|/// breakStmt()
comment|///   matches 'break'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BreakStmt
operator|>
name|breakStmt
expr_stmt|;
comment|/// \brief Matches continue statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) { continue; }
comment|/// \endcode
comment|/// continueStmt()
comment|///   matches 'continue'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ContinueStmt
operator|>
name|continueStmt
expr_stmt|;
comment|/// \brief Matches return statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   return 1;
comment|/// \endcode
comment|/// returnStmt()
comment|///   matches 'return 1'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ReturnStmt
operator|>
name|returnStmt
expr_stmt|;
comment|/// \brief Matches goto statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   goto FOO;
comment|///   FOO: bar();
comment|/// \endcode
comment|/// gotoStmt()
comment|///   matches 'goto FOO'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|GotoStmt
operator|>
name|gotoStmt
expr_stmt|;
comment|/// \brief Matches label statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   goto FOO;
comment|///   FOO: bar();
comment|/// \endcode
comment|/// labelStmt()
comment|///   matches 'FOO:'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|LabelStmt
operator|>
name|labelStmt
expr_stmt|;
comment|/// \brief Matches switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// switchStmt()
comment|///   matches 'switch(a)'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SwitchStmt
operator|>
name|switchStmt
expr_stmt|;
comment|/// \brief Matches case and default statements inside switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// switchCase()
comment|///   matches 'case 42: break;' and 'default: break;'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SwitchCase
operator|>
name|switchCase
expr_stmt|;
comment|/// \brief Matches compound statements.
comment|///
comment|/// Example matches '{}' and '{{}}'in 'for (;;) {{}}'
comment|/// \code
comment|///   for (;;) {{}}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CompoundStmt
operator|>
name|compoundStmt
expr_stmt|;
comment|/// \brief Matches catch statements.
comment|///
comment|/// \code
comment|///   try {} catch(int i) {}
comment|/// \endcode
comment|/// catchStmt()
comment|///   matches 'catch(int i)'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXCatchStmt
operator|>
name|catchStmt
expr_stmt|;
comment|/// \brief Matches try statements.
comment|///
comment|/// \code
comment|///   try {} catch(int i) {}
comment|/// \endcode
comment|/// tryStmt()
comment|///   matches 'try {}'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXTryStmt
operator|>
name|tryStmt
expr_stmt|;
comment|/// \brief Matches throw expressions.
comment|///
comment|/// \code
comment|///   try { throw 5; } catch(int i) {}
comment|/// \endcode
comment|/// throwExpr()
comment|///   matches 'throw 5'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXThrowExpr
operator|>
name|throwExpr
expr_stmt|;
comment|/// \brief Matches null statements.
comment|///
comment|/// \code
comment|///   foo();;
comment|/// \endcode
comment|/// nullStmt()
comment|///   matches the second ';'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|NullStmt
operator|>
name|nullStmt
expr_stmt|;
comment|/// \brief Matches asm statements.
comment|///
comment|/// \code
comment|///  int i = 100;
comment|///   __asm("mov al, 2");
comment|/// \endcode
comment|/// asmStmt()
comment|///   matches '__asm("mov al, 2")'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|AsmStmt
operator|>
name|asmStmt
expr_stmt|;
comment|/// \brief Matches bool literals.
comment|///
comment|/// Example matches true
comment|/// \code
comment|///   true
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXBoolLiteralExpr
operator|>
name|boolLiteral
expr_stmt|;
comment|/// \brief Matches string literals (also matches wide string literals).
comment|///
comment|/// Example matches "abcd", L"abcd"
comment|/// \code
comment|///   char *s = "abcd"; wchar_t *ws = L"abcd"
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|StringLiteral
operator|>
name|stringLiteral
expr_stmt|;
comment|/// \brief Matches character literals (also matches wchar_t).
comment|///
comment|/// Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
comment|/// though.
comment|///
comment|/// Example matches 'a', L'a'
comment|/// \code
comment|///   char ch = 'a'; wchar_t chw = L'a';
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CharacterLiteral
operator|>
name|characterLiteral
expr_stmt|;
comment|/// \brief Matches integer literals of all sizes / encodings.
comment|///
comment|/// Not matching character-encoded integers such as L'a'.
comment|///
comment|/// Example matches 1, 1L, 0x1, 1U
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|IntegerLiteral
operator|>
name|integerLiteral
expr_stmt|;
comment|/// \brief Matches user defined literal operator call.
comment|///
comment|/// Example match: "foo"_suffix
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UserDefinedLiteral
operator|>
name|userDefinedLiteral
expr_stmt|;
comment|/// \brief Matches nullptr literal.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXNullPtrLiteralExpr
operator|>
name|nullPtrLiteralExpr
expr_stmt|;
comment|/// \brief Matches binary operator expressions.
comment|///
comment|/// Example matches a || b
comment|/// \code
comment|///   !(a || b)
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BinaryOperator
operator|>
name|binaryOperator
expr_stmt|;
comment|/// \brief Matches unary operator expressions.
comment|///
comment|/// Example matches !a
comment|/// \code
comment|///   !a || b
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryOperator
operator|>
name|unaryOperator
expr_stmt|;
comment|/// \brief Matches conditional operator expressions.
comment|///
comment|/// Example matches a ? b : c
comment|/// \code
comment|///   (a ? b : c) + 42
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ConditionalOperator
operator|>
name|conditionalOperator
expr_stmt|;
comment|/// \brief Matches a reinterpret_cast expression.
comment|///
comment|/// Either the source expression or the destination type can be matched
comment|/// using has(), but hasDestinationType() is more specific and can be
comment|/// more readable.
comment|///
comment|/// Example matches reinterpret_cast<char*>(&p) in
comment|/// \code
comment|///   void* p = reinterpret_cast<char*>(&p);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXReinterpretCastExpr
operator|>
name|reinterpretCastExpr
expr_stmt|;
comment|/// \brief Matches a C++ static_cast expression.
comment|///
comment|/// \see hasDestinationType
comment|/// \see reinterpretCast
comment|///
comment|/// Example:
comment|///   staticCastExpr()
comment|/// matches
comment|///   static_cast<long>(8)
comment|/// in
comment|/// \code
comment|///   long eight(static_cast<long>(8));
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXStaticCastExpr
operator|>
name|staticCastExpr
expr_stmt|;
comment|/// \brief Matches a dynamic_cast expression.
comment|///
comment|/// Example:
comment|///   dynamicCastExpr()
comment|/// matches
comment|///   dynamic_cast<D*>(&b);
comment|/// in
comment|/// \code
comment|///   struct B { virtual ~B() {} }; struct D : B {};
comment|///   B b;
comment|///   D* p = dynamic_cast<D*>(&b);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDynamicCastExpr
operator|>
name|dynamicCastExpr
expr_stmt|;
comment|/// \brief Matches a const_cast expression.
comment|///
comment|/// Example: Matches const_cast<int*>(&r) in
comment|/// \code
comment|///   int n = 42;
comment|///   const int&r(n);
comment|///   int* p = const_cast<int*>(&r);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXConstCastExpr
operator|>
name|constCastExpr
expr_stmt|;
comment|/// \brief Matches a C-style cast expression.
comment|///
comment|/// Example: Matches (int*) 2.2f in
comment|/// \code
comment|///   int i = (int) 2.2f;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CStyleCastExpr
operator|>
name|cStyleCastExpr
expr_stmt|;
comment|/// \brief Matches explicit cast expressions.
comment|///
comment|/// Matches any cast expression written in user code, whether it be a
comment|/// C-style cast, a functional-style cast, or a keyword cast.
comment|///
comment|/// Does not match implicit conversions.
comment|///
comment|/// Note: the name "explicitCast" is chosen to match Clang's terminology, as
comment|/// Clang uses the term "cast" to apply to implicit conversions as well as to
comment|/// actual cast expressions.
comment|///
comment|/// \see hasDestinationType.
comment|///
comment|/// Example: matches all five of the casts in
comment|/// \code
comment|///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))
comment|/// \endcode
comment|/// but does not match the implicit conversion in
comment|/// \code
comment|///   long ell = 42;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ExplicitCastExpr
operator|>
name|explicitCastExpr
expr_stmt|;
comment|/// \brief Matches the implicit cast nodes of Clang's AST.
comment|///
comment|/// This matches many different places, including function call return value
comment|/// eliding, as well as any type conversions.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ImplicitCastExpr
operator|>
name|implicitCastExpr
expr_stmt|;
comment|/// \brief Matches any cast nodes of Clang's AST.
comment|///
comment|/// Example: castExpr() matches each of the following:
comment|/// \code
comment|///   (int) 3;
comment|///   const_cast<Expr *>(SubExpr);
comment|///   char c = 0;
comment|/// \endcode
comment|/// but does not match
comment|/// \code
comment|///   int i = (0);
comment|///   int k = 0;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CastExpr
operator|>
name|castExpr
expr_stmt|;
comment|/// \brief Matches functional cast expressions
comment|///
comment|/// Example: Matches Foo(bar);
comment|/// \code
comment|///   Foo f = bar;
comment|///   Foo g = (Foo) bar;
comment|///   Foo h = Foo(bar);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXFunctionalCastExpr
operator|>
name|functionalCastExpr
expr_stmt|;
comment|/// \brief Matches \c QualTypes in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|QualType
operator|>
name|qualType
expr_stmt|;
comment|/// \brief Matches \c Types in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Type
operator|,
name|Type
operator|>
name|type
expr_stmt|;
comment|/// \brief Matches \c TypeLocs in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|TypeLoc
operator|,
name|TypeLoc
operator|>
name|typeLoc
expr_stmt|;
comment|/// \brief Various overloads for the anyOf matcher.
comment|/// @{
comment|/// \brief Matches if any of the given matchers matches.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M1
operator|,
name|M2
operator|>
name|anyOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M1
operator|,
name|M2
operator|>
operator|(
name|P1
operator|,
name|P2
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M2
operator|,
name|M3
operator|>
expr|>
name|anyOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|,
argument|const M3&P3
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|P3
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M2
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M3
operator|,
name|M4
operator|>
expr|>
operator|>
name|anyOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|,
argument|const M3&P3
argument_list|,
argument|const M4&P4
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|anyOf
argument_list|(
name|P3
argument_list|,
name|P4
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M2
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M3
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AnyOfMatcher
operator|,
name|M4
operator|,
name|M5
operator|>
expr|>
operator|>
expr|>
name|anyOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|,
argument|const M3&P3
argument_list|,
argument|const M4&P4
argument_list|,
argument|const M5&P5
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|P1
argument_list|,
name|anyOf
argument_list|(
name|P2
argument_list|,
name|anyOf
argument_list|(
name|P3
argument_list|,
name|anyOf
argument_list|(
name|P4
argument_list|,
name|P5
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// @}
comment|/// \brief Various overloads for the allOf matcher.
comment|/// @{
comment|/// \brief Matches if all given matchers match.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|M1
operator|,
name|M2
operator|>
name|allOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|M1
operator|,
name|M2
operator|>
operator|(
name|P1
operator|,
name|P2
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|M1
operator|,
name|internal
operator|::
name|PolymorphicMatcherWithParam2
operator|<
name|internal
operator|::
name|AllOfMatcher
operator|,
name|M2
operator|,
name|M3
operator|>
expr|>
name|allOf
argument_list|(
argument|const M1&P1
argument_list|,
argument|const M2&P2
argument_list|,
argument|const M3&P3
argument_list|)
block|{
return|return
name|allOf
argument_list|(
name|P1
argument_list|,
name|allOf
argument_list|(
name|P2
argument_list|,
name|P3
argument_list|)
argument_list|)
return|;
block|}
comment|/// @}
comment|/// \brief Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)
comment|///
comment|/// Given
comment|/// \code
comment|///   Foo x = bar;
comment|///   int y = sizeof(x) + alignof(x);
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr()
comment|///   matches \c sizeof(x) and \c alignof(x)
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryExprOrTypeTraitExpr
operator|>
name|unaryExprOrTypeTraitExpr
expr_stmt|;
comment|/// \brief Matches unary expressions that have a specific type of argument.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int"))
comment|///   matches \c sizeof(a) and \c alignof(c)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|hasArgumentOfType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|ArgumentType
init|=
name|Node
operator|.
name|getTypeOfArgument
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|ArgumentType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches unary expressions of a certain kind.
comment|///
comment|/// Given
comment|/// \code
comment|///   int x;
comment|///   int s = sizeof(x) + alignof(x)
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))
comment|///   matches \c sizeof(x)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|ofKind
argument_list|,
argument|UnaryExprOrTypeTrait
argument_list|,
argument|Kind
argument_list|)
block|{
return|return
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|Kind
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// alignof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|alignOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
operator|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_AlignOf
argument_list|)
argument_list|,
name|InnerMatcher
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// sizeof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|sizeOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
operator|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_SizeOf
argument_list|)
argument_list|,
name|InnerMatcher
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches NamedDecl nodes that have the specified name.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by prefixing the name
comment|/// with '<enclosing>::'.
comment|/// Does not match typedefs of an underlying type with the given name.
comment|///
comment|/// Example matches X (Name == "X")
comment|/// \code
comment|///   class X;
comment|/// \endcode
comment|///
comment|/// Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X")
comment|/// \code
comment|///   namespace a { namespace b { class X; } }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|hasName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Name
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|std
operator|::
name|string
name|FullNameString
operator|=
literal|"::"
operator|+
name|Node
operator|.
name|getQualifiedNameAsString
argument_list|()
expr_stmt|;
specifier|const
name|llvm
operator|::
name|StringRef
name|FullName
operator|=
name|FullNameString
expr_stmt|;
specifier|const
name|llvm
operator|::
name|StringRef
name|Pattern
operator|=
name|Name
expr_stmt|;
if|if
condition|(
name|Pattern
operator|.
name|startswith
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
return|return
name|FullName
operator|==
name|Pattern
return|;
block|}
else|else
block|{
return|return
name|FullName
operator|.
name|endswith
argument_list|(
operator|(
literal|"::"
operator|+
name|Pattern
operator|)
operator|.
name|str
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/// \brief Matches NamedDecl nodes whose full names partially match the
comment|/// given RegExp.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by
comment|/// prefixing the name with '<enclosing>::'.  Does not match typedefs
comment|/// of an underlying type with the given name.
comment|///
comment|/// Example matches X (regexp == "::X")
comment|/// \code
comment|///   class X;
comment|/// \endcode
comment|///
comment|/// Example matches X (regexp is one of "::X", "^foo::.*X", among others)
comment|/// \code
comment|///   namespace foo { namespace bar { class X; } }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|matchesName
argument_list|,
argument|std::string
argument_list|,
argument|RegExp
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|RegExp
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|FullNameString
operator|=
literal|"::"
operator|+
name|Node
operator|.
name|getQualifiedNameAsString
argument_list|()
expr_stmt|;
name|llvm
operator|::
name|Regex
name|RE
argument_list|(
name|RegExp
argument_list|)
expr_stmt|;
return|return
name|RE
operator|.
name|match
argument_list|(
name|FullNameString
argument_list|)
return|;
block|}
comment|/// \brief Matches overloaded operator names.
comment|///
comment|/// Matches overloaded operator names specified in strings without the
comment|/// "operator" prefix, such as "<<", for OverloadedOperatorCall's.
comment|///
comment|/// Example matches a<< b
comment|///     (matcher == operatorCallExpr(hasOverloadedOperatorName("<<")))
comment|/// \code
comment|///   a<< b;
comment|///   c&& d;  // assuming both operator<<
comment|///            // and operator&& are overloaded somewhere.
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXOperatorCallExpr
argument_list|,
argument|hasOverloadedOperatorName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|getOperatorSpelling
argument_list|(
name|Node
operator|.
name|getOperator
argument_list|()
argument_list|)
operator|==
name|Name
return|;
block|}
comment|/// \brief Matches C++ classes that are directly or indirectly derived from
comment|/// a class matching \c Base.
comment|///
comment|/// Note that a class is not considered to be derived from itself.
comment|///
comment|/// Example matches Y, Z, C (Base == hasName("X"))
comment|/// \code
comment|///   class X;
comment|///   class Y : public X {};  // directly derived
comment|///   class Z : public Y {};  // indirectly derived
comment|///   typedef X A;
comment|///   typedef A B;
comment|///   class C : public B {};  // derived from a typedef of X
comment|/// \endcode
comment|///
comment|/// In the following example, Bar matches isDerivedFrom(hasName("X")):
comment|/// \code
comment|///   class Foo;
comment|///   typedef Foo X;
comment|///   class Bar : public Foo {};  // derived from a type that X is a typedef of
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isDerivedFrom
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|Base
argument_list|)
block|{
return|return
name|Finder
operator|->
name|classIsDerivedFrom
argument_list|(
operator|&
name|Node
argument_list|,
name|Base
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded method as shortcut for \c isDerivedFrom(hasName(...)).
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXRecordDecl
operator|>
name|isDerivedFrom
argument_list|(
argument|StringRef BaseName
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|BaseName
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|isDerivedFrom
argument_list|(
name|hasName
argument_list|(
name|BaseName
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Similar to \c isDerivedFrom(), but also matches classes that directly
comment|/// match \c Base.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXRecordDecl
operator|>
name|isSameOrDerivedFrom
argument_list|(
argument|internal::Matcher<NamedDecl> Base
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|Base
argument_list|,
name|isDerivedFrom
argument_list|(
name|Base
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Overloaded method as shortcut for
comment|/// \c isSameOrDerivedFrom(hasName(...)).
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXRecordDecl
operator|>
name|isSameOrDerivedFrom
argument_list|(
argument|StringRef BaseName
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|BaseName
operator|.
name|empty
argument_list|()
argument_list|)
block|;
return|return
name|isSameOrDerivedFrom
argument_list|(
name|hasName
argument_list|(
name|BaseName
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y (matcher = recordDecl(has(recordDecl(hasName("X")))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|/// \endcode
comment|///
comment|/// ChildT must be an AST base type.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|ChildT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasMatcher
operator|,
name|ChildT
operator|>
name|has
argument_list|(
argument|const internal::Matcher<ChildT>&ChildMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasMatcher
operator|,
name|ChildT
operator|>
operator|(
name|ChildMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y, Z
comment|///     (matcher = recordDecl(hasDescendant(recordDecl(hasName("X")))))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };
comment|/// \endcode
comment|///
comment|/// DescendantT must be an AST base type.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|DescendantT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasDescendantMatcher
operator|,
name|DescendantT
operator|>
name|hasDescendant
argument_list|(
argument|const internal::Matcher<DescendantT>&DescendantMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasDescendantMatcher
operator|,
name|DescendantT
operator|>
operator|(
name|DescendantMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y (matcher = recordDecl(forEach(recordDecl(hasName("X")))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|/// \endcode
comment|///
comment|/// ChildT must be an AST base type.
comment|///
comment|/// As opposed to 'has', 'forEach' will cause a match for each result that
comment|/// matches instead of only on the first one.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|ChildT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachMatcher
operator|,
name|ChildT
operator|>
name|forEach
argument_list|(
argument|const internal::Matcher<ChildT>&ChildMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachMatcher
operator|,
name|ChildT
operator|>
operator|(
name|ChildMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, A, B, C
comment|///     (matcher = recordDecl(forEachDescendant(recordDecl(hasName("X")))))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class A { class X {}; };
comment|///   class B { class C { class X {}; }; };
comment|/// \endcode
comment|///
comment|/// DescendantT must be an AST base type.
comment|///
comment|/// As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for
comment|/// each result that matches instead of only on the first one.
comment|///
comment|/// Note: Recursively combined ForEachDescendant can cause many matches:
comment|///   recordDecl(forEachDescendant(recordDecl(forEachDescendant(recordDecl()))))
comment|/// will match 10 times (plus injected class name matches) on:
comment|/// \code
comment|///   class A { class B { class C { class D { class E {}; }; }; }; };
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|DescendantT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachDescendantMatcher
operator|,
name|DescendantT
operator|>
name|forEachDescendant
argument_list|(
argument|const internal::Matcher<DescendantT>&DescendantMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|ForEachDescendantMatcher
operator|,
name|DescendantT
operator|>
operator|(
name|DescendantMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have a parent that matches the provided
comment|/// matcher.
comment|///
comment|/// Given
comment|/// \code
comment|/// void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }
comment|/// \endcode
comment|/// \c compoundStmt(hasParent(ifStmt())) matches "{ int x = 43; }".
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|ParentT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasParentMatcher
operator|,
name|ParentT
operator|>
name|hasParent
argument_list|(
argument|const internal::Matcher<ParentT>&ParentMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasParentMatcher
operator|,
name|ParentT
operator|>
operator|(
name|ParentMatcher
operator|)
return|;
block|}
comment|/// \brief Matches AST nodes that have an ancestor that matches the provided
comment|/// matcher.
comment|///
comment|/// Given
comment|/// \code
comment|/// void f() { if (true) { int x = 42; } }
comment|/// void g() { for (;;) { int x = 43; } }
comment|/// \endcode
comment|/// \c expr(integerLiteral(hasAncestor(ifStmt()))) matches \c 42, but not 43.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|AncestorT
operator|>
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasAncestorMatcher
operator|,
name|AncestorT
operator|>
name|hasAncestor
argument_list|(
argument|const internal::Matcher<AncestorT>&AncestorMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgumentAdaptingMatcher
operator|<
name|internal
operator|::
name|HasAncestorMatcher
operator|,
name|AncestorT
operator|>
operator|(
name|AncestorMatcher
operator|)
return|;
block|}
comment|/// \brief Matches if the provided matcher does not match.
comment|///
comment|/// Example matches Y (matcher = recordDecl(unless(hasName("X"))))
comment|/// \code
comment|///   class X {};
comment|///   class Y {};
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|M
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|NotMatcher
operator|,
name|M
operator|>
name|unless
argument_list|(
argument|const M&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|NotMatcher
operator|,
name|M
operator|>
operator|(
name|InnerMatcher
operator|)
return|;
block|}
comment|/// \brief Matches a type if the declaration of the type matches the given
comment|/// matcher.
comment|///
comment|/// Usable as: Matcher<QualType>, Matcher<CallExpr>, Matcher<CXXConstructExpr>,
comment|///   Matcher<MemberExpr>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
expr|>
name|hasDeclaration
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
expr|>
operator|(
name|InnerMatcher
operator|)
return|;
block|}
comment|/// \brief Matches on the implicit object argument of a member call expression.
comment|///
comment|/// Example matches y.x() (matcher = callExpr(on(hasType(recordDecl(hasName("Y"))))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x(); }",
comment|/// \endcode
comment|///
comment|/// FIXME: Overload to allow directly matching types?
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|on
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|const_cast
operator|<
name|CXXMemberCallExpr
operator|&
operator|>
operator|(
name|Node
operator|)
operator|.
name|getImplicitObjectArgument
argument_list|()
operator|->
name|IgnoreParenImpCasts
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the call expression's callee expression matches.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y { void x() { this->x(); x(); Y y; y.x(); } };
comment|///   void f() { f(); }
comment|/// \endcode
comment|/// callExpr(callee(expr()))
comment|///   matches this->x(), x(), y.x(), f()
comment|/// with callee(...)
comment|///   matching this->x, x, y.x, f respectively
comment|///
comment|/// Note: Callee cannot take the more general internal::Matcher<Expr>
comment|/// because this introduces ambiguous overloads with calls to Callee taking a
comment|/// internal::Matcher<Decl>, as the matcher hierarchy is purely
comment|/// implemented in terms of implicit casts.
name|AST_MATCHER_P
argument_list|(
argument|CallExpr
argument_list|,
argument|callee
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|Node
operator|.
name|getCallee
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the call expression's callee's declaration matches the
comment|/// given matcher.
comment|///
comment|/// Example matches y.x() (matcher = callExpr(callee(methodDecl(hasName("x")))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x();
comment|/// \endcode
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CallExpr
operator|>
name|callee
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|Matcher
operator|<
name|CallExpr
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the expression's or declaration's type matches a type
comment|/// matcher.
comment|///
comment|/// Example matches x (matcher = expr(hasType(recordDecl(hasName("X")))))
comment|///             and z (matcher = varDecl(hasType(recordDecl(hasName("X")))))
comment|/// \code
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|Expr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|ValueDecl
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the declaration of the expression's or value
comment|/// declaration's type.
comment|///
comment|/// In case of a value declaration (for example a variable declaration),
comment|/// this resolves one layer of indirection. For example, in the value
comment|/// declaration "X x;", recordDecl(hasName("X")) matches the declaration of X,
comment|/// while varDecl(hasType(recordDecl(hasName("X")))) matches the declaration
comment|/// of x."
comment|///
comment|/// Example matches x (matcher = expr(hasType(recordDecl(hasName("X")))))
comment|///             and z (matcher = varDecl(hasType(recordDecl(hasName("X")))))
comment|/// \code
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<Expr>, Matcher<ValueDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|matcher_hasTypeMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
expr|>
name|hasType
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|hasType
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is represented by the given string.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y* y; y->x(); }
comment|/// \endcode
comment|/// callExpr(on(hasType(asString("class Y *"))))
comment|///   matches y->x()
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|asString
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|Name
operator|==
name|Node
operator|.
name|getAsString
argument_list|()
return|;
block|}
comment|/// \brief Matches if the matched type is a pointer type and the pointee type
comment|/// matches the specified matcher.
comment|///
comment|/// Example matches y->x()
comment|///     (matcher = callExpr(on(hasType(pointsTo(recordDecl(hasName("Y")))))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y *y; y->x(); }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|pointsTo
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isPointerType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Overloaded to match the pointee type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|pointsTo
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|pointsTo
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is a reference type and the referenced
comment|/// type matches the specified matcher.
comment|///
comment|/// Example matches X&x and const X&y
comment|///     (matcher = varDecl(hasType(references(recordDecl(hasName("X"))))))
comment|/// \code
comment|///   class X {
comment|///     void a(X b) {
comment|///       X&x = b;
comment|///       const X&y = b;
comment|///   };
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|references
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isReferenceType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Overloaded to match the referenced type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|references
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|references
argument_list|(
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
operator|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
argument_list|)
return|;
block|}
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|onImplicitObjectArgument
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|const_cast
operator|<
name|CXXMemberCallExpr
operator|&
operator|>
operator|(
name|Node
operator|)
operator|.
name|getImplicitObjectArgument
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the expression's type either matches the specified
comment|/// matcher, or is a pointer to a type that matches the InnerMatcher.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXMemberCallExpr
operator|>
name|thisPointerType
argument_list|(
argument|const internal::Matcher<QualType>&InnerMatcher
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the type's declaration.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|CXXMemberCallExpr
operator|>
name|thisPointerType
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches a DeclRefExpr that refers to a declaration that matches the
comment|/// specified matcher.
comment|///
comment|/// Example matches x in if(x)
comment|///     (matcher = declRefExpr(to(varDecl(hasName("x")))))
comment|/// \code
comment|///   bool x;
comment|///   if (x) {}
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|to
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Decl
modifier|*
name|DeclNode
init|=
name|Node
operator|.
name|getDecl
argument_list|()
decl_stmt|;
return|return
operator|(
name|DeclNode
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a \c DeclRefExpr that refers to a declaration through a
comment|/// specific using shadow declaration.
comment|///
comment|/// FIXME: This currently only works for functions. Fix.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace a { void f() {} }
comment|///   using a::f;
comment|///   void g() {
comment|///     f();     // Matches this ..
comment|///     a::f();  // .. but not this.
comment|///   }
comment|/// \endcode
comment|/// declRefExpr(throughUsingDeclaration(anything()))
comment|///   matches \c f()
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|throughUsingDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|NamedDecl
modifier|*
name|FoundDecl
init|=
name|Node
operator|.
name|getFoundDecl
argument_list|()
decl_stmt|;
if|if
condition|(
specifier|const
name|UsingShadowDecl
modifier|*
name|UsingDecl
init|=
name|llvm
operator|::
name|dyn_cast
operator|<
name|UsingShadowDecl
operator|>
operator|(
name|FoundDecl
operator|)
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|UsingDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches the Decl of a DeclStmt which has a single declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a, b;
comment|///   int c;
comment|/// \endcode
comment|/// declStmt(hasSingleDecl(anything()))
comment|///   matches 'int c;' but not 'int a, b;'.
name|AST_MATCHER_P
argument_list|(
argument|DeclStmt
argument_list|,
argument|hasSingleDecl
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|isSingleDecl
argument_list|()
condition|)
block|{
specifier|const
name|Decl
modifier|*
name|FoundDecl
init|=
name|Node
operator|.
name|getSingleDecl
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|FoundDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a variable declaration that has an initializer expression
comment|/// that matches the given matcher.
comment|///
comment|/// Example matches x (matcher = varDecl(hasInitializer(callExpr())))
comment|/// \code
comment|///   bool y() { return true; }
comment|///   bool x = y();
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|VarDecl
argument_list|,
argument|hasInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Initializer
init|=
name|Node
operator|.
name|getAnyInitializer
argument_list|()
decl_stmt|;
return|return
operator|(
name|Initializer
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Initializer
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Checks that a call expression or a constructor call expression has
comment|/// a specific number of arguments (including absent default arguments).
comment|///
comment|/// Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2)))
comment|/// \code
comment|///   void f(int x, int y);
comment|///   f(0, 0);
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|argumentCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches the n'th argument of a call expression or a constructor
comment|/// call expression.
comment|///
comment|/// Example matches y in x(y)
comment|///     (matcher = callExpr(hasArgument(0, declRefExpr())))
comment|/// \code
comment|///   void x(int) { int y; x(y); }
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P2
argument_list|(
argument|hasArgument
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getArg
argument_list|(
name|N
argument_list|)
operator|->
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches declaration statements that contain a specific number of
comment|/// declarations.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   int a, b;
comment|///   int c;
comment|///   int d = 2, e;
comment|/// \endcode
comment|/// declCountIs(2)
comment|///   matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'.
name|AST_MATCHER_P
argument_list|(
argument|DeclStmt
argument_list|,
argument|declCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|Node
operator|.
name|decl_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|decl_end
argument_list|()
argument_list|)
operator|==
operator|(
name|ptrdiff_t
operator|)
name|N
return|;
block|}
comment|/// \brief Matches the n'th declaration of a declaration statement.
comment|///
comment|/// Note that this does not work for global declarations because the AST
comment|/// breaks up multiple-declaration DeclStmt's into multiple single-declaration
comment|/// DeclStmt's.
comment|/// Example: Given non-global declarations
comment|/// \code
comment|///   int a, b = 0;
comment|///   int c;
comment|///   int d = 2, e;
comment|/// \endcode
comment|/// declStmt(containsDeclaration(
comment|///       0, varDecl(hasInitializer(anything()))))
comment|///   matches only 'int d = 2, e;', and
comment|/// declStmt(containsDeclaration(1, varDecl()))
comment|/// \code
comment|///   matches 'int a, b = 0' as well as 'int d = 2, e;'
comment|///   but 'int c;' is not matched.
comment|/// \endcode
name|AST_MATCHER_P2
argument_list|(
argument|DeclStmt
argument_list|,
argument|containsDeclaration
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|unsigned
name|NumDecls
init|=
name|std
operator|::
name|distance
argument_list|(
name|Node
operator|.
name|decl_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|decl_end
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|N
operator|>=
name|NumDecls
condition|)
return|return
name|false
return|;
name|DeclStmt
operator|::
name|const_decl_iterator
name|Iterator
operator|=
name|Node
operator|.
name|decl_begin
argument_list|()
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|Iterator
argument_list|,
name|N
argument_list|)
expr_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|Iterator
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// recordDecl(has(constructorDecl(hasAnyConstructorInitializer(anything()))))
comment|///   record matches Foo, hasAnyConstructorInitializer matches foo_(1)
name|AST_MATCHER_P
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|hasAnyConstructorInitializer
argument_list|,
argument|internal::Matcher<CXXCtorInitializer>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|CXXConstructorDecl
operator|::
name|init_const_iterator
name|I
operator|=
name|Node
operator|.
name|init_begin
argument_list|()
init|;
name|I
operator|!=
name|Node
operator|.
name|init_end
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|I
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the field declaration of a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// recordDecl(has(constructorDecl(hasAnyConstructorInitializer(
comment|///     forField(hasName("foo_"))))))
comment|///   matches Foo
comment|/// with forField matching foo_
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|forField
argument_list|,
argument|internal::Matcher<FieldDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|FieldDecl
modifier|*
name|NodeAsDecl
init|=
name|Node
operator|.
name|getMember
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsDecl
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initializer expression of a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// recordDecl(has(constructorDecl(hasAnyConstructorInitializer(
comment|///     withInitializer(integerLiteral(equals(1)))))))
comment|///   matches Foo
comment|/// with withInitializer matching (1)
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|withInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|NodeAsExpr
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsExpr
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsExpr
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a contructor initializer if it is explicitly written in
comment|/// code (as opposed to implicitly added by the compiler).
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() { }
comment|///     Foo(int) : foo_("A") { }
comment|///     string foo_;
comment|///   };
comment|/// \endcode
comment|/// constructorDecl(hasAnyConstructorInitializer(isWritten()))
comment|///   will match Foo(int), but not Foo()
name|AST_MATCHER
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|isWritten
argument_list|)
block|{
return|return
name|Node
operator|.
name|isWritten
argument_list|()
return|;
block|}
comment|/// \brief Matches a constructor declaration that has been implicitly added
comment|/// by the compiler (eg. implicit default/copy constructors).
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isImplicit
argument_list|)
block|{
return|return
name|Node
operator|.
name|isImplicit
argument_list|()
return|;
block|}
comment|/// \brief Matches any argument of a call expression or a constructor call
comment|/// expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void x(int, int, int) { int y; x(1, y, 42); }
comment|/// \endcode
comment|/// callExpr(hasAnyArgument(declRefExpr()))
comment|///   matches x(1, y, 42)
comment|/// with hasAnyArgument(...)
comment|///   matching y
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasAnyArgument
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|CallExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|||
name|llvm
operator|::
name|is_base_of
operator|<
name|CXXConstructExpr
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|instantiated_with_wrong_types
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getArg
argument_list|(
name|I
argument_list|)
operator|->
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the n'th parameter of a function declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { void f(int x) {} };
comment|/// \endcode
comment|/// methodDecl(hasParameter(0, hasType(varDecl())))
comment|///   matches f(int x) {}
comment|/// with hasParameter(...)
comment|///   matching int x
name|AST_MATCHER_P2
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasParameter
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumParams
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getParamDecl
argument_list|(
name|N
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches any parameter of a function declaration.
comment|///
comment|/// Does not match the 'this' parameter of a method.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { void f(int x, int y, int z) {} };
comment|/// \endcode
comment|/// methodDecl(hasAnyParameter(hasName("y")))
comment|///   matches f(int x, int y, int z) {}
comment|/// with hasAnyParameter(...)
comment|///   matching int y
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasAnyParameter
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Node
operator|.
name|getNumParams
argument_list|()
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getParamDecl
argument_list|(
name|I
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the return type of a function declaration.
comment|///
comment|/// Given:
comment|/// \code
comment|///   class X { int f() { return 1; } };
comment|/// \endcode
comment|/// methodDecl(returns(asString("int")))
comment|///   matches int f() { return 1; }
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|returns
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getResultType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches extern "C" function declarations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   extern "C" void f() {}
comment|///   extern "C" { void g() {} }
comment|///   void h() {}
comment|/// \endcode
comment|/// functionDecl(isExternC())
comment|///   matches the declaration of f and g, but not the declaration h
name|AST_MATCHER
argument_list|(
argument|FunctionDecl
argument_list|,
argument|isExternC
argument_list|)
block|{
return|return
name|Node
operator|.
name|isExternC
argument_list|()
return|;
block|}
comment|/// \brief Matches the condition expression of an if statement, for loop,
comment|/// or conditional operator.
comment|///
comment|/// Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
comment|/// \code
comment|///   if (true) {}
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasCondition
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|IfStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ForStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|WhileStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|DoStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ConditionalOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_condition_requires_if_statement_conditional_operator_or_loop
argument_list|)
expr_stmt|;
specifier|const
name|Expr
modifier|*
specifier|const
name|Condition
init|=
name|Node
operator|.
name|getCond
argument_list|()
decl_stmt|;
return|return
operator|(
name|Condition
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Condition
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the condition variable statement in an if statement.
comment|///
comment|/// Given
comment|/// \code
comment|///   if (A* a = GetAPointer()) {}
comment|/// \endcode
comment|/// hasConditionVariableStatment(...)
comment|///   matches 'A* a = GetAPointer()'.
name|AST_MATCHER_P
argument_list|(
argument|IfStmt
argument_list|,
argument|hasConditionVariableStatement
argument_list|,
argument|internal::Matcher<DeclStmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|DeclStmt
modifier|*
specifier|const
name|DeclarationStatement
init|=
name|Node
operator|.
name|getConditionVariableDeclStmt
argument_list|()
decl_stmt|;
return|return
name|DeclarationStatement
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclarationStatement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the index expression of an array subscript expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// \endcode
comment|/// arraySubscriptExpression(hasIndex(integerLiteral()))
comment|///   matches \c i[1] with the \c integerLiteral() matching \c 1
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasIndex
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getIdx
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches the base expression of an array subscript expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// \endcode
comment|/// arraySubscriptExpression(hasBase(implicitCastExpr(
comment|///     hasSourceExpression(declRefExpr()))))
comment|///   matches \c i[1] with the \c declRefExpr() matching \c i
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasBase
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getBase
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a 'for', 'while', or 'do while' statement that has
comment|/// a given body.
comment|///
comment|/// Given
comment|/// \code
comment|///   for (;;) {}
comment|/// \endcode
comment|/// hasBody(compoundStmt())
comment|///   matches 'for (;;) {}'
comment|/// with compoundStmt()
comment|///   matching '{}'
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasBody
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|DoStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|ForStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|WhileStmt
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_body_requires_for_while_or_do_statement
argument_list|)
expr_stmt|;
specifier|const
name|Stmt
modifier|*
specifier|const
name|Statement
init|=
name|Node
operator|.
name|getBody
argument_list|()
decl_stmt|;
return|return
operator|(
name|Statement
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Statement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches compound statements where at least one substatement matches
comment|/// a given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   { {}; 1+2; }
comment|/// \endcode
comment|/// hasAnySubstatement(compoundStmt())
comment|///   matches '{ {}; 1+2; }'
comment|/// with compoundStmt()
comment|///   matching '{}'
name|AST_MATCHER_P
argument_list|(
argument|CompoundStmt
argument_list|,
argument|hasAnySubstatement
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|CompoundStmt
operator|::
name|const_body_iterator
name|It
operator|=
name|Node
operator|.
name|body_begin
argument_list|()
init|;
name|It
operator|!=
name|Node
operator|.
name|body_end
argument_list|()
condition|;
operator|++
name|It
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|It
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Checks that a compound statement contains a specific number of
comment|/// child statements.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   { for (;;) {} }
comment|/// \endcode
comment|/// compoundStmt(statementCountIs(0)))
comment|///   matches '{}'
comment|///   but does not match the outer compound statement.
name|AST_MATCHER_P
argument_list|(
argument|CompoundStmt
argument_list|,
argument|statementCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|size
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches literals that are equal to the given value.
comment|///
comment|/// Example matches true (matcher = boolLiteral(equals(true)))
comment|/// \code
comment|///   true
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteral>,
comment|///            Matcher<FloatingLiteral>, Matcher<IntegerLiteral>
name|template
operator|<
name|typename
name|ValueT
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
name|equals
argument_list|(
argument|const ValueT&Value
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
operator|(
name|Value
operator|)
return|;
block|}
comment|/// \brief Matches the operator Name of operator expressions (binary or
comment|/// unary).
comment|///
comment|/// Example matches a || b (matcher = binaryOperator(hasOperatorName("||")))
comment|/// \code
comment|///   !(a || b)
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasOperatorName
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
name|TOOLING_COMPILE_ASSERT
argument_list|(
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|BinaryOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
operator|||
operator|(
name|llvm
operator|::
name|is_base_of
operator|<
name|UnaryOperator
operator|,
name|NodeType
operator|>
operator|::
name|value
operator|)
argument_list|,
name|has_condition_requires_if_statement_or_conditional_operator
argument_list|)
expr_stmt|;
return|return
name|Name
operator|==
name|Node
operator|.
name|getOpcodeStr
argument_list|(
name|Node
operator|.
name|getOpcode
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Matches the left hand side of binary operator expressions.
comment|///
comment|/// Example matches a (matcher = binaryOperator(hasLHS()))
comment|/// \code
comment|///   a || b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|BinaryOperator
argument_list|,
argument|hasLHS
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|LeftHandSide
init|=
name|Node
operator|.
name|getLHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|LeftHandSide
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|LeftHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the right hand side of binary operator expressions.
comment|///
comment|/// Example matches b (matcher = binaryOperator(hasRHS()))
comment|/// \code
comment|///   a || b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|BinaryOperator
argument_list|,
argument|hasRHS
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|RightHandSide
init|=
name|Node
operator|.
name|getRHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|RightHandSide
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|RightHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if either the left hand side or the right hand side of a
comment|/// binary operator matches.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|BinaryOperator
operator|>
name|hasEitherOperand
argument_list|(
argument|const internal::Matcher<Expr>&InnerMatcher
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|hasLHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasRHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the operand of a unary operator matches.
comment|///
comment|/// Example matches true (matcher = hasUnaryOperand(boolLiteral(equals(true))))
comment|/// \code
comment|///   !true
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|UnaryOperator
argument_list|,
argument|hasUnaryOperand
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|Operand
init|=
name|Node
operator|.
name|getSubExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Operand
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Operand
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the cast's source expression matches the given matcher.
comment|///
comment|/// Example: matches "a string" (matcher =
comment|///                                  hasSourceExpression(constructExpr()))
comment|/// \code
comment|/// class URL { URL(string); };
comment|/// URL url = "a string";
name|AST_MATCHER_P
argument_list|(
argument|CastExpr
argument_list|,
argument|hasSourceExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|SubExpression
init|=
name|Node
operator|.
name|getSubExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|SubExpression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|SubExpression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches casts whose destination type matches a given matcher.
comment|///
comment|/// (Note: Clang's AST refers to other conversions as "casts" too, and calls
comment|/// actual casts "explicit" casts.)
name|AST_MATCHER_P
argument_list|(
argument|ExplicitCastExpr
argument_list|,
argument|hasDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|NodeType
init|=
name|Node
operator|.
name|getTypeAsWritten
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|NodeType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches implicit casts whose destination type matches a given
comment|/// matcher.
comment|///
comment|/// FIXME: Unit test this matcher
name|AST_MATCHER_P
argument_list|(
argument|ImplicitCastExpr
argument_list|,
argument|hasImplicitDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the true branch expression of a conditional operator.
comment|///
comment|/// Example matches a
comment|/// \code
comment|///   condition ? a : b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ConditionalOperator
argument_list|,
argument|hasTrueExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getTrueExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the false branch expression of a conditional operator.
comment|///
comment|/// Example matches b
comment|/// \code
comment|///   condition ? a : b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ConditionalOperator
argument_list|,
argument|hasFalseExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getFalseExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if a declaration has a body attached.
comment|///
comment|/// Example matches A, va, fa
comment|/// \code
comment|///   class A {};
comment|///   class B;  // Doesn't match, as it has no body.
comment|///   int va;
comment|///   extern int vb;  // Doesn't match, as it doesn't define the variable.
comment|///   void fa() {}
comment|///   void fb();  // Doesn't match, as it has no body.
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsDefinitionMatcher
operator|>
name|isDefinition
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsDefinitionMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches the class declaration that the given method declaration
comment|/// belongs to.
comment|///
comment|/// FIXME: Generalize this for other kinds of declarations.
comment|/// FIXME: What other kind of declarations would we need to generalize
comment|/// this to?
comment|///
comment|/// Example matches A() in the last line
comment|///     (matcher = constructExpr(hasDeclaration(methodDecl(
comment|///         ofClass(hasName("A"))))))
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     A();
comment|///   };
comment|///   A a = A();
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|ofClass
argument_list|,
argument|internal::Matcher<CXXRecordDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|CXXRecordDecl
modifier|*
name|Parent
init|=
name|Node
operator|.
name|getParent
argument_list|()
decl_stmt|;
return|return
operator|(
name|Parent
operator|!=
name|NULL
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Parent
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches member expressions that are called with '->' as opposed
comment|/// to '.'.
comment|///
comment|/// Member calls on the implicit this pointer match as called with '->'.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a;
comment|///     static int b;
comment|///   };
comment|/// \endcode
comment|/// memberExpr(isArrow())
comment|///   matches this->x, x, y.x, a, this->b
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|MemberExpr
operator|>
name|isArrow
argument_list|()
block|{
return|return
name|makeMatcher
argument_list|(
argument|new internal::IsArrowMatcher()
argument_list|)
return|;
block|}
comment|/// \brief Matches QualType nodes that are of integer type.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(long);
comment|///   void c(double);
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isInteger())))
comment|/// matches "a(int)", "b(long)", but not "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isInteger
argument_list|)
block|{
return|return
name|Node
operator|->
name|isIntegerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are const-qualified, i.e., that
comment|/// include "top-level" const.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(int const);
comment|///   void c(const int);
comment|///   void d(const int*);
comment|///   void e(int const) {};
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isConstQualified())))
comment|///   matches "void b(int const)", "void c(const int)" and
comment|///   "void e(int const) {}". It does not match d as there
comment|///   is no top-level const on the parameter type "const int *".
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|isConstQualified
argument_list|()
block|{
return|return
name|makeMatcher
argument_list|(
argument|new internal::IsConstQualifiedMatcher()
argument_list|)
return|;
block|}
comment|/// \brief Matches a member expression where the member is matched by a
comment|/// given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct { int first, second; } first, second;
comment|///   int i(second.first);
comment|///   int j(first.second);
comment|/// \endcode
comment|/// memberExpr(member(hasName("first")))
comment|///   matches second.first
comment|///   but not first.second (because the member name there is "second").
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|member
argument_list|,
argument|internal::Matcher<ValueDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getMemberDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a member expression where the object expression is
comment|/// matched by a given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct X { int m; };
comment|///   void f(X x) { x.m; m; }
comment|/// \endcode
comment|/// memberExpr(hasObjectExpression(hasType(recordDecl(hasName("X")))))))
comment|///   matches "x.m" and "m"
comment|/// with hasObjectExpression(...)
comment|///   matching "x" and the implicit object expression of "m" which has type X*.
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|hasObjectExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getBase
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches any using shadow declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { void b(); }
comment|///   using X::b;
comment|/// \endcode
comment|/// usingDecl(hasAnyUsingShadowDecl(hasName("b"))))
comment|///   matches \code using X::b \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingDecl
argument_list|,
argument|hasAnyUsingShadowDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|II
operator|=
name|Node
operator|.
name|shadow_begin
argument_list|()
init|;
name|II
operator|!=
name|Node
operator|.
name|shadow_end
argument_list|()
condition|;
operator|++
name|II
control|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|II
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a using shadow declaration where the target declaration is
comment|/// matched by the given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { int a; void b(); }
comment|///   using X::a;
comment|///   using X::b;
comment|/// \endcode
comment|/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))
comment|///   matches \code using X::b \endcode
comment|///   but not \code using X::a \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingShadowDecl
argument_list|,
argument|hasTargetDecl
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getTargetDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches template instantiations of function, class, or static
comment|/// member variable template instantiations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class X {}; class A {}; X<A> x;
comment|/// \endcode
comment|/// or
comment|/// \code
comment|///   template<typename T> class X {}; class A {}; template class X<A>;
comment|/// \endcode
comment|/// recordDecl(hasName("::X"), isTemplateInstantiation())
comment|///   matches the template instantiation of X<A>.
comment|///
comment|/// But given
comment|/// \code
comment|///   template<typename T>  class X {}; class A {};
comment|///   template<> class X<A> {}; X<A> x;
comment|/// \endcode
comment|/// recordDecl(hasName("::X"), isTemplateInstantiation())
comment|///   does not match, as X<A> is an explicit template specialization.
comment|///
comment|/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsTemplateInstantiationMatcher
operator|>
name|isTemplateInstantiation
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsTemplateInstantiationMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches explicit template specializations of function, class, or
comment|/// static member variable template instantiations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> void A(T t) { }
comment|///   template<> void A(int N) { }
comment|/// \endcode
comment|/// functionDecl(isExplicitTemplateSpecialization())
comment|///   matches the specialization A<int>().
comment|///
comment|/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsExplicitTemplateSpecializationMatcher
operator|>
name|isExplicitTemplateSpecialization
argument_list|()
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam0
operator|<
name|internal
operator|::
name|IsExplicitTemplateSpecializationMatcher
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches \c TypeLocs for which the given inner
comment|/// QualType-matcher matches.
specifier|inline
name|internal
operator|::
name|BindableMatcher
operator|<
name|TypeLoc
operator|>
name|loc
argument_list|(
argument|const internal::Matcher<QualType>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|BindableMatcher
operator|<
name|TypeLoc
operator|>
operator|(
name|new
name|internal
operator|::
name|TypeLocTypeMatcher
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches builtin Types.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A {};
comment|///   A a;
comment|///   int b;
comment|///   float c;
comment|///   bool d;
comment|/// \endcode
comment|/// builtinType()
comment|///   matches "int b", "float c" and "bool d"
name|AST_TYPE_MATCHER
argument_list|(
name|BuiltinType
argument_list|,
name|builtinType
argument_list|)
expr_stmt|;
comment|/// \brief Matches all kinds of arrays.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 2, 3 };
comment|///   int b[4];
comment|///   void f() { int c[a[0]]; }
comment|/// \endcode
comment|/// arrayType()
comment|///   matches "int a[]", "int b[4]" and "int c[a[0]]";
name|AST_TYPE_MATCHER
argument_list|(
name|ArrayType
argument_list|,
name|arrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C99 complex types.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Complex float f;
comment|/// \endcode
comment|/// complexType()
comment|///   matches "_Complex float f"
name|AST_TYPE_MATCHER
argument_list|(
name|ComplexType
argument_list|,
name|complexType
argument_list|)
expr_stmt|;
comment|/// \brief Matches arrays and C99 complex types that have a specific element
comment|/// type.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A {};
comment|///   A a[7];
comment|///   int b[7];
comment|/// \endcode
comment|/// arrayType(hasElementType(builtinType()))
comment|///   matches "int b[7]"
comment|///
comment|/// Usable as: Matcher<ArrayType>, Matcher<ComplexType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|hasElementType
argument_list|,
name|getElement
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with a specified constant size.
comment|///
comment|/// Given
comment|/// \code
comment|///   void() {
comment|///     int a[2];
comment|///     int b[] = { 2, 3 };
comment|///     int c[b[0]];
comment|///   }
comment|/// \endcode
comment|/// constantArrayType()
comment|///   matches "int a[2]"
name|AST_TYPE_MATCHER
argument_list|(
name|ConstantArrayType
argument_list|,
name|constantArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c ConstantArrayType nodes that have the specified size.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[42];
comment|///   int b[2 * 21];
comment|///   int c[41], d[43];
comment|/// \endcode
comment|/// constantArrayType(hasSize(42))
comment|///   matches "int a[42]" and "int b[2 * 21]"
name|AST_MATCHER_P
argument_list|(
argument|ConstantArrayType
argument_list|,
argument|hasSize
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|getSize
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches C++ arrays whose size is a value-dependent expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, int Size>
comment|///   class array {
comment|///     T data[Size];
comment|///   };
comment|/// \endcode
comment|/// dependentSizedArrayType
comment|///   matches "T data[Size]"
name|AST_TYPE_MATCHER
argument_list|(
name|DependentSizedArrayType
argument_list|,
name|dependentSizedArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with unspecified size.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 2, 3 };
comment|///   int b[42];
comment|///   void f(int c[]) { int d[a[0]]; };
comment|/// \endcode
comment|/// incompleteArrayType()
comment|///   matches "int a[]" and "int c[]"
name|AST_TYPE_MATCHER
argument_list|(
name|IncompleteArrayType
argument_list|,
name|incompleteArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with a specified size that is not an
comment|/// integer-constant-expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f() {
comment|///     int a[] = { 2, 3 }
comment|///     int b[42];
comment|///     int c[a[0]];
comment|/// \endcode
comment|/// variableArrayType()
comment|///   matches "int c[a[0]]"
name|AST_TYPE_MATCHER
argument_list|(
name|VariableArrayType
argument_list|,
name|variableArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c VariableArrayType nodes that have a specific size
comment|/// expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f(int b) {
comment|///     int a[b];
comment|///   }
comment|/// \endcode
comment|/// variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(
comment|///   varDecl(hasName("b")))))))
comment|///   matches "int a[b]"
name|AST_MATCHER_P
argument_list|(
argument|VariableArrayType
argument_list|,
argument|hasSizeExpr
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getSizeExpr
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches atomic types.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Atomic(int) i;
comment|/// \endcode
comment|/// atomicType()
comment|///   matches "_Atomic(int) i"
name|AST_TYPE_MATCHER
argument_list|(
name|AtomicType
argument_list|,
name|atomicType
argument_list|)
expr_stmt|;
comment|/// \brief Matches atomic types with a specific value type.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Atomic(int) i;
comment|///   _Atomic(float) f;
comment|/// \endcode
comment|/// atomicType(hasValueType(isInteger()))
comment|///  matches "_Atomic(int) i"
comment|///
comment|/// Usable as: Matcher<AtomicType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|hasValueType
argument_list|,
name|getValue
argument_list|)
expr_stmt|;
comment|/// \brief Matches types nodes representing C++11 auto types.
comment|///
comment|/// Given:
comment|/// \code
comment|///   auto n = 4;
comment|///   int v[] = { 2, 3 }
comment|///   for (auto i : v) { }
comment|/// \endcode
comment|/// autoType()
comment|///   matches "auto n" and "auto i"
name|AST_TYPE_MATCHER
argument_list|(
name|AutoType
argument_list|,
name|autoType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c AutoType nodes where the deduced type is a specific type.
comment|///
comment|/// Note: There is no \c TypeLoc for the deduced type and thus no
comment|/// \c getDeducedLoc() matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   auto a = 1;
comment|///   auto b = 2.0;
comment|/// \endcode
comment|/// autoType(hasDeducedType(isInteger()))
comment|///   matches "auto a"
comment|///
comment|/// Usable as: Matcher<AutoType>
name|AST_TYPE_TRAVERSE_MATCHER
argument_list|(
name|hasDeducedType
argument_list|,
name|getDeducedType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c FunctionType nodes.
comment|///
comment|/// Given
comment|/// \code
comment|///   int (*f)(int);
comment|///   void g();
comment|/// \endcode
comment|/// functionType()
comment|///   matches "int (*f)(int)" and the type of "g".
name|AST_TYPE_MATCHER
argument_list|(
name|FunctionType
argument_list|,
name|functionType
argument_list|)
expr_stmt|;
comment|/// \brief Matches block pointer types, i.e. types syntactically represented as
comment|/// "void (^)(int)".
comment|///
comment|/// The \c pointee is always required to be a \c FunctionType.
name|AST_TYPE_MATCHER
argument_list|(
name|BlockPointerType
argument_list|,
name|blockPointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches member pointer types.
comment|/// Given
comment|/// \code
comment|///   struct A { int i; }
comment|///   A::* ptr = A::i;
comment|/// \endcode
comment|/// memberPointerType()
comment|///   matches "A::* ptr"
name|AST_TYPE_MATCHER
argument_list|(
name|MemberPointerType
argument_list|,
name|memberPointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches pointer types.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int c = 5;
comment|/// \endcode
comment|/// pointerType()
comment|///   matches "int *a"
name|AST_TYPE_MATCHER
argument_list|(
name|PointerType
argument_list|,
name|pointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches reference types.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int c = 5;
comment|/// \endcode
comment|/// pointerType()
comment|///   matches "int&b"
name|AST_TYPE_MATCHER
argument_list|(
name|ReferenceType
argument_list|,
name|referenceType
argument_list|)
expr_stmt|;
comment|/// \brief Narrows PointerType (and similar) matchers to those where the
comment|/// \c pointee matches a given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int const *b;
comment|///   float const *f;
comment|/// \endcode
comment|/// pointerType(pointee(isConstQualified(), isInteger()))
comment|///   matches "int const *b"
comment|///
comment|/// Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,
comment|///   Matcher<PointerType>, Matcher<ReferenceType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|pointee
argument_list|,
name|getPointee
argument_list|)
expr_stmt|;
comment|/// \brief Matches typedef types.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef int X;
comment|/// \endcode
comment|/// typedefType()
comment|///   matches "typedef int X"
name|AST_TYPE_MATCHER
argument_list|(
name|TypedefType
argument_list|,
name|typedefType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c TypedefTypes referring to a specific
comment|/// \c TypedefNameDecl.
name|AST_MATCHER_P
argument_list|(
argument|TypedefType
argument_list|,
argument|hasDecl
argument_list|,
argument|internal::Matcher<TypedefNameDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifiers.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace ns {
comment|///     struct A { static void f(); };
comment|///     void A::f() {}
comment|///     void g() { A::f(); }
comment|///   }
comment|///   ns::A a;
comment|/// \endcode
comment|/// nestedNameSpecifier()
comment|///   matches "ns::" and both "A::"
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|NestedNameSpecifier
operator|>
name|nestedNameSpecifier
expr_stmt|;
comment|/// \brief Same as \c nestedNameSpecifier but matches \c NestedNameSpecifierLoc.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|nestedNameSpecifierLoc
expr_stmt|;
comment|/// \brief Matches \c NestedNameSpecifierLocs for which the given inner
comment|/// NestedNameSpecifier-matcher matches.
specifier|inline
name|internal
operator|::
name|BindableMatcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|loc
argument_list|(
argument|const internal::Matcher<NestedNameSpecifier>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|BindableMatcher
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
name|new
name|internal
operator|::
name|LocMatcher
operator|<
name|NestedNameSpecifierLoc
operator|,
name|NestedNameSpecifier
operator|>
operator|(
name|InnerMatcher
operator|)
operator|)
return|;
block|}
comment|/// \brief Matches nested name specifiers that specify a type matching the
comment|/// given \c QualType matcher without qualifiers.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifier(specifiesType(hasDeclaration(recordDecl(hasName("A")))))
comment|///   matches "A::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifier
argument_list|,
argument|specifiesType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getAsType
argument_list|()
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|QualType
argument_list|(
name|Node
operator|.
name|getAsType
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifier locs that specify a type matching the
comment|/// given \c TypeLoc.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(
comment|///   hasDeclaration(recordDecl(hasName("A")))))))
comment|///   matches "A::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifierLoc
argument_list|,
argument|specifiesTypeLoc
argument_list|,
argument|internal::Matcher<TypeLoc>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getTypeLoc
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches on the prefix of a \c NestedNameSpecifier.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifier(hasPrefix(specifiesType(asString("struct A")))) and
comment|///   matches "A::"
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifier
operator|>
name|hasPrefix
argument_list|(
argument|const internal::Matcher<NestedNameSpecifier>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|makeMatcher
argument_list|(
argument|new internal::NestedNameSpecifierPrefixMatcher(InnerMatcher)
argument_list|)
return|;
block|}
comment|/// \brief Matches on the prefix of a \c NestedNameSpecifierLoc.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString("struct A")))))
comment|///   matches "A::"
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|hasPrefix
argument_list|(
argument|const internal::Matcher<NestedNameSpecifierLoc>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|makeMatcher
argument_list|(
argument|new internal::NestedNameSpecifierLocPrefixMatcher(InnerMatcher)
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifiers that specify a namespace matching the
comment|/// given namespace matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace ns { struct A {}; }
comment|///   ns::A a;
comment|/// \endcode
comment|/// nestedNameSpecifier(specifiesNamespace(hasName("ns")))
comment|///   matches "ns::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifier
argument_list|,
argument|specifiesNamespace
argument_list|,
argument|internal::Matcher<NamespaceDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getAsNamespace
argument_list|()
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getAsNamespace
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
block|}
comment|// end namespace ast_matchers
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
end_comment

end_unit

