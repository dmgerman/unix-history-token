begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- ASTMatchers.h - Structural query framework -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file implements matchers to be used together with the MatchFinder to
end_comment

begin_comment
comment|//  match AST nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Matchers are created by generator functions, which can be combined in
end_comment

begin_comment
comment|//  a functional in-language DSL to express queries over the C++ AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, to match a class with a certain name, one would call:
end_comment

begin_comment
comment|//    cxxRecordDecl(hasName("MyClass"))
end_comment

begin_comment
comment|//  which returns a matcher that can be used to find all AST nodes that declare
end_comment

begin_comment
comment|//  a class named 'MyClass'.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For more complicated match expressions we're often interested in accessing
end_comment

begin_comment
comment|//  multiple parts of the matched AST nodes once a match is found. In that case,
end_comment

begin_comment
comment|//  use the id(...) matcher around the match expressions that match the nodes
end_comment

begin_comment
comment|//  you want to access.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  For example, when we're interested in child classes of a certain class, we
end_comment

begin_comment
comment|//  would write:
end_comment

begin_comment
comment|//    cxxRecordDecl(hasName("MyClass"), hasChild(id("child", recordDecl())))
end_comment

begin_comment
comment|//  When the match is found via the MatchFinder, a user provided callback will
end_comment

begin_comment
comment|//  be called with a BoundNodes instance that contains a mapping from the
end_comment

begin_comment
comment|//  strings that we provided for the id(...) calls to the nodes that were
end_comment

begin_comment
comment|//  matched.
end_comment

begin_comment
comment|//  In the given example, each time our matcher finds a match we get a callback
end_comment

begin_comment
comment|//  where "child" is bound to the RecordDecl node of the matching child
end_comment

begin_comment
comment|//  class declaration.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchersInternal.h for a more in-depth explanation of the
end_comment

begin_comment
comment|//  implementation details of the matcher framework.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  See ASTMatchFinder.h for how to use the generated matchers to run over
end_comment

begin_comment
comment|//  an AST.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclFriend.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/DeclTemplate.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersInternal.h"
end_include

begin_include
include|#
directive|include
file|"clang/ASTMatchers/ASTMatchersMacros.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Regex.h"
end_include

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|ast_matchers
block|{
comment|/// \brief Maps string IDs to AST nodes matched by parts of a matcher.
comment|///
comment|/// The bound nodes are generated by calling \c bind("id") on the node matchers
comment|/// of the nodes we want to access later.
comment|///
comment|/// The instances of BoundNodes are created by \c MatchFinder when the user's
comment|/// callbacks are executed every time a match is found.
name|class
name|BoundNodes
block|{
name|public
label|:
comment|/// \brief Returns the AST node bound to \c ID.
comment|///
comment|/// Returns NULL if there was no node bound to \c ID or if there is a node but
comment|/// it cannot be converted to the specified type.
name|template
operator|<
name|typename
name|T
operator|>
specifier|const
name|T
operator|*
name|getNodeAs
argument_list|(
argument|StringRef ID
argument_list|)
specifier|const
block|{
return|return
name|MyBoundNodes
operator|.
name|getNodeAs
operator|<
name|T
operator|>
operator|(
name|ID
operator|)
return|;
block|}
comment|/// \brief Type of mapping from binding identifiers to bound nodes. This type
comment|/// is an associative container with a key type of \c std::string and a value
comment|/// type of \c clang::ast_type_traits::DynTypedNode
typedef|typedef
name|internal
operator|::
name|BoundNodesMap
operator|::
name|IDToNodeMap
name|IDToNodeMap
expr_stmt|;
comment|/// \brief Retrieve mapping from binding identifiers to bound nodes.
specifier|const
name|IDToNodeMap
operator|&
name|getMap
argument_list|()
specifier|const
block|{
return|return
name|MyBoundNodes
operator|.
name|getMap
argument_list|()
return|;
block|}
name|private
label|:
comment|/// \brief Create BoundNodes from a pre-filled map of bindings.
name|BoundNodes
argument_list|(
name|internal
operator|::
name|BoundNodesMap
operator|&
name|MyBoundNodes
argument_list|)
operator|:
name|MyBoundNodes
argument_list|(
argument|MyBoundNodes
argument_list|)
block|{}
name|internal
operator|::
name|BoundNodesMap
name|MyBoundNodes
expr_stmt|;
name|friend
name|class
name|internal
operator|::
name|BoundNodesTreeBuilder
expr_stmt|;
block|}
empty_stmt|;
comment|/// \brief If the provided matcher matches a node, binds the node to \c ID.
comment|///
comment|/// FIXME: Do we want to support this now that we have bind()?
name|template
operator|<
name|typename
name|T
operator|>
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|id
argument_list|(
argument|StringRef ID
argument_list|,
argument|const internal::BindableMatcher<T>&InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|bind
argument_list|(
name|ID
argument_list|)
return|;
block|}
comment|/// \brief Types of matchers for the top-level classes in the AST class
comment|/// hierarchy.
comment|/// @{
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
name|DeclarationMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|StatementMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|QualType
operator|>
name|TypeMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|TypeLoc
operator|>
name|TypeLocMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifier
operator|>
name|NestedNameSpecifierMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|NestedNameSpecifierLocMatcher
expr_stmt|;
typedef|typedef
name|internal
operator|::
name|Matcher
operator|<
name|CXXCtorInitializer
operator|>
name|CXXCtorInitializerMatcher
expr_stmt|;
comment|/// @}
comment|/// \brief Matches any node.
comment|///
comment|/// Useful when another matcher requires a child matcher, but there's no
comment|/// additional constraint. This will often be used with an explicit conversion
comment|/// to an \c internal::Matcher<> type such as \c TypeMatcher.
comment|///
comment|/// Example: \c DeclarationMatcher(anything()) matches all declarations, e.g.,
comment|/// \code
comment|/// "int* p" and "void f()" in
comment|///   int* p;
comment|///   void f();
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
specifier|inline
name|internal
operator|::
name|TrueMatcher
name|anything
argument_list|()
block|{
return|return
name|internal
operator|::
name|TrueMatcher
argument_list|()
return|;
block|}
comment|/// \brief Matches the top declaration context.
comment|///
comment|/// Given
comment|/// \code
comment|///   int X;
comment|///   namespace NS {
comment|///   int Y;
comment|///   }  // namespace NS
comment|/// \endcode
comment|/// decl(hasDeclContext(translationUnitDecl()))
comment|///   matches "int X", but not "int Y".
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TranslationUnitDecl
operator|>
name|translationUnitDecl
expr_stmt|;
comment|/// \brief Matches typedef declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef int X;
comment|///   using Y = int;
comment|/// \endcode
comment|/// typedefDecl()
comment|///   matches "typedef int X", but not "using Y = int"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TypedefDecl
operator|>
name|typedefDecl
expr_stmt|;
comment|/// \brief Matches typedef name declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef int X;
comment|///   using Y = int;
comment|/// \endcode
comment|/// typedefNameDecl()
comment|///   matches "typedef int X" and "using Y = int"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TypedefNameDecl
operator|>
name|typedefNameDecl
expr_stmt|;
comment|/// \brief Matches type alias declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef int X;
comment|///   using Y = int;
comment|/// \endcode
comment|/// typeAliasDecl()
comment|///   matches "using Y = int", but not "typedef int X"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TypeAliasDecl
operator|>
name|typeAliasDecl
expr_stmt|;
comment|/// \brief Matches type alias template declarations.
comment|///
comment|/// typeAliasTemplateDecl() matches
comment|/// \code
comment|///   template<typename T>
comment|///   using Y = X<T>;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TypeAliasTemplateDecl
operator|>
name|typeAliasTemplateDecl
expr_stmt|;
comment|/// \brief Matches AST nodes that were expanded within the main-file.
comment|///
comment|/// Example matches X but not Y
comment|///   (matcher = cxxRecordDecl(isExpansionInMainFile())
comment|/// \code
comment|///   #include<Y.h>
comment|///   class X {};
comment|/// \endcode
comment|/// Y.h:
comment|/// \code
comment|///   class Y {};
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isExpansionInMainFile
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)
argument_list|)
block|{
name|auto
operator|&
name|SourceManager
operator|=
name|Finder
operator|->
name|getASTContext
argument_list|()
operator|.
name|getSourceManager
argument_list|()
expr_stmt|;
return|return
name|SourceManager
operator|.
name|isInMainFile
argument_list|(
name|SourceManager
operator|.
name|getExpansionLoc
argument_list|(
name|Node
operator|.
name|getLocStart
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches AST nodes that were expanded within system-header-files.
comment|///
comment|/// Example matches Y but not X
comment|///     (matcher = cxxRecordDecl(isExpansionInSystemHeader())
comment|/// \code
comment|///   #include<SystemHeader.h>
comment|///   class X {};
comment|/// \endcode
comment|/// SystemHeader.h:
comment|/// \code
comment|///   class Y {};
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isExpansionInSystemHeader
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)
argument_list|)
block|{
name|auto
operator|&
name|SourceManager
operator|=
name|Finder
operator|->
name|getASTContext
argument_list|()
operator|.
name|getSourceManager
argument_list|()
expr_stmt|;
name|auto
name|ExpansionLoc
init|=
name|SourceManager
operator|.
name|getExpansionLoc
argument_list|(
name|Node
operator|.
name|getLocStart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ExpansionLoc
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|SourceManager
operator|.
name|isInSystemHeader
argument_list|(
name|ExpansionLoc
argument_list|)
return|;
block|}
comment|/// \brief Matches AST nodes that were expanded within files whose name is
comment|/// partially matching a given regex.
comment|///
comment|/// Example matches Y but not X
comment|///     (matcher = cxxRecordDecl(isExpansionInFileMatching("AST.*"))
comment|/// \code
comment|///   #include "ASTMatcher.h"
comment|///   class X {};
comment|/// \endcode
comment|/// ASTMatcher.h:
comment|/// \code
comment|///   class Y {};
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|isExpansionInFileMatching
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)
argument_list|,
argument|std::string
argument_list|,
argument|RegExp
argument_list|)
block|{
name|auto
operator|&
name|SourceManager
operator|=
name|Finder
operator|->
name|getASTContext
argument_list|()
operator|.
name|getSourceManager
argument_list|()
expr_stmt|;
name|auto
name|ExpansionLoc
init|=
name|SourceManager
operator|.
name|getExpansionLoc
argument_list|(
name|Node
operator|.
name|getLocStart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ExpansionLoc
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
return|return
name|false
return|;
block|}
name|auto
name|FileEntry
init|=
name|SourceManager
operator|.
name|getFileEntryForID
argument_list|(
name|SourceManager
operator|.
name|getFileID
argument_list|(
name|ExpansionLoc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|FileEntry
condition|)
block|{
return|return
name|false
return|;
block|}
name|auto
name|Filename
init|=
name|FileEntry
operator|->
name|getName
argument_list|()
decl_stmt|;
name|llvm
operator|::
name|Regex
name|RE
argument_list|(
name|RegExp
argument_list|)
expr_stmt|;
return|return
name|RE
operator|.
name|match
argument_list|(
name|Filename
argument_list|)
return|;
block|}
comment|/// \brief Matches declarations.
comment|///
comment|/// Examples matches \c X, \c C, and the friend declaration inside \c C;
comment|/// \code
comment|///   void X();
comment|///   class C {
comment|///     friend X;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|Decl
operator|>
name|decl
expr_stmt|;
comment|/// \brief Matches a declaration of a linkage specification.
comment|///
comment|/// Given
comment|/// \code
comment|///   extern "C" {}
comment|/// \endcode
comment|/// linkageSpecDecl()
comment|///   matches "extern "C" {}"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|LinkageSpecDecl
operator|>
name|linkageSpecDecl
expr_stmt|;
comment|/// \brief Matches a declaration of anything that could have a name.
comment|///
comment|/// Example matches \c X, \c S, the anonymous union type, \c i, and \c U;
comment|/// \code
comment|///   typedef int X;
comment|///   struct S {
comment|///     union {
comment|///       int i;
comment|///     } U;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NamedDecl
operator|>
name|namedDecl
expr_stmt|;
comment|/// \brief Matches a declaration of label.
comment|///
comment|/// Given
comment|/// \code
comment|///   goto FOO;
comment|///   FOO: bar();
comment|/// \endcode
comment|/// labelDecl()
comment|///   matches 'FOO:'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|LabelDecl
operator|>
name|labelDecl
expr_stmt|;
comment|/// \brief Matches a declaration of a namespace.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace {}
comment|///   namespace test {}
comment|/// \endcode
comment|/// namespaceDecl()
comment|///   matches "namespace {}" and "namespace test {}"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NamespaceDecl
operator|>
name|namespaceDecl
expr_stmt|;
comment|/// \brief Matches a declaration of a namespace alias.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace test {}
comment|///   namespace alias = ::test;
comment|/// \endcode
comment|/// namespaceAliasDecl()
comment|///   matches "namespace alias" but not "namespace test"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NamespaceAliasDecl
operator|>
name|namespaceAliasDecl
expr_stmt|;
comment|/// \brief Matches class, struct, and union declarations.
comment|///
comment|/// Example matches \c X, \c Z, \c U, and \c S
comment|/// \code
comment|///   class X;
comment|///   template<class T> class Z {};
comment|///   struct S {};
comment|///   union U {};
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|RecordDecl
operator|>
name|recordDecl
expr_stmt|;
comment|/// \brief Matches C++ class declarations.
comment|///
comment|/// Example matches \c X, \c Z
comment|/// \code
comment|///   class X;
comment|///   template<class T> class Z {};
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXRecordDecl
operator|>
name|cxxRecordDecl
expr_stmt|;
comment|/// \brief Matches C++ class template declarations.
comment|///
comment|/// Example matches \c Z
comment|/// \code
comment|///   template<class T> class Z {};
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ClassTemplateDecl
operator|>
name|classTemplateDecl
expr_stmt|;
comment|/// \brief Matches C++ class template specializations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl()
comment|///   matches the specializations \c A<int> and \c A<double>
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ClassTemplateSpecializationDecl
operator|>
name|classTemplateSpecializationDecl
expr_stmt|;
comment|/// \brief Matches declarator declarations (field, variable, function
comment|/// and non-type template parameter declarations).
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { int y; };
comment|/// \endcode
comment|/// declaratorDecl()
comment|///   matches \c int y.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|DeclaratorDecl
operator|>
name|declaratorDecl
expr_stmt|;
comment|/// \brief Matches parameter variable declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f(int x);
comment|/// \endcode
comment|/// parmVarDecl()
comment|///   matches \c int x.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ParmVarDecl
operator|>
name|parmVarDecl
expr_stmt|;
comment|/// \brief Matches C++ access specifier declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///   public:
comment|///     int a;
comment|///   };
comment|/// \endcode
comment|/// accessSpecDecl()
comment|///   matches 'public:'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|AccessSpecDecl
operator|>
name|accessSpecDecl
expr_stmt|;
comment|/// \brief Matches constructor initializers.
comment|///
comment|/// Examples matches \c i(42).
comment|/// \code
comment|///   class C {
comment|///     C() : i(42) {}
comment|///     int i;
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|CXXCtorInitializer
operator|>
name|cxxCtorInitializer
expr_stmt|;
comment|/// \brief Matches template arguments.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> struct C {};
comment|///   C<int> c;
comment|/// \endcode
comment|/// templateArgument()
comment|///   matches 'int' in C<int>.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|TemplateArgument
operator|>
name|templateArgument
expr_stmt|;
comment|/// \brief Matches template name.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class X { };
comment|///   X<int> xi;
comment|/// \endcode
comment|/// templateName()
comment|///   matches 'X' in X<int>.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|TemplateName
operator|>
name|templateName
expr_stmt|;
comment|/// \brief Matches non-type template parameter declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, int N> struct C {};
comment|/// \endcode
comment|/// nonTypeTemplateParmDecl()
comment|///   matches 'N', but not 'T'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|NonTypeTemplateParmDecl
operator|>
name|nonTypeTemplateParmDecl
expr_stmt|;
comment|/// \brief Matches template type parameter declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, int N> struct C {};
comment|/// \endcode
comment|/// templateTypeParmDecl()
comment|///   matches 'T', but not 'N'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|TemplateTypeParmDecl
operator|>
name|templateTypeParmDecl
expr_stmt|;
comment|/// \brief Matches public C++ declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///   public:    int a;
comment|///   protected: int b;
comment|///   private:   int c;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(isPublic())
comment|///   matches 'int a;'
name|AST_MATCHER
argument_list|(
argument|Decl
argument_list|,
argument|isPublic
argument_list|)
block|{
return|return
name|Node
operator|.
name|getAccess
argument_list|()
operator|==
name|AS_public
return|;
block|}
comment|/// \brief Matches protected C++ declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///   public:    int a;
comment|///   protected: int b;
comment|///   private:   int c;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(isProtected())
comment|///   matches 'int b;'
name|AST_MATCHER
argument_list|(
argument|Decl
argument_list|,
argument|isProtected
argument_list|)
block|{
return|return
name|Node
operator|.
name|getAccess
argument_list|()
operator|==
name|AS_protected
return|;
block|}
comment|/// \brief Matches private C++ declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///   public:    int a;
comment|///   protected: int b;
comment|///   private:   int c;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(isPrivate())
comment|///   matches 'int c;'
name|AST_MATCHER
argument_list|(
argument|Decl
argument_list|,
argument|isPrivate
argument_list|)
block|{
return|return
name|Node
operator|.
name|getAccess
argument_list|()
operator|==
name|AS_private
return|;
block|}
comment|/// \brief Matches non-static data members that are bit-fields.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///     int a : 2;
comment|///     int b;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(isBitField())
comment|///   matches 'int a;' but not 'int b;'.
name|AST_MATCHER
argument_list|(
argument|FieldDecl
argument_list|,
argument|isBitField
argument_list|)
block|{
return|return
name|Node
operator|.
name|isBitField
argument_list|()
return|;
block|}
comment|/// \brief Matches non-static data members that are bit-fields of the specified
comment|/// bit width.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///     int a : 2;
comment|///     int b : 4;
comment|///     int c : 2;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(hasBitWidth(2))
comment|///   matches 'int a;' and 'int c;' but not 'int b;'.
name|AST_MATCHER_P
argument_list|(
argument|FieldDecl
argument_list|,
argument|hasBitWidth
argument_list|,
argument|unsigned
argument_list|,
argument|Width
argument_list|)
block|{
return|return
name|Node
operator|.
name|isBitField
argument_list|()
operator|&&
name|Node
operator|.
name|getBitWidthValue
argument_list|(
name|Finder
operator|->
name|getASTContext
argument_list|()
argument_list|)
operator|==
name|Width
return|;
block|}
comment|/// \brief Matches non-static data members that have an in-class initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {
comment|///     int a = 2;
comment|///     int b = 3;
comment|///     int c;
comment|///   };
comment|/// \endcode
comment|/// fieldDecl(hasInClassInitializer(integerLiteral(equals(2))))
comment|///   matches 'int a;' but not 'int b;'.
comment|/// fieldDecl(hasInClassInitializer(anything()))
comment|///   matches 'int a;' and 'int b;' but not 'int c;'.
name|AST_MATCHER_P
argument_list|(
argument|FieldDecl
argument_list|,
argument|hasInClassInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Initializer
init|=
name|Node
operator|.
name|getInClassInitializer
argument_list|()
decl_stmt|;
return|return
operator|(
name|Initializer
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Initializer
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a declaration that has been implicitly added
comment|/// by the compiler (eg. implicit default/copy constructors).
name|AST_MATCHER
argument_list|(
argument|Decl
argument_list|,
argument|isImplicit
argument_list|)
block|{
return|return
name|Node
operator|.
name|isImplicit
argument_list|()
return|;
block|}
comment|/// \brief Matches classTemplateSpecializations, templateSpecializationType and
comment|/// functionDecl that have at least one TemplateArgument matching the given
comment|/// InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class A {};
comment|///   template<> class A<double> {};
comment|///   A<int> a;
comment|///
comment|///   template<typename T> f() {};
comment|///   void func() { f<int>(); };
comment|/// \endcode
comment|///
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToType(asString("int"))))
comment|///   matches the specialization \c A<int>
comment|///
comment|/// functionDecl(hasAnyTemplateArgument(refersToType(asString("int"))))
comment|///   matches the specialization \c f<int>
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasAnyTemplateArgument
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,                                     TemplateSpecializationType,                                     FunctionDecl)
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|ArrayRef
operator|<
name|TemplateArgument
operator|>
name|List
operator|=
name|internal
operator|::
name|getTemplateSpecializationArgs
argument_list|(
name|Node
argument_list|)
expr_stmt|;
return|return
name|matchesFirstInRange
argument_list|(
name|InnerMatcher
argument_list|,
name|List
operator|.
name|begin
argument_list|()
argument_list|,
name|List
operator|.
name|end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after any implicit AST
comment|/// nodes are stripped off.
comment|///
comment|/// Parentheses and explicit casts are not discarded.
comment|/// Given
comment|/// \code
comment|///   class C {};
comment|///   C a = C();
comment|///   C b;
comment|///   C c = b;
comment|/// \endcode
comment|/// The matchers
comment|/// \code
comment|///    varDecl(hasInitializer(ignoringImplicit(cxxConstructExpr())))
comment|/// \endcode
comment|/// would match the declarations for a, b, and c.
comment|/// While
comment|/// \code
comment|///    varDecl(hasInitializer(cxxConstructExpr()))
comment|/// \endcode
comment|/// only match the declarations for b and c.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringImplicit
argument_list|,
argument|ast_matchers::internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreImplicit
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after any implicit casts
comment|/// are stripped off.
comment|///
comment|/// Parentheses and explicit casts are not discarded.
comment|/// Given
comment|/// \code
comment|///   int arr[5];
comment|///   int a = 0;
comment|///   char b = 0;
comment|///   const int c = a;
comment|///   int *d = arr;
comment|///   long e = (long) 0l;
comment|/// \endcode
comment|/// The matchers
comment|/// \code
comment|///    varDecl(hasInitializer(ignoringImpCasts(integerLiteral())))
comment|///    varDecl(hasInitializer(ignoringImpCasts(declRefExpr())))
comment|/// \endcode
comment|/// would match the declarations for a, b, c, and d, but not e.
comment|/// While
comment|/// \code
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|///    varDecl(hasInitializer(declRefExpr()))
comment|/// \endcode
comment|/// only match the declarations for b, c, and d.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringImpCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after parentheses and
comment|/// casts are stripped off.
comment|///
comment|/// Implicit and non-C Style casts are also discarded.
comment|/// Given
comment|/// \code
comment|///   int a = 0;
comment|///   char b = (0);
comment|///   void* c = reinterpret_cast<char*>(0);
comment|///   char d = char(0);
comment|/// \endcode
comment|/// The matcher
comment|///    varDecl(hasInitializer(ignoringParenCasts(integerLiteral())))
comment|/// would match the declarations for a, b, c, and d.
comment|/// while
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|/// only match the declaration for a.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringParenCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreParenCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches expressions that match InnerMatcher after implicit casts and
comment|/// parentheses are stripped off.
comment|///
comment|/// Explicit casts are not discarded.
comment|/// Given
comment|/// \code
comment|///   int arr[5];
comment|///   int a = 0;
comment|///   char b = (0);
comment|///   const int c = a;
comment|///   int *d = (arr);
comment|///   long e = ((long) 0l);
comment|/// \endcode
comment|/// The matchers
comment|///    varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral())))
comment|///    varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr())))
comment|/// would match the declarations for a, b, c, and d, but not e.
comment|/// while
comment|///    varDecl(hasInitializer(integerLiteral()))
comment|///    varDecl(hasInitializer(declRefExpr()))
comment|/// would only match the declaration for a.
name|AST_MATCHER_P
argument_list|(
argument|Expr
argument_list|,
argument|ignoringParenImpCasts
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches types that match InnerMatcher after any parens are stripped.
comment|///
comment|/// Given
comment|/// \code
comment|///   void (*fp)(void);
comment|/// \endcode
comment|/// The matcher
comment|/// \code
comment|///   varDecl(hasType(pointerType(pointee(ignoringParens(functionType())))))
comment|/// \endcode
comment|/// would match the declaration for fp.
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|ignoringParens
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|IgnoreParens
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches classTemplateSpecializations, templateSpecializationType and
comment|/// functionDecl where the n'th TemplateArgument matches the given InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, typename U> class A {};
comment|///   A<bool, int> b;
comment|///   A<int, bool> c;
comment|///
comment|///   template<typename T> f() {};
comment|///   void func() { f<int>(); };
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasTemplateArgument(
comment|///     1, refersToType(asString("int"))))
comment|///   matches the specialization \c A<bool, int>
comment|///
comment|/// functionDecl(hasTemplateArgument(0, refersToType(asString("int"))))
comment|///   matches the specialization \c f<int>
name|AST_POLYMORPHIC_MATCHER_P2
argument_list|(
argument|hasTemplateArgument
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,                                     TemplateSpecializationType,                                     FunctionDecl)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<TemplateArgument>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|ArrayRef
operator|<
name|TemplateArgument
operator|>
name|List
operator|=
name|internal
operator|::
name|getTemplateSpecializationArgs
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|List
operator|.
name|size
argument_list|()
operator|<=
name|N
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|List
index|[
name|N
index|]
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the number of template arguments equals \p N.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> struct C {};
comment|///   C<int> c;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(templateArgumentCountIs(1))
comment|///   matches C<int>.
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|templateArgumentCountIs
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,                                     TemplateSpecializationType)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|internal
operator|::
name|getTemplateSpecializationArgs
argument_list|(
name|Node
argument_list|)
operator|.
name|size
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain type.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct X {};
comment|///   template<typename T> struct A {};
comment|///   A<X> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToType(class(hasName("X")))))
comment|///   matches the specialization \c A<X>
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Type
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getAsType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument that refers to a certain template.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<template<typename> class S> class X {};
comment|///   template<typename T> class Y {};"
comment|///   X<Y> xi;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToTemplate(templateName())))
comment|///   matches the specialization \c X<Y>
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToTemplate
argument_list|,
argument|internal::Matcher<TemplateName>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Template
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getAsTemplate
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a canonical TemplateArgument that refers to a certain
comment|/// declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> struct A {};
comment|///   struct B { B* next; };
comment|///   A<&B::next> a;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(hasAnyTemplateArgument(
comment|///     refersToDeclaration(fieldDecl(hasName("next"))))
comment|///   matches the specialization \c A<&B::next> with \c fieldDecl(...) matching
comment|///     \c B::next
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToDeclaration
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Declaration
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getAsDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a sugar TemplateArgument that refers to a certain expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> struct A {};
comment|///   struct B { B* next; };
comment|///   A<&B::next> a;
comment|/// \endcode
comment|/// templateSpecializationType(hasAnyTemplateArgument(
comment|///   isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName("next"))))))))
comment|///   matches the specialization \c A<&B::next> with \c fieldDecl(...) matching
comment|///     \c B::next
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|isExpr
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Expression
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getAsExpr
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a TemplateArgument that is an integral value.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<int T> struct A {};
comment|///   C<42> c;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(
comment|///   hasAnyTemplateArgument(isIntegral()))
comment|///   matches the implicit instantiation of C in C<42>
comment|///   with isIntegral() matching 42.
name|AST_MATCHER
argument_list|(
argument|TemplateArgument
argument_list|,
argument|isIntegral
argument_list|)
block|{
return|return
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|TemplateArgument
operator|::
name|Integral
return|;
block|}
comment|/// \brief Matches a TemplateArgument that referes to an integral type.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<int T> struct A {};
comment|///   C<42> c;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(
comment|///   hasAnyTemplateArgument(refersToIntegralType(asString("int"))))
comment|///   matches the implicit instantiation of C in C<42>.
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|refersToIntegralType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Integral
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getIntegralType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a TemplateArgument of integral type with a given value.
comment|///
comment|/// Note that 'Value' is a string as the template argument's value is
comment|/// an arbitrary precision integer. 'Value' must be euqal to the canonical
comment|/// representation of that integral value in base 10.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<int T> struct A {};
comment|///   C<42> c;
comment|/// \endcode
comment|/// classTemplateSpecializationDecl(
comment|///   hasAnyTemplateArgument(equalsIntegralValue("42")))
comment|///   matches the implicit instantiation of C in C<42>.
name|AST_MATCHER_P
argument_list|(
argument|TemplateArgument
argument_list|,
argument|equalsIntegralValue
argument_list|,
argument|std::string
argument_list|,
argument|Value
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getKind
argument_list|()
operator|!=
name|TemplateArgument
operator|::
name|Integral
condition|)
return|return
name|false
return|;
return|return
name|Node
operator|.
name|getAsIntegral
argument_list|()
operator|.
name|toString
argument_list|(
literal|10
argument_list|)
operator|==
name|Value
return|;
block|}
comment|/// \brief Matches any value declaration.
comment|///
comment|/// Example matches A, B, C and F
comment|/// \code
comment|///   enum X { A, B, C };
comment|///   void F();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ValueDecl
operator|>
name|valueDecl
expr_stmt|;
comment|/// \brief Matches C++ constructor declarations.
comment|///
comment|/// Example matches Foo::Foo() and Foo::Foo(int)
comment|/// \code
comment|///   class Foo {
comment|///    public:
comment|///     Foo();
comment|///     Foo(int);
comment|///     int DoSomething();
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXConstructorDecl
operator|>
name|cxxConstructorDecl
expr_stmt|;
comment|/// \brief Matches explicit C++ destructor declarations.
comment|///
comment|/// Example matches Foo::~Foo()
comment|/// \code
comment|///   class Foo {
comment|///    public:
comment|///     virtual ~Foo();
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXDestructorDecl
operator|>
name|cxxDestructorDecl
expr_stmt|;
comment|/// \brief Matches enum declarations.
comment|///
comment|/// Example matches X
comment|/// \code
comment|///   enum X {
comment|///     A, B, C
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumDecl
operator|>
name|enumDecl
expr_stmt|;
comment|/// \brief Matches enum constants.
comment|///
comment|/// Example matches A, B, C
comment|/// \code
comment|///   enum X {
comment|///     A, B, C
comment|///   };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|EnumConstantDecl
operator|>
name|enumConstantDecl
expr_stmt|;
comment|/// \brief Matches method declarations.
comment|///
comment|/// Example matches y
comment|/// \code
comment|///   class X { void y(); };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXMethodDecl
operator|>
name|cxxMethodDecl
expr_stmt|;
comment|/// \brief Matches conversion operator declarations.
comment|///
comment|/// Example matches the operator.
comment|/// \code
comment|///   class X { operator int() const; };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|CXXConversionDecl
operator|>
name|cxxConversionDecl
expr_stmt|;
comment|/// \brief Matches variable declarations.
comment|///
comment|/// Note: this does not match declarations of member variables, which are
comment|/// "field" declarations in Clang parlance.
comment|///
comment|/// Example matches a
comment|/// \code
comment|///   int a;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|VarDecl
operator|>
name|varDecl
expr_stmt|;
comment|/// \brief Matches field declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { int m; };
comment|/// \endcode
comment|/// fieldDecl()
comment|///   matches 'm'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FieldDecl
operator|>
name|fieldDecl
expr_stmt|;
comment|/// \brief Matches function declarations.
comment|///
comment|/// Example matches f
comment|/// \code
comment|///   void f();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FunctionDecl
operator|>
name|functionDecl
expr_stmt|;
comment|/// \brief Matches C++ function template declarations.
comment|///
comment|/// Example matches f
comment|/// \code
comment|///   template<class T> void f(T t) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FunctionTemplateDecl
operator|>
name|functionTemplateDecl
expr_stmt|;
comment|/// \brief Matches friend declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { friend void foo(); };
comment|/// \endcode
comment|/// friendDecl()
comment|///   matches 'friend void foo()'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|FriendDecl
operator|>
name|friendDecl
expr_stmt|;
comment|/// \brief Matches statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   { ++a; }
comment|/// \endcode
comment|/// stmt()
comment|///   matches both the compound statement '{ ++a; }' and '++a'.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|Stmt
operator|>
name|stmt
expr_stmt|;
comment|/// \brief Matches declaration statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a;
comment|/// \endcode
comment|/// declStmt()
comment|///   matches 'int a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclStmt
operator|>
name|declStmt
expr_stmt|;
comment|/// \brief Matches member expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a; static int b;
comment|///   };
comment|/// \endcode
comment|/// memberExpr()
comment|///   matches this->x, x, y.x, a, this->b
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|MemberExpr
operator|>
name|memberExpr
expr_stmt|;
comment|/// \brief Matches call expressions.
comment|///
comment|/// Example matches x.y() and y()
comment|/// \code
comment|///   X x;
comment|///   x.y();
comment|///   y();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CallExpr
operator|>
name|callExpr
expr_stmt|;
comment|/// \brief Matches lambda expressions.
comment|///
comment|/// Example matches [&](){return 5;}
comment|/// \code
comment|///   [&](){return 5;}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|LambdaExpr
operator|>
name|lambdaExpr
expr_stmt|;
comment|/// \brief Matches member call expressions.
comment|///
comment|/// Example matches x.y()
comment|/// \code
comment|///   X x;
comment|///   x.y();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXMemberCallExpr
operator|>
name|cxxMemberCallExpr
expr_stmt|;
comment|/// \brief Matches ObjectiveC Message invocation expressions.
comment|///
comment|/// The innermost message send invokes the "alloc" class method on the
comment|/// NSString class, while the outermost message send invokes the
comment|/// "initWithString" instance method on the object returned from
comment|/// NSString's "alloc". This matcher should match both message sends.
comment|/// \code
comment|///   [[NSString alloc] initWithString:@"Hello"]
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ObjCMessageExpr
operator|>
name|objcMessageExpr
expr_stmt|;
comment|/// \brief Matches Objective-C interface declarations.
comment|///
comment|/// Example matches Foo
comment|/// \code
comment|///   @interface Foo
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCInterfaceDecl
operator|>
name|objcInterfaceDecl
expr_stmt|;
comment|/// \brief Matches Objective-C protocol declarations.
comment|///
comment|/// Example matches FooDelegate
comment|/// \code
comment|///   @protocol FooDelegate
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCProtocolDecl
operator|>
name|objcProtocolDecl
expr_stmt|;
comment|/// \brief Matches Objective-C category declarations.
comment|///
comment|/// Example matches Foo (Additions)
comment|/// \code
comment|///   @interface Foo (Additions)
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCCategoryDecl
operator|>
name|objcCategoryDecl
expr_stmt|;
comment|/// \brief Matches Objective-C method declarations.
comment|///
comment|/// Example matches both declaration and definition of -[Foo method]
comment|/// \code
comment|///   @interface Foo
comment|///   - (void)method;
comment|///   @end
comment|///
comment|///   @implementation Foo
comment|///   - (void)method {}
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCMethodDecl
operator|>
name|objcMethodDecl
expr_stmt|;
comment|/// \brief Matches Objective-C instance variable declarations.
comment|///
comment|/// Example matches _enabled
comment|/// \code
comment|///   @implementation Foo {
comment|///     BOOL _enabled;
comment|///   }
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCIvarDecl
operator|>
name|objcIvarDecl
expr_stmt|;
comment|/// \brief Matches Objective-C property declarations.
comment|///
comment|/// Example matches enabled
comment|/// \code
comment|///   @interface Foo
comment|///   @property BOOL enabled;
comment|///   @end
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|ObjCPropertyDecl
operator|>
name|objcPropertyDecl
expr_stmt|;
comment|/// \brief Matches expressions that introduce cleanups to be run at the end
comment|/// of the sub-expression's evaluation.
comment|///
comment|/// Example matches std::string()
comment|/// \code
comment|///   const std::string str = std::string();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ExprWithCleanups
operator|>
name|exprWithCleanups
expr_stmt|;
comment|/// \brief Matches init list expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 1, 2 };
comment|///   struct B { int x, y; };
comment|///   B b = { 5, 6 };
comment|/// \endcode
comment|/// initListExpr()
comment|///   matches "{ 1, 2 }" and "{ 5, 6 }"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|InitListExpr
operator|>
name|initListExpr
expr_stmt|;
comment|/// \brief Matches the syntactic form of init list expressions
comment|/// (if expression have it).
name|AST_MATCHER_P
argument_list|(
argument|InitListExpr
argument_list|,
argument|hasSyntacticForm
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|SyntForm
init|=
name|Node
operator|.
name|getSyntacticForm
argument_list|()
decl_stmt|;
return|return
operator|(
name|SyntForm
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|SyntForm
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches C++ initializer list expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   std::vector<int> a({ 1, 2, 3 });
comment|///   std::vector<int> b = { 4, 5 };
comment|///   int c[] = { 6, 7 };
comment|///   std::pair<int, int> d = { 8, 9 };
comment|/// \endcode
comment|/// cxxStdInitializerListExpr()
comment|///   matches "{ 1, 2, 3 }" and "{ 4, 5 }"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXStdInitializerListExpr
operator|>
name|cxxStdInitializerListExpr
expr_stmt|;
comment|/// \brief Matches implicit initializers of init list expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };
comment|/// \endcode
comment|/// implicitValueInitExpr()
comment|///   matches "[0].y" (implicitly)
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ImplicitValueInitExpr
operator|>
name|implicitValueInitExpr
expr_stmt|;
comment|/// \brief Matches paren list expressions.
comment|/// ParenListExprs don't have a predefined type and are used for late parsing.
comment|/// In the final AST, they can be met in template declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class X {
comment|///     void f() {
comment|///       X x(*this);
comment|///       int a = 0, b = 1; int i = (a, b);
comment|///     }
comment|///   };
comment|/// \endcode
comment|/// parenListExpr() matches "*this" but NOT matches (a, b) because (a, b)
comment|/// has a predefined type and is a ParenExpr, not a ParenListExpr.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ParenListExpr
operator|>
name|parenListExpr
expr_stmt|;
comment|/// \brief Matches substitutions of non-type template parameters.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<int N>
comment|///   struct A { static const int n = N; };
comment|///   struct B : public A<42> {};
comment|/// \endcode
comment|/// substNonTypeTemplateParmExpr()
comment|///   matches "N" in the right-hand side of "static const int n = N;"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SubstNonTypeTemplateParmExpr
operator|>
name|substNonTypeTemplateParmExpr
expr_stmt|;
comment|/// \brief Matches using declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { int x; }
comment|///   using X::x;
comment|/// \endcode
comment|/// usingDecl()
comment|///   matches \code using X::x \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UsingDecl
operator|>
name|usingDecl
expr_stmt|;
comment|/// \brief Matches using namespace declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { int x; }
comment|///   using namespace X;
comment|/// \endcode
comment|/// usingDirectiveDecl()
comment|///   matches \code using namespace X \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UsingDirectiveDecl
operator|>
name|usingDirectiveDecl
expr_stmt|;
comment|/// \brief Matches reference to a name that can be looked up during parsing
comment|/// but could not be resolved to a specific declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T>
comment|///   T foo() { T a; return a; }
comment|///   template<typename T>
comment|///   void bar() {
comment|///     foo<T>();
comment|///   }
comment|/// \endcode
comment|/// unresolvedLookupExpr()
comment|///   matches \code foo<T>() \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnresolvedLookupExpr
operator|>
name|unresolvedLookupExpr
expr_stmt|;
comment|/// \brief Matches unresolved using value declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename X>
comment|///   class C : private X {
comment|///     using X::x;
comment|///   };
comment|/// \endcode
comment|/// unresolvedUsingValueDecl()
comment|///   matches \code using X::x \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UnresolvedUsingValueDecl
operator|>
name|unresolvedUsingValueDecl
expr_stmt|;
comment|/// \brief Matches unresolved using value declarations that involve the
comment|/// typename.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T>
comment|///   struct Base { typedef T Foo; };
comment|///
comment|///   template<typename T>
comment|///   struct S : private Base<T> {
comment|///     using typename Base<T>::Foo;
comment|///   };
comment|/// \endcode
comment|/// unresolvedUsingTypenameDecl()
comment|///   matches \code using Base<T>::Foo \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|UnresolvedUsingTypenameDecl
operator|>
name|unresolvedUsingTypenameDecl
expr_stmt|;
comment|/// \brief Matches parentheses used in expressions.
comment|///
comment|/// Example matches (foo() + 1)
comment|/// \code
comment|///   int foo() { return 1; }
comment|///   int a = (foo() + 1);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ParenExpr
operator|>
name|parenExpr
expr_stmt|;
comment|/// \brief Matches constructor call expressions (including implicit ones).
comment|///
comment|/// Example matches string(ptr, n) and ptr within arguments of f
comment|///     (matcher = cxxConstructExpr())
comment|/// \code
comment|///   void f(const string&a, const string&b);
comment|///   char *ptr;
comment|///   int n;
comment|///   f(string(ptr, n), ptr);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXConstructExpr
operator|>
name|cxxConstructExpr
expr_stmt|;
comment|/// \brief Matches unresolved constructor call expressions.
comment|///
comment|/// Example matches T(t) in return statement of f
comment|///     (matcher = cxxUnresolvedConstructExpr())
comment|/// \code
comment|///   template<typename T>
comment|///   void f(const T& t) { return T(t); }
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXUnresolvedConstructExpr
operator|>
name|cxxUnresolvedConstructExpr
expr_stmt|;
comment|/// \brief Matches implicit and explicit this expressions.
comment|///
comment|/// Example matches the implicit this expression in "return i".
comment|///     (matcher = cxxThisExpr())
comment|/// \code
comment|/// struct foo {
comment|///   int i;
comment|///   int f() { return i; }
comment|/// };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXThisExpr
operator|>
name|cxxThisExpr
expr_stmt|;
comment|/// \brief Matches nodes where temporaries are created.
comment|///
comment|/// Example matches FunctionTakesString(GetStringByValue())
comment|///     (matcher = cxxBindTemporaryExpr())
comment|/// \code
comment|///   FunctionTakesString(GetStringByValue());
comment|///   FunctionTakesStringByPointer(GetStringPointer());
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXBindTemporaryExpr
operator|>
name|cxxBindTemporaryExpr
expr_stmt|;
comment|/// \brief Matches nodes where temporaries are materialized.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   struct T {void func();};
comment|///   T f();
comment|///   void g(T);
comment|/// \endcode
comment|/// materializeTemporaryExpr() matches 'f()' in these statements
comment|/// \code
comment|///   T u(f());
comment|///   g(f());
comment|/// \endcode
comment|/// but does not match
comment|/// \code
comment|///   f();
comment|///   f().func();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|MaterializeTemporaryExpr
operator|>
name|materializeTemporaryExpr
expr_stmt|;
comment|/// \brief Matches new expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   new X;
comment|/// \endcode
comment|/// cxxNewExpr()
comment|///   matches 'new X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXNewExpr
operator|>
name|cxxNewExpr
expr_stmt|;
comment|/// \brief Matches delete expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   delete X;
comment|/// \endcode
comment|/// cxxDeleteExpr()
comment|///   matches 'delete X'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDeleteExpr
operator|>
name|cxxDeleteExpr
expr_stmt|;
comment|/// \brief Matches array subscript expressions.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i = a[1];
comment|/// \endcode
comment|/// arraySubscriptExpr()
comment|///   matches "a[1]"
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ArraySubscriptExpr
operator|>
name|arraySubscriptExpr
expr_stmt|;
comment|/// \brief Matches the value of a default argument at the call site.
comment|///
comment|/// Example matches the CXXDefaultArgExpr placeholder inserted for the
comment|///     default value of the second parameter in the call expression f(42)
comment|///     (matcher = cxxDefaultArgExpr())
comment|/// \code
comment|///   void f(int x, int y = 0);
comment|///   f(42);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDefaultArgExpr
operator|>
name|cxxDefaultArgExpr
expr_stmt|;
comment|/// \brief Matches overloaded operator calls.
comment|///
comment|/// Note that if an operator isn't overloaded, it won't match. Instead, use
comment|/// binaryOperator matcher.
comment|/// Currently it does not match operators such as new delete.
comment|/// FIXME: figure out why these do not match?
comment|///
comment|/// Example matches both operator<<((o<< b), c) and operator<<(o, b)
comment|///     (matcher = cxxOperatorCallExpr())
comment|/// \code
comment|///   ostream&operator<< (ostream&out, int i) { };
comment|///   ostream&o; int b = 1, c = 1;
comment|///   o<< b<< c;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXOperatorCallExpr
operator|>
name|cxxOperatorCallExpr
expr_stmt|;
comment|/// \brief Matches expressions.
comment|///
comment|/// Example matches x()
comment|/// \code
comment|///   void f() { x(); }
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|Expr
operator|>
name|expr
expr_stmt|;
comment|/// \brief Matches expressions that refer to declarations.
comment|///
comment|/// Example matches x in if (x)
comment|/// \code
comment|///   bool x;
comment|///   if (x) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DeclRefExpr
operator|>
name|declRefExpr
expr_stmt|;
comment|/// \brief Matches if statements.
comment|///
comment|/// Example matches 'if (x) {}'
comment|/// \code
comment|///   if (x) {}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|IfStmt
operator|>
name|ifStmt
expr_stmt|;
comment|/// \brief Matches for statements.
comment|///
comment|/// Example matches 'for (;;) {}'
comment|/// \code
comment|///   for (;;) {}
comment|///   int i[] =  {1, 2, 3}; for (auto a : i);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ForStmt
operator|>
name|forStmt
expr_stmt|;
comment|/// \brief Matches the increment statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasIncrement(unaryOperator(hasOperatorName("++"))))
comment|/// matches '++x' in
comment|/// \code
comment|///     for (x; x< N; ++x) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasIncrement
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Increment
init|=
name|Node
operator|.
name|getInc
argument_list|()
decl_stmt|;
return|return
operator|(
name|Increment
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Increment
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initialization statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasLoopInit(declStmt()))
comment|/// matches 'int x = 0' in
comment|/// \code
comment|///     for (int x = 0; x< N; ++x) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ForStmt
argument_list|,
argument|hasLoopInit
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Init
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|Init
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Init
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches range-based for statements.
comment|///
comment|/// cxxForRangeStmt() matches 'for (auto a : i)'
comment|/// \code
comment|///   int i[] =  {1, 2, 3}; for (auto a : i);
comment|///   for(int j = 0; j< 5; ++j);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXForRangeStmt
operator|>
name|cxxForRangeStmt
expr_stmt|;
comment|/// \brief Matches the initialization statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasLoopVariable(anything()))
comment|/// matches 'int x' in
comment|/// \code
comment|///     for (int x : a) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXForRangeStmt
argument_list|,
argument|hasLoopVariable
argument_list|,
argument|internal::Matcher<VarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|VarDecl
modifier|*
specifier|const
name|Var
init|=
name|Node
operator|.
name|getLoopVariable
argument_list|()
decl_stmt|;
return|return
operator|(
name|Var
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Var
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the range initialization statement of a for loop.
comment|///
comment|/// Example:
comment|///     forStmt(hasRangeInit(anything()))
comment|/// matches 'a' in
comment|/// \code
comment|///     for (int x : a) { }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXForRangeStmt
argument_list|,
argument|hasRangeInit
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|Init
init|=
name|Node
operator|.
name|getRangeInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|Init
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Init
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches while statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) {}
comment|/// \endcode
comment|/// whileStmt()
comment|///   matches 'while (true) {}'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|WhileStmt
operator|>
name|whileStmt
expr_stmt|;
comment|/// \brief Matches do statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   do {} while (true);
comment|/// \endcode
comment|/// doStmt()
comment|///   matches 'do {} while(true)'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DoStmt
operator|>
name|doStmt
expr_stmt|;
comment|/// \brief Matches break statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) { break; }
comment|/// \endcode
comment|/// breakStmt()
comment|///   matches 'break'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BreakStmt
operator|>
name|breakStmt
expr_stmt|;
comment|/// \brief Matches continue statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   while (true) { continue; }
comment|/// \endcode
comment|/// continueStmt()
comment|///   matches 'continue'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ContinueStmt
operator|>
name|continueStmt
expr_stmt|;
comment|/// \brief Matches return statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   return 1;
comment|/// \endcode
comment|/// returnStmt()
comment|///   matches 'return 1'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ReturnStmt
operator|>
name|returnStmt
expr_stmt|;
comment|/// \brief Matches goto statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   goto FOO;
comment|///   FOO: bar();
comment|/// \endcode
comment|/// gotoStmt()
comment|///   matches 'goto FOO'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|GotoStmt
operator|>
name|gotoStmt
expr_stmt|;
comment|/// \brief Matches label statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   goto FOO;
comment|///   FOO: bar();
comment|/// \endcode
comment|/// labelStmt()
comment|///   matches 'FOO:'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|LabelStmt
operator|>
name|labelStmt
expr_stmt|;
comment|/// \brief Matches address of label statements (GNU extension).
comment|///
comment|/// Given
comment|/// \code
comment|///   FOO: bar();
comment|///   void *ptr =&&FOO;
comment|///   goto *bar;
comment|/// \endcode
comment|/// addrLabelExpr()
comment|///   matches '&&FOO'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|AddrLabelExpr
operator|>
name|addrLabelExpr
expr_stmt|;
comment|/// \brief Matches switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// switchStmt()
comment|///   matches 'switch(a)'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SwitchStmt
operator|>
name|switchStmt
expr_stmt|;
comment|/// \brief Matches case and default statements inside switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// switchCase()
comment|///   matches 'case 42: break;' and 'default: break;'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|SwitchCase
operator|>
name|switchCase
expr_stmt|;
comment|/// \brief Matches case statements inside switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// caseStmt()
comment|///   matches 'case 42: break;'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CaseStmt
operator|>
name|caseStmt
expr_stmt|;
comment|/// \brief Matches default statements inside switch statements.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch(a) { case 42: break; default: break; }
comment|/// \endcode
comment|/// defaultStmt()
comment|///   matches 'default: break;'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DefaultStmt
operator|>
name|defaultStmt
expr_stmt|;
comment|/// \brief Matches compound statements.
comment|///
comment|/// Example matches '{}' and '{{}}'in 'for (;;) {{}}'
comment|/// \code
comment|///   for (;;) {{}}
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CompoundStmt
operator|>
name|compoundStmt
expr_stmt|;
comment|/// \brief Matches catch statements.
comment|///
comment|/// \code
comment|///   try {} catch(int i) {}
comment|/// \endcode
comment|/// cxxCatchStmt()
comment|///   matches 'catch(int i)'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXCatchStmt
operator|>
name|cxxCatchStmt
expr_stmt|;
comment|/// \brief Matches try statements.
comment|///
comment|/// \code
comment|///   try {} catch(int i) {}
comment|/// \endcode
comment|/// cxxTryStmt()
comment|///   matches 'try {}'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXTryStmt
operator|>
name|cxxTryStmt
expr_stmt|;
comment|/// \brief Matches throw expressions.
comment|///
comment|/// \code
comment|///   try { throw 5; } catch(int i) {}
comment|/// \endcode
comment|/// cxxThrowExpr()
comment|///   matches 'throw 5'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXThrowExpr
operator|>
name|cxxThrowExpr
expr_stmt|;
comment|/// \brief Matches null statements.
comment|///
comment|/// \code
comment|///   foo();;
comment|/// \endcode
comment|/// nullStmt()
comment|///   matches the second ';'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|NullStmt
operator|>
name|nullStmt
expr_stmt|;
comment|/// \brief Matches asm statements.
comment|///
comment|/// \code
comment|///  int i = 100;
comment|///   __asm("mov al, 2");
comment|/// \endcode
comment|/// asmStmt()
comment|///   matches '__asm("mov al, 2")'
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|AsmStmt
operator|>
name|asmStmt
expr_stmt|;
comment|/// \brief Matches bool literals.
comment|///
comment|/// Example matches true
comment|/// \code
comment|///   true
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXBoolLiteralExpr
operator|>
name|cxxBoolLiteral
expr_stmt|;
comment|/// \brief Matches string literals (also matches wide string literals).
comment|///
comment|/// Example matches "abcd", L"abcd"
comment|/// \code
comment|///   char *s = "abcd";
comment|///   wchar_t *ws = L"abcd";
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|StringLiteral
operator|>
name|stringLiteral
expr_stmt|;
comment|/// \brief Matches character literals (also matches wchar_t).
comment|///
comment|/// Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
comment|/// though.
comment|///
comment|/// Example matches 'a', L'a'
comment|/// \code
comment|///   char ch = 'a';
comment|///   wchar_t chw = L'a';
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CharacterLiteral
operator|>
name|characterLiteral
expr_stmt|;
comment|/// \brief Matches integer literals of all sizes / encodings, e.g.
comment|/// 1, 1L, 0x1 and 1U.
comment|///
comment|/// Does not match character-encoded integers such as L'a'.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|IntegerLiteral
operator|>
name|integerLiteral
expr_stmt|;
comment|/// \brief Matches float literals of all sizes / encodings, e.g.
comment|/// 1.0, 1.0f, 1.0L and 1e10.
comment|///
comment|/// Does not match implicit conversions such as
comment|/// \code
comment|///   float a = 10;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|FloatingLiteral
operator|>
name|floatLiteral
expr_stmt|;
comment|/// \brief Matches user defined literal operator call.
comment|///
comment|/// Example match: "foo"_suffix
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UserDefinedLiteral
operator|>
name|userDefinedLiteral
expr_stmt|;
comment|/// \brief Matches compound (i.e. non-scalar) literals
comment|///
comment|/// Example match: {1}, (1, 2)
comment|/// \code
comment|///   int array[4] = {1};
comment|///   vector int myvec = (vector int)(1, 2);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CompoundLiteralExpr
operator|>
name|compoundLiteralExpr
expr_stmt|;
comment|/// \brief Matches nullptr literal.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXNullPtrLiteralExpr
operator|>
name|cxxNullPtrLiteralExpr
expr_stmt|;
comment|/// \brief Matches GNU __null expression.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|GNUNullExpr
operator|>
name|gnuNullExpr
expr_stmt|;
comment|/// \brief Matches atomic builtins.
comment|/// Example matches __atomic_load_n(ptr, 1)
comment|/// \code
comment|///   void foo() { int *ptr; __atomic_load_n(ptr, 1); }
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|AtomicExpr
operator|>
name|atomicExpr
expr_stmt|;
comment|/// \brief Matches statement expression (GNU extension).
comment|///
comment|/// Example match: ({ int X = 4; X; })
comment|/// \code
comment|///   int C = ({ int X = 4; X; });
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|StmtExpr
operator|>
name|stmtExpr
expr_stmt|;
comment|/// \brief Matches binary operator expressions.
comment|///
comment|/// Example matches a || b
comment|/// \code
comment|///   !(a || b)
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BinaryOperator
operator|>
name|binaryOperator
expr_stmt|;
comment|/// \brief Matches unary operator expressions.
comment|///
comment|/// Example matches !a
comment|/// \code
comment|///   !a || b
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryOperator
operator|>
name|unaryOperator
expr_stmt|;
comment|/// \brief Matches conditional operator expressions.
comment|///
comment|/// Example matches a ? b : c
comment|/// \code
comment|///   (a ? b : c) + 42
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ConditionalOperator
operator|>
name|conditionalOperator
expr_stmt|;
comment|/// \brief Matches binary conditional operator expressions (GNU extension).
comment|///
comment|/// Example matches a ?: b
comment|/// \code
comment|///   (a ?: b) + 42;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|BinaryConditionalOperator
operator|>
name|binaryConditionalOperator
expr_stmt|;
comment|/// \brief Matches opaque value expressions. They are used as helpers
comment|/// to reference another expressions and can be met
comment|/// in BinaryConditionalOperators, for example.
comment|///
comment|/// Example matches 'a'
comment|/// \code
comment|///   (a ?: c) + 42;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|OpaqueValueExpr
operator|>
name|opaqueValueExpr
expr_stmt|;
comment|/// \brief Matches a C++ static_assert declaration.
comment|///
comment|/// Example:
comment|///   staticAssertExpr()
comment|/// matches
comment|///   static_assert(sizeof(S) == sizeof(int))
comment|/// in
comment|/// \code
comment|///   struct S {
comment|///     int x;
comment|///   };
comment|///   static_assert(sizeof(S) == sizeof(int));
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Decl
operator|,
name|StaticAssertDecl
operator|>
name|staticAssertDecl
expr_stmt|;
comment|/// \brief Matches a reinterpret_cast expression.
comment|///
comment|/// Either the source expression or the destination type can be matched
comment|/// using has(), but hasDestinationType() is more specific and can be
comment|/// more readable.
comment|///
comment|/// Example matches reinterpret_cast<char*>(&p) in
comment|/// \code
comment|///   void* p = reinterpret_cast<char*>(&p);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXReinterpretCastExpr
operator|>
name|cxxReinterpretCastExpr
expr_stmt|;
comment|/// \brief Matches a C++ static_cast expression.
comment|///
comment|/// \see hasDestinationType
comment|/// \see reinterpretCast
comment|///
comment|/// Example:
comment|///   cxxStaticCastExpr()
comment|/// matches
comment|///   static_cast<long>(8)
comment|/// in
comment|/// \code
comment|///   long eight(static_cast<long>(8));
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXStaticCastExpr
operator|>
name|cxxStaticCastExpr
expr_stmt|;
comment|/// \brief Matches a dynamic_cast expression.
comment|///
comment|/// Example:
comment|///   cxxDynamicCastExpr()
comment|/// matches
comment|///   dynamic_cast<D*>(&b);
comment|/// in
comment|/// \code
comment|///   struct B { virtual ~B() {} }; struct D : B {};
comment|///   B b;
comment|///   D* p = dynamic_cast<D*>(&b);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXDynamicCastExpr
operator|>
name|cxxDynamicCastExpr
expr_stmt|;
comment|/// \brief Matches a const_cast expression.
comment|///
comment|/// Example: Matches const_cast<int*>(&r) in
comment|/// \code
comment|///   int n = 42;
comment|///   const int&r(n);
comment|///   int* p = const_cast<int*>(&r);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXConstCastExpr
operator|>
name|cxxConstCastExpr
expr_stmt|;
comment|/// \brief Matches a C-style cast expression.
comment|///
comment|/// Example: Matches (int) 2.2f in
comment|/// \code
comment|///   int i = (int) 2.2f;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CStyleCastExpr
operator|>
name|cStyleCastExpr
expr_stmt|;
comment|/// \brief Matches explicit cast expressions.
comment|///
comment|/// Matches any cast expression written in user code, whether it be a
comment|/// C-style cast, a functional-style cast, or a keyword cast.
comment|///
comment|/// Does not match implicit conversions.
comment|///
comment|/// Note: the name "explicitCast" is chosen to match Clang's terminology, as
comment|/// Clang uses the term "cast" to apply to implicit conversions as well as to
comment|/// actual cast expressions.
comment|///
comment|/// \see hasDestinationType.
comment|///
comment|/// Example: matches all five of the casts in
comment|/// \code
comment|///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))
comment|/// \endcode
comment|/// but does not match the implicit conversion in
comment|/// \code
comment|///   long ell = 42;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ExplicitCastExpr
operator|>
name|explicitCastExpr
expr_stmt|;
comment|/// \brief Matches the implicit cast nodes of Clang's AST.
comment|///
comment|/// This matches many different places, including function call return value
comment|/// eliding, as well as any type conversions.
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|ImplicitCastExpr
operator|>
name|implicitCastExpr
expr_stmt|;
comment|/// \brief Matches any cast nodes of Clang's AST.
comment|///
comment|/// Example: castExpr() matches each of the following:
comment|/// \code
comment|///   (int) 3;
comment|///   const_cast<Expr *>(SubExpr);
comment|///   char c = 0;
comment|/// \endcode
comment|/// but does not match
comment|/// \code
comment|///   int i = (0);
comment|///   int k = 0;
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CastExpr
operator|>
name|castExpr
expr_stmt|;
comment|/// \brief Matches functional cast expressions
comment|///
comment|/// Example: Matches Foo(bar);
comment|/// \code
comment|///   Foo f = bar;
comment|///   Foo g = (Foo) bar;
comment|///   Foo h = Foo(bar);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXFunctionalCastExpr
operator|>
name|cxxFunctionalCastExpr
expr_stmt|;
comment|/// \brief Matches functional cast expressions having N != 1 arguments
comment|///
comment|/// Example: Matches Foo(bar, bar)
comment|/// \code
comment|///   Foo h = Foo(bar, bar);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CXXTemporaryObjectExpr
operator|>
name|cxxTemporaryObjectExpr
expr_stmt|;
comment|/// \brief Matches predefined identifier expressions [C99 6.4.2.2].
comment|///
comment|/// Example: Matches __func__
comment|/// \code
comment|///   printf("%s", __func__);
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|PredefinedExpr
operator|>
name|predefinedExpr
expr_stmt|;
comment|/// \brief Matches C99 designated initializer expressions [C99 6.7.8].
comment|///
comment|/// Example: Matches { [2].y = 1.0, [0].x = 1.0 }
comment|/// \code
comment|///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|DesignatedInitExpr
operator|>
name|designatedInitExpr
expr_stmt|;
comment|/// \brief Matches designated initializer expressions that contain
comment|/// a specific number of designators.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };
comment|///   point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };
comment|/// \endcode
comment|/// designatorCountIs(2)
comment|///   matches '{ [2].y = 1.0, [0].x = 1.0 }',
comment|///   but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'.
name|AST_MATCHER_P
argument_list|(
argument|DesignatedInitExpr
argument_list|,
argument|designatorCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|size
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches \c QualTypes in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|QualType
operator|>
name|qualType
expr_stmt|;
comment|/// \brief Matches \c Types in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|Type
operator|>
name|type
expr_stmt|;
comment|/// \brief Matches \c TypeLocs in the clang AST.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|TypeLoc
operator|>
name|typeLoc
expr_stmt|;
comment|/// \brief Matches if any of the given matchers matches.
comment|///
comment|/// Unlike \c anyOf, \c eachOf will generate a match result for each
comment|/// matching submatcher.
comment|///
comment|/// For example, in:
comment|/// \code
comment|///   class A { int a; int b; };
comment|/// \endcode
comment|/// The matcher:
comment|/// \code
comment|///   cxxRecordDecl(eachOf(has(fieldDecl(hasName("a")).bind("v")),
comment|///                        has(fieldDecl(hasName("b")).bind("v"))))
comment|/// \endcode
comment|/// will generate two results binding "v", the first of which binds
comment|/// the field declaration of \c a, the second the field declaration of
comment|/// \c b.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|VariadicOperatorMatcherFunc
operator|<
literal|2
operator|,
name|UINT_MAX
operator|>
name|eachOf
operator|=
block|{
name|internal
operator|::
name|DynTypedMatcher
operator|::
name|VO_EachOf
block|}
expr_stmt|;
comment|/// \brief Matches if any of the given matchers matches.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|VariadicOperatorMatcherFunc
operator|<
literal|2
operator|,
name|UINT_MAX
operator|>
name|anyOf
operator|=
block|{
name|internal
operator|::
name|DynTypedMatcher
operator|::
name|VO_AnyOf
block|}
expr_stmt|;
comment|/// \brief Matches if all given matchers match.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|VariadicOperatorMatcherFunc
operator|<
literal|2
operator|,
name|UINT_MAX
operator|>
name|allOf
operator|=
block|{
name|internal
operator|::
name|DynTypedMatcher
operator|::
name|VO_AllOf
block|}
expr_stmt|;
comment|/// \brief Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)
comment|///
comment|/// Given
comment|/// \code
comment|///   Foo x = bar;
comment|///   int y = sizeof(x) + alignof(x);
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr()
comment|///   matches \c sizeof(x) and \c alignof(x)
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|UnaryExprOrTypeTraitExpr
operator|>
name|unaryExprOrTypeTraitExpr
expr_stmt|;
comment|/// \brief Matches unary expressions that have a specific type of argument.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int"))
comment|///   matches \c sizeof(a) and \c alignof(c)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|hasArgumentOfType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|ArgumentType
init|=
name|Node
operator|.
name|getTypeOfArgument
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|ArgumentType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches unary expressions of a certain kind.
comment|///
comment|/// Given
comment|/// \code
comment|///   int x;
comment|///   int s = sizeof(x) + alignof(x)
comment|/// \endcode
comment|/// unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))
comment|///   matches \c sizeof(x)
name|AST_MATCHER_P
argument_list|(
argument|UnaryExprOrTypeTraitExpr
argument_list|,
argument|ofKind
argument_list|,
argument|UnaryExprOrTypeTrait
argument_list|,
argument|Kind
argument_list|)
block|{
return|return
name|Node
operator|.
name|getKind
argument_list|()
operator|==
name|Kind
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// alignof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|alignOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&InnerMatcher
argument_list|)
block|{
return|return
name|stmt
argument_list|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_AlignOf
argument_list|)
argument_list|,
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Same as unaryExprOrTypeTraitExpr, but only matching
comment|/// sizeof.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|Stmt
operator|>
name|sizeOfExpr
argument_list|(
argument|const internal::Matcher<UnaryExprOrTypeTraitExpr>&InnerMatcher
argument_list|)
block|{
return|return
name|stmt
argument_list|(
name|unaryExprOrTypeTraitExpr
argument_list|(
name|allOf
argument_list|(
name|ofKind
argument_list|(
name|UETT_SizeOf
argument_list|)
argument_list|,
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches NamedDecl nodes that have the specified name.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by prefixing the name
comment|/// with '<enclosing>::'.
comment|/// Does not match typedefs of an underlying type with the given name.
comment|///
comment|/// Example matches X (Name == "X")
comment|/// \code
comment|///   class X;
comment|/// \endcode
comment|///
comment|/// Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X")
comment|/// \code
comment|///   namespace a { namespace b { class X; } }
comment|/// \endcode
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|NamedDecl
operator|>
name|hasName
argument_list|(
argument|const std::string&Name
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|Names
block|;
name|Names
operator|.
name|push_back
argument_list|(
name|Name
argument_list|)
block|;
return|return
name|internal
operator|::
name|Matcher
operator|<
name|NamedDecl
operator|>
operator|(
name|new
name|internal
operator|::
name|HasNameMatcher
argument_list|(
name|Names
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches NamedDecl nodes that have any of the specified names.
comment|///
comment|/// This matcher is only provided as a performance optimization of hasName.
comment|/// \code
comment|///     hasAnyName(a, b, c)
comment|/// \endcode
comment|///  is equivalent to, but faster than
comment|/// \code
comment|///     anyOf(hasName(a), hasName(b), hasName(c))
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicFunction
operator|<
name|internal
operator|::
name|Matcher
operator|<
name|NamedDecl
operator|>
operator|,
name|StringRef
operator|,
name|internal
operator|::
name|hasAnyNameFunc
operator|>
name|hasAnyName
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches NamedDecl nodes whose fully qualified names contain
comment|/// a substring matched by the given RegExp.
comment|///
comment|/// Supports specifying enclosing namespaces or classes by
comment|/// prefixing the name with '<enclosing>::'.  Does not match typedefs
comment|/// of an underlying type with the given name.
comment|///
comment|/// Example matches X (regexp == "::X")
comment|/// \code
comment|///   class X;
comment|/// \endcode
comment|///
comment|/// Example matches X (regexp is one of "::X", "^foo::.*X", among others)
comment|/// \code
comment|///   namespace foo { namespace bar { class X; } }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|matchesName
argument_list|,
argument|std::string
argument_list|,
argument|RegExp
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|RegExp
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|FullNameString
operator|=
literal|"::"
operator|+
name|Node
operator|.
name|getQualifiedNameAsString
argument_list|()
expr_stmt|;
name|llvm
operator|::
name|Regex
name|RE
argument_list|(
name|RegExp
argument_list|)
expr_stmt|;
return|return
name|RE
operator|.
name|match
argument_list|(
name|FullNameString
argument_list|)
return|;
block|}
comment|/// \brief Matches overloaded operator names.
comment|///
comment|/// Matches overloaded operator names specified in strings without the
comment|/// "operator" prefix: e.g. "<<".
comment|///
comment|/// Given:
comment|/// \code
comment|///   class A { int operator*(); };
comment|///   const A&operator<<(const A&a, const A&b);
comment|///   A a;
comment|///   a<< a;   //<-- This matches
comment|/// \endcode
comment|///
comment|/// \c cxxOperatorCallExpr(hasOverloadedOperatorName("<<"))) matches the
comment|/// specified line and
comment|/// \c cxxRecordDecl(hasMethod(hasOverloadedOperatorName("*")))
comment|/// matches the declaration of \c A.
comment|///
comment|/// Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasOverloadedOperatorNameMatcher
operator|,
name|StringRef
operator|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|CXXOperatorCallExpr
argument_list|,
name|FunctionDecl
argument_list|)
operator|>
name|hasOverloadedOperatorName
argument_list|(
argument|StringRef Name
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasOverloadedOperatorNameMatcher
operator|,
name|StringRef
operator|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|CXXOperatorCallExpr
argument_list|,
name|FunctionDecl
argument_list|)
operator|>
operator|(
name|Name
operator|)
return|;
block|}
comment|/// \brief Matches C++ classes that are directly or indirectly derived from
comment|/// a class matching \c Base.
comment|///
comment|/// Note that a class is not considered to be derived from itself.
comment|///
comment|/// Example matches Y, Z, C (Base == hasName("X"))
comment|/// \code
comment|///   class X;
comment|///   class Y : public X {};  // directly derived
comment|///   class Z : public Y {};  // indirectly derived
comment|///   typedef X A;
comment|///   typedef A B;
comment|///   class C : public B {};  // derived from a typedef of X
comment|/// \endcode
comment|///
comment|/// In the following example, Bar matches isDerivedFrom(hasName("X")):
comment|/// \code
comment|///   class Foo;
comment|///   typedef Foo X;
comment|///   class Bar : public Foo {};  // derived from a type that X is a typedef of
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isDerivedFrom
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|Base
argument_list|)
block|{
return|return
name|Finder
operator|->
name|classIsDerivedFrom
argument_list|(
operator|&
name|Node
argument_list|,
name|Base
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded method as shortcut for \c isDerivedFrom(hasName(...)).
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isDerivedFrom
argument_list|,
argument|std::string
argument_list|,
argument|BaseName
argument_list|,
literal|1
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|BaseName
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|isDerivedFrom
argument_list|(
name|hasName
argument_list|(
name|BaseName
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Similar to \c isDerivedFrom(), but also matches classes that directly
comment|/// match \c Base.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isSameOrDerivedFrom
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|Base
argument_list|,
literal|0
argument_list|)
block|{
return|return
name|Matcher
operator|<
name|CXXRecordDecl
operator|>
operator|(
name|anyOf
argument_list|(
name|Base
argument_list|,
name|isDerivedFrom
argument_list|(
name|Base
argument_list|)
argument_list|)
operator|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded method as shortcut for
comment|/// \c isSameOrDerivedFrom(hasName(...)).
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isSameOrDerivedFrom
argument_list|,
argument|std::string
argument_list|,
argument|BaseName
argument_list|,
literal|1
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|BaseName
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|isSameOrDerivedFrom
argument_list|(
name|hasName
argument_list|(
name|BaseName
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the first method of a class or struct that satisfies \c
comment|/// InnerMatcher.
comment|///
comment|/// Given:
comment|/// \code
comment|///   class A { void func(); };
comment|///   class B { void member(); };
comment|/// \endcode
comment|///
comment|/// \c cxxRecordDecl(hasMethod(hasName("func"))) matches the declaration of
comment|/// \c A but not \c B.
name|AST_MATCHER_P
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|hasMethod
argument_list|,
argument|internal::Matcher<CXXMethodDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|Node
operator|.
name|method_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|method_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the generated class of lambda expressions.
comment|///
comment|/// Given:
comment|/// \code
comment|///   auto x = []{};
comment|/// \endcode
comment|///
comment|/// \c cxxRecordDecl(isLambda()) matches the implicit class declaration of
comment|/// \c decltype(x)
name|AST_MATCHER
argument_list|(
argument|CXXRecordDecl
argument_list|,
argument|isLambda
argument_list|)
block|{
return|return
name|Node
operator|.
name|isLambda
argument_list|()
return|;
block|}
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y
comment|///   (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName("X")))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|/// \endcode
comment|///
comment|/// ChildT must be an AST base type.
comment|///
comment|/// Usable as: Any Matcher
comment|/// Note that has is direct matcher, so it also matches things like implicit
comment|/// casts and paren casts. If you are matching with expr then you should
comment|/// probably consider using ignoringParenImpCasts like:
comment|/// has(ignoringParenImpCasts(expr())).
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|HasMatcher
operator|>
name|LLVM_ATTRIBUTE_UNUSED
name|has
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y, Z
comment|///     (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName("X")))))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };
comment|/// \endcode
comment|///
comment|/// DescendantT must be an AST base type.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|HasDescendantMatcher
operator|>
name|LLVM_ATTRIBUTE_UNUSED
name|hasDescendant
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches AST nodes that have child AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, Y
comment|///   (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName("X")))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class Y { class X {}; };
comment|///   class Z { class Y { class X {}; }; };  // Does not match Z.
comment|/// \endcode
comment|///
comment|/// ChildT must be an AST base type.
comment|///
comment|/// As opposed to 'has', 'forEach' will cause a match for each result that
comment|/// matches instead of only on the first one.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|ForEachMatcher
operator|>
name|LLVM_ATTRIBUTE_UNUSED
name|forEach
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches AST nodes that have descendant AST nodes that match the
comment|/// provided matcher.
comment|///
comment|/// Example matches X, A, B, C
comment|///   (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName("X")))))
comment|/// \code
comment|///   class X {};  // Matches X, because X::X is a class of name X inside X.
comment|///   class A { class X {}; };
comment|///   class B { class C { class X {}; }; };
comment|/// \endcode
comment|///
comment|/// DescendantT must be an AST base type.
comment|///
comment|/// As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for
comment|/// each result that matches instead of only on the first one.
comment|///
comment|/// Note: Recursively combined ForEachDescendant can cause many matches:
comment|///   cxxRecordDecl(forEachDescendant(cxxRecordDecl(
comment|///     forEachDescendant(cxxRecordDecl())
comment|///   )))
comment|/// will match 10 times (plus injected class name matches) on:
comment|/// \code
comment|///   class A { class B { class C { class D { class E {}; }; }; }; };
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|ForEachDescendantMatcher
operator|>
name|LLVM_ATTRIBUTE_UNUSED
name|forEachDescendant
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches if the node or any descendant matches.
comment|///
comment|/// Generates results for each match.
comment|///
comment|/// For example, in:
comment|/// \code
comment|///   class A { class B {}; class C {}; };
comment|/// \endcode
comment|/// The matcher:
comment|/// \code
comment|///   cxxRecordDecl(hasName("::A"),
comment|///                 findAll(cxxRecordDecl(isDefinition()).bind("m")))
comment|/// \endcode
comment|/// will generate results for \c A, \c B and \c C.
comment|///
comment|/// Usable as: Any Matcher
name|template
operator|<
name|typename
name|T
operator|>
name|internal
operator|::
name|Matcher
operator|<
name|T
operator|>
name|findAll
argument_list|(
argument|const internal::Matcher<T>&Matcher
argument_list|)
block|{
return|return
name|eachOf
argument_list|(
name|Matcher
argument_list|,
name|forEachDescendant
argument_list|(
name|Matcher
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches AST nodes that have a parent that matches the provided
comment|/// matcher.
comment|///
comment|/// Given
comment|/// \code
comment|/// void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }
comment|/// \endcode
comment|/// \c compoundStmt(hasParent(ifStmt())) matches "{ int x = 43; }".
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|HasParentMatcher
operator|,
name|internal
operator|::
name|TypeList
operator|<
name|Decl
operator|,
name|NestedNameSpecifierLoc
operator|,
name|Stmt
operator|,
name|TypeLoc
operator|>
operator|,
name|internal
operator|::
name|TypeList
operator|<
name|Decl
operator|,
name|NestedNameSpecifierLoc
operator|,
name|Stmt
operator|,
name|TypeLoc
operator|>>
name|LLVM_ATTRIBUTE_UNUSED
name|hasParent
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches AST nodes that have an ancestor that matches the provided
comment|/// matcher.
comment|///
comment|/// Given
comment|/// \code
comment|/// void f() { if (true) { int x = 42; } }
comment|/// void g() { for (;;) { int x = 43; } }
comment|/// \endcode
comment|/// \c expr(integerLiteral(hasAncestor(ifStmt()))) matches \c 42, but not 43.
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|ArgumentAdaptingMatcherFunc
operator|<
name|internal
operator|::
name|HasAncestorMatcher
operator|,
name|internal
operator|::
name|TypeList
operator|<
name|Decl
operator|,
name|NestedNameSpecifierLoc
operator|,
name|Stmt
operator|,
name|TypeLoc
operator|>
operator|,
name|internal
operator|::
name|TypeList
operator|<
name|Decl
operator|,
name|NestedNameSpecifierLoc
operator|,
name|Stmt
operator|,
name|TypeLoc
operator|>>
name|LLVM_ATTRIBUTE_UNUSED
name|hasAncestor
operator|=
block|{}
expr_stmt|;
comment|/// \brief Matches if the provided matcher does not match.
comment|///
comment|/// Example matches Y (matcher = cxxRecordDecl(unless(hasName("X"))))
comment|/// \code
comment|///   class X {};
comment|///   class Y {};
comment|/// \endcode
comment|///
comment|/// Usable as: Any Matcher
specifier|const
name|internal
operator|::
name|VariadicOperatorMatcherFunc
operator|<
literal|1
operator|,
literal|1
operator|>
name|unless
operator|=
block|{
name|internal
operator|::
name|DynTypedMatcher
operator|::
name|VO_UnaryNot
block|}
expr_stmt|;
comment|/// \brief Matches a node if the declaration associated with that node
comment|/// matches the given matcher.
comment|///
comment|/// The associated declaration is:
comment|/// - for type nodes, the declaration of the underlying type
comment|/// - for CallExpr, the declaration of the callee
comment|/// - for MemberExpr, the declaration of the referenced member
comment|/// - for CXXConstructExpr, the declaration of the constructor
comment|/// - for CXXNewExpr, the declaration of the operator new
comment|///
comment|/// Also usable as Matcher<T> for any T supporting the getDecl() member
comment|/// function. e.g. various subtypes of clang::Type and various expressions.
comment|///
comment|/// Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,
comment|///   Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,
comment|///   Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,
comment|///   Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,
comment|///   Matcher<TagType>, Matcher<TemplateSpecializationType>,
comment|///   Matcher<TemplateTypeParmType>, Matcher<TypedefType>,
comment|///   Matcher<UnresolvedUsingType>
specifier|inline
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
operator|,
name|void
argument_list|(
name|internal
operator|::
name|HasDeclarationSupportedTypes
argument_list|)
operator|>
name|hasDeclaration
argument_list|(
argument|const internal::Matcher<Decl>&InnerMatcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|HasDeclarationMatcher
operator|,
name|internal
operator|::
name|Matcher
operator|<
name|Decl
operator|>
operator|,
name|void
argument_list|(
name|internal
operator|::
name|HasDeclarationSupportedTypes
argument_list|)
operator|>
operator|(
name|InnerMatcher
operator|)
return|;
block|}
comment|/// \brief Matches a \c NamedDecl whose underlying declaration matches the given
comment|/// matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace N { template<class T> void f(T t); }
comment|///   template<class T> void g() { using N::f; f(T()); }
comment|/// \endcode
comment|/// \c unresolvedLookupExpr(hasAnyDeclaration(
comment|///     namedDecl(hasUnderlyingDecl(hasName("::N::f")))))
comment|///   matches the use of \c f in \c g() .
name|AST_MATCHER_P
argument_list|(
argument|NamedDecl
argument_list|,
argument|hasUnderlyingDecl
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|NamedDecl
modifier|*
name|UnderlyingDecl
init|=
name|Node
operator|.
name|getUnderlyingDecl
argument_list|()
decl_stmt|;
return|return
name|UnderlyingDecl
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|UnderlyingDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches on the implicit object argument of a member call expression.
comment|///
comment|/// Example matches y.x()
comment|///   (matcher = cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("Y"))))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x(); }",
comment|/// \endcode
comment|///
comment|/// FIXME: Overload to allow directly matching types?
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|on
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|Node
operator|.
name|getImplicitObjectArgument
argument_list|()
operator|->
name|IgnoreParenImpCasts
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches on the receiver of an ObjectiveC Message expression.
comment|///
comment|/// Example
comment|/// matcher = objCMessageExpr(hasReceiverType(asString("UIWebView *")));
comment|/// matches the [webView ...] message invocation.
comment|/// \code
comment|///   NSString *webViewJavaScript = ...
comment|///   UIWebView *webView = ...
comment|///   [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|hasReceiverType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|TypeDecl
init|=
name|Node
operator|.
name|getReceiverType
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|TypeDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches when BaseName == Selector.getAsString()
comment|///
comment|///  matcher = objCMessageExpr(hasSelector("loadHTMLString:baseURL:"));
comment|///  matches the outer message expr in the code below, but NOT the message
comment|///  invocation for self.bodyView.
comment|/// \code
comment|///     [self.bodyView loadHTMLString:html baseURL:NULL];
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|hasSelector
argument_list|,
argument|std::string
argument_list|,
argument|BaseName
argument_list|)
block|{
name|Selector
name|Sel
init|=
name|Node
operator|.
name|getSelector
argument_list|()
decl_stmt|;
return|return
name|BaseName
operator|.
name|compare
argument_list|(
name|Sel
operator|.
name|getAsString
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/// \brief Matches ObjC selectors whose name contains
comment|/// a substring matched by the given RegExp.
comment|///  matcher = objCMessageExpr(matchesSelector("loadHTMLString\:baseURL?"));
comment|///  matches the outer message expr in the code below, but NOT the message
comment|///  invocation for self.bodyView.
comment|/// \code
comment|///     [self.bodyView loadHTMLString:html baseURL:NULL];
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|matchesSelector
argument_list|,
argument|std::string
argument_list|,
argument|RegExp
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|RegExp
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|SelectorString
operator|=
name|Node
operator|.
name|getSelector
argument_list|()
operator|.
name|getAsString
argument_list|()
expr_stmt|;
name|llvm
operator|::
name|Regex
name|RE
argument_list|(
name|RegExp
argument_list|)
expr_stmt|;
return|return
name|RE
operator|.
name|match
argument_list|(
name|SelectorString
argument_list|)
return|;
block|}
comment|/// \brief Matches when the selector is the empty selector
comment|///
comment|/// Matches only when the selector of the objCMessageExpr is NULL. This may
comment|/// represent an error condition in the tree!
name|AST_MATCHER
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|hasNullSelector
argument_list|)
block|{
return|return
name|Node
operator|.
name|getSelector
argument_list|()
operator|.
name|isNull
argument_list|()
return|;
block|}
comment|/// \brief Matches when the selector is a Unary Selector
comment|///
comment|///  matcher = objCMessageExpr(matchesSelector(hasUnarySelector());
comment|///  matches self.bodyView in the code below, but NOT the outer message
comment|///  invocation of "loadHTMLString:baseURL:".
comment|/// \code
comment|///     [self.bodyView loadHTMLString:html baseURL:NULL];
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|hasUnarySelector
argument_list|)
block|{
return|return
name|Node
operator|.
name|getSelector
argument_list|()
operator|.
name|isUnarySelector
argument_list|()
return|;
block|}
comment|/// \brief Matches when the selector is a keyword selector
comment|///
comment|/// objCMessageExpr(hasKeywordSelector()) matches the generated setFrame
comment|/// message expression in
comment|///
comment|/// \code
comment|///   UIWebView *webView = ...;
comment|///   CGRect bodyFrame = webView.frame;
comment|///   bodyFrame.size.height = self.bodyContentHeight;
comment|///   webView.frame = bodyFrame;
comment|///   //     ^---- matches here
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|hasKeywordSelector
argument_list|)
block|{
return|return
name|Node
operator|.
name|getSelector
argument_list|()
operator|.
name|isKeywordSelector
argument_list|()
return|;
block|}
comment|/// \brief Matches when the selector has the specified number of arguments
comment|///
comment|///  matcher = objCMessageExpr(numSelectorArgs(0));
comment|///  matches self.bodyView in the code below
comment|///
comment|///  matcher = objCMessageExpr(numSelectorArgs(2));
comment|///  matches the invocation of "loadHTMLString:baseURL:" but not that
comment|///  of self.bodyView
comment|/// \code
comment|///     [self.bodyView loadHTMLString:html baseURL:NULL];
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|ObjCMessageExpr
argument_list|,
argument|numSelectorArgs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|getSelector
argument_list|()
operator|.
name|getNumArgs
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches if the call expression's callee expression matches.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y { void x() { this->x(); x(); Y y; y.x(); } };
comment|///   void f() { f(); }
comment|/// \endcode
comment|/// callExpr(callee(expr()))
comment|///   matches this->x(), x(), y.x(), f()
comment|/// with callee(...)
comment|///   matching this->x, x, y.x, f respectively
comment|///
comment|/// Note: Callee cannot take the more general internal::Matcher<Expr>
comment|/// because this introduces ambiguous overloads with calls to Callee taking a
comment|/// internal::Matcher<Decl>, as the matcher hierarchy is purely
comment|/// implemented in terms of implicit casts.
name|AST_MATCHER_P
argument_list|(
argument|CallExpr
argument_list|,
argument|callee
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|Node
operator|.
name|getCallee
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the call expression's callee's declaration matches the
comment|/// given matcher.
comment|///
comment|/// Example matches y.x() (matcher = callExpr(callee(
comment|///                                    cxxMethodDecl(hasName("x")))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y y; y.x(); }
comment|/// \endcode
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CallExpr
argument_list|,
argument|callee
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|callExpr
argument_list|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the expression's or declaration's type matches a type
comment|/// matcher.
comment|///
comment|/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X")))))
comment|///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X")))))
comment|///             and U (matcher = typedefDecl(hasType(asString("int")))
comment|/// \code
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
comment|///  typedef int U;
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P_OVERLOAD
argument_list|(
argument|hasType
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, TypedefNameDecl, ValueDecl)
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|0
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|internal
operator|::
name|getUnderlyingType
argument_list|(
name|Node
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the declaration of the expression's or value
comment|/// declaration's type.
comment|///
comment|/// In case of a value declaration (for example a variable declaration),
comment|/// this resolves one layer of indirection. For example, in the value
comment|/// declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of
comment|/// X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the
comment|/// declaration of x.
comment|///
comment|/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X")))))
comment|///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X")))))
comment|/// \code
comment|///  class X {};
comment|///  void y(X&x) { x; X z; }
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<Expr>, Matcher<ValueDecl>
name|AST_POLYMORPHIC_MATCHER_P_OVERLOAD
argument_list|(
argument|hasType
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Expr,                                                                    ValueDecl)
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|qualType
argument_list|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the type location of the declarator decl's type matches
comment|/// the inner matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   int x;
comment|/// \endcode
comment|/// declaratorDecl(hasTypeLoc(loc(asString("int"))))
comment|///   matches int x
name|AST_MATCHER_P
argument_list|(
argument|DeclaratorDecl
argument_list|,
argument|hasTypeLoc
argument_list|,
argument|internal::Matcher<TypeLoc>
argument_list|,
argument|Inner
argument_list|)
block|{
if|if
condition|(
operator|!
name|Node
operator|.
name|getTypeSourceInfo
argument_list|()
condition|)
comment|// This happens for example for implicit destructors.
return|return
name|false
return|;
return|return
name|Inner
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getTypeSourceInfo
argument_list|()
operator|->
name|getTypeLoc
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is represented by the given string.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y* y; y->x(); }
comment|/// \endcode
comment|/// cxxMemberCallExpr(on(hasType(asString("class Y *"))))
comment|///   matches y->x()
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|asString
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|Name
operator|==
name|Node
operator|.
name|getAsString
argument_list|()
return|;
block|}
comment|/// \brief Matches if the matched type is a pointer type and the pointee type
comment|/// matches the specified matcher.
comment|///
comment|/// Example matches y->x()
comment|///   (matcher = cxxMemberCallExpr(on(hasType(pointsTo
comment|///      cxxRecordDecl(hasName("Y")))))))
comment|/// \code
comment|///   class Y { public: void x(); };
comment|///   void z() { Y *y; y->x(); }
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|pointsTo
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isAnyPointerType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Overloaded to match the pointee type's declaration.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|QualType
argument_list|,
argument|pointsTo
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|pointsTo
argument_list|(
name|qualType
argument_list|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type matches the unqualified desugared
comment|/// type of the matched node.
comment|///
comment|/// For example, in:
comment|/// \code
comment|///   class A {};
comment|///   using B = A;
comment|/// \endcode
comment|/// The matcher type(hasUniqualifeidDesugaredType(recordType())) matches
comment|/// both B and A.
name|AST_MATCHER_P
argument_list|(
argument|Type
argument_list|,
argument|hasUnqualifiedDesugaredType
argument_list|,
argument|internal::Matcher<Type>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getUnqualifiedDesugaredType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches if the matched type is a reference type and the referenced
comment|/// type matches the specified matcher.
comment|///
comment|/// Example matches X&x and const X&y
comment|///     (matcher = varDecl(hasType(references(cxxRecordDecl(hasName("X"))))))
comment|/// \code
comment|///   class X {
comment|///     void a(X b) {
comment|///       X&x = b;
comment|///       const X&y = b;
comment|///     }
comment|///   };
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|references
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
operator|!
name|Node
operator|.
name|isNull
argument_list|()
operator|&&
name|Node
operator|->
name|isReferenceType
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|->
name|getPointeeType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches QualTypes whose canonical type matches InnerMatcher.
comment|///
comment|/// Given:
comment|/// \code
comment|///   typedef int&int_ref;
comment|///   int a;
comment|///   int_ref b = a;
comment|/// \endcode
comment|///
comment|/// \c varDecl(hasType(qualType(referenceType()))))) will not match the
comment|/// declaration of b but \c
comment|/// varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does.
name|AST_MATCHER_P
argument_list|(
argument|QualType
argument_list|,
argument|hasCanonicalType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getCanonicalType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the referenced type's declaration.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|QualType
argument_list|,
argument|references
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|references
argument_list|(
name|qualType
argument_list|(
name|hasDeclaration
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
name|AST_MATCHER_P
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|onImplicitObjectArgument
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|ExprNode
init|=
name|Node
operator|.
name|getImplicitObjectArgument
argument_list|()
decl_stmt|;
return|return
operator|(
name|ExprNode
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|ExprNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the expression's type either matches the specified
comment|/// matcher, or is a pointer to a type that matches the InnerMatcher.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|thisPointerType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|0
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloaded to match the type's declaration.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|CXXMemberCallExpr
argument_list|,
argument|thisPointerType
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|onImplicitObjectArgument
argument_list|(
name|anyOf
argument_list|(
name|hasType
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasType
argument_list|(
name|pointsTo
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a DeclRefExpr that refers to a declaration that matches the
comment|/// specified matcher.
comment|///
comment|/// Example matches x in if(x)
comment|///     (matcher = declRefExpr(to(varDecl(hasName("x")))))
comment|/// \code
comment|///   bool x;
comment|///   if (x) {}
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|to
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Decl
modifier|*
name|DeclNode
init|=
name|Node
operator|.
name|getDecl
argument_list|()
decl_stmt|;
return|return
operator|(
name|DeclNode
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a \c DeclRefExpr that refers to a declaration through a
comment|/// specific using shadow declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace a { void f() {} }
comment|///   using a::f;
comment|///   void g() {
comment|///     f();     // Matches this ..
comment|///     a::f();  // .. but not this.
comment|///   }
comment|/// \endcode
comment|/// declRefExpr(throughUsingDecl(anything()))
comment|///   matches \c f()
name|AST_MATCHER_P
argument_list|(
argument|DeclRefExpr
argument_list|,
argument|throughUsingDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|NamedDecl
modifier|*
name|FoundDecl
init|=
name|Node
operator|.
name|getFoundDecl
argument_list|()
decl_stmt|;
if|if
condition|(
specifier|const
name|UsingShadowDecl
modifier|*
name|UsingDecl
init|=
name|dyn_cast
operator|<
name|UsingShadowDecl
operator|>
operator|(
name|FoundDecl
operator|)
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|UsingDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches an \c OverloadExpr if any of the declarations in the set of
comment|/// overloads matches the given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> void foo(T);
comment|///   template<typename T> void bar(T);
comment|///   template<typename T> void baz(T t) {
comment|///     foo(t);
comment|///     bar(t);
comment|///   }
comment|/// \endcode
comment|/// unresolvedLookupExpr(hasAnyDeclaration(
comment|///     functionTemplateDecl(hasName("foo"))))
comment|///   matches \c foo in \c foo(t); but not \c bar in \c bar(t);
name|AST_MATCHER_P
argument_list|(
argument|OverloadExpr
argument_list|,
argument|hasAnyDeclaration
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|Node
operator|.
name|decls_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|decls_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the Decl of a DeclStmt which has a single declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a, b;
comment|///   int c;
comment|/// \endcode
comment|/// declStmt(hasSingleDecl(anything()))
comment|///   matches 'int c;' but not 'int a, b;'.
name|AST_MATCHER_P
argument_list|(
argument|DeclStmt
argument_list|,
argument|hasSingleDecl
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|isSingleDecl
argument_list|()
condition|)
block|{
specifier|const
name|Decl
modifier|*
name|FoundDecl
init|=
name|Node
operator|.
name|getSingleDecl
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|FoundDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a variable declaration that has an initializer expression
comment|/// that matches the given matcher.
comment|///
comment|/// Example matches x (matcher = varDecl(hasInitializer(callExpr())))
comment|/// \code
comment|///   bool y() { return true; }
comment|///   bool x = y();
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|VarDecl
argument_list|,
argument|hasInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Initializer
init|=
name|Node
operator|.
name|getAnyInitializer
argument_list|()
decl_stmt|;
return|return
operator|(
name|Initializer
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Initializer
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a variable declaration that has function scope and is a
comment|/// non-static local variable.
comment|///
comment|/// Example matches x (matcher = varDecl(hasLocalStorage())
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|/// }
comment|/// int z;
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|hasLocalStorage
argument_list|)
block|{
return|return
name|Node
operator|.
name|hasLocalStorage
argument_list|()
return|;
block|}
comment|/// \brief Matches a variable declaration that does not have local storage.
comment|///
comment|/// Example matches y and z (matcher = varDecl(hasGlobalStorage())
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|/// }
comment|/// int z;
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|hasGlobalStorage
argument_list|)
block|{
return|return
name|Node
operator|.
name|hasGlobalStorage
argument_list|()
return|;
block|}
comment|/// \brief Matches a variable declaration that has automatic storage duration.
comment|///
comment|/// Example matches x, but not y, z, or a.
comment|/// (matcher = varDecl(hasAutomaticStorageDuration())
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|///   thread_local int z;
comment|/// }
comment|/// int a;
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|hasAutomaticStorageDuration
argument_list|)
block|{
return|return
name|Node
operator|.
name|getStorageDuration
argument_list|()
operator|==
name|SD_Automatic
return|;
block|}
comment|/// \brief Matches a variable declaration that has static storage duration.
comment|/// It includes the variable declared at namespace scope and those declared
comment|/// with "static" and "extern" storage class specifiers.
comment|///
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|///   thread_local int z;
comment|/// }
comment|/// int a;
comment|/// static int b;
comment|/// extern int c;
comment|/// varDecl(hasStaticStorageDuration())
comment|///   matches the function declaration y, a, b and c.
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|hasStaticStorageDuration
argument_list|)
block|{
return|return
name|Node
operator|.
name|getStorageDuration
argument_list|()
operator|==
name|SD_Static
return|;
block|}
comment|/// \brief Matches a variable declaration that has thread storage duration.
comment|///
comment|/// Example matches z, but not x, z, or a.
comment|/// (matcher = varDecl(hasThreadStorageDuration())
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|///   thread_local int z;
comment|/// }
comment|/// int a;
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|hasThreadStorageDuration
argument_list|)
block|{
return|return
name|Node
operator|.
name|getStorageDuration
argument_list|()
operator|==
name|SD_Thread
return|;
block|}
comment|/// \brief Matches a variable declaration that is an exception variable from
comment|/// a C++ catch block, or an Objective-C \@catch statement.
comment|///
comment|/// Example matches x (matcher = varDecl(isExceptionVariable())
comment|/// \code
comment|/// void f(int y) {
comment|///   try {
comment|///   } catch (int x) {
comment|///   }
comment|/// }
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|VarDecl
argument_list|,
argument|isExceptionVariable
argument_list|)
block|{
return|return
name|Node
operator|.
name|isExceptionVariable
argument_list|()
return|;
block|}
comment|/// \brief Checks that a call expression or a constructor call expression has
comment|/// a specific number of arguments (including absent default arguments).
comment|///
comment|/// Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2)))
comment|/// \code
comment|///   void f(int x, int y);
comment|///   f(0, 0);
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|argumentCountIs
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,                                                           CXXConstructExpr,                                                           ObjCMessageExpr)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches the n'th argument of a call expression or a constructor
comment|/// call expression.
comment|///
comment|/// Example matches y in x(y)
comment|///     (matcher = callExpr(hasArgument(0, declRefExpr())))
comment|/// \code
comment|///   void x(int) { int y; x(y); }
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P2
argument_list|(
argument|hasArgument
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,                                                            CXXConstructExpr,                                                            ObjCMessageExpr)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getArg
argument_list|(
name|N
argument_list|)
operator|->
name|IgnoreParenImpCasts
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches declaration statements that contain a specific number of
comment|/// declarations.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   int a, b;
comment|///   int c;
comment|///   int d = 2, e;
comment|/// \endcode
comment|/// declCountIs(2)
comment|///   matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'.
name|AST_MATCHER_P
argument_list|(
argument|DeclStmt
argument_list|,
argument|declCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|Node
operator|.
name|decl_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|decl_end
argument_list|()
argument_list|)
operator|==
operator|(
name|ptrdiff_t
operator|)
name|N
return|;
block|}
comment|/// \brief Matches the n'th declaration of a declaration statement.
comment|///
comment|/// Note that this does not work for global declarations because the AST
comment|/// breaks up multiple-declaration DeclStmt's into multiple single-declaration
comment|/// DeclStmt's.
comment|/// Example: Given non-global declarations
comment|/// \code
comment|///   int a, b = 0;
comment|///   int c;
comment|///   int d = 2, e;
comment|/// \endcode
comment|/// declStmt(containsDeclaration(
comment|///       0, varDecl(hasInitializer(anything()))))
comment|///   matches only 'int d = 2, e;', and
comment|/// declStmt(containsDeclaration(1, varDecl()))
comment|/// \code
comment|///   matches 'int a, b = 0' as well as 'int d = 2, e;'
comment|///   but 'int c;' is not matched.
comment|/// \endcode
name|AST_MATCHER_P2
argument_list|(
argument|DeclStmt
argument_list|,
argument|containsDeclaration
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|unsigned
name|NumDecls
init|=
name|std
operator|::
name|distance
argument_list|(
name|Node
operator|.
name|decl_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|decl_end
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|N
operator|>=
name|NumDecls
condition|)
return|return
name|false
return|;
name|DeclStmt
operator|::
name|const_decl_iterator
name|Iterator
operator|=
name|Node
operator|.
name|decl_begin
argument_list|()
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|Iterator
argument_list|,
name|N
argument_list|)
expr_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|*
name|Iterator
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a C++ catch statement that has a catch-all handler.
comment|///
comment|/// Given
comment|/// \code
comment|///   try {
comment|///     // ...
comment|///   } catch (int) {
comment|///     // ...
comment|///   } catch (...) {
comment|///     // ...
comment|///   }
comment|/// /endcode
comment|/// cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int).
name|AST_MATCHER
argument_list|(
argument|CXXCatchStmt
argument_list|,
argument|isCatchAll
argument_list|)
block|{
return|return
name|Node
operator|.
name|getExceptionDecl
argument_list|()
operator|==
name|nullptr
return|;
block|}
comment|/// \brief Matches a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// cxxRecordDecl(has(cxxConstructorDecl(
comment|///   hasAnyConstructorInitializer(anything())
comment|/// )))
comment|///   record matches Foo, hasAnyConstructorInitializer matches foo_(1)
name|AST_MATCHER_P
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|hasAnyConstructorInitializer
argument_list|,
argument|internal::Matcher<CXXCtorInitializer>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|Node
operator|.
name|init_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|init_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the field declaration of a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(
comment|///     forField(hasName("foo_"))))))
comment|///   matches Foo
comment|/// with forField matching foo_
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|forField
argument_list|,
argument|internal::Matcher<FieldDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|FieldDecl
modifier|*
name|NodeAsDecl
init|=
name|Node
operator|.
name|getMember
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsDecl
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsDecl
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the initializer expression of a constructor initializer.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() : foo_(1) { }
comment|///     int foo_;
comment|///   };
comment|/// \endcode
comment|/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(
comment|///     withInitializer(integerLiteral(equals(1)))))))
comment|///   matches Foo
comment|/// with withInitializer matching (1)
name|AST_MATCHER_P
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|withInitializer
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|NodeAsExpr
init|=
name|Node
operator|.
name|getInit
argument_list|()
decl_stmt|;
return|return
operator|(
name|NodeAsExpr
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NodeAsExpr
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches a constructor initializer if it is explicitly written in
comment|/// code (as opposed to implicitly added by the compiler).
comment|///
comment|/// Given
comment|/// \code
comment|///   struct Foo {
comment|///     Foo() { }
comment|///     Foo(int) : foo_("A") { }
comment|///     string foo_;
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(hasAnyConstructorInitializer(isWritten()))
comment|///   will match Foo(int), but not Foo()
name|AST_MATCHER
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|isWritten
argument_list|)
block|{
return|return
name|Node
operator|.
name|isWritten
argument_list|()
return|;
block|}
comment|/// \brief Matches a constructor initializer if it is initializing a base, as
comment|/// opposed to a member.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct B {};
comment|///   struct D : B {
comment|///     int I;
comment|///     D(int i) : I(i) {}
comment|///   };
comment|///   struct E : B {
comment|///     E() : B() {}
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer()))
comment|///   will match E(), but not match D(int).
name|AST_MATCHER
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|isBaseInitializer
argument_list|)
block|{
return|return
name|Node
operator|.
name|isBaseInitializer
argument_list|()
return|;
block|}
comment|/// \brief Matches a constructor initializer if it is initializing a member, as
comment|/// opposed to a base.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct B {};
comment|///   struct D : B {
comment|///     int I;
comment|///     D(int i) : I(i) {}
comment|///   };
comment|///   struct E : B {
comment|///     E() : B() {}
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer()))
comment|///   will match D(int), but not match E().
name|AST_MATCHER
argument_list|(
argument|CXXCtorInitializer
argument_list|,
argument|isMemberInitializer
argument_list|)
block|{
return|return
name|Node
operator|.
name|isMemberInitializer
argument_list|()
return|;
block|}
comment|/// \brief Matches any argument of a call expression or a constructor call
comment|/// expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void x(int, int, int) { int y; x(1, y, 42); }
comment|/// \endcode
comment|/// callExpr(hasAnyArgument(declRefExpr()))
comment|///   matches x(1, y, 42)
comment|/// with hasAnyArgument(...)
comment|///   matching y
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasAnyArgument
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,                                                           CXXConstructExpr)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
for|for
control|(
specifier|const
name|Expr
modifier|*
name|Arg
range|:
name|Node
operator|.
name|arguments
argument_list|()
control|)
block|{
name|BoundNodesTreeBuilder
name|Result
argument_list|(
operator|*
name|Builder
argument_list|)
decl_stmt|;
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Arg
argument_list|,
name|Finder
argument_list|,
operator|&
name|Result
argument_list|)
condition|)
block|{
operator|*
name|Builder
operator|=
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a constructor call expression which uses list initialization.
name|AST_MATCHER
argument_list|(
argument|CXXConstructExpr
argument_list|,
argument|isListInitialization
argument_list|)
block|{
return|return
name|Node
operator|.
name|isListInitialization
argument_list|()
return|;
block|}
comment|/// \brief Matches a constructor call expression which requires
comment|/// zero initialization.
comment|///
comment|/// Given
comment|/// \code
comment|/// void foo() {
comment|///   struct point { double x; double y; };
comment|///   point pt[2] = { { 1.0, 2.0 } };
comment|/// }
comment|/// \endcode
comment|/// initListExpr(has(cxxConstructExpr(requiresZeroInitialization()))
comment|/// will match the implicit array filler for pt[1].
name|AST_MATCHER
argument_list|(
argument|CXXConstructExpr
argument_list|,
argument|requiresZeroInitialization
argument_list|)
block|{
return|return
name|Node
operator|.
name|requiresZeroInitialization
argument_list|()
return|;
block|}
comment|/// \brief Matches the n'th parameter of a function declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { void f(int x) {} };
comment|/// \endcode
comment|/// cxxMethodDecl(hasParameter(0, hasType(varDecl())))
comment|///   matches f(int x) {}
comment|/// with hasParameter(...)
comment|///   matching int x
name|AST_MATCHER_P2
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasParameter
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
operator|(
name|N
operator|<
name|Node
operator|.
name|getNumParams
argument_list|()
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getParamDecl
argument_list|(
name|N
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches all arguments and their respective ParmVarDecl.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f(int i);
comment|///   int y;
comment|///   f(y);
comment|/// \endcode
comment|/// callExpr(
comment|///   forEachArgumentWithParam(
comment|///     declRefExpr(to(varDecl(hasName("y")))),
comment|///     parmVarDecl(hasType(isInteger()))
comment|/// ))
comment|///   matches f(y);
comment|/// with declRefExpr(...)
comment|///   matching int y
comment|/// and parmVarDecl(...)
comment|///   matching int i
name|AST_POLYMORPHIC_MATCHER_P2
argument_list|(
argument|forEachArgumentWithParam
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,                                                            CXXConstructExpr)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|ArgMatcher
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|ParamMatcher
argument_list|)
block|{
name|BoundNodesTreeBuilder
name|Result
decl_stmt|;
comment|// The first argument of an overloaded member operator is the implicit object
comment|// argument of the method which should not be matched against a parameter, so
comment|// we skip over it here.
name|BoundNodesTreeBuilder
name|Matches
decl_stmt|;
name|unsigned
name|ArgIndex
init|=
name|cxxOperatorCallExpr
argument_list|(
name|callee
argument_list|(
name|cxxMethodDecl
argument_list|()
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
operator|&
name|Matches
argument_list|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|ParamIndex
init|=
literal|0
decl_stmt|;
name|bool
name|Matched
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
name|ArgIndex
operator|<
name|Node
operator|.
name|getNumArgs
argument_list|()
condition|;
operator|++
name|ArgIndex
control|)
block|{
name|BoundNodesTreeBuilder
name|ArgMatches
argument_list|(
operator|*
name|Builder
argument_list|)
decl_stmt|;
if|if
condition|(
name|ArgMatcher
operator|.
name|matches
argument_list|(
operator|*
operator|(
name|Node
operator|.
name|getArg
argument_list|(
name|ArgIndex
argument_list|)
operator|->
name|IgnoreParenCasts
argument_list|()
operator|)
argument_list|,
name|Finder
argument_list|,
operator|&
name|ArgMatches
argument_list|)
condition|)
block|{
name|BoundNodesTreeBuilder
name|ParamMatches
parameter_list|(
name|ArgMatches
parameter_list|)
function_decl|;
if|if
condition|(
name|expr
argument_list|(
name|anyOf
argument_list|(
name|cxxConstructExpr
argument_list|(
name|hasDeclaration
argument_list|(
name|cxxConstructorDecl
argument_list|(
name|hasParameter
argument_list|(
name|ParamIndex
argument_list|,
name|ParamMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|callExpr
argument_list|(
name|callee
argument_list|(
name|functionDecl
argument_list|(
name|hasParameter
argument_list|(
name|ParamIndex
argument_list|,
name|ParamMatcher
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|matches
argument_list|(
name|Node
argument_list|,
name|Finder
argument_list|,
operator|&
name|ParamMatches
argument_list|)
condition|)
block|{
name|Result
operator|.
name|addMatch
argument_list|(
name|ParamMatches
argument_list|)
expr_stmt|;
name|Matched
operator|=
name|true
expr_stmt|;
block|}
block|}
operator|++
name|ParamIndex
expr_stmt|;
block|}
operator|*
name|Builder
operator|=
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
expr_stmt|;
return|return
name|Matched
return|;
block|}
comment|/// \brief Matches any parameter of a function declaration.
comment|///
comment|/// Does not match the 'this' parameter of a method.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { void f(int x, int y, int z) {} };
comment|/// \endcode
comment|/// cxxMethodDecl(hasAnyParameter(hasName("y")))
comment|///   matches f(int x, int y, int z) {}
comment|/// with hasAnyParameter(...)
comment|///   matching int y
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|hasAnyParameter
argument_list|,
argument|internal::Matcher<ParmVarDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|Node
operator|.
name|param_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|param_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches \c FunctionDecls and \c FunctionProtoTypes that have a
comment|/// specific parameter count.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f(int i) {}
comment|///   void g(int i, int j) {}
comment|///   void h(int i, int j);
comment|///   void j(int i);
comment|///   void k(int x, int y, int z, ...);
comment|/// \endcode
comment|/// functionDecl(parameterCountIs(2))
comment|///   matches void g(int i, int j) {}
comment|/// functionProtoType(parameterCountIs(2))
comment|///   matches void h(int i, int j)
comment|/// functionProtoType(parameterCountIs(3))
comment|///   matches void k(int x, int y, int z, ...);
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|parameterCountIs
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,                                                           FunctionProtoType)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|getNumParams
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches the return type of a function declaration.
comment|///
comment|/// Given:
comment|/// \code
comment|///   class X { int f() { return 1; } };
comment|/// \endcode
comment|/// cxxMethodDecl(returns(asString("int")))
comment|///   matches int f() { return 1; }
name|AST_MATCHER_P
argument_list|(
argument|FunctionDecl
argument_list|,
argument|returns
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getReturnType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches extern "C" function declarations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   extern "C" void f() {}
comment|///   extern "C" { void g() {} }
comment|///   void h() {}
comment|/// \endcode
comment|/// functionDecl(isExternC())
comment|///   matches the declaration of f and g, but not the declaration h
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isExternC
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,                                                                    VarDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|isExternC
argument_list|()
return|;
block|}
comment|/// \brief Matches variable/function declarations that have "static" storage
comment|/// class specifier ("static" keyword) written in the source.
comment|///
comment|/// Given:
comment|/// \code
comment|///   static void f() {}
comment|///   static int i = 0;
comment|///   extern int j;
comment|///   int k;
comment|/// \endcode
comment|/// functionDecl(isStaticStorageClass())
comment|///   matches the function declaration f.
comment|/// varDecl(isStaticStorageClass())
comment|///   matches the variable declaration i.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isStaticStorageClass
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,                                                         VarDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|getStorageClass
argument_list|()
operator|==
name|SC_Static
return|;
block|}
comment|/// \brief Matches deleted function declarations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   void Func();
comment|///   void DeletedFunc() = delete;
comment|/// \endcode
comment|/// functionDecl(isDeleted())
comment|///   matches the declaration of DeletedFunc, but not Func.
name|AST_MATCHER
argument_list|(
argument|FunctionDecl
argument_list|,
argument|isDeleted
argument_list|)
block|{
return|return
name|Node
operator|.
name|isDeleted
argument_list|()
return|;
block|}
comment|/// \brief Matches defaulted function declarations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   class A { ~A(); };
comment|///   class B { ~B() = default; };
comment|/// \endcode
comment|/// functionDecl(isDefaulted())
comment|///   matches the declaration of ~B, but not ~A.
name|AST_MATCHER
argument_list|(
argument|FunctionDecl
argument_list|,
argument|isDefaulted
argument_list|)
block|{
return|return
name|Node
operator|.
name|isDefaulted
argument_list|()
return|;
block|}
comment|/// \brief Matches functions that have a dynamic exception specification.
comment|///
comment|/// Given:
comment|/// \code
comment|///   void f();
comment|///   void g() noexcept;
comment|///   void h() noexcept(true);
comment|///   void i() noexcept(false);
comment|///   void j() throw();
comment|///   void k() throw(int);
comment|///   void l() throw(...);
comment|/// \endcode
comment|/// functionDecl(hasDynamicExceptionSpec()) and
comment|///   functionProtoType(hasDynamicExceptionSpec())
comment|///   match the declarations of j, k, and l, but not f, g, h, or i.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|hasDynamicExceptionSpec
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,                                                         FunctionProtoType)
argument_list|)
block|{
if|if
condition|(
specifier|const
name|FunctionProtoType
modifier|*
name|FnTy
init|=
name|internal
operator|::
name|getFunctionProtoType
argument_list|(
name|Node
argument_list|)
condition|)
return|return
name|FnTy
operator|->
name|hasDynamicExceptionSpec
argument_list|()
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches functions that have a non-throwing exception specification.
comment|///
comment|/// Given:
comment|/// \code
comment|///   void f();
comment|///   void g() noexcept;
comment|///   void h() throw();
comment|///   void i() throw(int);
comment|///   void j() noexcept(false);
comment|/// \endcode
comment|/// functionDecl(isNoThrow()) and functionProtoType(isNoThrow())
comment|///   match the declarations of g, and h, but not f, i or j.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isNoThrow
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,                                                         FunctionProtoType)
argument_list|)
block|{
specifier|const
name|FunctionProtoType
modifier|*
name|FnTy
init|=
name|internal
operator|::
name|getFunctionProtoType
argument_list|(
name|Node
argument_list|)
decl_stmt|;
comment|// If the function does not have a prototype, then it is assumed to be a
comment|// throwing function (as it would if the function did not have any exception
comment|// specification).
if|if
condition|(
operator|!
name|FnTy
condition|)
return|return
name|false
return|;
comment|// Assume the best for any unresolved exception specification.
if|if
condition|(
name|isUnresolvedExceptionSpec
argument_list|(
name|FnTy
operator|->
name|getExceptionSpecType
argument_list|()
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|FnTy
operator|->
name|isNothrow
argument_list|(
name|Finder
operator|->
name|getASTContext
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Matches constexpr variable and function declarations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   constexpr int foo = 42;
comment|///   constexpr int bar();
comment|/// \endcode
comment|/// varDecl(isConstexpr())
comment|///   matches the declaration of foo.
comment|/// functionDecl(isConstexpr())
comment|///   matches the declaration of bar.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isConstexpr
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(VarDecl,                                                         FunctionDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|isConstexpr
argument_list|()
return|;
block|}
comment|/// \brief Matches the condition expression of an if statement, for loop,
comment|/// switch statement or conditional operator.
comment|///
comment|/// Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true))))
comment|/// \code
comment|///   if (true) {}
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasCondition
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, ForStmt, WhileStmt, DoStmt,                                     SwitchStmt, AbstractConditionalOperator)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|Condition
init|=
name|Node
operator|.
name|getCond
argument_list|()
decl_stmt|;
return|return
operator|(
name|Condition
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Condition
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the then-statement of an if statement.
comment|///
comment|/// Examples matches the if statement
comment|///   (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true)))))
comment|/// \code
comment|///   if (false) true; else false;
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|IfStmt
argument_list|,
argument|hasThen
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Then
init|=
name|Node
operator|.
name|getThen
argument_list|()
decl_stmt|;
return|return
operator|(
name|Then
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Then
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the else-statement of an if statement.
comment|///
comment|/// Examples matches the if statement
comment|///   (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true)))))
comment|/// \code
comment|///   if (false) false; else true;
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|IfStmt
argument_list|,
argument|hasElse
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Else
init|=
name|Node
operator|.
name|getElse
argument_list|()
decl_stmt|;
return|return
operator|(
name|Else
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Else
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if a node equals a previously bound node.
comment|///
comment|/// Matches a node if it equals the node previously bound to \p ID.
comment|///
comment|/// Given
comment|/// \code
comment|///   class X { int a; int b; };
comment|/// \endcode
comment|/// cxxRecordDecl(
comment|///     has(fieldDecl(hasName("a"), hasType(type().bind("t")))),
comment|///     has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t"))))))
comment|///   matches the class \c X, as \c a and \c b have the same type.
comment|///
comment|/// Note that when multiple matches are involved via \c forEach* matchers,
comment|/// \c equalsBoundNodes acts as a filter.
comment|/// For example:
comment|/// compoundStmt(
comment|///     forEachDescendant(varDecl().bind("d")),
comment|///     forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d"))))))
comment|/// will trigger a match for each combination of variable declaration
comment|/// and reference to that variable declaration within a compound statement.
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|equalsBoundNode
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(Stmt, Decl, Type,                                                           QualType)
argument_list|,
argument|std::string
argument_list|,
argument|ID
argument_list|)
block|{
comment|// FIXME: Figure out whether it makes sense to allow this
comment|// on any other node types.
comment|// For *Loc it probably does not make sense, as those seem
comment|// unique. For NestedNameSepcifier it might make sense, as
comment|// those also have pointer identity, but I'm not sure whether
comment|// they're ever reused.
name|internal
operator|::
name|NotEqualsBoundNodePredicate
name|Predicate
expr_stmt|;
name|Predicate
operator|.
name|ID
operator|=
name|ID
expr_stmt|;
name|Predicate
operator|.
name|Node
operator|=
name|ast_type_traits
operator|::
name|DynTypedNode
operator|::
name|create
argument_list|(
name|Node
argument_list|)
expr_stmt|;
return|return
name|Builder
operator|->
name|removeBindings
argument_list|(
name|Predicate
argument_list|)
return|;
block|}
comment|/// \brief Matches the condition variable statement in an if statement.
comment|///
comment|/// Given
comment|/// \code
comment|///   if (A* a = GetAPointer()) {}
comment|/// \endcode
comment|/// hasConditionVariableStatement(...)
comment|///   matches 'A* a = GetAPointer()'.
name|AST_MATCHER_P
argument_list|(
argument|IfStmt
argument_list|,
argument|hasConditionVariableStatement
argument_list|,
argument|internal::Matcher<DeclStmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|DeclStmt
modifier|*
specifier|const
name|DeclarationStatement
init|=
name|Node
operator|.
name|getConditionVariableDeclStmt
argument_list|()
decl_stmt|;
return|return
name|DeclarationStatement
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|DeclarationStatement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches the index expression of an array subscript expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// \endcode
comment|/// arraySubscriptExpression(hasIndex(integerLiteral()))
comment|///   matches \c i[1] with the \c integerLiteral() matching \c 1
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasIndex
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getIdx
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches the base expression of an array subscript expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   int i[5];
comment|///   void f() { i[1] = 42; }
comment|/// \endcode
comment|/// arraySubscriptExpression(hasBase(implicitCastExpr(
comment|///     hasSourceExpression(declRefExpr()))))
comment|///   matches \c i[1] with the \c declRefExpr() matching \c i
name|AST_MATCHER_P
argument_list|(
argument|ArraySubscriptExpr
argument_list|,
argument|hasBase
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getBase
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches a 'for', 'while', 'do while' statement or a function
comment|/// definition that has a given body.
comment|///
comment|/// Given
comment|/// \code
comment|///   for (;;) {}
comment|/// \endcode
comment|/// hasBody(compoundStmt())
comment|///   matches 'for (;;) {}'
comment|/// with compoundStmt()
comment|///   matching '{}'
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasBody
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(DoStmt, ForStmt,                                                           WhileStmt,                                                           CXXForRangeStmt,                                                           FunctionDecl)
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Stmt
modifier|*
specifier|const
name|Statement
init|=
name|internal
operator|::
name|GetBodyMatcher
operator|<
name|NodeType
operator|>
operator|::
name|get
argument_list|(
name|Node
argument_list|)
decl_stmt|;
return|return
operator|(
name|Statement
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Statement
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches compound statements where at least one substatement matches
comment|/// a given matcher. Also matches StmtExprs that have CompoundStmt as children.
comment|///
comment|/// Given
comment|/// \code
comment|///   { {}; 1+2; }
comment|/// \endcode
comment|/// hasAnySubstatement(compoundStmt())
comment|///   matches '{ {}; 1+2; }'
comment|/// with compoundStmt()
comment|///   matching '{}'
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasAnySubstatement
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CompoundStmt,                                                           StmtExpr)
argument_list|,
argument|internal::Matcher<Stmt>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|CompoundStmt
modifier|*
name|CS
init|=
name|CompoundStmtMatcher
operator|<
name|NodeType
operator|>
operator|::
name|get
argument_list|(
name|Node
argument_list|)
decl_stmt|;
return|return
name|CS
operator|&&
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|CS
operator|->
name|body_begin
argument_list|()
argument_list|,
name|CS
operator|->
name|body_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Checks that a compound statement contains a specific number of
comment|/// child statements.
comment|///
comment|/// Example: Given
comment|/// \code
comment|///   { for (;;) {} }
comment|/// \endcode
comment|/// compoundStmt(statementCountIs(0)))
comment|///   matches '{}'
comment|///   but does not match the outer compound statement.
name|AST_MATCHER_P
argument_list|(
argument|CompoundStmt
argument_list|,
argument|statementCountIs
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|Node
operator|.
name|size
argument_list|()
operator|==
name|N
return|;
block|}
comment|/// \brief Matches literals that are equal to the given value of type ValueT.
comment|///
comment|/// Given
comment|/// \code
comment|///   f('\0', false, 3.14, 42);
comment|/// \endcode
comment|/// characterLiteral(equals(0))
comment|///   matches '\0'
comment|/// cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0))
comment|///   match false
comment|/// floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2))
comment|///   match 3.14
comment|/// integerLiteral(equals(42))
comment|///   matches 42
comment|///
comment|/// Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,
comment|///            Matcher<FloatingLiteral>, Matcher<IntegerLiteral>
name|template
operator|<
name|typename
name|ValueT
operator|>
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
name|equals
argument_list|(
argument|const ValueT&Value
argument_list|)
block|{
return|return
name|internal
operator|::
name|PolymorphicMatcherWithParam1
operator|<
name|internal
operator|::
name|ValueEqualsMatcher
operator|,
name|ValueT
operator|>
operator|(
name|Value
operator|)
return|;
block|}
name|AST_POLYMORPHIC_MATCHER_P_OVERLOAD
argument_list|(
argument|equals
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,                                                           CXXBoolLiteralExpr,                                                           IntegerLiteral)
argument_list|,
argument|bool
argument_list|,
argument|Value
argument_list|,
literal|0
argument_list|)
block|{
return|return
name|internal
operator|::
name|ValueEqualsMatcher
operator|<
name|NodeType
operator|,
name|ParamT
operator|>
operator|(
name|Value
operator|)
operator|.
name|matchesNode
argument_list|(
name|Node
argument_list|)
return|;
block|}
name|AST_POLYMORPHIC_MATCHER_P_OVERLOAD
argument_list|(
argument|equals
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,                                                           CXXBoolLiteralExpr,                                                           IntegerLiteral)
argument_list|,
argument|unsigned
argument_list|,
argument|Value
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|internal
operator|::
name|ValueEqualsMatcher
operator|<
name|NodeType
operator|,
name|ParamT
operator|>
operator|(
name|Value
operator|)
operator|.
name|matchesNode
argument_list|(
name|Node
argument_list|)
return|;
block|}
name|AST_POLYMORPHIC_MATCHER_P_OVERLOAD
argument_list|(
argument|equals
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,                                                           CXXBoolLiteralExpr,                                                           FloatingLiteral,                                                           IntegerLiteral)
argument_list|,
argument|double
argument_list|,
argument|Value
argument_list|,
literal|2
argument_list|)
block|{
return|return
name|internal
operator|::
name|ValueEqualsMatcher
operator|<
name|NodeType
operator|,
name|ParamT
operator|>
operator|(
name|Value
operator|)
operator|.
name|matchesNode
argument_list|(
name|Node
argument_list|)
return|;
block|}
comment|/// \brief Matches the operator Name of operator expressions (binary or
comment|/// unary).
comment|///
comment|/// Example matches a || b (matcher = binaryOperator(hasOperatorName("||")))
comment|/// \code
comment|///   !(a || b)
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasOperatorName
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator,                                                           UnaryOperator)
argument_list|,
argument|std::string
argument_list|,
argument|Name
argument_list|)
block|{
return|return
name|Name
operator|==
name|Node
operator|.
name|getOpcodeStr
argument_list|(
name|Node
operator|.
name|getOpcode
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Matches the left hand side of binary operator expressions.
comment|///
comment|/// Example matches a (matcher = binaryOperator(hasLHS()))
comment|/// \code
comment|///   a || b
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasLHS
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator,                                                           ArraySubscriptExpr)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|LeftHandSide
init|=
name|Node
operator|.
name|getLHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|LeftHandSide
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|LeftHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the right hand side of binary operator expressions.
comment|///
comment|/// Example matches b (matcher = binaryOperator(hasRHS()))
comment|/// \code
comment|///   a || b
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasRHS
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator,                                                           ArraySubscriptExpr)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|RightHandSide
init|=
name|Node
operator|.
name|getRHS
argument_list|()
decl_stmt|;
return|return
operator|(
name|RightHandSide
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|RightHandSide
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if either the left hand side or the right hand side of a
comment|/// binary operator matches.
specifier|inline
name|internal
operator|::
name|Matcher
operator|<
name|BinaryOperator
operator|>
name|hasEitherOperand
argument_list|(
argument|const internal::Matcher<Expr>&InnerMatcher
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|hasLHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|,
name|hasRHS
argument_list|(
name|InnerMatcher
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches if the operand of a unary operator matches.
comment|///
comment|/// Example matches true (matcher = hasUnaryOperand(
comment|///                                   cxxBoolLiteral(equals(true))))
comment|/// \code
comment|///   !true
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|UnaryOperator
argument_list|,
argument|hasUnaryOperand
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|Operand
init|=
name|Node
operator|.
name|getSubExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Operand
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Operand
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if the cast's source expression
comment|/// or opaque value's source expression matches the given matcher.
comment|///
comment|/// Example 1: matches "a string"
comment|/// (matcher = castExpr(hasSourceExpression(cxxConstructExpr())))
comment|/// \code
comment|/// class URL { URL(string); };
comment|/// URL url = "a string";
comment|/// \endcode
comment|///
comment|/// Example 2: matches 'b' (matcher =
comment|/// opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr())))
comment|/// \code
comment|/// int a = b ?: 1;
comment|/// \endcode
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasSourceExpression
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CastExpr,                                                           OpaqueValueExpr)
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
specifier|const
name|SubExpression
init|=
name|internal
operator|::
name|GetSourceExpressionMatcher
operator|<
name|NodeType
operator|>
operator|::
name|get
argument_list|(
name|Node
argument_list|)
decl_stmt|;
return|return
operator|(
name|SubExpression
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|SubExpression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches casts that has a given cast kind.
comment|///
comment|/// Example: matches the implicit cast around \c 0
comment|/// (matcher = castExpr(hasCastKind(CK_NullToPointer)))
comment|/// \code
comment|///   int *p = 0;
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CastExpr
argument_list|,
argument|hasCastKind
argument_list|,
argument|CastKind
argument_list|,
argument|Kind
argument_list|)
block|{
return|return
name|Node
operator|.
name|getCastKind
argument_list|()
operator|==
name|Kind
return|;
block|}
comment|/// \brief Matches casts whose destination type matches a given matcher.
comment|///
comment|/// (Note: Clang's AST refers to other conversions as "casts" too, and calls
comment|/// actual casts "explicit" casts.)
name|AST_MATCHER_P
argument_list|(
argument|ExplicitCastExpr
argument_list|,
argument|hasDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|QualType
name|NodeType
init|=
name|Node
operator|.
name|getTypeAsWritten
argument_list|()
decl_stmt|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|NodeType
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches implicit casts whose destination type matches a given
comment|/// matcher.
comment|///
comment|/// FIXME: Unit test this matcher
name|AST_MATCHER_P
argument_list|(
argument|ImplicitCastExpr
argument_list|,
argument|hasImplicitDestinationType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches RecordDecl object that are spelled with "struct."
comment|///
comment|/// Example matches S, but not C or U.
comment|/// \code
comment|///   struct S {};
comment|///   class C {};
comment|///   union U {};
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|RecordDecl
argument_list|,
argument|isStruct
argument_list|)
block|{
return|return
name|Node
operator|.
name|isStruct
argument_list|()
return|;
block|}
comment|/// \brief Matches RecordDecl object that are spelled with "union."
comment|///
comment|/// Example matches U, but not C or S.
comment|/// \code
comment|///   struct S {};
comment|///   class C {};
comment|///   union U {};
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|RecordDecl
argument_list|,
argument|isUnion
argument_list|)
block|{
return|return
name|Node
operator|.
name|isUnion
argument_list|()
return|;
block|}
comment|/// \brief Matches RecordDecl object that are spelled with "class."
comment|///
comment|/// Example matches C, but not S or U.
comment|/// \code
comment|///   struct S {};
comment|///   class C {};
comment|///   union U {};
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|RecordDecl
argument_list|,
argument|isClass
argument_list|)
block|{
return|return
name|Node
operator|.
name|isClass
argument_list|()
return|;
block|}
comment|/// \brief Matches the true branch expression of a conditional operator.
comment|///
comment|/// Example 1 (conditional ternary operator): matches a
comment|/// \code
comment|///   condition ? a : b
comment|/// \endcode
comment|///
comment|/// Example 2 (conditional binary operator): matches opaqueValueExpr(condition)
comment|/// \code
comment|///   condition ?: b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|AbstractConditionalOperator
argument_list|,
argument|hasTrueExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getTrueExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches the false branch expression of a conditional operator
comment|/// (binary or ternary).
comment|///
comment|/// Example matches b
comment|/// \code
comment|///   condition ? a : b
comment|///   condition ?: b
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|AbstractConditionalOperator
argument_list|,
argument|hasFalseExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|Expr
modifier|*
name|Expression
init|=
name|Node
operator|.
name|getFalseExpr
argument_list|()
decl_stmt|;
return|return
operator|(
name|Expression
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Expression
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches if a declaration has a body attached.
comment|///
comment|/// Example matches A, va, fa
comment|/// \code
comment|///   class A {};
comment|///   class B;  // Doesn't match, as it has no body.
comment|///   int va;
comment|///   extern int vb;  // Doesn't match, as it doesn't define the variable.
comment|///   void fa() {}
comment|///   void fb();  // Doesn't match, as it has no body.
comment|/// \endcode
comment|///
comment|/// Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isDefinition
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(TagDecl, VarDecl,                                                         FunctionDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|isThisDeclarationADefinition
argument_list|()
return|;
block|}
comment|/// \brief Matches if a function declaration is variadic.
comment|///
comment|/// Example matches f, but not g or h. The function i will not match, even when
comment|/// compiled in C mode.
comment|/// \code
comment|///   void f(...);
comment|///   void g(int);
comment|///   template<typename... Ts> void h(Ts...);
comment|///   void i();
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|FunctionDecl
argument_list|,
argument|isVariadic
argument_list|)
block|{
return|return
name|Node
operator|.
name|isVariadic
argument_list|()
return|;
block|}
comment|/// \brief Matches the class declaration that the given method declaration
comment|/// belongs to.
comment|///
comment|/// FIXME: Generalize this for other kinds of declarations.
comment|/// FIXME: What other kind of declarations would we need to generalize
comment|/// this to?
comment|///
comment|/// Example matches A() in the last line
comment|///     (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl(
comment|///         ofClass(hasName("A"))))))
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     A();
comment|///   };
comment|///   A a = A();
comment|/// \endcode
name|AST_MATCHER_P
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|ofClass
argument_list|,
argument|internal::Matcher<CXXRecordDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|CXXRecordDecl
modifier|*
name|Parent
init|=
name|Node
operator|.
name|getParent
argument_list|()
decl_stmt|;
return|return
operator|(
name|Parent
operator|!=
name|nullptr
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Parent
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches each method overriden by the given method. This matcher may
comment|/// produce multiple matches.
comment|///
comment|/// Given
comment|/// \code
comment|///   class A { virtual void f(); };
comment|///   class B : public A { void f(); };
comment|///   class C : public B { void f(); };
comment|/// \endcode
comment|/// cxxMethodDecl(ofClass(hasName("C")),
comment|///               forEachOverridden(cxxMethodDecl().bind("b"))).bind("d")
comment|///   matches once, with "b" binding "A::f" and "d" binding "C::f" (Note
comment|///   that B::f is not overridden by C::f).
comment|///
comment|/// The check can produce multiple matches in case of multiple inheritance, e.g.
comment|/// \code
comment|///   class A1 { virtual void f(); };
comment|///   class A2 { virtual void f(); };
comment|///   class C : public A1, public A2 { void f(); };
comment|/// \endcode
comment|/// cxxMethodDecl(ofClass(hasName("C")),
comment|///               forEachOverridden(cxxMethodDecl().bind("b"))).bind("d")
comment|///   matches twice, once with "b" binding "A1::f" and "d" binding "C::f", and
comment|///   once with "b" binding "A2::f" and "d" binding "C::f".
name|AST_MATCHER_P
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|forEachOverridden
argument_list|,
argument|internal::Matcher<CXXMethodDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|BoundNodesTreeBuilder
name|Result
decl_stmt|;
name|bool
name|Matched
init|=
name|false
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|Overridden
range|:
name|Node
operator|.
name|overridden_methods
argument_list|()
control|)
block|{
name|BoundNodesTreeBuilder
name|OverriddenBuilder
argument_list|(
operator|*
name|Builder
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|OverriddenMatched
init|=
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Overridden
argument_list|,
name|Finder
argument_list|,
operator|&
name|OverriddenBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
name|OverriddenMatched
condition|)
block|{
name|Matched
operator|=
name|true
expr_stmt|;
name|Result
operator|.
name|addMatch
argument_list|(
name|OverriddenBuilder
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|Builder
operator|=
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
expr_stmt|;
return|return
name|Matched
return|;
block|}
comment|/// \brief Matches if the given method declaration is virtual.
comment|///
comment|/// Given
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     virtual void x();
comment|///   };
comment|/// \endcode
comment|///   matches A::x
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isVirtual
argument_list|)
block|{
return|return
name|Node
operator|.
name|isVirtual
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method declaration has an explicit "virtual".
comment|///
comment|/// Given
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     virtual void x();
comment|///   };
comment|///   class B : public A {
comment|///    public:
comment|///     void x();
comment|///   };
comment|/// \endcode
comment|///   matches A::x but not B::x
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isVirtualAsWritten
argument_list|)
block|{
return|return
name|Node
operator|.
name|isVirtualAsWritten
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method or class declaration is final.
comment|///
comment|/// Given:
comment|/// \code
comment|///   class A final {};
comment|///
comment|///   struct B {
comment|///     virtual void f();
comment|///   };
comment|///
comment|///   struct C : B {
comment|///     void f() final;
comment|///   };
comment|/// \endcode
comment|/// matches A and C::f, but not B, C, or B::f
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isFinal
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl,                                                         CXXMethodDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|template
name|hasAttr
operator|<
name|FinalAttr
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches if the given method declaration is pure.
comment|///
comment|/// Given
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     virtual void x() = 0;
comment|///   };
comment|/// \endcode
comment|///   matches A::x
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isPure
argument_list|)
block|{
return|return
name|Node
operator|.
name|isPure
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method declaration is const.
comment|///
comment|/// Given
comment|/// \code
comment|/// struct A {
comment|///   void foo() const;
comment|///   void bar();
comment|/// };
comment|/// \endcode
comment|///
comment|/// cxxMethodDecl(isConst()) matches A::foo() but not A::bar()
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isConst
argument_list|)
block|{
return|return
name|Node
operator|.
name|isConst
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method declaration declares a copy assignment
comment|/// operator.
comment|///
comment|/// Given
comment|/// \code
comment|/// struct A {
comment|///   A&operator=(const A&);
comment|///   A&operator=(A&&);
comment|/// };
comment|/// \endcode
comment|///
comment|/// cxxMethodDecl(isCopyAssignmentOperator()) matches the first method but not
comment|/// the second one.
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isCopyAssignmentOperator
argument_list|)
block|{
return|return
name|Node
operator|.
name|isCopyAssignmentOperator
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method declaration declares a move assignment
comment|/// operator.
comment|///
comment|/// Given
comment|/// \code
comment|/// struct A {
comment|///   A&operator=(const A&);
comment|///   A&operator=(A&&);
comment|/// };
comment|/// \endcode
comment|///
comment|/// cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not
comment|/// the first one.
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isMoveAssignmentOperator
argument_list|)
block|{
return|return
name|Node
operator|.
name|isMoveAssignmentOperator
argument_list|()
return|;
block|}
comment|/// \brief Matches if the given method declaration overrides another method.
comment|///
comment|/// Given
comment|/// \code
comment|///   class A {
comment|///    public:
comment|///     virtual void x();
comment|///   };
comment|///   class B : public A {
comment|///    public:
comment|///     virtual void x();
comment|///   };
comment|/// \endcode
comment|///   matches B::x
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isOverride
argument_list|)
block|{
return|return
name|Node
operator|.
name|size_overridden_methods
argument_list|()
operator|>
literal|0
operator|||
name|Node
operator|.
name|hasAttr
operator|<
name|OverrideAttr
operator|>
operator|(
operator|)
return|;
block|}
comment|/// \brief Matches method declarations that are user-provided.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(); // #1
comment|///     S(const S&) = default; // #2
comment|///     S(S&&) = delete; // #3
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3.
name|AST_MATCHER
argument_list|(
argument|CXXMethodDecl
argument_list|,
argument|isUserProvided
argument_list|)
block|{
return|return
name|Node
operator|.
name|isUserProvided
argument_list|()
return|;
block|}
comment|/// \brief Matches member expressions that are called with '->' as opposed
comment|/// to '.'.
comment|///
comment|/// Member calls on the implicit this pointer match as called with '->'.
comment|///
comment|/// Given
comment|/// \code
comment|///   class Y {
comment|///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
comment|///     int a;
comment|///     static int b;
comment|///   };
comment|/// \endcode
comment|/// memberExpr(isArrow())
comment|///   matches this->x, x, y.x, a, this->b
name|AST_MATCHER
argument_list|(
argument|MemberExpr
argument_list|,
argument|isArrow
argument_list|)
block|{
return|return
name|Node
operator|.
name|isArrow
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are of integer type.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(long);
comment|///   void c(double);
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isInteger())))
comment|/// matches "a(int)", "b(long)", but not "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isInteger
argument_list|)
block|{
return|return
name|Node
operator|->
name|isIntegerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are of unsigned integer type.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(unsigned long);
comment|///   void c(double);
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isUnsignedInteger())))
comment|/// matches "b(unsigned long)", but not "a(int)" and "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isUnsignedInteger
argument_list|)
block|{
return|return
name|Node
operator|->
name|isUnsignedIntegerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are of signed integer type.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(unsigned long);
comment|///   void c(double);
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isSignedInteger())))
comment|/// matches "a(int)", but not "b(unsigned long)" and "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isSignedInteger
argument_list|)
block|{
return|return
name|Node
operator|->
name|isSignedIntegerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are of character type.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(char);
comment|///   void b(wchar_t);
comment|///   void c(double);
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isAnyCharacter())))
comment|/// matches "a(char)", "b(wchar_t)", but not "c(double)".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isAnyCharacter
argument_list|)
block|{
return|return
name|Node
operator|->
name|isAnyCharacterType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are of any pointer type; this includes
comment|/// the Objective-C object pointer type, which is different despite being
comment|/// syntactically similar.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *i = nullptr;
comment|///
comment|///   @interface Foo
comment|///   @end
comment|///   Foo *f;
comment|///
comment|///   int j;
comment|/// \endcode
comment|/// varDecl(hasType(isAnyPointer()))
comment|///   matches "int *i" and "Foo *f", but not "int j".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isAnyPointer
argument_list|)
block|{
return|return
name|Node
operator|->
name|isAnyPointerType
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are const-qualified, i.e., that
comment|/// include "top-level" const.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(int const);
comment|///   void c(const int);
comment|///   void d(const int*);
comment|///   void e(int const) {};
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isConstQualified())))
comment|///   matches "void b(int const)", "void c(const int)" and
comment|///   "void e(int const) {}". It does not match d as there
comment|///   is no top-level const on the parameter type "const int *".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isConstQualified
argument_list|)
block|{
return|return
name|Node
operator|.
name|isConstQualified
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that are volatile-qualified, i.e., that
comment|/// include "top-level" volatile.
comment|///
comment|/// Given
comment|/// \code
comment|///   void a(int);
comment|///   void b(int volatile);
comment|///   void c(volatile int);
comment|///   void d(volatile int*);
comment|///   void e(int volatile) {};
comment|/// \endcode
comment|/// functionDecl(hasAnyParameter(hasType(isVolatileQualified())))
comment|///   matches "void b(int volatile)", "void c(volatile int)" and
comment|///   "void e(int volatile) {}". It does not match d as there
comment|///   is no top-level volatile on the parameter type "volatile int *".
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|isVolatileQualified
argument_list|)
block|{
return|return
name|Node
operator|.
name|isVolatileQualified
argument_list|()
return|;
block|}
comment|/// \brief Matches QualType nodes that have local CV-qualifiers attached to
comment|/// the node, not hidden within a typedef.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef const int const_int;
comment|///   const_int i;
comment|///   int *const j;
comment|///   int *volatile k;
comment|///   int m;
comment|/// \endcode
comment|/// \c varDecl(hasType(hasLocalQualifiers())) matches only \c j and \c k.
comment|/// \c i is const-qualified but the qualifier is not local.
name|AST_MATCHER
argument_list|(
argument|QualType
argument_list|,
argument|hasLocalQualifiers
argument_list|)
block|{
return|return
name|Node
operator|.
name|hasLocalQualifiers
argument_list|()
return|;
block|}
comment|/// \brief Matches a member expression where the member is matched by a
comment|/// given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct { int first, second; } first, second;
comment|///   int i(second.first);
comment|///   int j(first.second);
comment|/// \endcode
comment|/// memberExpr(member(hasName("first")))
comment|///   matches second.first
comment|///   but not first.second (because the member name there is "second").
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|member
argument_list|,
argument|internal::Matcher<ValueDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getMemberDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a member expression where the object expression is
comment|/// matched by a given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct X { int m; };
comment|///   void f(X x) { x.m; m; }
comment|/// \endcode
comment|/// memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName("X")))))))
comment|///   matches "x.m" and "m"
comment|/// with hasObjectExpression(...)
comment|///   matching "x" and the implicit object expression of "m" which has type X*.
name|AST_MATCHER_P
argument_list|(
argument|MemberExpr
argument_list|,
argument|hasObjectExpression
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getBase
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches any using shadow declaration.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { void b(); }
comment|///   using X::b;
comment|/// \endcode
comment|/// usingDecl(hasAnyUsingShadowDecl(hasName("b"))))
comment|///   matches \code using X::b \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingDecl
argument_list|,
argument|hasAnyUsingShadowDecl
argument_list|,
argument|internal::Matcher<UsingShadowDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|matchesFirstInPointerRange
argument_list|(
name|InnerMatcher
argument_list|,
name|Node
operator|.
name|shadow_begin
argument_list|()
argument_list|,
name|Node
operator|.
name|shadow_end
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches a using shadow declaration where the target declaration is
comment|/// matched by the given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace X { int a; void b(); }
comment|///   using X::a;
comment|///   using X::b;
comment|/// \endcode
comment|/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))
comment|///   matches \code using X::b \endcode
comment|///   but not \code using X::a \endcode
name|AST_MATCHER_P
argument_list|(
argument|UsingShadowDecl
argument_list|,
argument|hasTargetDecl
argument_list|,
argument|internal::Matcher<NamedDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getTargetDecl
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches template instantiations of function, class, or static
comment|/// member variable template instantiations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> class X {}; class A {}; X<A> x;
comment|/// \endcode
comment|/// or
comment|/// \code
comment|///   template<typename T> class X {}; class A {}; template class X<A>;
comment|/// \endcode
comment|/// cxxRecordDecl(hasName("::X"), isTemplateInstantiation())
comment|///   matches the template instantiation of X<A>.
comment|///
comment|/// But given
comment|/// \code
comment|///   template<typename T>  class X {}; class A {};
comment|///   template<> class X<A> {}; X<A> x;
comment|/// \endcode
comment|/// cxxRecordDecl(hasName("::X"), isTemplateInstantiation())
comment|///   does not match, as X<A> is an explicit template specialization.
comment|///
comment|/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isTemplateInstantiation
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,                                                         CXXRecordDecl)
argument_list|)
block|{
return|return
operator|(
name|Node
operator|.
name|getTemplateSpecializationKind
argument_list|()
operator|==
name|TSK_ImplicitInstantiation
operator|||
name|Node
operator|.
name|getTemplateSpecializationKind
argument_list|()
operator|==
name|TSK_ExplicitInstantiationDefinition
operator|)
return|;
block|}
comment|/// \brief Matches declarations that are template instantiations or are inside
comment|/// template instantiations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> void A(T t) { T i; }
comment|///   A(0);
comment|///   A(0U);
comment|/// \endcode
comment|/// functionDecl(isInstantiated())
comment|///   matches 'A(int) {...};' and 'A(unsigned) {...}'.
name|AST_MATCHER_FUNCTION
argument_list|(
argument|internal::Matcher<Decl>
argument_list|,
argument|isInstantiated
argument_list|)
block|{
name|auto
name|IsInstantiation
init|=
name|decl
argument_list|(
name|anyOf
argument_list|(
name|cxxRecordDecl
argument_list|(
name|isTemplateInstantiation
argument_list|()
argument_list|)
argument_list|,
name|functionDecl
argument_list|(
name|isTemplateInstantiation
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|decl
argument_list|(
name|anyOf
argument_list|(
name|IsInstantiation
argument_list|,
name|hasAncestor
argument_list|(
name|IsInstantiation
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches statements inside of a template instantiation.
comment|///
comment|/// Given
comment|/// \code
comment|///   int j;
comment|///   template<typename T> void A(T t) { T i; j += 42;}
comment|///   A(0);
comment|///   A(0U);
comment|/// \endcode
comment|/// declStmt(isInTemplateInstantiation())
comment|///   matches 'int i;' and 'unsigned i'.
comment|/// unless(stmt(isInTemplateInstantiation()))
comment|///   will NOT match j += 42; as it's shared between the template definition and
comment|///   instantiation.
name|AST_MATCHER_FUNCTION
argument_list|(
argument|internal::Matcher<Stmt>
argument_list|,
argument|isInTemplateInstantiation
argument_list|)
block|{
return|return
name|stmt
argument_list|(
name|hasAncestor
argument_list|(
name|decl
argument_list|(
name|anyOf
argument_list|(
name|cxxRecordDecl
argument_list|(
name|isTemplateInstantiation
argument_list|()
argument_list|)
argument_list|,
name|functionDecl
argument_list|(
name|isTemplateInstantiation
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches explicit template specializations of function, class, or
comment|/// static member variable template instantiations.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T> void A(T t) { }
comment|///   template<> void A(int N) { }
comment|/// \endcode
comment|/// functionDecl(isExplicitTemplateSpecialization())
comment|///   matches the specialization A<int>().
comment|///
comment|/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isExplicitTemplateSpecialization
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,                                                         CXXRecordDecl)
argument_list|)
block|{
return|return
operator|(
name|Node
operator|.
name|getTemplateSpecializationKind
argument_list|()
operator|==
name|TSK_ExplicitSpecialization
operator|)
return|;
block|}
comment|/// \brief Matches \c TypeLocs for which the given inner
comment|/// QualType-matcher matches.
name|AST_MATCHER_FUNCTION_P_OVERLOAD
argument_list|(
argument|internal::BindableMatcher<TypeLoc>
argument_list|,
argument|loc
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|0
argument_list|)
block|{
return|return
name|internal
operator|::
name|BindableMatcher
operator|<
name|TypeLoc
operator|>
operator|(
name|new
name|internal
operator|::
name|TypeLocTypeMatcher
argument_list|(
name|InnerMatcher
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Matches type \c bool.
comment|///
comment|/// Given
comment|/// \code
comment|///  struct S { bool func(); };
comment|/// \endcode
comment|/// functionDecl(returns(booleanType()))
comment|///   matches "bool func();"
name|AST_MATCHER
argument_list|(
argument|Type
argument_list|,
argument|booleanType
argument_list|)
block|{
return|return
name|Node
operator|.
name|isBooleanType
argument_list|()
return|;
block|}
comment|/// \brief Matches type \c void.
comment|///
comment|/// Given
comment|/// \code
comment|///  struct S { void func(); };
comment|/// \endcode
comment|/// functionDecl(returns(voidType()))
comment|///   matches "void func();"
name|AST_MATCHER
argument_list|(
argument|Type
argument_list|,
argument|voidType
argument_list|)
block|{
return|return
name|Node
operator|.
name|isVoidType
argument_list|()
return|;
block|}
comment|/// \brief Matches builtin Types.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A {};
comment|///   A a;
comment|///   int b;
comment|///   float c;
comment|///   bool d;
comment|/// \endcode
comment|/// builtinType()
comment|///   matches "int b", "float c" and "bool d"
name|AST_TYPE_MATCHER
argument_list|(
name|BuiltinType
argument_list|,
name|builtinType
argument_list|)
expr_stmt|;
comment|/// \brief Matches all kinds of arrays.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 2, 3 };
comment|///   int b[4];
comment|///   void f() { int c[a[0]]; }
comment|/// \endcode
comment|/// arrayType()
comment|///   matches "int a[]", "int b[4]" and "int c[a[0]]";
name|AST_TYPE_MATCHER
argument_list|(
name|ArrayType
argument_list|,
name|arrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C99 complex types.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Complex float f;
comment|/// \endcode
comment|/// complexType()
comment|///   matches "_Complex float f"
name|AST_TYPE_MATCHER
argument_list|(
name|ComplexType
argument_list|,
name|complexType
argument_list|)
expr_stmt|;
comment|/// \brief Matches any real floating-point type (float, double, long double).
comment|///
comment|/// Given
comment|/// \code
comment|///   int i;
comment|///   float f;
comment|/// \endcode
comment|/// realFloatingPointType()
comment|///   matches "float f" but not "int i"
name|AST_MATCHER
argument_list|(
argument|Type
argument_list|,
argument|realFloatingPointType
argument_list|)
block|{
return|return
name|Node
operator|.
name|isRealFloatingType
argument_list|()
return|;
block|}
comment|/// \brief Matches arrays and C99 complex types that have a specific element
comment|/// type.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A {};
comment|///   A a[7];
comment|///   int b[7];
comment|/// \endcode
comment|/// arrayType(hasElementType(builtinType()))
comment|///   matches "int b[7]"
comment|///
comment|/// Usable as: Matcher<ArrayType>, Matcher<ComplexType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|hasElementType
argument_list|,
name|getElement
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|ArrayType
argument_list|,
name|ComplexType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with a specified constant size.
comment|///
comment|/// Given
comment|/// \code
comment|///   void() {
comment|///     int a[2];
comment|///     int b[] = { 2, 3 };
comment|///     int c[b[0]];
comment|///   }
comment|/// \endcode
comment|/// constantArrayType()
comment|///   matches "int a[2]"
name|AST_TYPE_MATCHER
argument_list|(
name|ConstantArrayType
argument_list|,
name|constantArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches nodes that have the specified size.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[42];
comment|///   int b[2 * 21];
comment|///   int c[41], d[43];
comment|///   char *s = "abcd";
comment|///   wchar_t *ws = L"abcd";
comment|///   char *w = "a";
comment|/// \endcode
comment|/// constantArrayType(hasSize(42))
comment|///   matches "int a[42]" and "int b[2 * 21]"
comment|/// stringLiteral(hasSize(4))
comment|///   matches "abcd", L"abcd"
name|AST_POLYMORPHIC_MATCHER_P
argument_list|(
argument|hasSize
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(ConstantArrayType,                                                           StringLiteral)
argument_list|,
argument|unsigned
argument_list|,
argument|N
argument_list|)
block|{
return|return
name|internal
operator|::
name|HasSizeMatcher
operator|<
name|NodeType
operator|>
operator|::
name|hasSize
argument_list|(
name|Node
argument_list|,
name|N
argument_list|)
return|;
block|}
comment|/// \brief Matches C++ arrays whose size is a value-dependent expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T, int Size>
comment|///   class array {
comment|///     T data[Size];
comment|///   };
comment|/// \endcode
comment|/// dependentSizedArrayType
comment|///   matches "T data[Size]"
name|AST_TYPE_MATCHER
argument_list|(
name|DependentSizedArrayType
argument_list|,
name|dependentSizedArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with unspecified size.
comment|///
comment|/// Given
comment|/// \code
comment|///   int a[] = { 2, 3 };
comment|///   int b[42];
comment|///   void f(int c[]) { int d[a[0]]; };
comment|/// \endcode
comment|/// incompleteArrayType()
comment|///   matches "int a[]" and "int c[]"
name|AST_TYPE_MATCHER
argument_list|(
name|IncompleteArrayType
argument_list|,
name|incompleteArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches C arrays with a specified size that is not an
comment|/// integer-constant-expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f() {
comment|///     int a[] = { 2, 3 }
comment|///     int b[42];
comment|///     int c[a[0]];
comment|///   }
comment|/// \endcode
comment|/// variableArrayType()
comment|///   matches "int c[a[0]]"
name|AST_TYPE_MATCHER
argument_list|(
name|VariableArrayType
argument_list|,
name|variableArrayType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c VariableArrayType nodes that have a specific size
comment|/// expression.
comment|///
comment|/// Given
comment|/// \code
comment|///   void f(int b) {
comment|///     int a[b];
comment|///   }
comment|/// \endcode
comment|/// variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(
comment|///   varDecl(hasName("b")))))))
comment|///   matches "int a[b]"
name|AST_MATCHER_P
argument_list|(
argument|VariableArrayType
argument_list|,
argument|hasSizeExpr
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getSizeExpr
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches atomic types.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Atomic(int) i;
comment|/// \endcode
comment|/// atomicType()
comment|///   matches "_Atomic(int) i"
name|AST_TYPE_MATCHER
argument_list|(
name|AtomicType
argument_list|,
name|atomicType
argument_list|)
expr_stmt|;
comment|/// \brief Matches atomic types with a specific value type.
comment|///
comment|/// Given
comment|/// \code
comment|///   _Atomic(int) i;
comment|///   _Atomic(float) f;
comment|/// \endcode
comment|/// atomicType(hasValueType(isInteger()))
comment|///  matches "_Atomic(int) i"
comment|///
comment|/// Usable as: Matcher<AtomicType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|hasValueType
argument_list|,
name|getValue
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|AtomicType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches types nodes representing C++11 auto types.
comment|///
comment|/// Given:
comment|/// \code
comment|///   auto n = 4;
comment|///   int v[] = { 2, 3 }
comment|///   for (auto i : v) { }
comment|/// \endcode
comment|/// autoType()
comment|///   matches "auto n" and "auto i"
name|AST_TYPE_MATCHER
argument_list|(
name|AutoType
argument_list|,
name|autoType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c AutoType nodes where the deduced type is a specific type.
comment|///
comment|/// Note: There is no \c TypeLoc for the deduced type and thus no
comment|/// \c getDeducedLoc() matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   auto a = 1;
comment|///   auto b = 2.0;
comment|/// \endcode
comment|/// autoType(hasDeducedType(isInteger()))
comment|///   matches "auto a"
comment|///
comment|/// Usable as: Matcher<AutoType>
name|AST_TYPE_TRAVERSE_MATCHER
argument_list|(
name|hasDeducedType
argument_list|,
name|getDeducedType
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|AutoType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c FunctionType nodes.
comment|///
comment|/// Given
comment|/// \code
comment|///   int (*f)(int);
comment|///   void g();
comment|/// \endcode
comment|/// functionType()
comment|///   matches "int (*f)(int)" and the type of "g".
name|AST_TYPE_MATCHER
argument_list|(
name|FunctionType
argument_list|,
name|functionType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c FunctionProtoType nodes.
comment|///
comment|/// Given
comment|/// \code
comment|///   int (*f)(int);
comment|///   void g();
comment|/// \endcode
comment|/// functionProtoType()
comment|///   matches "int (*f)(int)" and the type of "g" in C++ mode.
comment|///   In C mode, "g" is not matched because it does not contain a prototype.
name|AST_TYPE_MATCHER
argument_list|(
name|FunctionProtoType
argument_list|,
name|functionProtoType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c ParenType nodes.
comment|///
comment|/// Given
comment|/// \code
comment|///   int (*ptr_to_array)[4];
comment|///   int *array_of_ptrs[4];
comment|/// \endcode
comment|///
comment|/// \c varDecl(hasType(pointsTo(parenType()))) matches \c ptr_to_array but not
comment|/// \c array_of_ptrs.
name|AST_TYPE_MATCHER
argument_list|(
name|ParenType
argument_list|,
name|parenType
argument_list|)
expr_stmt|;
comment|/// \brief Matches \c ParenType nodes where the inner type is a specific type.
comment|///
comment|/// Given
comment|/// \code
comment|///   int (*ptr_to_array)[4];
comment|///   int (*ptr_to_func)(int);
comment|/// \endcode
comment|///
comment|/// \c varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches
comment|/// \c ptr_to_func but not \c ptr_to_array.
comment|///
comment|/// Usable as: Matcher<ParenType>
name|AST_TYPE_TRAVERSE_MATCHER
argument_list|(
name|innerType
argument_list|,
name|getInnerType
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|ParenType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches block pointer types, i.e. types syntactically represented as
comment|/// "void (^)(int)".
comment|///
comment|/// The \c pointee is always required to be a \c FunctionType.
name|AST_TYPE_MATCHER
argument_list|(
name|BlockPointerType
argument_list|,
name|blockPointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches member pointer types.
comment|/// Given
comment|/// \code
comment|///   struct A { int i; }
comment|///   A::* ptr = A::i;
comment|/// \endcode
comment|/// memberPointerType()
comment|///   matches "A::* ptr"
name|AST_TYPE_MATCHER
argument_list|(
name|MemberPointerType
argument_list|,
name|memberPointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches pointer types, but does not match Objective-C object pointer
comment|/// types.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int c = 5;
comment|///
comment|///   @interface Foo
comment|///   @end
comment|///   Foo *f;
comment|/// \endcode
comment|/// pointerType()
comment|///   matches "int *a", but does not match "Foo *f".
name|AST_TYPE_MATCHER
argument_list|(
name|PointerType
argument_list|,
name|pointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches an Objective-C object pointer type, which is different from
comment|/// a pointer type, despite being syntactically similar.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///
comment|///   @interface Foo
comment|///   @end
comment|///   Foo *f;
comment|/// \endcode
comment|/// pointerType()
comment|///   matches "Foo *f", but does not match "int *a".
name|AST_TYPE_MATCHER
argument_list|(
name|ObjCObjectPointerType
argument_list|,
name|objcObjectPointerType
argument_list|)
expr_stmt|;
comment|/// \brief Matches both lvalue and rvalue reference types.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int&&c = 1;
comment|///   auto&d = b;
comment|///   auto&&e = c;
comment|///   auto&&f = 2;
comment|///   int g = 5;
comment|/// \endcode
comment|///
comment|/// \c referenceType() matches the types of \c b, \c c, \c d, \c e, and \c f.
name|AST_TYPE_MATCHER
argument_list|(
name|ReferenceType
argument_list|,
name|referenceType
argument_list|)
expr_stmt|;
comment|/// \brief Matches lvalue reference types.
comment|///
comment|/// Given:
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int&&c = 1;
comment|///   auto&d = b;
comment|///   auto&&e = c;
comment|///   auto&&f = 2;
comment|///   int g = 5;
comment|/// \endcode
comment|///
comment|/// \c lValueReferenceType() matches the types of \c b, \c d, and \c e. \c e is
comment|/// matched since the type is deduced as int& by reference collapsing rules.
name|AST_TYPE_MATCHER
argument_list|(
name|LValueReferenceType
argument_list|,
name|lValueReferenceType
argument_list|)
expr_stmt|;
comment|/// \brief Matches rvalue reference types.
comment|///
comment|/// Given:
comment|/// \code
comment|///   int *a;
comment|///   int&b = *a;
comment|///   int&&c = 1;
comment|///   auto&d = b;
comment|///   auto&&e = c;
comment|///   auto&&f = 2;
comment|///   int g = 5;
comment|/// \endcode
comment|///
comment|/// \c rValueReferenceType() matches the types of \c c and \c f. \c e is not
comment|/// matched as it is deduced to int& by reference collapsing rules.
name|AST_TYPE_MATCHER
argument_list|(
name|RValueReferenceType
argument_list|,
name|rValueReferenceType
argument_list|)
expr_stmt|;
comment|/// \brief Narrows PointerType (and similar) matchers to those where the
comment|/// \c pointee matches a given matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   int *a;
comment|///   int const *b;
comment|///   float const *f;
comment|/// \endcode
comment|/// pointerType(pointee(isConstQualified(), isInteger()))
comment|///   matches "int const *b"
comment|///
comment|/// Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,
comment|///   Matcher<PointerType>, Matcher<ReferenceType>
name|AST_TYPELOC_TRAVERSE_MATCHER
argument_list|(
name|pointee
argument_list|,
name|getPointee
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|BlockPointerType
argument_list|,
name|MemberPointerType
argument_list|,
name|PointerType
argument_list|,
name|ReferenceType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches typedef types.
comment|///
comment|/// Given
comment|/// \code
comment|///   typedef int X;
comment|/// \endcode
comment|/// typedefType()
comment|///   matches "typedef int X"
name|AST_TYPE_MATCHER
argument_list|(
name|TypedefType
argument_list|,
name|typedefType
argument_list|)
expr_stmt|;
comment|/// \brief Matches enum types.
comment|///
comment|/// Given
comment|/// \code
comment|///   enum C { Green };
comment|///   enum class S { Red };
comment|///
comment|///   C c;
comment|///   S s;
comment|/// \endcode
comment|//
comment|/// \c enumType() matches the type of the variable declarations of both \c c and
comment|/// \c s.
name|AST_TYPE_MATCHER
argument_list|(
name|EnumType
argument_list|,
name|enumType
argument_list|)
expr_stmt|;
comment|/// \brief Matches template specialization types.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T>
comment|///   class C { };
comment|///
comment|///   template class C<int>;  // A
comment|///   C<char> var;            // B
comment|/// \endcode
comment|///
comment|/// \c templateSpecializationType() matches the type of the explicit
comment|/// instantiation in \c A and the type of the variable declaration in \c B.
name|AST_TYPE_MATCHER
argument_list|(
name|TemplateSpecializationType
argument_list|,
name|templateSpecializationType
argument_list|)
expr_stmt|;
comment|/// \brief Matches types nodes representing unary type transformations.
comment|///
comment|/// Given:
comment|/// \code
comment|///   typedef __underlying_type(T) type;
comment|/// \endcode
comment|/// unaryTransformType()
comment|///   matches "__underlying_type(T)"
name|AST_TYPE_MATCHER
argument_list|(
name|UnaryTransformType
argument_list|,
name|unaryTransformType
argument_list|)
expr_stmt|;
comment|/// \brief Matches record types (e.g. structs, classes).
comment|///
comment|/// Given
comment|/// \code
comment|///   class C {};
comment|///   struct S {};
comment|///
comment|///   C c;
comment|///   S s;
comment|/// \endcode
comment|///
comment|/// \c recordType() matches the type of the variable declarations of both \c c
comment|/// and \c s.
name|AST_TYPE_MATCHER
argument_list|(
name|RecordType
argument_list|,
name|recordType
argument_list|)
expr_stmt|;
comment|/// \brief Matches types specified with an elaborated type keyword or with a
comment|/// qualified name.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace N {
comment|///     namespace M {
comment|///       class D {};
comment|///     }
comment|///   }
comment|///   class C {};
comment|///
comment|///   class C c;
comment|///   N::M::D d;
comment|/// \endcode
comment|///
comment|/// \c elaboratedType() matches the type of the variable declarations of both
comment|/// \c c and \c d.
name|AST_TYPE_MATCHER
argument_list|(
name|ElaboratedType
argument_list|,
name|elaboratedType
argument_list|)
expr_stmt|;
comment|/// \brief Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,
comment|/// matches \c InnerMatcher if the qualifier exists.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace N {
comment|///     namespace M {
comment|///       class D {};
comment|///     }
comment|///   }
comment|///   N::M::D d;
comment|/// \endcode
comment|///
comment|/// \c elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName("N"))))
comment|/// matches the type of the variable declaration of \c d.
name|AST_MATCHER_P
argument_list|(
argument|ElaboratedType
argument_list|,
argument|hasQualifier
argument_list|,
argument|internal::Matcher<NestedNameSpecifier>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
name|NestedNameSpecifier
modifier|*
name|Qualifier
init|=
name|Node
operator|.
name|getQualifier
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Qualifier
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches ElaboratedTypes whose named type matches \c InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace N {
comment|///     namespace M {
comment|///       class D {};
comment|///     }
comment|///   }
comment|///   N::M::D d;
comment|/// \endcode
comment|///
comment|/// \c elaboratedType(namesType(recordType(
comment|/// hasDeclaration(namedDecl(hasName("D")))))) matches the type of the variable
comment|/// declaration of \c d.
name|AST_MATCHER_P
argument_list|(
argument|ElaboratedType
argument_list|,
argument|namesType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getNamedType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches types that represent the result of substituting a type for a
comment|/// template type parameter.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T>
comment|///   void F(T t) {
comment|///     int i = 1 + t;
comment|///   }
comment|/// \endcode
comment|///
comment|/// \c substTemplateTypeParmType() matches the type of 't' but not '1'
name|AST_TYPE_MATCHER
argument_list|(
name|SubstTemplateTypeParmType
argument_list|,
name|substTemplateTypeParmType
argument_list|)
expr_stmt|;
comment|/// \brief Matches template type parameter substitutions that have a replacement
comment|/// type that matches the provided matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   template<typename T>
comment|///   double F(T t);
comment|///   int i;
comment|///   double j = F(i);
comment|/// \endcode
comment|///
comment|/// \c substTemplateTypeParmType(hasReplacementType(type())) matches int
name|AST_TYPE_TRAVERSE_MATCHER
argument_list|(
name|hasReplacementType
argument_list|,
name|getReplacementType
argument_list|,
name|AST_POLYMORPHIC_SUPPORTED_TYPES
argument_list|(
name|SubstTemplateTypeParmType
argument_list|)
argument_list|)
expr_stmt|;
comment|/// \brief Matches template type parameter types.
comment|///
comment|/// Example matches T, but not int.
comment|///     (matcher = templateTypeParmType())
comment|/// \code
comment|///   template<typename T> void f(int i);
comment|/// \endcode
name|AST_TYPE_MATCHER
argument_list|(
name|TemplateTypeParmType
argument_list|,
name|templateTypeParmType
argument_list|)
expr_stmt|;
comment|/// \brief Matches injected class name types.
comment|///
comment|/// Example matches S s, but not S<T> s.
comment|///     (matcher = parmVarDecl(hasType(injectedClassNameType())))
comment|/// \code
comment|///   template<typename T> struct S {
comment|///     void f(S s);
comment|///     void g(S<T> s);
comment|///   };
comment|/// \endcode
name|AST_TYPE_MATCHER
argument_list|(
name|InjectedClassNameType
argument_list|,
name|injectedClassNameType
argument_list|)
expr_stmt|;
comment|/// \brief Matches decayed type
comment|/// Example matches i[] in declaration of f.
comment|///     (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType())))))
comment|/// Example matches i[1].
comment|///     (matcher = expr(hasType(decayedType(hasDecayedType(pointerType())))))
comment|/// \code
comment|///   void f(int i[]) {
comment|///     i[1] = 0;
comment|///   }
comment|/// \endcode
name|AST_TYPE_MATCHER
argument_list|(
name|DecayedType
argument_list|,
name|decayedType
argument_list|)
expr_stmt|;
comment|/// \brief Matches the decayed type, whos decayed type matches \c InnerMatcher
name|AST_MATCHER_P
argument_list|(
argument|DecayedType
argument_list|,
argument|hasDecayedType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerType
argument_list|)
block|{
return|return
name|InnerType
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getDecayedType
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches declarations whose declaration context, interpreted as a
comment|/// Decl, matches \c InnerMatcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace N {
comment|///     namespace M {
comment|///       class D {};
comment|///     }
comment|///   }
comment|/// \endcode
comment|///
comment|/// \c cxxRcordDecl(hasDeclContext(namedDecl(hasName("M")))) matches the
comment|/// declaration of \c class \c D.
name|AST_MATCHER_P
argument_list|(
argument|Decl
argument_list|,
argument|hasDeclContext
argument_list|,
argument|internal::Matcher<Decl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
name|DeclContext
modifier|*
name|DC
init|=
name|Node
operator|.
name|getDeclContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DC
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Decl
operator|::
name|castFromDeclContext
argument_list|(
name|DC
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifiers.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace ns {
comment|///     struct A { static void f(); };
comment|///     void A::f() {}
comment|///     void g() { A::f(); }
comment|///   }
comment|///   ns::A a;
comment|/// \endcode
comment|/// nestedNameSpecifier()
comment|///   matches "ns::" and both "A::"
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|NestedNameSpecifier
operator|>
name|nestedNameSpecifier
expr_stmt|;
comment|/// \brief Same as \c nestedNameSpecifier but matches \c NestedNameSpecifierLoc.
specifier|const
name|internal
operator|::
name|VariadicAllOfMatcher
operator|<
name|NestedNameSpecifierLoc
operator|>
name|nestedNameSpecifierLoc
expr_stmt|;
comment|/// \brief Matches \c NestedNameSpecifierLocs for which the given inner
comment|/// NestedNameSpecifier-matcher matches.
name|AST_MATCHER_FUNCTION_P_OVERLOAD
argument_list|(
argument|internal::BindableMatcher<NestedNameSpecifierLoc>
argument_list|,
argument|loc
argument_list|,
argument|internal::Matcher<NestedNameSpecifier>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
return|return
name|internal
operator|::
name|BindableMatcher
operator|<
name|NestedNameSpecifierLoc
operator|>
operator|(
name|new
name|internal
operator|::
name|LocMatcher
operator|<
name|NestedNameSpecifierLoc
operator|,
name|NestedNameSpecifier
operator|>
operator|(
name|InnerMatcher
operator|)
operator|)
return|;
block|}
comment|/// \brief Matches nested name specifiers that specify a type matching the
comment|/// given \c QualType matcher without qualifiers.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifier(specifiesType(
comment|///   hasDeclaration(cxxRecordDecl(hasName("A")))
comment|/// ))
comment|///   matches "A::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifier
argument_list|,
argument|specifiesType
argument_list|,
argument|internal::Matcher<QualType>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
operator|!
name|Node
operator|.
name|getAsType
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|QualType
argument_list|(
name|Node
operator|.
name|getAsType
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifier locs that specify a type matching the
comment|/// given \c TypeLoc.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(
comment|///   hasDeclaration(cxxRecordDecl(hasName("A")))))))
comment|///   matches "A::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifierLoc
argument_list|,
argument|specifiesTypeLoc
argument_list|,
argument|internal::Matcher<TypeLoc>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
return|return
name|Node
operator|&&
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|Node
operator|.
name|getTypeLoc
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches on the prefix of a \c NestedNameSpecifier.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifier(hasPrefix(specifiesType(asString("struct A")))) and
comment|///   matches "A::"
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|NestedNameSpecifier
argument_list|,
argument|hasPrefix
argument_list|,
argument|internal::Matcher<NestedNameSpecifier>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|0
argument_list|)
block|{
specifier|const
name|NestedNameSpecifier
modifier|*
name|NextNode
init|=
name|Node
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|NextNode
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|NextNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches on the prefix of a \c NestedNameSpecifierLoc.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct A { struct B { struct C {}; }; };
comment|///   A::B::C c;
comment|/// \endcode
comment|/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString("struct A")))))
comment|///   matches "A::"
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|NestedNameSpecifierLoc
argument_list|,
argument|hasPrefix
argument_list|,
argument|internal::Matcher<NestedNameSpecifierLoc>
argument_list|,
argument|InnerMatcher
argument_list|,
literal|1
argument_list|)
block|{
name|NestedNameSpecifierLoc
name|NextNode
init|=
name|Node
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|NextNode
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
name|NextNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches nested name specifiers that specify a namespace matching the
comment|/// given namespace matcher.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace ns { struct A {}; }
comment|///   ns::A a;
comment|/// \endcode
comment|/// nestedNameSpecifier(specifiesNamespace(hasName("ns")))
comment|///   matches "ns::"
name|AST_MATCHER_P
argument_list|(
argument|NestedNameSpecifier
argument_list|,
argument|specifiesNamespace
argument_list|,
argument|internal::Matcher<NamespaceDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
operator|!
name|Node
operator|.
name|getAsNamespace
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getAsNamespace
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Overloads for the \c equalsNode matcher.
comment|/// FIXME: Implement for other node types.
comment|/// @{
comment|/// \brief Matches if a node equals another node.
comment|///
comment|/// \c Decl has pointer identity in the AST.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|Decl
argument_list|,
argument|equalsNode
argument_list|,
argument|const Decl*
argument_list|,
argument|Other
argument_list|,
literal|0
argument_list|)
block|{
return|return
operator|&
name|Node
operator|==
name|Other
return|;
block|}
comment|/// \brief Matches if a node equals another node.
comment|///
comment|/// \c Stmt has pointer identity in the AST.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|Stmt
argument_list|,
argument|equalsNode
argument_list|,
argument|const Stmt*
argument_list|,
argument|Other
argument_list|,
literal|1
argument_list|)
block|{
return|return
operator|&
name|Node
operator|==
name|Other
return|;
block|}
comment|/// \brief Matches if a node equals another node.
comment|///
comment|/// \c Type has pointer identity in the AST.
name|AST_MATCHER_P_OVERLOAD
argument_list|(
argument|Type
argument_list|,
argument|equalsNode
argument_list|,
argument|const Type*
argument_list|,
argument|Other
argument_list|,
literal|2
argument_list|)
block|{
return|return
operator|&
name|Node
operator|==
name|Other
return|;
block|}
comment|/// @}
comment|/// \brief Matches each case or default statement belonging to the given switch
comment|/// statement. This matcher may produce multiple matches.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }
comment|/// \endcode
comment|/// switchStmt(forEachSwitchCase(caseStmt().bind("c"))).bind("s")
comment|///   matches four times, with "c" binding each of "case 1:", "case 2:",
comment|/// "case 3:" and "case 4:", and "s" respectively binding "switch (1)",
comment|/// "switch (1)", "switch (2)" and "switch (2)".
name|AST_MATCHER_P
argument_list|(
argument|SwitchStmt
argument_list|,
argument|forEachSwitchCase
argument_list|,
argument|internal::Matcher<SwitchCase>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|BoundNodesTreeBuilder
name|Result
decl_stmt|;
comment|// FIXME: getSwitchCaseList() does not necessarily guarantee a stable
comment|// iteration order. We should use the more general iterating matchers once
comment|// they are capable of expressing this matcher (for example, it should ignore
comment|// case statements belonging to nested switch statements).
name|bool
name|Matched
init|=
name|false
decl_stmt|;
for|for
control|(
specifier|const
name|SwitchCase
modifier|*
name|SC
init|=
name|Node
operator|.
name|getSwitchCaseList
argument_list|()
init|;
name|SC
condition|;
name|SC
operator|=
name|SC
operator|->
name|getNextSwitchCase
argument_list|()
control|)
block|{
name|BoundNodesTreeBuilder
name|CaseBuilder
argument_list|(
operator|*
name|Builder
argument_list|)
decl_stmt|;
name|bool
name|CaseMatched
init|=
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|SC
argument_list|,
name|Finder
argument_list|,
operator|&
name|CaseBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
name|CaseMatched
condition|)
block|{
name|Matched
operator|=
name|true
expr_stmt|;
name|Result
operator|.
name|addMatch
argument_list|(
name|CaseBuilder
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|Builder
operator|=
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
expr_stmt|;
return|return
name|Matched
return|;
block|}
comment|/// \brief Matches each constructor initializer in a constructor definition.
comment|///
comment|/// Given
comment|/// \code
comment|///   class A { A() : i(42), j(42) {} int i; int j; };
comment|/// \endcode
comment|/// cxxConstructorDecl(forEachConstructorInitializer(
comment|///   forField(decl().bind("x"))
comment|/// ))
comment|///   will trigger two matches, binding for 'i' and 'j' respectively.
name|AST_MATCHER_P
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|forEachConstructorInitializer
argument_list|,
argument|internal::Matcher<CXXCtorInitializer>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
name|BoundNodesTreeBuilder
name|Result
decl_stmt|;
name|bool
name|Matched
init|=
name|false
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|I
range|:
name|Node
operator|.
name|inits
argument_list|()
control|)
block|{
name|BoundNodesTreeBuilder
name|InitBuilder
argument_list|(
operator|*
name|Builder
argument_list|)
decl_stmt|;
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|I
argument_list|,
name|Finder
argument_list|,
operator|&
name|InitBuilder
argument_list|)
condition|)
block|{
name|Matched
operator|=
name|true
expr_stmt|;
name|Result
operator|.
name|addMatch
argument_list|(
name|InitBuilder
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|Builder
operator|=
name|std
operator|::
name|move
argument_list|(
name|Result
argument_list|)
expr_stmt|;
return|return
name|Matched
return|;
block|}
comment|/// \brief Matches constructor declarations that are copy constructors.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(); // #1
comment|///     S(const S&); // #2
comment|///     S(S&&); // #3
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3.
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isCopyConstructor
argument_list|)
block|{
return|return
name|Node
operator|.
name|isCopyConstructor
argument_list|()
return|;
block|}
comment|/// \brief Matches constructor declarations that are move constructors.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(); // #1
comment|///     S(const S&); // #2
comment|///     S(S&&); // #3
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2.
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isMoveConstructor
argument_list|)
block|{
return|return
name|Node
operator|.
name|isMoveConstructor
argument_list|()
return|;
block|}
comment|/// \brief Matches constructor declarations that are default constructors.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(); // #1
comment|///     S(const S&); // #2
comment|///     S(S&&); // #3
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3.
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isDefaultConstructor
argument_list|)
block|{
return|return
name|Node
operator|.
name|isDefaultConstructor
argument_list|()
return|;
block|}
comment|/// \brief Matches constructors that delegate to another constructor.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(); // #1
comment|///     S(int) {} // #2
comment|///     S(S&&) : S() {} // #3
comment|///   };
comment|///   S::S() : S(0) {} // #4
comment|/// \endcode
comment|/// cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not
comment|/// #1 or #2.
name|AST_MATCHER
argument_list|(
argument|CXXConstructorDecl
argument_list|,
argument|isDelegatingConstructor
argument_list|)
block|{
return|return
name|Node
operator|.
name|isDelegatingConstructor
argument_list|()
return|;
block|}
comment|/// \brief Matches constructor and conversion declarations that are marked with
comment|/// the explicit keyword.
comment|///
comment|/// Given
comment|/// \code
comment|///   struct S {
comment|///     S(int); // #1
comment|///     explicit S(double); // #2
comment|///     operator int(); // #3
comment|///     explicit operator bool(); // #4
comment|///   };
comment|/// \endcode
comment|/// cxxConstructorDecl(isExplicit()) will match #2, but not #1.
comment|/// cxxConversionDecl(isExplicit()) will match #4, but not #3.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isExplicit
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(CXXConstructorDecl,                                                         CXXConversionDecl)
argument_list|)
block|{
return|return
name|Node
operator|.
name|isExplicit
argument_list|()
return|;
block|}
comment|/// \brief Matches function and namespace declarations that are marked with
comment|/// the inline keyword.
comment|///
comment|/// Given
comment|/// \code
comment|///   inline void f();
comment|///   void g();
comment|///   namespace n {
comment|///   inline namespace m {}
comment|///   }
comment|/// \endcode
comment|/// functionDecl(isInline()) will match ::f().
comment|/// namespaceDecl(isInline()) will match n::m.
name|AST_POLYMORPHIC_MATCHER
argument_list|(
argument|isInline
argument_list|,
argument|AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,                                                         FunctionDecl)
argument_list|)
block|{
comment|// This is required because the spelling of the function used to determine
comment|// whether inline is specified or not differs between the polymorphic types.
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|FD
init|=
name|dyn_cast
operator|<
name|FunctionDecl
operator|>
operator|(
operator|&
name|Node
operator|)
condition|)
return|return
name|FD
operator|->
name|isInlineSpecified
argument_list|()
return|;
elseif|else
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|NSD
init|=
name|dyn_cast
operator|<
name|NamespaceDecl
operator|>
operator|(
operator|&
name|Node
operator|)
condition|)
return|return
name|NSD
operator|->
name|isInline
argument_list|()
return|;
name|llvm_unreachable
argument_list|(
literal|"Not a valid polymorphic type"
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Matches anonymous namespace declarations.
comment|///
comment|/// Given
comment|/// \code
comment|///   namespace n {
comment|///   namespace {} // #1
comment|///   }
comment|/// \endcode
comment|/// namespaceDecl(isAnonymous()) will match #1 but not ::n.
name|AST_MATCHER
argument_list|(
argument|NamespaceDecl
argument_list|,
argument|isAnonymous
argument_list|)
block|{
return|return
name|Node
operator|.
name|isAnonymousNamespace
argument_list|()
return|;
block|}
comment|/// \brief If the given case statement does not use the GNU case range
comment|/// extension, matches the constant given in the statement.
comment|///
comment|/// Given
comment|/// \code
comment|///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }
comment|/// \endcode
comment|/// caseStmt(hasCaseConstant(integerLiteral()))
comment|///   matches "case 1:"
name|AST_MATCHER_P
argument_list|(
argument|CaseStmt
argument_list|,
argument|hasCaseConstant
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
name|Node
operator|.
name|getRHS
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|Node
operator|.
name|getLHS
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
block|}
comment|/// \brief Matches declaration that has a given attribute.
comment|///
comment|/// Given
comment|/// \code
comment|///   __attribute__((device)) void f() { ... }
comment|/// \endcode
comment|/// decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of
comment|/// f. If the matcher is use from clang-query, attr::Kind parameter should be
comment|/// passed as a quoted string. e.g., hasAttr("attr::CUDADevice").
name|AST_MATCHER_P
argument_list|(
argument|Decl
argument_list|,
argument|hasAttr
argument_list|,
argument|attr::Kind
argument_list|,
argument|AttrKind
argument_list|)
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|*
name|Attr
range|:
name|Node
operator|.
name|attrs
argument_list|()
control|)
block|{
if|if
condition|(
name|Attr
operator|->
name|getKind
argument_list|()
operator|==
name|AttrKind
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches the return value expression of a return statement
comment|///
comment|/// Given
comment|/// \code
comment|///   return a + b;
comment|/// \endcode
comment|/// hasReturnValue(binaryOperator())
comment|///   matches 'return a + b'
comment|/// with binaryOperator()
comment|///   matching 'a + b'
name|AST_MATCHER_P
argument_list|(
argument|ReturnStmt
argument_list|,
argument|hasReturnValue
argument_list|,
argument|internal::Matcher<Expr>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|RetValue
init|=
name|Node
operator|.
name|getRetValue
argument_list|()
condition|)
return|return
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|RetValue
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
return|;
return|return
name|false
return|;
block|}
comment|/// \brief Matches CUDA kernel call expression.
comment|///
comment|/// Example matches,
comment|/// \code
comment|///   kernel<<<i,j>>>();
comment|/// \endcode
specifier|const
name|internal
operator|::
name|VariadicDynCastAllOfMatcher
operator|<
name|Stmt
operator|,
name|CUDAKernelCallExpr
operator|>
name|cudaKernelCallExpr
expr_stmt|;
comment|/// \brief Matches expressions that resolve to a null pointer constant, such as
comment|/// GNU's __null, C++11's nullptr, or C's NULL macro.
comment|///
comment|/// Given:
comment|/// \code
comment|///   void *v1 = NULL;
comment|///   void *v2 = nullptr;
comment|///   void *v3 = __null; // GNU extension
comment|///   char *cp = (char *)0;
comment|///   int *ip = 0;
comment|///   int i = 0;
comment|/// \endcode
comment|/// expr(nullPointerConstant())
comment|///   matches the initializer for v1, v2, v3, cp, and ip. Does not match the
comment|///   initializer for i.
name|AST_MATCHER_FUNCTION
argument_list|(
argument|internal::Matcher<Expr>
argument_list|,
argument|nullPointerConstant
argument_list|)
block|{
return|return
name|anyOf
argument_list|(
name|gnuNullExpr
argument_list|()
argument_list|,
name|cxxNullPtrLiteralExpr
argument_list|()
argument_list|,
name|integerLiteral
argument_list|(
name|equals
argument_list|(
literal|0
argument_list|)
argument_list|,
name|hasParent
argument_list|(
name|expr
argument_list|(
name|hasType
argument_list|(
name|pointerType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Matches declaration of the function the statement belongs to
comment|///
comment|/// Given:
comment|/// \code
comment|/// F& operator=(const F& o) {
comment|///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v> 0; });
comment|///   return *this;
comment|/// }
comment|/// \endcode
comment|/// returnStmt(forFunction(hasName("operator=")))
comment|///   matches 'return *this'
comment|///   but does match 'return> 0'
name|AST_MATCHER_P
argument_list|(
argument|Stmt
argument_list|,
argument|forFunction
argument_list|,
argument|internal::Matcher<FunctionDecl>
argument_list|,
argument|InnerMatcher
argument_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|Parents
init|=
name|Finder
operator|->
name|getASTContext
argument_list|()
operator|.
name|getParents
argument_list|(
name|Node
argument_list|)
decl_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|ast_type_traits
operator|::
name|DynTypedNode
operator|,
literal|8
operator|>
name|Stack
argument_list|(
name|Parents
operator|.
name|begin
argument_list|()
argument_list|,
name|Parents
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Stack
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
specifier|auto
modifier|&
name|CurNode
init|=
name|Stack
operator|.
name|back
argument_list|()
decl_stmt|;
name|Stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|FuncDeclNode
init|=
name|CurNode
operator|.
name|get
operator|<
name|FunctionDecl
operator|>
operator|(
operator|)
condition|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|FuncDeclNode
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|LambdaExprNode
init|=
name|CurNode
operator|.
name|get
operator|<
name|LambdaExpr
operator|>
operator|(
operator|)
condition|)
block|{
if|if
condition|(
name|InnerMatcher
operator|.
name|matches
argument_list|(
operator|*
name|LambdaExprNode
operator|->
name|getCallOperator
argument_list|()
argument_list|,
name|Finder
argument_list|,
name|Builder
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Parent
range|:
name|Finder
operator|->
name|getASTContext
argument_list|()
operator|.
name|getParents
argument_list|(
name|CurNode
argument_list|)
control|)
name|Stack
operator|.
name|push_back
argument_list|(
name|Parent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|/// \brief Matches a declaration that has external formal linkage.
comment|///
comment|/// Example matches only z (matcher = varDecl(hasExternalFormalLinkage()))
comment|/// \code
comment|/// void f() {
comment|///   int x;
comment|///   static int y;
comment|/// }
comment|/// int z;
comment|/// \endcode
comment|///
comment|/// Example matches f() because it has external formal linkage despite being
comment|/// unique to the translation unit as though it has internal likage
comment|/// (matcher = functionDecl(hasExternalFormalLinkage()))
comment|///
comment|/// \code
comment|/// namespace {
comment|/// void f() {}
comment|/// }
comment|/// \endcode
name|AST_MATCHER
argument_list|(
argument|NamedDecl
argument_list|,
argument|hasExternalFormalLinkage
argument_list|)
block|{
return|return
name|Node
operator|.
name|hasExternalFormalLinkage
argument_list|()
return|;
block|}
block|}
comment|// end namespace ast_matchers
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

