begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ConstantInitBuilder.h - Builder for LLVM IR constants ----*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class provides a convenient interface for building complex
end_comment

begin_comment
comment|// global initializers of the sort that are frequently required for
end_comment

begin_comment
comment|// language ABIs.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_CODEGEN_CONSTANTINITBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_CODEGEN_CONSTANTINITBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/GlobalValue.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/CharUnits.h"
end_include

begin_include
include|#
directive|include
file|"clang/CodeGen/ConstantInitFuture.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|CodeGen
block|{
name|class
name|CodeGenModule
decl_stmt|;
comment|/// A convenience builder class for complex constant initializers,
comment|/// especially for anonymous global structures used by various language
comment|/// runtimes.
comment|///
comment|/// The basic usage pattern is expected to be something like:
comment|///    ConstantInitBuilder builder(CGM);
comment|///    auto toplevel = builder.beginStruct();
comment|///    toplevel.addInt(CGM.SizeTy, widgets.size());
comment|///    auto widgetArray = builder.beginArray();
comment|///    for (auto&widget : widgets) {
comment|///      auto widgetDesc = widgetArray.beginStruct();
comment|///      widgetDesc.addInt(CGM.SizeTy, widget.getPower());
comment|///      widgetDesc.add(CGM.GetAddrOfConstantString(widget.getName()));
comment|///      widgetDesc.add(CGM.GetAddrOfGlobal(widget.getInitializerDecl()));
comment|///      widgetDesc.finishAndAddTo(widgetArray);
comment|///    }
comment|///    widgetArray.finishAndAddTo(toplevel);
comment|///    auto global = toplevel.finishAndCreateGlobal("WIDGET_LIST", Align,
comment|///                                                 /*constant*/ true);
name|class
name|ConstantInitBuilderBase
block|{
struct|struct
name|SelfReference
block|{
name|llvm
operator|::
name|GlobalVariable
operator|*
name|Dummy
expr_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|,
literal|4
operator|>
name|Indices
expr_stmt|;
name|SelfReference
argument_list|(
name|llvm
operator|::
name|GlobalVariable
operator|*
name|dummy
argument_list|)
operator|:
name|Dummy
argument_list|(
argument|dummy
argument_list|)
block|{}
block|}
struct|;
name|CodeGenModule
modifier|&
name|CGM
decl_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|,
literal|16
operator|>
name|Buffer
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SelfReference
operator|>
name|SelfReferences
expr_stmt|;
name|bool
name|Frozen
init|=
name|false
decl_stmt|;
name|friend
name|class
name|ConstantInitFuture
decl_stmt|;
name|friend
name|class
name|ConstantAggregateBuilderBase
decl_stmt|;
name|template
operator|<
name|class
operator|,
name|class
operator|>
name|friend
name|class
name|ConstantAggregateBuilderTemplateBase
expr_stmt|;
name|protected
label|:
name|explicit
name|ConstantInitBuilderBase
argument_list|(
name|CodeGenModule
operator|&
name|CGM
argument_list|)
operator|:
name|CGM
argument_list|(
argument|CGM
argument_list|)
block|{}
operator|~
name|ConstantInitBuilderBase
argument_list|()
block|{
name|assert
argument_list|(
name|Buffer
operator|.
name|empty
argument_list|()
operator|&&
literal|"didn't claim all values out of buffer"
argument_list|)
block|;
name|assert
argument_list|(
name|SelfReferences
operator|.
name|empty
argument_list|()
operator|&&
literal|"didn't apply all self-references"
argument_list|)
block|;   }
name|private
operator|:
name|llvm
operator|::
name|GlobalVariable
operator|*
name|createGlobal
argument_list|(
argument|llvm::Constant *initializer
argument_list|,
argument|const llvm::Twine&name
argument_list|,
argument|CharUnits alignment
argument_list|,
argument|bool constant = false
argument_list|,
argument|llvm::GlobalValue::LinkageTypes linkage                                        = llvm::GlobalValue::InternalLinkage
argument_list|,
argument|unsigned addressSpace =
literal|0
argument_list|)
expr_stmt|;
name|ConstantInitFuture
name|createFuture
argument_list|(
name|llvm
operator|::
name|Constant
operator|*
name|initializer
argument_list|)
decl_stmt|;
name|void
name|setGlobalInitializer
argument_list|(
name|llvm
operator|::
name|GlobalVariable
operator|*
name|GV
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|initializer
argument_list|)
decl_stmt|;
name|void
name|resolveSelfReferences
argument_list|(
name|llvm
operator|::
name|GlobalVariable
operator|*
name|GV
argument_list|)
decl_stmt|;
name|void
name|abandon
parameter_list|(
name|size_t
name|newEnd
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// A concrete base class for struct and array aggregate
comment|/// initializer builders.
name|class
name|ConstantAggregateBuilderBase
block|{
name|protected
label|:
name|ConstantInitBuilderBase
modifier|&
name|Builder
decl_stmt|;
name|ConstantAggregateBuilderBase
modifier|*
name|Parent
decl_stmt|;
name|size_t
name|Begin
decl_stmt|;
name|mutable
name|size_t
name|CachedOffsetEnd
init|=
literal|0
decl_stmt|;
name|bool
name|Finished
init|=
name|false
decl_stmt|;
name|bool
name|Frozen
init|=
name|false
decl_stmt|;
name|bool
name|Packed
init|=
name|false
decl_stmt|;
name|mutable
name|CharUnits
name|CachedOffsetFromGlobal
decl_stmt|;
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
operator|&
name|getBuffer
argument_list|()
block|{
return|return
name|Builder
operator|.
name|Buffer
return|;
block|}
specifier|const
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
operator|&
name|getBuffer
argument_list|()
specifier|const
block|{
return|return
name|Builder
operator|.
name|Buffer
return|;
block|}
name|ConstantAggregateBuilderBase
argument_list|(
name|ConstantInitBuilderBase
operator|&
name|builder
argument_list|,
name|ConstantAggregateBuilderBase
operator|*
name|parent
argument_list|)
operator|:
name|Builder
argument_list|(
name|builder
argument_list|)
operator|,
name|Parent
argument_list|(
name|parent
argument_list|)
operator|,
name|Begin
argument_list|(
argument|builder.Buffer.size()
argument_list|)
block|{
if|if
condition|(
name|parent
condition|)
block|{
name|assert
argument_list|(
operator|!
name|parent
operator|->
name|Frozen
operator|&&
literal|"parent already has child builder active"
argument_list|)
expr_stmt|;
name|parent
operator|->
name|Frozen
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|!
name|builder
operator|.
name|Frozen
operator|&&
literal|"builder already has child builder active"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|Frozen
operator|=
name|true
expr_stmt|;
block|}
block|}
operator|~
name|ConstantAggregateBuilderBase
argument_list|()
block|{
name|assert
argument_list|(
name|Finished
operator|&&
literal|"didn't finish aggregate builder"
argument_list|)
block|;   }
name|void
name|markFinished
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"child builder still active"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"builder already finished"
argument_list|)
block|;
name|Finished
operator|=
name|true
block|;
if|if
condition|(
name|Parent
condition|)
block|{
name|assert
argument_list|(
name|Parent
operator|->
name|Frozen
operator|&&
literal|"parent not frozen while child builder active"
argument_list|)
expr_stmt|;
name|Parent
operator|->
name|Frozen
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|Builder
operator|.
name|Frozen
operator|&&
literal|"builder not frozen while child builder active"
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Frozen
operator|=
name|false
expr_stmt|;
block|}
block|}
name|public
operator|:
comment|// Not copyable.
name|ConstantAggregateBuilderBase
argument_list|(
specifier|const
name|ConstantAggregateBuilderBase
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|ConstantAggregateBuilderBase
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ConstantAggregateBuilderBase
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
comment|// Movable, mostly to allow returning.  But we have to write this out
comment|// properly to satisfy the assert in the destructor.
name|ConstantAggregateBuilderBase
argument_list|(
name|ConstantAggregateBuilderBase
operator|&&
name|other
argument_list|)
operator|:
name|Builder
argument_list|(
name|other
operator|.
name|Builder
argument_list|)
operator|,
name|Parent
argument_list|(
name|other
operator|.
name|Parent
argument_list|)
operator|,
name|Begin
argument_list|(
name|other
operator|.
name|Begin
argument_list|)
operator|,
name|CachedOffsetEnd
argument_list|(
name|other
operator|.
name|CachedOffsetEnd
argument_list|)
operator|,
name|Finished
argument_list|(
name|other
operator|.
name|Finished
argument_list|)
operator|,
name|Frozen
argument_list|(
name|other
operator|.
name|Frozen
argument_list|)
operator|,
name|Packed
argument_list|(
name|other
operator|.
name|Packed
argument_list|)
operator|,
name|CachedOffsetFromGlobal
argument_list|(
argument|other.CachedOffsetFromGlobal
argument_list|)
block|{
name|other
operator|.
name|Finished
operator|=
name|true
block|;   }
name|ConstantAggregateBuilderBase
operator|&
name|operator
operator|=
operator|(
name|ConstantAggregateBuilderBase
operator|&&
name|other
operator|)
operator|=
name|delete
expr_stmt|;
comment|/// Return the number of elements that have been added to
comment|/// this struct or array.
name|size_t
name|size
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Finished
operator|&&
literal|"cannot query after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Frozen
operator|&&
literal|"cannot query while sub-builder is active"
argument_list|)
block|;
name|assert
argument_list|(
name|this
operator|->
name|Begin
operator|<=
name|this
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|this
operator|->
name|getBuffer
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|this
operator|->
name|Begin
return|;
block|}
comment|/// Return true if no elements have yet been added to this struct or array.
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/// Abandon this builder completely.
name|void
name|abandon
parameter_list|()
block|{
name|markFinished
argument_list|()
expr_stmt|;
name|Builder
operator|.
name|abandon
argument_list|(
name|Begin
argument_list|)
expr_stmt|;
block|}
comment|/// Add a new value to this initializer.
name|void
name|add
argument_list|(
name|llvm
operator|::
name|Constant
operator|*
name|value
argument_list|)
block|{
name|assert
argument_list|(
name|value
operator|&&
literal|"adding null value to constant initializer"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Buffer
operator|.
name|push_back
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/// Add an integer value of type size_t.
name|void
name|addSize
parameter_list|(
name|CharUnits
name|size
parameter_list|)
function_decl|;
comment|/// Add an integer value of a specific type.
name|void
name|addInt
argument_list|(
name|llvm
operator|::
name|IntegerType
operator|*
name|intTy
argument_list|,
name|uint64_t
name|value
argument_list|,
name|bool
name|isSigned
operator|=
name|false
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|intTy
argument_list|,
name|value
argument_list|,
name|isSigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Add a null pointer of a specific type.
name|void
name|addNullPointer
argument_list|(
name|llvm
operator|::
name|PointerType
operator|*
name|ptrTy
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantPointerNull
operator|::
name|get
argument_list|(
name|ptrTy
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Add a bitcast of a value to a specific type.
name|void
name|addBitCast
argument_list|(
name|llvm
operator|::
name|Constant
operator|*
name|value
argument_list|,
name|llvm
operator|::
name|Type
operator|*
name|type
argument_list|)
block|{
name|add
argument_list|(
name|llvm
operator|::
name|ConstantExpr
operator|::
name|getBitCast
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Add a bunch of new values to this initializer.
name|void
name|addAll
argument_list|(
name|llvm
operator|::
name|ArrayRef
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
name|values
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Buffer
operator|.
name|append
argument_list|(
name|values
operator|.
name|begin
argument_list|()
argument_list|,
name|values
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// Add a relative offset to the given target address, i.e. the
comment|/// static difference between the target address and the address
comment|/// of the relative offset.  The target must be known to be defined
comment|/// in the current linkage unit.  The offset will have the given
comment|/// integer type, which must be no wider than intptr_t.  Some
comment|/// targets may not fully support this operation.
name|void
name|addRelativeOffset
argument_list|(
name|llvm
operator|::
name|IntegerType
operator|*
name|type
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|target
argument_list|)
block|{
name|add
argument_list|(
name|getRelativeOffset
argument_list|(
name|type
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Add a relative offset to the target address, plus a small
comment|/// constant offset.  This is primarily useful when the relative
comment|/// offset is known to be a multiple of (say) four and therefore
comment|/// the tag can be used to express an extra two bits of information.
name|void
name|addTaggedRelativeOffset
argument_list|(
name|llvm
operator|::
name|IntegerType
operator|*
name|type
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|address
argument_list|,
name|unsigned
name|tag
argument_list|)
block|{
name|llvm
operator|::
name|Constant
operator|*
name|offset
operator|=
name|getRelativeOffset
argument_list|(
name|type
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|offset
operator|=
name|llvm
operator|::
name|ConstantExpr
operator|::
name|getAdd
argument_list|(
name|offset
argument_list|,
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|type
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/// Return the offset from the start of the initializer to the
comment|/// next position, assuming no padding is required prior to it.
comment|///
comment|/// This operation will not succeed if any unsized placeholders are
comment|/// currently in place in the initializer.
name|CharUnits
name|getNextOffsetFromGlobal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
block|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
block|;
return|return
name|getOffsetFromGlobalTo
argument_list|(
name|Builder
operator|.
name|Buffer
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/// An opaque class to hold the abstract position of a placeholder.
name|class
name|PlaceholderPosition
block|{
name|size_t
name|Index
decl_stmt|;
name|friend
name|class
name|ConstantAggregateBuilderBase
decl_stmt|;
name|PlaceholderPosition
argument_list|(
argument|size_t index
argument_list|)
block|:
name|Index
argument_list|(
argument|index
argument_list|)
block|{}
block|}
empty_stmt|;
comment|/// Add a placeholder value to the structure.  The returned position
comment|/// can be used to set the value later; it will not be invalidated by
comment|/// any intermediate operations except (1) filling the same position or
comment|/// (2) finishing the entire builder.
comment|///
comment|/// This is useful for emitting certain kinds of structure which
comment|/// contain some sort of summary field, generaly a count, before any
comment|/// of the data.  By emitting a placeholder first, the structure can
comment|/// be emitted eagerly.
name|PlaceholderPosition
name|addPlaceholder
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot add more values after finishing builder"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|Buffer
operator|.
name|push_back
argument_list|(
name|nullptr
argument_list|)
expr_stmt|;
return|return
name|Builder
operator|.
name|Buffer
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/// Add a placeholder, giving the expected type that will be filled in.
name|PlaceholderPosition
name|addPlaceholderWithSize
argument_list|(
name|llvm
operator|::
name|Type
operator|*
name|expectedType
argument_list|)
decl_stmt|;
comment|/// Fill a previously-added placeholder.
name|void
name|fillPlaceholderWithInt
argument_list|(
name|PlaceholderPosition
name|position
argument_list|,
name|llvm
operator|::
name|IntegerType
operator|*
name|type
argument_list|,
name|uint64_t
name|value
argument_list|,
name|bool
name|isSigned
operator|=
name|false
argument_list|)
block|{
name|fillPlaceholder
argument_list|(
name|position
argument_list|,
name|llvm
operator|::
name|ConstantInt
operator|::
name|get
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|isSigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/// Fill a previously-added placeholder.
name|void
name|fillPlaceholder
argument_list|(
name|PlaceholderPosition
name|position
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|value
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Finished
operator|&&
literal|"cannot change values after finishing builder"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|Frozen
operator|&&
literal|"cannot add values while subbuilder is active"
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|Constant
operator|*
operator|&
name|slot
operator|=
name|Builder
operator|.
name|Buffer
index|[
name|position
operator|.
name|Index
index|]
expr_stmt|;
name|assert
argument_list|(
name|slot
operator|==
name|nullptr
operator|&&
literal|"placeholder already filled"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|value
expr_stmt|;
block|}
comment|/// Produce an address which will eventually point to the the next
comment|/// position to be filled.  This is computed with an indexed
comment|/// getelementptr rather than by computing offsets.
comment|///
comment|/// The returned pointer will have type T*, where T is the given
comment|/// position.
name|llvm
operator|::
name|Constant
operator|*
name|getAddrOfCurrentPosition
argument_list|(
name|llvm
operator|::
name|Type
operator|*
name|type
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|ArrayRef
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
name|getGEPIndicesToCurrentPosition
argument_list|(
argument|llvm::SmallVectorImpl<llvm::Constant*>&indices
argument_list|)
block|{
name|getGEPIndicesTo
argument_list|(
name|indices
argument_list|,
name|Builder
operator|.
name|Buffer
operator|.
name|size
argument_list|()
argument_list|)
block|;
return|return
name|indices
return|;
block|}
name|protected
label|:
name|llvm
operator|::
name|Constant
operator|*
name|finishArray
argument_list|(
name|llvm
operator|::
name|Type
operator|*
name|eltTy
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|Constant
operator|*
name|finishStruct
argument_list|(
name|llvm
operator|::
name|StructType
operator|*
name|structTy
argument_list|)
expr_stmt|;
name|private
label|:
name|void
name|getGEPIndicesTo
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|llvm
operator|::
name|Constant
operator|*
operator|>
operator|&
name|indices
argument_list|,
name|size_t
name|position
argument_list|)
decl|const
decl_stmt|;
name|llvm
operator|::
name|Constant
operator|*
name|getRelativeOffset
argument_list|(
name|llvm
operator|::
name|IntegerType
operator|*
name|offsetType
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|target
argument_list|)
expr_stmt|;
name|CharUnits
name|getOffsetFromGlobalTo
argument_list|(
name|size_t
name|index
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Impl
operator|,
name|class
name|Traits
operator|>
name|class
name|ConstantAggregateBuilderTemplateBase
operator|:
name|public
name|Traits
operator|::
name|AggregateBuilderBase
block|{
name|using
name|super
operator|=
name|typename
name|Traits
operator|::
name|AggregateBuilderBase
block|;
name|public
operator|:
name|using
name|InitBuilder
operator|=
name|typename
name|Traits
operator|::
name|InitBuilder
block|;
name|using
name|ArrayBuilder
operator|=
name|typename
name|Traits
operator|::
name|ArrayBuilder
block|;
name|using
name|StructBuilder
operator|=
name|typename
name|Traits
operator|::
name|StructBuilder
block|;
name|using
name|AggregateBuilderBase
operator|=
name|typename
name|Traits
operator|::
name|AggregateBuilderBase
block|;
name|protected
operator|:
name|ConstantAggregateBuilderTemplateBase
argument_list|(
name|InitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|)
operator|:
name|super
argument_list|(
argument|builder
argument_list|,
argument|parent
argument_list|)
block|{}
name|Impl
operator|&
name|asImpl
argument_list|()
block|{
return|return
operator|*
name|static_cast
operator|<
name|Impl
operator|*
operator|>
operator|(
name|this
operator|)
return|;
block|}
name|public
operator|:
name|ArrayBuilder
name|beginArray
argument_list|(
argument|llvm::Type *eltTy = nullptr
argument_list|)
block|{
return|return
name|ArrayBuilder
argument_list|(
name|static_cast
operator|<
name|InitBuilder
operator|&
operator|>
operator|(
name|this
operator|->
name|Builder
operator|)
argument_list|,
name|this
argument_list|,
name|eltTy
argument_list|)
return|;
block|}
name|StructBuilder
name|beginStruct
argument_list|(
argument|llvm::StructType *ty = nullptr
argument_list|)
block|{
return|return
name|StructBuilder
argument_list|(
name|static_cast
operator|<
name|InitBuilder
operator|&
operator|>
operator|(
name|this
operator|->
name|Builder
operator|)
argument_list|,
name|this
argument_list|,
name|ty
argument_list|)
return|;
block|}
comment|/// Given that this builder was created by beginning an array or struct
comment|/// component on the given parent builder, finish the array/struct
comment|/// component and add it to the parent.
comment|///
comment|/// It is an intentional choice that the parent is passed in explicitly
comment|/// despite it being redundant with information already kept in the
comment|/// builder.  This aids in readability by making it easier to find the
comment|/// places that add components to a builder, as well as "bookending"
comment|/// the sub-builder more explicitly.
name|void
name|finishAndAddTo
argument_list|(
argument|AggregateBuilderBase&parent
argument_list|)
block|{
name|assert
argument_list|(
name|this
operator|->
name|Parent
operator|==
operator|&
name|parent
operator|&&
literal|"adding to non-parent builder"
argument_list|)
block|;
name|parent
operator|.
name|add
argument_list|(
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|)
block|;   }
comment|/// Given that this builder was created by beginning an array or struct
comment|/// directly on a ConstantInitBuilder, finish the array/struct and
comment|/// create a global variable with it as the initializer.
name|template
operator|<
name|class
operator|...
name|As
operator|>
name|llvm
operator|::
name|GlobalVariable
operator|*
name|finishAndCreateGlobal
argument_list|(
argument|As&&...args
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Parent
operator|&&
literal|"finishing non-root builder"
argument_list|)
block|;
return|return
name|this
operator|->
name|Builder
operator|.
name|createGlobal
argument_list|(
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|,
name|std
operator|::
name|forward
operator|<
name|As
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
return|;
block|}
comment|/// Given that this builder was created by beginning an array or struct
comment|/// directly on a ConstantInitBuilder, finish the array/struct and
comment|/// set it as the initializer of the given global variable.
name|void
name|finishAndSetAsInitializer
argument_list|(
argument|llvm::GlobalVariable *global
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Parent
operator|&&
literal|"finishing non-root builder"
argument_list|)
block|;
return|return
name|this
operator|->
name|Builder
operator|.
name|setGlobalInitializer
argument_list|(
name|global
argument_list|,
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|)
return|;
block|}
comment|/// Given that this builder was created by beginning an array or struct
comment|/// directly on a ConstantInitBuilder, finish the array/struct and
comment|/// return a future which can be used to install the initializer in
comment|/// a global later.
comment|///
comment|/// This is useful for allowing a finished initializer to passed to
comment|/// an API which will build the global.  However, the "future" preserves
comment|/// a dependency on the original builder; it is an error to pass it aside.
name|ConstantInitFuture
name|finishAndCreateFuture
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|this
operator|->
name|Parent
operator|&&
literal|"finishing non-root builder"
argument_list|)
block|;
return|return
name|this
operator|->
name|Builder
operator|.
name|createFuture
argument_list|(
name|asImpl
argument_list|()
operator|.
name|finishImpl
argument_list|()
argument_list|)
return|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|Traits
operator|>
name|class
name|ConstantArrayBuilderTemplateBase
operator|:
name|public
name|ConstantAggregateBuilderTemplateBase
operator|<
name|typename
name|Traits
operator|::
name|ArrayBuilder
block|,
name|Traits
operator|>
block|{
name|using
name|super
operator|=
name|ConstantAggregateBuilderTemplateBase
operator|<
name|typename
name|Traits
operator|::
name|ArrayBuilder
block|,
name|Traits
operator|>
block|;
name|public
operator|:
name|using
name|InitBuilder
operator|=
name|typename
name|Traits
operator|::
name|InitBuilder
block|;
name|using
name|AggregateBuilderBase
operator|=
name|typename
name|Traits
operator|::
name|AggregateBuilderBase
block|;
name|private
operator|:
name|llvm
operator|::
name|Type
operator|*
name|EltTy
block|;
name|template
operator|<
name|class
block|,
name|class
operator|>
name|friend
name|class
name|ConstantAggregateBuilderTemplateBase
block|;
name|protected
operator|:
name|ConstantArrayBuilderTemplateBase
argument_list|(
name|InitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|Type
operator|*
name|eltTy
argument_list|)
operator|:
name|super
argument_list|(
name|builder
argument_list|,
name|parent
argument_list|)
block|,
name|EltTy
argument_list|(
argument|eltTy
argument_list|)
block|{}
name|private
operator|:
comment|/// Form an array constant from the values that have been added to this
comment|/// builder.
name|llvm
operator|::
name|Constant
operator|*
name|finishImpl
argument_list|()
block|{
return|return
name|AggregateBuilderBase
operator|::
name|finishArray
argument_list|(
name|EltTy
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// A template class designed to allow other frontends to
comment|/// easily customize the builder classes used by ConstantInitBuilder,
comment|/// and thus to extend the API to work with the abstractions they
comment|/// prefer.  This would probably not be necessary if C++ just
comment|/// supported extension methods.
name|template
operator|<
name|class
name|Traits
operator|>
name|class
name|ConstantStructBuilderTemplateBase
operator|:
name|public
name|ConstantAggregateBuilderTemplateBase
operator|<
name|typename
name|Traits
operator|::
name|StructBuilder
block|,
name|Traits
operator|>
block|{
name|using
name|super
operator|=
name|ConstantAggregateBuilderTemplateBase
operator|<
name|typename
name|Traits
operator|::
name|StructBuilder
block|,
name|Traits
operator|>
block|;
name|public
operator|:
name|using
name|InitBuilder
operator|=
name|typename
name|Traits
operator|::
name|InitBuilder
block|;
name|using
name|AggregateBuilderBase
operator|=
name|typename
name|Traits
operator|::
name|AggregateBuilderBase
block|;
name|private
operator|:
name|llvm
operator|::
name|StructType
operator|*
name|StructTy
block|;
name|template
operator|<
name|class
block|,
name|class
operator|>
name|friend
name|class
name|ConstantAggregateBuilderTemplateBase
block|;
name|protected
operator|:
name|ConstantStructBuilderTemplateBase
argument_list|(
name|InitBuilder
operator|&
name|builder
argument_list|,
name|AggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|StructType
operator|*
name|structTy
argument_list|)
operator|:
name|super
argument_list|(
name|builder
argument_list|,
name|parent
argument_list|)
block|,
name|StructTy
argument_list|(
argument|structTy
argument_list|)
block|{
if|if
condition|(
name|structTy
condition|)
name|this
operator|->
name|Packed
operator|=
name|structTy
operator|->
name|isPacked
argument_list|()
expr_stmt|;
block|}
name|public
operator|:
name|void
name|setPacked
argument_list|(
argument|bool packed
argument_list|)
block|{
name|this
operator|->
name|Packed
operator|=
name|packed
block|;   }
comment|/// Use the given type for the struct if its element count is correct.
comment|/// Don't add more elements after calling this.
name|void
name|suggestType
argument_list|(
argument|llvm::StructType *structTy
argument_list|)
block|{
if|if
condition|(
name|this
operator|->
name|size
argument_list|()
operator|==
name|structTy
operator|->
name|getNumElements
argument_list|()
condition|)
block|{
name|StructTy
operator|=
name|structTy
expr_stmt|;
block|}
block|}
name|private
operator|:
comment|/// Form an array constant from the values that have been added to this
comment|/// builder.
name|llvm
operator|::
name|Constant
operator|*
name|finishImpl
argument_list|()
block|{
return|return
name|AggregateBuilderBase
operator|::
name|finishStruct
argument_list|(
name|StructTy
argument_list|)
return|;
block|}
expr|}
block|;
comment|/// A template class designed to allow other frontends to
comment|/// easily customize the builder classes used by ConstantInitBuilder,
comment|/// and thus to extend the API to work with the abstractions they
comment|/// prefer.  This would probably not be necessary if C++ just
comment|/// supported extension methods.
name|template
operator|<
name|class
name|Traits
operator|>
name|class
name|ConstantInitBuilderTemplateBase
operator|:
name|public
name|ConstantInitBuilderBase
block|{
name|protected
operator|:
name|ConstantInitBuilderTemplateBase
argument_list|(
name|CodeGenModule
operator|&
name|CGM
argument_list|)
operator|:
name|ConstantInitBuilderBase
argument_list|(
argument|CGM
argument_list|)
block|{}
name|public
operator|:
name|using
name|InitBuilder
operator|=
name|typename
name|Traits
operator|::
name|InitBuilder
block|;
name|using
name|ArrayBuilder
operator|=
name|typename
name|Traits
operator|::
name|ArrayBuilder
block|;
name|using
name|StructBuilder
operator|=
name|typename
name|Traits
operator|::
name|StructBuilder
block|;
name|ArrayBuilder
name|beginArray
argument_list|(
argument|llvm::Type *eltTy = nullptr
argument_list|)
block|{
return|return
name|ArrayBuilder
argument_list|(
name|static_cast
operator|<
name|InitBuilder
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
argument_list|,
name|nullptr
argument_list|,
name|eltTy
argument_list|)
return|;
block|}
name|StructBuilder
name|beginStruct
argument_list|(
argument|llvm::StructType *structTy = nullptr
argument_list|)
block|{
return|return
name|StructBuilder
argument_list|(
name|static_cast
operator|<
name|InitBuilder
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
argument_list|,
name|nullptr
argument_list|,
name|structTy
argument_list|)
return|;
block|}
expr|}
block|;
name|class
name|ConstantInitBuilder
block|;
name|class
name|ConstantStructBuilder
block|;
name|class
name|ConstantArrayBuilder
block|;  struct
name|ConstantInitBuilderTraits
block|{
name|using
name|InitBuilder
operator|=
name|ConstantInitBuilder
block|;
name|using
name|AggregateBuilderBase
operator|=
name|ConstantAggregateBuilderBase
block|;
name|using
name|ArrayBuilder
operator|=
name|ConstantArrayBuilder
block|;
name|using
name|StructBuilder
operator|=
name|ConstantStructBuilder
block|; }
block|;
comment|/// The standard implementation of ConstantInitBuilder used in Clang.
name|class
name|ConstantInitBuilder
operator|:
name|public
name|ConstantInitBuilderTemplateBase
operator|<
name|ConstantInitBuilderTraits
operator|>
block|{
name|public
operator|:
name|explicit
name|ConstantInitBuilder
argument_list|(
name|CodeGenModule
operator|&
name|CGM
argument_list|)
operator|:
name|ConstantInitBuilderTemplateBase
argument_list|(
argument|CGM
argument_list|)
block|{}
block|}
block|;
comment|/// A helper class of ConstantInitBuilder, used for building constant
comment|/// array initializers.
name|class
name|ConstantArrayBuilder
operator|:
name|public
name|ConstantArrayBuilderTemplateBase
operator|<
name|ConstantInitBuilderTraits
operator|>
block|{
name|template
operator|<
name|class
name|Traits
operator|>
name|friend
name|class
name|ConstantInitBuilderTemplateBase
block|;
comment|// The use of explicit qualification is a GCC workaround.
name|template
operator|<
name|class
name|Impl
block|,
name|class
name|Traits
operator|>
name|friend
name|class
name|CodeGen
operator|::
name|ConstantAggregateBuilderTemplateBase
block|;
name|ConstantArrayBuilder
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|ConstantAggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|Type
operator|*
name|eltTy
argument_list|)
operator|:
name|ConstantArrayBuilderTemplateBase
argument_list|(
argument|builder
argument_list|,
argument|parent
argument_list|,
argument|eltTy
argument_list|)
block|{}
block|}
block|;
comment|/// A helper class of ConstantInitBuilder, used for building constant
comment|/// struct initializers.
name|class
name|ConstantStructBuilder
operator|:
name|public
name|ConstantStructBuilderTemplateBase
operator|<
name|ConstantInitBuilderTraits
operator|>
block|{
name|template
operator|<
name|class
name|Traits
operator|>
name|friend
name|class
name|ConstantInitBuilderTemplateBase
block|;
comment|// The use of explicit qualification is a GCC workaround.
name|template
operator|<
name|class
name|Impl
block|,
name|class
name|Traits
operator|>
name|friend
name|class
name|CodeGen
operator|::
name|ConstantAggregateBuilderTemplateBase
block|;
name|ConstantStructBuilder
argument_list|(
name|ConstantInitBuilder
operator|&
name|builder
argument_list|,
name|ConstantAggregateBuilderBase
operator|*
name|parent
argument_list|,
name|llvm
operator|::
name|StructType
operator|*
name|structTy
argument_list|)
operator|:
name|ConstantStructBuilderTemplateBase
argument_list|(
argument|builder
argument_list|,
argument|parent
argument_list|,
argument|structTy
argument_list|)
block|{}
block|}
block|;  }
comment|// end namespace CodeGen
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

