begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- SemaInternal.h - Internal Sema Interfaces --------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file provides common API and #includes for the internal
end_comment

begin_comment
comment|// implementation of Sema.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_SEMAINTERNAL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_SEMAINTERNAL_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/ASTContext.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Lookup.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/SemaDiagnostic.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
specifier|inline
name|PartialDiagnostic
name|Sema
operator|::
name|PDiag
argument_list|(
argument|unsigned DiagID
argument_list|)
block|{
return|return
name|PartialDiagnostic
argument_list|(
name|DiagID
argument_list|,
name|Context
operator|.
name|getDiagAllocator
argument_list|()
argument_list|)
return|;
block|}
specifier|inline
name|bool
name|FTIHasSingleVoidParameter
argument_list|(
specifier|const
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|FTI
argument_list|)
block|{
return|return
name|FTI
operator|.
name|NumParams
operator|==
literal|1
operator|&&
operator|!
name|FTI
operator|.
name|isVariadic
operator|&&
name|FTI
operator|.
name|Params
index|[
literal|0
index|]
operator|.
name|Ident
operator|==
name|nullptr
operator|&&
name|FTI
operator|.
name|Params
index|[
literal|0
index|]
operator|.
name|Param
operator|&&
name|cast
operator|<
name|ParmVarDecl
operator|>
operator|(
name|FTI
operator|.
name|Params
index|[
literal|0
index|]
operator|.
name|Param
operator|)
operator|->
name|getType
argument_list|()
operator|->
name|isVoidType
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|FTIHasNonVoidParameters
argument_list|(
specifier|const
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|FTI
argument_list|)
block|{
comment|// Assume FTI is well-formed.
return|return
name|FTI
operator|.
name|NumParams
operator|&&
operator|!
name|FTIHasSingleVoidParameter
argument_list|(
name|FTI
argument_list|)
return|;
block|}
comment|// This requires the variable to be non-dependent and the initializer
comment|// to not be value dependent.
specifier|inline
name|bool
name|IsVariableAConstantExpression
parameter_list|(
name|VarDecl
modifier|*
name|Var
parameter_list|,
name|ASTContext
modifier|&
name|Context
parameter_list|)
block|{
specifier|const
name|VarDecl
modifier|*
name|DefVD
init|=
name|nullptr
decl_stmt|;
return|return
operator|!
name|isa
operator|<
name|ParmVarDecl
operator|>
operator|(
name|Var
operator|)
operator|&&
name|Var
operator|->
name|isUsableInConstantExpressions
argument_list|(
name|Context
argument_list|)
operator|&&
name|Var
operator|->
name|getAnyInitializer
argument_list|(
name|DefVD
argument_list|)
operator|&&
name|DefVD
operator|->
name|checkInitIsICE
argument_list|()
return|;
block|}
comment|// Directly mark a variable odr-used. Given a choice, prefer to use
comment|// MarkVariableReferenced since it does additional checks and then
comment|// calls MarkVarDeclODRUsed.
comment|// If the variable must be captured:
comment|//  - if FunctionScopeIndexToStopAt is null, capture it in the CurContext
comment|//  - else capture it in the DeclContext that maps to the
comment|//    *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.
specifier|inline
name|void
name|MarkVarDeclODRUsed
parameter_list|(
name|VarDecl
modifier|*
name|Var
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|Sema
modifier|&
name|SemaRef
parameter_list|,
specifier|const
name|unsigned
modifier|*
specifier|const
name|FunctionScopeIndexToStopAt
parameter_list|)
block|{
comment|// Keep track of used but undefined variables.
comment|// FIXME: We shouldn't suppress this warning for static data members.
if|if
condition|(
name|Var
operator|->
name|hasDefinition
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
operator|==
name|VarDecl
operator|::
name|DeclarationOnly
operator|&&
operator|!
name|Var
operator|->
name|isExternallyVisible
argument_list|()
operator|&&
operator|!
operator|(
name|Var
operator|->
name|isStaticDataMember
argument_list|()
operator|&&
name|Var
operator|->
name|hasInit
argument_list|()
operator|)
condition|)
block|{
name|SourceLocation
modifier|&
name|old
init|=
name|SemaRef
operator|.
name|UndefinedButUsed
index|[
name|Var
operator|->
name|getCanonicalDecl
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|old
operator|.
name|isInvalid
argument_list|()
condition|)
name|old
operator|=
name|Loc
expr_stmt|;
block|}
name|QualType
name|CaptureType
decl_stmt|,
name|DeclRefType
decl_stmt|;
name|SemaRef
operator|.
name|tryCaptureVariable
argument_list|(
name|Var
argument_list|,
name|Loc
argument_list|,
name|Sema
operator|::
name|TryCapture_Implicit
argument_list|,
comment|/*EllipsisLoc*/
name|SourceLocation
argument_list|()
argument_list|,
comment|/*BuildAndDiagnose*/
name|true
argument_list|,
name|CaptureType
argument_list|,
name|DeclRefType
argument_list|,
name|FunctionScopeIndexToStopAt
argument_list|)
expr_stmt|;
name|Var
operator|->
name|markUsed
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
expr_stmt|;
block|}
comment|/// Return a DLL attribute from the declaration.
specifier|inline
name|InheritableAttr
modifier|*
name|getDLLAttr
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|D
operator|->
name|hasAttr
operator|<
name|DLLImportAttr
operator|>
operator|(
operator|)
operator|&&
name|D
operator|->
name|hasAttr
operator|<
name|DLLExportAttr
operator|>
operator|(
operator|)
operator|)
operator|&&
literal|"A declaration cannot be both dllimport and dllexport."
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto
operator|*
name|Import
operator|=
name|D
operator|->
name|getAttr
operator|<
name|DLLImportAttr
operator|>
operator|(
operator|)
condition|)
return|return
name|Import
return|;
if|if
condition|(
name|auto
operator|*
name|Export
operator|=
name|D
operator|->
name|getAttr
operator|<
name|DLLExportAttr
operator|>
operator|(
operator|)
condition|)
return|return
name|Export
return|;
return|return
name|nullptr
return|;
block|}
name|class
name|TypoCorrectionConsumer
range|:
name|public
name|VisibleDeclConsumer
block|{
typedef|typedef
name|SmallVector
operator|<
name|TypoCorrection
operator|,
literal|1
operator|>
name|TypoResultList
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|StringMap
operator|<
name|TypoResultList
operator|>
name|TypoResultsMap
expr_stmt|;
typedef|typedef
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|TypoResultsMap
operator|>
name|TypoEditDistanceMap
expr_stmt|;
name|public
label|:
name|TypoCorrectionConsumer
argument_list|(
argument|Sema&SemaRef
argument_list|,
argument|const DeclarationNameInfo&TypoName
argument_list|,
argument|Sema::LookupNameKind LookupKind
argument_list|,
argument|Scope *S
argument_list|,
argument|CXXScopeSpec *SS
argument_list|,
argument|std::unique_ptr<CorrectionCandidateCallback> CCC
argument_list|,
argument|DeclContext *MemberContext
argument_list|,
argument|bool EnteringContext
argument_list|)
block|:
name|Typo
argument_list|(
name|TypoName
operator|.
name|getName
argument_list|()
operator|.
name|getAsIdentifierInfo
argument_list|()
argument_list|)
operator|,
name|CurrentTCIndex
argument_list|(
literal|0
argument_list|)
operator|,
name|SavedTCIndex
argument_list|(
literal|0
argument_list|)
operator|,
name|SemaRef
argument_list|(
name|SemaRef
argument_list|)
operator|,
name|S
argument_list|(
name|S
argument_list|)
operator|,
name|SS
argument_list|(
name|SS
condition|?
name|llvm
operator|::
name|make_unique
operator|<
name|CXXScopeSpec
operator|>
operator|(
operator|*
name|SS
operator|)
else|:
name|nullptr
argument_list|)
operator|,
name|CorrectionValidator
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|CCC
argument_list|)
argument_list|)
operator|,
name|MemberContext
argument_list|(
name|MemberContext
argument_list|)
operator|,
name|Result
argument_list|(
name|SemaRef
argument_list|,
name|TypoName
argument_list|,
name|LookupKind
argument_list|)
operator|,
name|Namespaces
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|SemaRef
operator|.
name|CurContext
argument_list|,
name|SS
argument_list|)
operator|,
name|EnteringContext
argument_list|(
name|EnteringContext
argument_list|)
operator|,
name|SearchNamespaces
argument_list|(
argument|false
argument_list|)
block|{
name|Result
operator|.
name|suppressDiagnostics
argument_list|()
block|;
comment|// Arrange for ValidatedCorrections[0] to always be an empty correction.
name|ValidatedCorrections
operator|.
name|push_back
argument_list|(
name|TypoCorrection
argument_list|()
argument_list|)
block|;   }
name|bool
name|includeHiddenDecls
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
comment|// Methods for adding potential corrections to the consumer.
name|void
name|FoundDecl
argument_list|(
name|NamedDecl
operator|*
name|ND
argument_list|,
name|NamedDecl
operator|*
name|Hiding
argument_list|,
name|DeclContext
operator|*
name|Ctx
argument_list|,
name|bool
name|InBaseClass
argument_list|)
name|override
decl_stmt|;
name|void
name|FoundName
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|void
name|addKeywordResult
parameter_list|(
name|StringRef
name|Keyword
parameter_list|)
function_decl|;
name|void
name|addCorrection
parameter_list|(
name|TypoCorrection
name|Correction
parameter_list|)
function_decl|;
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|CorrectionResults
operator|.
name|empty
argument_list|()
operator|&&
name|ValidatedCorrections
operator|.
name|size
argument_list|()
operator|==
literal|1
return|;
block|}
comment|/// \brief Return the list of TypoCorrections for the given identifier from
comment|/// the set of corrections that have the closest edit distance, if any.
name|TypoResultList
modifier|&
name|operator
function|[]
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
return|return
name|CorrectionResults
operator|.
name|begin
argument_list|()
operator|->
name|second
index|[
name|Name
index|]
return|;
block|}
comment|/// \brief Return the edit distance of the corrections that have the
comment|/// closest/best edit distance from the original typop.
name|unsigned
name|getBestEditDistance
parameter_list|(
name|bool
name|Normalized
parameter_list|)
block|{
if|if
condition|(
name|CorrectionResults
operator|.
name|empty
argument_list|()
condition|)
return|return
operator|(
name|std
operator|::
name|numeric_limits
operator|<
name|unsigned
operator|>
operator|::
name|max
operator|)
operator|(
operator|)
return|;
name|unsigned
name|BestED
init|=
name|CorrectionResults
operator|.
name|begin
argument_list|()
operator|->
name|first
decl_stmt|;
return|return
name|Normalized
condition|?
name|TypoCorrection
operator|::
name|NormalizeEditDistance
argument_list|(
name|BestED
argument_list|)
else|:
name|BestED
return|;
block|}
comment|/// \brief Set-up method to add to the consumer the set of namespaces to use
comment|/// in performing corrections to nested name specifiers. This method also
comment|/// implicitly adds all of the known classes in the current AST context to the
comment|/// to the consumer for correcting nested name specifiers.
name|void
name|addNamespaces
argument_list|(
specifier|const
name|llvm
operator|::
name|MapVector
operator|<
name|NamespaceDecl
operator|*
argument_list|,
name|bool
operator|>
operator|&
name|KnownNamespaces
argument_list|)
decl_stmt|;
comment|/// \brief Return the next typo correction that passes all internal filters
comment|/// and is deemed valid by the consumer's CorrectionCandidateCallback,
comment|/// starting with the corrections that have the closest edit distance. An
comment|/// empty TypoCorrection is returned once no more viable corrections remain
comment|/// in the consumer.
specifier|const
name|TypoCorrection
modifier|&
name|getNextCorrection
parameter_list|()
function_decl|;
comment|/// \brief Get the last correction returned by getNextCorrection().
specifier|const
name|TypoCorrection
modifier|&
name|getCurrentCorrection
parameter_list|()
block|{
return|return
name|CurrentTCIndex
operator|<
name|ValidatedCorrections
operator|.
name|size
argument_list|()
condition|?
name|ValidatedCorrections
index|[
name|CurrentTCIndex
index|]
else|:
name|ValidatedCorrections
index|[
literal|0
index|]
return|;
comment|// The empty correction.
block|}
comment|/// \brief Return the next typo correction like getNextCorrection, but keep
comment|/// the internal state pointed to the current correction (i.e. the next time
comment|/// getNextCorrection is called, it will return the same correction returned
comment|/// by peekNextcorrection).
specifier|const
name|TypoCorrection
modifier|&
name|peekNextCorrection
parameter_list|()
block|{
name|auto
name|Current
init|=
name|CurrentTCIndex
decl_stmt|;
specifier|const
name|TypoCorrection
modifier|&
name|TC
init|=
name|getNextCorrection
argument_list|()
decl_stmt|;
name|CurrentTCIndex
operator|=
name|Current
expr_stmt|;
return|return
name|TC
return|;
block|}
comment|/// \brief Reset the consumer's position in the stream of viable corrections
comment|/// (i.e. getNextCorrection() will return each of the previously returned
comment|/// corrections in order before returning any new corrections).
name|void
name|resetCorrectionStream
parameter_list|()
block|{
name|CurrentTCIndex
operator|=
literal|0
expr_stmt|;
block|}
comment|/// \brief Return whether the end of the stream of corrections has been
comment|/// reached.
name|bool
name|finished
parameter_list|()
block|{
return|return
name|CorrectionResults
operator|.
name|empty
argument_list|()
operator|&&
name|CurrentTCIndex
operator|>=
name|ValidatedCorrections
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// \brief Save the current position in the correction stream (overwriting any
comment|/// previously saved position).
name|void
name|saveCurrentPosition
parameter_list|()
block|{
name|SavedTCIndex
operator|=
name|CurrentTCIndex
expr_stmt|;
block|}
comment|/// \brief Restore the saved position in the correction stream.
name|void
name|restoreSavedPosition
parameter_list|()
block|{
name|CurrentTCIndex
operator|=
name|SavedTCIndex
expr_stmt|;
block|}
name|ASTContext
operator|&
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|SemaRef
operator|.
name|Context
return|;
block|}
specifier|const
name|LookupResult
operator|&
name|getLookupResult
argument_list|()
specifier|const
block|{
return|return
name|Result
return|;
block|}
name|bool
name|isAddressOfOperand
argument_list|()
specifier|const
block|{
return|return
name|CorrectionValidator
operator|->
name|IsAddressOfOperand
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|*
name|getSS
argument_list|()
specifier|const
block|{
return|return
name|SS
operator|.
name|get
argument_list|()
return|;
block|}
name|Scope
operator|*
name|getScope
argument_list|()
specifier|const
block|{
return|return
name|S
return|;
block|}
name|private
label|:
name|class
name|NamespaceSpecifierSet
block|{
struct|struct
name|SpecifierInfo
block|{
name|DeclContext
modifier|*
name|DeclCtx
decl_stmt|;
name|NestedNameSpecifier
modifier|*
name|NameSpecifier
decl_stmt|;
name|unsigned
name|EditDistance
decl_stmt|;
block|}
struct|;
typedef|typedef
name|SmallVector
operator|<
name|DeclContext
operator|*
operator|,
literal|4
operator|>
name|DeclContextList
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|SpecifierInfo
operator|,
literal|16
operator|>
name|SpecifierInfoList
expr_stmt|;
name|ASTContext
modifier|&
name|Context
decl_stmt|;
name|DeclContextList
name|CurContextChain
decl_stmt|;
name|std
operator|::
name|string
name|CurNameSpecifier
expr_stmt|;
name|SmallVector
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|,
literal|4
operator|>
name|CurContextIdentifiers
expr_stmt|;
name|SmallVector
operator|<
specifier|const
name|IdentifierInfo
operator|*
operator|,
literal|4
operator|>
name|CurNameSpecifierIdentifiers
expr_stmt|;
name|bool
name|isSorted
decl_stmt|;
name|SpecifierInfoList
name|Specifiers
decl_stmt|;
name|llvm
operator|::
name|SmallSetVector
operator|<
name|unsigned
operator|,
literal|4
operator|>
name|Distances
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|SpecifierInfoList
operator|>
name|DistanceMap
expr_stmt|;
comment|/// \brief Helper for building the list of DeclContexts between the current
comment|/// context and the top of the translation unit
specifier|static
name|DeclContextList
name|buildContextChain
parameter_list|(
name|DeclContext
modifier|*
name|Start
parameter_list|)
function_decl|;
name|void
name|sortNamespaces
parameter_list|()
function_decl|;
name|unsigned
name|buildNestedNameSpecifier
parameter_list|(
name|DeclContextList
modifier|&
name|DeclChain
parameter_list|,
name|NestedNameSpecifier
modifier|*
modifier|&
name|NNS
parameter_list|)
function_decl|;
name|public
label|:
name|NamespaceSpecifierSet
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|,
name|DeclContext
operator|*
name|CurContext
argument_list|,
name|CXXScopeSpec
operator|*
name|CurScopeSpec
argument_list|)
expr_stmt|;
comment|/// \brief Add the DeclContext (a namespace or record) to the set, computing
comment|/// the corresponding NestedNameSpecifier and its distance in the process.
name|void
name|addNameSpecifier
parameter_list|(
name|DeclContext
modifier|*
name|Ctx
parameter_list|)
function_decl|;
typedef|typedef
name|SpecifierInfoList
operator|::
name|iterator
name|iterator
expr_stmt|;
name|iterator
name|begin
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSorted
condition|)
name|sortNamespaces
argument_list|()
expr_stmt|;
return|return
name|Specifiers
operator|.
name|begin
argument_list|()
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
return|return
name|Specifiers
operator|.
name|end
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|void
name|addName
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|NamedDecl
modifier|*
name|ND
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|NNS
init|=
name|nullptr
parameter_list|,
name|bool
name|isKeyword
init|=
name|false
parameter_list|)
function_decl|;
comment|/// \brief Find any visible decls for the given typo correction candidate.
comment|/// If none are found, it to the set of candidates for which qualified lookups
comment|/// will be performed to find possible nested name specifier changes.
name|bool
name|resolveCorrection
parameter_list|(
name|TypoCorrection
modifier|&
name|Candidate
parameter_list|)
function_decl|;
comment|/// \brief Perform qualified lookups on the queued set of typo correction
comment|/// candidates and add the nested name specifier changes to each candidate if
comment|/// a lookup succeeds (at which point the candidate will be returned to the
comment|/// main pool of potential corrections).
name|void
name|performQualifiedLookups
parameter_list|()
function_decl|;
comment|/// \brief The name written that is a typo in the source.
name|IdentifierInfo
modifier|*
name|Typo
decl_stmt|;
comment|/// \brief The results found that have the smallest edit distance
comment|/// found (so far) with the typo name.
comment|///
comment|/// The pointer value being set to the current DeclContext indicates
comment|/// whether there is a keyword with this name.
name|TypoEditDistanceMap
name|CorrectionResults
decl_stmt|;
name|SmallVector
operator|<
name|TypoCorrection
operator|,
literal|4
operator|>
name|ValidatedCorrections
expr_stmt|;
name|size_t
name|CurrentTCIndex
decl_stmt|;
name|size_t
name|SavedTCIndex
decl_stmt|;
name|Sema
modifier|&
name|SemaRef
decl_stmt|;
name|Scope
modifier|*
name|S
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|CXXScopeSpec
operator|>
name|SS
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|CorrectionCandidateCallback
operator|>
name|CorrectionValidator
expr_stmt|;
name|DeclContext
modifier|*
name|MemberContext
decl_stmt|;
name|LookupResult
name|Result
decl_stmt|;
name|NamespaceSpecifierSet
name|Namespaces
decl_stmt|;
name|SmallVector
operator|<
name|TypoCorrection
operator|,
literal|2
operator|>
name|QualifiedResults
expr_stmt|;
name|bool
name|EnteringContext
decl_stmt|;
name|bool
name|SearchNamespaces
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|inline
name|Sema
operator|::
name|TypoExprState
operator|::
name|TypoExprState
argument_list|()
block|{}
specifier|inline
name|Sema
operator|::
name|TypoExprState
operator|::
name|TypoExprState
argument_list|(
argument|TypoExprState&&other
argument_list|)
name|LLVM_NOEXCEPT
block|{
operator|*
name|this
operator|=
name|std
operator|::
name|move
argument_list|(
name|other
argument_list|)
block|; }
specifier|inline
name|Sema
operator|::
name|TypoExprState
operator|&
name|Sema
operator|::
name|TypoExprState
operator|::
name|operator
operator|=
operator|(
name|Sema
operator|::
name|TypoExprState
operator|&&
name|other
operator|)
name|LLVM_NOEXCEPT
block|{
name|Consumer
operator|=
name|std
operator|::
name|move
argument_list|(
name|other
operator|.
name|Consumer
argument_list|)
block|;
name|DiagHandler
operator|=
name|std
operator|::
name|move
argument_list|(
name|other
operator|.
name|DiagHandler
argument_list|)
block|;
name|RecoveryHandler
operator|=
name|std
operator|::
name|move
argument_list|(
name|other
operator|.
name|RecoveryHandler
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

