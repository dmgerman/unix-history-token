begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- AttributeList.h - Parsed attribute sets ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the AttributeList class, which is used to collect
end_comment

begin_comment
comment|// parsed attributes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|Expr
decl_stmt|;
comment|/// \brief Represents information about a change in availability for
comment|/// an entity, which is part of the encoding of the 'availability'
comment|/// attribute.
struct|struct
name|AvailabilityChange
block|{
comment|/// \brief The location of the keyword indicating the kind of change.
name|SourceLocation
name|KeywordLoc
decl_stmt|;
comment|/// \brief The version number at which the change occurred.
name|VersionTuple
name|Version
decl_stmt|;
comment|/// \brief The source range covering the version number.
name|SourceRange
name|VersionRange
decl_stmt|;
comment|/// \brief Determine whether this availability change is valid.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Version
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
struct|;
comment|/// AttributeList - Represents GCC's __attribute__ declaration. There are
comment|/// 4 forms of this construct...they are:
comment|///
comment|/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.
comment|/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.
comment|/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.
comment|/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.
comment|///
name|class
name|AttributeList
block|{
comment|// TODO: This should really be called ParsedAttribute
name|private
label|:
name|IdentifierInfo
modifier|*
name|AttrName
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ScopeName
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ParmName
decl_stmt|;
name|SourceLocation
name|AttrLoc
decl_stmt|;
name|SourceLocation
name|ScopeLoc
decl_stmt|;
name|SourceLocation
name|ParmLoc
decl_stmt|;
comment|/// The number of expression arguments this attribute has.
comment|/// The expressions themselves are stored after the object.
name|unsigned
name|NumArgs
range|:
literal|16
decl_stmt|;
comment|/// True if Microsoft style: declspec(foo).
name|unsigned
name|DeclspecAttribute
range|:
literal|1
decl_stmt|;
comment|/// True if C++0x-style: [[foo]].
name|unsigned
name|CXX0XAttribute
range|:
literal|1
decl_stmt|;
comment|/// True if already diagnosed as invalid.
name|mutable
name|unsigned
name|Invalid
range|:
literal|1
decl_stmt|;
comment|/// True if this has the extra information associated with an
comment|/// availability attribute.
name|unsigned
name|IsAvailability
range|:
literal|1
decl_stmt|;
comment|/// \brief The location of the 'unavailable' keyword in an
comment|/// availability attribute.
name|SourceLocation
name|UnavailableLoc
decl_stmt|;
comment|/// The next attribute in the current position.
name|AttributeList
modifier|*
name|NextInPosition
decl_stmt|;
comment|/// The next attribute allocated in the current Pool.
name|AttributeList
modifier|*
name|NextInPool
decl_stmt|;
name|Expr
modifier|*
modifier|*
name|getArgsBuffer
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|Expr
operator|*
specifier|const
operator|*
name|getArgsBuffer
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Expr
operator|*
specifier|const
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
enum|enum
name|AvailabilitySlot
block|{
name|IntroducedSlot
block|,
name|DeprecatedSlot
block|,
name|ObsoletedSlot
block|}
enum|;
name|AvailabilityChange
modifier|&
name|getAvailabilitySlot
parameter_list|(
name|AvailabilitySlot
name|index
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|AvailabilityChange
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
index|[
name|index
index|]
return|;
block|}
specifier|const
name|AvailabilityChange
modifier|&
name|getAvailabilitySlot
argument_list|(
name|AvailabilitySlot
name|index
argument_list|)
decl|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|AvailabilityChange
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
index|[
name|index
index|]
return|;
block|}
name|AttributeList
argument_list|(
specifier|const
name|AttributeList
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|AttributeList
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|// DO NOT IMPLEMENT
operator|~
name|AttributeList
argument_list|()
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|size_t
name|allocated_size
argument_list|()
specifier|const
decl_stmt|;
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceLocation attrLoc
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|Expr **args
argument_list|,
argument|unsigned numArgs
argument_list|,
argument|bool declspec
argument_list|,
argument|bool cxx0x
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrLoc
argument_list|(
name|attrLoc
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|NumArgs
argument_list|(
name|numArgs
argument_list|)
operator|,
name|DeclspecAttribute
argument_list|(
name|declspec
argument_list|)
operator|,
name|CXX0XAttribute
argument_list|(
name|cxx0x
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|numArgs
condition|)
name|memcpy
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
name|args
argument_list|,
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|Expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceLocation attrLoc
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *parmName
argument_list|,
argument|SourceLocation parmLoc
argument_list|,
argument|const AvailabilityChange&introduced
argument_list|,
argument|const AvailabilityChange&deprecated
argument_list|,
argument|const AvailabilityChange&obsoleted
argument_list|,
argument|SourceLocation unavailable
argument_list|,
argument|bool declspec
argument_list|,
argument|bool cxx0x
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|ParmName
argument_list|(
name|parmName
argument_list|)
operator|,
name|AttrLoc
argument_list|(
name|attrLoc
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|ParmLoc
argument_list|(
name|parmLoc
argument_list|)
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|DeclspecAttribute
argument_list|(
name|declspec
argument_list|)
operator|,
name|CXX0XAttribute
argument_list|(
name|cxx0x
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|true
argument_list|)
operator|,
name|UnavailableLoc
argument_list|(
name|unavailable
argument_list|)
operator|,
name|NextInPosition
argument_list|(
literal|0
argument_list|)
operator|,
name|NextInPool
argument_list|(
literal|0
argument_list|)
block|{
name|new
argument_list|(
argument|&getAvailabilitySlot(IntroducedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|introduced
argument_list|)
block|;
name|new
argument_list|(
argument|&getAvailabilitySlot(DeprecatedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|deprecated
argument_list|)
block|;
name|new
argument_list|(
argument|&getAvailabilitySlot(ObsoletedSlot)
argument_list|)
name|AvailabilityChange
argument_list|(
name|obsoleted
argument_list|)
block|;   }
name|friend
name|class
name|AttributePool
expr_stmt|;
name|friend
name|class
name|AttributeFactory
decl_stmt|;
name|public
label|:
enum|enum
name|Kind
block|{
comment|// Please keep this list alphabetized.
name|AT_IBAction
block|,
comment|// Clang-specific.
name|AT_IBOutlet
block|,
comment|// Clang-specific.
name|AT_IBOutletCollection
block|,
comment|// Clang-specific.
name|AT_address_space
block|,
name|AT_alias
block|,
name|AT_aligned
block|,
name|AT_always_inline
block|,
name|AT_analyzer_noreturn
block|,
name|AT_annotate
block|,
name|AT_availability
block|,
comment|// Clang-specific
name|AT_base_check
block|,
name|AT_blocks
block|,
name|AT_carries_dependency
block|,
name|AT_cdecl
block|,
name|AT_cleanup
block|,
name|AT_common
block|,
name|AT_const
block|,
name|AT_constant
block|,
name|AT_constructor
block|,
name|AT_deprecated
block|,
name|AT_destructor
block|,
name|AT_device
block|,
name|AT_dllexport
block|,
name|AT_dllimport
block|,
name|AT_ext_vector_type
block|,
name|AT_fastcall
block|,
name|AT_format
block|,
name|AT_format_arg
block|,
name|AT_global
block|,
name|AT_gnu_inline
block|,
name|AT_host
block|,
name|AT_launch_bounds
block|,
name|AT_malloc
block|,
name|AT_may_alias
block|,
name|AT_mode
block|,
name|AT_neon_polyvector_type
block|,
comment|// Clang-specific.
name|AT_neon_vector_type
block|,
comment|// Clang-specific.
name|AT_naked
block|,
name|AT_nodebug
block|,
name|AT_noinline
block|,
name|AT_no_instrument_function
block|,
name|AT_nocommon
block|,
name|AT_nonnull
block|,
name|AT_noreturn
block|,
name|AT_nothrow
block|,
name|AT_nsobject
block|,
name|AT_objc_exception
block|,
name|AT_objc_method_family
block|,
name|AT_cf_returns_not_retained
block|,
comment|// Clang-specific.
name|AT_cf_returns_retained
block|,
comment|// Clang-specific.
name|AT_ns_returns_not_retained
block|,
comment|// Clang-specific.
name|AT_ns_returns_retained
block|,
comment|// Clang-specific.
name|AT_ns_returns_autoreleased
block|,
comment|// Clang-specific.
name|AT_cf_consumed
block|,
comment|// Clang-specific.
name|AT_ns_consumed
block|,
comment|// Clang-specific.
name|AT_ns_consumes_self
block|,
comment|// Clang-specific.
name|AT_objc_gc
block|,
name|AT_opencl_image_access
block|,
comment|// OpenCL-specific.
name|AT_opencl_kernel_function
block|,
comment|// OpenCL-specific.
name|AT_overloadable
block|,
comment|// Clang-specific.
name|AT_ownership_holds
block|,
comment|// Clang-specific.
name|AT_ownership_returns
block|,
comment|// Clang-specific.
name|AT_ownership_takes
block|,
comment|// Clang-specific.
name|AT_packed
block|,
name|AT_pascal
block|,
name|AT_pcs
block|,
comment|// ARM specific
name|AT_pure
block|,
name|AT_regparm
block|,
name|AT_section
block|,
name|AT_sentinel
block|,
name|AT_shared
block|,
name|AT_stdcall
block|,
name|AT_thiscall
block|,
name|AT_transparent_union
block|,
name|AT_unavailable
block|,
name|AT_unused
block|,
name|AT_used
block|,
name|AT_uuid
block|,
name|AT_vecreturn
block|,
comment|// PS3 PPU-specific.
name|AT_vector_size
block|,
name|AT_visibility
block|,
name|AT_warn_unused_result
block|,
name|AT_weak
block|,
name|AT_weakref
block|,
name|AT_weak_import
block|,
name|AT_reqd_wg_size
block|,
name|AT_init_priority
block|,
name|AT_MsStruct
block|,
name|IgnoredAttribute
block|,
name|UnknownAttribute
block|}
enum|;
name|IdentifierInfo
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|AttrName
return|;
block|}
name|SourceLocation
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|AttrLoc
return|;
block|}
name|bool
name|hasScope
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|IdentifierInfo
operator|*
name|getScopeName
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|SourceLocation
name|getScopeLoc
argument_list|()
specifier|const
block|{
return|return
name|ScopeLoc
return|;
block|}
name|IdentifierInfo
operator|*
name|getParameterName
argument_list|()
specifier|const
block|{
return|return
name|ParmName
return|;
block|}
name|SourceLocation
name|getParameterLoc
argument_list|()
specifier|const
block|{
return|return
name|ParmLoc
return|;
block|}
name|bool
name|isDeclspecAttribute
argument_list|()
specifier|const
block|{
return|return
name|DeclspecAttribute
return|;
block|}
name|bool
name|isCXX0XAttribute
argument_list|()
specifier|const
block|{
return|return
name|CXX0XAttribute
return|;
block|}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
name|void
name|setInvalid
argument_list|(
name|bool
name|b
operator|=
name|true
argument_list|)
decl|const
block|{
name|Invalid
operator|=
name|b
expr_stmt|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|Kind
name|getKind
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|)
function_decl|;
name|AttributeList
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|NextInPosition
return|;
block|}
name|void
name|setNext
parameter_list|(
name|AttributeList
modifier|*
name|N
parameter_list|)
block|{
name|NextInPosition
operator|=
name|N
expr_stmt|;
block|}
comment|/// getNumArgs - Return the number of actual arguments to this attribute.
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
comment|/// hasParameterOrArguments - Return true if this attribute has a parameter,
comment|/// or has a non empty argument expression list.
name|bool
name|hasParameterOrArguments
argument_list|()
specifier|const
block|{
return|return
name|ParmName
operator|||
name|NumArgs
return|;
block|}
comment|/// getArg - Return the specified argument.
name|Expr
modifier|*
name|getArg
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Arg
operator|<
name|NumArgs
operator|&&
literal|"Arg access out of range!"
argument_list|)
expr_stmt|;
return|return
name|getArgsBuffer
argument_list|()
index|[
name|Arg
index|]
return|;
block|}
name|class
name|arg_iterator
block|{
name|Expr
modifier|*
specifier|const
modifier|*
name|X
decl_stmt|;
name|unsigned
name|Idx
decl_stmt|;
name|public
label|:
name|arg_iterator
argument_list|(
argument|Expr * const *x
argument_list|,
argument|unsigned idx
argument_list|)
block|:
name|X
argument_list|(
name|x
argument_list|)
operator|,
name|Idx
argument_list|(
argument|idx
argument_list|)
block|{}
name|arg_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|X
operator|==
name|I
operator|.
name|X
operator|&&
literal|"compared arg_iterators are for different argument lists"
argument_list|)
block|;
return|return
name|Idx
operator|==
name|I
operator|.
name|Idx
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|I
operator|)
return|;
block|}
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|X
index|[
name|Idx
index|]
return|;
block|}
name|unsigned
name|getArgNum
argument_list|()
specifier|const
block|{
return|return
name|Idx
operator|+
literal|1
return|;
block|}
block|}
empty_stmt|;
name|arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
name|NumArgs
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityIntroduced
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|IntroducedSlot
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityDeprecated
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|DeprecatedSlot
argument_list|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityObsoleted
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilitySlot
argument_list|(
name|ObsoletedSlot
argument_list|)
return|;
block|}
name|SourceLocation
name|getUnavailableLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|UnavailableLoc
return|;
block|}
block|}
empty_stmt|;
comment|/// A factory, from which one makes pools, from which one creates
comment|/// individual attributes which are deallocated with the pool.
comment|///
comment|/// Note that it's tolerably cheap to create and destroy one of
comment|/// these as long as you don't actually allocate anything in it.
name|class
name|AttributeFactory
block|{
name|public
label|:
enum|enum
block|{
comment|/// The required allocation size of an availability attribute,
comment|/// which we want to ensure is a multiple of sizeof(void*).
name|AvailabilityAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|AvailabilityChange
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
block|}
enum|;
name|private
label|:
enum|enum
block|{
comment|/// The number of free lists we want to be sure to support
comment|/// inline.  This is just enough that availability attributes
comment|/// don't surpass it.  It's actually very unlikely we'll see an
comment|/// attribute that needs more than that; on x86-64 you'd need 10
comment|/// expression arguments, and on i386 you'd need 19.
name|InlineFreeListsCapacity
init|=
literal|1
operator|+
operator|(
name|AvailabilityAllocSize
operator|-
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|)
operator|/
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|llvm
operator|::
name|BumpPtrAllocator
name|Alloc
expr_stmt|;
comment|/// Free lists.  The index is determined by the following formula:
comment|///   (size - sizeof(AttributeList)) / sizeof(void*)
name|llvm
operator|::
name|SmallVector
operator|<
name|AttributeList
operator|*
operator|,
name|InlineFreeListsCapacity
operator|>
name|FreeLists
expr_stmt|;
comment|// The following are the private interface used by AttributePool.
name|friend
name|class
name|AttributePool
decl_stmt|;
comment|/// Allocate an attribute of the given size.
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/// Reclaim all the attributes in the given pool chain, which is
comment|/// non-empty.  Note that the current implementation is safe
comment|/// against reclaiming things which were not actually allocated
comment|/// with the allocator, although of course it's important to make
comment|/// sure that their allocator lives at least as long as this one.
name|void
name|reclaimPool
parameter_list|(
name|AttributeList
modifier|*
name|head
parameter_list|)
function_decl|;
name|public
label|:
name|AttributeFactory
argument_list|()
expr_stmt|;
operator|~
name|AttributeFactory
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|class
name|AttributePool
block|{
name|AttributeFactory
modifier|&
name|Factory
decl_stmt|;
name|AttributeList
modifier|*
name|Head
decl_stmt|;
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|Factory
operator|.
name|allocate
argument_list|(
name|size
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|add
parameter_list|(
name|AttributeList
modifier|*
name|attr
parameter_list|)
block|{
comment|// We don't care about the order of the pool.
name|attr
operator|->
name|NextInPool
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
name|attr
expr_stmt|;
return|return
name|attr
return|;
block|}
name|void
name|takePool
parameter_list|(
name|AttributeList
modifier|*
name|pool
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Create a new pool for a factory.
name|AttributePool
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|Factory
argument_list|(
name|factory
argument_list|)
operator|,
name|Head
argument_list|(
literal|0
argument_list|)
block|{}
comment|/// Move the given pool's allocations to this pool.
name|AttributePool
argument_list|(
name|AttributePool
operator|&
name|pool
argument_list|)
operator|:
name|Factory
argument_list|(
name|pool
operator|.
name|Factory
argument_list|)
operator|,
name|Head
argument_list|(
argument|pool.Head
argument_list|)
block|{
name|pool
operator|.
name|Head
operator|=
literal|0
block|;   }
name|AttributeFactory
operator|&
name|getFactory
argument_list|()
specifier|const
block|{
return|return
name|Factory
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|Head
condition|)
block|{
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
name|Head
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/// Take the given pool's allocations and add them to this pool.
name|void
name|takeAllFrom
parameter_list|(
name|AttributePool
modifier|&
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|.
name|Head
condition|)
block|{
name|takePool
argument_list|(
name|pool
operator|.
name|Head
argument_list|)
expr_stmt|;
name|pool
operator|.
name|Head
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|~
name|AttributePool
argument_list|()
block|{
if|if
condition|(
name|Head
condition|)
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
block|}
name|AttributeList
modifier|*
name|create
parameter_list|(
name|IdentifierInfo
modifier|*
name|attrName
parameter_list|,
name|SourceLocation
name|attrLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|scopeName
parameter_list|,
name|SourceLocation
name|scopeLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|parmName
parameter_list|,
name|SourceLocation
name|parmLoc
parameter_list|,
name|Expr
modifier|*
modifier|*
name|args
parameter_list|,
name|unsigned
name|numArgs
parameter_list|,
name|bool
name|declspec
init|=
name|false
parameter_list|,
name|bool
name|cxx0x
init|=
name|false
parameter_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|Expr
operator|*
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrLoc
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|declspec
argument_list|,
name|cxx0x
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|create
parameter_list|(
name|IdentifierInfo
modifier|*
name|attrName
parameter_list|,
name|SourceLocation
name|attrLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|scopeName
parameter_list|,
name|SourceLocation
name|scopeLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|parmName
parameter_list|,
name|SourceLocation
name|parmLoc
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|introduced
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|deprecated
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|obsoleted
parameter_list|,
name|SourceLocation
name|unavailable
parameter_list|,
name|bool
name|declspec
init|=
name|false
parameter_list|,
name|bool
name|cxx0x
init|=
name|false
parameter_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|AvailabilityAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrLoc
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|declspec
argument_list|,
name|cxx0x
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createIntegerAttribute
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|TokLoc
parameter_list|,
name|int
name|Arg
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|/// addAttributeLists - Add two AttributeLists together
comment|/// The right-hand list is appended to the left-hand list, if any
comment|/// A pointer to the joined list is returned.
comment|/// Note: the lists are not left unmodified.
specifier|inline
name|AttributeList
modifier|*
name|addAttributeLists
parameter_list|(
name|AttributeList
modifier|*
name|Left
parameter_list|,
name|AttributeList
modifier|*
name|Right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Left
condition|)
return|return
name|Right
return|;
name|AttributeList
modifier|*
name|next
init|=
name|Left
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
name|prev
operator|->
name|setNext
argument_list|(
name|Right
argument_list|)
expr_stmt|;
return|return
name|Left
return|;
block|}
comment|/// CXX0XAttributeList - A wrapper around a C++0x attribute list.
comment|/// Stores, in addition to the list proper, whether or not an actual list was
comment|/// (as opposed to an empty list, which may be ill-formed in some places) and
comment|/// the source range of the list.
struct|struct
name|CXX0XAttributeList
block|{
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
name|bool
name|HasAttr
decl_stmt|;
name|CXX0XAttributeList
argument_list|(
argument|AttributeList *attrList
argument_list|,
argument|SourceRange range
argument_list|,
argument|bool hasAttr
argument_list|)
block|:
name|AttrList
argument_list|(
name|attrList
argument_list|)
operator|,
name|Range
argument_list|(
name|range
argument_list|)
operator|,
name|HasAttr
argument_list|(
argument|hasAttr
argument_list|)
block|{   }
name|CXX0XAttributeList
argument_list|()
operator|:
name|AttrList
argument_list|(
literal|0
argument_list|)
operator|,
name|Range
argument_list|()
operator|,
name|HasAttr
argument_list|(
argument|false
argument_list|)
block|{   }
block|}
struct|;
comment|/// ParsedAttributes - A collection of parsed attributes.  Currently
comment|/// we don't differentiate between the various attribute syntaxes,
comment|/// which is basically silly.
comment|///
comment|/// Right now this is a very lightweight container, but the expectation
comment|/// is that this will become significantly more serious.
name|class
name|ParsedAttributes
block|{
name|public
label|:
name|ParsedAttributes
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|pool
argument_list|(
name|factory
argument_list|)
operator|,
name|list
argument_list|(
literal|0
argument_list|)
block|{   }
name|ParsedAttributes
argument_list|(
name|ParsedAttributes
operator|&
name|attrs
argument_list|)
operator|:
name|pool
argument_list|(
name|attrs
operator|.
name|pool
argument_list|)
operator|,
name|list
argument_list|(
argument|attrs.list
argument_list|)
block|{
name|attrs
operator|.
name|list
operator|=
literal|0
block|;   }
name|AttributePool
operator|&
name|getPool
argument_list|()
specifier|const
block|{
return|return
name|pool
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|list
operator|==
literal|0
return|;
block|}
name|void
name|add
parameter_list|(
name|AttributeList
modifier|*
name|newAttr
parameter_list|)
block|{
name|assert
argument_list|(
name|newAttr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|newAttr
operator|->
name|getNext
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newAttr
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newAttr
expr_stmt|;
block|}
name|void
name|addAll
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newList
condition|)
return|return;
name|AttributeList
modifier|*
name|lastInNewList
init|=
name|newList
decl_stmt|;
while|while
condition|(
name|AttributeList
modifier|*
name|next
init|=
name|lastInNewList
operator|->
name|getNext
argument_list|()
condition|)
name|lastInNewList
operator|=
name|next
expr_stmt|;
name|lastInNewList
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|set
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|takeAllFrom
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|addAll
argument_list|(
name|attrs
operator|.
name|list
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|list
operator|=
literal|0
expr_stmt|;
name|pool
operator|.
name|takeAllFrom
argument_list|(
name|attrs
operator|.
name|pool
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|list
operator|=
literal|0
expr_stmt|;
name|pool
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|AttributeList
operator|*
name|getList
argument_list|()
specifier|const
block|{
return|return
name|list
return|;
block|}
comment|/// Returns a reference to the attribute list.  Try not to introduce
comment|/// dependencies on this method, it may not be long-lived.
name|AttributeList
modifier|*
modifier|&
name|getListRef
parameter_list|()
block|{
return|return
name|list
return|;
block|}
name|AttributeList
modifier|*
name|addNew
parameter_list|(
name|IdentifierInfo
modifier|*
name|attrName
parameter_list|,
name|SourceLocation
name|attrLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|scopeName
parameter_list|,
name|SourceLocation
name|scopeLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|parmName
parameter_list|,
name|SourceLocation
name|parmLoc
parameter_list|,
name|Expr
modifier|*
modifier|*
name|args
parameter_list|,
name|unsigned
name|numArgs
parameter_list|,
name|bool
name|declspec
init|=
name|false
parameter_list|,
name|bool
name|cxx0x
init|=
name|false
parameter_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrLoc
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|declspec
argument_list|,
name|cxx0x
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|AttributeList
modifier|*
name|addNew
parameter_list|(
name|IdentifierInfo
modifier|*
name|attrName
parameter_list|,
name|SourceLocation
name|attrLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|scopeName
parameter_list|,
name|SourceLocation
name|scopeLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|parmName
parameter_list|,
name|SourceLocation
name|parmLoc
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|introduced
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|deprecated
parameter_list|,
specifier|const
name|AvailabilityChange
modifier|&
name|obsoleted
parameter_list|,
name|SourceLocation
name|unavailable
parameter_list|,
name|bool
name|declspec
init|=
name|false
parameter_list|,
name|bool
name|cxx0x
init|=
name|false
parameter_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrLoc
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|parmName
argument_list|,
name|parmLoc
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|declspec
argument_list|,
name|cxx0x
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|AttributeList
modifier|*
name|addNewInteger
parameter_list|(
name|ASTContext
modifier|&
name|C
parameter_list|,
name|IdentifierInfo
modifier|*
name|name
parameter_list|,
name|SourceLocation
name|loc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createIntegerAttribute
argument_list|(
name|C
argument_list|,
name|name
argument_list|,
name|loc
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|private
label|:
name|mutable
name|AttributePool
name|pool
decl_stmt|;
name|AttributeList
modifier|*
name|list
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

