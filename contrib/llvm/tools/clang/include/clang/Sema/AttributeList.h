begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- AttributeList.h - Parsed attribute sets ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the AttributeList class, which is used to collect
end_comment

begin_comment
comment|// parsed attributes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_ATTRIBUTELIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_ATTRIBUTELIST_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/AttrSubjectMatchRules.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/TargetInfo.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/VersionTuple.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|Expr
decl_stmt|;
comment|/// \brief Represents information about a change in availability for
comment|/// an entity, which is part of the encoding of the 'availability'
comment|/// attribute.
struct|struct
name|AvailabilityChange
block|{
comment|/// \brief The location of the keyword indicating the kind of change.
name|SourceLocation
name|KeywordLoc
decl_stmt|;
comment|/// \brief The version number at which the change occurred.
name|VersionTuple
name|Version
decl_stmt|;
comment|/// \brief The source range covering the version number.
name|SourceRange
name|VersionRange
decl_stmt|;
comment|/// \brief Determine whether this availability change is valid.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Version
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
struct|;
name|namespace
block|{
enum|enum
name|AvailabilitySlot
block|{
name|IntroducedSlot
block|,
name|DeprecatedSlot
block|,
name|ObsoletedSlot
block|,
name|NumAvailabilitySlots
block|}
enum|;
comment|/// Describes the trailing object for Availability attribute in AttributeList.
struct|struct
name|AvailabilityData
block|{
name|AvailabilityChange
name|Changes
index|[
name|NumAvailabilitySlots
index|]
decl_stmt|;
name|SourceLocation
name|StrictLoc
decl_stmt|;
specifier|const
name|Expr
modifier|*
name|Replacement
decl_stmt|;
name|AvailabilityData
argument_list|(
argument|const AvailabilityChange&Introduced
argument_list|,
argument|const AvailabilityChange&Deprecated
argument_list|,
argument|const AvailabilityChange&Obsoleted
argument_list|,
argument|SourceLocation Strict
argument_list|,
argument|const Expr *ReplaceExpr
argument_list|)
block|:
name|StrictLoc
argument_list|(
name|Strict
argument_list|)
operator|,
name|Replacement
argument_list|(
argument|ReplaceExpr
argument_list|)
block|{
name|Changes
index|[
name|IntroducedSlot
index|]
operator|=
name|Introduced
block|;
name|Changes
index|[
name|DeprecatedSlot
index|]
operator|=
name|Deprecated
block|;
name|Changes
index|[
name|ObsoletedSlot
index|]
operator|=
name|Obsoleted
block|;   }
block|}
struct|;
block|}
comment|/// \brief Wraps an identifier and optional source location for the identifier.
struct|struct
name|IdentifierLoc
block|{
name|SourceLocation
name|Loc
decl_stmt|;
name|IdentifierInfo
modifier|*
name|Ident
decl_stmt|;
specifier|static
name|IdentifierLoc
modifier|*
name|create
parameter_list|(
name|ASTContext
modifier|&
name|Ctx
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Ident
parameter_list|)
function_decl|;
block|}
struct|;
comment|/// \brief A union of the various pointer types that can be passed to an
comment|/// AttributeList as an argument.
typedef|typedef
name|llvm
operator|::
name|PointerUnion
operator|<
name|Expr
operator|*
operator|,
name|IdentifierLoc
operator|*
operator|>
name|ArgsUnion
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ArgsUnion
operator|,
literal|12U
operator|>
name|ArgsVector
expr_stmt|;
comment|/// AttributeList - Represents a syntactic attribute.
comment|///
comment|/// For a GNU attribute, there are four forms of this construct:
comment|///
comment|/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.
comment|/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.
comment|/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.
comment|/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.
comment|///
name|class
name|AttributeList
block|{
comment|// TODO: This should really be called ParsedAttribute
name|public
label|:
comment|/// The style used to specify an attribute.
enum|enum
name|Syntax
block|{
comment|/// __attribute__((...))
name|AS_GNU
block|,
comment|/// [[...]]
name|AS_CXX11
block|,
comment|/// __declspec(...)
name|AS_Declspec
block|,
comment|/// [uuid("...")] class Foo
name|AS_Microsoft
block|,
comment|/// __ptr16, alignas(...), etc.
name|AS_Keyword
block|,
comment|/// Context-sensitive version of a keyword attribute.
name|AS_ContextSensitiveKeyword
block|,
comment|/// #pragma ...
name|AS_Pragma
block|,   }
enum|;
name|private
label|:
name|IdentifierInfo
modifier|*
name|AttrName
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ScopeName
decl_stmt|;
name|SourceRange
name|AttrRange
decl_stmt|;
name|SourceLocation
name|ScopeLoc
decl_stmt|;
name|SourceLocation
name|EllipsisLoc
decl_stmt|;
name|unsigned
name|AttrKind
range|:
literal|16
decl_stmt|;
comment|/// The number of expression arguments this attribute has.
comment|/// The expressions themselves are stored after the object.
name|unsigned
name|NumArgs
range|:
literal|16
decl_stmt|;
comment|/// Corresponds to the Syntax enum.
name|unsigned
name|SyntaxUsed
range|:
literal|3
decl_stmt|;
comment|/// True if already diagnosed as invalid.
name|mutable
name|unsigned
name|Invalid
range|:
literal|1
decl_stmt|;
comment|/// True if this attribute was used as a type attribute.
name|mutable
name|unsigned
name|UsedAsTypeAttr
range|:
literal|1
decl_stmt|;
comment|/// True if this has the extra information associated with an
comment|/// availability attribute.
name|unsigned
name|IsAvailability
range|:
literal|1
decl_stmt|;
comment|/// True if this has extra information associated with a
comment|/// type_tag_for_datatype attribute.
name|unsigned
name|IsTypeTagForDatatype
range|:
literal|1
decl_stmt|;
comment|/// True if this has extra information associated with a
comment|/// Microsoft __delcspec(property) attribute.
name|unsigned
name|IsProperty
range|:
literal|1
decl_stmt|;
comment|/// True if this has a ParsedType
name|unsigned
name|HasParsedType
range|:
literal|1
decl_stmt|;
comment|/// True if the processing cache is valid.
name|mutable
name|unsigned
name|HasProcessingCache
range|:
literal|1
decl_stmt|;
comment|/// A cached value.
name|mutable
name|unsigned
name|ProcessingCache
range|:
literal|8
decl_stmt|;
comment|/// \brief The location of the 'unavailable' keyword in an
comment|/// availability attribute.
name|SourceLocation
name|UnavailableLoc
decl_stmt|;
specifier|const
name|Expr
modifier|*
name|MessageExpr
decl_stmt|;
comment|/// The next attribute in the current position.
name|AttributeList
modifier|*
name|NextInPosition
decl_stmt|;
comment|/// The next attribute allocated in the current Pool.
name|AttributeList
modifier|*
name|NextInPool
decl_stmt|;
comment|/// Arguments, if any, are stored immediately following the object.
name|ArgsUnion
modifier|*
name|getArgsBuffer
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|ArgsUnion
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|ArgsUnion
specifier|const
operator|*
name|getArgsBuffer
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|ArgsUnion
specifier|const
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
comment|/// Availability information is stored immediately following the arguments,
comment|/// if any, at the end of the object.
name|AvailabilityData
modifier|*
name|getAvailabilityData
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|AvailabilityData
operator|*
operator|>
operator|(
name|getArgsBuffer
argument_list|()
operator|+
name|NumArgs
operator|)
return|;
block|}
specifier|const
name|AvailabilityData
operator|*
name|getAvailabilityData
argument_list|()
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|AvailabilityData
operator|*
operator|>
operator|(
name|getArgsBuffer
argument_list|()
operator|+
name|NumArgs
operator|)
return|;
block|}
name|public
label|:
struct|struct
name|TypeTagForDatatypeData
block|{
name|ParsedType
modifier|*
name|MatchingCType
decl_stmt|;
name|unsigned
name|LayoutCompatible
range|:
literal|1
decl_stmt|;
name|unsigned
name|MustBeNull
range|:
literal|1
decl_stmt|;
block|}
struct|;
struct|struct
name|PropertyData
block|{
name|IdentifierInfo
modifier|*
name|GetterId
decl_stmt|,
modifier|*
name|SetterId
decl_stmt|;
name|PropertyData
argument_list|(
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|)
operator|:
name|GetterId
argument_list|(
name|getterId
argument_list|)
operator|,
name|SetterId
argument_list|(
argument|setterId
argument_list|)
block|{}
block|}
struct|;
name|private
label|:
comment|/// Type tag information is stored immediately following the arguments, if
comment|/// any, at the end of the object.  They are mutually exlusive with
comment|/// availability slots.
name|TypeTagForDatatypeData
modifier|&
name|getTypeTagForDatatypeDataSlot
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|TypeTagForDatatypeData
operator|*
operator|>
operator|(
name|getArgsBuffer
argument_list|()
operator|+
name|NumArgs
operator|)
return|;
block|}
specifier|const
name|TypeTagForDatatypeData
operator|&
name|getTypeTagForDatatypeDataSlot
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|TypeTagForDatatypeData
operator|*
operator|>
operator|(
name|getArgsBuffer
argument_list|()
operator|+
name|NumArgs
operator|)
return|;
block|}
comment|/// The type buffer immediately follows the object and are mutually exclusive
comment|/// with arguments.
name|ParsedType
modifier|&
name|getTypeBuffer
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|ParsedType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getTypeBuffer
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|ParsedType
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
comment|/// The property data immediately follows the object is is mutually exclusive
comment|/// with arguments.
name|PropertyData
modifier|&
name|getPropertyDataBuffer
parameter_list|()
block|{
name|assert
argument_list|(
name|IsProperty
argument_list|)
expr_stmt|;
return|return
operator|*
name|reinterpret_cast
operator|<
name|PropertyData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
specifier|const
name|PropertyData
operator|&
name|getPropertyDataBuffer
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|IsProperty
argument_list|)
block|;
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|PropertyData
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|AttributeList
argument_list|(
specifier|const
name|AttributeList
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|AttributeList
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|void
name|operator
name|delete
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|delete
function_decl|;
operator|~
name|AttributeList
argument_list|()
operator|=
name|delete
expr_stmt|;
name|size_t
name|allocated_size
argument_list|()
specifier|const
decl_stmt|;
comment|/// Constructor for attributes with expression arguments.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|ArgsUnion *args
argument_list|,
argument|unsigned numArgs
argument_list|,
argument|Syntax syntaxUsed
argument_list|,
argument|SourceLocation ellipsisLoc
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|(
name|ellipsisLoc
argument_list|)
operator|,
name|NumArgs
argument_list|(
name|numArgs
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|false
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
if|if
condition|(
name|numArgs
condition|)
name|memcpy
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
name|args
argument_list|,
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
argument_list|)
expr_stmt|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
expr_stmt|;
block|}
comment|/// Constructor for availability attributes.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierLoc *Parm
argument_list|,
argument|const AvailabilityChange&introduced
argument_list|,
argument|const AvailabilityChange&deprecated
argument_list|,
argument|const AvailabilityChange&obsoleted
argument_list|,
argument|SourceLocation unavailable
argument_list|,
argument|const Expr *messageExpr
argument_list|,
argument|Syntax syntaxUsed
argument_list|,
argument|SourceLocation strict
argument_list|,
argument|const Expr *replacementExpr
argument_list|)
block|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|1
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|true
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|false
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|UnavailableLoc
argument_list|(
name|unavailable
argument_list|)
operator|,
name|MessageExpr
argument_list|(
name|messageExpr
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|ArgsUnion
name|PVal
argument_list|(
name|Parm
argument_list|)
block|;
name|memcpy
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
operator|&
name|PVal
argument_list|,
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
argument_list|)
block|;
name|new
argument_list|(
argument|getAvailabilityData()
argument_list|)
name|AvailabilityData
argument_list|(
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|strict
argument_list|,
name|replacementExpr
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for objc_bridge_related attributes.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierLoc *Parm1
argument_list|,
argument|IdentifierLoc *Parm2
argument_list|,
argument|IdentifierLoc *Parm3
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|3
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|false
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|ArgsUnion
operator|*
name|Args
operator|=
name|getArgsBuffer
argument_list|()
block|;
name|Args
index|[
literal|0
index|]
operator|=
name|Parm1
block|;
name|Args
index|[
literal|1
index|]
operator|=
name|Parm2
block|;
name|Args
index|[
literal|2
index|]
operator|=
name|Parm3
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for type_tag_for_datatype attribute.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierLoc *ArgKind
argument_list|,
argument|ParsedType matchingCType
argument_list|,
argument|bool layoutCompatible
argument_list|,
argument|bool mustBeNull
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|1
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|true
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|false
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|ArgsUnion
name|PVal
argument_list|(
name|ArgKind
argument_list|)
block|;
name|memcpy
argument_list|(
name|getArgsBuffer
argument_list|()
argument_list|,
operator|&
name|PVal
argument_list|,
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
argument_list|)
block|;
name|TypeTagForDatatypeData
operator|&
name|ExtraData
operator|=
name|getTypeTagForDatatypeDataSlot
argument_list|()
block|;
name|new
argument_list|(
argument|&ExtraData.MatchingCType
argument_list|)
name|ParsedType
argument_list|(
name|matchingCType
argument_list|)
block|;
name|ExtraData
operator|.
name|LayoutCompatible
operator|=
name|layoutCompatible
block|;
name|ExtraData
operator|.
name|MustBeNull
operator|=
name|mustBeNull
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for attributes with a single type argument.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|ParsedType typeArg
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|false
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|true
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|new
argument_list|(
argument|&getTypeBuffer()
argument_list|)
name|ParsedType
argument_list|(
name|typeArg
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
comment|/// Constructor for microsoft __declspec(property) attribute.
name|AttributeList
argument_list|(
argument|IdentifierInfo *attrName
argument_list|,
argument|SourceRange attrRange
argument_list|,
argument|IdentifierInfo *scopeName
argument_list|,
argument|SourceLocation scopeLoc
argument_list|,
argument|IdentifierInfo *getterId
argument_list|,
argument|IdentifierInfo *setterId
argument_list|,
argument|Syntax syntaxUsed
argument_list|)
operator|:
name|AttrName
argument_list|(
name|attrName
argument_list|)
operator|,
name|ScopeName
argument_list|(
name|scopeName
argument_list|)
operator|,
name|AttrRange
argument_list|(
name|attrRange
argument_list|)
operator|,
name|ScopeLoc
argument_list|(
name|scopeLoc
argument_list|)
operator|,
name|EllipsisLoc
argument_list|()
operator|,
name|NumArgs
argument_list|(
literal|0
argument_list|)
operator|,
name|SyntaxUsed
argument_list|(
name|syntaxUsed
argument_list|)
operator|,
name|Invalid
argument_list|(
name|false
argument_list|)
operator|,
name|UsedAsTypeAttr
argument_list|(
name|false
argument_list|)
operator|,
name|IsAvailability
argument_list|(
name|false
argument_list|)
operator|,
name|IsTypeTagForDatatype
argument_list|(
name|false
argument_list|)
operator|,
name|IsProperty
argument_list|(
name|true
argument_list|)
operator|,
name|HasParsedType
argument_list|(
name|false
argument_list|)
operator|,
name|HasProcessingCache
argument_list|(
name|false
argument_list|)
operator|,
name|NextInPosition
argument_list|(
name|nullptr
argument_list|)
operator|,
name|NextInPool
argument_list|(
argument|nullptr
argument_list|)
block|{
name|new
argument_list|(
argument|&getPropertyDataBuffer()
argument_list|)
name|PropertyData
argument_list|(
name|getterId
argument_list|,
name|setterId
argument_list|)
block|;
name|AttrKind
operator|=
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|,
name|getScopeName
argument_list|()
argument_list|,
name|syntaxUsed
argument_list|)
block|;   }
name|friend
name|class
name|AttributePool
expr_stmt|;
name|friend
name|class
name|AttributeFactory
decl_stmt|;
name|public
label|:
enum|enum
name|Kind
block|{
define|#
directive|define
name|PARSED_ATTR
parameter_list|(
name|NAME
parameter_list|)
value|AT_##NAME,
include|#
directive|include
file|"clang/Sema/AttrParsedAttrList.inc"
undef|#
directive|undef
name|PARSED_ATTR
name|IgnoredAttribute
block|,
name|UnknownAttribute
block|}
enum|;
name|IdentifierInfo
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|AttrName
return|;
block|}
name|SourceLocation
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|AttrRange
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceRange
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|AttrRange
return|;
block|}
name|bool
name|hasScope
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|IdentifierInfo
operator|*
name|getScopeName
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|SourceLocation
name|getScopeLoc
argument_list|()
specifier|const
block|{
return|return
name|ScopeLoc
return|;
block|}
name|bool
name|hasParsedType
argument_list|()
specifier|const
block|{
return|return
name|HasParsedType
return|;
block|}
comment|/// Is this the Microsoft __declspec(property) attribute?
name|bool
name|isDeclspecPropertyAttribute
argument_list|()
specifier|const
block|{
return|return
name|IsProperty
return|;
block|}
name|bool
name|isAlignasAttribute
argument_list|()
specifier|const
block|{
comment|// FIXME: Use a better mechanism to determine this.
return|return
name|getKind
argument_list|()
operator|==
name|AT_Aligned
operator|&&
name|isKeywordAttribute
argument_list|()
return|;
block|}
name|bool
name|isDeclspecAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_Declspec
return|;
block|}
name|bool
name|isMicrosoftAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_Microsoft
return|;
block|}
name|bool
name|isCXX11Attribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_CXX11
operator|||
name|isAlignasAttribute
argument_list|()
return|;
block|}
name|bool
name|isKeywordAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_Keyword
operator|||
name|SyntaxUsed
operator|==
name|AS_ContextSensitiveKeyword
return|;
block|}
name|bool
name|isContextSensitiveKeywordAttribute
argument_list|()
specifier|const
block|{
return|return
name|SyntaxUsed
operator|==
name|AS_ContextSensitiveKeyword
return|;
block|}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
name|void
name|setInvalid
argument_list|(
name|bool
name|b
operator|=
name|true
argument_list|)
decl|const
block|{
name|Invalid
operator|=
name|b
expr_stmt|;
block|}
name|bool
name|hasProcessingCache
argument_list|()
specifier|const
block|{
return|return
name|HasProcessingCache
return|;
block|}
name|unsigned
name|getProcessingCache
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasProcessingCache
argument_list|()
argument_list|)
block|;
return|return
name|ProcessingCache
return|;
block|}
name|void
name|setProcessingCache
argument_list|(
name|unsigned
name|value
argument_list|)
decl|const
block|{
name|ProcessingCache
operator|=
name|value
expr_stmt|;
name|HasProcessingCache
operator|=
name|true
expr_stmt|;
block|}
name|bool
name|isUsedAsTypeAttr
argument_list|()
specifier|const
block|{
return|return
name|UsedAsTypeAttr
return|;
block|}
name|void
name|setUsedAsTypeAttr
parameter_list|()
block|{
name|UsedAsTypeAttr
operator|=
name|true
expr_stmt|;
block|}
name|bool
name|isPackExpansion
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
argument_list|(
name|AttrKind
argument_list|)
return|;
block|}
specifier|static
name|Kind
name|getKind
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|*
name|Scope
parameter_list|,
name|Syntax
name|SyntaxUsed
parameter_list|)
function_decl|;
name|AttributeList
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|NextInPosition
return|;
block|}
name|void
name|setNext
parameter_list|(
name|AttributeList
modifier|*
name|N
parameter_list|)
block|{
name|NextInPosition
operator|=
name|N
expr_stmt|;
block|}
comment|/// getNumArgs - Return the number of actual arguments to this attribute.
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
comment|/// getArg - Return the specified argument.
name|ArgsUnion
name|getArg
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Arg
operator|<
name|NumArgs
operator|&&
literal|"Arg access out of range!"
argument_list|)
expr_stmt|;
return|return
name|getArgsBuffer
argument_list|()
index|[
name|Arg
index|]
return|;
block|}
name|bool
name|isArgExpr
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
return|return
name|Arg
operator|<
name|NumArgs
operator|&&
name|getArg
argument_list|(
name|Arg
argument_list|)
operator|.
name|is
operator|<
name|Expr
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|Expr
modifier|*
name|getArgAsExpr
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
return|return
name|getArg
argument_list|(
name|Arg
argument_list|)
operator|.
name|get
operator|<
name|Expr
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|bool
name|isArgIdent
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
return|return
name|Arg
operator|<
name|NumArgs
operator|&&
name|getArg
argument_list|(
name|Arg
argument_list|)
operator|.
name|is
operator|<
name|IdentifierLoc
operator|*
operator|>
operator|(
operator|)
return|;
block|}
name|IdentifierLoc
modifier|*
name|getArgAsIdent
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
return|return
name|getArg
argument_list|(
name|Arg
argument_list|)
operator|.
name|get
operator|<
name|IdentifierLoc
operator|*
operator|>
operator|(
operator|)
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityIntroduced
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilityData
argument_list|()
operator|->
name|Changes
index|[
name|IntroducedSlot
index|]
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityDeprecated
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilityData
argument_list|()
operator|->
name|Changes
index|[
name|DeprecatedSlot
index|]
return|;
block|}
specifier|const
name|AvailabilityChange
operator|&
name|getAvailabilityObsoleted
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilityData
argument_list|()
operator|->
name|Changes
index|[
name|ObsoletedSlot
index|]
return|;
block|}
name|SourceLocation
name|getStrictLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilityData
argument_list|()
operator|->
name|StrictLoc
return|;
block|}
name|SourceLocation
name|getUnavailableLoc
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|UnavailableLoc
return|;
block|}
specifier|const
name|Expr
operator|*
name|getMessageExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|MessageExpr
return|;
block|}
specifier|const
name|Expr
operator|*
name|getReplacementExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_Availability
operator|&&
literal|"Not an availability attribute"
argument_list|)
block|;
return|return
name|getAvailabilityData
argument_list|()
operator|->
name|Replacement
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getMatchingCType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
operator|*
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|MatchingCType
return|;
block|}
name|bool
name|getLayoutCompatible
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|LayoutCompatible
return|;
block|}
name|bool
name|getMustBeNull
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|getKind
argument_list|()
operator|==
name|AT_TypeTagForDatatype
operator|&&
literal|"Not a type_tag_for_datatype attribute"
argument_list|)
block|;
return|return
name|getTypeTagForDatatypeDataSlot
argument_list|()
operator|.
name|MustBeNull
return|;
block|}
specifier|const
name|ParsedType
operator|&
name|getTypeArg
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|HasParsedType
operator|&&
literal|"Not a type attribute"
argument_list|)
block|;
return|return
name|getTypeBuffer
argument_list|()
return|;
block|}
specifier|const
name|PropertyData
operator|&
name|getPropertyData
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclspecPropertyAttribute
argument_list|()
operator|&&
literal|"Not a __delcspec(property) attribute"
argument_list|)
block|;
return|return
name|getPropertyDataBuffer
argument_list|()
return|;
block|}
comment|/// \brief Get an index into the attribute spelling list
comment|/// defined in Attr.td. This index is used by an attribute
comment|/// to pretty print itself.
name|unsigned
name|getAttributeSpellingListIndex
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isTargetSpecificAttr
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isTypeAttr
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isStmtAttr
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasCustomParsing
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|getMinArgs
argument_list|()
specifier|const
expr_stmt|;
name|unsigned
name|getMaxArgs
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasVariadicArg
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|diagnoseAppertainsTo
argument_list|(
name|class
name|Sema
operator|&
name|S
argument_list|,
specifier|const
name|Decl
operator|*
name|D
argument_list|)
decl|const
decl_stmt|;
name|bool
name|appliesToDecl
argument_list|(
specifier|const
name|Decl
operator|*
name|D
argument_list|,
name|attr
operator|::
name|SubjectMatchRule
name|MatchRule
argument_list|)
decl|const
decl_stmt|;
name|void
name|getMatchRules
argument_list|(
specifier|const
name|LangOptions
operator|&
name|LangOpts
argument_list|,
name|SmallVectorImpl
operator|<
name|std
operator|::
name|pair
operator|<
name|attr
operator|::
name|SubjectMatchRule
argument_list|,
name|bool
operator|>>
operator|&
name|MatchRules
argument_list|)
decl|const
decl_stmt|;
name|bool
name|diagnoseLangOpts
argument_list|(
name|class
name|Sema
operator|&
name|S
argument_list|)
decl|const
decl_stmt|;
name|bool
name|existsInTarget
argument_list|(
specifier|const
name|TargetInfo
operator|&
name|Target
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isKnownToGCC
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isSupportedByPragmaAttribute
argument_list|()
specifier|const
expr_stmt|;
comment|/// \brief If the parsed attribute has a semantic equivalent, and it would
comment|/// have a semantic Spelling enumeration (due to having semantically-distinct
comment|/// spelling variations), return the value of that semantic spelling. If the
comment|/// parsed attribute does not have a semantic equivalent, or would not have
comment|/// a Spelling enumeration, the value UINT_MAX is returned.
name|unsigned
name|getSemanticSpelling
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// A factory, from which one makes pools, from which one creates
end_comment

begin_comment
comment|/// individual attributes which are deallocated with the pool.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Note that it's tolerably cheap to create and destroy one of
end_comment

begin_comment
comment|/// these as long as you don't actually allocate anything in it.
end_comment

begin_decl_stmt
name|class
name|AttributeFactory
block|{
name|public
label|:
enum|enum
block|{
comment|/// The required allocation size of an availability attribute,
comment|/// which we want to ensure is a multiple of sizeof(void*).
name|AvailabilityAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|AvailabilityData
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
block|,
name|TypeTagForDatatypeAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|AttributeList
operator|::
name|TypeTagForDatatypeData
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
block|,
name|PropertyAllocSize
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|AttributeList
operator|::
name|PropertyData
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|private
label|:
enum|enum
block|{
comment|/// The number of free lists we want to be sure to support
comment|/// inline.  This is just enough that availability attributes
comment|/// don't surpass it.  It's actually very unlikely we'll see an
comment|/// attribute that needs more than that; on x86-64 you'd need 10
comment|/// expression arguments, and on i386 you'd need 19.
name|InlineFreeListsCapacity
init|=
literal|1
operator|+
operator|(
name|AvailabilityAllocSize
operator|-
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|)
operator|/
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|llvm
operator|::
name|BumpPtrAllocator
name|Alloc
expr_stmt|;
comment|/// Free lists.  The index is determined by the following formula:
comment|///   (size - sizeof(AttributeList)) / sizeof(void*)
name|SmallVector
operator|<
name|AttributeList
operator|*
operator|,
name|InlineFreeListsCapacity
operator|>
name|FreeLists
expr_stmt|;
comment|// The following are the private interface used by AttributePool.
name|friend
name|class
name|AttributePool
decl_stmt|;
comment|/// Allocate an attribute of the given size.
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/// Reclaim all the attributes in the given pool chain, which is
comment|/// non-empty.  Note that the current implementation is safe
comment|/// against reclaiming things which were not actually allocated
comment|/// with the allocator, although of course it's important to make
comment|/// sure that their allocator lives at least as long as this one.
name|void
name|reclaimPool
parameter_list|(
name|AttributeList
modifier|*
name|head
parameter_list|)
function_decl|;
name|public
label|:
name|AttributeFactory
argument_list|()
expr_stmt|;
operator|~
name|AttributeFactory
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|AttributePool
block|{
name|AttributeFactory
modifier|&
name|Factory
decl_stmt|;
name|AttributeList
modifier|*
name|Head
decl_stmt|;
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|Factory
operator|.
name|allocate
argument_list|(
name|size
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|add
parameter_list|(
name|AttributeList
modifier|*
name|attr
parameter_list|)
block|{
comment|// We don't care about the order of the pool.
name|attr
operator|->
name|NextInPool
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
name|attr
expr_stmt|;
return|return
name|attr
return|;
block|}
name|void
name|takePool
parameter_list|(
name|AttributeList
modifier|*
name|pool
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Create a new pool for a factory.
name|AttributePool
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|Factory
argument_list|(
name|factory
argument_list|)
operator|,
name|Head
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|AttributePool
argument_list|(
specifier|const
name|AttributePool
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
comment|/// Move the given pool's allocations to this pool.
name|AttributePool
argument_list|(
name|AttributePool
operator|&&
name|pool
argument_list|)
operator|:
name|Factory
argument_list|(
name|pool
operator|.
name|Factory
argument_list|)
operator|,
name|Head
argument_list|(
argument|pool.Head
argument_list|)
block|{
name|pool
operator|.
name|Head
operator|=
name|nullptr
block|;   }
name|AttributeFactory
operator|&
name|getFactory
argument_list|()
specifier|const
block|{
return|return
name|Factory
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|Head
condition|)
block|{
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
name|Head
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
comment|/// Take the given pool's allocations and add them to this pool.
name|void
name|takeAllFrom
parameter_list|(
name|AttributePool
modifier|&
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|.
name|Head
condition|)
block|{
name|takePool
argument_list|(
name|pool
operator|.
name|Head
argument_list|)
expr_stmt|;
name|pool
operator|.
name|Head
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
operator|~
name|AttributePool
argument_list|()
block|{
if|if
condition|(
name|Head
condition|)
name|Factory
operator|.
name|reclaimPool
argument_list|(
name|Head
argument_list|)
expr_stmt|;
block|}
name|AttributeList
modifier|*
name|create
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|ArgsUnion
operator|*
name|args
argument_list|,
name|unsigned
name|numArgs
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|ellipsisLoc
operator|=
name|SourceLocation
argument_list|()
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|syntax
argument_list|,
name|ellipsisLoc
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|create
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|Param
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|introduced
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|deprecated
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|obsoleted
argument_list|,
name|SourceLocation
name|unavailable
argument_list|,
specifier|const
name|Expr
operator|*
name|MessageExpr
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|strict
argument_list|,
specifier|const
name|Expr
operator|*
name|ReplacementExpr
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|AvailabilityAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|Param
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|MessageExpr
argument_list|,
name|syntax
argument_list|,
name|strict
argument_list|,
name|ReplacementExpr
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|create
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|Param1
argument_list|,
name|IdentifierLoc
operator|*
name|Param2
argument_list|,
name|IdentifierLoc
operator|*
name|Param3
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|ArgsUnion
argument_list|)
decl_stmt|;
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|size
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|Param1
argument_list|,
name|Param2
argument_list|,
name|Param3
argument_list|,
name|syntax
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createTypeTagForDatatype
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|argumentKind
argument_list|,
name|ParsedType
name|matchingCType
argument_list|,
name|bool
name|layoutCompatible
argument_list|,
name|bool
name|mustBeNull
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|TypeTagForDatatypeAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|argumentKind
argument_list|,
name|matchingCType
argument_list|,
name|layoutCompatible
argument_list|,
name|mustBeNull
argument_list|,
name|syntax
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createTypeAttribute
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|ParsedType
name|typeArg
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeList
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|typeArg
argument_list|,
name|syntaxUsed
argument_list|)
argument_list|)
return|;
block|}
name|AttributeList
modifier|*
name|createPropertyAttribute
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|void
modifier|*
name|memory
init|=
name|allocate
argument_list|(
name|AttributeFactory
operator|::
name|PropertyAllocSize
argument_list|)
decl_stmt|;
return|return
name|add
argument_list|(
name|new
argument_list|(
argument|memory
argument_list|)
name|AttributeList
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|getterId
argument_list|,
name|setterId
argument_list|,
name|syntaxUsed
argument_list|)
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// ParsedAttributes - A collection of parsed attributes.  Currently
end_comment

begin_comment
comment|/// we don't differentiate between the various attribute syntaxes,
end_comment

begin_comment
comment|/// which is basically silly.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Right now this is a very lightweight container, but the expectation
end_comment

begin_comment
comment|/// is that this will become significantly more serious.
end_comment

begin_decl_stmt
name|class
name|ParsedAttributes
block|{
name|public
label|:
name|ParsedAttributes
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|pool
argument_list|(
name|factory
argument_list|)
operator|,
name|list
argument_list|(
argument|nullptr
argument_list|)
block|{   }
name|ParsedAttributes
argument_list|(
specifier|const
name|ParsedAttributes
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|AttributePool
operator|&
name|getPool
argument_list|()
specifier|const
block|{
return|return
name|pool
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|list
operator|==
name|nullptr
return|;
block|}
name|void
name|add
parameter_list|(
name|AttributeList
modifier|*
name|newAttr
parameter_list|)
block|{
name|assert
argument_list|(
name|newAttr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|newAttr
operator|->
name|getNext
argument_list|()
operator|==
name|nullptr
argument_list|)
expr_stmt|;
name|newAttr
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newAttr
expr_stmt|;
block|}
name|void
name|addAll
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newList
condition|)
return|return;
name|AttributeList
modifier|*
name|lastInNewList
init|=
name|newList
decl_stmt|;
while|while
condition|(
name|AttributeList
modifier|*
name|next
init|=
name|lastInNewList
operator|->
name|getNext
argument_list|()
condition|)
name|lastInNewList
operator|=
name|next
expr_stmt|;
name|lastInNewList
operator|->
name|setNext
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|addAllAtEnd
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|list
operator|=
name|newList
expr_stmt|;
return|return;
block|}
name|AttributeList
modifier|*
name|lastInList
init|=
name|list
decl_stmt|;
while|while
condition|(
name|AttributeList
modifier|*
name|next
init|=
name|lastInList
operator|->
name|getNext
argument_list|()
condition|)
name|lastInList
operator|=
name|next
expr_stmt|;
name|lastInList
operator|->
name|setNext
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
name|void
name|set
parameter_list|(
name|AttributeList
modifier|*
name|newList
parameter_list|)
block|{
name|list
operator|=
name|newList
expr_stmt|;
block|}
name|void
name|takeAllFrom
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|addAll
argument_list|(
name|attrs
operator|.
name|list
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|list
operator|=
name|nullptr
expr_stmt|;
name|pool
operator|.
name|takeAllFrom
argument_list|(
name|attrs
operator|.
name|pool
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|list
operator|=
name|nullptr
expr_stmt|;
name|pool
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|AttributeList
operator|*
name|getList
argument_list|()
specifier|const
block|{
return|return
name|list
return|;
block|}
name|void
name|clearListOnly
parameter_list|()
block|{
name|list
operator|=
name|nullptr
expr_stmt|;
block|}
comment|/// Returns a reference to the attribute list.  Try not to introduce
comment|/// dependencies on this method, it may not be long-lived.
name|AttributeList
modifier|*
modifier|&
name|getListRef
parameter_list|()
block|{
return|return
name|list
return|;
block|}
comment|/// Add attribute with expression arguments.
name|AttributeList
modifier|*
name|addNew
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|ArgsUnion
operator|*
name|args
argument_list|,
name|unsigned
name|numArgs
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|ellipsisLoc
operator|=
name|SourceLocation
argument_list|()
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|args
argument_list|,
name|numArgs
argument_list|,
name|syntax
argument_list|,
name|ellipsisLoc
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add availability attribute.
name|AttributeList
modifier|*
name|addNew
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|Param
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|introduced
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|deprecated
argument_list|,
specifier|const
name|AvailabilityChange
operator|&
name|obsoleted
argument_list|,
name|SourceLocation
name|unavailable
argument_list|,
specifier|const
name|Expr
operator|*
name|MessageExpr
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|,
name|SourceLocation
name|strict
argument_list|,
specifier|const
name|Expr
operator|*
name|ReplacementExpr
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|Param
argument_list|,
name|introduced
argument_list|,
name|deprecated
argument_list|,
name|obsoleted
argument_list|,
name|unavailable
argument_list|,
name|MessageExpr
argument_list|,
name|syntax
argument_list|,
name|strict
argument_list|,
name|ReplacementExpr
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add objc_bridge_related attribute.
name|AttributeList
modifier|*
name|addNew
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|Param1
argument_list|,
name|IdentifierLoc
operator|*
name|Param2
argument_list|,
name|IdentifierLoc
operator|*
name|Param3
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|create
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|Param1
argument_list|,
name|Param2
argument_list|,
name|Param3
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add type_tag_for_datatype attribute.
name|AttributeList
modifier|*
name|addNewTypeTagForDatatype
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierLoc
operator|*
name|argumentKind
argument_list|,
name|ParsedType
name|matchingCType
argument_list|,
name|bool
name|layoutCompatible
argument_list|,
name|bool
name|mustBeNull
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntax
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createTypeTagForDatatype
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|argumentKind
argument_list|,
name|matchingCType
argument_list|,
name|layoutCompatible
argument_list|,
name|mustBeNull
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add an attribute with a single type argument.
name|AttributeList
modifier|*
name|addNewTypeAttr
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|ParsedType
name|typeArg
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createTypeAttribute
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|typeArg
argument_list|,
name|syntaxUsed
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
comment|/// Add microsoft __delspec(property) attribute.
name|AttributeList
modifier|*
name|addNewPropertyAttr
argument_list|(
name|IdentifierInfo
operator|*
name|attrName
argument_list|,
name|SourceRange
name|attrRange
argument_list|,
name|IdentifierInfo
operator|*
name|scopeName
argument_list|,
name|SourceLocation
name|scopeLoc
argument_list|,
name|IdentifierInfo
operator|*
name|getterId
argument_list|,
name|IdentifierInfo
operator|*
name|setterId
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|syntaxUsed
argument_list|)
block|{
name|AttributeList
modifier|*
name|attr
init|=
name|pool
operator|.
name|createPropertyAttribute
argument_list|(
name|attrName
argument_list|,
name|attrRange
argument_list|,
name|scopeName
argument_list|,
name|scopeLoc
argument_list|,
name|getterId
argument_list|,
name|setterId
argument_list|,
name|syntaxUsed
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|attr
return|;
block|}
name|private
label|:
name|mutable
name|AttributePool
name|pool
decl_stmt|;
name|AttributeList
modifier|*
name|list
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// These constants match the enumerated choices of
end_comment

begin_comment
comment|/// err_attribute_argument_n_type and err_attribute_argument_type.
end_comment

begin_enum
enum|enum
name|AttributeArgumentNType
block|{
name|AANT_ArgumentIntOrBool
block|,
name|AANT_ArgumentIntegerConstant
block|,
name|AANT_ArgumentString
block|,
name|AANT_ArgumentIdentifier
block|}
enum|;
end_enum

begin_comment
comment|/// These constants match the enumerated choices of
end_comment

begin_comment
comment|/// warn_attribute_wrong_decl_type and err_attribute_wrong_decl_type.
end_comment

begin_enum
enum|enum
name|AttributeDeclKind
block|{
name|ExpectedFunction
block|,
name|ExpectedUnion
block|,
name|ExpectedVariableOrFunction
block|,
name|ExpectedFunctionOrGlobalVar
block|,
name|ExpectedFunctionVariableOrObjCInterface
block|,
name|ExpectedFunctionOrMethod
block|,
name|ExpectedParameter
block|,
name|ExpectedFunctionMethodOrBlock
block|,
name|ExpectedFunctionMethodOrClass
block|,
name|ExpectedFunctionMethodOrParameter
block|,
name|ExpectedFunctionMethodOrGlobalVar
block|,
name|ExpectedClass
block|,
name|ExpectedEnum
block|,
name|ExpectedVariable
block|,
name|ExpectedMethod
block|,
name|ExpectedFieldOrGlobalVar
block|,
name|ExpectedStruct
block|,
name|ExpectedParameterOrTypedef
block|,
name|ExpectedVariableOrTypedef
block|,
name|ExpectedTLSVar
block|,
name|ExpectedVariableOrField
block|,
name|ExpectedVariableFieldOrTag
block|,
name|ExpectedTypeOrNamespace
block|,
name|ExpectedObjectiveCInterface
block|,
name|ExpectedMethodOrProperty
block|,
name|ExpectedFunctionOrMethodOrProperty
block|,
name|ExpectedStructOrUnion
block|,
name|ExpectedStructOrUnionOrClass
block|,
name|ExpectedType
block|,
name|ExpectedObjCInstanceMethod
block|,
name|ExpectedObjCInterfaceDeclInitMethod
block|,
name|ExpectedFunctionVariableOrClass
block|,
name|ExpectedFunctionVariableClassOrObjCInterface
block|,
name|ExpectedObjectiveCProtocol
block|,
name|ExpectedStaticOrTLSVar
block|,
name|ExpectedFunctionGlobalVarMethodOrProperty
block|,
name|ExpectedStructOrUnionOrTypedef
block|,
name|ExpectedStructOrTypedef
block|,
name|ExpectedObjectiveCInterfaceOrProtocol
block|,
name|ExpectedKernelFunction
block|,
name|ExpectedFunctionWithProtoType
block|,
name|ExpectedVariableEnumFieldOrTypedef
block|,
name|ExpectedFunctionMethodEnumOrClass
block|,
name|ExpectedStructClassVariableFunctionOrInlineNamespace
block|,
name|ExpectedForMaybeUnused
block|,
name|ExpectedEnumOrClass
block|,
name|ExpectedNamedDecl
block|, }
enum|;
end_enum

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

