begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- AttributeList.h - Parsed attribute sets ----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the AttributeList class, which is used to collect
end_comment

begin_comment
comment|// parsed attributes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_ATTRLIST_H
end_define

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/SourceLocation.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|Expr
decl_stmt|;
comment|/// AttributeList - Represents GCC's __attribute__ declaration. There are
comment|/// 4 forms of this construct...they are:
comment|///
comment|/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.
comment|/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.
comment|/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.
comment|/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.
comment|///
name|class
name|AttributeList
block|{
name|IdentifierInfo
modifier|*
name|AttrName
decl_stmt|;
name|SourceLocation
name|AttrLoc
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ScopeName
decl_stmt|;
name|SourceLocation
name|ScopeLoc
decl_stmt|;
name|IdentifierInfo
modifier|*
name|ParmName
decl_stmt|;
name|SourceLocation
name|ParmLoc
decl_stmt|;
name|Expr
modifier|*
modifier|*
name|Args
decl_stmt|;
name|unsigned
name|NumArgs
decl_stmt|;
name|AttributeList
modifier|*
name|Next
decl_stmt|;
name|bool
name|DeclspecAttribute
decl_stmt|,
name|CXX0XAttribute
decl_stmt|;
name|mutable
name|bool
name|Invalid
decl_stmt|;
comment|/// True if already diagnosed as invalid.
name|AttributeList
argument_list|(
specifier|const
name|AttributeList
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|AttributeList
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
name|AttributeList
argument_list|(
argument|IdentifierInfo *AttrName
argument_list|,
argument|SourceLocation AttrLoc
argument_list|,
argument|IdentifierInfo *ScopeName
argument_list|,
argument|SourceLocation ScopeLoc
argument_list|,
argument|IdentifierInfo *ParmName
argument_list|,
argument|SourceLocation ParmLoc
argument_list|,
argument|Expr **args
argument_list|,
argument|unsigned numargs
argument_list|,
argument|AttributeList *Next
argument_list|,
argument|bool declspec = false
argument_list|,
argument|bool cxx0x = false
argument_list|)
empty_stmt|;
operator|~
name|AttributeList
argument_list|()
expr_stmt|;
enum|enum
name|Kind
block|{
comment|// Please keep this list alphabetized.
name|AT_IBAction
block|,
comment|// Clang-specific.
name|AT_IBOutlet
block|,
comment|// Clang-specific.
name|AT_IBOutletCollection
block|,
comment|// Clang-specific.
name|AT_address_space
block|,
name|AT_alias
block|,
name|AT_aligned
block|,
name|AT_always_inline
block|,
name|AT_analyzer_noreturn
block|,
name|AT_annotate
block|,
name|AT_base_check
block|,
name|AT_blocks
block|,
name|AT_carries_dependency
block|,
name|AT_cdecl
block|,
name|AT_cleanup
block|,
name|AT_const
block|,
name|AT_constructor
block|,
name|AT_deprecated
block|,
name|AT_destructor
block|,
name|AT_dllexport
block|,
name|AT_dllimport
block|,
name|AT_ext_vector_type
block|,
name|AT_fastcall
block|,
name|AT_final
block|,
name|AT_format
block|,
name|AT_format_arg
block|,
name|AT_gnu_inline
block|,
name|AT_hiding
block|,
name|AT_malloc
block|,
name|AT_mode
block|,
name|AT_nodebug
block|,
name|AT_noinline
block|,
name|AT_no_instrument_function
block|,
name|AT_nonnull
block|,
name|AT_noreturn
block|,
name|AT_nothrow
block|,
name|AT_nsobject
block|,
name|AT_objc_exception
block|,
name|AT_override
block|,
name|AT_cf_returns_not_retained
block|,
comment|// Clang-specific.
name|AT_cf_returns_retained
block|,
comment|// Clang-specific.
name|AT_ns_returns_not_retained
block|,
comment|// Clang-specific.
name|AT_ns_returns_retained
block|,
comment|// Clang-specific.
name|AT_objc_gc
block|,
name|AT_overloadable
block|,
comment|// Clang-specific.
name|AT_ownership_holds
block|,
comment|// Clang-specific.
name|AT_ownership_returns
block|,
comment|// Clang-specific.
name|AT_ownership_takes
block|,
comment|// Clang-specific.
name|AT_packed
block|,
name|AT_pascal
block|,
name|AT_pure
block|,
name|AT_regparm
block|,
name|AT_section
block|,
name|AT_sentinel
block|,
name|AT_stdcall
block|,
name|AT_thiscall
block|,
name|AT_transparent_union
block|,
name|AT_unavailable
block|,
name|AT_unused
block|,
name|AT_used
block|,
name|AT_vecreturn
block|,
comment|// PS3 PPU-specific.
name|AT_vector_size
block|,
name|AT_visibility
block|,
name|AT_warn_unused_result
block|,
name|AT_weak
block|,
name|AT_weakref
block|,
name|AT_weak_import
block|,
name|AT_reqd_wg_size
block|,
name|AT_init_priority
block|,
name|IgnoredAttribute
block|,
name|UnknownAttribute
block|}
enum|;
name|IdentifierInfo
operator|*
name|getName
argument_list|()
specifier|const
block|{
return|return
name|AttrName
return|;
block|}
name|SourceLocation
name|getLoc
argument_list|()
specifier|const
block|{
return|return
name|AttrLoc
return|;
block|}
name|bool
name|hasScope
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|IdentifierInfo
operator|*
name|getScopeName
argument_list|()
specifier|const
block|{
return|return
name|ScopeName
return|;
block|}
name|SourceLocation
name|getScopeLoc
argument_list|()
specifier|const
block|{
return|return
name|ScopeLoc
return|;
block|}
name|IdentifierInfo
operator|*
name|getParameterName
argument_list|()
specifier|const
block|{
return|return
name|ParmName
return|;
block|}
name|bool
name|isDeclspecAttribute
argument_list|()
specifier|const
block|{
return|return
name|DeclspecAttribute
return|;
block|}
name|bool
name|isCXX0XAttribute
argument_list|()
specifier|const
block|{
return|return
name|CXX0XAttribute
return|;
block|}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
name|void
name|setInvalid
argument_list|(
name|bool
name|b
operator|=
name|true
argument_list|)
decl|const
block|{
name|Invalid
operator|=
name|b
expr_stmt|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|getKind
argument_list|(
name|getName
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|Kind
name|getKind
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Name
parameter_list|)
function_decl|;
name|AttributeList
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|Next
return|;
block|}
name|void
name|setNext
parameter_list|(
name|AttributeList
modifier|*
name|N
parameter_list|)
block|{
name|Next
operator|=
name|N
expr_stmt|;
block|}
comment|/// getNumArgs - Return the number of actual arguments to this attribute.
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|NumArgs
return|;
block|}
comment|/// getArg - Return the specified argument.
name|Expr
modifier|*
name|getArg
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Arg
operator|<
name|NumArgs
operator|&&
literal|"Arg access out of range!"
argument_list|)
expr_stmt|;
return|return
name|Args
index|[
name|Arg
index|]
return|;
block|}
name|class
name|arg_iterator
block|{
name|Expr
modifier|*
modifier|*
name|X
decl_stmt|;
name|unsigned
name|Idx
decl_stmt|;
name|public
label|:
name|arg_iterator
argument_list|(
argument|Expr** x
argument_list|,
argument|unsigned idx
argument_list|)
block|:
name|X
argument_list|(
name|x
argument_list|)
operator|,
name|Idx
argument_list|(
argument|idx
argument_list|)
block|{}
name|arg_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Idx
block|;
return|return
operator|*
name|this
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
name|assert
argument_list|(
name|X
operator|==
name|I
operator|.
name|X
operator|&&
literal|"compared arg_iterators are for different argument lists"
argument_list|)
block|;
return|return
name|Idx
operator|==
name|I
operator|.
name|Idx
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|arg_iterator
operator|&
name|I
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|I
operator|)
return|;
block|}
name|Expr
operator|*
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|X
index|[
name|Idx
index|]
return|;
block|}
name|unsigned
name|getArgNum
argument_list|()
specifier|const
block|{
return|return
name|Idx
operator|+
literal|1
return|;
block|}
block|}
empty_stmt|;
name|arg_iterator
name|arg_begin
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|Args
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|arg_iterator
name|arg_end
argument_list|()
specifier|const
block|{
return|return
name|arg_iterator
argument_list|(
name|Args
argument_list|,
name|NumArgs
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// addAttributeLists - Add two AttributeLists together
comment|/// The right-hand list is appended to the left-hand list, if any
comment|/// A pointer to the joined list is returned.
comment|/// Note: the lists are not left unmodified.
specifier|inline
name|AttributeList
modifier|*
name|addAttributeLists
parameter_list|(
name|AttributeList
modifier|*
name|Left
parameter_list|,
name|AttributeList
modifier|*
name|Right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Left
condition|)
return|return
name|Right
return|;
name|AttributeList
modifier|*
name|next
init|=
name|Left
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
name|prev
operator|->
name|setNext
argument_list|(
name|Right
argument_list|)
expr_stmt|;
return|return
name|Left
return|;
block|}
comment|/// CXX0XAttributeList - A wrapper around a C++0x attribute list.
comment|/// Stores, in addition to the list proper, whether or not an actual list was
comment|/// (as opposed to an empty list, which may be ill-formed in some places) and
comment|/// the source range of the list.
struct|struct
name|CXX0XAttributeList
block|{
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
name|bool
name|HasAttr
decl_stmt|;
name|CXX0XAttributeList
argument_list|(
argument|AttributeList *attrList
argument_list|,
argument|SourceRange range
argument_list|,
argument|bool hasAttr
argument_list|)
block|:
name|AttrList
argument_list|(
name|attrList
argument_list|)
operator|,
name|Range
argument_list|(
name|range
argument_list|)
operator|,
name|HasAttr
argument_list|(
argument|hasAttr
argument_list|)
block|{   }
name|CXX0XAttributeList
argument_list|()
operator|:
name|AttrList
argument_list|(
literal|0
argument_list|)
operator|,
name|Range
argument_list|()
operator|,
name|HasAttr
argument_list|(
argument|false
argument_list|)
block|{   }
block|}
struct|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

