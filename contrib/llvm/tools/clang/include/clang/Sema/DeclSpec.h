begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to store parsed information about
end_comment

begin_comment
comment|// declaration-specifiers and declarators.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   static const int volatile x, *y, *(*(*z)[10])(const void *x);
end_comment

begin_comment
comment|//   ------------------------- -  --  ---------------------------
end_comment

begin_comment
comment|//     declaration-specifiers  \  |   /
end_comment

begin_comment
comment|//                            declarators
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_define

begin_include
include|#
directive|include
file|"clang/Sema/AttributeList.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Token.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|LangOptions
decl_stmt|;
name|class
name|Diagnostic
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|NestedNameSpecifier
decl_stmt|;
name|class
name|Preprocessor
decl_stmt|;
name|class
name|Declarator
decl_stmt|;
struct_decl|struct
name|TemplateIdAnnotation
struct_decl|;
comment|/// CXXScopeSpec - Represents a C++ nested-name-specifier or a global scope
comment|/// specifier.  These can be in 3 states:
comment|///   1) Not present, identified by isEmpty()
comment|///   2) Present, identified by isNotEmpty()
comment|///      2.a) Valid, idenified by isValid()
comment|///      2.b) Invalid, identified by isInvalid().
comment|///
comment|/// isSet() is deprecated because it mostly corresponded to "valid" but was
comment|/// often used as if it meant "present".
comment|///
comment|/// The actual scope is described by getScopeRep().
name|class
name|CXXScopeSpec
block|{
name|SourceRange
name|Range
decl_stmt|;
name|NestedNameSpecifier
modifier|*
name|ScopeRep
decl_stmt|;
name|public
label|:
name|CXXScopeSpec
argument_list|()
operator|:
name|Range
argument_list|()
operator|,
name|ScopeRep
argument_list|()
block|{ }
specifier|const
name|SourceRange
operator|&
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|void
name|setRange
parameter_list|(
specifier|const
name|SourceRange
modifier|&
name|R
parameter_list|)
block|{
name|Range
operator|=
name|R
expr_stmt|;
block|}
name|void
name|setBeginLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|setEndLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|SourceLocation
name|getBeginLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|NestedNameSpecifier
operator|*
name|getScopeRep
argument_list|()
specifier|const
block|{
return|return
name|ScopeRep
return|;
block|}
name|void
name|setScopeRep
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|S
parameter_list|)
block|{
name|ScopeRep
operator|=
name|S
expr_stmt|;
block|}
comment|/// No scope specifier.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Range
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// A scope specifier is present, but may be valid or invalid.
name|bool
name|isNotEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isEmpty
argument_list|()
return|;
block|}
comment|/// An error occured during parsing of the scope specifier.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|ScopeRep
operator|==
literal|0
return|;
block|}
comment|/// A scope specifier is present, and it refers to a real scope.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|ScopeRep
operator|!=
literal|0
return|;
block|}
comment|/// Deprecated.  Some call sites intend isNotEmpty() while others intend
comment|/// isValid().
name|bool
name|isSet
argument_list|()
specifier|const
block|{
return|return
name|ScopeRep
operator|!=
literal|0
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Range
operator|=
name|SourceRange
argument_list|()
expr_stmt|;
name|ScopeRep
operator|=
literal|0
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// DeclSpec - This class captures information about "declaration specifiers",
comment|/// which encompasses storage-class-specifiers, type-specifiers,
comment|/// type-qualifiers, and function-specifiers.
name|class
name|DeclSpec
block|{
name|public
label|:
comment|// storage-class-specifier
comment|// Note: The order of these enumerators is important for diagnostics.
enum|enum
name|SCS
block|{
name|SCS_unspecified
init|=
literal|0
block|,
name|SCS_typedef
block|,
name|SCS_extern
block|,
name|SCS_static
block|,
name|SCS_auto
block|,
name|SCS_register
block|,
name|SCS_private_extern
block|,
name|SCS_mutable
block|}
enum|;
comment|// Import type specifier width enumeration and constants.
typedef|typedef
name|TypeSpecifierWidth
name|TSW
typedef|;
specifier|static
specifier|const
name|TSW
name|TSW_unspecified
init|=
name|clang
operator|::
name|TSW_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_short
init|=
name|clang
operator|::
name|TSW_short
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_long
init|=
name|clang
operator|::
name|TSW_long
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_longlong
init|=
name|clang
operator|::
name|TSW_longlong
decl_stmt|;
enum|enum
name|TSC
block|{
name|TSC_unspecified
block|,
name|TSC_imaginary
block|,
name|TSC_complex
block|}
enum|;
comment|// Import type specifier sign enumeration and constants.
typedef|typedef
name|TypeSpecifierSign
name|TSS
typedef|;
specifier|static
specifier|const
name|TSS
name|TSS_unspecified
init|=
name|clang
operator|::
name|TSS_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_signed
init|=
name|clang
operator|::
name|TSS_signed
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_unsigned
init|=
name|clang
operator|::
name|TSS_unsigned
decl_stmt|;
comment|// Import type specifier type enumeration and constants.
typedef|typedef
name|TypeSpecifierType
name|TST
typedef|;
specifier|static
specifier|const
name|TST
name|TST_unspecified
init|=
name|clang
operator|::
name|TST_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_void
init|=
name|clang
operator|::
name|TST_void
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char
init|=
name|clang
operator|::
name|TST_char
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_wchar
init|=
name|clang
operator|::
name|TST_wchar
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char16
init|=
name|clang
operator|::
name|TST_char16
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char32
init|=
name|clang
operator|::
name|TST_char32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_int
init|=
name|clang
operator|::
name|TST_int
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_float
init|=
name|clang
operator|::
name|TST_float
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_double
init|=
name|clang
operator|::
name|TST_double
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_bool
init|=
name|clang
operator|::
name|TST_bool
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal32
init|=
name|clang
operator|::
name|TST_decimal32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal64
init|=
name|clang
operator|::
name|TST_decimal64
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal128
init|=
name|clang
operator|::
name|TST_decimal128
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_enum
init|=
name|clang
operator|::
name|TST_enum
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_union
init|=
name|clang
operator|::
name|TST_union
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_struct
init|=
name|clang
operator|::
name|TST_struct
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_class
init|=
name|clang
operator|::
name|TST_class
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typename
init|=
name|clang
operator|::
name|TST_typename
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofType
init|=
name|clang
operator|::
name|TST_typeofType
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofExpr
init|=
name|clang
operator|::
name|TST_typeofExpr
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decltype
init|=
name|clang
operator|::
name|TST_decltype
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_auto
init|=
name|clang
operator|::
name|TST_auto
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_error
init|=
name|clang
operator|::
name|TST_error
decl_stmt|;
comment|// type-qualifiers
enum|enum
name|TQ
block|{
comment|// NOTE: These flags must be kept in sync with Qualifiers::TQ.
name|TQ_unspecified
init|=
literal|0
block|,
name|TQ_const
init|=
literal|1
block|,
name|TQ_restrict
init|=
literal|2
block|,
name|TQ_volatile
init|=
literal|4
block|}
enum|;
comment|/// ParsedSpecifiers - Flags to query which specifiers were applied.  This is
comment|/// returned by getParsedSpecifiers.
enum|enum
name|ParsedSpecifiers
block|{
name|PQ_None
init|=
literal|0
block|,
name|PQ_StorageClassSpecifier
init|=
literal|1
block|,
name|PQ_TypeSpecifier
init|=
literal|2
block|,
name|PQ_TypeQualifier
init|=
literal|4
block|,
name|PQ_FunctionSpecifier
init|=
literal|8
block|}
enum|;
name|private
label|:
comment|// storage-class-specifier
comment|/*SCS*/
name|unsigned
name|StorageClassSpec
range|:
literal|3
decl_stmt|;
name|bool
name|SCS_thread_specified
range|:
literal|1
decl_stmt|;
name|bool
name|SCS_extern_in_linkage_spec
range|:
literal|1
decl_stmt|;
comment|// type-specifier
comment|/*TSW*/
name|unsigned
name|TypeSpecWidth
range|:
literal|2
decl_stmt|;
comment|/*TSC*/
name|unsigned
name|TypeSpecComplex
range|:
literal|2
decl_stmt|;
comment|/*TSS*/
name|unsigned
name|TypeSpecSign
range|:
literal|2
decl_stmt|;
comment|/*TST*/
name|unsigned
name|TypeSpecType
range|:
literal|5
decl_stmt|;
name|bool
name|TypeAltiVecVector
range|:
literal|1
decl_stmt|;
name|bool
name|TypeAltiVecPixel
range|:
literal|1
decl_stmt|;
name|bool
name|TypeAltiVecBool
range|:
literal|1
decl_stmt|;
name|bool
name|TypeSpecOwned
range|:
literal|1
decl_stmt|;
comment|// type-qualifiers
name|unsigned
name|TypeQualifiers
range|:
literal|3
decl_stmt|;
comment|// Bitwise OR of TQ.
comment|// function-specifier
name|bool
name|FS_inline_specified
range|:
literal|1
decl_stmt|;
name|bool
name|FS_virtual_specified
range|:
literal|1
decl_stmt|;
name|bool
name|FS_explicit_specified
range|:
literal|1
decl_stmt|;
comment|// friend-specifier
name|bool
name|Friend_specified
range|:
literal|1
decl_stmt|;
comment|// constexpr-specifier
name|bool
name|Constexpr_specified
range|:
literal|1
decl_stmt|;
comment|/*SCS*/
name|unsigned
name|StorageClassSpecAsWritten
range|:
literal|3
decl_stmt|;
union|union
block|{
name|UnionParsedType
name|TypeRep
decl_stmt|;
name|Decl
modifier|*
name|DeclRep
decl_stmt|;
name|Expr
modifier|*
name|ExprRep
decl_stmt|;
block|}
union|;
comment|// attributes.
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
comment|// Scope specifier for the type spec, if applicable.
name|CXXScopeSpec
name|TypeScope
decl_stmt|;
comment|// List of protocol qualifiers for objective-c classes.  Used for
comment|// protocol-qualified interfaces "NString<foo>" and protocol-qualified id
comment|// "id<foo>".
name|Decl
modifier|*
specifier|const
modifier|*
name|ProtocolQualifiers
decl_stmt|;
name|unsigned
name|NumProtocolQualifiers
decl_stmt|;
name|SourceLocation
name|ProtocolLAngleLoc
decl_stmt|;
name|SourceLocation
modifier|*
name|ProtocolLocs
decl_stmt|;
comment|// SourceLocation info.  These are null if the item wasn't specified or if
comment|// the setting was synthesized.
name|SourceRange
name|Range
decl_stmt|;
name|SourceLocation
name|StorageClassSpecLoc
decl_stmt|,
name|SCS_threadLoc
decl_stmt|;
name|SourceLocation
name|TSWLoc
decl_stmt|,
name|TSCLoc
decl_stmt|,
name|TSSLoc
decl_stmt|,
name|TSTLoc
decl_stmt|,
name|AltiVecLoc
decl_stmt|;
name|SourceRange
name|TypeofParensRange
decl_stmt|;
name|SourceLocation
name|TQ_constLoc
decl_stmt|,
name|TQ_restrictLoc
decl_stmt|,
name|TQ_volatileLoc
decl_stmt|;
name|SourceLocation
name|FS_inlineLoc
decl_stmt|,
name|FS_virtualLoc
decl_stmt|,
name|FS_explicitLoc
decl_stmt|;
name|SourceLocation
name|FriendLoc
decl_stmt|,
name|ConstexprLoc
decl_stmt|;
name|WrittenBuiltinSpecs
name|writtenBS
decl_stmt|;
name|void
name|SaveWrittenBuiltinSpecs
parameter_list|()
function_decl|;
name|void
name|SaveStorageSpecifierAsWritten
parameter_list|()
function_decl|;
specifier|static
name|bool
name|isTypeRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typename
operator|||
name|T
operator|==
name|TST_typeofType
operator|)
return|;
block|}
specifier|static
name|bool
name|isExprRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typeofExpr
operator|||
name|T
operator|==
name|TST_decltype
operator|)
return|;
block|}
specifier|static
name|bool
name|isDeclRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_enum
operator|||
name|T
operator|==
name|TST_struct
operator|||
name|T
operator|==
name|TST_union
operator|||
name|T
operator|==
name|TST_class
operator|)
return|;
block|}
name|DeclSpec
argument_list|(
specifier|const
name|DeclSpec
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|DeclSpec
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
name|DeclSpec
argument_list|()
operator|:
name|StorageClassSpec
argument_list|(
name|SCS_unspecified
argument_list|)
operator|,
name|SCS_thread_specified
argument_list|(
name|false
argument_list|)
operator|,
name|SCS_extern_in_linkage_spec
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecWidth
argument_list|(
name|TSW_unspecified
argument_list|)
operator|,
name|TypeSpecComplex
argument_list|(
name|TSC_unspecified
argument_list|)
operator|,
name|TypeSpecSign
argument_list|(
name|TSS_unspecified
argument_list|)
operator|,
name|TypeSpecType
argument_list|(
name|TST_unspecified
argument_list|)
operator|,
name|TypeAltiVecVector
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecPixel
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecBool
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecOwned
argument_list|(
name|false
argument_list|)
operator|,
name|TypeQualifiers
argument_list|(
name|TSS_unspecified
argument_list|)
operator|,
name|FS_inline_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_virtual_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_explicit_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Friend_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Constexpr_specified
argument_list|(
name|false
argument_list|)
operator|,
name|StorageClassSpecAsWritten
argument_list|(
name|SCS_unspecified
argument_list|)
operator|,
name|AttrList
argument_list|(
literal|0
argument_list|)
operator|,
name|ProtocolQualifiers
argument_list|(
literal|0
argument_list|)
operator|,
name|NumProtocolQualifiers
argument_list|(
literal|0
argument_list|)
operator|,
name|ProtocolLocs
argument_list|(
literal|0
argument_list|)
operator|,
name|writtenBS
argument_list|()
block|{   }
operator|~
name|DeclSpec
argument_list|()
block|{
name|delete
name|AttrList
block|;
name|delete
index|[]
name|ProtocolQualifiers
block|;
name|delete
index|[]
name|ProtocolLocs
block|;   }
comment|// storage-class-specifier
name|SCS
name|getStorageClassSpec
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SCS
operator|)
name|StorageClassSpec
return|;
block|}
name|bool
name|isThreadSpecified
argument_list|()
specifier|const
block|{
return|return
name|SCS_thread_specified
return|;
block|}
name|bool
name|isExternInLinkageSpec
argument_list|()
specifier|const
block|{
return|return
name|SCS_extern_in_linkage_spec
return|;
block|}
name|void
name|setExternInLinkageSpec
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|SCS_extern_in_linkage_spec
operator|=
name|Value
expr_stmt|;
block|}
name|SourceLocation
name|getStorageClassSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|StorageClassSpecLoc
return|;
block|}
name|SourceLocation
name|getThreadSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|SCS_threadLoc
return|;
block|}
name|void
name|ClearStorageClassSpecs
parameter_list|()
block|{
name|StorageClassSpec
operator|=
name|DeclSpec
operator|::
name|SCS_unspecified
expr_stmt|;
name|SCS_thread_specified
operator|=
name|false
expr_stmt|;
name|SCS_extern_in_linkage_spec
operator|=
name|false
expr_stmt|;
name|StorageClassSpecLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|SCS_threadLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|// type-specifier
name|TSW
name|getTypeSpecWidth
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSW
operator|)
name|TypeSpecWidth
return|;
block|}
name|TSC
name|getTypeSpecComplex
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSC
operator|)
name|TypeSpecComplex
return|;
block|}
name|TSS
name|getTypeSpecSign
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSS
operator|)
name|TypeSpecSign
return|;
block|}
name|TST
name|getTypeSpecType
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TST
operator|)
name|TypeSpecType
return|;
block|}
name|bool
name|isTypeAltiVecVector
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecVector
return|;
block|}
name|bool
name|isTypeAltiVecPixel
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecPixel
return|;
block|}
name|bool
name|isTypeAltiVecBool
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecBool
return|;
block|}
name|bool
name|isTypeSpecOwned
argument_list|()
specifier|const
block|{
return|return
name|TypeSpecOwned
return|;
block|}
name|ParsedType
name|getRepAsType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a type"
argument_list|)
block|;
return|return
name|TypeRep
return|;
block|}
name|Decl
operator|*
name|getRepAsDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a decl"
argument_list|)
block|;
return|return
name|DeclRep
return|;
block|}
name|Expr
operator|*
name|getRepAsExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store an expr"
argument_list|)
block|;
return|return
name|ExprRep
return|;
block|}
name|CXXScopeSpec
modifier|&
name|getTypeSpecScope
parameter_list|()
block|{
return|return
name|TypeScope
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|getTypeSpecScope
argument_list|()
specifier|const
block|{
return|return
name|TypeScope
return|;
block|}
specifier|const
name|SourceRange
operator|&
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|SourceLocation
name|getTypeSpecWidthLoc
argument_list|()
specifier|const
block|{
return|return
name|TSWLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecComplexLoc
argument_list|()
specifier|const
block|{
return|return
name|TSCLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecSignLoc
argument_list|()
specifier|const
block|{
return|return
name|TSSLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|TSTLoc
return|;
block|}
name|SourceLocation
name|getAltiVecLoc
argument_list|()
specifier|const
block|{
return|return
name|AltiVecLoc
return|;
block|}
name|SourceRange
name|getTypeofParensRange
argument_list|()
specifier|const
block|{
return|return
name|TypeofParensRange
return|;
block|}
name|void
name|setTypeofParensRange
parameter_list|(
name|SourceRange
name|range
parameter_list|)
block|{
name|TypeofParensRange
operator|=
name|range
expr_stmt|;
block|}
comment|/// getSpecifierName - Turn a type-specifier-type into a string like "_Bool"
comment|/// or "union".
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TST
name|T
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TQ
name|Q
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSS
name|S
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSC
name|C
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSW
name|W
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|SCS
name|S
argument_list|)
decl_stmt|;
comment|// type-qualifiers
comment|/// getTypeQualifiers - Return a set of TQs.
name|unsigned
name|getTypeQualifiers
argument_list|()
specifier|const
block|{
return|return
name|TypeQualifiers
return|;
block|}
name|SourceLocation
name|getConstSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_constLoc
return|;
block|}
name|SourceLocation
name|getRestrictSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_restrictLoc
return|;
block|}
name|SourceLocation
name|getVolatileSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_volatileLoc
return|;
block|}
comment|// function-specifier
name|bool
name|isInlineSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_inline_specified
return|;
block|}
name|SourceLocation
name|getInlineSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_inlineLoc
return|;
block|}
name|bool
name|isVirtualSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_virtual_specified
return|;
block|}
name|SourceLocation
name|getVirtualSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_virtualLoc
return|;
block|}
name|bool
name|isExplicitSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_explicit_specified
return|;
block|}
name|SourceLocation
name|getExplicitSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_explicitLoc
return|;
block|}
name|void
name|ClearFunctionSpecs
parameter_list|()
block|{
name|FS_inline_specified
operator|=
name|false
expr_stmt|;
name|FS_inlineLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_virtual_specified
operator|=
name|false
expr_stmt|;
name|FS_virtualLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_explicit_specified
operator|=
name|false
expr_stmt|;
name|FS_explicitLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|/// hasTypeSpecifier - Return true if any type-specifier has been found.
name|bool
name|hasTypeSpecifier
argument_list|()
specifier|const
block|{
return|return
name|getTypeSpecType
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TST_unspecified
operator|||
name|getTypeSpecWidth
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSW_unspecified
operator|||
name|getTypeSpecComplex
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSC_unspecified
operator|||
name|getTypeSpecSign
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSS_unspecified
return|;
block|}
comment|/// getParsedSpecifiers - Return a bitmask of which flavors of specifiers this
comment|/// DeclSpec includes.
comment|///
name|unsigned
name|getParsedSpecifiers
argument_list|()
specifier|const
expr_stmt|;
name|SCS
name|getStorageClassSpecAsWritten
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SCS
operator|)
name|StorageClassSpecAsWritten
return|;
block|}
comment|/// isEmpty - Return true if this declaration specifier is completely empty:
comment|/// no tokens were parsed in the production of it.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|getParsedSpecifiers
argument_list|()
operator|==
name|DeclSpec
operator|::
name|PQ_None
return|;
block|}
name|void
name|SetRangeStart
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|SetRangeEnd
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// These methods set the specified attribute of the DeclSpec and
comment|/// return false if there was no error.  If an error occurs (for
comment|/// example, if we tried to set "auto" on a spec with "extern"
comment|/// already set), they return true and set PrevSpec and DiagID
comment|/// such that
comment|///   Diag(Loc, DiagID)<< PrevSpec;
comment|/// will yield a useful result.
comment|///
comment|/// TODO: use a more general approach that still allows these
comment|/// diagnostics to be ignored when desired.
name|bool
name|SetStorageClassSpec
parameter_list|(
name|SCS
name|S
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetStorageClassSpecThread
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecWidth
parameter_list|(
name|TSW
name|W
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecComplex
parameter_list|(
name|TSC
name|C
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecSign
parameter_list|(
name|TSS
name|S
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|ParsedType
name|Rep
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Decl
modifier|*
name|Rep
parameter_list|,
name|bool
name|Owned
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Expr
modifier|*
name|Rep
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecVector
parameter_list|(
name|bool
name|isAltiVecVector
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecPixel
parameter_list|(
name|bool
name|isAltiVecPixel
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecError
parameter_list|()
function_decl|;
name|void
name|UpdateDeclRep
parameter_list|(
name|Decl
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|DeclRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateTypeRep
parameter_list|(
name|ParsedType
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|TypeRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateExprRep
parameter_list|(
name|Expr
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|ExprRep
operator|=
name|Rep
expr_stmt|;
block|}
name|bool
name|SetTypeQual
parameter_list|(
name|TQ
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|Lang
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecInline
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecVirtual
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecExplicit
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFriendSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetConstexprSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|isFriendSpecified
argument_list|()
specifier|const
block|{
return|return
name|Friend_specified
return|;
block|}
name|SourceLocation
name|getFriendSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FriendLoc
return|;
block|}
name|bool
name|isConstexprSpecified
argument_list|()
specifier|const
block|{
return|return
name|Constexpr_specified
return|;
block|}
name|SourceLocation
name|getConstexprSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ConstexprLoc
return|;
block|}
comment|/// AddAttributes - contatenates two attribute lists.
comment|/// The GCC attribute syntax allows for the following:
comment|///
comment|/// short __attribute__(( unused, deprecated ))
comment|/// int __attribute__(( may_alias, aligned(16) )) var;
comment|///
comment|/// This declares 4 attributes using 2 lists. The following syntax is
comment|/// also allowed and equivalent to the previous declaration.
comment|///
comment|/// short __attribute__((unused)) __attribute__((deprecated))
comment|/// int __attribute__((may_alias)) __attribute__((aligned(16))) var;
comment|///
name|void
name|AddAttributes
parameter_list|(
name|AttributeList
modifier|*
name|alist
parameter_list|)
block|{
name|AttrList
operator|=
name|addAttributeLists
argument_list|(
name|AttrList
argument_list|,
name|alist
argument_list|)
expr_stmt|;
block|}
name|void
name|SetAttributes
parameter_list|(
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|AttrList
operator|=
name|AL
expr_stmt|;
block|}
specifier|const
name|AttributeList
operator|*
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|AttrList
return|;
block|}
name|AttributeList
modifier|*
name|getAttributes
parameter_list|()
block|{
return|return
name|AttrList
return|;
block|}
comment|/// TakeAttributes - Return the current attribute list and remove them from
comment|/// the DeclSpec so that it doesn't own them.
name|AttributeList
modifier|*
name|TakeAttributes
parameter_list|()
block|{
name|AttributeList
modifier|*
name|AL
init|=
name|AttrList
decl_stmt|;
name|AttrList
operator|=
literal|0
expr_stmt|;
return|return
name|AL
return|;
block|}
typedef|typedef
name|Decl
modifier|*
specifier|const
modifier|*
name|ProtocolQualifierListTy
typedef|;
name|ProtocolQualifierListTy
name|getProtocolQualifiers
argument_list|()
specifier|const
block|{
return|return
name|ProtocolQualifiers
return|;
block|}
name|SourceLocation
operator|*
name|getProtocolLocs
argument_list|()
specifier|const
block|{
return|return
name|ProtocolLocs
return|;
block|}
name|unsigned
name|getNumProtocolQualifiers
argument_list|()
specifier|const
block|{
return|return
name|NumProtocolQualifiers
return|;
block|}
name|SourceLocation
name|getProtocolLAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|ProtocolLAngleLoc
return|;
block|}
name|void
name|setProtocolQualifiers
parameter_list|(
name|Decl
modifier|*
specifier|const
modifier|*
name|Protos
parameter_list|,
name|unsigned
name|NP
parameter_list|,
name|SourceLocation
modifier|*
name|ProtoLocs
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|)
function_decl|;
comment|/// Finish - This does final analysis of the declspec, issuing diagnostics for
comment|/// things like "_Imaginary" (lacking an FP type).  After calling this method,
comment|/// DeclSpec is guaranteed self-consistent, even if an error occurred.
name|void
name|Finish
parameter_list|(
name|Diagnostic
modifier|&
name|D
parameter_list|,
name|Preprocessor
modifier|&
name|PP
parameter_list|)
function_decl|;
specifier|const
name|WrittenBuiltinSpecs
operator|&
name|getWrittenBuiltinSpecs
argument_list|()
specifier|const
block|{
return|return
name|writtenBS
return|;
block|}
comment|/// isMissingDeclaratorOk - This checks if this DeclSpec can stand alone,
comment|/// without a Declarator. Only tag declspecs can stand alone.
name|bool
name|isMissingDeclaratorOk
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// ObjCDeclSpec - This class captures information about
comment|/// "declaration specifiers" specific to objective-c
name|class
name|ObjCDeclSpec
block|{
name|public
label|:
comment|/// ObjCDeclQualifier - Qualifier used on types in method declarations
enum|enum
name|ObjCDeclQualifier
block|{
name|DQ_None
init|=
literal|0x0
block|,
name|DQ_In
init|=
literal|0x1
block|,
name|DQ_Inout
init|=
literal|0x2
block|,
name|DQ_Out
init|=
literal|0x4
block|,
name|DQ_Bycopy
init|=
literal|0x8
block|,
name|DQ_Byref
init|=
literal|0x10
block|,
name|DQ_Oneway
init|=
literal|0x20
block|}
enum|;
comment|/// PropertyAttributeKind - list of property attributes.
enum|enum
name|ObjCPropertyAttributeKind
block|{
name|DQ_PR_noattr
init|=
literal|0x0
block|,
name|DQ_PR_readonly
init|=
literal|0x01
block|,
name|DQ_PR_getter
init|=
literal|0x02
block|,
name|DQ_PR_assign
init|=
literal|0x04
block|,
name|DQ_PR_readwrite
init|=
literal|0x08
block|,
name|DQ_PR_retain
init|=
literal|0x10
block|,
name|DQ_PR_copy
init|=
literal|0x20
block|,
name|DQ_PR_nonatomic
init|=
literal|0x40
block|,
name|DQ_PR_setter
init|=
literal|0x80
block|}
enum|;
name|ObjCDeclSpec
argument_list|()
operator|:
name|objcDeclQualifier
argument_list|(
name|DQ_None
argument_list|)
operator|,
name|PropertyAttributes
argument_list|(
name|DQ_PR_noattr
argument_list|)
operator|,
name|GetterName
argument_list|(
literal|0
argument_list|)
operator|,
name|SetterName
argument_list|(
literal|0
argument_list|)
block|{ }
name|ObjCDeclQualifier
name|getObjCDeclQualifier
argument_list|()
specifier|const
block|{
return|return
name|objcDeclQualifier
return|;
block|}
name|void
name|setObjCDeclQualifier
parameter_list|(
name|ObjCDeclQualifier
name|DQVal
parameter_list|)
block|{
name|objcDeclQualifier
operator|=
call|(
name|ObjCDeclQualifier
call|)
argument_list|(
name|objcDeclQualifier
operator||
name|DQVal
argument_list|)
expr_stmt|;
block|}
name|ObjCPropertyAttributeKind
name|getPropertyAttributes
argument_list|()
specifier|const
block|{
return|return
name|ObjCPropertyAttributeKind
argument_list|(
name|PropertyAttributes
argument_list|)
return|;
block|}
name|void
name|setPropertyAttributes
parameter_list|(
name|ObjCPropertyAttributeKind
name|PRVal
parameter_list|)
block|{
name|PropertyAttributes
operator|=
call|(
name|ObjCPropertyAttributeKind
call|)
argument_list|(
name|PropertyAttributes
operator||
name|PRVal
argument_list|)
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getGetterName
argument_list|()
specifier|const
block|{
return|return
name|GetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getGetterName
parameter_list|()
block|{
return|return
name|GetterName
return|;
block|}
name|void
name|setGetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|GetterName
operator|=
name|name
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getSetterName
argument_list|()
specifier|const
block|{
return|return
name|SetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getSetterName
parameter_list|()
block|{
return|return
name|SetterName
return|;
block|}
name|void
name|setSetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|SetterName
operator|=
name|name
expr_stmt|;
block|}
name|private
label|:
comment|// FIXME: These two are unrelated and mutially exclusive. So perhaps
comment|// we can put them in a union to reflect their mutual exclusiveness
comment|// (space saving is negligible).
name|ObjCDeclQualifier
name|objcDeclQualifier
range|:
literal|6
decl_stmt|;
comment|// NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttributeKind
name|unsigned
name|PropertyAttributes
range|:
literal|8
decl_stmt|;
name|IdentifierInfo
modifier|*
name|GetterName
decl_stmt|;
comment|// getter name of NULL if no getter
name|IdentifierInfo
modifier|*
name|SetterName
decl_stmt|;
comment|// setter name of NULL if no setter
block|}
empty_stmt|;
comment|/// \brief Represents a C++ unqualified-id that has been parsed.
name|class
name|UnqualifiedId
block|{
name|private
label|:
specifier|const
name|UnqualifiedId
modifier|&
name|operator
init|=
operator|(
specifier|const
name|UnqualifiedId
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
comment|/// \brief Describes the kind of unqualified-id parsed.
enum|enum
name|IdKind
block|{
comment|/// \brief An identifier.
name|IK_Identifier
block|,
comment|/// \brief An overloaded operator name, e.g., operator+.
name|IK_OperatorFunctionId
block|,
comment|/// \brief A conversion function name, e.g., operator int.
name|IK_ConversionFunctionId
block|,
comment|/// \brief A user-defined literal name, e.g., operator "" _i.
name|IK_LiteralOperatorId
block|,
comment|/// \brief A constructor name.
name|IK_ConstructorName
block|,
comment|/// \brief A constructor named via a template-id.
name|IK_ConstructorTemplateId
block|,
comment|/// \brief A destructor name.
name|IK_DestructorName
block|,
comment|/// \brief A template-id, e.g., f<int>.
name|IK_TemplateId
block|}
name|Kind
enum|;
comment|/// \brief Anonymous union that holds extra data associated with the
comment|/// parsed unqualified-id.
union|union
block|{
comment|/// \brief When Kind == IK_Identifier, the parsed identifier, or when Kind
comment|/// == IK_UserLiteralId, the identifier suffix.
name|IdentifierInfo
modifier|*
name|Identifier
decl_stmt|;
comment|/// \brief When Kind == IK_OperatorFunctionId, the overloaded operator
comment|/// that we parsed.
struct|struct
block|{
comment|/// \brief The kind of overloaded operator.
name|OverloadedOperatorKind
name|Operator
decl_stmt|;
comment|/// \brief The source locations of the individual tokens that name
comment|/// the operator, e.g., the "new", "[", and "]" tokens in
comment|/// operator new [].
comment|///
comment|/// Different operators have different numbers of tokens in their name,
comment|/// up to three. Any remaining source locations in this array will be
comment|/// set to an invalid value for operators with fewer than three tokens.
name|unsigned
name|SymbolLocations
index|[
literal|3
index|]
decl_stmt|;
block|}
name|OperatorFunctionId
struct|;
comment|/// \brief When Kind == IK_ConversionFunctionId, the type that the
comment|/// conversion function names.
name|UnionParsedType
name|ConversionFunctionId
decl_stmt|;
comment|/// \brief When Kind == IK_ConstructorName, the class-name of the type
comment|/// whose constructor is being referenced.
name|UnionParsedType
name|ConstructorName
decl_stmt|;
comment|/// \brief When Kind == IK_DestructorName, the type referred to by the
comment|/// class-name.
name|UnionParsedType
name|DestructorName
decl_stmt|;
comment|/// \brief When Kind == IK_TemplateId or IK_ConstructorTemplateId,
comment|/// the template-id annotation that contains the template name and
comment|/// template arguments.
name|TemplateIdAnnotation
modifier|*
name|TemplateId
decl_stmt|;
block|}
union|;
comment|/// \brief The location of the first token that describes this unqualified-id,
comment|/// which will be the location of the identifier, "operator" keyword,
comment|/// tilde (for a destructor), or the template name of a template-id.
name|SourceLocation
name|StartLocation
decl_stmt|;
comment|/// \brief The location of the last token that describes this unqualified-id.
name|SourceLocation
name|EndLocation
decl_stmt|;
name|UnqualifiedId
argument_list|()
operator|:
name|Kind
argument_list|(
name|IK_Identifier
argument_list|)
operator|,
name|Identifier
argument_list|(
literal|0
argument_list|)
block|{ }
comment|/// \brief Do not use this copy constructor. It is temporary, and only
comment|/// exists because we are holding FieldDeclarators in a SmallVector when we
comment|/// don't actually need them.
comment|///
comment|/// FIXME: Kill this copy constructor.
name|UnqualifiedId
argument_list|(
specifier|const
name|UnqualifiedId
operator|&
name|Other
argument_list|)
operator|:
name|Kind
argument_list|(
name|IK_Identifier
argument_list|)
operator|,
name|Identifier
argument_list|(
name|Other
operator|.
name|Identifier
argument_list|)
operator|,
name|StartLocation
argument_list|(
name|Other
operator|.
name|StartLocation
argument_list|)
operator|,
name|EndLocation
argument_list|(
argument|Other.EndLocation
argument_list|)
block|{
name|assert
argument_list|(
name|Other
operator|.
name|Kind
operator|==
name|IK_Identifier
operator|&&
literal|"Cannot copy non-identifiers"
argument_list|)
block|;   }
comment|/// \brief Destroy this unqualified-id.
operator|~
name|UnqualifiedId
argument_list|()
block|{
name|clear
argument_list|()
block|; }
comment|/// \brief Clear out this unqualified-id, setting it to default (invalid)
comment|/// state.
name|void
name|clear
argument_list|()
expr_stmt|;
comment|/// \brief Determine whether this unqualified-id refers to a valid name.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|StartLocation
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine whether this unqualified-id refers to an invalid name.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine what kind of name we have.
name|IdKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an identifier.
comment|///
comment|/// \param Id the parsed identifier.
comment|/// \param IdLoc the location of the parsed identifier.
name|void
name|setIdentifier
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_Identifier
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an
comment|/// operator-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Op the overloaded operator.
comment|///
comment|/// \param SymbolLocations the locations of the individual operator symbols
comment|/// in the operator.
name|void
name|setOperatorFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|OverloadedOperatorKind
name|Op
parameter_list|,
name|SourceLocation
name|SymbolLocations
index|[
literal|3
index|]
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// conversion-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Ty the type to which this conversion function is converting.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConversionFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConversionFunctionId
expr_stmt|;
name|StartLocation
operator|=
name|OperatorLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConversionFunctionId
operator|=
name|Ty
expr_stmt|;
block|}
comment|/// \brief Specific that this unqualified-id was parsed as a
comment|/// literal-operator-id.
comment|///
comment|/// \param Id the parsed identifier.
comment|///
comment|/// \param OpLoc the location of the 'operator' keyword.
comment|///
comment|/// \param IdLoc the location of the identifier.
name|void
name|setLiteralOperatorId
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_LiteralOperatorId
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|OpLoc
expr_stmt|;
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a constructor name.
comment|///
comment|/// \param ClassType the class type referred to by the constructor name.
comment|///
comment|/// \param ClassNameLoc the location of the class name.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConstructorName
parameter_list|(
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|ClassNameLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConstructorName
expr_stmt|;
name|StartLocation
operator|=
name|ClassNameLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConstructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// template-id that names a constructor.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setConstructorTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a destructor name.
comment|///
comment|/// \param TildeLoc the location of the '~' that introduces the destructor
comment|/// name.
comment|///
comment|/// \param ClassType the name of the class referred to by the destructor name.
name|void
name|setDestructorName
parameter_list|(
name|SourceLocation
name|TildeLoc
parameter_list|,
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_DestructorName
expr_stmt|;
name|StartLocation
operator|=
name|TildeLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|DestructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a template-id.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Return the source range that covers this unqualified-id.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|StartLocation
argument_list|,
name|EndLocation
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// CachedTokens - A set of tokens that has been cached for later
comment|/// parsing.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Token
operator|,
literal|4
operator|>
name|CachedTokens
expr_stmt|;
comment|/// DeclaratorChunk - One instance of this struct is used for each type in a
comment|/// declarator that is parsed.
comment|///
comment|/// This is intended to be a small value object.
struct|struct
name|DeclaratorChunk
block|{
enum|enum
block|{
name|Pointer
block|,
name|Reference
block|,
name|Array
block|,
name|Function
block|,
name|BlockPointer
block|,
name|MemberPointer
block|}
name|Kind
enum|;
comment|/// Loc - The place where this type was defined.
name|SourceLocation
name|Loc
decl_stmt|;
comment|/// EndLoc - If valid, the place where this chunck ends.
name|SourceLocation
name|EndLoc
decl_stmt|;
struct|struct
name|PointerTypeInfo
block|{
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
range|:
literal|3
decl_stmt|;
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|void
name|destroy
parameter_list|()
block|{
name|delete
name|AttrList
decl_stmt|;
block|}
block|}
struct|;
struct|struct
name|ReferenceTypeInfo
block|{
comment|/// The type qualifier: restrict. [GNU] C++ extension
name|bool
name|HasRestrict
range|:
literal|1
decl_stmt|;
comment|/// True if this is an lvalue reference, false if it's an rvalue reference.
name|bool
name|LValueRef
range|:
literal|1
decl_stmt|;
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|void
name|destroy
parameter_list|()
block|{
name|delete
name|AttrList
decl_stmt|;
block|}
block|}
struct|;
struct|struct
name|ArrayTypeInfo
block|{
comment|/// The type qualifiers for the array: const/volatile/restrict.
name|unsigned
name|TypeQuals
range|:
literal|3
decl_stmt|;
comment|/// True if this dimension included the 'static' keyword.
name|bool
name|hasStatic
range|:
literal|1
decl_stmt|;
comment|/// True if this dimension was [*].  In this case, NumElts is null.
name|bool
name|isStar
range|:
literal|1
decl_stmt|;
comment|/// This is the size of the array, or null if [] or [*] was specified.
comment|/// Since the parser is multi-purpose, and we don't want to impose a root
comment|/// expression class on all clients, NumElts is untyped.
name|Expr
modifier|*
name|NumElts
decl_stmt|;
name|void
name|destroy
parameter_list|()
block|{}
block|}
struct|;
comment|/// ParamInfo - An array of paraminfo objects is allocated whenever a function
comment|/// declarator is parsed.  There are two interesting styles of arguments here:
comment|/// K&R-style identifier lists and parameter type lists.  K&R-style identifier
comment|/// lists will have information about the identifier, but no type information.
comment|/// Parameter type lists will have type info (if the actions module provides
comment|/// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.
struct|struct
name|ParamInfo
block|{
name|IdentifierInfo
modifier|*
name|Ident
decl_stmt|;
name|SourceLocation
name|IdentLoc
decl_stmt|;
name|Decl
modifier|*
name|Param
decl_stmt|;
comment|/// DefaultArgTokens - When the parameter's default argument
comment|/// cannot be parsed immediately (because it occurs within the
comment|/// declaration of a member function), it will be stored here as a
comment|/// sequence of tokens to be parsed once the class definition is
comment|/// complete. Non-NULL indicates that there is a default argument.
name|CachedTokens
modifier|*
name|DefaultArgTokens
decl_stmt|;
name|ParamInfo
argument_list|()
block|{}
name|ParamInfo
argument_list|(
argument|IdentifierInfo *ident
argument_list|,
argument|SourceLocation iloc
argument_list|,
argument|Decl *param
argument_list|,
argument|CachedTokens *DefArgTokens =
literal|0
argument_list|)
block|:
name|Ident
argument_list|(
name|ident
argument_list|)
operator|,
name|IdentLoc
argument_list|(
name|iloc
argument_list|)
operator|,
name|Param
argument_list|(
name|param
argument_list|)
operator|,
name|DefaultArgTokens
argument_list|(
argument|DefArgTokens
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|TypeAndRange
block|{
name|ParsedType
name|Ty
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
block|}
struct|;
struct|struct
name|FunctionTypeInfo
block|{
comment|/// hasPrototype - This is true if the function had at least one typed
comment|/// argument.  If the function is () or (a,b,c), then it has no prototype,
comment|/// and is treated as a K&R-style function.
name|bool
name|hasPrototype
range|:
literal|1
decl_stmt|;
comment|/// isVariadic - If this function has a prototype, and if that
comment|/// proto ends with ',...)', this is true. When true, EllipsisLoc
comment|/// contains the location of the ellipsis.
name|bool
name|isVariadic
range|:
literal|1
decl_stmt|;
comment|/// The type qualifiers: const/volatile/restrict.
comment|/// The qualifier bitmask values are the same as in QualType.
name|unsigned
name|TypeQuals
range|:
literal|3
decl_stmt|;
comment|/// hasExceptionSpec - True if the function has an exception specification.
name|bool
name|hasExceptionSpec
range|:
literal|1
decl_stmt|;
comment|/// hasAnyExceptionSpec - True if the function has a throw(...) specifier.
name|bool
name|hasAnyExceptionSpec
range|:
literal|1
decl_stmt|;
comment|/// DeleteArgInfo - If this is true, we need to delete[] ArgInfo.
name|bool
name|DeleteArgInfo
range|:
literal|1
decl_stmt|;
comment|/// When isVariadic is true, the location of the ellipsis in the source.
name|unsigned
name|EllipsisLoc
decl_stmt|;
comment|/// NumArgs - This is the number of formal arguments provided for the
comment|/// declarator.
name|unsigned
name|NumArgs
decl_stmt|;
comment|/// NumExceptions - This is the number of types in the exception-decl, if
comment|/// the function has one.
name|unsigned
name|NumExceptions
decl_stmt|;
comment|/// ThrowLoc - When hasExceptionSpec is true, the location of the throw
comment|/// keyword introducing the spec.
name|unsigned
name|ThrowLoc
decl_stmt|;
comment|/// ArgInfo - This is a pointer to a new[]'d array of ParamInfo objects that
comment|/// describe the arguments for this function declarator.  This is null if
comment|/// there are no arguments specified.
name|ParamInfo
modifier|*
name|ArgInfo
decl_stmt|;
comment|/// Exceptions - This is a pointer to a new[]'d array of TypeAndRange
comment|/// objects that contain the types in the function's exception
comment|/// specification and their locations.
name|TypeAndRange
modifier|*
name|Exceptions
decl_stmt|;
comment|/// freeArgs - reset the argument list to having zero arguments.  This is
comment|/// used in various places for error recovery.
name|void
name|freeArgs
parameter_list|()
block|{
if|if
condition|(
name|DeleteArgInfo
condition|)
block|{
name|delete
index|[]
name|ArgInfo
decl_stmt|;
name|DeleteArgInfo
operator|=
name|false
expr_stmt|;
block|}
name|NumArgs
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|DeleteArgInfo
condition|)
name|delete
index|[]
name|ArgInfo
decl_stmt|;
name|delete
index|[]
name|Exceptions
decl_stmt|;
block|}
comment|/// isKNRPrototype - Return true if this is a K&R style identifier list,
comment|/// like "void foo(a,b,c)".  In a function definition, this will be followed
comment|/// by the argument type definitions.
name|bool
name|isKNRPrototype
argument_list|()
specifier|const
block|{
return|return
operator|!
name|hasPrototype
operator|&&
name|NumArgs
operator|!=
literal|0
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|EllipsisLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getThrowLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ThrowLoc
argument_list|)
return|;
block|}
block|}
struct|;
struct|struct
name|BlockPointerTypeInfo
block|{
comment|/// For now, sema will catch these as invalid.
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
range|:
literal|3
decl_stmt|;
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
name|void
name|destroy
parameter_list|()
block|{
name|delete
name|AttrList
decl_stmt|;
block|}
block|}
struct|;
struct|struct
name|MemberPointerTypeInfo
block|{
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
range|:
literal|3
decl_stmt|;
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
comment|// CXXScopeSpec has a constructor, so it can't be a direct member.
comment|// So we need some pointer-aligned storage and a bit of trickery.
union|union
block|{
name|void
modifier|*
name|Aligner
decl_stmt|;
name|char
name|Mem
index|[
sizeof|sizeof
argument_list|(
name|CXXScopeSpec
argument_list|)
index|]
decl_stmt|;
block|}
name|ScopeMem
union|;
name|CXXScopeSpec
modifier|&
name|Scope
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|Scope
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
name|void
name|destroy
parameter_list|()
block|{
name|delete
name|AttrList
decl_stmt|;
name|Scope
argument_list|()
operator|.
operator|~
name|CXXScopeSpec
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
union|union
block|{
name|PointerTypeInfo
name|Ptr
decl_stmt|;
name|ReferenceTypeInfo
name|Ref
decl_stmt|;
name|ArrayTypeInfo
name|Arr
decl_stmt|;
name|FunctionTypeInfo
name|Fun
decl_stmt|;
name|BlockPointerTypeInfo
name|Cls
decl_stmt|;
name|MemberPointerTypeInfo
name|Mem
decl_stmt|;
block|}
union|;
name|void
name|destroy
parameter_list|()
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown decl type!"
argument_list|)
expr_stmt|;
case|case
name|DeclaratorChunk
operator|::
name|Function
case|:
return|return
name|Fun
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Pointer
case|:
return|return
name|Ptr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|BlockPointer
case|:
return|return
name|Cls
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Reference
case|:
return|return
name|Ref
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Array
case|:
return|return
name|Arr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|MemberPointer
case|:
return|return
name|Mem
operator|.
name|destroy
argument_list|()
return|;
block|}
block|}
comment|/// getAttrs - If there are attributes applied to this declaratorchunk, return
comment|/// them.
specifier|const
name|AttributeList
operator|*
name|getAttrs
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown declarator kind!"
argument_list|)
expr_stmt|;
case|case
name|Pointer
case|:
return|return
name|Ptr
operator|.
name|AttrList
return|;
case|case
name|Reference
case|:
return|return
name|Ref
operator|.
name|AttrList
return|;
case|case
name|MemberPointer
case|:
return|return
name|Mem
operator|.
name|AttrList
return|;
case|case
name|Array
case|:
return|return
literal|0
return|;
case|case
name|Function
case|:
return|return
literal|0
return|;
case|case
name|BlockPointer
case|:
return|return
name|Cls
operator|.
name|AttrList
return|;
block|}
block|}
comment|/// getPointer - Return a DeclaratorChunk for a pointer.
comment|///
specifier|static
name|DeclaratorChunk
name|getPointer
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|AttributeList *AL
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Pointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Ptr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Ptr
operator|.
name|AttrList
operator|=
name|AL
block|;
return|return
name|I
return|;
block|}
comment|/// getReference - Return a DeclaratorChunk for a reference.
comment|///
specifier|static
name|DeclaratorChunk
name|getReference
parameter_list|(
name|unsigned
name|TypeQuals
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|AttributeList
modifier|*
name|AL
parameter_list|,
name|bool
name|lvalue
parameter_list|)
block|{
name|DeclaratorChunk
name|I
decl_stmt|;
name|I
operator|.
name|Kind
operator|=
name|Reference
expr_stmt|;
name|I
operator|.
name|Loc
operator|=
name|Loc
expr_stmt|;
name|I
operator|.
name|Ref
operator|.
name|HasRestrict
operator|=
operator|(
name|TypeQuals
operator|&
name|DeclSpec
operator|::
name|TQ_restrict
operator|)
operator|!=
literal|0
expr_stmt|;
name|I
operator|.
name|Ref
operator|.
name|LValueRef
operator|=
name|lvalue
expr_stmt|;
name|I
operator|.
name|Ref
operator|.
name|AttrList
operator|=
name|AL
expr_stmt|;
return|return
name|I
return|;
block|}
comment|/// getArray - Return a DeclaratorChunk for an array.
comment|///
specifier|static
name|DeclaratorChunk
name|getArray
parameter_list|(
name|unsigned
name|TypeQuals
parameter_list|,
name|bool
name|isStatic
parameter_list|,
name|bool
name|isStar
parameter_list|,
name|Expr
modifier|*
name|NumElts
parameter_list|,
name|SourceLocation
name|LBLoc
parameter_list|,
name|SourceLocation
name|RBLoc
parameter_list|)
block|{
name|DeclaratorChunk
name|I
decl_stmt|;
name|I
operator|.
name|Kind
operator|=
name|Array
expr_stmt|;
name|I
operator|.
name|Loc
operator|=
name|LBLoc
expr_stmt|;
name|I
operator|.
name|EndLoc
operator|=
name|RBLoc
expr_stmt|;
name|I
operator|.
name|Arr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
expr_stmt|;
name|I
operator|.
name|Arr
operator|.
name|hasStatic
operator|=
name|isStatic
expr_stmt|;
name|I
operator|.
name|Arr
operator|.
name|isStar
operator|=
name|isStar
expr_stmt|;
name|I
operator|.
name|Arr
operator|.
name|NumElts
operator|=
name|NumElts
expr_stmt|;
return|return
name|I
return|;
block|}
comment|/// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.
comment|/// "TheDeclarator" is the declarator that this will be added to.
specifier|static
name|DeclaratorChunk
name|getFunction
parameter_list|(
name|bool
name|hasProto
parameter_list|,
name|bool
name|isVariadic
parameter_list|,
name|SourceLocation
name|EllipsisLoc
parameter_list|,
name|ParamInfo
modifier|*
name|ArgInfo
parameter_list|,
name|unsigned
name|NumArgs
parameter_list|,
name|unsigned
name|TypeQuals
parameter_list|,
name|bool
name|hasExceptionSpec
parameter_list|,
name|SourceLocation
name|ThrowLoc
parameter_list|,
name|bool
name|hasAnyExceptionSpec
parameter_list|,
name|ParsedType
modifier|*
name|Exceptions
parameter_list|,
name|SourceRange
modifier|*
name|ExceptionRanges
parameter_list|,
name|unsigned
name|NumExceptions
parameter_list|,
name|SourceLocation
name|LPLoc
parameter_list|,
name|SourceLocation
name|RPLoc
parameter_list|,
name|Declarator
modifier|&
name|TheDeclarator
parameter_list|)
function_decl|;
comment|/// getBlockPointer - Return a DeclaratorChunk for a block.
comment|///
specifier|static
name|DeclaratorChunk
name|getBlockPointer
parameter_list|(
name|unsigned
name|TypeQuals
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|DeclaratorChunk
name|I
decl_stmt|;
name|I
operator|.
name|Kind
operator|=
name|BlockPointer
expr_stmt|;
name|I
operator|.
name|Loc
operator|=
name|Loc
expr_stmt|;
name|I
operator|.
name|Cls
operator|.
name|TypeQuals
operator|=
name|TypeQuals
expr_stmt|;
name|I
operator|.
name|Cls
operator|.
name|AttrList
operator|=
name|AL
expr_stmt|;
return|return
name|I
return|;
block|}
specifier|static
name|DeclaratorChunk
name|getMemberPointer
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|unsigned
name|TypeQuals
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|DeclaratorChunk
name|I
decl_stmt|;
name|I
operator|.
name|Kind
operator|=
name|MemberPointer
expr_stmt|;
name|I
operator|.
name|Loc
operator|=
name|Loc
expr_stmt|;
name|I
operator|.
name|Mem
operator|.
name|TypeQuals
operator|=
name|TypeQuals
expr_stmt|;
name|I
operator|.
name|Mem
operator|.
name|AttrList
operator|=
name|AL
expr_stmt|;
name|new
argument_list|(
argument|I.Mem.ScopeMem.Mem
argument_list|)
name|CXXScopeSpec
argument_list|(
name|SS
argument_list|)
expr_stmt|;
return|return
name|I
return|;
block|}
block|}
struct|;
comment|/// Declarator - Information about one declarator, including the parsed type
comment|/// information and the identifier.  When the declarator is fully formed, this
comment|/// is turned into the appropriate Decl object.
comment|///
comment|/// Declarators come in two types: normal declarators and abstract declarators.
comment|/// Abstract declarators are used when parsing types, and don't have an
comment|/// identifier.  Normal declarators do have ID's.
comment|///
comment|/// Instances of this class should be a transient object that lives on the
comment|/// stack, not objects that are allocated in large quantities on the heap.
name|class
name|Declarator
block|{
name|public
label|:
enum|enum
name|TheContext
block|{
name|FileContext
block|,
comment|// File scope declaration.
name|PrototypeContext
block|,
comment|// Within a function prototype.
name|KNRTypeListContext
block|,
comment|// K&R type definition list for formals.
name|TypeNameContext
block|,
comment|// Abstract declarator for types.
name|MemberContext
block|,
comment|// Struct/Union field.
name|BlockContext
block|,
comment|// Declaration within a block in a function.
name|ForContext
block|,
comment|// Declaration within first part of a for loop.
name|ConditionContext
block|,
comment|// Condition declaration in a C++ if/switch/while/for.
name|TemplateParamContext
block|,
comment|// Within a template parameter list.
name|CXXCatchContext
block|,
comment|// C++ catch exception-declaration
name|BlockLiteralContext
comment|// Block literal declarator.
block|}
enum|;
name|private
label|:
specifier|const
name|DeclSpec
modifier|&
name|DS
decl_stmt|;
name|CXXScopeSpec
name|SS
decl_stmt|;
name|UnqualifiedId
name|Name
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
comment|/// Context - Where we are parsing this declarator.
comment|///
name|TheContext
name|Context
decl_stmt|;
comment|/// DeclTypeInfo - This holds each type that the declarator includes as it is
comment|/// parsed.  This is pushed from the identifier out, which means that element
comment|/// #0 will be the most closely bound to the identifier, and
comment|/// DeclTypeInfo.back() will be the least closely bound.
name|llvm
operator|::
name|SmallVector
operator|<
name|DeclaratorChunk
operator|,
literal|8
operator|>
name|DeclTypeInfo
expr_stmt|;
comment|/// InvalidType - Set by Sema::GetTypeForDeclarator().
name|bool
name|InvalidType
range|:
literal|1
decl_stmt|;
comment|/// GroupingParens - Set by Parser::ParseParenDeclarator().
name|bool
name|GroupingParens
range|:
literal|1
decl_stmt|;
comment|/// AttrList - Attributes.
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
comment|/// AsmLabel - The asm label, if specified.
name|Expr
modifier|*
name|AsmLabel
decl_stmt|;
comment|/// InlineParams - This is a local array used for the first function decl
comment|/// chunk to avoid going to the heap for the common case when we have one
comment|/// function chunk in the declarator.
name|DeclaratorChunk
operator|::
name|ParamInfo
name|InlineParams
index|[
literal|16
index|]
expr_stmt|;
name|bool
name|InlineParamsUsed
decl_stmt|;
comment|/// Extension - true if the declaration is preceded by __extension__.
name|bool
name|Extension
range|:
literal|1
decl_stmt|;
name|friend
struct_decl|struct
name|DeclaratorChunk
struct_decl|;
name|public
label|:
name|Declarator
argument_list|(
argument|const DeclSpec&ds
argument_list|,
argument|TheContext C
argument_list|)
block|:
name|DS
argument_list|(
name|ds
argument_list|)
operator|,
name|Range
argument_list|(
name|ds
operator|.
name|getSourceRange
argument_list|()
argument_list|)
operator|,
name|Context
argument_list|(
name|C
argument_list|)
operator|,
name|InvalidType
argument_list|(
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
argument_list|)
operator|,
name|GroupingParens
argument_list|(
name|false
argument_list|)
operator|,
name|AttrList
argument_list|(
literal|0
argument_list|)
operator|,
name|AsmLabel
argument_list|(
literal|0
argument_list|)
operator|,
name|InlineParamsUsed
argument_list|(
name|false
argument_list|)
operator|,
name|Extension
argument_list|(
argument|false
argument_list|)
block|{   }
operator|~
name|Declarator
argument_list|()
block|{
name|clear
argument_list|()
block|;   }
comment|/// getDeclSpec - Return the declaration-specifier that this declarator was
comment|/// declared with.
specifier|const
name|DeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|DS
return|;
block|}
comment|/// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This
comment|/// should be used with extreme care: declspecs can often be shared between
comment|/// multiple declarators, so mutating the DeclSpec affects all of the
comment|/// Declarators.  This should only be done when the declspec is known to not
comment|/// be shared or when in error recovery etc.
name|DeclSpec
modifier|&
name|getMutableDeclSpec
parameter_list|()
block|{
return|return
name|const_cast
operator|<
name|DeclSpec
operator|&
operator|>
operator|(
name|DS
operator|)
return|;
block|}
comment|/// getCXXScopeSpec - Return the C++ scope specifier (global scope or
comment|/// nested-name-specifier) that is part of the declarator-id.
specifier|const
name|CXXScopeSpec
operator|&
name|getCXXScopeSpec
argument_list|()
specifier|const
block|{
return|return
name|SS
return|;
block|}
name|CXXScopeSpec
modifier|&
name|getCXXScopeSpec
parameter_list|()
block|{
return|return
name|SS
return|;
block|}
comment|/// \brief Retrieve the name specified by this declarator.
name|UnqualifiedId
modifier|&
name|getName
parameter_list|()
block|{
return|return
name|Name
return|;
block|}
name|TheContext
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// getSourceRange - Get the source range that spans this declarator.
specifier|const
name|SourceRange
operator|&
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|void
name|SetSourceRange
parameter_list|(
name|SourceRange
name|R
parameter_list|)
block|{
name|Range
operator|=
name|R
expr_stmt|;
block|}
comment|/// SetRangeBegin - Set the start of the source range to Loc, unless it's
comment|/// invalid.
name|void
name|SetRangeBegin
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.
name|void
name|SetRangeEnd
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// ExtendWithDeclSpec - Extend the declarator source range to include the
comment|/// given declspec, unless its location is invalid. Adopts the range start if
comment|/// the current range start is invalid.
name|void
name|ExtendWithDeclSpec
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|)
block|{
specifier|const
name|SourceRange
modifier|&
name|SR
init|=
name|DS
operator|.
name|getSourceRange
argument_list|()
decl_stmt|;
if|if
condition|(
name|Range
operator|.
name|getBegin
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|SR
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SR
operator|.
name|getEnd
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|SR
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// clear - Reset the contents of this Declarator.
name|void
name|clear
parameter_list|()
block|{
name|SS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Name
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Range
operator|=
name|DS
operator|.
name|getSourceRange
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|delete
name|AttrList
decl_stmt|;
name|AttrList
operator|=
literal|0
expr_stmt|;
name|AsmLabel
operator|=
literal|0
expr_stmt|;
name|InlineParamsUsed
operator|=
name|false
expr_stmt|;
block|}
comment|/// mayOmitIdentifier - Return true if the identifier is either optional or
comment|/// not allowed.  This is true for typenames, prototypes, and template
comment|/// parameter lists.
name|bool
name|mayOmitIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Context
operator|==
name|TypeNameContext
operator|||
name|Context
operator|==
name|PrototypeContext
operator|||
name|Context
operator|==
name|TemplateParamContext
operator|||
name|Context
operator|==
name|CXXCatchContext
operator|||
name|Context
operator|==
name|BlockLiteralContext
return|;
block|}
comment|/// mayHaveIdentifier - Return true if the identifier is either optional or
comment|/// required.  This is true for normal declarators and prototypes, but not
comment|/// typenames.
name|bool
name|mayHaveIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Context
operator|!=
name|TypeNameContext
operator|&&
name|Context
operator|!=
name|BlockLiteralContext
return|;
block|}
comment|/// mayBeFollowedByCXXDirectInit - Return true if the declarator can be
comment|/// followed by a C++ direct initializer, e.g. "int x(1);".
name|bool
name|mayBeFollowedByCXXDirectInit
argument_list|()
specifier|const
block|{
return|return
operator|!
name|hasGroupingParens
argument_list|()
operator|&&
operator|(
name|Context
operator|==
name|FileContext
operator|||
name|Context
operator|==
name|BlockContext
operator|||
name|Context
operator|==
name|ForContext
operator|)
return|;
block|}
comment|/// isPastIdentifier - Return true if we have parsed beyond the point where
comment|/// the
name|bool
name|isPastIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// hasName - Whether this declarator has a name, which might be an
comment|/// identifier (accessible via getIdentifier()) or some kind of
comment|/// special C++ name (constructor, destructor, etc.).
name|bool
name|hasName
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|getKind
argument_list|()
operator|!=
name|UnqualifiedId
operator|::
name|IK_Identifier
operator|||
name|Name
operator|.
name|Identifier
return|;
block|}
name|IdentifierInfo
operator|*
name|getIdentifier
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Name
operator|.
name|getKind
argument_list|()
operator|==
name|UnqualifiedId
operator|::
name|IK_Identifier
condition|)
return|return
name|Name
operator|.
name|Identifier
return|;
return|return
literal|0
return|;
block|}
name|SourceLocation
name|getIdentifierLoc
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|StartLocation
return|;
block|}
comment|/// \brief Set the name of this declarator to be the given identifier.
name|void
name|SetIdentifier
parameter_list|(
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Name
operator|.
name|setIdentifier
argument_list|(
name|Id
argument_list|,
name|IdLoc
argument_list|)
expr_stmt|;
block|}
comment|/// AddTypeInfo - Add a chunk to this declarator. Also extend the range to
comment|/// EndLoc, which should be the last token of the chunk.
name|void
name|AddTypeInfo
parameter_list|(
specifier|const
name|DeclaratorChunk
modifier|&
name|TI
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|DeclTypeInfo
operator|.
name|push_back
argument_list|(
name|TI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EndLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|EndLoc
argument_list|)
expr_stmt|;
block|}
comment|/// getNumTypeObjects() - Return the number of types applied to this
comment|/// declarator.
name|unsigned
name|getNumTypeObjects
argument_list|()
specifier|const
block|{
return|return
name|DeclTypeInfo
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// Return the specified TypeInfo from this declarator.  TypeInfo #0 is
comment|/// closest to the identifier.
specifier|const
name|DeclaratorChunk
modifier|&
name|getTypeObject
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
name|DeclaratorChunk
modifier|&
name|getTypeObject
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
name|void
name|DropFirstTypeObject
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|DeclTypeInfo
operator|.
name|empty
argument_list|()
operator|&&
literal|"No type chunks to drop."
argument_list|)
expr_stmt|;
name|DeclTypeInfo
operator|.
name|front
argument_list|()
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|erase
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// isFunctionDeclarator - Once this declarator is fully parsed and formed,
comment|/// this method returns true if the identifier is a function declarator.
name|bool
name|isFunctionDeclarator
argument_list|()
specifier|const
block|{
return|return
operator|!
name|DeclTypeInfo
operator|.
name|empty
argument_list|()
operator|&&
name|DeclTypeInfo
index|[
literal|0
index|]
operator|.
name|Kind
operator|==
name|DeclaratorChunk
operator|::
name|Function
return|;
block|}
comment|/// AddAttributes - simply adds the attribute list to the Declarator.
comment|/// These examples both add 3 attributes to "var":
comment|///  short int var __attribute__((aligned(16),common,deprecated));
comment|///  short int x, __attribute__((aligned(16)) var
comment|///                                 __attribute__((common,deprecated));
comment|///
comment|/// Also extends the range of the declarator.
name|void
name|AddAttributes
parameter_list|(
name|AttributeList
modifier|*
name|alist
parameter_list|,
name|SourceLocation
name|LastLoc
parameter_list|)
block|{
name|AttrList
operator|=
name|addAttributeLists
argument_list|(
name|AttrList
argument_list|,
name|alist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LastLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|LastLoc
argument_list|)
expr_stmt|;
block|}
specifier|const
name|AttributeList
operator|*
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|AttrList
return|;
block|}
name|AttributeList
modifier|*
name|getAttributes
parameter_list|()
block|{
return|return
name|AttrList
return|;
block|}
comment|/// hasAttributes - do we contain any attributes?
name|bool
name|hasAttributes
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getAttributes
argument_list|()
operator|||
name|getDeclSpec
argument_list|()
operator|.
name|getAttributes
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumTypeObjects
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getTypeObject
argument_list|(
name|i
argument_list|)
operator|.
name|getAttrs
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|void
name|setAsmLabel
parameter_list|(
name|Expr
modifier|*
name|E
parameter_list|)
block|{
name|AsmLabel
operator|=
name|E
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|Expr
operator|*
name|getAsmLabel
argument_list|()
specifier|const
block|{
return|return
name|AsmLabel
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setExtension
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|Extension
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|getExtension
argument_list|()
specifier|const
block|{
return|return
name|Extension
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setInvalidType
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|InvalidType
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isInvalidType
argument_list|()
specifier|const
block|{
return|return
name|InvalidType
operator|||
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setGroupingParens
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|GroupingParens
operator|=
name|flag
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|hasGroupingParens
argument_list|()
specifier|const
block|{
return|return
name|GroupingParens
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// FieldDeclarator - This little struct is used to capture information about
end_comment

begin_comment
comment|/// structure field declarators, which is basically just a bitfield size.
end_comment

begin_struct
struct|struct
name|FieldDeclarator
block|{
name|Declarator
name|D
decl_stmt|;
name|Expr
modifier|*
name|BitfieldSize
decl_stmt|;
name|explicit
name|FieldDeclarator
argument_list|(
name|DeclSpec
operator|&
name|DS
argument_list|)
operator|:
name|D
argument_list|(
argument|DS
argument_list|,
argument|Declarator::MemberContext
argument_list|)
block|{
name|BitfieldSize
operator|=
literal|0
block|;   }
block|}
struct|;
end_struct

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

