begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the classes used to store parsed information about
end_comment

begin_comment
comment|// declaration-specifiers and declarators.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   static const int volatile x, *y, *(*(*z)[10])(const void *x);
end_comment

begin_comment
comment|//   ------------------------- -  --  ---------------------------
end_comment

begin_comment
comment|//     declaration-specifiers  \  |   /
end_comment

begin_comment
comment|//                            declarators
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_DECLSPEC_H
end_define

begin_include
include|#
directive|include
file|"clang/Sema/AttributeList.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Token.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|class
name|TypeLoc
decl_stmt|;
name|class
name|LangOptions
decl_stmt|;
name|class
name|Diagnostic
decl_stmt|;
name|class
name|IdentifierInfo
decl_stmt|;
name|class
name|NamespaceAliasDecl
decl_stmt|;
name|class
name|NamespaceDecl
decl_stmt|;
name|class
name|NestedNameSpecifier
decl_stmt|;
name|class
name|NestedNameSpecifierLoc
decl_stmt|;
name|class
name|Preprocessor
decl_stmt|;
name|class
name|Declarator
decl_stmt|;
struct_decl|struct
name|TemplateIdAnnotation
struct_decl|;
comment|/// CXXScopeSpec - Represents a C++ nested-name-specifier or a global scope
comment|/// specifier.  These can be in 3 states:
comment|///   1) Not present, identified by isEmpty()
comment|///   2) Present, identified by isNotEmpty()
comment|///      2.a) Valid, idenified by isValid()
comment|///      2.b) Invalid, identified by isInvalid().
comment|///
comment|/// isSet() is deprecated because it mostly corresponded to "valid" but was
comment|/// often used as if it meant "present".
comment|///
comment|/// The actual scope is described by getScopeRep().
name|class
name|CXXScopeSpec
block|{
name|SourceRange
name|Range
decl_stmt|;
name|NestedNameSpecifier
modifier|*
name|ScopeRep
decl_stmt|;
comment|/// \brief Buffer used to store source-location information for the
comment|/// nested-name-specifier.
comment|///
comment|/// Note that we explicitly manage the buffer (rather than using a
comment|/// SmallVector) because \c Declarator expects it to be possible to memcpy()
comment|/// a \c CXXScopeSpec.
name|char
modifier|*
name|Buffer
decl_stmt|;
comment|/// \brief The size of the buffer used to store source-location information
comment|/// for the nested-name-specifier.
name|unsigned
name|BufferSize
decl_stmt|;
comment|/// \brief The capacity of the buffer used to store source-location
comment|/// information for the nested-name-specifier.
name|unsigned
name|BufferCapacity
decl_stmt|;
name|public
label|:
name|CXXScopeSpec
argument_list|()
operator|:
name|Range
argument_list|()
operator|,
name|ScopeRep
argument_list|()
operator|,
name|Buffer
argument_list|(
literal|0
argument_list|)
operator|,
name|BufferSize
argument_list|(
literal|0
argument_list|)
operator|,
name|BufferCapacity
argument_list|(
literal|0
argument_list|)
block|{ }
name|CXXScopeSpec
argument_list|(
specifier|const
name|CXXScopeSpec
operator|&
name|Other
argument_list|)
expr_stmt|;
name|CXXScopeSpec
modifier|&
name|operator
init|=
operator|(
specifier|const
name|CXXScopeSpec
operator|&
name|Other
operator|)
decl_stmt|;
operator|~
name|CXXScopeSpec
argument_list|()
expr_stmt|;
specifier|const
name|SourceRange
operator|&
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|void
name|setRange
parameter_list|(
specifier|const
name|SourceRange
modifier|&
name|R
parameter_list|)
block|{
name|Range
operator|=
name|R
expr_stmt|;
block|}
name|void
name|setBeginLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|setEndLoc
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|SourceLocation
name|getBeginLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getBegin
argument_list|()
return|;
block|}
name|SourceLocation
name|getEndLoc
argument_list|()
specifier|const
block|{
return|return
name|Range
operator|.
name|getEnd
argument_list|()
return|;
block|}
name|NestedNameSpecifier
operator|*
name|getScopeRep
argument_list|()
specifier|const
block|{
return|return
name|ScopeRep
return|;
block|}
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'type::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param TemplateKWLoc The location of the 'template' keyword, if present.
comment|///
comment|/// \param TL The TypeLoc that describes the type preceding the '::'.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|TypeLoc
name|TL
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'identifier::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Identifier The identifier.
comment|///
comment|/// \param IdentifierLoc The location of the identifier.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|IdentifierInfo
modifier|*
name|Identifier
parameter_list|,
name|SourceLocation
name|IdentifierLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'namespace::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Namespace The namespace.
comment|///
comment|/// \param NamespaceLoc The location of the namespace name.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NamespaceDecl
modifier|*
name|Namespace
parameter_list|,
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Extend the current nested-name-specifier by another
comment|/// nested-name-specifier component of the form 'namespace-alias::'.
comment|///
comment|/// \param Context The AST context in which this nested-name-specifier
comment|/// resides.
comment|///
comment|/// \param Alias The namespace alias.
comment|///
comment|/// \param AliasLoc The location of the namespace alias
comment|/// name.
comment|///
comment|/// \param ColonColonLoc The location of the trailing '::'.
name|void
name|Extend
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NamespaceAliasDecl
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Turn this (empty) nested-name-specifier into the global
comment|/// nested-name-specifier '::'.
name|void
name|MakeGlobal
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|SourceLocation
name|ColonColonLoc
parameter_list|)
function_decl|;
comment|/// \brief Make a new nested-name-specifier from incomplete source-location
comment|/// information.
comment|///
comment|/// FIXME: This routine should be used very, very rarely, in cases where we
comment|/// need to synthesize a nested-name-specifier. Most code should instead use
comment|/// \c Adopt() with a proper \c NestedNameSpecifierLoc.
name|void
name|MakeTrivial
parameter_list|(
name|ASTContext
modifier|&
name|Context
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|R
parameter_list|)
function_decl|;
comment|/// \brief Adopt an existing nested-name-specifier (with source-range
comment|/// information).
name|void
name|Adopt
parameter_list|(
name|NestedNameSpecifierLoc
name|Other
parameter_list|)
function_decl|;
comment|/// \brief Retrieve a nested-name-specifier with location information, copied
comment|/// into the given AST context.
comment|///
comment|/// \param Context The context into which this nested-name-specifier will be
comment|/// copied.
name|NestedNameSpecifierLoc
name|getWithLocInContext
argument_list|(
name|ASTContext
operator|&
name|Context
argument_list|)
decl|const
decl_stmt|;
comment|/// No scope specifier.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Range
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// A scope specifier is present, but may be valid or invalid.
name|bool
name|isNotEmpty
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isEmpty
argument_list|()
return|;
block|}
comment|/// An error occured during parsing of the scope specifier.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|ScopeRep
operator|==
literal|0
return|;
block|}
comment|/// A scope specifier is present, and it refers to a real scope.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|isNotEmpty
argument_list|()
operator|&&
name|ScopeRep
operator|!=
literal|0
return|;
block|}
comment|/// \brief Indicate that this nested-name-specifier is invalid.
name|void
name|SetInvalid
parameter_list|(
name|SourceRange
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|R
operator|.
name|isValid
argument_list|()
operator|&&
literal|"Must have a valid source range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Range
operator|.
name|getBegin
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|R
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
name|Range
operator|.
name|setEnd
argument_list|(
name|R
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|ScopeRep
operator|=
literal|0
expr_stmt|;
block|}
comment|/// Deprecated.  Some call sites intend isNotEmpty() while others intend
comment|/// isValid().
name|bool
name|isSet
argument_list|()
specifier|const
block|{
return|return
name|ScopeRep
operator|!=
literal|0
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Range
operator|=
name|SourceRange
argument_list|()
expr_stmt|;
name|ScopeRep
operator|=
literal|0
expr_stmt|;
block|}
comment|/// \brief Retrieve the data associated with the source-location information.
name|char
operator|*
name|location_data
argument_list|()
specifier|const
block|{
return|return
name|Buffer
return|;
block|}
comment|/// \brief Retrieve the size of the data associated with source-location
comment|/// information.
name|unsigned
name|location_size
argument_list|()
specifier|const
block|{
return|return
name|BufferSize
return|;
block|}
block|}
empty_stmt|;
comment|/// DeclSpec - This class captures information about "declaration specifiers",
comment|/// which encompasses storage-class-specifiers, type-specifiers,
comment|/// type-qualifiers, and function-specifiers.
name|class
name|DeclSpec
block|{
name|public
label|:
comment|// storage-class-specifier
comment|// Note: The order of these enumerators is important for diagnostics.
enum|enum
name|SCS
block|{
name|SCS_unspecified
init|=
literal|0
block|,
name|SCS_typedef
block|,
name|SCS_extern
block|,
name|SCS_static
block|,
name|SCS_auto
block|,
name|SCS_register
block|,
name|SCS_private_extern
block|,
name|SCS_mutable
block|}
enum|;
comment|// Import type specifier width enumeration and constants.
typedef|typedef
name|TypeSpecifierWidth
name|TSW
typedef|;
specifier|static
specifier|const
name|TSW
name|TSW_unspecified
init|=
name|clang
operator|::
name|TSW_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_short
init|=
name|clang
operator|::
name|TSW_short
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_long
init|=
name|clang
operator|::
name|TSW_long
decl_stmt|;
specifier|static
specifier|const
name|TSW
name|TSW_longlong
init|=
name|clang
operator|::
name|TSW_longlong
decl_stmt|;
enum|enum
name|TSC
block|{
name|TSC_unspecified
block|,
name|TSC_imaginary
block|,
name|TSC_complex
block|}
enum|;
comment|// Import type specifier sign enumeration and constants.
typedef|typedef
name|TypeSpecifierSign
name|TSS
typedef|;
specifier|static
specifier|const
name|TSS
name|TSS_unspecified
init|=
name|clang
operator|::
name|TSS_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_signed
init|=
name|clang
operator|::
name|TSS_signed
decl_stmt|;
specifier|static
specifier|const
name|TSS
name|TSS_unsigned
init|=
name|clang
operator|::
name|TSS_unsigned
decl_stmt|;
comment|// Import type specifier type enumeration and constants.
typedef|typedef
name|TypeSpecifierType
name|TST
typedef|;
specifier|static
specifier|const
name|TST
name|TST_unspecified
init|=
name|clang
operator|::
name|TST_unspecified
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_void
init|=
name|clang
operator|::
name|TST_void
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char
init|=
name|clang
operator|::
name|TST_char
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_wchar
init|=
name|clang
operator|::
name|TST_wchar
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char16
init|=
name|clang
operator|::
name|TST_char16
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_char32
init|=
name|clang
operator|::
name|TST_char32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_int
init|=
name|clang
operator|::
name|TST_int
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_float
init|=
name|clang
operator|::
name|TST_float
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_double
init|=
name|clang
operator|::
name|TST_double
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_bool
init|=
name|clang
operator|::
name|TST_bool
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal32
init|=
name|clang
operator|::
name|TST_decimal32
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal64
init|=
name|clang
operator|::
name|TST_decimal64
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decimal128
init|=
name|clang
operator|::
name|TST_decimal128
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_enum
init|=
name|clang
operator|::
name|TST_enum
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_union
init|=
name|clang
operator|::
name|TST_union
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_struct
init|=
name|clang
operator|::
name|TST_struct
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_class
init|=
name|clang
operator|::
name|TST_class
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typename
init|=
name|clang
operator|::
name|TST_typename
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofType
init|=
name|clang
operator|::
name|TST_typeofType
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_typeofExpr
init|=
name|clang
operator|::
name|TST_typeofExpr
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_decltype
init|=
name|clang
operator|::
name|TST_decltype
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_auto
init|=
name|clang
operator|::
name|TST_auto
decl_stmt|;
specifier|static
specifier|const
name|TST
name|TST_error
init|=
name|clang
operator|::
name|TST_error
decl_stmt|;
comment|// type-qualifiers
enum|enum
name|TQ
block|{
comment|// NOTE: These flags must be kept in sync with Qualifiers::TQ.
name|TQ_unspecified
init|=
literal|0
block|,
name|TQ_const
init|=
literal|1
block|,
name|TQ_restrict
init|=
literal|2
block|,
name|TQ_volatile
init|=
literal|4
block|}
enum|;
comment|/// ParsedSpecifiers - Flags to query which specifiers were applied.  This is
comment|/// returned by getParsedSpecifiers.
enum|enum
name|ParsedSpecifiers
block|{
name|PQ_None
init|=
literal|0
block|,
name|PQ_StorageClassSpecifier
init|=
literal|1
block|,
name|PQ_TypeSpecifier
init|=
literal|2
block|,
name|PQ_TypeQualifier
init|=
literal|4
block|,
name|PQ_FunctionSpecifier
init|=
literal|8
block|}
enum|;
name|private
label|:
comment|// storage-class-specifier
comment|/*SCS*/
name|unsigned
name|StorageClassSpec
range|:
literal|3
decl_stmt|;
name|unsigned
name|SCS_thread_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|SCS_extern_in_linkage_spec
range|:
literal|1
decl_stmt|;
comment|// type-specifier
comment|/*TSW*/
name|unsigned
name|TypeSpecWidth
range|:
literal|2
decl_stmt|;
comment|/*TSC*/
name|unsigned
name|TypeSpecComplex
range|:
literal|2
decl_stmt|;
comment|/*TSS*/
name|unsigned
name|TypeSpecSign
range|:
literal|2
decl_stmt|;
comment|/*TST*/
name|unsigned
name|TypeSpecType
range|:
literal|5
decl_stmt|;
name|unsigned
name|TypeAltiVecVector
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeAltiVecPixel
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeAltiVecBool
range|:
literal|1
decl_stmt|;
name|unsigned
name|TypeSpecOwned
range|:
literal|1
decl_stmt|;
comment|// type-qualifiers
name|unsigned
name|TypeQualifiers
range|:
literal|3
decl_stmt|;
comment|// Bitwise OR of TQ.
comment|// function-specifier
name|unsigned
name|FS_inline_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_virtual_specified
range|:
literal|1
decl_stmt|;
name|unsigned
name|FS_explicit_specified
range|:
literal|1
decl_stmt|;
comment|// friend-specifier
name|unsigned
name|Friend_specified
range|:
literal|1
decl_stmt|;
comment|// constexpr-specifier
name|unsigned
name|Constexpr_specified
range|:
literal|1
decl_stmt|;
comment|/*SCS*/
name|unsigned
name|StorageClassSpecAsWritten
range|:
literal|3
decl_stmt|;
union|union
block|{
name|UnionParsedType
name|TypeRep
decl_stmt|;
name|Decl
modifier|*
name|DeclRep
decl_stmt|;
name|Expr
modifier|*
name|ExprRep
decl_stmt|;
block|}
union|;
comment|// attributes.
name|ParsedAttributes
name|Attrs
decl_stmt|;
comment|// Scope specifier for the type spec, if applicable.
name|CXXScopeSpec
name|TypeScope
decl_stmt|;
comment|// List of protocol qualifiers for objective-c classes.  Used for
comment|// protocol-qualified interfaces "NString<foo>" and protocol-qualified id
comment|// "id<foo>".
name|Decl
modifier|*
specifier|const
modifier|*
name|ProtocolQualifiers
decl_stmt|;
name|unsigned
name|NumProtocolQualifiers
decl_stmt|;
name|SourceLocation
name|ProtocolLAngleLoc
decl_stmt|;
name|SourceLocation
modifier|*
name|ProtocolLocs
decl_stmt|;
comment|// SourceLocation info.  These are null if the item wasn't specified or if
comment|// the setting was synthesized.
name|SourceRange
name|Range
decl_stmt|;
name|SourceLocation
name|StorageClassSpecLoc
decl_stmt|,
name|SCS_threadLoc
decl_stmt|;
name|SourceLocation
name|TSWLoc
decl_stmt|,
name|TSCLoc
decl_stmt|,
name|TSSLoc
decl_stmt|,
name|TSTLoc
decl_stmt|,
name|AltiVecLoc
decl_stmt|;
name|SourceRange
name|TypeofParensRange
decl_stmt|;
name|SourceLocation
name|TQ_constLoc
decl_stmt|,
name|TQ_restrictLoc
decl_stmt|,
name|TQ_volatileLoc
decl_stmt|;
name|SourceLocation
name|FS_inlineLoc
decl_stmt|,
name|FS_virtualLoc
decl_stmt|,
name|FS_explicitLoc
decl_stmt|;
name|SourceLocation
name|FriendLoc
decl_stmt|,
name|ConstexprLoc
decl_stmt|;
name|WrittenBuiltinSpecs
name|writtenBS
decl_stmt|;
name|void
name|SaveWrittenBuiltinSpecs
parameter_list|()
function_decl|;
name|void
name|SaveStorageSpecifierAsWritten
parameter_list|()
function_decl|;
specifier|static
name|bool
name|isTypeRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typename
operator|||
name|T
operator|==
name|TST_typeofType
operator|)
return|;
block|}
specifier|static
name|bool
name|isExprRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_typeofExpr
operator|||
name|T
operator|==
name|TST_decltype
operator|)
return|;
block|}
specifier|static
name|bool
name|isDeclRep
parameter_list|(
name|TST
name|T
parameter_list|)
block|{
return|return
operator|(
name|T
operator|==
name|TST_enum
operator|||
name|T
operator|==
name|TST_struct
operator|||
name|T
operator|==
name|TST_union
operator|||
name|T
operator|==
name|TST_class
operator|)
return|;
block|}
name|DeclSpec
argument_list|(
specifier|const
name|DeclSpec
operator|&
argument_list|)
expr_stmt|;
comment|// DO NOT IMPLEMENT
name|void
name|operator
init|=
operator|(
specifier|const
name|DeclSpec
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
name|DeclSpec
argument_list|()
operator|:
name|StorageClassSpec
argument_list|(
name|SCS_unspecified
argument_list|)
operator|,
name|SCS_thread_specified
argument_list|(
name|false
argument_list|)
operator|,
name|SCS_extern_in_linkage_spec
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecWidth
argument_list|(
name|TSW_unspecified
argument_list|)
operator|,
name|TypeSpecComplex
argument_list|(
name|TSC_unspecified
argument_list|)
operator|,
name|TypeSpecSign
argument_list|(
name|TSS_unspecified
argument_list|)
operator|,
name|TypeSpecType
argument_list|(
name|TST_unspecified
argument_list|)
operator|,
name|TypeAltiVecVector
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecPixel
argument_list|(
name|false
argument_list|)
operator|,
name|TypeAltiVecBool
argument_list|(
name|false
argument_list|)
operator|,
name|TypeSpecOwned
argument_list|(
name|false
argument_list|)
operator|,
name|TypeQualifiers
argument_list|(
name|TSS_unspecified
argument_list|)
operator|,
name|FS_inline_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_virtual_specified
argument_list|(
name|false
argument_list|)
operator|,
name|FS_explicit_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Friend_specified
argument_list|(
name|false
argument_list|)
operator|,
name|Constexpr_specified
argument_list|(
name|false
argument_list|)
operator|,
name|StorageClassSpecAsWritten
argument_list|(
name|SCS_unspecified
argument_list|)
operator|,
name|ProtocolQualifiers
argument_list|(
literal|0
argument_list|)
operator|,
name|NumProtocolQualifiers
argument_list|(
literal|0
argument_list|)
operator|,
name|ProtocolLocs
argument_list|(
literal|0
argument_list|)
operator|,
name|writtenBS
argument_list|()
block|{   }
operator|~
name|DeclSpec
argument_list|()
block|{
name|delete
index|[]
name|ProtocolQualifiers
block|;
name|delete
index|[]
name|ProtocolLocs
block|;   }
comment|// storage-class-specifier
name|SCS
name|getStorageClassSpec
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SCS
operator|)
name|StorageClassSpec
return|;
block|}
name|bool
name|isThreadSpecified
argument_list|()
specifier|const
block|{
return|return
name|SCS_thread_specified
return|;
block|}
name|bool
name|isExternInLinkageSpec
argument_list|()
specifier|const
block|{
return|return
name|SCS_extern_in_linkage_spec
return|;
block|}
name|void
name|setExternInLinkageSpec
parameter_list|(
name|bool
name|Value
parameter_list|)
block|{
name|SCS_extern_in_linkage_spec
operator|=
name|Value
expr_stmt|;
block|}
name|SourceLocation
name|getStorageClassSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|StorageClassSpecLoc
return|;
block|}
name|SourceLocation
name|getThreadSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|SCS_threadLoc
return|;
block|}
name|void
name|ClearStorageClassSpecs
parameter_list|()
block|{
name|StorageClassSpec
operator|=
name|DeclSpec
operator|::
name|SCS_unspecified
expr_stmt|;
name|SCS_thread_specified
operator|=
name|false
expr_stmt|;
name|SCS_extern_in_linkage_spec
operator|=
name|false
expr_stmt|;
name|StorageClassSpecLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|SCS_threadLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|// type-specifier
name|TSW
name|getTypeSpecWidth
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSW
operator|)
name|TypeSpecWidth
return|;
block|}
name|TSC
name|getTypeSpecComplex
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSC
operator|)
name|TypeSpecComplex
return|;
block|}
name|TSS
name|getTypeSpecSign
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TSS
operator|)
name|TypeSpecSign
return|;
block|}
name|TST
name|getTypeSpecType
argument_list|()
specifier|const
block|{
return|return
operator|(
name|TST
operator|)
name|TypeSpecType
return|;
block|}
name|bool
name|isTypeAltiVecVector
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecVector
return|;
block|}
name|bool
name|isTypeAltiVecPixel
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecPixel
return|;
block|}
name|bool
name|isTypeAltiVecBool
argument_list|()
specifier|const
block|{
return|return
name|TypeAltiVecBool
return|;
block|}
name|bool
name|isTypeSpecOwned
argument_list|()
specifier|const
block|{
return|return
name|TypeSpecOwned
return|;
block|}
name|ParsedType
name|getRepAsType
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a type"
argument_list|)
block|;
return|return
name|TypeRep
return|;
block|}
name|Decl
operator|*
name|getRepAsDecl
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store a decl"
argument_list|)
block|;
return|return
name|DeclRep
return|;
block|}
name|Expr
operator|*
name|getRepAsExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
operator|&&
literal|"DeclSpec does not store an expr"
argument_list|)
block|;
return|return
name|ExprRep
return|;
block|}
name|CXXScopeSpec
modifier|&
name|getTypeSpecScope
parameter_list|()
block|{
return|return
name|TypeScope
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|getTypeSpecScope
argument_list|()
specifier|const
block|{
return|return
name|TypeScope
return|;
block|}
specifier|const
name|SourceRange
operator|&
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|SourceLocation
name|getTypeSpecWidthLoc
argument_list|()
specifier|const
block|{
return|return
name|TSWLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecComplexLoc
argument_list|()
specifier|const
block|{
return|return
name|TSCLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecSignLoc
argument_list|()
specifier|const
block|{
return|return
name|TSSLoc
return|;
block|}
name|SourceLocation
name|getTypeSpecTypeLoc
argument_list|()
specifier|const
block|{
return|return
name|TSTLoc
return|;
block|}
name|SourceLocation
name|getAltiVecLoc
argument_list|()
specifier|const
block|{
return|return
name|AltiVecLoc
return|;
block|}
name|SourceRange
name|getTypeofParensRange
argument_list|()
specifier|const
block|{
return|return
name|TypeofParensRange
return|;
block|}
name|void
name|setTypeofParensRange
parameter_list|(
name|SourceRange
name|range
parameter_list|)
block|{
name|TypeofParensRange
operator|=
name|range
expr_stmt|;
block|}
comment|/// getSpecifierName - Turn a type-specifier-type into a string like "_Bool"
comment|/// or "union".
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TST
name|T
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TQ
name|Q
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSS
name|S
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSC
name|C
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|TSW
name|W
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
argument_list|(
name|DeclSpec
operator|::
name|SCS
name|S
argument_list|)
decl_stmt|;
comment|// type-qualifiers
comment|/// getTypeQualifiers - Return a set of TQs.
name|unsigned
name|getTypeQualifiers
argument_list|()
specifier|const
block|{
return|return
name|TypeQualifiers
return|;
block|}
name|SourceLocation
name|getConstSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_constLoc
return|;
block|}
name|SourceLocation
name|getRestrictSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_restrictLoc
return|;
block|}
name|SourceLocation
name|getVolatileSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|TQ_volatileLoc
return|;
block|}
comment|// function-specifier
name|bool
name|isInlineSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_inline_specified
return|;
block|}
name|SourceLocation
name|getInlineSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_inlineLoc
return|;
block|}
name|bool
name|isVirtualSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_virtual_specified
return|;
block|}
name|SourceLocation
name|getVirtualSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_virtualLoc
return|;
block|}
name|bool
name|isExplicitSpecified
argument_list|()
specifier|const
block|{
return|return
name|FS_explicit_specified
return|;
block|}
name|SourceLocation
name|getExplicitSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FS_explicitLoc
return|;
block|}
name|void
name|ClearFunctionSpecs
parameter_list|()
block|{
name|FS_inline_specified
operator|=
name|false
expr_stmt|;
name|FS_inlineLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_virtual_specified
operator|=
name|false
expr_stmt|;
name|FS_virtualLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|FS_explicit_specified
operator|=
name|false
expr_stmt|;
name|FS_explicitLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
block|}
comment|/// hasTypeSpecifier - Return true if any type-specifier has been found.
name|bool
name|hasTypeSpecifier
argument_list|()
specifier|const
block|{
return|return
name|getTypeSpecType
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TST_unspecified
operator|||
name|getTypeSpecWidth
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSW_unspecified
operator|||
name|getTypeSpecComplex
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSC_unspecified
operator|||
name|getTypeSpecSign
argument_list|()
operator|!=
name|DeclSpec
operator|::
name|TSS_unspecified
return|;
block|}
comment|/// getParsedSpecifiers - Return a bitmask of which flavors of specifiers this
comment|/// DeclSpec includes.
comment|///
name|unsigned
name|getParsedSpecifiers
argument_list|()
specifier|const
expr_stmt|;
name|SCS
name|getStorageClassSpecAsWritten
argument_list|()
specifier|const
block|{
return|return
operator|(
name|SCS
operator|)
name|StorageClassSpecAsWritten
return|;
block|}
comment|/// isEmpty - Return true if this declaration specifier is completely empty:
comment|/// no tokens were parsed in the production of it.
name|bool
name|isEmpty
argument_list|()
specifier|const
block|{
return|return
name|getParsedSpecifiers
argument_list|()
operator|==
name|DeclSpec
operator|::
name|PQ_None
return|;
block|}
name|void
name|SetRangeStart
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
name|void
name|SetRangeEnd
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
block|{
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// These methods set the specified attribute of the DeclSpec and
comment|/// return false if there was no error.  If an error occurs (for
comment|/// example, if we tried to set "auto" on a spec with "extern"
comment|/// already set), they return true and set PrevSpec and DiagID
comment|/// such that
comment|///   Diag(Loc, DiagID)<< PrevSpec;
comment|/// will yield a useful result.
comment|///
comment|/// TODO: use a more general approach that still allows these
comment|/// diagnostics to be ignored when desired.
name|bool
name|SetStorageClassSpec
parameter_list|(
name|SCS
name|S
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|Lang
parameter_list|)
function_decl|;
name|bool
name|SetStorageClassSpecThread
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecWidth
parameter_list|(
name|TSW
name|W
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecComplex
parameter_list|(
name|TSC
name|C
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecSign
parameter_list|(
name|TSS
name|S
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|ParsedType
name|Rep
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Decl
modifier|*
name|Rep
parameter_list|,
name|bool
name|Owned
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecType
parameter_list|(
name|TST
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|Expr
modifier|*
name|Rep
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecVector
parameter_list|(
name|bool
name|isAltiVecVector
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeAltiVecPixel
parameter_list|(
name|bool
name|isAltiVecPixel
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetTypeSpecError
parameter_list|()
function_decl|;
name|void
name|UpdateDeclRep
parameter_list|(
name|Decl
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isDeclRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|DeclRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateTypeRep
parameter_list|(
name|ParsedType
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isTypeRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|TypeRep
operator|=
name|Rep
expr_stmt|;
block|}
name|void
name|UpdateExprRep
parameter_list|(
name|Expr
modifier|*
name|Rep
parameter_list|)
block|{
name|assert
argument_list|(
name|isExprRep
argument_list|(
operator|(
name|TST
operator|)
name|TypeSpecType
argument_list|)
argument_list|)
expr_stmt|;
name|ExprRep
operator|=
name|Rep
expr_stmt|;
block|}
name|bool
name|SetTypeQual
parameter_list|(
name|TQ
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|Lang
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecInline
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecVirtual
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFunctionSpecExplicit
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetFriendSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|SetConstexprSpec
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|)
function_decl|;
name|bool
name|isFriendSpecified
argument_list|()
specifier|const
block|{
return|return
name|Friend_specified
return|;
block|}
name|SourceLocation
name|getFriendSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|FriendLoc
return|;
block|}
name|bool
name|isConstexprSpecified
argument_list|()
specifier|const
block|{
return|return
name|Constexpr_specified
return|;
block|}
name|SourceLocation
name|getConstexprSpecLoc
argument_list|()
specifier|const
block|{
return|return
name|ConstexprLoc
return|;
block|}
comment|/// AddAttributes - contatenates two attribute lists.
comment|/// The GCC attribute syntax allows for the following:
comment|///
comment|/// short __attribute__(( unused, deprecated ))
comment|/// int __attribute__(( may_alias, aligned(16) )) var;
comment|///
comment|/// This declares 4 attributes using 2 lists. The following syntax is
comment|/// also allowed and equivalent to the previous declaration.
comment|///
comment|/// short __attribute__((unused)) __attribute__((deprecated))
comment|/// int __attribute__((may_alias)) __attribute__((aligned(16))) var;
comment|///
name|void
name|addAttributes
parameter_list|(
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|Attrs
operator|.
name|append
argument_list|(
name|AL
argument_list|)
expr_stmt|;
block|}
name|void
name|aetAttributes
parameter_list|(
name|AttributeList
modifier|*
name|AL
parameter_list|)
block|{
name|Attrs
operator|.
name|set
argument_list|(
name|AL
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasAttributes
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Attrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|ParsedAttributes
modifier|&
name|getAttributes
parameter_list|()
block|{
return|return
name|Attrs
return|;
block|}
specifier|const
name|ParsedAttributes
operator|&
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|Attrs
return|;
block|}
comment|/// TakeAttributes - Return the current attribute list and remove them from
comment|/// the DeclSpec so that it doesn't own them.
name|ParsedAttributes
name|takeAttributes
parameter_list|()
block|{
name|ParsedAttributes
name|saved
init|=
name|Attrs
decl_stmt|;
name|Attrs
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|saved
return|;
block|}
name|void
name|takeAttributesFrom
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|Attrs
operator|.
name|append
argument_list|(
name|attrs
operator|.
name|getList
argument_list|()
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
typedef|typedef
name|Decl
modifier|*
specifier|const
modifier|*
name|ProtocolQualifierListTy
typedef|;
name|ProtocolQualifierListTy
name|getProtocolQualifiers
argument_list|()
specifier|const
block|{
return|return
name|ProtocolQualifiers
return|;
block|}
name|SourceLocation
operator|*
name|getProtocolLocs
argument_list|()
specifier|const
block|{
return|return
name|ProtocolLocs
return|;
block|}
name|unsigned
name|getNumProtocolQualifiers
argument_list|()
specifier|const
block|{
return|return
name|NumProtocolQualifiers
return|;
block|}
name|SourceLocation
name|getProtocolLAngleLoc
argument_list|()
specifier|const
block|{
return|return
name|ProtocolLAngleLoc
return|;
block|}
name|void
name|setProtocolQualifiers
parameter_list|(
name|Decl
modifier|*
specifier|const
modifier|*
name|Protos
parameter_list|,
name|unsigned
name|NP
parameter_list|,
name|SourceLocation
modifier|*
name|ProtoLocs
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|)
function_decl|;
comment|/// Finish - This does final analysis of the declspec, issuing diagnostics for
comment|/// things like "_Imaginary" (lacking an FP type).  After calling this method,
comment|/// DeclSpec is guaranteed self-consistent, even if an error occurred.
name|void
name|Finish
parameter_list|(
name|Diagnostic
modifier|&
name|D
parameter_list|,
name|Preprocessor
modifier|&
name|PP
parameter_list|)
function_decl|;
specifier|const
name|WrittenBuiltinSpecs
operator|&
name|getWrittenBuiltinSpecs
argument_list|()
specifier|const
block|{
return|return
name|writtenBS
return|;
block|}
comment|/// isMissingDeclaratorOk - This checks if this DeclSpec can stand alone,
comment|/// without a Declarator. Only tag declspecs can stand alone.
name|bool
name|isMissingDeclaratorOk
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// ObjCDeclSpec - This class captures information about
comment|/// "declaration specifiers" specific to objective-c
name|class
name|ObjCDeclSpec
block|{
name|public
label|:
comment|/// ObjCDeclQualifier - Qualifier used on types in method declarations
enum|enum
name|ObjCDeclQualifier
block|{
name|DQ_None
init|=
literal|0x0
block|,
name|DQ_In
init|=
literal|0x1
block|,
name|DQ_Inout
init|=
literal|0x2
block|,
name|DQ_Out
init|=
literal|0x4
block|,
name|DQ_Bycopy
init|=
literal|0x8
block|,
name|DQ_Byref
init|=
literal|0x10
block|,
name|DQ_Oneway
init|=
literal|0x20
block|}
enum|;
comment|/// PropertyAttributeKind - list of property attributes.
enum|enum
name|ObjCPropertyAttributeKind
block|{
name|DQ_PR_noattr
init|=
literal|0x0
block|,
name|DQ_PR_readonly
init|=
literal|0x01
block|,
name|DQ_PR_getter
init|=
literal|0x02
block|,
name|DQ_PR_assign
init|=
literal|0x04
block|,
name|DQ_PR_readwrite
init|=
literal|0x08
block|,
name|DQ_PR_retain
init|=
literal|0x10
block|,
name|DQ_PR_copy
init|=
literal|0x20
block|,
name|DQ_PR_nonatomic
init|=
literal|0x40
block|,
name|DQ_PR_setter
init|=
literal|0x80
block|,
name|DQ_PR_atomic
init|=
literal|0x100
block|}
enum|;
name|ObjCDeclSpec
argument_list|()
operator|:
name|objcDeclQualifier
argument_list|(
name|DQ_None
argument_list|)
operator|,
name|PropertyAttributes
argument_list|(
name|DQ_PR_noattr
argument_list|)
operator|,
name|GetterName
argument_list|(
literal|0
argument_list|)
operator|,
name|SetterName
argument_list|(
literal|0
argument_list|)
block|{ }
name|ObjCDeclQualifier
name|getObjCDeclQualifier
argument_list|()
specifier|const
block|{
return|return
name|objcDeclQualifier
return|;
block|}
name|void
name|setObjCDeclQualifier
parameter_list|(
name|ObjCDeclQualifier
name|DQVal
parameter_list|)
block|{
name|objcDeclQualifier
operator|=
call|(
name|ObjCDeclQualifier
call|)
argument_list|(
name|objcDeclQualifier
operator||
name|DQVal
argument_list|)
expr_stmt|;
block|}
name|ObjCPropertyAttributeKind
name|getPropertyAttributes
argument_list|()
specifier|const
block|{
return|return
name|ObjCPropertyAttributeKind
argument_list|(
name|PropertyAttributes
argument_list|)
return|;
block|}
name|void
name|setPropertyAttributes
parameter_list|(
name|ObjCPropertyAttributeKind
name|PRVal
parameter_list|)
block|{
name|PropertyAttributes
operator|=
call|(
name|ObjCPropertyAttributeKind
call|)
argument_list|(
name|PropertyAttributes
operator||
name|PRVal
argument_list|)
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getGetterName
argument_list|()
specifier|const
block|{
return|return
name|GetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getGetterName
parameter_list|()
block|{
return|return
name|GetterName
return|;
block|}
name|void
name|setGetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|GetterName
operator|=
name|name
expr_stmt|;
block|}
specifier|const
name|IdentifierInfo
operator|*
name|getSetterName
argument_list|()
specifier|const
block|{
return|return
name|SetterName
return|;
block|}
name|IdentifierInfo
modifier|*
name|getSetterName
parameter_list|()
block|{
return|return
name|SetterName
return|;
block|}
name|void
name|setSetterName
parameter_list|(
name|IdentifierInfo
modifier|*
name|name
parameter_list|)
block|{
name|SetterName
operator|=
name|name
expr_stmt|;
block|}
name|private
label|:
comment|// FIXME: These two are unrelated and mutially exclusive. So perhaps
comment|// we can put them in a union to reflect their mutual exclusiveness
comment|// (space saving is negligible).
name|ObjCDeclQualifier
name|objcDeclQualifier
range|:
literal|6
decl_stmt|;
comment|// NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttributeKind
name|unsigned
name|PropertyAttributes
range|:
literal|9
decl_stmt|;
name|IdentifierInfo
modifier|*
name|GetterName
decl_stmt|;
comment|// getter name of NULL if no getter
name|IdentifierInfo
modifier|*
name|SetterName
decl_stmt|;
comment|// setter name of NULL if no setter
block|}
empty_stmt|;
comment|/// \brief Represents a C++ unqualified-id that has been parsed.
name|class
name|UnqualifiedId
block|{
name|private
label|:
specifier|const
name|UnqualifiedId
modifier|&
name|operator
init|=
operator|(
specifier|const
name|UnqualifiedId
operator|&
operator|)
decl_stmt|;
comment|// DO NOT IMPLEMENT
name|public
label|:
comment|/// \brief Describes the kind of unqualified-id parsed.
enum|enum
name|IdKind
block|{
comment|/// \brief An identifier.
name|IK_Identifier
block|,
comment|/// \brief An overloaded operator name, e.g., operator+.
name|IK_OperatorFunctionId
block|,
comment|/// \brief A conversion function name, e.g., operator int.
name|IK_ConversionFunctionId
block|,
comment|/// \brief A user-defined literal name, e.g., operator "" _i.
name|IK_LiteralOperatorId
block|,
comment|/// \brief A constructor name.
name|IK_ConstructorName
block|,
comment|/// \brief A constructor named via a template-id.
name|IK_ConstructorTemplateId
block|,
comment|/// \brief A destructor name.
name|IK_DestructorName
block|,
comment|/// \brief A template-id, e.g., f<int>.
name|IK_TemplateId
block|}
name|Kind
enum|;
comment|/// \brief Anonymous union that holds extra data associated with the
comment|/// parsed unqualified-id.
union|union
block|{
comment|/// \brief When Kind == IK_Identifier, the parsed identifier, or when Kind
comment|/// == IK_UserLiteralId, the identifier suffix.
name|IdentifierInfo
modifier|*
name|Identifier
decl_stmt|;
comment|/// \brief When Kind == IK_OperatorFunctionId, the overloaded operator
comment|/// that we parsed.
struct|struct
block|{
comment|/// \brief The kind of overloaded operator.
name|OverloadedOperatorKind
name|Operator
decl_stmt|;
comment|/// \brief The source locations of the individual tokens that name
comment|/// the operator, e.g., the "new", "[", and "]" tokens in
comment|/// operator new [].
comment|///
comment|/// Different operators have different numbers of tokens in their name,
comment|/// up to three. Any remaining source locations in this array will be
comment|/// set to an invalid value for operators with fewer than three tokens.
name|unsigned
name|SymbolLocations
index|[
literal|3
index|]
decl_stmt|;
block|}
name|OperatorFunctionId
struct|;
comment|/// \brief When Kind == IK_ConversionFunctionId, the type that the
comment|/// conversion function names.
name|UnionParsedType
name|ConversionFunctionId
decl_stmt|;
comment|/// \brief When Kind == IK_ConstructorName, the class-name of the type
comment|/// whose constructor is being referenced.
name|UnionParsedType
name|ConstructorName
decl_stmt|;
comment|/// \brief When Kind == IK_DestructorName, the type referred to by the
comment|/// class-name.
name|UnionParsedType
name|DestructorName
decl_stmt|;
comment|/// \brief When Kind == IK_TemplateId or IK_ConstructorTemplateId,
comment|/// the template-id annotation that contains the template name and
comment|/// template arguments.
name|TemplateIdAnnotation
modifier|*
name|TemplateId
decl_stmt|;
block|}
union|;
comment|/// \brief The location of the first token that describes this unqualified-id,
comment|/// which will be the location of the identifier, "operator" keyword,
comment|/// tilde (for a destructor), or the template name of a template-id.
name|SourceLocation
name|StartLocation
decl_stmt|;
comment|/// \brief The location of the last token that describes this unqualified-id.
name|SourceLocation
name|EndLocation
decl_stmt|;
name|UnqualifiedId
argument_list|()
operator|:
name|Kind
argument_list|(
name|IK_Identifier
argument_list|)
operator|,
name|Identifier
argument_list|(
literal|0
argument_list|)
block|{ }
comment|/// \brief Do not use this copy constructor. It is temporary, and only
comment|/// exists because we are holding FieldDeclarators in a SmallVector when we
comment|/// don't actually need them.
comment|///
comment|/// FIXME: Kill this copy constructor.
name|UnqualifiedId
argument_list|(
specifier|const
name|UnqualifiedId
operator|&
name|Other
argument_list|)
operator|:
name|Kind
argument_list|(
name|IK_Identifier
argument_list|)
operator|,
name|Identifier
argument_list|(
name|Other
operator|.
name|Identifier
argument_list|)
operator|,
name|StartLocation
argument_list|(
name|Other
operator|.
name|StartLocation
argument_list|)
operator|,
name|EndLocation
argument_list|(
argument|Other.EndLocation
argument_list|)
block|{
name|assert
argument_list|(
name|Other
operator|.
name|Kind
operator|==
name|IK_Identifier
operator|&&
literal|"Cannot copy non-identifiers"
argument_list|)
block|;   }
comment|/// \brief Destroy this unqualified-id.
operator|~
name|UnqualifiedId
argument_list|()
block|{
name|clear
argument_list|()
block|; }
comment|/// \brief Clear out this unqualified-id, setting it to default (invalid)
comment|/// state.
name|void
name|clear
argument_list|()
expr_stmt|;
comment|/// \brief Determine whether this unqualified-id refers to a valid name.
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|StartLocation
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine whether this unqualified-id refers to an invalid name.
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isValid
argument_list|()
return|;
block|}
comment|/// \brief Determine what kind of name we have.
name|IdKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an identifier.
comment|///
comment|/// \param Id the parsed identifier.
comment|/// \param IdLoc the location of the parsed identifier.
name|void
name|setIdentifier
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_Identifier
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as an
comment|/// operator-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Op the overloaded operator.
comment|///
comment|/// \param SymbolLocations the locations of the individual operator symbols
comment|/// in the operator.
name|void
name|setOperatorFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|OverloadedOperatorKind
name|Op
parameter_list|,
name|SourceLocation
name|SymbolLocations
index|[
literal|3
index|]
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// conversion-function-id.
comment|///
comment|/// \param OperatorLoc the location of the 'operator' keyword.
comment|///
comment|/// \param Ty the type to which this conversion function is converting.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConversionFunctionId
parameter_list|(
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConversionFunctionId
expr_stmt|;
name|StartLocation
operator|=
name|OperatorLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConversionFunctionId
operator|=
name|Ty
expr_stmt|;
block|}
comment|/// \brief Specific that this unqualified-id was parsed as a
comment|/// literal-operator-id.
comment|///
comment|/// \param Id the parsed identifier.
comment|///
comment|/// \param OpLoc the location of the 'operator' keyword.
comment|///
comment|/// \param IdLoc the location of the identifier.
name|void
name|setLiteralOperatorId
parameter_list|(
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_LiteralOperatorId
expr_stmt|;
name|Identifier
operator|=
name|const_cast
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|(
name|Id
operator|)
expr_stmt|;
name|StartLocation
operator|=
name|OpLoc
expr_stmt|;
name|EndLocation
operator|=
name|IdLoc
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a constructor name.
comment|///
comment|/// \param ClassType the class type referred to by the constructor name.
comment|///
comment|/// \param ClassNameLoc the location of the class name.
comment|///
comment|/// \param EndLoc the location of the last token that makes up the type name.
name|void
name|setConstructorName
parameter_list|(
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|ClassNameLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_ConstructorName
expr_stmt|;
name|StartLocation
operator|=
name|ClassNameLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|ConstructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a
comment|/// template-id that names a constructor.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setConstructorTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Specify that this unqualified-id was parsed as a destructor name.
comment|///
comment|/// \param TildeLoc the location of the '~' that introduces the destructor
comment|/// name.
comment|///
comment|/// \param ClassType the name of the class referred to by the destructor name.
name|void
name|setDestructorName
parameter_list|(
name|SourceLocation
name|TildeLoc
parameter_list|,
name|ParsedType
name|ClassType
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|Kind
operator|=
name|IK_DestructorName
expr_stmt|;
name|StartLocation
operator|=
name|TildeLoc
expr_stmt|;
name|EndLocation
operator|=
name|EndLoc
expr_stmt|;
name|DestructorName
operator|=
name|ClassType
expr_stmt|;
block|}
comment|/// \brief Specify that this unqualified-id was parsed as a template-id.
comment|///
comment|/// \param TemplateId the template-id annotation that describes the parsed
comment|/// template-id. This UnqualifiedId instance will take ownership of the
comment|/// \p TemplateId and will free it on destruction.
name|void
name|setTemplateId
parameter_list|(
name|TemplateIdAnnotation
modifier|*
name|TemplateId
parameter_list|)
function_decl|;
comment|/// \brief Return the source range that covers this unqualified-id.
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|StartLocation
argument_list|,
name|EndLocation
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|/// CachedTokens - A set of tokens that has been cached for later
comment|/// parsing.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|Token
operator|,
literal|4
operator|>
name|CachedTokens
expr_stmt|;
comment|/// DeclaratorChunk - One instance of this struct is used for each type in a
comment|/// declarator that is parsed.
comment|///
comment|/// This is intended to be a small value object.
struct|struct
name|DeclaratorChunk
block|{
enum|enum
block|{
name|Pointer
block|,
name|Reference
block|,
name|Array
block|,
name|Function
block|,
name|BlockPointer
block|,
name|MemberPointer
block|,
name|Paren
block|}
name|Kind
enum|;
comment|/// Loc - The place where this type was defined.
name|SourceLocation
name|Loc
decl_stmt|;
comment|/// EndLoc - If valid, the place where this chunck ends.
name|SourceLocation
name|EndLoc
decl_stmt|;
struct|struct
name|TypeInfoCommon
block|{
name|AttributeList
modifier|*
name|AttrList
decl_stmt|;
block|}
struct|;
name|struct
name|PointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|/// The location of the const-qualifier, if any.
name|unsigned
name|ConstQualLoc
block|;
comment|/// The location of the volatile-qualifier, if any.
name|unsigned
name|VolatileQualLoc
block|;
comment|/// The location of the restrict-qualifier, if any.
name|unsigned
name|RestrictQualLoc
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
name|struct
name|ReferenceTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifier: restrict. [GNU] C++ extension
name|bool
name|HasRestrict
operator|:
literal|1
block|;
comment|/// True if this is an lvalue reference, false if it's an rvalue reference.
name|bool
name|LValueRef
operator|:
literal|1
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
name|struct
name|ArrayTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers for the array: const/volatile/restrict.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|/// True if this dimension included the 'static' keyword.
name|bool
name|hasStatic
operator|:
literal|1
block|;
comment|/// True if this dimension was [*].  In this case, NumElts is null.
name|bool
name|isStar
operator|:
literal|1
block|;
comment|/// This is the size of the array, or null if [] or [*] was specified.
comment|/// Since the parser is multi-purpose, and we don't want to impose a root
comment|/// expression class on all clients, NumElts is untyped.
name|Expr
operator|*
name|NumElts
block|;
name|void
name|destroy
argument_list|()
block|{}
block|}
decl_stmt|;
comment|/// ParamInfo - An array of paraminfo objects is allocated whenever a function
comment|/// declarator is parsed.  There are two interesting styles of arguments here:
comment|/// K&R-style identifier lists and parameter type lists.  K&R-style identifier
comment|/// lists will have information about the identifier, but no type information.
comment|/// Parameter type lists will have type info (if the actions module provides
comment|/// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.
struct|struct
name|ParamInfo
block|{
name|IdentifierInfo
modifier|*
name|Ident
decl_stmt|;
name|SourceLocation
name|IdentLoc
decl_stmt|;
name|Decl
modifier|*
name|Param
decl_stmt|;
comment|/// DefaultArgTokens - When the parameter's default argument
comment|/// cannot be parsed immediately (because it occurs within the
comment|/// declaration of a member function), it will be stored here as a
comment|/// sequence of tokens to be parsed once the class definition is
comment|/// complete. Non-NULL indicates that there is a default argument.
name|CachedTokens
modifier|*
name|DefaultArgTokens
decl_stmt|;
name|ParamInfo
argument_list|()
block|{}
name|ParamInfo
argument_list|(
argument|IdentifierInfo *ident
argument_list|,
argument|SourceLocation iloc
argument_list|,
argument|Decl *param
argument_list|,
argument|CachedTokens *DefArgTokens =
literal|0
argument_list|)
block|:
name|Ident
argument_list|(
name|ident
argument_list|)
operator|,
name|IdentLoc
argument_list|(
name|iloc
argument_list|)
operator|,
name|Param
argument_list|(
name|param
argument_list|)
operator|,
name|DefaultArgTokens
argument_list|(
argument|DefArgTokens
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|TypeAndRange
block|{
name|ParsedType
name|Ty
decl_stmt|;
name|SourceRange
name|Range
decl_stmt|;
block|}
struct|;
name|struct
name|FunctionTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// hasPrototype - This is true if the function had at least one typed
comment|/// argument.  If the function is () or (a,b,c), then it has no prototype,
comment|/// and is treated as a K&R-style function.
name|unsigned
name|hasPrototype
operator|:
literal|1
block|;
comment|/// isVariadic - If this function has a prototype, and if that
comment|/// proto ends with ',...)', this is true. When true, EllipsisLoc
comment|/// contains the location of the ellipsis.
name|unsigned
name|isVariadic
operator|:
literal|1
block|;
comment|/// \brief Whether the ref-qualifier (if any) is an lvalue reference.
comment|/// Otherwise, it's an rvalue reference.
name|unsigned
name|RefQualifierIsLValueRef
operator|:
literal|1
block|;
comment|/// The type qualifiers: const/volatile/restrict.
comment|/// The qualifier bitmask values are the same as in QualType.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|/// hasExceptionSpec - True if the function has an exception specification.
name|unsigned
name|hasExceptionSpec
operator|:
literal|1
block|;
comment|/// hasAnyExceptionSpec - True if the function has a throw(...) specifier.
name|unsigned
name|hasAnyExceptionSpec
operator|:
literal|1
block|;
comment|/// DeleteArgInfo - If this is true, we need to delete[] ArgInfo.
name|unsigned
name|DeleteArgInfo
operator|:
literal|1
block|;
comment|/// When isVariadic is true, the location of the ellipsis in the source.
name|unsigned
name|EllipsisLoc
block|;
comment|/// NumArgs - This is the number of formal arguments provided for the
comment|/// declarator.
name|unsigned
name|NumArgs
block|;
comment|/// NumExceptions - This is the number of types in the exception-decl, if
comment|/// the function has one.
name|unsigned
name|NumExceptions
block|;
comment|/// \brief The location of the ref-qualifier, if any.
comment|///
comment|/// If this is an invalid location, there is no ref-qualifier.
name|unsigned
name|RefQualifierLoc
block|;
comment|/// ThrowLoc - When hasExceptionSpec is true, the location of the throw
comment|/// keyword introducing the spec.
name|unsigned
name|ThrowLoc
block|;
comment|/// ArgInfo - This is a pointer to a new[]'d array of ParamInfo objects that
comment|/// describe the arguments for this function declarator.  This is null if
comment|/// there are no arguments specified.
name|ParamInfo
operator|*
name|ArgInfo
block|;
comment|/// Exceptions - This is a pointer to a new[]'d array of TypeAndRange
comment|/// objects that contain the types in the function's exception
comment|/// specification and their locations.
name|TypeAndRange
operator|*
name|Exceptions
block|;
comment|/// TrailingReturnType - If this isn't null, it's the trailing return type
comment|/// specified. This is actually a ParsedType, but stored as void* to
comment|/// allow union storage.
name|void
operator|*
name|TrailingReturnType
block|;
comment|/// freeArgs - reset the argument list to having zero arguments.  This is
comment|/// used in various places for error recovery.
name|void
name|freeArgs
argument_list|()
block|{
if|if
condition|(
name|DeleteArgInfo
condition|)
block|{
name|delete
index|[]
name|ArgInfo
decl_stmt|;
name|DeleteArgInfo
operator|=
name|false
expr_stmt|;
block|}
name|NumArgs
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|destroy
argument_list|()
block|{
if|if
condition|(
name|DeleteArgInfo
condition|)
name|delete
index|[]
name|ArgInfo
decl_stmt|;
name|delete
index|[]
name|Exceptions
block|;     }
comment|/// isKNRPrototype - Return true if this is a K&R style identifier list,
comment|/// like "void foo(a,b,c)".  In a function definition, this will be followed
comment|/// by the argument type definitions.
name|bool
name|isKNRPrototype
argument_list|()
specifier|const
block|{
return|return
operator|!
name|hasPrototype
operator|&&
name|NumArgs
operator|!=
literal|0
return|;
block|}
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|EllipsisLoc
argument_list|)
return|;
block|}
name|SourceLocation
name|getThrowLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|ThrowLoc
argument_list|)
return|;
block|}
comment|/// \brief Retrieve the location of the ref-qualifier, if any.
name|SourceLocation
name|getRefQualifierLoc
argument_list|()
specifier|const
block|{
return|return
name|SourceLocation
operator|::
name|getFromRawEncoding
argument_list|(
name|RefQualifierLoc
argument_list|)
return|;
block|}
comment|/// \brief Determine whether this function declaration contains a
comment|/// ref-qualifier.
name|bool
name|hasRefQualifier
argument_list|()
specifier|const
block|{
return|return
name|getRefQualifierLoc
argument_list|()
operator|.
name|isValid
argument_list|()
return|;
block|}
block|}
struct|;
name|struct
name|BlockPointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// For now, sema will catch these as invalid.
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
name|void
name|destroy
argument_list|()
block|{     }
block|}
decl_stmt|;
name|struct
name|MemberPointerTypeInfo
range|:
name|TypeInfoCommon
block|{
comment|/// The type qualifiers: const/volatile/restrict.
name|unsigned
name|TypeQuals
operator|:
literal|3
block|;
comment|// CXXScopeSpec has a constructor, so it can't be a direct member.
comment|// So we need some pointer-aligned storage and a bit of trickery.
expr|union
block|{
name|void
operator|*
name|Aligner
block|;
name|char
name|Mem
index|[
sizeof|sizeof
argument_list|(
name|CXXScopeSpec
argument_list|)
index|]
block|;     }
name|ScopeMem
block|;
name|CXXScopeSpec
operator|&
name|Scope
argument_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
specifier|const
name|CXXScopeSpec
operator|&
name|Scope
argument_list|()
specifier|const
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|CXXScopeSpec
operator|*
operator|>
operator|(
name|ScopeMem
operator|.
name|Mem
operator|)
return|;
block|}
name|void
name|destroy
argument_list|()
block|{
name|Scope
argument_list|()
operator|.
operator|~
name|CXXScopeSpec
argument_list|()
block|;     }
expr|}
block|;
expr|union
block|{
name|TypeInfoCommon
name|Common
block|;
name|PointerTypeInfo
name|Ptr
block|;
name|ReferenceTypeInfo
name|Ref
block|;
name|ArrayTypeInfo
name|Arr
block|;
name|FunctionTypeInfo
name|Fun
block|;
name|BlockPointerTypeInfo
name|Cls
block|;
name|MemberPointerTypeInfo
name|Mem
block|;   }
block|;
name|void
name|destroy
argument_list|()
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown decl type!"
argument_list|)
expr_stmt|;
case|case
name|DeclaratorChunk
operator|::
name|Function
case|:
return|return
name|Fun
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Pointer
case|:
return|return
name|Ptr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|BlockPointer
case|:
return|return
name|Cls
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Reference
case|:
return|return
name|Ref
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Array
case|:
return|return
name|Arr
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|MemberPointer
case|:
return|return
name|Mem
operator|.
name|destroy
argument_list|()
return|;
case|case
name|DeclaratorChunk
operator|::
name|Paren
case|:
return|return;
block|}
block|}
comment|/// getAttrs - If there are attributes applied to this declaratorchunk, return
comment|/// them.
specifier|const
name|AttributeList
operator|*
name|getAttrs
argument_list|()
specifier|const
block|{
return|return
name|Common
operator|.
name|AttrList
return|;
block|}
name|AttributeList
operator|*
operator|&
name|getAttrListRef
argument_list|()
block|{
return|return
name|Common
operator|.
name|AttrList
return|;
block|}
comment|/// getPointer - Return a DeclaratorChunk for a pointer.
comment|///
specifier|static
name|DeclaratorChunk
name|getPointer
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|SourceLocation ConstQualLoc
argument_list|,
argument|SourceLocation VolatileQualLoc
argument_list|,
argument|SourceLocation RestrictQualLoc
argument_list|,
argument|const ParsedAttributes&attrs
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Pointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Ptr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Ptr
operator|.
name|ConstQualLoc
operator|=
name|ConstQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|VolatileQualLoc
operator|=
name|VolatileQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|RestrictQualLoc
operator|=
name|RestrictQualLoc
operator|.
name|getRawEncoding
argument_list|()
block|;
name|I
operator|.
name|Ptr
operator|.
name|AttrList
operator|=
name|attrs
operator|.
name|getList
argument_list|()
block|;
return|return
name|I
return|;
block|}
comment|/// getReference - Return a DeclaratorChunk for a reference.
comment|///
specifier|static
name|DeclaratorChunk
name|getReference
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const ParsedAttributes&attrs
argument_list|,
argument|bool lvalue
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Reference
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Ref
operator|.
name|HasRestrict
operator|=
operator|(
name|TypeQuals
operator|&
name|DeclSpec
operator|::
name|TQ_restrict
operator|)
operator|!=
literal|0
block|;
name|I
operator|.
name|Ref
operator|.
name|LValueRef
operator|=
name|lvalue
block|;
name|I
operator|.
name|Ref
operator|.
name|AttrList
operator|=
name|attrs
operator|.
name|getList
argument_list|()
block|;
return|return
name|I
return|;
block|}
comment|/// getArray - Return a DeclaratorChunk for an array.
comment|///
specifier|static
name|DeclaratorChunk
name|getArray
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|const ParsedAttributes&attrs
argument_list|,
argument|bool isStatic
argument_list|,
argument|bool isStar
argument_list|,
argument|Expr *NumElts
argument_list|,
argument|SourceLocation LBLoc
argument_list|,
argument|SourceLocation RBLoc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Array
block|;
name|I
operator|.
name|Loc
operator|=
name|LBLoc
block|;
name|I
operator|.
name|EndLoc
operator|=
name|RBLoc
block|;
name|I
operator|.
name|Arr
operator|.
name|AttrList
operator|=
name|attrs
operator|.
name|getList
argument_list|()
block|;
name|I
operator|.
name|Arr
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Arr
operator|.
name|hasStatic
operator|=
name|isStatic
block|;
name|I
operator|.
name|Arr
operator|.
name|isStar
operator|=
name|isStar
block|;
name|I
operator|.
name|Arr
operator|.
name|NumElts
operator|=
name|NumElts
block|;
return|return
name|I
return|;
block|}
comment|/// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.
comment|/// "TheDeclarator" is the declarator that this will be added to.
specifier|static
name|DeclaratorChunk
name|getFunction
argument_list|(
argument|const ParsedAttributes&attrs
argument_list|,
argument|bool hasProto
argument_list|,
argument|bool isVariadic
argument_list|,
argument|SourceLocation EllipsisLoc
argument_list|,
argument|ParamInfo *ArgInfo
argument_list|,
argument|unsigned NumArgs
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|bool RefQualifierIsLvalueRef
argument_list|,
argument|SourceLocation RefQualifierLoc
argument_list|,
argument|bool hasExceptionSpec
argument_list|,
argument|SourceLocation ThrowLoc
argument_list|,
argument|bool hasAnyExceptionSpec
argument_list|,
argument|ParsedType *Exceptions
argument_list|,
argument|SourceRange *ExceptionRanges
argument_list|,
argument|unsigned NumExceptions
argument_list|,
argument|SourceLocation LPLoc
argument_list|,
argument|SourceLocation RPLoc
argument_list|,
argument|Declarator&TheDeclarator
argument_list|,
argument|ParsedType TrailingReturnType = ParsedType()
argument_list|)
block|;
comment|/// getBlockPointer - Return a DeclaratorChunk for a block.
comment|///
specifier|static
name|DeclaratorChunk
name|getBlockPointer
argument_list|(
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const ParsedAttributes&attrs
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|BlockPointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Cls
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Cls
operator|.
name|AttrList
operator|=
name|attrs
operator|.
name|getList
argument_list|()
block|;
return|return
name|I
return|;
block|}
specifier|static
name|DeclaratorChunk
name|getMemberPointer
argument_list|(
argument|const CXXScopeSpec&SS
argument_list|,
argument|unsigned TypeQuals
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const ParsedAttributes&attrs
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|MemberPointer
block|;
name|I
operator|.
name|Loc
operator|=
name|Loc
block|;
name|I
operator|.
name|Mem
operator|.
name|TypeQuals
operator|=
name|TypeQuals
block|;
name|I
operator|.
name|Mem
operator|.
name|AttrList
operator|=
name|attrs
operator|.
name|getList
argument_list|()
block|;
name|new
argument_list|(
argument|I.Mem.ScopeMem.Mem
argument_list|)
name|CXXScopeSpec
argument_list|(
name|SS
argument_list|)
block|;
return|return
name|I
return|;
block|}
comment|/// getParen - Return a DeclaratorChunk for a paren.
comment|///
specifier|static
name|DeclaratorChunk
name|getParen
argument_list|(
argument|SourceLocation LParenLoc
argument_list|,
argument|SourceLocation RParenLoc
argument_list|)
block|{
name|DeclaratorChunk
name|I
block|;
name|I
operator|.
name|Kind
operator|=
name|Paren
block|;
name|I
operator|.
name|Loc
operator|=
name|LParenLoc
block|;
name|I
operator|.
name|EndLoc
operator|=
name|RParenLoc
block|;
name|I
operator|.
name|Common
operator|.
name|AttrList
operator|=
literal|0
block|;
return|return
name|I
return|;
block|}
expr|}
block|;
comment|/// Declarator - Information about one declarator, including the parsed type
comment|/// information and the identifier.  When the declarator is fully formed, this
comment|/// is turned into the appropriate Decl object.
comment|///
comment|/// Declarators come in two types: normal declarators and abstract declarators.
comment|/// Abstract declarators are used when parsing types, and don't have an
comment|/// identifier.  Normal declarators do have ID's.
comment|///
comment|/// Instances of this class should be a transient object that lives on the
comment|/// stack, not objects that are allocated in large quantities on the heap.
name|class
name|Declarator
block|{
name|public
operator|:
expr|enum
name|TheContext
block|{
name|FileContext
block|,
comment|// File scope declaration.
name|PrototypeContext
block|,
comment|// Within a function prototype.
name|KNRTypeListContext
block|,
comment|// K&R type definition list for formals.
name|TypeNameContext
block|,
comment|// Abstract declarator for types.
name|MemberContext
block|,
comment|// Struct/Union field.
name|BlockContext
block|,
comment|// Declaration within a block in a function.
name|ForContext
block|,
comment|// Declaration within first part of a for loop.
name|ConditionContext
block|,
comment|// Condition declaration in a C++ if/switch/while/for.
name|TemplateParamContext
block|,
comment|// Within a template parameter list.
name|CXXCatchContext
block|,
comment|// C++ catch exception-declaration
name|BlockLiteralContext
block|,
comment|// Block literal declarator.
name|TemplateTypeArgContext
comment|// Template type argument.
block|}
block|;
name|private
operator|:
specifier|const
name|DeclSpec
operator|&
name|DS
block|;
name|CXXScopeSpec
name|SS
block|;
name|UnqualifiedId
name|Name
block|;
name|SourceRange
name|Range
block|;
comment|/// Context - Where we are parsing this declarator.
comment|///
name|TheContext
name|Context
block|;
comment|/// DeclTypeInfo - This holds each type that the declarator includes as it is
comment|/// parsed.  This is pushed from the identifier out, which means that element
comment|/// #0 will be the most closely bound to the identifier, and
comment|/// DeclTypeInfo.back() will be the least closely bound.
name|llvm
operator|::
name|SmallVector
operator|<
name|DeclaratorChunk
block|,
literal|8
operator|>
name|DeclTypeInfo
block|;
comment|/// InvalidType - Set by Sema::GetTypeForDeclarator().
name|bool
name|InvalidType
operator|:
literal|1
block|;
comment|/// GroupingParens - Set by Parser::ParseParenDeclarator().
name|bool
name|GroupingParens
operator|:
literal|1
block|;
comment|/// AttrList - Attributes.
name|AttributeList
operator|*
name|AttrList
block|;
comment|/// AsmLabel - The asm label, if specified.
name|Expr
operator|*
name|AsmLabel
block|;
comment|/// InlineParams - This is a local array used for the first function decl
comment|/// chunk to avoid going to the heap for the common case when we have one
comment|/// function chunk in the declarator.
name|DeclaratorChunk
operator|::
name|ParamInfo
name|InlineParams
index|[
literal|16
index|]
block|;
name|bool
name|InlineParamsUsed
block|;
comment|/// Extension - true if the declaration is preceded by __extension__.
name|bool
name|Extension
operator|:
literal|1
block|;
comment|/// \brief If provided, the source location of the ellipsis used to describe
comment|/// this declarator as a parameter pack.
name|SourceLocation
name|EllipsisLoc
block|;
name|friend
expr|struct
name|DeclaratorChunk
block|;
name|public
operator|:
name|Declarator
argument_list|(
argument|const DeclSpec&ds
argument_list|,
argument|TheContext C
argument_list|)
operator|:
name|DS
argument_list|(
name|ds
argument_list|)
block|,
name|Range
argument_list|(
name|ds
operator|.
name|getSourceRange
argument_list|()
argument_list|)
block|,
name|Context
argument_list|(
name|C
argument_list|)
block|,
name|InvalidType
argument_list|(
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
argument_list|)
block|,
name|GroupingParens
argument_list|(
name|false
argument_list|)
block|,
name|AttrList
argument_list|(
literal|0
argument_list|)
block|,
name|AsmLabel
argument_list|(
literal|0
argument_list|)
block|,
name|InlineParamsUsed
argument_list|(
name|false
argument_list|)
block|,
name|Extension
argument_list|(
argument|false
argument_list|)
block|{   }
operator|~
name|Declarator
argument_list|()
block|{
name|clear
argument_list|()
block|;   }
comment|/// getDeclSpec - Return the declaration-specifier that this declarator was
comment|/// declared with.
specifier|const
name|DeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|DS
return|;
block|}
comment|/// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This
comment|/// should be used with extreme care: declspecs can often be shared between
comment|/// multiple declarators, so mutating the DeclSpec affects all of the
comment|/// Declarators.  This should only be done when the declspec is known to not
comment|/// be shared or when in error recovery etc.
name|DeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
block|{
return|return
name|const_cast
operator|<
name|DeclSpec
operator|&
operator|>
operator|(
name|DS
operator|)
return|;
block|}
comment|/// getCXXScopeSpec - Return the C++ scope specifier (global scope or
comment|/// nested-name-specifier) that is part of the declarator-id.
specifier|const
name|CXXScopeSpec
operator|&
name|getCXXScopeSpec
argument_list|()
specifier|const
block|{
return|return
name|SS
return|;
block|}
name|CXXScopeSpec
operator|&
name|getCXXScopeSpec
argument_list|()
block|{
return|return
name|SS
return|;
block|}
comment|/// \brief Retrieve the name specified by this declarator.
name|UnqualifiedId
operator|&
name|getName
argument_list|()
block|{
return|return
name|Name
return|;
block|}
name|TheContext
name|getContext
argument_list|()
specifier|const
block|{
return|return
name|Context
return|;
block|}
comment|/// getSourceRange - Get the source range that spans this declarator.
specifier|const
name|SourceRange
operator|&
name|getSourceRange
argument_list|()
specifier|const
block|{
return|return
name|Range
return|;
block|}
name|void
name|SetSourceRange
argument_list|(
argument|SourceRange R
argument_list|)
block|{
name|Range
operator|=
name|R
block|; }
comment|/// SetRangeBegin - Set the start of the source range to Loc, unless it's
comment|/// invalid.
name|void
name|SetRangeBegin
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.
name|void
name|SetRangeEnd
argument_list|(
argument|SourceLocation Loc
argument_list|)
block|{
if|if
condition|(
operator|!
name|Loc
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
comment|/// ExtendWithDeclSpec - Extend the declarator source range to include the
comment|/// given declspec, unless its location is invalid. Adopts the range start if
comment|/// the current range start is invalid.
name|void
name|ExtendWithDeclSpec
argument_list|(
argument|const DeclSpec&DS
argument_list|)
block|{
specifier|const
name|SourceRange
operator|&
name|SR
operator|=
name|DS
operator|.
name|getSourceRange
argument_list|()
block|;
if|if
condition|(
name|Range
operator|.
name|getBegin
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setBegin
argument_list|(
name|SR
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SR
operator|.
name|getEnd
argument_list|()
operator|.
name|isInvalid
argument_list|()
condition|)
name|Range
operator|.
name|setEnd
argument_list|(
name|SR
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// clear - Reset the contents of this Declarator.
name|void
name|clear
argument_list|()
block|{
name|SS
operator|.
name|clear
argument_list|()
block|;
name|Name
operator|.
name|clear
argument_list|()
block|;
name|Range
operator|=
name|DS
operator|.
name|getSourceRange
argument_list|()
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|clear
argument_list|()
block|;
name|AttrList
operator|=
literal|0
block|;
name|AsmLabel
operator|=
literal|0
block|;
name|InlineParamsUsed
operator|=
name|false
block|;   }
comment|/// mayOmitIdentifier - Return true if the identifier is either optional or
comment|/// not allowed.  This is true for typenames, prototypes, and template
comment|/// parameter lists.
name|bool
name|mayOmitIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Context
operator|==
name|TypeNameContext
operator|||
name|Context
operator|==
name|PrototypeContext
operator|||
name|Context
operator|==
name|TemplateParamContext
operator|||
name|Context
operator|==
name|CXXCatchContext
operator|||
name|Context
operator|==
name|BlockLiteralContext
operator|||
name|Context
operator|==
name|TemplateTypeArgContext
return|;
block|}
comment|/// mayHaveIdentifier - Return true if the identifier is either optional or
comment|/// required.  This is true for normal declarators and prototypes, but not
comment|/// typenames.
name|bool
name|mayHaveIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Context
operator|!=
name|TypeNameContext
operator|&&
name|Context
operator|!=
name|BlockLiteralContext
operator|&&
name|Context
operator|!=
name|TemplateTypeArgContext
return|;
block|}
comment|/// mayBeFollowedByCXXDirectInit - Return true if the declarator can be
comment|/// followed by a C++ direct initializer, e.g. "int x(1);".
name|bool
name|mayBeFollowedByCXXDirectInit
argument_list|()
specifier|const
block|{
return|return
operator|!
name|hasGroupingParens
argument_list|()
operator|&&
operator|(
name|Context
operator|==
name|FileContext
operator|||
name|Context
operator|==
name|BlockContext
operator|||
name|Context
operator|==
name|ForContext
operator|)
return|;
block|}
comment|/// isPastIdentifier - Return true if we have parsed beyond the point where
comment|/// the
name|bool
name|isPastIdentifier
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|isValid
argument_list|()
return|;
block|}
comment|/// hasName - Whether this declarator has a name, which might be an
comment|/// identifier (accessible via getIdentifier()) or some kind of
comment|/// special C++ name (constructor, destructor, etc.).
name|bool
name|hasName
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|getKind
argument_list|()
operator|!=
name|UnqualifiedId
operator|::
name|IK_Identifier
operator|||
name|Name
operator|.
name|Identifier
return|;
block|}
name|IdentifierInfo
operator|*
name|getIdentifier
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Name
operator|.
name|getKind
argument_list|()
operator|==
name|UnqualifiedId
operator|::
name|IK_Identifier
condition|)
return|return
name|Name
operator|.
name|Identifier
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SourceLocation
name|getIdentifierLoc
argument_list|()
specifier|const
block|{
return|return
name|Name
operator|.
name|StartLocation
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Set the name of this declarator to be the given identifier.
end_comment

begin_function
name|void
name|SetIdentifier
parameter_list|(
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|IdLoc
parameter_list|)
block|{
name|Name
operator|.
name|setIdentifier
argument_list|(
name|Id
argument_list|,
name|IdLoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// AddTypeInfo - Add a chunk to this declarator. Also extend the range to
end_comment

begin_comment
comment|/// EndLoc, which should be the last token of the chunk.
end_comment

begin_function
name|void
name|AddTypeInfo
parameter_list|(
specifier|const
name|DeclaratorChunk
modifier|&
name|TI
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
name|DeclTypeInfo
operator|.
name|push_back
argument_list|(
name|TI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EndLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|EndLoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// AddInnermostTypeInfo - Add a new innermost chunk to this declarator.
end_comment

begin_function
name|void
name|AddInnermostTypeInfo
parameter_list|(
specifier|const
name|DeclaratorChunk
modifier|&
name|TI
parameter_list|)
block|{
name|DeclTypeInfo
operator|.
name|insert
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|,
name|TI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// getNumTypeObjects() - Return the number of types applied to this
end_comment

begin_comment
comment|/// declarator.
end_comment

begin_expr_stmt
name|unsigned
name|getNumTypeObjects
argument_list|()
specifier|const
block|{
return|return
name|DeclTypeInfo
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Return the specified TypeInfo from this declarator.  TypeInfo #0 is
end_comment

begin_comment
comment|/// closest to the identifier.
end_comment

begin_decl_stmt
specifier|const
name|DeclaratorChunk
modifier|&
name|getTypeObject
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
end_decl_stmt

begin_function
name|DeclaratorChunk
modifier|&
name|getTypeObject
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|DeclTypeInfo
operator|.
name|size
argument_list|()
operator|&&
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|DeclTypeInfo
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
name|void
name|DropFirstTypeObject
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|DeclTypeInfo
operator|.
name|empty
argument_list|()
operator|&&
literal|"No type chunks to drop."
argument_list|)
expr_stmt|;
name|DeclTypeInfo
operator|.
name|front
argument_list|()
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|DeclTypeInfo
operator|.
name|erase
argument_list|(
name|DeclTypeInfo
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// isFunctionDeclarator - This method returns true if the declarator
end_comment

begin_comment
comment|/// is a function declarator (looking through parentheses).
end_comment

begin_comment
comment|/// If true is returned, then the reference type parameter idx is
end_comment

begin_comment
comment|/// assigned with the index of the declaration chunk.
end_comment

begin_decl_stmt
name|bool
name|isFunctionDeclarator
argument_list|(
name|unsigned
operator|&
name|idx
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|i_end
init|=
name|DeclTypeInfo
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|i_end
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|DeclTypeInfo
index|[
name|i
index|]
operator|.
name|Kind
condition|)
block|{
case|case
name|DeclaratorChunk
operator|::
name|Function
case|:
name|idx
operator|=
name|i
expr_stmt|;
return|return
name|true
return|;
case|case
name|DeclaratorChunk
operator|::
name|Paren
case|:
continue|continue;
case|case
name|DeclaratorChunk
operator|::
name|Pointer
case|:
case|case
name|DeclaratorChunk
operator|::
name|Reference
case|:
case|case
name|DeclaratorChunk
operator|::
name|Array
case|:
case|case
name|DeclaratorChunk
operator|::
name|BlockPointer
case|:
case|case
name|DeclaratorChunk
operator|::
name|MemberPointer
case|:
return|return
name|false
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Invalid type chunk"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// isFunctionDeclarator - Once this declarator is fully parsed and formed,
end_comment

begin_comment
comment|/// this method returns true if the identifier is a function declarator
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
name|bool
name|isFunctionDeclarator
argument_list|()
specifier|const
block|{
name|unsigned
name|index
block|;
return|return
name|isFunctionDeclarator
argument_list|(
name|index
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getFunctionTypeInfo - Retrieves the function type info object
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|getFunctionTypeInfo
argument_list|()
block|{
name|assert
argument_list|(
name|isFunctionDeclarator
argument_list|()
operator|&&
literal|"Not a function declarator!"
argument_list|)
block|;
name|unsigned
name|index
operator|=
literal|0
block|;
name|isFunctionDeclarator
argument_list|(
name|index
argument_list|)
block|;
return|return
name|DeclTypeInfo
index|[
name|index
index|]
operator|.
name|Fun
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getFunctionTypeInfo - Retrieves the function type info object
end_comment

begin_comment
comment|/// (looking through parentheses).
end_comment

begin_expr_stmt
specifier|const
name|DeclaratorChunk
operator|::
name|FunctionTypeInfo
operator|&
name|getFunctionTypeInfo
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|Declarator
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getFunctionTypeInfo
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// AddAttributes - simply adds the attribute list to the Declarator.
end_comment

begin_comment
comment|/// These examples both add 3 attributes to "var":
end_comment

begin_comment
comment|///  short int var __attribute__((aligned(16),common,deprecated));
end_comment

begin_comment
comment|///  short int x, __attribute__((aligned(16)) var
end_comment

begin_comment
comment|///                                 __attribute__((common,deprecated));
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Also extends the range of the declarator.
end_comment

begin_function
name|void
name|addAttributes
parameter_list|(
name|AttributeList
modifier|*
name|alist
parameter_list|,
name|SourceLocation
name|LastLoc
parameter_list|)
block|{
name|AttrList
operator|=
name|addAttributeLists
argument_list|(
name|AttrList
argument_list|,
name|alist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LastLoc
operator|.
name|isInvalid
argument_list|()
condition|)
name|SetRangeEnd
argument_list|(
name|LastLoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addAttributes
parameter_list|(
specifier|const
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
block|{
name|addAttributes
argument_list|(
name|attrs
operator|.
name|getList
argument_list|()
argument_list|,
name|SourceLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|const
name|AttributeList
operator|*
name|getAttributes
argument_list|()
specifier|const
block|{
return|return
name|AttrList
return|;
block|}
end_expr_stmt

begin_function
name|AttributeList
modifier|*
name|getAttributes
parameter_list|()
block|{
return|return
name|AttrList
return|;
block|}
end_function

begin_function
name|AttributeList
modifier|*
modifier|&
name|getAttrListRef
parameter_list|()
block|{
return|return
name|AttrList
return|;
block|}
end_function

begin_comment
comment|/// hasAttributes - do we contain any attributes?
end_comment

begin_expr_stmt
name|bool
name|hasAttributes
argument_list|()
specifier|const
block|{
if|if
condition|(
name|getAttributes
argument_list|()
operator|||
name|getDeclSpec
argument_list|()
operator|.
name|hasAttributes
argument_list|()
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumTypeObjects
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getTypeObject
argument_list|(
name|i
argument_list|)
operator|.
name|getAttrs
argument_list|()
condition|)
return|return
name|true
return|;
end_for

begin_return
return|return
name|false
return|;
end_return

begin_macro
unit|}    void
name|setAsmLabel
argument_list|(
argument|Expr *E
argument_list|)
end_macro

begin_block
block|{
name|AsmLabel
operator|=
name|E
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|Expr
operator|*
name|getAsmLabel
argument_list|()
specifier|const
block|{
return|return
name|AsmLabel
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setExtension
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|Extension
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|getExtension
argument_list|()
specifier|const
block|{
return|return
name|Extension
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setInvalidType
parameter_list|(
name|bool
name|Val
init|=
name|true
parameter_list|)
block|{
name|InvalidType
operator|=
name|Val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|isInvalidType
argument_list|()
specifier|const
block|{
return|return
name|InvalidType
operator|||
name|DS
operator|.
name|getTypeSpecType
argument_list|()
operator|==
name|DeclSpec
operator|::
name|TST_error
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setGroupingParens
parameter_list|(
name|bool
name|flag
parameter_list|)
block|{
name|GroupingParens
operator|=
name|flag
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|hasGroupingParens
argument_list|()
specifier|const
block|{
return|return
name|GroupingParens
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|hasEllipsis
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
operator|.
name|isValid
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SourceLocation
name|getEllipsisLoc
argument_list|()
specifier|const
block|{
return|return
name|EllipsisLoc
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setEllipsisLoc
parameter_list|(
name|SourceLocation
name|EL
parameter_list|)
block|{
name|EllipsisLoc
operator|=
name|EL
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/// FieldDeclarator - This little struct is used to capture information about
end_comment

begin_comment
comment|/// structure field declarators, which is basically just a bitfield size.
end_comment

begin_struct
struct|struct
name|FieldDeclarator
block|{
name|Declarator
name|D
decl_stmt|;
name|Expr
modifier|*
name|BitfieldSize
decl_stmt|;
name|explicit
name|FieldDeclarator
argument_list|(
name|DeclSpec
operator|&
name|DS
argument_list|)
operator|:
name|D
argument_list|(
argument|DS
argument_list|,
argument|Declarator::MemberContext
argument_list|)
block|{
name|BitfieldSize
operator|=
literal|0
block|;   }
block|}
struct|;
end_struct

begin_comment
comment|/// VirtSpecifiers - Represents a C++0x virt-specifier-seq.
end_comment

begin_decl_stmt
name|class
name|VirtSpecifiers
block|{
name|public
label|:
enum|enum
name|Specifier
block|{
name|VS_None
init|=
literal|0
block|,
name|VS_Override
init|=
literal|1
block|,
name|VS_Final
init|=
literal|2
block|,
name|VS_New
init|=
literal|4
block|}
enum|;
name|VirtSpecifiers
argument_list|()
operator|:
name|Specifiers
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|SetSpecifier
argument_list|(
argument|Specifier VS
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const char *&PrevSpec
argument_list|)
expr_stmt|;
name|bool
name|isOverrideSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|VS_Override
return|;
block|}
name|SourceLocation
name|getOverrideLoc
argument_list|()
specifier|const
block|{
return|return
name|VS_overrideLoc
return|;
block|}
name|bool
name|isFinalSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|VS_Final
return|;
block|}
name|SourceLocation
name|getFinalLoc
argument_list|()
specifier|const
block|{
return|return
name|VS_finalLoc
return|;
block|}
name|bool
name|isNewSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|VS_New
return|;
block|}
name|SourceLocation
name|getNewLoc
argument_list|()
specifier|const
block|{
return|return
name|VS_newLoc
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|Specifiers
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
parameter_list|(
name|Specifier
name|VS
parameter_list|)
function_decl|;
name|private
label|:
name|unsigned
name|Specifiers
decl_stmt|;
name|SourceLocation
name|VS_overrideLoc
decl_stmt|,
name|VS_finalLoc
decl_stmt|,
name|VS_newLoc
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// ClassVirtSpecifiers - Represents a C++0x class-virt-specifier-seq.
end_comment

begin_decl_stmt
name|class
name|ClassVirtSpecifiers
block|{
name|public
label|:
enum|enum
name|Specifier
block|{
name|CVS_None
init|=
literal|0
block|,
name|CVS_Final
init|=
literal|1
block|,
name|CVS_Explicit
init|=
literal|2
block|}
enum|;
name|ClassVirtSpecifiers
argument_list|()
operator|:
name|Specifiers
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|SetSpecifier
argument_list|(
argument|Specifier CVS
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|const char *&PrevSpec
argument_list|)
expr_stmt|;
name|bool
name|isFinalSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|CVS_Final
return|;
block|}
name|SourceLocation
name|getFinalLoc
argument_list|()
specifier|const
block|{
return|return
name|CVS_finalLoc
return|;
block|}
name|bool
name|isExplicitSpecified
argument_list|()
specifier|const
block|{
return|return
name|Specifiers
operator|&
name|CVS_Explicit
return|;
block|}
name|SourceLocation
name|getExplicitLoc
argument_list|()
specifier|const
block|{
return|return
name|CVS_explicitLoc
return|;
block|}
specifier|static
specifier|const
name|char
modifier|*
name|getSpecifierName
parameter_list|(
name|Specifier
name|CVS
parameter_list|)
function_decl|;
name|private
label|:
name|unsigned
name|Specifiers
decl_stmt|;
name|SourceLocation
name|CVS_finalLoc
decl_stmt|,
name|CVS_explicitLoc
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

