begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Ownership.h - Parser ownership helpers -----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file contains classes for managing ownership of Stmt and Expr nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_OWNERSHIP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_OWNERSHIP_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// OpaquePtr
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|CXXCtorInitializer
decl_stmt|;
name|class
name|CXXBaseSpecifier
decl_stmt|;
name|class
name|Decl
decl_stmt|;
name|class
name|Expr
decl_stmt|;
name|class
name|ParsedTemplateArgument
decl_stmt|;
name|class
name|QualType
decl_stmt|;
name|class
name|Stmt
decl_stmt|;
name|class
name|TemplateName
decl_stmt|;
name|class
name|TemplateParameterList
decl_stmt|;
comment|/// \brief Wrapper for void* pointer.
comment|/// \tparam PtrTy Either a pointer type like 'T*' or a type that behaves like
comment|///               a pointer.
comment|///
comment|/// This is a very simple POD type that wraps a pointer that the Parser
comment|/// doesn't know about but that Sema or another client does.  The PtrTy
comment|/// template argument is used to make sure that "Decl" pointers are not
comment|/// compatible with "Type" pointers for example.
name|template
operator|<
name|class
name|PtrTy
operator|>
name|class
name|OpaquePtr
block|{
name|void
operator|*
name|Ptr
operator|=
name|nullptr
block|;
name|explicit
name|OpaquePtr
argument_list|(
name|void
operator|*
name|Ptr
argument_list|)
operator|:
name|Ptr
argument_list|(
argument|Ptr
argument_list|)
block|{}
typedef|typedef
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|PtrTy
operator|>
name|Traits
expr_stmt|;
name|public
operator|:
name|OpaquePtr
argument_list|(
argument|std::nullptr_t = nullptr
argument_list|)
block|{}
specifier|static
name|OpaquePtr
name|make
argument_list|(
argument|PtrTy P
argument_list|)
block|{
name|OpaquePtr
name|OP
block|;
name|OP
operator|.
name|set
argument_list|(
name|P
argument_list|)
block|;
return|return
name|OP
return|;
block|}
comment|/// \brief Returns plain pointer to the entity pointed by this wrapper.
comment|/// \tparam PointeeT Type of pointed entity.
comment|///
comment|/// It is identical to getPtrAs<PointeeT*>.
name|template
operator|<
name|typename
name|PointeeT
operator|>
name|PointeeT
operator|*
name|getPtrTo
argument_list|()
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
comment|/// \brief Returns pointer converted to the specified type.
comment|/// \tparam PtrT Result pointer type.  There must be implicit conversion
comment|///              from PtrTy to PtrT.
comment|///
comment|/// In contrast to getPtrTo, this method allows the return type to be
comment|/// a smart pointer.
name|template
operator|<
name|typename
name|PtrT
operator|>
name|PtrT
name|getPtrAs
argument_list|()
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
name|PtrTy
name|get
argument_list|()
specifier|const
block|{
return|return
name|Traits
operator|::
name|getFromVoidPointer
argument_list|(
name|Ptr
argument_list|)
return|;
block|}
name|void
name|set
parameter_list|(
name|PtrTy
name|P
parameter_list|)
block|{
name|Ptr
operator|=
name|Traits
operator|::
name|getAsVoidPointer
argument_list|(
name|P
argument_list|)
expr_stmt|;
block|}
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Ptr
operator|!=
name|nullptr
return|;
block|}
name|void
operator|*
name|getAsOpaquePtr
argument_list|()
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
specifier|static
name|OpaquePtr
name|getFromOpaquePtr
parameter_list|(
name|void
modifier|*
name|P
parameter_list|)
block|{
return|return
name|OpaquePtr
argument_list|(
name|P
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// UnionOpaquePtr - A version of OpaquePtr suitable for membership
end_comment

begin_comment
comment|/// in a union.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|UnionOpaquePtr
block|{
name|void
operator|*
name|Ptr
block|;
specifier|static
name|UnionOpaquePtr
name|make
argument_list|(
argument|OpaquePtr<T> P
argument_list|)
block|{
name|UnionOpaquePtr
name|OP
operator|=
block|{
name|P
operator|.
name|getAsOpaquePtr
argument_list|()
block|}
block|;
return|return
name|OP
return|;
block|}
name|OpaquePtr
operator|<
name|T
operator|>
name|get
argument_list|()
specifier|const
block|{
return|return
name|OpaquePtr
operator|<
name|T
operator|>
operator|::
name|getFromOpaquePtr
argument_list|(
name|Ptr
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|operator
name|OpaquePtr
operator|<
name|T
operator|>
operator|(
operator|)
specifier|const
block|{
return|return
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|UnionOpaquePtr
modifier|&
name|operator
init|=
operator|(
name|OpaquePtr
operator|<
name|T
operator|>
name|P
operator|)
block|{
name|Ptr
operator|=
name|P
operator|.
name|getAsOpaquePtr
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_macro
unit|}; }  namespace
name|llvm
end_macro

begin_block
block|{
name|template
operator|<
name|class
name|T
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|clang
operator|::
name|OpaquePtr
operator|<
name|T
operator|>
expr|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|clang::OpaquePtr<T> P
argument_list|)
block|{
comment|// FIXME: Doesn't work? return P.getAs< void>();
return|return
name|P
operator|.
name|getAsOpaquePtr
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|clang
operator|::
name|OpaquePtr
operator|<
name|T
operator|>
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|clang
operator|::
name|OpaquePtr
operator|<
name|T
operator|>
operator|::
name|getFromOpaquePtr
argument_list|(
name|P
argument_list|)
return|;
block|}
enum|enum
block|{
name|NumLowBitsAvailable
init|=
literal|0
block|}
enum|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|isPodLike
operator|<
name|clang
operator|::
name|OpaquePtr
operator|<
name|T
operator|>
expr|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|; }
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  namespace
name|clang
end_macro

begin_block
block|{
comment|// Basic
name|class
name|DiagnosticBuilder
decl_stmt|;
comment|// Determines whether the low bit of the result pointer for the
comment|// given UID is always zero. If so, ActionResult will use that bit
comment|// for it's "invalid" flag.
name|template
operator|<
name|class
name|Ptr
operator|>
expr|struct
name|IsResultPtrLowBitFree
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;   }
expr_stmt|;
comment|/// ActionResult - This structure is used while parsing/acting on
comment|/// expressions, stmts, etc.  It encapsulates both the object returned by
comment|/// the action, plus a sense of whether or not it is valid.
comment|/// When CompressInvalid is true, the "invalid" flag will be
comment|/// stored in the low bit of the Val pointer.
name|template
operator|<
name|class
name|PtrTy
operator|,
name|bool
name|CompressInvalid
operator|=
name|IsResultPtrLowBitFree
operator|<
name|PtrTy
operator|>
operator|::
name|value
operator|>
name|class
name|ActionResult
block|{
name|PtrTy
name|Val
block|;
name|bool
name|Invalid
block|;
name|public
operator|:
name|ActionResult
argument_list|(
argument|bool Invalid = false
argument_list|)
operator|:
name|Val
argument_list|(
name|PtrTy
argument_list|()
argument_list|)
block|,
name|Invalid
argument_list|(
argument|Invalid
argument_list|)
block|{}
name|ActionResult
argument_list|(
argument|PtrTy val
argument_list|)
operator|:
name|Val
argument_list|(
name|val
argument_list|)
block|,
name|Invalid
argument_list|(
argument|false
argument_list|)
block|{}
name|ActionResult
argument_list|(
specifier|const
name|DiagnosticBuilder
operator|&
argument_list|)
operator|:
name|Val
argument_list|(
name|PtrTy
argument_list|()
argument_list|)
block|,
name|Invalid
argument_list|(
argument|true
argument_list|)
block|{}
comment|// These two overloads prevent void* -> bool conversions.
name|ActionResult
argument_list|(
specifier|const
name|void
operator|*
argument_list|)
operator|=
name|delete
block|;
name|ActionResult
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|=
name|delete
block|;
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
name|bool
name|isUsable
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Invalid
operator|&&
name|Val
return|;
block|}
name|bool
name|isUnset
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Invalid
operator|&&
operator|!
name|Val
return|;
block|}
name|PtrTy
name|get
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|getAs
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|get
argument_list|()
operator|)
return|;
block|}
name|void
name|set
parameter_list|(
name|PtrTy
name|V
parameter_list|)
block|{
name|Val
operator|=
name|V
expr_stmt|;
block|}
specifier|const
name|ActionResult
modifier|&
name|operator
init|=
operator|(
name|PtrTy
name|RHS
operator|)
block|{
name|Val
operator|=
name|RHS
block|;
name|Invalid
operator|=
name|false
block|;
return|return
operator|*
name|this
return|;
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// This ActionResult partial specialization places the "invalid"
end_comment

begin_comment
comment|// flag into the low bit of the pointer.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|PtrTy
operator|>
name|class
name|ActionResult
operator|<
name|PtrTy
operator|,
name|true
operator|>
block|{
comment|// A pointer whose low bit is 1 if this result is invalid, 0
comment|// otherwise.
name|uintptr_t
name|PtrWithInvalid
block|;
typedef|typedef
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|PtrTy
operator|>
name|PtrTraits
expr_stmt|;
name|public
operator|:
name|ActionResult
argument_list|(
argument|bool Invalid = false
argument_list|)
operator|:
name|PtrWithInvalid
argument_list|(
argument|static_cast<uintptr_t>(Invalid)
argument_list|)
block|{ }
name|ActionResult
argument_list|(
argument|PtrTy V
argument_list|)
block|{
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|V
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;     }
name|ActionResult
argument_list|(
specifier|const
name|DiagnosticBuilder
operator|&
argument_list|)
operator|:
name|PtrWithInvalid
argument_list|(
literal|0x01
argument_list|)
block|{ }
comment|// These two overloads prevent void* -> bool conversions.
name|ActionResult
argument_list|(
specifier|const
name|void
operator|*
argument_list|)
operator|=
name|delete
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ActionResult
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|=
name|delete
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|PtrWithInvalid
operator|&
literal|0x01
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isUsable
argument_list|()
specifier|const
block|{
return|return
name|PtrWithInvalid
operator|>
literal|0x01
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isUnset
argument_list|()
specifier|const
block|{
return|return
name|PtrWithInvalid
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|PtrTy
name|get
argument_list|()
specifier|const
block|{
name|void
operator|*
name|VP
operator|=
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|PtrWithInvalid
operator|&
operator|~
literal|0x01
operator|)
block|;
return|return
name|PtrTraits
operator|::
name|getFromVoidPointer
argument_list|(
name|VP
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|getAs
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|get
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|set
parameter_list|(
name|PtrTy
name|V
parameter_list|)
block|{
name|void
modifier|*
name|VP
init|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|ActionResult
modifier|&
name|operator
init|=
operator|(
name|PtrTy
name|RHS
operator|)
block|{
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|RHS
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|// For types where we can fit a flag in with the pointer, provide
end_comment

begin_comment
comment|// conversions to/from pointer type.
end_comment

begin_function
specifier|static
name|ActionResult
name|getFromOpaquePointer
parameter_list|(
name|void
modifier|*
name|P
parameter_list|)
block|{
name|ActionResult
name|Result
decl_stmt|;
name|Result
operator|.
name|PtrWithInvalid
operator|=
operator|(
name|uintptr_t
operator|)
name|P
expr_stmt|;
return|return
name|Result
return|;
block|}
end_function

begin_expr_stmt
name|void
operator|*
name|getAsOpaquePointer
argument_list|()
specifier|const
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|PtrWithInvalid
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// An opaque type for threading parsed type information through the
end_comment

begin_comment
comment|/// parser.
end_comment

begin_typedef
typedef|typedef
name|OpaquePtr
operator|<
name|QualType
operator|>
name|ParsedType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|UnionOpaquePtr
operator|<
name|QualType
operator|>
name|UnionParsedType
expr_stmt|;
end_typedef

begin_comment
comment|// We can re-use the low bit of expression, statement, base, and
end_comment

begin_comment
comment|// member-initializer pointers for the "invalid" flag of
end_comment

begin_comment
comment|// ActionResult.
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IsResultPtrLowBitFree
operator|<
name|Expr
operator|*
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IsResultPtrLowBitFree
operator|<
name|Stmt
operator|*
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IsResultPtrLowBitFree
operator|<
name|CXXBaseSpecifier
operator|*
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|IsResultPtrLowBitFree
operator|<
name|CXXCtorInitializer
operator|*
operator|>
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|true
block|;   }
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|Expr
operator|*
operator|>
name|ExprResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|Stmt
operator|*
operator|>
name|StmtResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|ParsedType
operator|>
name|TypeResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|CXXBaseSpecifier
operator|*
operator|>
name|BaseResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|CXXCtorInitializer
operator|*
operator|>
name|MemInitResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ActionResult
operator|<
name|Decl
operator|*
operator|>
name|DeclResult
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|OpaquePtr
operator|<
name|TemplateName
operator|>
name|ParsedTemplateTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|UnionOpaquePtr
operator|<
name|TemplateName
operator|>
name|UnionParsedTemplateTy
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MutableArrayRef
operator|<
name|Expr
operator|*
operator|>
name|MultiExprArg
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MutableArrayRef
operator|<
name|Stmt
operator|*
operator|>
name|MultiStmtArg
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MutableArrayRef
operator|<
name|ParsedTemplateArgument
operator|>
name|ASTTemplateArgsPtr
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MutableArrayRef
operator|<
name|ParsedType
operator|>
name|MultiTypeArg
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|MutableArrayRef
operator|<
name|TemplateParameterList
operator|*
operator|>
name|MultiTemplateParamsArg
expr_stmt|;
end_typedef

begin_function
specifier|inline
name|ExprResult
name|ExprError
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|StmtResult
name|StmtError
parameter_list|()
block|{
return|return
name|StmtResult
argument_list|(
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|ExprResult
name|ExprError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|ExprError
argument_list|()
return|;
block|}
end_function

begin_function
specifier|inline
name|StmtResult
name|StmtError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|StmtError
argument_list|()
return|;
block|}
end_function

begin_function
specifier|inline
name|ExprResult
name|ExprEmpty
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|StmtResult
name|StmtEmpty
parameter_list|()
block|{
return|return
name|StmtResult
argument_list|(
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|Expr
modifier|*
name|AssertSuccess
parameter_list|(
name|ExprResult
name|R
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|R
operator|.
name|isInvalid
argument_list|()
operator|&&
literal|"operation was asserted to never fail!"
argument_list|)
expr_stmt|;
return|return
name|R
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
specifier|inline
name|Stmt
modifier|*
name|AssertSuccess
parameter_list|(
name|StmtResult
name|R
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|R
operator|.
name|isInvalid
argument_list|()
operator|&&
literal|"operation was asserted to never fail!"
argument_list|)
expr_stmt|;
return|return
name|R
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

