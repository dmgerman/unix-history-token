begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- IndexSymbol.h - Types and functions for indexing symbols ---------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_INDEX_INDEXSYMBOL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_INDEX_INDEXSYMBOL_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Decl
decl_stmt|;
name|class
name|LangOptions
decl_stmt|;
name|namespace
name|index
block|{
name|enum
name|class
name|SymbolKind
range|:
name|uint8_t
block|{
name|Unknown
block|,
name|Module
block|,
name|Namespace
block|,
name|NamespaceAlias
block|,
name|Macro
block|,
name|Enum
block|,
name|Struct
block|,
name|Class
block|,
name|Protocol
block|,
name|Extension
block|,
name|Union
block|,
name|TypeAlias
block|,
name|Function
block|,
name|Variable
block|,
name|Field
block|,
name|EnumConstant
block|,
name|InstanceMethod
block|,
name|ClassMethod
block|,
name|StaticMethod
block|,
name|InstanceProperty
block|,
name|ClassProperty
block|,
name|StaticProperty
block|,
name|Constructor
block|,
name|Destructor
block|,
name|ConversionFunction
block|,
name|Parameter
block|, }
decl_stmt|;
name|enum
name|class
name|SymbolLanguage
block|{
name|C
operator|,
name|ObjC
operator|,
name|CXX
operator|,
block|}
empty_stmt|;
comment|/// Language specific sub-kinds.
name|enum
name|class
name|SymbolSubKind
block|{
name|None
operator|,
name|CXXCopyConstructor
operator|,
name|CXXMoveConstructor
operator|,
name|AccessorGetter
operator|,
name|AccessorSetter
operator|,
block|}
empty_stmt|;
comment|/// Set of properties that provide additional info about a symbol.
name|enum
name|class
name|SymbolProperty
range|:
name|uint8_t
block|{
name|Generic
operator|=
literal|1
operator|<<
literal|0
block|,
name|TemplatePartialSpecialization
operator|=
literal|1
operator|<<
literal|1
block|,
name|TemplateSpecialization
operator|=
literal|1
operator|<<
literal|2
block|,
name|UnitTest
operator|=
literal|1
operator|<<
literal|3
block|,
name|IBAnnotated
operator|=
literal|1
operator|<<
literal|4
block|,
name|IBOutletCollection
operator|=
literal|1
operator|<<
literal|5
block|,
name|GKInspectable
operator|=
literal|1
operator|<<
literal|6
block|,
name|Local
operator|=
literal|1
operator|<<
literal|7
block|, }
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|SymbolPropertyBitNum
init|=
literal|8
decl_stmt|;
typedef|typedef
name|unsigned
name|SymbolPropertySet
typedef|;
comment|/// Set of roles that are attributed to symbol occurrences.
name|enum
name|class
name|SymbolRole
range|:
name|uint32_t
block|{
name|Declaration
operator|=
literal|1
operator|<<
literal|0
block|,
name|Definition
operator|=
literal|1
operator|<<
literal|1
block|,
name|Reference
operator|=
literal|1
operator|<<
literal|2
block|,
name|Read
operator|=
literal|1
operator|<<
literal|3
block|,
name|Write
operator|=
literal|1
operator|<<
literal|4
block|,
name|Call
operator|=
literal|1
operator|<<
literal|5
block|,
name|Dynamic
operator|=
literal|1
operator|<<
literal|6
block|,
name|AddressOf
operator|=
literal|1
operator|<<
literal|7
block|,
name|Implicit
operator|=
literal|1
operator|<<
literal|8
block|,
comment|// Relation roles.
name|RelationChildOf
operator|=
literal|1
operator|<<
literal|9
block|,
name|RelationBaseOf
operator|=
literal|1
operator|<<
literal|10
block|,
name|RelationOverrideOf
operator|=
literal|1
operator|<<
literal|11
block|,
name|RelationReceivedBy
operator|=
literal|1
operator|<<
literal|12
block|,
name|RelationCalledBy
operator|=
literal|1
operator|<<
literal|13
block|,
name|RelationExtendedBy
operator|=
literal|1
operator|<<
literal|14
block|,
name|RelationAccessorOf
operator|=
literal|1
operator|<<
literal|15
block|,
name|RelationContainedBy
operator|=
literal|1
operator|<<
literal|16
block|,
name|RelationIBTypeOf
operator|=
literal|1
operator|<<
literal|17
block|, }
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|SymbolRoleBitNum
init|=
literal|18
decl_stmt|;
typedef|typedef
name|unsigned
name|SymbolRoleSet
typedef|;
comment|/// Represents a relation to another symbol for a symbol occurrence.
struct|struct
name|SymbolRelation
block|{
name|SymbolRoleSet
name|Roles
decl_stmt|;
specifier|const
name|Decl
modifier|*
name|RelatedSymbol
decl_stmt|;
name|SymbolRelation
argument_list|(
argument|SymbolRoleSet Roles
argument_list|,
argument|const Decl *Sym
argument_list|)
block|:
name|Roles
argument_list|(
name|Roles
argument_list|)
operator|,
name|RelatedSymbol
argument_list|(
argument|Sym
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|SymbolInfo
block|{
name|SymbolKind
name|Kind
decl_stmt|;
name|SymbolSubKind
name|SubKind
decl_stmt|;
name|SymbolPropertySet
name|Properties
decl_stmt|;
name|SymbolLanguage
name|Lang
decl_stmt|;
block|}
struct|;
name|SymbolInfo
name|getSymbolInfo
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
name|bool
name|isFunctionLocalSymbol
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
name|void
name|applyForEachSymbolRole
argument_list|(
name|SymbolRoleSet
name|Roles
argument_list|,
name|llvm
operator|::
name|function_ref
operator|<
name|void
argument_list|(
name|SymbolRole
argument_list|)
operator|>
name|Fn
argument_list|)
decl_stmt|;
name|bool
name|applyForEachSymbolRoleInterruptible
argument_list|(
name|SymbolRoleSet
name|Roles
argument_list|,
name|llvm
operator|::
name|function_ref
operator|<
name|bool
argument_list|(
name|SymbolRole
argument_list|)
operator|>
name|Fn
argument_list|)
decl_stmt|;
name|void
name|printSymbolRoles
parameter_list|(
name|SymbolRoleSet
name|Roles
parameter_list|,
name|raw_ostream
modifier|&
name|OS
parameter_list|)
function_decl|;
comment|/// \returns true if no name was printed, false otherwise.
name|bool
name|printSymbolName
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|,
specifier|const
name|LangOptions
modifier|&
name|LO
parameter_list|,
name|raw_ostream
modifier|&
name|OS
parameter_list|)
function_decl|;
name|StringRef
name|getSymbolKindString
parameter_list|(
name|SymbolKind
name|K
parameter_list|)
function_decl|;
name|StringRef
name|getSymbolSubKindString
parameter_list|(
name|SymbolSubKind
name|K
parameter_list|)
function_decl|;
name|StringRef
name|getSymbolLanguageString
parameter_list|(
name|SymbolLanguage
name|K
parameter_list|)
function_decl|;
name|void
name|applyForEachSymbolProperty
argument_list|(
name|SymbolPropertySet
name|Props
argument_list|,
name|llvm
operator|::
name|function_ref
operator|<
name|void
argument_list|(
name|SymbolProperty
argument_list|)
operator|>
name|Fn
argument_list|)
decl_stmt|;
name|void
name|printSymbolProperties
parameter_list|(
name|SymbolPropertySet
name|Props
parameter_list|,
name|raw_ostream
modifier|&
name|OS
parameter_list|)
function_decl|;
block|}
comment|// namespace index
block|}
end_decl_stmt

begin_comment
comment|// namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

