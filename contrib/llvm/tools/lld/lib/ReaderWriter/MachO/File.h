begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/MachO/File.h ----------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_MACHO_FILE_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_MACHO_FILE_H
end_define

begin_include
include|#
directive|include
file|"Atoms.h"
end_include

begin_include
include|#
directive|include
file|"DebugInfo.h"
end_include

begin_include
include|#
directive|include
file|"MachONormalizedFile.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/SharedLibraryFile.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Simple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Format.h"
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|mach_o
block|{
name|using
name|lld
operator|::
name|mach_o
operator|::
name|normalized
operator|::
name|Section
expr_stmt|;
name|class
name|MachOFile
range|:
name|public
name|SimpleFile
block|{
name|public
operator|:
comment|/// Real file constructor - for on-disk files.
name|MachOFile
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|MachOLinkingContext
operator|*
name|ctx
argument_list|)
operator|:
name|SimpleFile
argument_list|(
name|mb
operator|->
name|getBufferIdentifier
argument_list|()
argument_list|,
name|File
operator|::
name|kindMachObject
argument_list|)
block|,
name|_mb
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|mb
argument_list|)
argument_list|)
block|,
name|_ctx
argument_list|(
argument|ctx
argument_list|)
block|{}
comment|/// Dummy file constructor - for virtual files.
name|MachOFile
argument_list|(
argument|StringRef path
argument_list|)
operator|:
name|SimpleFile
argument_list|(
argument|path
argument_list|,
argument|File::kindMachObject
argument_list|)
block|{}
name|void
name|addDefinedAtom
argument_list|(
argument|StringRef name
argument_list|,
argument|Atom::Scope scope
argument_list|,
argument|DefinedAtom::ContentType type
argument_list|,
argument|DefinedAtom::Merge merge
argument_list|,
argument|uint64_t sectionOffset
argument_list|,
argument|uint64_t contentSize
argument_list|,
argument|bool thumb
argument_list|,
argument|bool noDeadStrip
argument_list|,
argument|bool copyRefs
argument_list|,
argument|const Section *inSection
argument_list|)
block|{
name|assert
argument_list|(
name|sectionOffset
operator|+
name|contentSize
operator|<=
name|inSection
operator|->
name|content
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|content
operator|=
name|inSection
operator|->
name|content
operator|.
name|slice
argument_list|(
name|sectionOffset
argument_list|,
name|contentSize
argument_list|)
block|;
if|if
condition|(
name|copyRefs
condition|)
block|{
comment|// Make a copy of the atom's name and content that is owned by this file.
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
name|content
operator|=
name|content
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DefinedAtom
operator|::
name|Alignment
name|align
argument_list|(
name|inSection
operator|->
name|alignment
argument_list|,
name|sectionOffset
operator|%
name|inSection
operator|->
name|alignment
argument_list|)
expr_stmt|;
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|MachODefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|type
argument_list|,
name|merge
argument_list|,
name|thumb
argument_list|,
name|noDeadStrip
argument_list|,
name|content
argument_list|,
name|align
argument_list|)
block|;
name|addAtomForSection
argument_list|(
name|inSection
argument_list|,
name|atom
argument_list|,
name|sectionOffset
argument_list|)
block|;   }
name|void
name|addDefinedAtomInCustomSection
argument_list|(
argument|StringRef name
argument_list|,
argument|Atom::Scope scope
argument_list|,
argument|DefinedAtom::ContentType type
argument_list|,
argument|DefinedAtom::Merge merge
argument_list|,
argument|bool thumb
argument_list|,
argument|bool noDeadStrip
argument_list|,
argument|uint64_t sectionOffset
argument_list|,
argument|uint64_t contentSize
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|bool copyRefs
argument_list|,
argument|const Section *inSection
argument_list|)
block|{
name|assert
argument_list|(
name|sectionOffset
operator|+
name|contentSize
operator|<=
name|inSection
operator|->
name|content
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|content
operator|=
name|inSection
operator|->
name|content
operator|.
name|slice
argument_list|(
name|sectionOffset
argument_list|,
name|contentSize
argument_list|)
block|;
if|if
condition|(
name|copyRefs
condition|)
block|{
comment|// Make a copy of the atom's name and content that is owned by this file.
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
name|content
operator|=
name|content
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
name|sectionName
operator|=
name|sectionName
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DefinedAtom
operator|::
name|Alignment
name|align
argument_list|(
name|inSection
operator|->
name|alignment
argument_list|,
name|sectionOffset
operator|%
name|inSection
operator|->
name|alignment
argument_list|)
expr_stmt|;
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|MachODefinedCustomSectionAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|type
argument_list|,
name|merge
argument_list|,
name|thumb
argument_list|,
name|noDeadStrip
argument_list|,
name|content
argument_list|,
name|sectionName
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|addAtomForSection
argument_list|(
name|inSection
argument_list|,
name|atom
argument_list|,
name|sectionOffset
argument_list|)
expr_stmt|;
block|}
name|void
name|addZeroFillDefinedAtom
argument_list|(
name|StringRef
name|name
argument_list|,
name|Atom
operator|::
name|Scope
name|scope
argument_list|,
name|uint64_t
name|sectionOffset
argument_list|,
name|uint64_t
name|size
argument_list|,
name|bool
name|noDeadStrip
argument_list|,
name|bool
name|copyRefs
argument_list|,
specifier|const
name|Section
operator|*
name|inSection
argument_list|)
block|{
if|if
condition|(
name|copyRefs
condition|)
block|{
comment|// Make a copy of the atom's name and content that is owned by this file.
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DefinedAtom
operator|::
name|Alignment
name|align
argument_list|(
name|inSection
operator|->
name|alignment
argument_list|,
name|sectionOffset
operator|%
name|inSection
operator|->
name|alignment
argument_list|)
expr_stmt|;
name|DefinedAtom
operator|::
name|ContentType
name|type
operator|=
name|DefinedAtom
operator|::
name|typeUnknown
expr_stmt|;
switch|switch
condition|(
name|inSection
operator|->
name|type
condition|)
block|{
case|case
name|llvm
operator|::
name|MachO
operator|::
name|S_ZEROFILL
case|:
name|type
operator|=
name|DefinedAtom
operator|::
name|typeZeroFill
expr_stmt|;
break|break;
case|case
name|llvm
operator|::
name|MachO
operator|::
name|S_THREAD_LOCAL_ZEROFILL
case|:
name|type
operator|=
name|DefinedAtom
operator|::
name|typeTLVInitialZeroFill
expr_stmt|;
break|break;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unrecognized zero-fill section"
argument_list|)
expr_stmt|;
block|}
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|MachODefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|noDeadStrip
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|addAtomForSection
argument_list|(
name|inSection
argument_list|,
name|atom
argument_list|,
name|sectionOffset
argument_list|)
expr_stmt|;
block|}
name|void
name|addUndefinedAtom
parameter_list|(
name|StringRef
name|name
parameter_list|,
name|bool
name|copyRefs
parameter_list|)
block|{
if|if
condition|(
name|copyRefs
condition|)
block|{
comment|// Make a copy of the atom's name that is owned by this file.
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|SimpleUndefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|addAtom
argument_list|(
operator|*
name|atom
argument_list|)
expr_stmt|;
name|_undefAtoms
index|[
name|name
index|]
operator|=
name|atom
expr_stmt|;
block|}
name|void
name|addTentativeDefAtom
argument_list|(
name|StringRef
name|name
argument_list|,
name|Atom
operator|::
name|Scope
name|scope
argument_list|,
name|uint64_t
name|size
argument_list|,
name|DefinedAtom
operator|::
name|Alignment
name|align
argument_list|,
name|bool
name|copyRefs
argument_list|)
block|{
if|if
condition|(
name|copyRefs
condition|)
block|{
comment|// Make a copy of the atom's name that is owned by this file.
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|MachOTentativeDefAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|addAtom
argument_list|(
operator|*
name|atom
argument_list|)
expr_stmt|;
name|_undefAtoms
index|[
name|name
index|]
operator|=
name|atom
expr_stmt|;
block|}
comment|/// Search this file for an the atom from 'section' that covers
comment|/// 'offsetInSect'.  Returns nullptr is no atom found.
name|MachODefinedAtom
modifier|*
name|findAtomCoveringAddress
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
name|uint64_t
name|offsetInSect
parameter_list|,
name|uint32_t
modifier|*
name|foundOffsetAtom
init|=
name|nullptr
parameter_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|pos
init|=
name|_sectionAtoms
operator|.
name|find
argument_list|(
operator|&
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|_sectionAtoms
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
specifier|const
specifier|auto
modifier|&
name|vec
init|=
name|pos
operator|->
name|second
decl_stmt|;
name|assert
argument_list|(
name|offsetInSect
operator|<
name|section
operator|.
name|content
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Vector of atoms for section are already sorted, so do binary search.
specifier|const
specifier|auto
modifier|&
name|atomPos
init|=
name|std
operator|::
name|lower_bound
argument_list|(
argument|vec.begin()
argument_list|,
argument|vec.end()
argument_list|,
argument|offsetInSect
argument_list|,
argument|[offsetInSect](const SectionOffsetAndAtom&ao,                        uint64_t targetAddr) -> bool {
comment|// Each atom has a start offset of its slice of the
comment|// section's content. This compare function must return true
comment|// iff the atom's range is before the offset being searched for.
argument|uint64_t atomsEndOffset = ao.offset+ao.atom->rawContent().size();           return (atomsEndOffset<= offsetInSect);         }
argument_list|)
decl_stmt|;
if|if
condition|(
name|atomPos
operator|==
name|vec
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
name|foundOffsetAtom
condition|)
operator|*
name|foundOffsetAtom
operator|=
name|offsetInSect
operator|-
name|atomPos
operator|->
name|offset
expr_stmt|;
return|return
name|atomPos
operator|->
name|atom
return|;
block|}
comment|/// Searches this file for an UndefinedAtom named 'name'. Returns
comment|/// nullptr is no such atom found.
specifier|const
name|lld
operator|::
name|Atom
operator|*
name|findUndefAtom
argument_list|(
argument|StringRef name
argument_list|)
block|{
name|auto
name|pos
operator|=
name|_undefAtoms
operator|.
name|find
argument_list|(
name|name
argument_list|)
block|;
if|if
condition|(
name|pos
operator|==
name|_undefAtoms
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|pos
operator|->
name|second
return|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|MachODefinedAtom
operator|*
name|atom
argument_list|)
operator|>
name|DefinedAtomVisitor
expr_stmt|;
end_typedef

begin_function
name|void
name|eachDefinedAtom
parameter_list|(
name|DefinedAtomVisitor
name|vistor
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|sectAndAtoms
operator|:
name|_sectionAtoms
control|)
block|{
for|for
control|(
name|auto
operator|&
name|offAndAtom
operator|:
name|sectAndAtoms
operator|.
name|second
control|)
block|{
name|vistor
argument_list|(
name|offAndAtom
operator|.
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
argument|MachODefinedAtom *atom
argument_list|,
argument|uint64_t offset
argument_list|)
operator|>
name|SectionAtomVisitor
expr_stmt|;
end_typedef

begin_function
name|void
name|eachAtomInSection
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
name|SectionAtomVisitor
name|visitor
parameter_list|)
block|{
name|auto
name|pos
init|=
name|_sectionAtoms
operator|.
name|find
argument_list|(
operator|&
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|_sectionAtoms
operator|.
name|end
argument_list|()
condition|)
return|return;
name|auto
name|vec
init|=
name|pos
operator|->
name|second
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|offAndAtom
operator|:
name|vec
control|)
name|visitor
argument_list|(
name|offAndAtom
operator|.
name|atom
argument_list|,
name|offAndAtom
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|Arch
name|arch
argument_list|()
specifier|const
block|{
return|return
name|_arch
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setArch
argument_list|(
name|MachOLinkingContext
operator|::
name|Arch
name|arch
argument_list|)
block|{
name|_arch
operator|=
name|arch
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|OS
name|OS
argument_list|()
specifier|const
block|{
return|return
name|_os
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setOS
argument_list|(
name|MachOLinkingContext
operator|::
name|OS
name|os
argument_list|)
block|{
name|_os
operator|=
name|os
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|ObjCConstraint
name|objcConstraint
argument_list|()
specifier|const
block|{
return|return
name|_objcConstraint
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setObjcConstraint
argument_list|(
name|MachOLinkingContext
operator|::
name|ObjCConstraint
name|v
argument_list|)
block|{
name|_objcConstraint
operator|=
name|v
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|uint32_t
name|minVersion
argument_list|()
specifier|const
block|{
return|return
name|_minVersion
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setMinVersion
parameter_list|(
name|uint32_t
name|v
parameter_list|)
block|{
name|_minVersion
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|LoadCommandType
name|minVersionLoadCommandKind
argument_list|()
specifier|const
block|{
return|return
name|_minVersionLoadCommandKind
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setMinVersionLoadCommandKind
parameter_list|(
name|LoadCommandType
name|v
parameter_list|)
block|{
name|_minVersionLoadCommandKind
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|uint32_t
name|swiftVersion
argument_list|()
specifier|const
block|{
return|return
name|_swiftVersion
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setSwiftVersion
parameter_list|(
name|uint32_t
name|v
parameter_list|)
block|{
name|_swiftVersion
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|subsectionsViaSymbols
argument_list|()
specifier|const
block|{
return|return
name|_flags
operator|&
name|llvm
operator|::
name|MachO
operator|::
name|MH_SUBSECTIONS_VIA_SYMBOLS
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setFlags
argument_list|(
name|normalized
operator|::
name|FileFlags
name|v
argument_list|)
block|{
name|_flags
operator|=
name|v
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Methods for support type inquiry through isa, cast, and dyn_cast:
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|File
modifier|*
name|F
parameter_list|)
block|{
return|return
name|F
operator|->
name|kind
argument_list|()
operator|==
name|File
operator|::
name|kindMachObject
return|;
block|}
end_function

begin_decl_stmt
name|void
name|setDebugInfo
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|DebugInfo
operator|>
name|debugInfo
argument_list|)
block|{
name|_debugInfo
operator|=
name|std
operator|::
name|move
argument_list|(
name|debugInfo
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|DebugInfo
operator|*
name|debugInfo
argument_list|()
specifier|const
block|{
return|return
name|_debugInfo
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|DebugInfo
operator|>
name|takeDebugInfo
argument_list|()
block|{
return|return
name|std
operator|::
name|move
argument_list|(
name|_debugInfo
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|error_code
name|doParse
argument_list|()
name|override
block|{
comment|// Convert binary file to normalized mach-o.
name|auto
name|normFile
operator|=
name|normalized
operator|::
name|readBinary
argument_list|(
name|_mb
argument_list|,
name|_ctx
operator|->
name|arch
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
name|ec
init|=
name|normFile
operator|.
name|takeError
argument_list|()
condition|)
return|return
name|llvm
operator|::
name|errorToErrorCode
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ec
argument_list|)
argument_list|)
return|;
end_expr_stmt

begin_comment
comment|// Convert normalized mach-o to atoms.
end_comment

begin_if
if|if
condition|(
name|auto
name|ec
init|=
name|normalized
operator|::
name|normalizedObjectToAtoms
argument_list|(
name|this
argument_list|,
operator|*
operator|*
name|normFile
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|llvm
operator|::
name|errorToErrorCode
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ec
argument_list|)
argument_list|)
return|;
end_if

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_struct
unit|}  private:
struct|struct
name|SectionOffsetAndAtom
block|{
name|uint64_t
name|offset
decl_stmt|;
name|MachODefinedAtom
modifier|*
name|atom
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|addAtomForSection
parameter_list|(
specifier|const
name|Section
modifier|*
name|inSection
parameter_list|,
name|MachODefinedAtom
modifier|*
name|atom
parameter_list|,
name|uint64_t
name|sectionOffset
parameter_list|)
block|{
name|SectionOffsetAndAtom
name|offAndAtom
decl_stmt|;
name|offAndAtom
operator|.
name|offset
operator|=
name|sectionOffset
expr_stmt|;
name|offAndAtom
operator|.
name|atom
operator|=
name|atom
expr_stmt|;
name|_sectionAtoms
index|[
name|inSection
index|]
operator|.
name|push_back
argument_list|(
name|offAndAtom
argument_list|)
expr_stmt|;
name|addAtom
argument_list|(
operator|*
name|atom
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|normalized
operator|::
name|Section
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|SectionOffsetAndAtom
operator|>>
name|SectionToAtoms
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|llvm
operator|::
name|StringMap
operator|<
specifier|const
name|lld
operator|::
name|Atom
operator|*
operator|>
name|NameToAtom
expr_stmt|;
end_typedef

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|_mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MachOLinkingContext
modifier|*
name|_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SectionToAtoms
name|_sectionAtoms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NameToAtom
name|_undefAtoms
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|Arch
name|_arch
operator|=
name|MachOLinkingContext
operator|::
name|arch_unknown
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|OS
name|_os
operator|=
name|MachOLinkingContext
operator|::
name|OS
operator|::
name|unknown
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint32_t
name|_minVersion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LoadCommandType
name|_minVersionLoadCommandKind
init|=
operator|(
name|LoadCommandType
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MachOLinkingContext
operator|::
name|ObjCConstraint
name|_objcConstraint
operator|=
name|MachOLinkingContext
operator|::
name|objc_unknown
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint32_t
name|_swiftVersion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|normalized
operator|::
name|FileFlags
name|_flags
operator|=
name|llvm
operator|::
name|MachO
operator|::
name|MH_SUBSECTIONS_VIA_SYMBOLS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|DebugInfo
operator|>
name|_debugInfo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|};
name|class
name|MachODylibFile
range|:
name|public
name|SharedLibraryFile
block|{
name|public
operator|:
name|MachODylibFile
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|MachOLinkingContext
operator|*
name|ctx
argument_list|)
operator|:
name|SharedLibraryFile
argument_list|(
name|mb
operator|->
name|getBufferIdentifier
argument_list|()
argument_list|)
block|,
name|_mb
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|mb
argument_list|)
argument_list|)
block|,
name|_ctx
argument_list|(
argument|ctx
argument_list|)
block|{}
name|MachODylibFile
argument_list|(
argument|StringRef path
argument_list|)
operator|:
name|SharedLibraryFile
argument_list|(
argument|path
argument_list|)
block|{}
name|OwningAtomPtr
operator|<
name|SharedLibraryAtom
operator|>
name|exports
argument_list|(
argument|StringRef name
argument_list|)
specifier|const
name|override
block|{
comment|// Pass down _installName so that if this requested symbol
comment|// is re-exported through this dylib, the SharedLibraryAtom's loadName()
comment|// is this dylib installName and not the implementation dylib's.
comment|// NOTE: isData is not needed for dylibs (it matters for static libs).
return|return
name|exports
argument_list|(
name|name
argument_list|,
name|_installName
argument_list|)
return|;
block|}
comment|/// Adds symbol name that this dylib exports. The corresponding
comment|/// SharedLibraryAtom is created lazily (since most symbols are not used).
name|void
name|addExportedSymbol
argument_list|(
argument|StringRef name
argument_list|,
argument|bool weakDef
argument_list|,
argument|bool copyRefs
argument_list|)
block|{
if|if
condition|(
name|copyRefs
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|copy
argument_list|(
name|allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|AtomAndFlags
name|info
parameter_list|(
name|weakDef
parameter_list|)
function_decl|;
name|_nameToAtom
index|[
name|name
index|]
operator|=
name|info
block|;   }
name|void
name|addReExportedDylib
argument_list|(
argument|StringRef dylibPath
argument_list|)
block|{
name|_reExportedDylibs
operator|.
name|emplace_back
argument_list|(
name|dylibPath
argument_list|)
block|;   }
name|StringRef
name|installName
argument_list|()
specifier|const
block|{
return|return
name|_installName
return|;
block|}
end_decl_stmt

begin_function
name|uint32_t
name|currentVersion
parameter_list|()
block|{
return|return
name|_currentVersion
return|;
block|}
end_function

begin_function
name|uint32_t
name|compatVersion
parameter_list|()
block|{
return|return
name|_compatVersion
return|;
block|}
end_function

begin_function
name|void
name|setInstallName
parameter_list|(
name|StringRef
name|name
parameter_list|)
block|{
name|_installName
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setCompatVersion
parameter_list|(
name|uint32_t
name|version
parameter_list|)
block|{
name|_compatVersion
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setCurrentVersion
parameter_list|(
name|uint32_t
name|version
parameter_list|)
block|{
name|_currentVersion
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|std
operator|::
name|function
operator|<
name|MachODylibFile
operator|*
operator|(
name|StringRef
operator|)
operator|>
name|FindDylib
expr_stmt|;
end_typedef

begin_function
name|void
name|loadReExportedDylibs
parameter_list|(
name|FindDylib
name|find
parameter_list|)
block|{
for|for
control|(
name|ReExportedDylib
modifier|&
name|entry
range|:
name|_reExportedDylibs
control|)
block|{
name|entry
operator|.
name|file
operator|=
name|find
argument_list|(
name|entry
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|StringRef
name|getDSOName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_installName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|error_code
name|doParse
argument_list|()
name|override
block|{
comment|// Convert binary file to normalized mach-o.
name|auto
name|normFile
operator|=
name|normalized
operator|::
name|readBinary
argument_list|(
name|_mb
argument_list|,
name|_ctx
operator|->
name|arch
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
name|ec
init|=
name|normFile
operator|.
name|takeError
argument_list|()
condition|)
return|return
name|llvm
operator|::
name|errorToErrorCode
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ec
argument_list|)
argument_list|)
return|;
end_expr_stmt

begin_comment
comment|// Convert normalized mach-o to atoms.
end_comment

begin_if
if|if
condition|(
name|auto
name|ec
init|=
name|normalized
operator|::
name|normalizedDylibToAtoms
argument_list|(
name|this
argument_list|,
operator|*
operator|*
name|normFile
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|llvm
operator|::
name|errorToErrorCode
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|ec
argument_list|)
argument_list|)
return|;
end_if

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  private:
name|OwningAtomPtr
operator|<
name|SharedLibraryAtom
operator|>
name|exports
argument_list|(
argument|StringRef name
argument_list|,
argument|StringRef installName
argument_list|)
specifier|const
block|{
comment|// First, check if requested symbol is directly implemented by this dylib.
name|auto
name|entry
operator|=
name|_nameToAtom
operator|.
name|find
argument_list|(
name|name
argument_list|)
block|;
if|if
condition|(
name|entry
operator|!=
name|_nameToAtom
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// FIXME: Make this map a set and only used in assert builds.
comment|// Note, its safe to assert here as the resolver is the only client of
comment|// this API and it only requests exports for undefined symbols.
comment|// If we return from here we are no longer undefined so we should never
comment|// get here again.
name|assert
argument_list|(
operator|!
name|entry
operator|->
name|second
operator|.
name|atom
operator|&&
literal|"Duplicate shared library export"
argument_list|)
expr_stmt|;
name|bool
name|weakDef
init|=
name|entry
operator|->
name|second
operator|.
name|weakDef
decl_stmt|;
name|auto
operator|*
name|atom
operator|=
name|new
argument_list|(
argument|allocator()
argument_list|)
name|MachOSharedLibraryAtom
argument_list|(
operator|*
name|this
argument_list|,
name|name
argument_list|,
name|installName
argument_list|,
name|weakDef
argument_list|)
expr_stmt|;
name|entry
operator|->
name|second
operator|.
name|atom
operator|=
name|atom
expr_stmt|;
return|return
name|atom
return|;
block|}
end_expr_stmt

begin_comment
comment|// Next, check if symbol is implemented in some re-exported dylib.
end_comment

begin_for
for|for
control|(
specifier|const
name|ReExportedDylib
modifier|&
name|dylib
range|:
name|_reExportedDylibs
control|)
block|{
name|assert
argument_list|(
name|dylib
operator|.
name|file
argument_list|)
expr_stmt|;
name|auto
name|atom
init|=
name|dylib
operator|.
name|file
operator|->
name|exports
argument_list|(
name|name
argument_list|,
name|installName
argument_list|)
decl_stmt|;
if|if
condition|(
name|atom
operator|.
name|get
argument_list|()
condition|)
return|return
name|atom
return|;
block|}
end_for

begin_comment
comment|// Symbol not exported or re-exported by this dylib.
end_comment

begin_return
return|return
name|nullptr
return|;
end_return

begin_macro
unit|}    struct
name|ReExportedDylib
end_macro

begin_block
block|{
name|ReExportedDylib
argument_list|(
argument|StringRef p
argument_list|)
block|:
name|path
argument_list|(
name|p
argument_list|)
operator|,
name|file
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|StringRef
name|path
expr_stmt|;
name|MachODylibFile
modifier|*
name|file
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|AtomAndFlags
block|{
name|AtomAndFlags
argument_list|()
operator|:
name|atom
argument_list|(
name|nullptr
argument_list|)
operator|,
name|weakDef
argument_list|(
argument|false
argument_list|)
block|{ }
name|AtomAndFlags
argument_list|(
argument|bool weak
argument_list|)
operator|:
name|atom
argument_list|(
name|nullptr
argument_list|)
operator|,
name|weakDef
argument_list|(
argument|weak
argument_list|)
block|{ }
specifier|const
name|SharedLibraryAtom
operator|*
name|atom
expr_stmt|;
name|bool
name|weakDef
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|_mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MachOLinkingContext
modifier|*
name|_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|_installName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|_currentVersion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|_compatVersion
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|ReExportedDylib
operator|>
name|_reExportedDylibs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mutable
name|std
operator|::
name|unordered_map
operator|<
name|StringRef
operator|,
name|AtomAndFlags
operator|>
name|_nameToAtom
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace mach_o
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_READER_WRITER_MACHO_FILE_H
end_comment

end_unit

