begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- LinkerScript.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_ELF_LINKER_SCRIPT_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_ELF_LINKER_SCRIPT_H
end_define

begin_include
include|#
directive|include
file|"Config.h"
end_include

begin_include
include|#
directive|include
file|"Strings.h"
end_include

begin_include
include|#
directive|include
file|"Writer.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|class
name|DefinedCommon
decl_stmt|;
name|class
name|SymbolBody
decl_stmt|;
name|class
name|InputSectionBase
decl_stmt|;
name|class
name|InputSection
decl_stmt|;
name|class
name|OutputSection
decl_stmt|;
name|class
name|OutputSectionFactory
decl_stmt|;
name|class
name|InputSectionBase
decl_stmt|;
name|class
name|SectionBase
decl_stmt|;
struct|struct
name|ExprValue
block|{
name|SectionBase
modifier|*
name|Sec
decl_stmt|;
name|uint64_t
name|Val
decl_stmt|;
name|bool
name|ForceAbsolute
decl_stmt|;
name|ExprValue
argument_list|(
argument|SectionBase *Sec
argument_list|,
argument|bool ForceAbsolute
argument_list|,
argument|uint64_t Val
argument_list|)
block|:
name|Sec
argument_list|(
name|Sec
argument_list|)
operator|,
name|Val
argument_list|(
name|Val
argument_list|)
operator|,
name|ForceAbsolute
argument_list|(
argument|ForceAbsolute
argument_list|)
block|{}
name|ExprValue
argument_list|(
argument|SectionBase *Sec
argument_list|,
argument|uint64_t Val
argument_list|)
operator|:
name|ExprValue
argument_list|(
argument|Sec
argument_list|,
argument|false
argument_list|,
argument|Val
argument_list|)
block|{}
name|ExprValue
argument_list|(
argument|uint64_t Val
argument_list|)
operator|:
name|ExprValue
argument_list|(
argument|nullptr
argument_list|,
argument|Val
argument_list|)
block|{}
name|bool
name|isAbsolute
argument_list|()
specifier|const
block|{
return|return
name|ForceAbsolute
operator|||
name|Sec
operator|==
name|nullptr
return|;
block|}
name|uint64_t
name|getValue
argument_list|()
specifier|const
expr_stmt|;
name|uint64_t
name|getSecAddr
argument_list|()
specifier|const
expr_stmt|;
block|}
struct|;
comment|// This represents an expression in the linker script.
comment|// ScriptParser::readExpr reads an expression and returns an Expr.
comment|// Later, we evaluate the expression by calling the function.
typedef|typedef
name|std
operator|::
name|function
operator|<
name|ExprValue
argument_list|()
operator|>
name|Expr
expr_stmt|;
comment|// This enum is used to implement linker script SECTIONS command.
comment|// https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS
enum|enum
name|SectionsCommandKind
block|{
name|AssignmentKind
block|,
comment|// . = expr or<sym> = expr
name|OutputSectionKind
block|,
name|InputSectionKind
block|,
name|AssertKind
block|,
comment|// ASSERT(expr)
name|BytesDataKind
comment|// BYTE(expr), SHORT(expr), LONG(expr) or QUAD(expr)
block|}
enum|;
struct|struct
name|BaseCommand
block|{
name|BaseCommand
argument_list|(
argument|int K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|int
name|Kind
decl_stmt|;
block|}
struct|;
comment|// This represents ". =<expr>" or "<symbol> =<expr>".
name|struct
name|SymbolAssignment
range|:
name|BaseCommand
block|{
name|SymbolAssignment
argument_list|(
argument|StringRef Name
argument_list|,
argument|Expr E
argument_list|,
argument|std::string Loc
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|AssignmentKind
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Expression
argument_list|(
name|E
argument_list|)
block|,
name|Location
argument_list|(
argument|Loc
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
comment|// The LHS of an expression. Name is either a symbol name or ".".
name|StringRef
name|Name
block|;
name|SymbolBody
operator|*
name|Sym
operator|=
name|nullptr
block|;
comment|// The RHS of an expression.
name|Expr
name|Expression
block|;
comment|// Command attributes for PROVIDE, HIDDEN and PROVIDE_HIDDEN.
name|bool
name|Provide
operator|=
name|false
block|;
name|bool
name|Hidden
operator|=
name|false
block|;
comment|// Holds file name and line number for error reporting.
name|std
operator|::
name|string
name|Location
block|; }
decl_stmt|;
comment|// Linker scripts allow additional constraints to be put on ouput sections.
comment|// If an output section is marked as ONLY_IF_RO, the section is created
comment|// only if its input sections are read-only. Likewise, an output section
comment|// with ONLY_IF_RW is created if all input sections are RW.
name|enum
name|class
name|ConstraintKind
block|{
name|NoConstraint
operator|,
name|ReadOnly
operator|,
name|ReadWrite
block|}
empty_stmt|;
comment|// This struct is used to represent the location and size of regions of
comment|// target memory. Instances of the struct are created by parsing the
comment|// MEMORY command.
struct|struct
name|MemoryRegion
block|{
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|uint64_t
name|Origin
decl_stmt|;
name|uint64_t
name|Length
decl_stmt|;
name|uint64_t
name|Offset
decl_stmt|;
name|uint32_t
name|Flags
decl_stmt|;
name|uint32_t
name|NegFlags
decl_stmt|;
block|}
struct|;
name|struct
name|OutputSectionCommand
range|:
name|BaseCommand
block|{
name|OutputSectionCommand
argument_list|(
argument|StringRef Name
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|OutputSectionKind
argument_list|)
block|,
name|Name
argument_list|(
argument|Name
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|OutputSection
operator|*
name|Sec
operator|=
name|nullptr
block|;
name|MemoryRegion
operator|*
name|MemRegion
operator|=
name|nullptr
block|;
name|StringRef
name|Name
block|;
name|Expr
name|AddrExpr
block|;
name|Expr
name|AlignExpr
block|;
name|Expr
name|LMAExpr
block|;
name|Expr
name|SubalignExpr
block|;
name|std
operator|::
name|vector
operator|<
name|BaseCommand
operator|*
operator|>
name|Commands
block|;
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|Phdrs
block|;
name|llvm
operator|::
name|Optional
operator|<
name|uint32_t
operator|>
name|Filler
block|;
name|ConstraintKind
name|Constraint
operator|=
name|ConstraintKind
operator|::
name|NoConstraint
block|;
name|std
operator|::
name|string
name|Location
block|;
name|std
operator|::
name|string
name|MemoryRegionName
block|; }
decl_stmt|;
comment|// This struct represents one section match pattern in SECTIONS() command.
comment|// It can optionally have negative match pattern for EXCLUDED_FILE command.
comment|// Also it may be surrounded with SORT() command, so contains sorting rules.
struct|struct
name|SectionPattern
block|{
name|SectionPattern
argument_list|(
name|StringMatcher
operator|&&
name|Pat1
argument_list|,
name|StringMatcher
operator|&&
name|Pat2
argument_list|)
operator|:
name|ExcludedFilePat
argument_list|(
name|Pat1
argument_list|)
operator|,
name|SectionPat
argument_list|(
argument|Pat2
argument_list|)
block|{}
name|StringMatcher
name|ExcludedFilePat
expr_stmt|;
name|StringMatcher
name|SectionPat
decl_stmt|;
name|SortSectionPolicy
name|SortOuter
decl_stmt|;
name|SortSectionPolicy
name|SortInner
decl_stmt|;
block|}
struct|;
name|struct
name|InputSectionDescription
range|:
name|BaseCommand
block|{
name|InputSectionDescription
argument_list|(
argument|StringRef FilePattern
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|InputSectionKind
argument_list|)
block|,
name|FilePat
argument_list|(
argument|FilePattern
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|StringMatcher
name|FilePat
block|;
comment|// Input sections that matches at least one of SectionPatterns
comment|// will be associated with this InputSectionDescription.
name|std
operator|::
name|vector
operator|<
name|SectionPattern
operator|>
name|SectionPatterns
block|;
name|std
operator|::
name|vector
operator|<
name|InputSectionBase
operator|*
operator|>
name|Sections
block|; }
decl_stmt|;
comment|// Represents an ASSERT().
name|struct
name|AssertCommand
range|:
name|BaseCommand
block|{
name|AssertCommand
argument_list|(
argument|Expr E
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|AssertKind
argument_list|)
block|,
name|Expression
argument_list|(
argument|E
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|Expr
name|Expression
block|; }
decl_stmt|;
comment|// Represents BYTE(), SHORT(), LONG(), or QUAD().
name|struct
name|BytesDataCommand
range|:
name|BaseCommand
block|{
name|BytesDataCommand
argument_list|(
argument|Expr E
argument_list|,
argument|unsigned Size
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|BytesDataKind
argument_list|)
block|,
name|Expression
argument_list|(
name|E
argument_list|)
block|,
name|Size
argument_list|(
argument|Size
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|Expr
name|Expression
block|;
name|unsigned
name|Offset
block|;
name|unsigned
name|Size
block|; }
decl_stmt|;
struct|struct
name|PhdrsCommand
block|{
name|StringRef
name|Name
decl_stmt|;
name|unsigned
name|Type
decl_stmt|;
name|bool
name|HasFilehdr
decl_stmt|;
name|bool
name|HasPhdrs
decl_stmt|;
name|unsigned
name|Flags
decl_stmt|;
name|Expr
name|LMAExpr
decl_stmt|;
block|}
struct|;
comment|// ScriptConfiguration holds linker script parse results.
struct|struct
name|ScriptConfiguration
block|{
comment|// Used to assign addresses to sections.
name|std
operator|::
name|vector
operator|<
name|BaseCommand
operator|*
operator|>
name|Commands
expr_stmt|;
comment|// Used to assign sections to headers.
name|std
operator|::
name|vector
operator|<
name|PhdrsCommand
operator|>
name|PhdrsCommands
expr_stmt|;
name|bool
name|HasSections
init|=
name|false
decl_stmt|;
comment|// List of section patterns specified with KEEP commands. They will
comment|// be kept even if they are unused and --gc-sections is specified.
name|std
operator|::
name|vector
operator|<
name|InputSectionDescription
operator|*
operator|>
name|KeptSections
expr_stmt|;
comment|// A map from memory region name to a memory region descriptor.
name|llvm
operator|::
name|DenseMap
operator|<
name|llvm
operator|::
name|StringRef
operator|,
name|MemoryRegion
operator|>
name|MemoryRegions
expr_stmt|;
comment|// A list of symbols referenced by the script.
name|std
operator|::
name|vector
operator|<
name|llvm
operator|::
name|StringRef
operator|>
name|ReferencedSymbols
expr_stmt|;
block|}
struct|;
name|class
name|LinkerScript
block|{
name|protected
label|:
name|void
name|assignSymbol
parameter_list|(
name|SymbolAssignment
modifier|*
name|Cmd
parameter_list|,
name|bool
name|InSec
parameter_list|)
function_decl|;
name|void
name|setDot
parameter_list|(
name|Expr
name|E
parameter_list|,
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|bool
name|InSec
parameter_list|)
function_decl|;
name|std
operator|::
name|vector
operator|<
name|InputSectionBase
operator|*
operator|>
name|computeInputSections
argument_list|(
specifier|const
name|InputSectionDescription
operator|*
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|InputSectionBase
operator|*
operator|>
name|createInputSectionList
argument_list|(
name|OutputSectionCommand
operator|&
name|Cmd
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|size_t
operator|>
name|getPhdrIndices
argument_list|(
argument|StringRef SectionName
argument_list|)
expr_stmt|;
name|size_t
name|getPhdrIndex
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|PhdrName
parameter_list|)
function_decl|;
name|MemoryRegion
modifier|*
name|findMemoryRegion
parameter_list|(
name|OutputSectionCommand
modifier|*
name|Cmd
parameter_list|)
function_decl|;
name|void
name|switchTo
parameter_list|(
name|OutputSection
modifier|*
name|Sec
parameter_list|)
function_decl|;
name|void
name|flush
parameter_list|()
function_decl|;
name|void
name|output
parameter_list|(
name|InputSection
modifier|*
name|Sec
parameter_list|)
function_decl|;
name|void
name|process
parameter_list|(
name|BaseCommand
modifier|&
name|Base
parameter_list|)
function_decl|;
name|OutputSection
modifier|*
name|Aether
decl_stmt|;
name|bool
name|ErrorOnMissingSection
init|=
name|false
decl_stmt|;
name|uint64_t
name|Dot
decl_stmt|;
name|uint64_t
name|ThreadBssOffset
init|=
literal|0
decl_stmt|;
name|std
operator|::
name|function
operator|<
name|uint64_t
argument_list|()
operator|>
name|LMAOffset
expr_stmt|;
name|OutputSection
modifier|*
name|CurOutSec
init|=
name|nullptr
decl_stmt|;
name|MemoryRegion
modifier|*
name|CurMemRegion
init|=
name|nullptr
decl_stmt|;
name|llvm
operator|::
name|DenseSet
operator|<
name|OutputSection
operator|*
operator|>
name|AlreadyOutputOS
expr_stmt|;
name|llvm
operator|::
name|DenseSet
operator|<
name|InputSectionBase
operator|*
operator|>
name|AlreadyOutputIS
expr_stmt|;
name|public
label|:
name|bool
name|hasPhdrsCommands
parameter_list|()
block|{
return|return
operator|!
name|Opt
operator|.
name|PhdrsCommands
operator|.
name|empty
argument_list|()
return|;
block|}
name|uint64_t
name|getDot
parameter_list|()
block|{
return|return
name|Dot
return|;
block|}
name|OutputSection
modifier|*
name|getOutputSection
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|S
parameter_list|)
function_decl|;
name|uint64_t
name|getOutputSectionSize
parameter_list|(
name|StringRef
name|S
parameter_list|)
function_decl|;
name|void
name|discard
argument_list|(
name|ArrayRef
operator|<
name|InputSectionBase
operator|*
operator|>
name|V
argument_list|)
decl_stmt|;
name|ExprValue
name|getSymbolValue
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|S
parameter_list|)
function_decl|;
name|bool
name|isDefined
parameter_list|(
name|StringRef
name|S
parameter_list|)
function_decl|;
name|std
operator|::
name|vector
operator|<
name|OutputSection
operator|*
operator|>
operator|*
name|OutputSections
expr_stmt|;
name|void
name|fabricateDefaultCommands
parameter_list|(
name|bool
name|AllocateHeader
parameter_list|)
function_decl|;
name|void
name|addOrphanSections
parameter_list|(
name|OutputSectionFactory
modifier|&
name|Factory
parameter_list|)
function_decl|;
name|void
name|removeEmptyCommands
parameter_list|()
function_decl|;
name|void
name|adjustSectionsBeforeSorting
parameter_list|()
function_decl|;
name|void
name|adjustSectionsAfterSorting
parameter_list|()
function_decl|;
name|std
operator|::
name|vector
operator|<
name|PhdrEntry
operator|>
name|createPhdrs
argument_list|()
expr_stmt|;
name|bool
name|ignoreInterpSection
parameter_list|()
function_decl|;
name|llvm
operator|::
name|Optional
operator|<
name|uint32_t
operator|>
name|getFiller
argument_list|(
argument|StringRef Name
argument_list|)
expr_stmt|;
name|bool
name|hasLMA
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|bool
name|shouldKeep
parameter_list|(
name|InputSectionBase
modifier|*
name|S
parameter_list|)
function_decl|;
name|void
name|assignOffsets
parameter_list|(
name|OutputSectionCommand
modifier|*
name|Cmd
parameter_list|)
function_decl|;
name|void
name|placeOrphanSections
parameter_list|()
function_decl|;
name|void
name|processNonSectionCommands
parameter_list|()
function_decl|;
name|void
name|assignAddresses
argument_list|(
name|std
operator|::
name|vector
operator|<
name|PhdrEntry
operator|>
operator|&
name|Phdrs
argument_list|)
decl_stmt|;
name|int
name|getSectionIndex
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|void
name|writeDataBytes
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
modifier|*
name|Buf
parameter_list|)
function_decl|;
name|void
name|addSymbol
parameter_list|(
name|SymbolAssignment
modifier|*
name|Cmd
parameter_list|)
function_decl|;
name|void
name|processCommands
parameter_list|(
name|OutputSectionFactory
modifier|&
name|Factory
parameter_list|)
function_decl|;
comment|// Parsed linker script configurations are set to this struct.
name|ScriptConfiguration
name|Opt
decl_stmt|;
block|}
empty_stmt|;
specifier|extern
name|LinkerScript
modifier|*
name|Script
decl_stmt|;
block|}
comment|// end namespace elf
block|}
end_decl_stmt

begin_comment
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_ELF_LINKER_SCRIPT_H
end_comment

end_unit

