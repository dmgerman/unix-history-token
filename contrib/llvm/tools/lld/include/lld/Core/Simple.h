begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lld/Core/Simple.h - Simple implementations of Atom and File --------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Provide simple implementations for Atoms and File.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_CORE_SIMPLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_CORE_SIMPLE_H
end_define

begin_include
include|#
directive|include
file|"lld/Core/AbsoluteAtom.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Atom.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/DefinedAtom.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/File.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Reference.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/SharedLibraryAtom.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/UndefinedAtom.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ilist.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|class
name|SimpleFile
range|:
name|public
name|File
block|{
name|public
operator|:
name|SimpleFile
argument_list|(
argument|StringRef path
argument_list|,
argument|File::Kind kind
argument_list|)
operator|:
name|File
argument_list|(
argument|path
argument_list|,
argument|kind
argument_list|)
block|{}
operator|~
name|SimpleFile
argument_list|()
name|override
block|{
name|_defined
operator|.
name|clear
argument_list|()
block|;
name|_undefined
operator|.
name|clear
argument_list|()
block|;
name|_shared
operator|.
name|clear
argument_list|()
block|;
name|_absolute
operator|.
name|clear
argument_list|()
block|;   }
name|void
name|addAtom
argument_list|(
argument|DefinedAtom&a
argument_list|)
block|{
name|_defined
operator|.
name|push_back
argument_list|(
name|OwningAtomPtr
operator|<
name|DefinedAtom
operator|>
operator|(
operator|&
name|a
operator|)
argument_list|)
block|;   }
name|void
name|addAtom
argument_list|(
argument|UndefinedAtom&a
argument_list|)
block|{
name|_undefined
operator|.
name|push_back
argument_list|(
name|OwningAtomPtr
operator|<
name|UndefinedAtom
operator|>
operator|(
operator|&
name|a
operator|)
argument_list|)
block|;   }
name|void
name|addAtom
argument_list|(
argument|SharedLibraryAtom&a
argument_list|)
block|{
name|_shared
operator|.
name|push_back
argument_list|(
name|OwningAtomPtr
operator|<
name|SharedLibraryAtom
operator|>
operator|(
operator|&
name|a
operator|)
argument_list|)
block|;   }
name|void
name|addAtom
argument_list|(
argument|AbsoluteAtom&a
argument_list|)
block|{
name|_absolute
operator|.
name|push_back
argument_list|(
name|OwningAtomPtr
operator|<
name|AbsoluteAtom
operator|>
operator|(
operator|&
name|a
operator|)
argument_list|)
block|;   }
name|void
name|addAtom
argument_list|(
argument|const Atom&atom
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|p
operator|=
name|dyn_cast
operator|<
name|DefinedAtom
operator|>
operator|(
operator|&
name|atom
operator|)
condition|)
block|{
name|addAtom
argument_list|(
name|const_cast
operator|<
name|DefinedAtom
operator|&
operator|>
operator|(
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto
operator|*
name|p
operator|=
name|dyn_cast
operator|<
name|UndefinedAtom
operator|>
operator|(
operator|&
name|atom
operator|)
condition|)
block|{
name|addAtom
argument_list|(
name|const_cast
operator|<
name|UndefinedAtom
operator|&
operator|>
operator|(
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto
operator|*
name|p
operator|=
name|dyn_cast
operator|<
name|SharedLibraryAtom
operator|>
operator|(
operator|&
name|atom
operator|)
condition|)
block|{
name|addAtom
argument_list|(
name|const_cast
operator|<
name|SharedLibraryAtom
operator|&
operator|>
operator|(
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto
operator|*
name|p
operator|=
name|dyn_cast
operator|<
name|AbsoluteAtom
operator|>
operator|(
operator|&
name|atom
operator|)
condition|)
block|{
name|addAtom
argument_list|(
name|const_cast
operator|<
name|AbsoluteAtom
operator|&
operator|>
operator|(
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|llvm_unreachable
argument_list|(
literal|"atom has unknown definition kind"
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|removeDefinedAtomsIf
argument_list|(
argument|std::function<bool(const DefinedAtom *)> pred
argument_list|)
block|{
name|auto
operator|&
name|atoms
operator|=
name|_defined
block|;
name|auto
name|newEnd
operator|=
name|std
operator|::
name|remove_if
argument_list|(
name|atoms
operator|.
name|begin
argument_list|()
argument_list|,
name|atoms
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
name|pred
index|]
operator|(
name|OwningAtomPtr
operator|<
name|DefinedAtom
operator|>
operator|&
name|p
operator|)
block|{
return|return
name|pred
argument_list|(
name|p
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
argument_list|)
block|;
name|atoms
operator|.
name|erase
argument_list|(
name|newEnd
argument_list|,
name|atoms
operator|.
name|end
argument_list|()
argument_list|)
block|;   }
specifier|const
name|AtomRange
operator|<
name|DefinedAtom
operator|>
name|defined
argument_list|()
specifier|const
name|override
block|{
return|return
name|_defined
return|;
block|}
specifier|const
name|AtomRange
operator|<
name|UndefinedAtom
operator|>
name|undefined
argument_list|()
specifier|const
name|override
block|{
return|return
name|_undefined
return|;
block|}
specifier|const
name|AtomRange
operator|<
name|SharedLibraryAtom
operator|>
name|sharedLibrary
argument_list|()
specifier|const
name|override
block|{
return|return
name|_shared
return|;
block|}
specifier|const
name|AtomRange
operator|<
name|AbsoluteAtom
operator|>
name|absolute
argument_list|()
specifier|const
name|override
block|{
return|return
name|_absolute
return|;
block|}
name|void
name|clearAtoms
argument_list|()
name|override
block|{
name|_defined
operator|.
name|clear
argument_list|()
block|;
name|_undefined
operator|.
name|clear
argument_list|()
block|;
name|_shared
operator|.
name|clear
argument_list|()
block|;
name|_absolute
operator|.
name|clear
argument_list|()
block|;   }
name|private
operator|:
name|AtomVector
operator|<
name|DefinedAtom
operator|>
name|_defined
block|;
name|AtomVector
operator|<
name|UndefinedAtom
operator|>
name|_undefined
block|;
name|AtomVector
operator|<
name|SharedLibraryAtom
operator|>
name|_shared
block|;
name|AtomVector
operator|<
name|AbsoluteAtom
operator|>
name|_absolute
block|; }
decl_stmt|;
name|class
name|SimpleReference
range|:
name|public
name|Reference
block|{
name|public
operator|:
name|SimpleReference
argument_list|(
argument|Reference::KindNamespace ns
argument_list|,
argument|Reference::KindArch arch
argument_list|,
argument|Reference::KindValue value
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
operator|:
name|Reference
argument_list|(
name|ns
argument_list|,
name|arch
argument_list|,
name|value
argument_list|)
block|,
name|_target
argument_list|(
name|t
argument_list|)
block|,
name|_offsetInAtom
argument_list|(
name|off
argument_list|)
block|,
name|_addend
argument_list|(
name|a
argument_list|)
block|,
name|_next
argument_list|(
name|nullptr
argument_list|)
block|,
name|_prev
argument_list|(
argument|nullptr
argument_list|)
block|{   }
name|SimpleReference
argument_list|()
operator|:
name|Reference
argument_list|(
name|Reference
operator|::
name|KindNamespace
operator|::
name|all
argument_list|,
name|Reference
operator|::
name|KindArch
operator|::
name|all
argument_list|,
literal|0
argument_list|)
block|,
name|_target
argument_list|(
name|nullptr
argument_list|)
block|,
name|_offsetInAtom
argument_list|(
literal|0
argument_list|)
block|,
name|_addend
argument_list|(
literal|0
argument_list|)
block|,
name|_next
argument_list|(
name|nullptr
argument_list|)
block|,
name|_prev
argument_list|(
argument|nullptr
argument_list|)
block|{   }
name|uint64_t
name|offsetInAtom
argument_list|()
specifier|const
name|override
block|{
return|return
name|_offsetInAtom
return|;
block|}
specifier|const
name|Atom
operator|*
name|target
argument_list|()
specifier|const
name|override
block|{
name|assert
argument_list|(
name|_target
argument_list|)
block|;
return|return
name|_target
return|;
block|}
name|Addend
name|addend
argument_list|()
specifier|const
name|override
block|{
return|return
name|_addend
return|;
block|}
name|void
name|setAddend
argument_list|(
argument|Addend a
argument_list|)
name|override
block|{
name|_addend
operator|=
name|a
block|; }
name|void
name|setTarget
argument_list|(
argument|const Atom *newAtom
argument_list|)
name|override
block|{
name|_target
operator|=
name|newAtom
block|; }
name|SimpleReference
operator|*
name|getNext
argument_list|()
specifier|const
block|{
return|return
name|_next
return|;
block|}
name|SimpleReference
operator|*
name|getPrev
argument_list|()
specifier|const
block|{
return|return
name|_prev
return|;
block|}
name|void
name|setNext
argument_list|(
argument|SimpleReference *n
argument_list|)
block|{
name|_next
operator|=
name|n
block|; }
name|void
name|setPrev
argument_list|(
argument|SimpleReference *p
argument_list|)
block|{
name|_prev
operator|=
name|p
block|; }
name|private
operator|:
specifier|const
name|Atom
operator|*
name|_target
block|;
name|uint64_t
name|_offsetInAtom
block|;
name|Addend
name|_addend
block|;
name|SimpleReference
operator|*
name|_next
block|;
name|SimpleReference
operator|*
name|_prev
block|; }
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace lld
end_comment

begin_comment
comment|// ilist will lazily create a sentinal (so end() can return a node past the
end_comment

begin_comment
comment|// end of the list). We need this trait so that the sentinal is allocated
end_comment

begin_comment
comment|// via the BumpPtrAllocator.
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
operator|>
expr|struct
name|ilist_sentinel_traits
operator|<
name|lld
operator|::
name|SimpleReference
operator|>
block|{
name|ilist_sentinel_traits
argument_list|()
operator|:
name|_allocator
argument_list|(
argument|nullptr
argument_list|)
block|{ }
name|void
name|setAllocator
argument_list|(
argument|llvm::BumpPtrAllocator *alloc
argument_list|)
block|{
name|_allocator
operator|=
name|alloc
block|;   }
name|lld
operator|::
name|SimpleReference
operator|*
name|createSentinel
argument_list|()
specifier|const
block|{
return|return
name|new
argument_list|(
argument|*_allocator
argument_list|)
name|lld
operator|::
name|SimpleReference
argument_list|()
return|;
block|}
specifier|static
name|void
name|destroySentinel
argument_list|(
argument|lld::SimpleReference*
argument_list|)
block|{}
specifier|static
name|lld
operator|::
name|SimpleReference
operator|*
name|provideInitialHead
argument_list|()
block|{
return|return
name|nullptr
return|;
block|}
name|lld
operator|::
name|SimpleReference
operator|*
name|ensureHead
argument_list|(
argument|lld::SimpleReference *&head
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|head
operator|=
name|createSentinel
argument_list|()
expr_stmt|;
name|noteHead
argument_list|(
name|head
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|ilist_traits
operator|<
name|lld
operator|::
name|SimpleReference
operator|>
operator|::
name|setNext
argument_list|(
name|head
argument_list|,
name|nullptr
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
return|return
name|ilist_traits
operator|<
name|lld
operator|::
name|SimpleReference
operator|>
operator|::
name|getPrev
argument_list|(
name|head
argument_list|)
return|;
block|}
name|void
name|noteHead
argument_list|(
argument|lld::SimpleReference *newHead
argument_list|,
argument|lld::SimpleReference *sentinel
argument_list|)
specifier|const
block|{
name|ilist_traits
operator|<
name|lld
operator|::
name|SimpleReference
operator|>
operator|::
name|setPrev
argument_list|(
name|newHead
argument_list|,
name|sentinel
argument_list|)
block|;   }
name|private
operator|:
name|mutable
name|llvm
operator|::
name|BumpPtrAllocator
operator|*
name|_allocator
block|; }
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_decl_stmt
name|namespace
name|lld
block|{
name|class
name|SimpleDefinedAtom
range|:
name|public
name|DefinedAtom
block|{
name|public
operator|:
name|explicit
name|SimpleDefinedAtom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|_file
argument_list|(
name|f
argument_list|)
block|,
name|_ordinal
argument_list|(
argument|f.getNextAtomOrdinalAndIncrement()
argument_list|)
block|{
name|_references
operator|.
name|setAllocator
argument_list|(
operator|&
name|f
operator|.
name|allocator
argument_list|()
argument_list|)
block|;   }
operator|~
name|SimpleDefinedAtom
argument_list|()
name|override
block|{
name|_references
operator|.
name|clearAndLeakNodesUnsafely
argument_list|()
block|;   }
specifier|const
name|File
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_file
return|;
block|}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|StringRef
argument_list|()
return|;
block|}
name|uint64_t
name|ordinal
argument_list|()
specifier|const
name|override
block|{
return|return
name|_ordinal
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|scopeLinkageUnit
return|;
block|}
name|Interposable
name|interposable
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|interposeNo
return|;
block|}
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|mergeNo
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|sectionBasedOnContent
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
name|StringRef
argument_list|()
return|;
block|}
name|DeadStripKind
name|deadStrip
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|deadStripNormal
return|;
block|}
name|DefinedAtom
operator|::
name|reference_iterator
name|begin
argument_list|()
specifier|const
name|override
block|{
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
operator|*
name|_references
operator|.
name|begin
argument_list|()
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
name|DefinedAtom
operator|::
name|reference_iterator
name|end
argument_list|()
specifier|const
name|override
block|{
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
operator|&
operator|*
name|_references
operator|.
name|end
argument_list|()
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
specifier|const
name|Reference
operator|*
name|derefIterator
argument_list|(
argument|const void *it
argument_list|)
specifier|const
name|override
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|Reference
operator|*
operator|>
operator|(
name|it
operator|)
return|;
block|}
name|void
name|incrementIterator
argument_list|(
argument|const void *&it
argument_list|)
specifier|const
name|override
block|{
specifier|const
name|SimpleReference
operator|*
name|node
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|SimpleReference
operator|*
operator|>
operator|(
name|it
operator|)
block|;
specifier|const
name|SimpleReference
operator|*
name|next
operator|=
name|node
operator|->
name|getNext
argument_list|()
block|;
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|next
operator|)
block|;   }
name|void
name|addReference
argument_list|(
argument|Reference::KindNamespace ns
argument_list|,
argument|Reference::KindArch arch
argument_list|,
argument|Reference::KindValue kindValue
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *target
argument_list|,
argument|Reference::Addend a
argument_list|)
name|override
block|{
name|assert
argument_list|(
name|target
operator|&&
literal|"trying to create reference to nothing"
argument_list|)
block|;
name|auto
name|node
operator|=
name|new
argument_list|(
argument|_file.allocator()
argument_list|)
name|SimpleReference
argument_list|(
name|ns
argument_list|,
name|arch
argument_list|,
name|kindValue
argument_list|,
name|off
argument_list|,
name|target
argument_list|,
name|a
argument_list|)
block|;
name|_references
operator|.
name|push_back
argument_list|(
name|node
argument_list|)
block|;   }
comment|/// Sort references in a canonical order (by offset, then by kind).
name|void
name|sortReferences
argument_list|()
specifier|const
block|{
comment|// Cannot sort a linked  list, so move elements into a temporary vector,
comment|// sort the vector, then reconstruct the list.
name|llvm
operator|::
name|SmallVector
operator|<
name|SimpleReference
operator|*
block|,
literal|16
operator|>
name|elements
block|;
for|for
control|(
name|SimpleReference
modifier|&
name|node
range|:
name|_references
control|)
block|{
name|elements
operator|.
name|push_back
argument_list|(
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
argument|elements.begin()
argument_list|,
argument|elements.end()
argument_list|,
argument|[] (const SimpleReference *lhs, const SimpleReference *rhs) -> bool {           uint64_t lhsOffset = lhs->offsetInAtom();           uint64_t rhsOffset = rhs->offsetInAtom();           if (rhsOffset != lhsOffset)             return (lhsOffset< rhsOffset);           if (rhs->kindNamespace() != lhs->kindNamespace())             return (lhs->kindNamespace()< rhs->kindNamespace());           if (rhs->kindArch() != lhs->kindArch())             return (lhs->kindArch()< rhs->kindArch());           return (lhs->kindValue()< rhs->kindValue());         }
argument_list|)
expr_stmt|;
name|_references
operator|.
name|clearAndLeakNodesUnsafely
argument_list|()
block|;
for|for
control|(
name|SimpleReference
modifier|*
name|node
range|:
name|elements
control|)
block|{
name|_references
operator|.
name|push_back
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|setOrdinal
argument_list|(
argument|uint64_t ord
argument_list|)
block|{
name|_ordinal
operator|=
name|ord
block|; }
name|private
operator|:
typedef|typedef
name|llvm
operator|::
name|ilist
operator|<
name|SimpleReference
operator|>
name|RefList
expr_stmt|;
specifier|const
name|File
modifier|&
name|_file
decl_stmt|;
name|uint64_t
name|_ordinal
decl_stmt|;
name|mutable
name|RefList
name|_references
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|SimpleUndefinedAtom
range|:
name|public
name|UndefinedAtom
block|{
name|public
operator|:
name|SimpleUndefinedAtom
argument_list|(
argument|const File&f
argument_list|,
argument|StringRef name
argument_list|)
operator|:
name|_file
argument_list|(
name|f
argument_list|)
block|,
name|_name
argument_list|(
argument|name
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|name
operator|.
name|empty
argument_list|()
operator|&&
literal|"UndefinedAtoms must have a name"
argument_list|)
block|;   }
operator|~
name|SimpleUndefinedAtom
argument_list|()
name|override
operator|=
expr|default
block|;
comment|/// file - returns the File that produced/owns this Atom
specifier|const
name|File
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_file
return|;
block|}
comment|/// name - The name of the atom. For a function atom, it is the (mangled)
comment|/// name of the function.
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|CanBeNull
name|canBeNull
argument_list|()
specifier|const
name|override
block|{
return|return
name|UndefinedAtom
operator|::
name|canBeNullNever
return|;
block|}
name|private
operator|:
specifier|const
name|File
operator|&
name|_file
block|;
name|StringRef
name|_name
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_CORE_SIMPLE_H
end_comment

end_unit

