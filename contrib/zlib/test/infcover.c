begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infcover.c -- test zlib's inflate routines with full code coverage  * Copyright (C) 2011 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* to use, do: ./configure --cover&& make cover */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* get definition of internal structure so we can mess with it (see pull()),    and so we can call inflate_trees() (see cover5()) */
end_comment

begin_define
define|#
directive|define
name|ZLIB_INTERNAL
end_define

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"inflate.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* -- memory tracking routines -- */
end_comment

begin_comment
comment|/*    These memory tracking routines are provided to zlib and track all of zlib's    allocations and deallocations, check for LIFO operations, keep a current    and high water mark of total bytes requested, optionally set a limit on the    total memory that can be allocated, and when done check for memory leaks.     They are used as follows:     z_stream strm;    mem_setup(&strm)         initializes the memory tracking and sets the                             zalloc, zfree, and opaque members of strm to use                             memory tracking for all zlib operations on strm    mem_limit(&strm, limit)  sets a limit on the total bytes requested -- a                             request that exceeds this limit will result in an                             allocation failure (returns NULL) -- setting the                             limit to zero means no limit, which is the default                             after mem_setup()    mem_used(&strm, "msg")   prints to stderr "msg" and the total bytes used    mem_high(&strm, "msg")   prints to stderr "msg" and the high water mark    mem_done(&strm, "msg")   ends memory tracking, releases all allocations                             for the tracking as well as leaked zlib blocks, if                             any.  If there was anything unusual, such as leaked                             blocks, non-FIFO frees, or frees of addresses not                             allocated, then "msg" and information about the                             problem is printed to stderr.  If everything is                             normal, nothing is printed. mem_done resets the                             strm members to Z_NULL to use the default memory                             allocation routines on the next zlib initialization                             using strm.  */
end_comment

begin_comment
comment|/* these items are strung together in a linked list, one for each allocation */
end_comment

begin_struct
struct|struct
name|mem_item
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
comment|/* pointer to allocated memory */
name|size_t
name|size
decl_stmt|;
comment|/* requested size of allocation */
name|struct
name|mem_item
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next item in list, or NULL */
block|}
struct|;
end_struct

begin_comment
comment|/* this structure is at the root of the linked list, and tracks statistics */
end_comment

begin_struct
struct|struct
name|mem_zone
block|{
name|struct
name|mem_item
modifier|*
name|first
decl_stmt|;
comment|/* pointer to first item in list, or NULL */
name|size_t
name|total
decl_stmt|,
name|highwater
decl_stmt|;
comment|/* total allocations, and largest total */
name|size_t
name|limit
decl_stmt|;
comment|/* memory allocation limit, or 0 if no limit */
name|int
name|notlifo
decl_stmt|,
name|rogue
decl_stmt|;
comment|/* counts of non-LIFO frees and rogue frees */
block|}
struct|;
end_struct

begin_comment
comment|/* memory allocation routine to pass to zlib */
end_comment

begin_function
name|local
name|void
modifier|*
name|mem_alloc
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|unsigned
name|count
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|struct
name|mem_item
modifier|*
name|item
decl_stmt|;
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|mem
decl_stmt|;
name|size_t
name|len
init|=
name|count
operator|*
operator|(
name|size_t
operator|)
name|size
decl_stmt|;
comment|/* induced allocation failure */
if|if
condition|(
name|zone
operator|==
name|NULL
operator|||
operator|(
name|zone
operator|->
name|limit
operator|&&
name|zone
operator|->
name|total
operator|+
name|len
operator|>
name|zone
operator|->
name|limit
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* perform allocation using the standard library, fill memory with a        non-zero value to make sure that the code isn't depending on zeros */
name|ptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0xa5
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* create a new item for the list */
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mem_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|item
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|item
operator|->
name|size
operator|=
name|len
expr_stmt|;
comment|/* insert item at the beginning of the list */
name|item
operator|->
name|next
operator|=
name|zone
operator|->
name|first
expr_stmt|;
name|zone
operator|->
name|first
operator|=
name|item
expr_stmt|;
comment|/* update the statistics */
name|zone
operator|->
name|total
operator|+=
name|item
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|total
operator|>
name|zone
operator|->
name|highwater
condition|)
name|zone
operator|->
name|highwater
operator|=
name|zone
operator|->
name|total
expr_stmt|;
comment|/* return the allocated memory */
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* memory free routine to pass to zlib */
end_comment

begin_function
name|local
name|void
name|mem_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|mem_item
modifier|*
name|item
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|mem
decl_stmt|;
comment|/* if no zone, just do a free */
if|if
condition|(
name|zone
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* point next to the item that matches ptr, or NULL if not found -- remove        the item from the linked list if found */
name|next
operator|=
name|zone
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|ptr
operator|==
name|ptr
condition|)
name|zone
operator|->
name|first
operator|=
name|next
operator|->
name|next
expr_stmt|;
comment|/* first one is it, remove from list */
else|else
block|{
do|do
block|{
comment|/* search the linked list */
name|item
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|item
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|->
name|ptr
operator|!=
name|ptr
condition|)
do|;
if|if
condition|(
name|next
condition|)
block|{
comment|/* if found, remove from linked list */
name|item
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|zone
operator|->
name|notlifo
operator|++
expr_stmt|;
comment|/* not a LIFO free */
block|}
block|}
block|}
comment|/* if found, update the statistics and free the item */
if|if
condition|(
name|next
condition|)
block|{
name|zone
operator|->
name|total
operator|-=
name|next
operator|->
name|size
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* if not found, update the rogue count */
else|else
name|zone
operator|->
name|rogue
operator|++
expr_stmt|;
comment|/* in any case, do the requested free with the standard library function */
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set up a controlled memory allocation space for monitoring, set the stream    parameters to the controlled routines, with opaque pointing to the space */
end_comment

begin_function
name|local
name|void
name|mem_setup
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|)
block|{
name|struct
name|mem_zone
modifier|*
name|zone
decl_stmt|;
name|zone
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mem_zone
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zone
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|highwater
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|notlifo
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|rogue
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
name|zone
expr_stmt|;
name|strm
operator|->
name|zalloc
operator|=
name|mem_alloc
expr_stmt|;
name|strm
operator|->
name|zfree
operator|=
name|mem_free
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set a limit on the total memory allocation, or 0 to remove the limit */
end_comment

begin_function
name|local
name|void
name|mem_limit
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|strm
operator|->
name|opaque
decl_stmt|;
name|zone
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* show the current total requested allocations in bytes */
end_comment

begin_function
name|local
name|void
name|mem_used
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|strm
operator|->
name|opaque
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %lu allocated\n"
argument_list|,
name|prefix
argument_list|,
name|zone
operator|->
name|total
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* show the high water allocation in bytes */
end_comment

begin_function
name|local
name|void
name|mem_high
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|strm
operator|->
name|opaque
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %lu high water mark\n"
argument_list|,
name|prefix
argument_list|,
name|zone
operator|->
name|highwater
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* release the memory allocation zone -- if there are any surprises, notify */
end_comment

begin_function
name|local
name|void
name|mem_done
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|mem_item
modifier|*
name|item
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|mem_zone
modifier|*
name|zone
init|=
name|strm
operator|->
name|opaque
decl_stmt|;
comment|/* show high water mark */
name|mem_high
argument_list|(
name|strm
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|/* free leftover allocations and item structures, if any */
name|item
operator|=
name|zone
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|item
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|next
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* issue alerts about anything unexpected */
if|if
condition|(
name|count
operator|||
name|zone
operator|->
name|total
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** %s: %lu bytes in %d blocks not freed\n"
argument_list|,
name|prefix
argument_list|,
name|zone
operator|->
name|total
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|notlifo
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** %s: %d frees not LIFO\n"
argument_list|,
name|prefix
argument_list|,
name|zone
operator|->
name|notlifo
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|rogue
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** %s: %d frees not recognized\n"
argument_list|,
name|prefix
argument_list|,
name|zone
operator|->
name|rogue
argument_list|)
expr_stmt|;
comment|/* free the zone and delete from the stream */
name|free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -- inflate test routines -- */
end_comment

begin_comment
comment|/* Decode a hexadecimal string, set *len to length, in[] to the bytes.  This    decodes liberally, in that hex digits can be adjacent, in which case two in    a row writes a byte.  Or they can delimited by any non-hex character, where    the delimiters are ignored except when a single hex digit is followed by a    delimiter in which case that single digit writes a byte.  The returned    data is allocated and must eventually be freed.  NULL is returned if out of    memory.  If the length is not needed, then len can be NULL. */
end_comment

begin_function
name|local
name|unsigned
name|char
modifier|*
name|h2b
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|unsigned
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
name|unsigned
name|next
decl_stmt|,
name|val
decl_stmt|;
name|in
operator|=
name|malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|hex
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|next
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|hex
operator|>=
literal|'0'
operator|&&
operator|*
name|hex
operator|<=
literal|'9'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|*
name|hex
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|hex
operator|>=
literal|'A'
operator|&&
operator|*
name|hex
operator|<=
literal|'F'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|*
name|hex
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|hex
operator|>=
literal|'a'
operator|&&
operator|*
name|hex
operator|<=
literal|'f'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|*
name|hex
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|!=
literal|1
operator|&&
name|val
operator|<
literal|32
condition|)
comment|/* one digit followed by delimiter */
name|val
operator|+=
literal|240
expr_stmt|;
comment|/* make it look like two digits */
if|if
condition|(
name|val
operator|>
literal|255
condition|)
block|{
comment|/* have two digits */
name|in
index|[
name|next
operator|++
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
comment|/* save the decoded byte */
name|val
operator|=
literal|1
expr_stmt|;
comment|/* start over */
block|}
block|}
do|while
condition|(
operator|*
name|hex
operator|++
condition|)
do|;
comment|/* go through the loop with the terminating null */
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
name|next
expr_stmt|;
name|in
operator|=
name|reallocf
argument_list|(
name|in
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* generic inflate() run, where hex is the hexadecimal input data, what is the    text to include in an error message, step is how much input data to feed    inflate() on each call, or zero to feed it all, win is the window bits    parameter to inflateInit2(), len is the size of the output buffer, and err    is the error code expected from the first inflate() call (the second    inflate() call is expected to return Z_STREAM_END).  If win is 47, then    header information is collected with inflateGetHeader().  If a zlib stream    is looking for a dictionary, then an empty dictionary is provided.    inflate() is run until all of the input data is consumed. */
end_comment

begin_function
name|local
name|void
name|inf
parameter_list|(
name|char
modifier|*
name|hex
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|unsigned
name|step
parameter_list|,
name|int
name|win
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|have
decl_stmt|;
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|z_stream
name|strm
decl_stmt|,
name|copy
decl_stmt|;
name|gz_header
name|head
decl_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|out
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|47
condition|)
block|{
name|head
operator|.
name|extra
operator|=
name|out
expr_stmt|;
name|head
operator|.
name|extra_max
operator|=
name|len
expr_stmt|;
name|head
operator|.
name|name
operator|=
name|out
expr_stmt|;
name|head
operator|.
name|name_max
operator|=
name|len
expr_stmt|;
name|head
operator|.
name|comment
operator|=
name|out
expr_stmt|;
name|head
operator|.
name|comm_max
operator|=
name|len
expr_stmt|;
name|ret
operator|=
name|inflateGetHeader
argument_list|(
operator|&
name|strm
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
block|}
name|in
operator|=
name|h2b
argument_list|(
name|hex
argument_list|,
operator|&
name|have
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|in
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
operator|||
name|step
operator|>
name|have
condition|)
name|step
operator|=
name|have
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|step
expr_stmt|;
name|have
operator|-=
name|step
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
do|do
block|{
name|strm
operator|.
name|avail_out
operator|=
name|len
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|err
operator|==
literal|9
operator|||
name|ret
operator|==
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|&&
name|ret
operator|!=
name|Z_BUF_ERROR
operator|&&
name|ret
operator|!=
name|Z_NEED_DICT
condition|)
break|break;
if|if
condition|(
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|inflate_state
operator|*
operator|)
name|strm
operator|.
name|state
operator|)
operator|->
name|mode
operator|=
name|DICT
expr_stmt|;
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|inflateCopy
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|err
operator|=
literal|9
expr_stmt|;
comment|/* don't care next time around */
name|have
operator|+=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|step
operator|>
name|have
condition|?
name|have
else|:
name|step
expr_stmt|;
name|have
operator|-=
name|strm
operator|.
name|avail_in
expr_stmt|;
block|}
do|while
condition|(
name|strm
operator|.
name|avail_in
condition|)
do|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateReset2
argument_list|(
operator|&
name|strm
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cover all of the lines in inflate.c up to inflate() */
end_comment

begin_function
name|local
name|void
name|cover_support
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_used
argument_list|(
operator|&
name|strm
argument_list|,
literal|"inflate init"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflatePrime
argument_list|(
operator|&
name|strm
argument_list|,
literal|5
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflatePrime
argument_list|(
operator|&
name|strm
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
literal|"prime"
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 0"
argument_list|,
literal|"force window allocation"
argument_list|,
literal|0
argument_list|,
operator|-
literal|15
argument_list|,
literal|1
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 18 5"
argument_list|,
literal|"force window replacement"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|259
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 18 68 30 d0 0 0"
argument_list|,
literal|"force split window update"
argument_list|,
literal|4
argument_list|,
operator|-
literal|8
argument_list|,
literal|259
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"3 0"
argument_list|,
literal|"use fixed blocks"
argument_list|,
literal|0
argument_list|,
operator|-
literal|15
argument_list|,
literal|1
argument_list|,
name|Z_STREAM_END
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|""
argument_list|,
literal|"bad window size"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit_
argument_list|(
operator|&
name|strm
argument_list|,
name|ZLIB_VERSION
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_VERSION_ERROR
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
literal|"wrong version"
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"inflate built-in memory routines\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cover all inflate() header and trailer cases and code after inflate() */
end_comment

begin_function
name|local
name|void
name|cover_wrap
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|z_stream
name|strm
decl_stmt|,
name|copy
decl_stmt|;
name|unsigned
name|char
name|dict
index|[
literal|257
index|]
decl_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateCopy
argument_list|(
name|Z_NULL
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"inflate bad parameters\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"1f 8b 0 0"
argument_list|,
literal|"bad gzip method"
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"1f 8b 8 80"
argument_list|,
literal|"bad gzip flags"
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"77 85"
argument_list|,
literal|"bad zlib method"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"8 99"
argument_list|,
literal|"set window size from header"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"78 9c"
argument_list|,
literal|"bad zlib window size"
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"78 9c 63 0 0 0 1 0 1"
argument_list|,
literal|"check adler32"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|,
name|Z_STREAM_END
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0"
argument_list|,
literal|"bad header crc"
argument_list|,
literal|0
argument_list|,
literal|47
argument_list|,
literal|1
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0"
argument_list|,
literal|"check gzip length"
argument_list|,
literal|0
argument_list|,
literal|47
argument_list|,
literal|0
argument_list|,
name|Z_STREAM_END
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"78 90"
argument_list|,
literal|"bad zlib header check"
argument_list|,
literal|0
argument_list|,
literal|47
argument_list|,
literal|0
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"8 b8 0 0 0 1"
argument_list|,
literal|"need dictionary"
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|Z_NEED_DICT
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"78 9c 63 0"
argument_list|,
literal|"compute adler32"
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|2
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
literal|"\x63"
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
literal|1
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ret
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dict
argument_list|,
literal|0
argument_list|,
literal|257
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|dict
argument_list|,
literal|257
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_state
argument_list|)
operator|<<
literal|1
operator|)
operator|+
literal|256
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflatePrime
argument_list|(
operator|&
name|strm
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|2
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
literal|"\x80"
expr_stmt|;
name|ret
operator|=
name|inflateSync
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|4
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
literal|"\0\0\xff\xff"
expr_stmt|;
name|ret
operator|=
name|inflateSync
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inflateSyncPoint
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateCopy
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
name|mem_limit
argument_list|(
operator|&
name|strm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateUndermine
argument_list|(
operator|&
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inflateMark
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
literal|"miscellaneous, force memory errors"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* input and output functions for inflateBack() */
end_comment

begin_function
name|local
name|unsigned
name|pull
parameter_list|(
name|void
modifier|*
name|desc
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|next
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|dat
index|[]
init|=
block|{
literal|0x63
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|inflate_state
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|desc
operator|==
name|Z_NULL
condition|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* no input (already provided at next_in) */
block|}
name|state
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|z_stream
operator|*
operator|)
name|desc
operator|)
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|Z_NULL
condition|)
name|state
operator|->
name|mode
operator|=
name|SYNC
expr_stmt|;
comment|/* force an otherwise impossible situation */
return|return
name|next
operator|<
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
condition|?
operator|(
operator|*
name|buf
operator|=
name|dat
operator|+
name|next
operator|++
operator|,
literal|1
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_function
name|local
name|int
name|push
parameter_list|(
name|void
modifier|*
name|desc
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|buf
operator|+=
name|len
expr_stmt|;
return|return
name|desc
operator|!=
name|Z_NULL
return|;
comment|/* force error if desc not null */
block|}
end_function

begin_comment
comment|/* cover inflateBack() up to common deflate data cases and after those */
end_comment

begin_function
name|local
name|void
name|cover_back
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|unsigned
name|char
name|win
index|[
literal|32768
index|]
decl_stmt|;
name|ret
operator|=
name|inflateBackInit_
argument_list|(
name|Z_NULL
argument_list|,
literal|0
argument_list|,
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_VERSION_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackInit
argument_list|(
name|Z_NULL
argument_list|,
literal|0
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBack
argument_list|(
name|Z_NULL
argument_list|,
name|Z_NULL
argument_list|,
name|Z_NULL
argument_list|,
name|Z_NULL
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackEnd
argument_list|(
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"inflateBack bad parameters\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackInit
argument_list|(
operator|&
name|strm
argument_list|,
literal|15
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|2
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
literal|"\x03"
expr_stmt|;
name|ret
operator|=
name|inflateBack
argument_list|(
operator|&
name|strm
argument_list|,
name|pull
argument_list|,
name|Z_NULL
argument_list|,
name|push
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_END
argument_list|)
expr_stmt|;
comment|/* force output error */
name|strm
operator|.
name|avail_in
operator|=
literal|3
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
literal|"\x63\x00"
expr_stmt|;
name|ret
operator|=
name|inflateBack
argument_list|(
operator|&
name|strm
argument_list|,
name|pull
argument_list|,
name|Z_NULL
argument_list|,
name|push
argument_list|,
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
comment|/* force mode error by mucking with state */
name|ret
operator|=
name|inflateBack
argument_list|(
operator|&
name|strm
argument_list|,
name|pull
argument_list|,
operator|&
name|strm
argument_list|,
name|push
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
literal|"inflateBack bad state"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackInit
argument_list|(
operator|&
name|strm
argument_list|,
literal|15
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"inflateBack built-in memory routines\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do a raw inflate of data in hexadecimal with both inflate and inflateBack */
end_comment

begin_function
name|local
name|int
name|try
parameter_list|(
name|char
modifier|*
name|hex
parameter_list|,
name|char
modifier|*
name|id
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|win
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
comment|/* convert to hex */
name|in
operator|=
name|h2b
argument_list|(
name|hex
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|in
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* allocate work areas */
name|size
operator|=
name|len
operator|<<
literal|3
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|out
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|win
operator|=
name|malloc
argument_list|(
literal|32768
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|win
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|id
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prefix
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* first with inflate */
name|strcpy
argument_list|(
name|prefix
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|prefix
argument_list|,
literal|"-late"
argument_list|)
expr_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
name|err
operator|<
literal|0
condition|?
literal|47
else|:
operator|-
literal|15
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
do|do
block|{
name|strm
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_TREES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
operator|&&
name|ret
operator|!=
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_DATA_ERROR
operator|||
name|ret
operator|==
name|Z_NEED_DICT
condition|)
break|break;
block|}
do|while
condition|(
name|strm
operator|.
name|avail_in
operator|||
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|err
condition|)
block|{
name|assert
argument_list|(
name|ret
operator|==
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|strm
operator|.
name|msg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|/* then with inflateBack */
if|if
condition|(
name|err
operator|>=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|prefix
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|prefix
argument_list|,
literal|"-back"
argument_list|)
expr_stmt|;
name|mem_setup
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateBackInit
argument_list|(
operator|&
name|strm
argument_list|,
literal|15
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_OK
argument_list|)
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|ret
operator|=
name|inflateBack
argument_list|(
operator|&
name|strm
argument_list|,
name|pull
argument_list|,
name|Z_NULL
argument_list|,
name|push
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|assert
argument_list|(
name|ret
operator|==
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|strm
operator|.
name|msg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|inflateBackEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|mem_done
argument_list|(
operator|&
name|strm
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* cover deflate data cases in both inflate() and inflateBack() */
end_comment

begin_function
name|local
name|void
name|cover_inflate
parameter_list|(
name|void
parameter_list|)
block|{
name|try
argument_list|(
literal|"0 0 0 0 0"
argument_list|,
literal|"invalid stored block lengths"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"3 0"
argument_list|,
literal|"fixed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"6"
argument_list|,
literal|"invalid block type"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"1 1 0 fe ff 0"
argument_list|,
literal|"stored"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"fc 0 0"
argument_list|,
literal|"too many length or distance symbols"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 0 fe ff"
argument_list|,
literal|"invalid code lengths set"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 0 24 49 0"
argument_list|,
literal|"invalid bit length repeat"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 0 24 e9 ff ff"
argument_list|,
literal|"invalid bit length repeat"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 0 24 e9 ff 6d"
argument_list|,
literal|"invalid code -- missing end-of-block"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 80 49 92 24 49 92 24 71 ff ff 93 11 0"
argument_list|,
literal|"invalid literal/lengths set"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 80 49 92 24 49 92 24 f b4 ff ff c3 84"
argument_list|,
literal|"invalid distances set"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"4 c0 81 8 0 0 0 0 20 7f eb b 0 0"
argument_list|,
literal|"invalid literal/length code"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"2 7e ff ff"
argument_list|,
literal|"invalid distance code"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"c c0 81 0 0 0 0 0 90 ff 6b 4 0"
argument_list|,
literal|"invalid distance too far back"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* also trailer mismatch just in inflate() */
name|try
argument_list|(
literal|"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1"
argument_list|,
literal|"incorrect data check"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1"
argument_list|,
literal|"incorrect length check"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c"
argument_list|,
literal|"pull 17"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f"
argument_list|,
literal|"long code"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f"
argument_list|,
literal|"length extra"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c"
argument_list|,
literal|"long distance and extra"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|try
argument_list|(
literal|"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
literal|"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6"
argument_list|,
literal|"window end"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"2 8 20 80 0 3 0"
argument_list|,
literal|"inflate_fast TYPE return"
argument_list|,
literal|0
argument_list|,
operator|-
literal|15
argument_list|,
literal|258
argument_list|,
name|Z_STREAM_END
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 18 5 40 c 0"
argument_list|,
literal|"window wrap"
argument_list|,
literal|3
argument_list|,
operator|-
literal|8
argument_list|,
literal|300
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cover remaining lines in inftrees.c */
end_comment

begin_function
name|local
name|void
name|cover_trees
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
name|unsigned
name|short
name|lens
index|[
literal|16
index|]
decl_stmt|,
name|work
index|[
literal|16
index|]
decl_stmt|;
name|code
modifier|*
name|next
decl_stmt|,
name|table
index|[
name|ENOUGH_DISTS
index|]
decl_stmt|;
comment|/* we need to call inflate_table() directly in order to manifest not-        enough errors, since zlib insures that enough is always enough */
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|bits
operator|<
literal|15
condition|;
name|bits
operator|++
control|)
name|lens
index|[
name|bits
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|bits
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lens
index|[
literal|15
index|]
operator|=
literal|15
expr_stmt|;
name|next
operator|=
name|table
expr_stmt|;
name|bits
operator|=
literal|15
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|lens
argument_list|,
literal|16
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|bits
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
expr_stmt|;
name|next
operator|=
name|table
expr_stmt|;
name|bits
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|lens
argument_list|,
literal|16
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|bits
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"inflate_table not enough errors\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cover remaining inffast.c decoding and window copying */
end_comment

begin_function
name|local
name|void
name|cover_fast
parameter_list|(
name|void
parameter_list|)
block|{
name|inf
argument_list|(
literal|"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68"
literal|" ff 7f 0f 0 0 0"
argument_list|,
literal|"fast length extra bits"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|258
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49"
literal|" 50 fe ff ff 3f 0 0"
argument_list|,
literal|"fast distance extra bits"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|258
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"3 7e 0 0 0 0 0"
argument_list|,
literal|"fast invalid distance code"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|258
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"1b 7 0 0 0 0 0"
argument_list|,
literal|"fast invalid literal/length code"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|258
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0"
argument_list|,
literal|"fast 2nd level codes and too far back"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|258
argument_list|,
name|Z_DATA_ERROR
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 18 5 8c 10 8 0 0 0 0"
argument_list|,
literal|"very common case"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|259
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0"
argument_list|,
literal|"contiguous and wrap around window"
argument_list|,
literal|6
argument_list|,
operator|-
literal|8
argument_list|,
literal|259
argument_list|,
name|Z_OK
argument_list|)
expr_stmt|;
name|inf
argument_list|(
literal|"63 0 3 0 0 0 0 0"
argument_list|,
literal|"copy direct from output"
argument_list|,
literal|0
argument_list|,
operator|-
literal|8
argument_list|,
literal|259
argument_list|,
name|Z_STREAM_END
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zlibVersion
argument_list|()
argument_list|)
expr_stmt|;
name|cover_support
argument_list|()
expr_stmt|;
name|cover_wrap
argument_list|()
expr_stmt|;
name|cover_back
argument_list|()
expr_stmt|;
name|cover_inflate
argument_list|()
expr_stmt|;
name|cover_trees
argument_list|()
expr_stmt|;
name|cover_fast
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

