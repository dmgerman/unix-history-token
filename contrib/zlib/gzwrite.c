begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzwrite.c -- zlib functions for writing gzip files  * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"gzguts.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* Local functions */
end_comment

begin_decl_stmt
name|local
name|int
name|gz_init
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_comp
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_zero
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|z_off64_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|z_size_t
name|gz_write
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|voidpc
operator|,
name|z_size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize state for writing a gzip file.  Mark initialization by setting    state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on    success. */
end_comment

begin_function
name|local
name|int
name|gz_init
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* allocate input buffer (double size for gzprintf) */
name|state
operator|->
name|in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|state
operator|->
name|want
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|in
operator|==
name|NULL
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* only need output buffer and deflate state if compressing */
if|if
condition|(
operator|!
name|state
operator|->
name|direct
condition|)
block|{
comment|/* allocate output buffer */
name|state
operator|->
name|out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|state
operator|->
name|want
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|out
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* allocate deflate memory, set up for gzip compression */
name|strm
operator|->
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit2
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
name|MAX_WBITS
operator|+
literal|16
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|state
operator|->
name|strategy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|free
argument_list|(
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strm
operator|->
name|next_in
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* mark state as initialized */
name|state
operator|->
name|size
operator|=
name|state
operator|->
name|want
expr_stmt|;
comment|/* initialize write buffer if compressing */
if|if
condition|(
operator|!
name|state
operator|->
name|direct
condition|)
block|{
name|strm
operator|->
name|avail_out
operator|=
name|state
operator|->
name|size
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|state
operator|->
name|out
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|strm
operator|->
name|next_out
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compress whatever is at avail_in and next_in and write to the output file.    Return -1 if there is an error writing to the output file or if gz_init()    fails to allocate memory, otherwise 0.  flush is assumed to be a valid    deflate() flush value.  If flush is Z_FINISH, then the deflate() state is    reset to start a new gzip stream.  If gz->direct is true, then simply write    to the output file without compressing, and ignore flush. */
end_comment

begin_function
name|local
name|int
name|gz_comp
parameter_list|(
name|state
parameter_list|,
name|flush
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|writ
decl_stmt|;
name|unsigned
name|have
decl_stmt|,
name|put
decl_stmt|,
name|max
init|=
operator|(
operator|(
name|unsigned
operator|)
operator|-
literal|1
operator|>>
literal|2
operator|)
operator|+
literal|1
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* allocate memory if this is the first time through */
if|if
condition|(
name|state
operator|->
name|size
operator|==
literal|0
operator|&&
name|gz_init
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write directly if requested */
if|if
condition|(
name|state
operator|->
name|direct
condition|)
block|{
while|while
condition|(
name|strm
operator|->
name|avail_in
condition|)
block|{
name|put
operator|=
name|strm
operator|->
name|avail_in
operator|>
name|max
condition|?
name|max
else|:
name|strm
operator|->
name|avail_in
expr_stmt|;
name|writ
operator|=
name|write
argument_list|(
name|state
operator|->
name|fd
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|writ
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_ERRNO
argument_list|,
name|zstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strm
operator|->
name|avail_in
operator|-=
operator|(
name|unsigned
operator|)
name|writ
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
name|writ
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* run deflate() on provided input until it produces no more output */
name|ret
operator|=
name|Z_OK
expr_stmt|;
do|do
block|{
comment|/* write out current buffer contents if full, or if flushing, but if            doing Z_FINISH then don't write until we get to Z_STREAM_END */
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
operator|||
operator|(
name|flush
operator|!=
name|Z_NO_FLUSH
operator|&&
operator|(
name|flush
operator|!=
name|Z_FINISH
operator|||
name|ret
operator|==
name|Z_STREAM_END
operator|)
operator|)
condition|)
block|{
while|while
condition|(
name|strm
operator|->
name|next_out
operator|>
name|state
operator|->
name|x
operator|.
name|next
condition|)
block|{
name|put
operator|=
name|strm
operator|->
name|next_out
operator|-
name|state
operator|->
name|x
operator|.
name|next
operator|>
operator|(
name|int
operator|)
name|max
condition|?
name|max
else|:
call|(
name|unsigned
call|)
argument_list|(
name|strm
operator|->
name|next_out
operator|-
name|state
operator|->
name|x
operator|.
name|next
argument_list|)
expr_stmt|;
name|writ
operator|=
name|write
argument_list|(
name|state
operator|->
name|fd
argument_list|,
name|state
operator|->
name|x
operator|.
name|next
argument_list|,
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|writ
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_ERRNO
argument_list|,
name|zstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|x
operator|.
name|next
operator|+=
name|writ
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|avail_out
operator|=
name|state
operator|->
name|size
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|state
operator|->
name|out
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|next
operator|=
name|state
operator|->
name|out
expr_stmt|;
block|}
block|}
comment|/* compress */
name|have
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
name|strm
argument_list|,
name|flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"internal error: deflate stream corrupt"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|have
operator|-=
name|strm
operator|->
name|avail_out
expr_stmt|;
block|}
do|while
condition|(
name|have
condition|)
do|;
comment|/* if that completed a deflate stream, allow another to start */
if|if
condition|(
name|flush
operator|==
name|Z_FINISH
condition|)
name|deflateReset
argument_list|(
name|strm
argument_list|)
expr_stmt|;
comment|/* all done, no errors */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compress len zeros to output.  Return -1 on a write error or memory    allocation failure by gz_comp(), or 0 on success. */
end_comment

begin_function
name|local
name|int
name|gz_zero
parameter_list|(
name|state
parameter_list|,
name|len
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|z_off64_t
name|len
decl_stmt|;
block|{
name|int
name|first
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* consume whatever's left in the input buffer */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|&&
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* compress len zeros (len guaranteed> 0) */
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|n
operator|=
name|GT_OFF
argument_list|(
name|state
operator|->
name|size
argument_list|)
operator|||
operator|(
name|z_off64_t
operator|)
name|state
operator|->
name|size
operator|>
name|len
condition|?
operator|(
name|unsigned
operator|)
name|len
else|:
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|memset
argument_list|(
name|state
operator|->
name|in
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|strm
operator|->
name|avail_in
operator|=
name|n
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write len bytes from buf to file.  Return the number of bytes written.  If    the returned value is less than len, then there was an error. */
end_comment

begin_function
name|local
name|z_size_t
name|gz_write
parameter_list|(
name|state
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|voidpc
name|buf
decl_stmt|;
name|z_size_t
name|len
decl_stmt|;
block|{
name|z_size_t
name|put
init|=
name|len
decl_stmt|;
comment|/* if len is zero, avoid unnecessary operations */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* allocate memory if this is the first time through */
if|if
condition|(
name|state
operator|->
name|size
operator|==
literal|0
operator|&&
name|gz_init
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
comment|/* for small len, copy to input buffer, otherwise compress directly */
if|if
condition|(
name|len
operator|<
name|state
operator|->
name|size
condition|)
block|{
comment|/* copy to input buffer, compress when full */
do|do
block|{
name|unsigned
name|have
decl_stmt|,
name|copy
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
name|state
operator|->
name|strm
operator|.
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|have
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|state
operator|->
name|strm
operator|.
name|next_in
operator|+
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|)
operator|-
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|copy
operator|=
name|state
operator|->
name|size
operator|-
name|have
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|len
condition|)
name|copy
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|state
operator|->
name|in
operator|+
name|have
argument_list|,
name|buf
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|+=
name|copy
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|copy
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|+
name|copy
expr_stmt|;
name|len
operator|-=
name|copy
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
name|len
condition|)
do|;
block|}
else|else
block|{
comment|/* consume whatever's left in the input buffer */
if|if
condition|(
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|&&
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* directly compress user buffer to file */
name|state
operator|->
name|strm
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|Bytef
operator|*
operator|)
name|buf
expr_stmt|;
do|do
block|{
name|unsigned
name|n
init|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|=
name|n
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|len
condition|)
do|;
block|}
comment|/* input was all buffered or compressed */
return|return
name|put
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzwrite
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|voidpc
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
literal|0
return|;
comment|/* since an int is returned, make sure len fits in one, otherwise return        with an error (this avoids a flaw in the interface) */
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"requested length does not fit in int"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* write len bytes from buf (the return value will fit in an int) */
return|return
operator|(
name|int
operator|)
name|gz_write
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|z_size_t
name|ZEXPORT
name|gzfwrite
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|file
parameter_list|)
name|voidpc
name|buf
decl_stmt|;
name|z_size_t
name|size
decl_stmt|;
name|z_size_t
name|nitems
decl_stmt|;
name|gzFile
name|file
decl_stmt|;
block|{
name|z_size_t
name|len
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
literal|0
return|;
comment|/* compute bytes to read -- error on overflow */
name|len
operator|=
name|nitems
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|len
operator|/
name|size
operator|!=
name|nitems
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"request does not fit in a size_t"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* write len bytes to buf, return the number of full items written */
return|return
name|len
condition|?
name|gz_write
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|/
name|size
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzputc
parameter_list|(
name|file
parameter_list|,
name|c
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|unsigned
name|have
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
name|z_streamp
name|strm
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
name|strm
operator|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* try writing to input buffer for speed (state->size == 0 if buffer not        initialized) */
if|if
condition|(
name|state
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|have
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|strm
operator|->
name|next_in
operator|+
name|strm
operator|->
name|avail_in
operator|)
operator|-
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|state
operator|->
name|size
condition|)
block|{
name|state
operator|->
name|in
index|[
name|have
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|++
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|++
expr_stmt|;
return|return
name|c
operator|&
literal|0xff
return|;
block|}
block|}
comment|/* no room in buffer or not initialized, use gz_write() */
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|gz_write
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|c
operator|&
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzputs
parameter_list|(
name|file
parameter_list|,
name|str
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|z_size_t
name|len
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write string */
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gz_write
argument_list|(
name|state
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
literal|0
operator|&&
name|len
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_HAVE_STDARG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORTVA
name|gzvprintf
parameter_list|(
name|gzFile
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|va
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|left
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
name|z_streamp
name|strm
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
name|strm
operator|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* make sure we have some buffer space */
if|if
condition|(
name|state
operator|->
name|size
operator|==
literal|0
operator|&&
name|gz_init
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
block|}
comment|/* do the printf() into the input buffer, put length in len -- the input        buffer is double-sized just for this function, so there is guaranteed to        be state->size bytes available after the current contents */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|state
operator|->
name|in
operator|+
operator|(
name|strm
operator|->
name|next_in
operator|-
name|state
operator|->
name|in
operator|)
operator|+
name|strm
operator|->
name|avail_in
operator|)
expr_stmt|;
name|next
index|[
name|state
operator|->
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_vsnprintf
ifdef|#
directive|ifdef
name|HAS_vsprintf_void
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|next
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|state
operator|->
name|size
condition|;
name|len
operator|++
control|)
if|if
condition|(
name|next
index|[
name|len
index|]
operator|==
literal|0
condition|)
break|break;
else|#
directive|else
name|len
operator|=
name|vsprintf
argument_list|(
name|next
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_vsnprintf_void
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|next
argument_list|,
name|state
operator|->
name|size
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|vsnprintf
argument_list|(
name|next
argument_list|,
name|state
operator|->
name|size
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* check that printf() results fit in buffer */
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|(
name|unsigned
operator|)
name|len
operator|>=
name|state
operator|->
name|size
operator|||
name|next
index|[
name|state
operator|->
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* update buffer and position, compress first half if past that */
name|strm
operator|->
name|avail_in
operator|+=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
name|state
operator|->
name|size
condition|)
block|{
name|left
operator|=
name|strm
operator|->
name|avail_in
operator|-
name|state
operator|->
name|size
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
name|memcpy
argument_list|(
name|state
operator|->
name|in
argument_list|,
name|state
operator|->
name|in
operator|+
name|state
operator|->
name|size
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|left
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORTVA
name|gzprintf
parameter_list|(
name|gzFile
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gzvprintf
argument_list|(
name|file
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !STDC&& !Z_HAVE_STDARG_H */
end_comment

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORTVA
name|gzprintf
parameter_list|(
name|file
parameter_list|,
name|format
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|,
name|a6
parameter_list|,
name|a7
parameter_list|,
name|a8
parameter_list|,
name|a9
parameter_list|,
name|a10
parameter_list|,
name|a11
parameter_list|,
name|a12
parameter_list|,
name|a13
parameter_list|,
name|a14
parameter_list|,
name|a15
parameter_list|,
name|a16
parameter_list|,
name|a17
parameter_list|,
name|a18
parameter_list|,
name|a19
parameter_list|,
name|a20
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|,
name|a10
decl_stmt|,
name|a11
decl_stmt|,
name|a12
decl_stmt|,
name|a13
decl_stmt|,
name|a14
decl_stmt|,
name|a15
decl_stmt|,
name|a16
decl_stmt|,
name|a17
decl_stmt|,
name|a18
decl_stmt|,
name|a19
decl_stmt|,
name|a20
decl_stmt|;
block|{
name|unsigned
name|len
decl_stmt|,
name|left
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
name|z_streamp
name|strm
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
name|strm
operator|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
expr_stmt|;
comment|/* check that can really pass pointer in ints */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* make sure we have some buffer space */
if|if
condition|(
name|state
operator|->
name|size
operator|==
literal|0
operator|&&
name|gz_init
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|error
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|error
return|;
block|}
comment|/* do the printf() into the input buffer, put length in len -- the input        buffer is double-sized just for this function, so there is guaranteed to        be state->size bytes available after the current contents */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|strm
operator|->
name|next_in
operator|+
name|strm
operator|->
name|avail_in
operator|)
expr_stmt|;
name|next
index|[
name|state
operator|->
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_snprintf
ifdef|#
directive|ifdef
name|HAS_sprintf_void
name|sprintf
argument_list|(
name|next
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|size
condition|;
name|len
operator|++
control|)
if|if
condition|(
name|next
index|[
name|len
index|]
operator|==
literal|0
condition|)
break|break;
else|#
directive|else
name|len
operator|=
name|sprintf
argument_list|(
name|next
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_snprintf_void
name|snprintf
argument_list|(
name|next
argument_list|,
name|state
operator|->
name|size
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|snprintf
argument_list|(
name|next
argument_list|,
name|state
operator|->
name|size
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* check that printf() results fit in buffer */
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|len
operator|>=
name|state
operator|->
name|size
operator|||
name|next
index|[
name|state
operator|->
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* update buffer and position, compress first half if past that */
name|strm
operator|->
name|avail_in
operator|+=
name|len
expr_stmt|;
name|state
operator|->
name|x
operator|.
name|pos
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
name|state
operator|->
name|size
condition|)
block|{
name|left
operator|=
name|strm
operator|->
name|avail_in
operator|-
name|state
operator|->
name|size
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
name|memcpy
argument_list|(
name|state
operator|->
name|in
argument_list|,
name|state
operator|->
name|in
operator|+
name|state
operator|->
name|size
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|left
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzflush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* check flush parameter */
if|if
condition|(
name|flush
operator|<
literal|0
operator|||
name|flush
operator|>
name|Z_FINISH
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
block|}
comment|/* compress remaining data with requested flush */
operator|(
name|void
operator|)
name|gz_comp
argument_list|(
name|state
argument_list|,
name|flush
argument_list|)
expr_stmt|;
return|return
name|state
operator|->
name|err
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzsetparams
parameter_list|(
name|file
parameter_list|,
name|level
parameter_list|,
name|strategy
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|strategy
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
name|z_streamp
name|strm
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
name|strm
operator|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
expr_stmt|;
comment|/* check that we're writing and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* if no change is requested, then do nothing */
if|if
condition|(
name|level
operator|==
name|state
operator|->
name|level
operator|&&
name|strategy
operator|==
name|state
operator|->
name|strategy
condition|)
return|return
name|Z_OK
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
block|}
comment|/* change compression parameters for subsequent input */
if|if
condition|(
name|state
operator|->
name|size
condition|)
block|{
comment|/* flush previous input with previous parameters before changing */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|&&
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_BLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|state
operator|->
name|err
return|;
name|deflateParams
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|state
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzclose_w
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|ret
init|=
name|Z_OK
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're writing */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_WRITE
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* check for seek request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_zero
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|state
operator|->
name|err
expr_stmt|;
block|}
comment|/* flush, free memory, and close file */
if|if
condition|(
name|gz_comp
argument_list|(
name|state
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|state
operator|->
name|err
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|state
operator|->
name|direct
condition|)
block|{
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|state
operator|->
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|Z_ERRNO
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

