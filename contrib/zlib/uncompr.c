begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uncompr.c -- decompress a memory buffer  * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* @(#) $Id$ */
end_comment

begin_define
define|#
directive|define
name|ZLIB_INTERNAL
end_define

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* ===========================================================================      Decompresses the source buffer into the destination buffer.  *sourceLen is    the byte length of the source buffer. Upon entry, *destLen is the total size    of the destination buffer, which must be large enough to hold the entire    uncompressed data. (The size of the uncompressed data must have been saved    previously by the compressor and transmitted to the decompressor by some    mechanism outside the scope of this compression library.) Upon exit,    *destLen is the size of the decompressed data and *sourceLen is the number    of source bytes consumed. Upon return, source + *sourceLen points to the    first unused input byte.       uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough    memory, Z_BUF_ERROR if there was not enough room in the output buffer, or    Z_DATA_ERROR if the input data was corrupted, including if the input data is    an incomplete zlib stream. */
end_comment

begin_function
name|int
name|ZEXPORT
name|uncompress2
parameter_list|(
name|dest
parameter_list|,
name|destLen
parameter_list|,
name|source
parameter_list|,
name|sourceLen
parameter_list|)
name|Bytef
modifier|*
name|dest
decl_stmt|;
name|uLongf
modifier|*
name|destLen
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|source
decl_stmt|;
name|uLong
modifier|*
name|sourceLen
decl_stmt|;
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|const
name|uInt
name|max
init|=
operator|(
name|uInt
operator|)
operator|-
literal|1
decl_stmt|;
name|uLong
name|len
decl_stmt|,
name|left
decl_stmt|;
name|Byte
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* for detection of incomplete stream when *destLen == 0 */
name|len
operator|=
operator|*
name|sourceLen
expr_stmt|;
if|if
condition|(
operator|*
name|destLen
condition|)
block|{
name|left
operator|=
operator|*
name|destLen
expr_stmt|;
operator|*
name|destLen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
literal|1
expr_stmt|;
name|dest
operator|=
name|buf
expr_stmt|;
block|}
name|stream
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|Bytef
operator|*
operator|)
name|source
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|stream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|err
operator|=
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|err
return|;
name|stream
operator|.
name|next_out
operator|=
name|dest
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|stream
operator|.
name|avail_out
operator|=
name|left
operator|>
operator|(
name|uLong
operator|)
name|max
condition|?
name|max
else|:
operator|(
name|uInt
operator|)
name|left
expr_stmt|;
name|left
operator|-=
name|stream
operator|.
name|avail_out
expr_stmt|;
block|}
if|if
condition|(
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|stream
operator|.
name|avail_in
operator|=
name|len
operator|>
operator|(
name|uLong
operator|)
name|max
condition|?
name|max
else|:
operator|(
name|uInt
operator|)
name|len
expr_stmt|;
name|len
operator|-=
name|stream
operator|.
name|avail_in
expr_stmt|;
block|}
name|err
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
name|Z_OK
condition|)
do|;
operator|*
name|sourceLen
operator|-=
name|len
operator|+
name|stream
operator|.
name|avail_in
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|buf
condition|)
operator|*
name|destLen
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
elseif|else
if|if
condition|(
name|stream
operator|.
name|total_out
operator|&&
name|err
operator|==
name|Z_BUF_ERROR
condition|)
name|left
operator|=
literal|1
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
return|return
name|err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|err
operator|==
name|Z_NEED_DICT
condition|?
name|Z_DATA_ERROR
else|:
name|err
operator|==
name|Z_BUF_ERROR
operator|&&
name|left
operator|+
name|stream
operator|.
name|avail_out
condition|?
name|Z_DATA_ERROR
else|:
name|err
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|uncompress
parameter_list|(
name|dest
parameter_list|,
name|destLen
parameter_list|,
name|source
parameter_list|,
name|sourceLen
parameter_list|)
name|Bytef
modifier|*
name|dest
decl_stmt|;
name|uLongf
modifier|*
name|destLen
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|source
decl_stmt|;
name|uLong
name|sourceLen
decl_stmt|;
block|{
return|return
name|uncompress2
argument_list|(
name|dest
argument_list|,
name|destLen
argument_list|,
name|source
argument_list|,
operator|&
name|sourceLen
argument_list|)
return|;
block|}
end_function

end_unit

