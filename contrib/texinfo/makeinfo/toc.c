begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* toc.c -- table of contents handling.    $Id: toc.c,v 1.6 2004/04/11 17:56:47 karl Exp $     Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Originally written by Karl Heinz Marbaise<kama@hippo.fido.de>.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"sectioning.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* array of toc entries */
end_comment

begin_decl_stmt
specifier|static
name|TOC_ENTRY_ELT
modifier|*
modifier|*
name|toc_entry_alist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* toc_counter start from 0 ... n for every @chapter, @section ... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|toc_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routine to add an entry to the table of contents */
end_comment

begin_function
name|int
name|toc_add_entry
parameter_list|(
name|char
modifier|*
name|tocname
parameter_list|,
name|int
name|level
parameter_list|,
name|char
modifier|*
name|node_name
parameter_list|,
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|char
modifier|*
name|tocname_and_node
decl_stmt|,
modifier|*
name|expanded_node
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|node_name
condition|)
name|node_name
operator|=
literal|""
expr_stmt|;
comment|/* I assume that xrealloc behaves like xmalloc if toc_entry_alist is      NULL */
name|toc_entry_alist
operator|=
name|xrealloc
argument_list|(
name|toc_entry_alist
argument_list|,
operator|(
name|toc_counter
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|TOC_ENTRY_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TOC_ENTRY_ELT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
comment|/* We need to insert the expanded node name into the toc, so          that when we eventually output the toc, its<a ref= link will          point to the<a name= tag created by cm_node in the navigation          bar.  We cannot expand the containing_node member, for the          reasons explained in the WARNING below.  We also cannot wait          with the node name expansion until the toc is actually output,          since by that time the macro definitions may have been changed.          So instead we store in the tocname member the expanded node          name and the toc name concatenated together (with the necessary          html markup), since that's how they are output.  */
if|if
condition|(
operator|!
name|anchor
condition|)
name|s
operator|=
name|expanded_node
operator|=
name|expand_node_name
argument_list|(
name|node_name
argument_list|)
expr_stmt|;
else|else
name|expanded_node
operator|=
name|anchor
expr_stmt|;
if|if
condition|(
name|splitting
condition|)
block|{
if|if
condition|(
operator|!
name|anchor
condition|)
name|filename
operator|=
name|nodename_to_filename
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
else|else
name|filename
operator|=
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Sigh...  Need to HTML-escape the expanded node name like          add_anchor_name does, except that we are not writing this to          the output, so can't use add_anchor_name...  */
comment|/* The factor 5 in the next allocation is because the maximum          expansion of HTML-escaping is for the& character, which is          output as "&amp;".  2 is for "> that separates node from tocname.  */
name|d
operator|=
name|tocname_and_node
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
literal|5
operator|*
name|strlen
argument_list|(
name|expanded_node
argument_list|)
operator|+
name|strlen
argument_list|(
name|tocname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|cr_or_whitespace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|URL_SAFE_CHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"_00%x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* do this manually since sprintf returns char * on                      SunOS 4 and other old systems.  */
while|while
condition|(
operator|*
name|d
condition|)
name|d
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"\">"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Section outside any node, they provided explicit anchor.  */
name|strcpy
argument_list|(
name|d
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|d
argument_list|,
name|tocname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tocname
argument_list|)
expr_stmt|;
comment|/* it was malloc'ed by substring() */
name|free
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|name
operator|=
name|tocname_and_node
expr_stmt|;
block|}
else|else
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|name
operator|=
name|tocname
expr_stmt|;
comment|/* WARNING!  The node name saved in containing_node member must      be the node name with _only_ macros expanded (the macros in      the node name are expanded by cm_node when it grabs the name      from the @node directive).  Non-macros, like @value, @@ and      other @-commands must NOT be expanded in containing_node,      because toc_find_section_of_node looks up the node name where      they are also unexpanded.  You *have* been warned!  */
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|containing_node
operator|=
name|xstrdup
argument_list|(
name|node_name
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|number
operator|=
name|toc_counter
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|html_file
operator|=
name|filename
expr_stmt|;
comment|/* have to be done at least */
return|return
name|toc_counter
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Return the name of a chapter/section/subsection etc. that    corresponds to the node NODE.  If the node isn't found,    return NULL.     WARNING!  This function relies on NODE being unexpanded    except for macros (i.e., @value, @@, and other non-macros    should NOT be expanded), because the containing_node member    stores unexpanded node names.     Note that this function returns the first section whose    containing node is NODE.  Thus, they will lose if they use    more than a single chapter structioning command in a node,    or if they have a node without any structuring commands.  */
end_comment

begin_function
name|char
modifier|*
name|toc_find_section_of_node
parameter_list|(
name|char
modifier|*
name|node
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|node
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|containing_node
argument_list|)
condition|)
return|return
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* free up memory used by toc entries */
end_comment

begin_function
name|void
name|toc_free
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|toc_counter
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|toc_entry_alist
argument_list|)
expr_stmt|;
name|toc_entry_alist
operator|=
name|NULL
expr_stmt|;
comment|/* to be sure ;-) */
name|toc_counter
operator|=
literal|0
expr_stmt|;
comment|/* to be absolutley sure ;-) */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print table of contents in HTML.  */
end_comment

begin_function
specifier|static
name|void
name|contents_update_html
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|last_level
decl_stmt|;
comment|/* does exist any toc? */
if|if
condition|(
operator|!
name|toc_counter
condition|)
comment|/* no, so return to sender ;-) */
return|return;
name|add_html_block_elt_args
argument_list|(
literal|"\n<div class=\"contents\">\n<h2>%s</h2>\n<ul>\n"
argument_list|,
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|)
expr_stmt|;
name|last_level
operator|=
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|>
name|last_level
condition|)
block|{
comment|/* unusual, but it is possible              @chapter ...              @subsubsection ...      ? */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|-
name|last_level
operator|)
condition|;
name|k
operator|++
control|)
name|add_html_block_elt
argument_list|(
literal|"<ul>\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|<
name|last_level
condition|)
block|{
comment|/* @subsubsection ...              @chapter ... this IS usual.*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|last_level
operator|-
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|)
condition|;
name|k
operator|++
control|)
name|add_word
argument_list|(
literal|"</li></ul>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* No double entries in TOC.  */
if|if
condition|(
operator|!
operator|(
name|i
operator|&&
name|strcmp
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|toc_entry_alist
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* each toc entry is a list item.  */
name|add_word
argument_list|(
literal|"<li>"
argument_list|)
expr_stmt|;
comment|/* Insert link -- to an external file if splitting, or              within the current document if not splitting.  */
name|add_word
argument_list|(
literal|"<a "
argument_list|)
expr_stmt|;
comment|/* For chapters (only), insert an anchor that the short contents              will link to.  */
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
comment|/* toc_entry_alist[i]->name has the form `foo">bar', 		 that is, it includes both the node name and anchor 		 text.  We need to find where `foo', the node name, 		 ends, and use that in toc_FOO.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
name|add_word_args
argument_list|(
literal|"name=\"toc_%.*s\" "
argument_list|,
name|p
operator|-
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"href=\"%s#%s</a>\n"
argument_list|,
name|splitting
condition|?
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|html_file
else|:
literal|""
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|last_level
operator|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
expr_stmt|;
block|}
comment|/* Go back to start level. */
if|if
condition|(
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
operator|<
name|last_level
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|last_level
operator|-
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
operator|)
condition|;
name|k
operator|++
control|)
name|add_word
argument_list|(
literal|"</li></ul>\n"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</li></ul>\n</div>\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print table of contents in ASCII (--no-headers)    May be we should create a new command line switch --ascii ? */
end_comment

begin_function
specifier|static
name|void
name|contents_update_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|insert_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* indention with two spaces per level, should this          changed? */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
condition|;
name|k
operator|++
control|)
name|insert_string
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|insert_string
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shortcontents in HTML; Should this produce a standalone file? */
end_comment

begin_function
specifier|static
name|void
name|shortcontents_update_html
parameter_list|(
name|char
modifier|*
name|contents_filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|toc_file
init|=
name|NULL
decl_stmt|;
comment|/* does exist any toc? */
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|add_html_block_elt_args
argument_list|(
literal|"\n<div class=\"shortcontents\">\n<h2>%s</h2>\n<ul>\n"
argument_list|,
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents_filename
condition|)
name|toc_file
operator|=
name|filename_part
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|contents_filename
condition|)
name|add_word_args
argument_list|(
literal|"<li><a href=\"%s#toc_%s</a></li>\n"
argument_list|,
name|splitting
condition|?
name|toc_file
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|add_word_args
argument_list|(
literal|"<a href=\"%s#%s</a>\n"
argument_list|,
name|splitting
condition|?
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|html_file
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|add_word
argument_list|(
literal|"</ul>\n</div>\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents_filename
condition|)
name|free
argument_list|(
name|toc_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* short contents in ASCII (--no-headers).  */
end_comment

begin_function
specifier|static
name|void
name|shortcontents_update_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|insert_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
block|{
name|insert_string
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|insert_string
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_contents
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* the file where we found the @contents directive */
specifier|static
name|char
modifier|*
name|contents_filename
decl_stmt|;
comment|/* No need to mess with delayed stuff for XML and Docbook.  */
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|int
name|elt
init|=
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"contents"
argument_list|)
condition|?
name|CONTENTS
else|:
name|SHORTCONTENTS
decl_stmt|;
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|elt
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|handling_delayed_writes
condition|)
block|{
name|register_delayed_write
argument_list|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"contents"
argument_list|)
condition|?
literal|"@contents"
else|:
literal|"@shortcontents"
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|&&
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"contents"
argument_list|)
condition|)
block|{
if|if
condition|(
name|contents_filename
condition|)
name|free
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
name|contents_filename
operator|=
name|xstrdup
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|html
condition|)
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"contents"
argument_list|)
condition|?
name|contents_update_html
argument_list|()
else|:
name|shortcontents_update_html
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|no_headers
condition|)
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"contents"
argument_list|)
condition|?
name|contents_update_info
argument_list|()
else|:
name|shortcontents_update_info
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

