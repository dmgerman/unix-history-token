begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* toc.c -- table of contents handling.    $Id: toc.c,v 1.21 2002/02/23 19:12:15 karl Exp $     Copyright (C) 1999, 2000, 01, 02 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Karl Heinz Marbaise<kama@hippo.fido.de>.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"sectioning.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* array of toc entries */
end_comment

begin_decl_stmt
specifier|static
name|TOC_ENTRY_ELT
modifier|*
modifier|*
name|toc_entry_alist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* toc_counter start from 0 ... n for every @chapter, @section ... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|toc_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the file where we found the @contents directive */
end_comment

begin_decl_stmt
name|char
modifier|*
name|contents_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the file where we found the @shortcontents directive */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shortcontents_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|contents_placebo
index|[]
init|=
literal|"\n...Table of Contents...\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|shortcontents_placebo
index|[]
init|=
literal|"\n...Short Contents...\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|lots_of_stars
index|[]
init|=
literal|"***************************************************************************"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routine to add an entry to the table of contents */
end_comment

begin_function
name|int
name|toc_add_entry
parameter_list|(
name|tocname
parameter_list|,
name|level
parameter_list|,
name|node_name
parameter_list|,
name|anchor
parameter_list|)
name|char
modifier|*
name|tocname
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
modifier|*
name|node_name
decl_stmt|;
name|char
modifier|*
name|anchor
decl_stmt|;
block|{
name|char
modifier|*
name|tocname_and_node
decl_stmt|,
modifier|*
name|expanded_node
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|node_name
condition|)
name|node_name
operator|=
literal|""
expr_stmt|;
comment|/* I assume that xrealloc behaves like xmalloc if toc_entry_alist is      NULL */
name|toc_entry_alist
operator|=
name|xrealloc
argument_list|(
name|toc_entry_alist
argument_list|,
operator|(
name|toc_counter
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|TOC_ENTRY_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TOC_ENTRY_ELT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
comment|/* We need to insert the expanded node name into the TOC, so          that when we eventually output the TOC, its<A REF= link will          point to the<A NAME= tag created by cm_node in the navigation          bar.  We cannot expand the containing_node member, for the          reasons explained in the WARNING below.  We also cannot wait          with the node name expansion until the TOC is actually output,          since by that time the macro definitions may have been changed.          So instead we store in the tocname member the expanded node          name and the TOC name concatenated together (with the necessary          HTML markup), since that's how they are output.  */
if|if
condition|(
operator|!
name|anchor
condition|)
name|s
operator|=
name|expanded_node
operator|=
name|expand_node_name
argument_list|(
name|node_name
argument_list|)
expr_stmt|;
else|else
name|expanded_node
operator|=
name|anchor
expr_stmt|;
if|if
condition|(
name|splitting
condition|)
block|{
if|if
condition|(
operator|!
name|anchor
condition|)
name|filename
operator|=
name|nodename_to_filename
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
else|else
name|filename
operator|=
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Sigh...  Need to HTML-escape the expanded node name like          add_anchor_name does, except that we are not writing this to          the output, so can't use add_anchor_name...  */
comment|/* The factor 5 in the next allocation is because the maximum          expansion of HTML-escaping is for the& character, which is          output as "&amp;".  2 is for "> that separates node from tocname.  */
name|d
operator|=
name|tocname_and_node
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
literal|5
operator|*
name|strlen
argument_list|(
name|expanded_node
argument_list|)
operator|+
name|strlen
argument_list|(
name|tocname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'&'
condition|)
block|{
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|URL_SAFE_CHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"%%%x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* do this manually since sprintf returns char * on                      SunOS 4 and other old systems.  */
while|while
condition|(
operator|*
name|d
condition|)
name|d
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"\">"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Section outside any node, they provided explicit anchor.  */
name|strcpy
argument_list|(
name|d
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|d
argument_list|,
name|tocname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tocname
argument_list|)
expr_stmt|;
comment|/* it was malloc'ed by substring() */
name|free
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|name
operator|=
name|tocname_and_node
expr_stmt|;
block|}
else|else
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|name
operator|=
name|tocname
expr_stmt|;
comment|/* WARNING!  The node name saved in containing_node member must      be the node name with _only_ macros expanded (the macros in      the node name are expanded by cm_node when it grabs the name      from the @node directive).  Non-macros, like @value, @@ and      other @-commands must NOT be expanded in containing_node,      because toc_find_section_of_node looks up the node name where      they are also unexpanded.  You *have* been warned!  */
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|containing_node
operator|=
name|xstrdup
argument_list|(
name|node_name
argument_list|)
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|number
operator|=
name|toc_counter
expr_stmt|;
name|toc_entry_alist
index|[
name|toc_counter
index|]
operator|->
name|html_file
operator|=
name|filename
expr_stmt|;
comment|/* have to be done at least */
return|return
name|toc_counter
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Return the name of a chapter/section/subsection etc. that    corresponds to the node NODE.  If the node isn't found,    return NULL.     WARNING!  This function relies on NODE being unexpanded    except for macros (i.e., @value, @@, and other non-macros    should NOT be expanded), because the containing_node member    stores unexpanded node names.     Note that this function returns the first section whose    containing node is NODE.  Thus, they will lose if they use    more than a single chapter structioning command in a node,    or if they have a node without any structuring commands.  */
end_comment

begin_function
name|char
modifier|*
name|toc_find_section_of_node
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|node
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|containing_node
argument_list|)
condition|)
return|return
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* free up memory used by toc entries */
end_comment

begin_function
name|void
name|toc_free
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|toc_counter
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|toc_entry_alist
argument_list|)
expr_stmt|;
name|toc_entry_alist
operator|=
name|NULL
expr_stmt|;
comment|/* to be sure ;-) */
name|toc_counter
operator|=
literal|0
expr_stmt|;
comment|/* to be absolutley sure ;-) */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print table of contents in HTML.  */
end_comment

begin_function
specifier|static
name|void
name|contents_update_html
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|last_level
decl_stmt|;
comment|/* does exist any toc? */
if|if
condition|(
operator|!
name|toc_counter
condition|)
comment|/* no, so return to sender ;-) */
return|return;
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case we are writing stdout */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n<h2>%s</h2>\n<ul>\n"
argument_list|,
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|)
expr_stmt|;
name|last_level
operator|=
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|>
name|last_level
condition|)
block|{
comment|/* unusual, but it is possible              @chapter ...              @subsubsection ...      ? */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|-
name|last_level
operator|)
condition|;
name|k
operator|++
control|)
name|fputs
argument_list|(
literal|"<ul>\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|<
name|last_level
condition|)
block|{
comment|/* @subsubsection ...              @chapter ... this IS usual.*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|last_level
operator|-
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|)
condition|;
name|k
operator|++
control|)
name|fputs
argument_list|(
literal|"</ul>\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* No double entries in TOC.  */
if|if
condition|(
operator|!
operator|(
name|i
operator|&&
name|strcmp
argument_list|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|toc_entry_alist
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* each toc entry is a list item.  */
name|fputs
argument_list|(
literal|"<li>"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* For chapters (only), insert an anchor that the short contents              will link to.  */
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
comment|/* toc_entry_alist[i]->name has the form `foo">bar', 		 that is, it includes both the node name and anchor 		 text.  We need to find where `foo', the node name, 		 ends, and use that in toc_FOO.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<a name=\"toc_%.*s\"></a>\n    "
argument_list|,
name|p
operator|-
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Insert link -- to an external file if splitting, or              within the current document if not splitting.  */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<a href=\"%s#%s</a>\n"
argument_list|,
name|splitting
condition|?
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|html_file
else|:
literal|""
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|last_level
operator|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
expr_stmt|;
block|}
comment|/* Go back to start level. */
if|if
condition|(
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
operator|<
name|last_level
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|last_level
operator|-
name|toc_entry_alist
index|[
literal|0
index|]
operator|->
name|level
operator|)
condition|;
name|k
operator|++
control|)
name|fputs
argument_list|(
literal|"</ul>\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"</ul>\n\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print table of contents in ASCII (--no-headers)    May be we should create a new command line switch --ascii ? */
end_comment

begin_function
specifier|static
name|void
name|contents_update_info
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case we are writing stdout */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n%.*s\n\n"
argument_list|,
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|_
argument_list|(
literal|"Table of Contents"
argument_list|)
argument_list|)
argument_list|,
name|lots_of_stars
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* indention with two spaces per level, should this          changed? */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
condition|;
name|k
operator|++
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shortcontents in HTML; Should this produce a standalone file? */
end_comment

begin_function
specifier|static
name|void
name|shortcontents_update_html
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|toc_file
decl_stmt|;
comment|/* does exist any toc? */
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case we are writing stdout */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n<h2>%s</h2>\n<ul>\n"
argument_list|,
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents_filename
condition|)
name|toc_file
operator|=
name|filename_part
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|contents_filename
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<li><a href=\"%s#toc_%s</a>\n"
argument_list|,
name|splitting
condition|?
name|toc_file
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<a href=\"%s#%s</a>\n"
argument_list|,
name|splitting
condition|?
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|html_file
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"</ul>\n\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents_filename
condition|)
name|free
argument_list|(
name|toc_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* short contents in ASCII (--no-headers).  */
end_comment

begin_function
specifier|static
name|void
name|shortcontents_update_info
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|toc_counter
condition|)
return|return;
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case we are writing stdout */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n%.*s\n\n"
argument_list|,
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|_
argument_list|(
literal|"Short Contents"
argument_list|)
argument_list|)
argument_list|,
name|lots_of_stars
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc_counter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|level
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|toc_entry_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|toc_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|toc_buf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rewrite_top
parameter_list|(
name|fname
parameter_list|,
name|placebo
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|,
decl|*
name|placebo
decl_stmt|;
end_function

begin_block
block|{
name|int
name|idx
decl_stmt|;
comment|/* Can't rewrite standard output or the null device.  No point in      complaining.  */
if|if
condition|(
name|STREQ
argument_list|(
name|fname
argument_list|,
literal|"-"
argument_list|)
operator|||
name|FILENAME_CMP
argument_list|(
name|fname
argument_list|,
name|NULL_DEVICE
argument_list|)
operator|==
literal|0
operator|||
name|FILENAME_CMP
argument_list|(
name|fname
argument_list|,
name|ALSO_NULL_DEVICE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|toc_buf
operator|=
name|find_and_load
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toc_buf
condition|)
block|{
name|fs_error
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|idx
operator|=
name|search_forward
argument_list|(
name|placebo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: TOC should be here, but it was not found"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|toc_fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toc_fp
condition|)
block|{
name|fs_error
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|toc_buf
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|,
name|toc_fp
argument_list|)
operator|!=
name|idx
condition|)
block|{
name|fs_error
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|idx
operator|+
name|strlen
argument_list|(
name|placebo
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|contents_update
parameter_list|()
block|{
name|int
name|cont_idx
init|=
name|rewrite_top
argument_list|(
name|contents_filename
argument_list|,
name|contents_placebo
argument_list|)
decl_stmt|;
if|if
condition|(
name|cont_idx
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|html
condition|)
name|contents_update_html
argument_list|(
name|toc_fp
argument_list|)
expr_stmt|;
else|else
name|contents_update_info
argument_list|(
name|toc_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|toc_buf
operator|+
name|cont_idx
argument_list|,
literal|1
argument_list|,
name|input_text_length
operator|-
name|cont_idx
argument_list|,
name|toc_fp
argument_list|)
operator|!=
name|input_text_length
operator|-
name|cont_idx
operator|||
name|fclose
argument_list|(
name|toc_fp
argument_list|)
operator|!=
literal|0
condition|)
name|fs_error
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shortcontents_update
parameter_list|()
block|{
name|int
name|cont_idx
init|=
name|rewrite_top
argument_list|(
name|shortcontents_filename
argument_list|,
name|shortcontents_placebo
argument_list|)
decl_stmt|;
if|if
condition|(
name|cont_idx
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|html
condition|)
name|shortcontents_update_html
argument_list|(
name|toc_fp
argument_list|)
expr_stmt|;
else|else
name|shortcontents_update_info
argument_list|(
name|toc_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|toc_buf
operator|+
name|cont_idx
argument_list|,
literal|1
argument_list|,
name|input_text_length
operator|-
name|cont_idx
operator|-
literal|1
argument_list|,
name|toc_fp
argument_list|)
operator|!=
name|input_text_length
operator|-
name|cont_idx
operator|-
literal|1
operator|||
name|fclose
argument_list|(
name|toc_fp
argument_list|)
operator|!=
literal|0
condition|)
name|fs_error
argument_list|(
name|shortcontents_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|toc_update
parameter_list|()
block|{
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|no_headers
condition|)
return|return;
if|if
condition|(
name|contents_filename
condition|)
name|contents_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|shortcontents_filename
condition|)
name|shortcontents_update
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_contents
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|html
operator|||
name|no_headers
operator|)
operator|&&
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|contents_filename
condition|)
block|{
name|free
argument_list|(
name|contents_filename
argument_list|)
expr_stmt|;
name|contents_filename
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|contents_filename
operator|&&
name|STREQ
argument_list|(
name|contents_filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|contents_update_html
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|else
name|contents_update_info
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|executing_string
operator|&&
name|html
condition|)
name|html_output_head
argument_list|()
expr_stmt|;
name|contents_filename
operator|=
name|xstrdup
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|contents_placebo
argument_list|)
expr_stmt|;
comment|/* just mark it, for now */
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_shortcontents
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|html
operator|||
name|no_headers
operator|)
operator|&&
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|shortcontents_filename
condition|)
block|{
name|free
argument_list|(
name|shortcontents_filename
argument_list|)
expr_stmt|;
name|shortcontents_filename
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|shortcontents_filename
operator|&&
name|STREQ
argument_list|(
name|shortcontents_filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|shortcontents_update_html
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|else
name|shortcontents_update_info
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|executing_string
operator|&&
name|html
condition|)
name|html_output_head
argument_list|()
expr_stmt|;
name|shortcontents_filename
operator|=
name|xstrdup
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|shortcontents_placebo
argument_list|)
expr_stmt|;
comment|/* just mark it, for now */
block|}
block|}
block|}
end_function

end_unit

